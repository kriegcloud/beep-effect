#!/usr/bin/env node
import nodeFs from "node:fs";
import nodePath from "node:path";
import { FsUtilsLive } from "@beep/tooling-utils/FsUtils";
import { DomainError, getWorkspaceDir } from "@beep/tooling-utils/repo";
import * as FileSystem from "@effect/platform/FileSystem";
import * as Path from "@effect/platform/Path";
import * as NodeContext from "@effect/platform-node/NodeContext";
import * as NodeRuntime from "@effect/platform-node/NodeRuntime";
import * as Cause from "effect/Cause";
import * as Console from "effect/Console";
import * as Effect from "effect/Effect";
import { TreeFormatter } from "effect/ParseResult";
import * as S from "effect/Schema";
import { AssetPaths } from "./utils";
import { convertDirectoryToNextgen } from "./utils/convert-to-nextgen";

/**
 * Recursively collect all files under a directory.
 */
function collectFiles(dir: string, baseDir: string = dir): string[] {
  const entries = nodeFs.readdirSync(dir, { withFileTypes: true });
  return entries.flatMap((entry) => {
    const fullPath = nodePath.join(dir, entry.name);
    if (entry.isDirectory()) {
      return collectFiles(fullPath, baseDir);
    }
    // Return path relative to PUBLIC_DIR and prefix with "/"
    return ["/" + nodePath.relative(baseDir, fullPath).replace(/\\/g, "/")];
  });
}

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem;
  const path = yield* Path.Path;
  const webDir = yield* getWorkspaceDir("@beep/web");
  yield* Console.log("WEB DIR: ", webDir);

  const publicDir = path.resolve(webDir, "public");
  yield* Console.log("PUBLIC DIR: ", publicDir);

  if (!(yield* fs.exists(publicDir))) {
    return yield* new DomainError({
      message: `publicDir: ${publicDir} does not exist in file system`,
    });
  }

  const conversions = yield* convertDirectoryToNextgen({ dir: publicDir });
  if (conversions.length > 0) {
    yield* Console.log("Converted assets:", JSON.stringify(conversions, null, 2));
  }

  const constantsDir = yield* getWorkspaceDir("@beep/constants");
  yield* Console.log("CONSTANTS DIR: ", constantsDir);

  const assetPathsFile = path.join(constantsDir, "src", "paths", "generated", "asset-paths.ts");

  yield* Console.log("ASSET PATHS FILE: ", assetPathsFile);
  if (!(yield* fs.exists(assetPathsFile))) {
    return yield* new DomainError({
      message: `assetPathsFile: ${assetPathsFile} does not exist in file system`,
    });
  }

  const collectedFiles = collectFiles(publicDir);

  const files = yield* S.decodeUnknown(AssetPaths)(collectedFiles).pipe(
    Effect.mapError(
      (error) =>
        new DomainError({
          message: `Invalid asset paths detected: ${TreeFormatter.formatErrorSync(error)}`,
          cause: error,
        })
    )
  );

  yield* Console.log("FILES: ", JSON.stringify(files, null, 2));

  const content = `// Auto-generated by tooling/repo-scripts/src/generate-asset-paths.ts
// Do not edit manually.

export const publicPaths = ${JSON.stringify(files, null, 2)} as const;
`;

  yield* fs.writeFileString(assetPathsFile, content);
}).pipe(
  Effect.provide([NodeContext.layer, FsUtilsLive]),
  Effect.catchAll((error) =>
    Effect.gen(function* () {
      const msg = String(error);
      yield* Console.log(`\nğŸ’¥ Program failed: ${msg}`);
      const cause = Cause.fail(error);
      yield* Console.log(`\nğŸ” Error details: ${Cause.pretty(cause)}`);
      return yield* Effect.fail(error);
    })
  )
);

NodeRuntime.runMain(program);
