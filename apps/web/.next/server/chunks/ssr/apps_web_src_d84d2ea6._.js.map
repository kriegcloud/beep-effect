{"version":3,"sources":["turbopack:///[project]/apps/web/src/features/upload/view.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/node_modules/exifreader/src/byte-order.js","turbopack:///[project]/apps/web/src/features/upload/errors.ts","turbopack:///[project]/node_modules/exifreader/src/errors.js","turbopack:///[project]/packages/files/domain/src/value-objects/exif-metadata/ExifTags.ts","turbopack:///[project]/packages/common/errors/src/client.ts","turbopack:///[project]/packages/files/domain/src/value-objects/file-types/typeChecker.ts","turbopack:///[project]/node_modules/exifreader/src/image-header-iso-bmff-utils.js","turbopack:///[project]/node_modules/exifreader/src/xmp-namespaces.js","turbopack:///[project]/node_modules/exifreader/src/dataview.js","turbopack:///[project]/packages/files/domain/src/value-objects/file-types/FileSignature.ts","turbopack:///[project]/packages/files/domain/src/value-objects/exif-metadata/ExifMetadata.ts","turbopack:///[project]/packages/files/domain/src/value-objects/file-types/utils.ts","turbopack:///[project]/apps/web/src/features/upload/observability.ts","turbopack:///[project]/packages/files/domain/src/errors.ts","turbopack:///[project]/node_modules/exifreader/src/image-header-iso-bmff-iloc.js","turbopack:///[project]/packages/files/domain/src/value-objects/FileInstance.ts","turbopack:///[project]/apps/web/src/app/upload/page.tsx","turbopack:///[project]/packages/files/domain/src/value-objects/FileAttributes.ts","turbopack:///[project]/packages/files/domain/src/utils/readFileArrayBuffer.ts","turbopack:///[project]/node_modules/exifreader/src/tag-names-utils.js","turbopack:///[project]/node_modules/exifreader/src/dom-parser.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-common.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-canon-ifd.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-pentax-ifd.js","turbopack:///[project]/node_modules/exifreader/src/text-decoder.js","turbopack:///[project]/node_modules/exifreader/src/constants.js","turbopack:///[project]/apps/web/src/features/upload/index.ts","turbopack:///[project]/node_modules/exifreader/src/image-header-iso-bmff.js","turbopack:///[project]/packages/files/domain/src/value-objects/file-types/FileInfo.ts","turbopack:///[project]/node_modules/effect/src/MetricBoundaries.ts","turbopack:///[project]/node_modules/exifreader/src/thumbnail.js","turbopack:///[project]/node_modules/exifreader/src/types.js","turbopack:///[project]/node_modules/exifreader/src/tag-decoder.js","turbopack:///[project]/node_modules/exifreader/src/composite.js","turbopack:///[project]/node_modules/exifreader/src/utils.js","turbopack:///[project]/node_modules/exifreader/src/icc-tag-names.js","turbopack:///[project]/node_modules/exifreader/src/png-file-tags.js","turbopack:///[project]/node_modules/exifreader/src/vp8x-tags.js","turbopack:///[project]/node_modules/exifreader/src/iptc-tag-names.js","turbopack:///[project]/node_modules/exifreader/src/image-header-heic.js","turbopack:///[project]/node_modules/exifreader/src/image-header-gif.js","turbopack:///[project]/node_modules/exifreader/src/xml.js","turbopack:///[project]/node_modules/exifreader/src/file-tags.js","turbopack:///[project]/node_modules/exifreader/src/jfif-tags.js","turbopack:///[project]/node_modules/exifreader/src/xmp-tag-names.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-0th-ifd.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-gps-ifd.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-interoperability-ifd.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-mpf-ifd.js","turbopack:///[project]/node_modules/exifreader/src/icc-tags.js","turbopack:///[project]/node_modules/exifreader/src/iptc-tags.js","turbopack:///[project]/packages/files/domain/src/value-objects/FileSize.ts","turbopack:///[project]/node_modules/exifreader/src/image-header-webp.js","turbopack:///[project]/node_modules/exifreader/src/image-header-tiff.js","turbopack:///[project]/node_modules/exifreader/src/image-header-jpeg.js","turbopack:///[project]/node_modules/exifreader/src/tag-names-exif-ifd.js","turbopack:///[project]/node_modules/exifreader/src/tags-helpers.js","turbopack:///[project]/node_modules/exifreader/src/png-tags.js","turbopack:///[project]/node_modules/exifreader/src/tags.js","turbopack:///[project]/node_modules/exifreader/src/image-header-png.js","turbopack:///[project]/node_modules/exifreader/src/xmp-tags.js","turbopack:///[project]/node_modules/exifreader/src/gif-file-tags.js","turbopack:///[project]/node_modules/exifreader/src/image-header-avif.js","turbopack:///[project]/apps/web/src/features/upload/UploadFileService.ts","turbopack:///[project]/node_modules/exifreader/src/photoshop-tags.js","turbopack:///[project]/node_modules/exifreader/src/mpf-tags.js","turbopack:///[project]/apps/web/src/features/upload/pipeline.ts","turbopack:///[project]/packages/files/domain/src/utils/formatSize.ts","turbopack:///[project]/node_modules/exifreader/src/png-text-tags.js","turbopack:///[project]/node_modules/exifreader/src/pentax-tags.js","turbopack:///[project]/node_modules/exifreader/src/tag-names.js","turbopack:///[project]/packages/files/domain/src/value-objects/file-types/detection.ts","turbopack:///[project]/node_modules/exifreader/src/canon-tags.js","turbopack:///[project]/node_modules/exifreader/src/image-header.js","turbopack:///[project]/packages/files/domain/src/value-objects/file-types/FileTypes.ts","turbopack:///[project]/node_modules/exifreader/src/photoshop-tag-names.js","turbopack:///[project]/node_modules/exifreader/src/exif-reader.js","turbopack:///[project]/apps/web/src/features/upload/UploadModels.ts"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const View = registerClientReference(\n    function() { throw new Error(\"Attempted to call View() from the server but View is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/src/features/upload/view.tsx\",\n    \"View\",\n);\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nconst LITTLE_ENDIAN = 0x4949;\nconst BIG_ENDIAN = 0x4d4d;\n\nexport default {\n    BIG_ENDIAN,\n    LITTLE_ENDIAN,\n    getByteOrder\n};\n\nfunction getByteOrder(dataView, tiffHeaderOffset) {\n    if (dataView.getUint16(tiffHeaderOffset) === LITTLE_ENDIAN) {\n        return LITTLE_ENDIAN;\n    } else if (dataView.getUint16(tiffHeaderOffset) === BIG_ENDIAN) {\n        return BIG_ENDIAN;\n    }\n    throw new Error('Illegal byte order value. Faulty image.');\n}\n","import * as Data from \"effect/Data\";\n\nexport class ValidationError extends Data.TaggedError(\"ValidationError\")<{\n  readonly message: string;\n  readonly cause?: unknown;\n  readonly fileName?: string;\n  readonly fileType?: string;\n  readonly fileSize?: number;\n  readonly candidateMime?: string;\n  readonly allowedMime?: ReadonlyArray<string>;\n}> {}\n\nexport class DetectionError extends Data.TaggedError(\"DetectionError\")<{\n  readonly message: string;\n  readonly cause?: unknown;\n  readonly fileName?: string;\n  readonly fileType?: string;\n  readonly fileSize?: number;\n  readonly chunkSize?: number;\n}> {}\n\nexport class ExifParseError extends Data.TaggedError(\"ExifParseError\")<{\n  readonly message: string;\n  readonly cause: unknown;\n  readonly fileName?: string;\n  readonly fileType?: string;\n  readonly fileSize?: number;\n  readonly phase?: \"read\" | \"parse\" | \"decode\";\n}> {}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n/**\n * Thrown when no Exif metadata was found for the given image.\n *\n * @param {string} message The error message.\n */\nfunction MetadataMissingError(message) {\n    this.name = 'MetadataMissingError';\n    this.message = message || 'No Exif data';\n    this.stack = (new Error()).stack;\n}\n\nMetadataMissingError.prototype = new Error;\n\nexport default {\n    MetadataMissingError,\n};\n","import { BS } from \"@beep/schema\";\n\nimport * as S from \"effect/Schema\";\n\n// Base tag types\nconst NumberFileTag = BS.Struct({\n  description: S.String,\n  value: S.Number,\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/NumberFileTag\"),\n  identifier: \"NumberFileTag\",\n  title: \"Number File Tag\",\n  description: \"EXIF tag with a numeric value and a human-readable description.\",\n});\n\nconst NumberArrayFileTag = BS.Struct({\n  description: S.String,\n  value: S.Array(S.Number),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/NumberArrayFileTag\"),\n  identifier: \"NumberArrayFileTag\",\n  title: \"Number Array File Tag\",\n  description: \"EXIF tag with an array of numbers (e.g., resolutions, coordinates).\",\n});\n\nconst NumberArray2DFileTag = BS.Struct({\n  description: S.String,\n  value: S.Union(S.Array(S.Number), S.Array(S.Array(S.Number))),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/NumberArray2DFileTag\"),\n  identifier: \"NumberArray2DFileTag\",\n  title: \"Number Array 2D File Tag\",\n  description: \"EXIF tag with a 1D or 2D array of numbers (e.g., chroma subsampling).\",\n});\n\n/**\n * Create a typed EXIF tag schema with a uniform shape `{ id, description, value }`.\n *\n * - `id`: numeric tag identifier as reported by EXIF/JFIF/PNG/XMP readers\n * - `description`: human-friendly string (or numeric code from source)\n * - `value`: the strongly-typed payload for this tag (e.g., number, string, tuple)\n */\nconst makeTypedTag = <A, I, R>(schema: S.Schema<A, I, R>) =>\n  BS.Struct({\n    id: S.Number,\n    description: S.Union(S.String, S.Number),\n    value: schema,\n  });\n\nconst RationalTag = makeTypedTag(S.Tuple(S.Number, S.Number)).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/RationalTag\"),\n  identifier: \"RationalTag\",\n  title: \"Rational Tag\",\n  description: \"Typed EXIF tag whose value is a rational tuple [numerator, denominator] (e.g., shutter speed).\",\n});\nconst NumberTag = makeTypedTag(S.Number).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/NumberTag\"),\n  identifier: \"NumberTag\",\n  title: \"Number Tag\",\n  description: \"Typed EXIF tag with numeric value.\",\n});\nconst NumberArrayTag = makeTypedTag(S.Array(S.Number)).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/NumberArrayTag\"),\n  identifier: \"NumberArrayTag\",\n  title: \"Number Array Tag\",\n  description: \"Typed EXIF tag with array of numbers.\",\n});\nconst StringArrayTag = makeTypedTag(S.Array(S.String)).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/StringArrayTag\"),\n  identifier: \"StringArrayTag\",\n  title: \"String Array Tag\",\n  description: \"Typed EXIF tag with array of strings.\",\n});\nconst StringTag = makeTypedTag(S.String).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/StringTag\"),\n  identifier: \"StringTag\",\n  title: \"String Tag\",\n  description: \"Typed EXIF tag with string value.\",\n});\n\nconst ValueTag = BS.Struct({\n  description: S.String,\n  value: S.Union(S.String, S.Number),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/ValueTag\"),\n  identifier: \"ValueTag\",\n  title: \"Value Tag\",\n  description: \"Generic EXIF tag with a string or numeric value.\",\n});\n\n// File types\nconst FileTypeTag = BS.Struct({\n  value: S.Literal(\"tiff\", \"jpeg\", \"png\", \"heic\", \"avif\", \"webp\", \"gif\"),\n  description: S.Literal(\"TIFF\", \"JPEG\", \"PNG\", \"HEIC\", \"AVIF\", \"WebP\", \"GIF\"),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/FileTypeTag\"),\n  identifier: \"FileTypeTag\",\n  title: \"File Type Tag\",\n  description: \"File container/codec identification reported by the reader.\",\n});\n\nconst FileTags = BS.Struct({\n  fileType: S.optional(S.Union(FileTypeTag, S.Literal(\"TIFF\", \"JPEG\", \"PNG\", \"HEIC\", \"AVIF\", \"WebP\", \"GIF\"))).pipe(\n    S.fromKey(\"FileType\")\n  ),\n  bitsPerSample: S.optional(NumberFileTag).pipe(S.fromKey(\"Bits Per Sample\")),\n  height: S.optional(NumberFileTag).pipe(S.fromKey(\"Image Height\")),\n  width: S.optional(NumberFileTag).pipe(S.fromKey(\"Image Width\")),\n  colorComponents: S.optional(NumberFileTag).pipe(S.fromKey(\"Color Components\")),\n  subsampling: S.optional(NumberArray2DFileTag).pipe(S.fromKey(\"Subsampling\")),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/FileTags\"),\n  identifier: \"FileTags\",\n  title: \"File Tags\",\n  description: \"Basic file-level properties from container headers (dimensions, bit depth, subsampling, etc.).\",\n});\n\n// JFIF tags\nconst JfifResolutionUnitTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"None\", \"inches\", \"cm\", \"Unknown\"),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/JfifResolutionUnitTag\"),\n  identifier: \"JfifResolutionUnitTag\",\n  title: \"Jfif Resolution Unit Tag\",\n  description: \"Resolution unit for JFIF (e.g., inches for DPI, centimeters for DPCM).\",\n});\n\nconst JfifThumbnailTag = BS.Struct({\n  value: S.Union(S.instanceOf(ArrayBuffer), S.instanceOf(SharedArrayBuffer), S.instanceOf(Buffer)),\n  description: S.Literal(\"<24-bit RGB pixel data>\"),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/JfifThumbnailTag\"),\n  identifier: \"JfifThumbnailTag\",\n  title: \"Jfif Thumbnail Tag\",\n  description: \"Embedded JFIF thumbnail or raw RGB pixel data from the container.\",\n});\n\nconst JfifTags = BS.Struct({\n  jfifVersion: S.optional(NumberFileTag).pipe(S.fromKey(\"JFIF Version\")),\n  resolutionUnit: S.optional(JfifResolutionUnitTag).pipe(S.fromKey(\"Resolution Unit\")),\n  xResolution: S.optional(NumberFileTag).pipe(S.fromKey(\"XResolution\")),\n  yResolution: S.optional(NumberFileTag).pipe(S.fromKey(\"YResolution\")),\n  jfifThumbnailWidth: S.optional(NumberFileTag).pipe(S.fromKey(\"JFIF Thumbnail Width\")),\n  jfifThumbnailHeight: S.optional(NumberFileTag).pipe(S.fromKey(\"JFIF Thumbnail Height\")),\n  jfifThumbnail: S.optional(JfifThumbnailTag).pipe(S.fromKey(\"JFIF Thumbnail\")),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/JfifTags\"),\n  identifier: \"JfifTags\",\n  title: \"JFIF Tags\",\n  description: \"JFIF segment fields including resolution and embedded thumbnail metadata.\",\n});\n\n// PNG tags\nconst PngColorTypeTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"Grayscale\", \"RGB\", \"Palette\", \"Grayscale with Alpha\", \"RGB with Alpha\", \"Unknown\"),\n});\n\nconst PngCompressionTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"Deflate/Inflate\", \"Unknown\"),\n});\n\nconst PngFilterTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"Adaptive\", \"Unknown\"),\n});\n\nconst PngInterlaceTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"Noninterlaced\", \"Adam7 Interlace\", \"Unknown\"),\n});\n\nconst PngFileTags = BS.Struct({\n  imageWidth: S.optional(NumberFileTag).pipe(S.fromKey(\"Image Width\")),\n  imageHeight: S.optional(NumberFileTag).pipe(S.fromKey(\"Image Height\")),\n  bitDepth: S.optional(NumberFileTag).pipe(S.fromKey(\"Bit Depth\")),\n  colorType: S.optional(PngColorTypeTag).pipe(S.fromKey(\"Color Type\")),\n  compression: S.optional(PngCompressionTag).pipe(S.fromKey(\"Compression\")),\n  filter: S.optional(PngFilterTag).pipe(S.fromKey(\"Filter\")),\n  interlace: S.optional(PngInterlaceTag).pipe(S.fromKey(\"Interlace\")),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PngFileTags\"),\n  identifier: \"PngFileTags\",\n  title: \"PNG File Tags\",\n  description: \"IHDR-level PNG properties: dimensions, bit depth, color type, compression, filter, and interlace.\",\n});\n\nconst PngPixelUnitsTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"meters\", \"Unknown\"),\n});\n\nconst PngPhysTags = BS.Struct({\n  pixelsPerUnitX: S.optional(NumberFileTag).pipe(S.fromKey(\"Pixels Per Unit X\")),\n  pixelsPerUnitY: S.optional(NumberFileTag).pipe(S.fromKey(\"Pixels Per Unit Y\")),\n  pixelUnits: S.optional(PngPixelUnitsTag).pipe(S.fromKey(\"Pixel Units\")),\n  modifyDate: S.optional(NumberArrayFileTag).pipe(S.fromKey(\"Modify Date\")),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PngPhysTags\"),\n  identifier: \"PngPhysTags\",\n  title: \"PNG Physical Pixel Tags\",\n  description: \"pHYs chunk-derived physical pixel density and units.\",\n});\n// NumberArrayFileTag | undefined' i\nconst PngTag = BS.Struct({\n  description: S.String,\n  value: S.Union(S.String, S.Number),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PngTag\"),\n  identifier: \"PngTag\",\n  title: \"PNG Tag\",\n  description: \"Generic PNG tag with a textual description and a string or numeric value.\",\n});\n\nconst PngTags = BS.Struct(\n  {\n    ...PngFileTags.fields,\n    ...PngPhysTags.fields,\n  },\n  S.Record({ key: S.String, value: PngTag })\n).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PngTags\"),\n  identifier: \"PngTags\",\n  title: \"PNG Tags\",\n  description: \"Aggregate PNG metadata combining IHDR/pHYs fields and arbitrary tag map.\",\n});\n\nconst PngTextTag = BS.Struct({\n  description: S.String,\n  value: S.String,\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PngTextTag\"),\n  identifier: \"PngTextTag\",\n  title: \"PNG Text Tag\",\n  description: \"PNG textual metadata entry (tEXt/zTXt/iTXt).\",\n});\n\nconst PngTextTags = S.Record({ key: S.String, value: PngTextTag }).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PngTextTags\"),\n  identifier: \"PngTextTags\",\n  title: \"PNG Text Tags\",\n  description: \"Map of PNG textual metadata entries.\",\n});\n\n// RIFF tags\nconst RiffAlphaTag = BS.Struct({\n  value: S.Literal(0, 1),\n  description: S.Literal(\"No\", \"Yes\"),\n});\n\nconst RiffAnimationTag = BS.Struct({\n  value: S.Literal(0, 1),\n  description: S.Literal(\"No\", \"Yes\"),\n});\n\nconst RiffImageDimensionTag = BS.Struct({\n  value: S.Number,\n  description: S.String,\n});\n\nconst RiffTags = BS.Struct({\n  alpha: S.optional(RiffAlphaTag).pipe(S.fromKey(\"Alpha\")),\n  animation: S.optional(RiffAnimationTag).pipe(S.fromKey(\"Animation\")),\n  imageWidth: S.optional(RiffImageDimensionTag).pipe(S.fromKey(\"ImageWidth\")),\n  imageHeight: S.optional(RiffImageDimensionTag).pipe(S.fromKey(\"ImageHeight\")),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/RiffTags\"),\n  identifier: \"RiffTags\",\n  title: \"RIFF/WEBP Tags\",\n  description: \"Basic WEBP/RIFF properties such as alpha, animation, and dimensions.\",\n});\n\n// GIF tags\nconst GifVersionTag = BS.Struct({\n  value: S.Literal(\"87a\", \"89a\"),\n  description: S.Literal(\"87a\", \"89a\"),\n});\n\nconst GifBooleanTag = BS.Struct({\n  value: S.Literal(0, 1),\n  description: S.Literal(\"No\", \"Yes\"),\n});\n\nconst GifDimensionTag = BS.Struct({\n  value: S.Number,\n  description: S.String,\n});\n\nconst GifBitsTag = BS.Struct({\n  value: S.Literal(1, 2, 3, 4, 5, 6, 7, 8),\n  description: S.String,\n});\n\nconst GifTags = BS.Struct({\n  gifVersion: GifVersionTag.pipe(S.propertySignature, S.fromKey(\"GIF Version\")),\n  imageWidth: S.optional(GifDimensionTag).pipe(S.fromKey(\"Image Width\")),\n  imageHeight: S.optional(GifDimensionTag).pipe(S.fromKey(\"Image Height\")),\n  globalColorMap: S.optional(GifBooleanTag).pipe(S.fromKey(\"Global Color Map\")),\n  bitsPerPixel: S.optional(GifBitsTag).pipe(S.fromKey(\"Bits Per Pixel\")),\n  colorResolutionDepth: S.optional(GifBitsTag).pipe(S.fromKey(\"Color Resolution Depth\")),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/GifTags\"),\n  identifier: \"GifTags\",\n  title: \"GIF Tags\",\n  description: \"Core GIF header and logical screen descriptor fields.\",\n});\n\n// XMP tags (recursive)\nexport interface IXmpTag {\n  value: string | ReadonlyArray<IXmpTag> | Record<string, IXmpTag>;\n  attributes: {\n    [name: string]: string;\n  };\n  description: string;\n}\n\nconst XmpTag = BS.Struct({\n  value: S.Union(\n    S.String,\n    S.Array(S.suspend((): S.Schema<IXmpTag> => XmpTag)),\n    S.Record({\n      key: S.String,\n      value: S.suspend((): S.Schema<IXmpTag> => XmpTag),\n    })\n  ),\n  attributes: S.Record({\n    key: S.String,\n    value: S.String,\n  }),\n  description: S.String,\n});\n\nconst XmpTags = S.Record({ key: S.String, value: XmpTag }).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/XmpTags\"),\n  identifier: \"XmpTags\",\n  title: \"XMP Tags\",\n  description: \"Recursive map of XMP metadata entries (namespaced XML properties).\",\n});\n\n// GPS tags\nconst GpsTags = BS.Struct({\n  Latitude: S.optional(S.Number),\n  Longitude: S.optional(S.Number),\n  Altitude: S.optional(S.Number),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/GpsTags\"),\n  identifier: \"GpsTags\",\n  title: \"GPS Tags\",\n  description: \"Simplified GPS coordinate values in decimal degrees and altitude in meters (if present).\",\n});\n\n// MPF Image tags\nconst MPFImageFlags = BS.Struct({\n  value: S.Array(S.Number),\n  description: S.String,\n});\n\nconst MPFImageDescriptionTag = BS.Struct({\n  value: S.Number,\n  description: S.String,\n});\n\nconst MPFImageTags = BS.Struct({\n  ImageFlags: MPFImageFlags,\n  ImageFormat: MPFImageDescriptionTag,\n  ImageType: MPFImageDescriptionTag,\n  ImageSize: MPFImageDescriptionTag,\n  ImageOffset: MPFImageDescriptionTag,\n  DependentImage1EntryNumber: MPFImageDescriptionTag,\n  DependentImage2EntryNumber: MPFImageDescriptionTag,\n  image: S.Union(S.instanceOf(ArrayBuffer), S.instanceOf(SharedArrayBuffer), S.instanceOf(Buffer)),\n  base64: S.String,\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/MPFImageTags\"),\n  identifier: \"MPFImageTags\",\n  title: \"MPF Image Tags\",\n  description: \"Multi-Picture Format (MPF) entries for burst/live-photo auxiliary images.\",\n});\n\n// Photoshop tags\nconst PhotoshopTags = BS.Struct({\n  PathInformation: S.optional(StringTag),\n  ClippingPathName: S.optional(StringTag),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PhotoshopTags\"),\n  identifier: \"PhotoshopTags\",\n  title: \"Photoshop Tags\",\n  description: \"Subset of Photoshop-specific metadata embedded in images.\",\n});\n\n// Canon tags\nconst CanonAutoRotateTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\"None\", \"Rotate 90 CW\", \"Rotate 180\", \"Rotate 270 CW\", \"Unknown\"),\n});\n\nconst CanonTags = BS.Struct({\n  AutoRotate: S.optional(CanonAutoRotateTag),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/CanonTags\"),\n  identifier: \"CanonTags\",\n  title: \"Canon Maker Notes\",\n  description: \"Common Canon-specific maker notes.\",\n});\n\n// Pentax tags\nconst PentaxVersionTag = BS.Struct({\n  value: S.Array(S.Number),\n  description: S.String,\n});\n\nconst PentaxModelIdTag = BS.Struct({\n  value: S.Number,\n  description: S.String,\n});\n\nconst PentaxOrientationTag = BS.Struct({\n  value: S.Number,\n  description: S.Literal(\n    \"Horizontal (normal)\",\n    \"Rotate 270 CW\",\n    \"Rotate 180\",\n    \"Rotate 90 CW\",\n    \"Upwards\",\n    \"Downwards\",\n    \"Unknown\"\n  ),\n});\n\nconst PentaxAngleTag = BS.Struct({\n  value: S.Number,\n  description: S.String,\n});\n\nconst PentaxTags = BS.Struct({\n  PentaxVersion: S.optional(PentaxVersionTag),\n  PentaxModelID: S.optional(PentaxModelIdTag),\n  Orientation: S.optional(PentaxOrientationTag),\n  RollAngle: S.optional(PentaxAngleTag),\n  PitchAngle: S.optional(PentaxAngleTag),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/PentaxTags\"),\n  identifier: \"PentaxTags\",\n  title: \"Pentax Maker Notes\",\n  description: \"Common Pentax-specific maker notes (orientation, roll/pitch).\",\n});\n\n// Composite tags\nconst CompositeValueTag = BS.Struct({\n  value: S.Number,\n  description: S.String,\n});\n\nconst CompositeTags = BS.Struct({\n  FocalLength35efl: S.optional(CompositeValueTag),\n  ScaleFactorTo35mmEquivalent: S.optional(CompositeValueTag),\n  FieldOfView: S.optional(CompositeValueTag),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/CompositeTags\"),\n  identifier: \"CompositeTags\",\n  title: \"Composite Tags\",\n  description: \"Calculated/composite properties derived from primary EXIF fields.\",\n});\n\n// Thumbnail tags\nconst ThumbnailTags = BS.Struct({\n  type: S.Literal(\"image/jpeg\"),\n  image: S.Union(S.instanceOf(ArrayBuffer), S.instanceOf(SharedArrayBuffer), S.instanceOf(Buffer)),\n  base64: S.optional(S.String),\n  Compression: S.optional(NumberTag),\n  XResolution: S.optional(RationalTag),\n  YResolution: S.optional(RationalTag),\n  ResolutionUnit: S.optional(NumberTag),\n  JPEGInterchangeFormat: S.optional(NumberTag),\n  JPEGInterchangeFormatLength: S.optional(NumberTag),\n  ImageWidth: S.optional(NumberTag),\n  ImageLength: S.optional(NumberTag),\n  YCbCrPositioning: S.optional(NumberTag),\n  Orientation: S.optional(NumberTag),\n  PhotometricInterpretation: S.optional(NumberTag),\n  StripOffsets: S.optional(NumberArrayTag),\n  SamplesPerPixel: S.optional(NumberTag),\n  RowsPerStrip: S.optional(NumberTag),\n  StripByteCounts: S.optional(NumberArrayTag),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/ThumbnailTags\"),\n  identifier: \"ThumbnailTags\",\n  title: \"Thumbnail Tags\",\n  description: \"Embedded thumbnail metadata and pixel data (image/base64 may be removed by cleaners).\",\n});\n\n// ICC tags\nconst IccTags = S.Record({ key: S.String, value: ValueTag }).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/IccTags\"),\n  identifier: \"IccTags\",\n  title: \"ICC Profile Tags\",\n  description: \"ICC color profile key-value entries. Large binary fields may be cleaned by utilities.\",\n});\n\n// Main EXIF tags\nexport const ExifTags = BS.Struct({\n  // Interoperability tags\n  interoperabilityIndex: S.optional(StringArrayTag).pipe(S.fromKey(\"InteroperabilityIndex\")),\n\n  // 0th IFD tags\n  imageWidth: S.optional(NumberTag).pipe(S.fromKey(\"ImageWidth\")),\n  imageLength: S.optional(NumberTag).pipe(S.fromKey(\"ImageLength\")),\n  bitsPerSample: S.optional(NumberArrayTag).pipe(S.fromKey(\"BitsPerSample\")),\n  compression: S.optional(NumberTag).pipe(S.fromKey(\"Compression\")),\n  photometricInterpretation: S.optional(NumberTag).pipe(S.fromKey(\"PhotometricInterpretation\")),\n  documentName: S.optional(StringArrayTag).pipe(S.fromKey(\"DocumentName\")),\n  imageDescription: S.optional(StringArrayTag).pipe(S.fromKey(\"ImageDescription\")),\n  make: S.optional(StringArrayTag).pipe(S.fromKey(\"Make\")),\n  model: S.optional(StringArrayTag).pipe(S.fromKey(\"Model\")),\n  stripOffsets: S.optional(NumberArrayTag).pipe(S.fromKey(\"StripOffsets\")),\n  orientation: S.optional(NumberTag).pipe(S.fromKey(\"Orientation\")),\n  samplesPerPixel: S.optional(NumberTag).pipe(S.fromKey(\"SamplesPerPixel\")),\n  rowsPerStrip: S.optional(NumberTag).pipe(S.fromKey(\"RowsPerStrip\")),\n  stripByteCounts: S.optional(NumberArrayTag).pipe(S.fromKey(\"StripByteCounts\")),\n  xResolution: S.optional(S.Union(RationalTag, NumberFileTag)).pipe(S.fromKey(\"XResolution\")),\n  yResolution: S.optional(S.Union(RationalTag, NumberFileTag)).pipe(S.fromKey(\"YResolution\")),\n  planarConfiguration: S.optional(NumberTag).pipe(S.fromKey(\"PlanarConfiguration\")),\n  resolutionUnit: S.optional(NumberTag).pipe(S.fromKey(\"ResolutionUnit\")),\n  transferFunction: S.optional(NumberArrayTag).pipe(S.fromKey(\"TransferFunction\")),\n  software: S.optional(StringArrayTag).pipe(S.fromKey(\"Software\")),\n  dateTime: S.optional(StringArrayTag).pipe(S.fromKey(\"DateTime\")),\n  artist: S.optional(StringArrayTag).pipe(S.fromKey(\"Artist\")),\n  whitePoint: S.optional(NumberArrayTag).pipe(S.fromKey(\"WhitePoint\")),\n  primaryChromaticities: S.optional(NumberArrayTag).pipe(S.fromKey(\"PrimaryChromaticities\")),\n  jpegInterchangeFormat: S.optional(NumberTag).pipe(S.fromKey(\"JPEGInterchangeFormat\")),\n  jpegInterchangeFormatLength: S.optional(NumberTag).pipe(S.fromKey(\"JPEGInterchangeFormatLength\")),\n  yCbCrCoefficients: S.optional(NumberArrayTag).pipe(S.fromKey(\"YCbCrCoefficients\")),\n  yCbCrSubSampling: S.optional(NumberArrayTag).pipe(S.fromKey(\"YCbCrSubSampling\")),\n  yCbCrPositioning: S.optional(NumberTag).pipe(S.fromKey(\"YCbCrPositioning\")),\n  referenceBlackWhite: S.optional(NumberArrayTag).pipe(S.fromKey(\"ReferenceBlackWhite\")),\n  copyright: S.optional(StringArrayTag).pipe(S.fromKey(\"Copyright\")),\n  exifIfdPointer: S.optional(NumberTag).pipe(S.fromKey(\"Exif IFD Pointer\")),\n  gpsInfoIfdPointer: S.optional(NumberTag).pipe(S.fromKey(\"GPS Info IFD Pointer\")),\n\n  // JFIF tags\n  jfifVersion: S.optional(NumberFileTag).pipe(S.fromKey(\"JFIF Version\")),\n  jfifResolutionUnit: S.optional(JfifResolutionUnitTag).pipe(S.fromKey(\"Resolution Unit\")),\n  jfifThumbnailWidth: S.optional(NumberFileTag).pipe(S.fromKey(\"JFIF Thumbnail Width\")),\n  jfifThumbnailHeight: S.optional(NumberFileTag).pipe(S.fromKey(\"JFIF Thumbnail Height\")),\n  jfifThumbnail: S.optional(JfifThumbnailTag).pipe(S.fromKey(\"JFIF Thumbnail\")),\n\n  // Exif tags\n  exposureTime: S.optional(RationalTag).pipe(S.fromKey(\"ExposureTime\")),\n  fNumber: S.optional(RationalTag).pipe(S.fromKey(\"FNumber\")),\n  exposureProgram: S.optional(NumberTag).pipe(S.fromKey(\"ExposureProgram\")),\n  spectralSensitivity: S.optional(StringArrayTag).pipe(S.fromKey(\"SpectralSensitivity\")),\n  isoSpeedRatings: S.optional(S.Union(NumberTag, NumberArrayTag)).pipe(S.fromKey(\"ISOSpeedRatings\")),\n  oecf: S.optional(S.Unknown).pipe(S.fromKey(\"OECF\")),\n  exifVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"ExifVersion\")),\n  dateTimeOriginal: S.optional(StringArrayTag).pipe(S.fromKey(\"DateTimeOriginal\")),\n  dateTimeDigitized: S.optional(StringArrayTag).pipe(S.fromKey(\"DateTimeDigitized\")),\n  componentsConfiguration: S.optional(NumberArrayTag).pipe(S.fromKey(\"ComponentsConfiguration\")),\n  compressedBitsPerPixel: S.optional(RationalTag).pipe(S.fromKey(\"CompressedBitsPerPixel\")),\n  shutterSpeedValue: S.optional(RationalTag).pipe(S.fromKey(\"ShutterSpeedValue\")),\n  apertureValue: S.optional(RationalTag).pipe(S.fromKey(\"ApertureValue\")),\n  brightnessValue: S.optional(RationalTag).pipe(S.fromKey(\"BrightnessValue\")),\n  exposureBiasValue: S.optional(RationalTag).pipe(S.fromKey(\"ExposureBiasValue\")),\n  maxApertureValue: S.optional(RationalTag).pipe(S.fromKey(\"MaxApertureValue\")),\n  subjectDistance: S.optional(RationalTag).pipe(S.fromKey(\"SubjectDistance\")),\n  meteringMode: S.optional(NumberTag).pipe(S.fromKey(\"MeteringMode\")),\n  lightSource: S.optional(NumberTag).pipe(S.fromKey(\"LightSource\")),\n  flash: S.optional(NumberTag).pipe(S.fromKey(\"Flash\")),\n  focalLength: S.optional(RationalTag).pipe(S.fromKey(\"FocalLength\")),\n  subjectArea: S.optional(NumberArrayTag).pipe(S.fromKey(\"SubjectArea\")),\n  makerNote: S.optional(S.Unknown).pipe(S.fromKey(\"MakerNote\")),\n  userComment: S.optional(S.Unknown).pipe(S.fromKey(\"UserComment\")),\n  subSecTime: S.optional(StringArrayTag).pipe(S.fromKey(\"SubSecTime\")),\n  subSecTimeOriginal: S.optional(StringArrayTag).pipe(S.fromKey(\"SubSecTimeOriginal\")),\n  subSecTimeDigitized: S.optional(StringArrayTag).pipe(S.fromKey(\"SubSecTimeDigitized\")),\n  flashpixVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"FlashpixVersion\")),\n  colorSpace: S.optional(NumberTag).pipe(S.fromKey(\"ColorSpace\")),\n  pixelXDimension: S.optional(NumberTag).pipe(S.fromKey(\"PixelXDimension\")),\n  pixelYDimension: S.optional(NumberTag).pipe(S.fromKey(\"PixelYDimension\")),\n  relatedSoundFile: S.optional(StringArrayTag).pipe(S.fromKey(\"RelatedSoundFile\")),\n  interoperabilityIfdPointer: S.optional(NumberTag).pipe(S.fromKey(\"Interoperability IFD Pointer\")),\n  flashEnergy: S.optional(NumberTag).pipe(S.fromKey(\"FlashEnergy\")),\n  spatialFrequencyResponse: S.optional(S.Unknown).pipe(S.fromKey(\"SpatialFrequencyResponse\")),\n  focalPlaneXResolution: S.optional(RationalTag).pipe(S.fromKey(\"FocalPlaneXResolution\")),\n  focalPlaneYResolution: S.optional(RationalTag).pipe(S.fromKey(\"FocalPlaneYResolution\")),\n  focalPlaneResolutionUnit: S.optional(NumberTag).pipe(S.fromKey(\"FocalPlaneResolutionUnit\")),\n  subjectLocation: S.optional(NumberArrayTag).pipe(S.fromKey(\"SubjectLocation\")),\n  exposureIndex: S.optional(RationalTag).pipe(S.fromKey(\"ExposureIndex\")),\n  sensingMethod: S.optional(NumberTag).pipe(S.fromKey(\"SensingMethod\")),\n  fileSource: S.optional(NumberTag).pipe(S.fromKey(\"FileSource\")),\n  sceneType: S.optional(NumberTag).pipe(S.fromKey(\"SceneType\")),\n  cfaPattern: S.optional(S.Unknown).pipe(S.fromKey(\"CFAPattern\")),\n  customRendered: S.optional(NumberTag).pipe(S.fromKey(\"CustomRendered\")),\n  exposureMode: S.optional(NumberTag).pipe(S.fromKey(\"ExposureMode\")),\n  whiteBalance: S.optional(NumberTag).pipe(S.fromKey(\"WhiteBalance\")),\n  digitalZoomRatio: S.optional(RationalTag).pipe(S.fromKey(\"DigitalZoomRatio\")),\n  focalLengthIn35mmFilm: S.optional(NumberTag).pipe(S.fromKey(\"FocalLengthIn35mmFilm\")),\n  sceneCaptureType: S.optional(NumberTag).pipe(S.fromKey(\"SceneCaptureType\")),\n  gainControl: S.optional(NumberTag).pipe(S.fromKey(\"GainControl\")),\n  contrast: S.optional(NumberTag).pipe(S.fromKey(\"Contrast\")),\n  saturation: S.optional(NumberTag).pipe(S.fromKey(\"Saturation\")),\n  sharpness: S.optional(NumberTag).pipe(S.fromKey(\"Sharpness\")),\n  deviceSettingDescription: S.optional(S.Unknown).pipe(S.fromKey(\"DeviceSettingDescription\")),\n  subjectDistanceRange: S.optional(NumberTag).pipe(S.fromKey(\"SubjectDistanceRange\")),\n  imageUniqueId: S.optional(StringArrayTag).pipe(S.fromKey(\"ImageUniqueID\")),\n  lensMake: S.optional(StringArrayTag).pipe(S.fromKey(\"LensMake\")),\n  lensModel: S.optional(StringArrayTag).pipe(S.fromKey(\"LensModel\")),\n  offsetTime: S.optional(StringArrayTag).pipe(S.fromKey(\"OffsetTime\")),\n  offsetTimeDigitized: S.optional(StringArrayTag).pipe(S.fromKey(\"OffsetTimeDigitized\")),\n  offsetTimeOriginal: S.optional(StringArrayTag).pipe(S.fromKey(\"OffsetTimeOriginal\")),\n  gpsHPositioningError: S.optional(NumberArrayTag).pipe(S.fromKey(\"GPSHPositioningError\")),\n\n  // GPS tags\n  gpsVersionId: S.optional(NumberTag).pipe(S.fromKey(\"GPSVersionID\")),\n  gpsLatitudeRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSLatitudeRef\")),\n  gpsLatitude: S.optional(\n    makeTypedTag(S.Tuple(S.Tuple(S.Number, S.Number), S.Tuple(S.Number, S.Number), S.Tuple(S.Number, S.Number)))\n  ).pipe(S.fromKey(\"GPSLatitude\")),\n  gpsLongitudeRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSLongitudeRef\")),\n  gpsLongitude: S.optional(\n    makeTypedTag(S.Tuple(S.Tuple(S.Number, S.Number), S.Tuple(S.Number, S.Number), S.Tuple(S.Number, S.Number)))\n  ).pipe(S.fromKey(\"GPSLongitude\")),\n  gpsAltitudeRef: S.optional(NumberTag).pipe(S.fromKey(\"GPSAltitudeRef\")),\n  gpsAltitude: S.optional(RationalTag).pipe(S.fromKey(\"GPSAltitude\")),\n  gpsTimeStamp: S.optional(NumberArrayTag).pipe(S.fromKey(\"GPSTimeStamp\")),\n  gpsSatellites: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSSatellites\")),\n  gpsStatus: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSStatus\")),\n  gpsMeasureMode: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSMeasureMode\")),\n  gpsDop: S.optional(NumberTag).pipe(S.fromKey(\"GPSDOP\")),\n  gpsSpeedRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSSpeedRef\")),\n  gpsSpeed: S.optional(NumberTag).pipe(S.fromKey(\"GPSSpeed\")),\n  gpsTrackRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSTrackRef\")),\n  gpsTrack: S.optional(NumberTag).pipe(S.fromKey(\"GPSTrack\")),\n  gpsImgDirectionRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSImgDirectionRef\")),\n  gpsImgDirection: S.optional(RationalTag).pipe(S.fromKey(\"GPSImgDirection\")),\n  gpsMapDatum: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSMapDatum\")),\n  gpsDestLatitudeRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSDestLatitudeRef\")),\n  gpsDestLatitude: S.optional(NumberArrayTag).pipe(S.fromKey(\"GPSDestLatitude\")),\n  gpsDestLongitudeRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSDestLongitudeRef\")),\n  gpsDestLongitude: S.optional(NumberArrayTag).pipe(S.fromKey(\"GPSDestLongitude\")),\n  gpsDestBearingRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSDestBearingRef\")),\n  gpsDestBearing: S.optional(NumberTag).pipe(S.fromKey(\"GPSDestBearing\")),\n  gpsDestDistanceRef: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSDestDistanceRef\")),\n  gpsDestDistance: S.optional(NumberTag).pipe(S.fromKey(\"GPSDestDistance\")),\n  gpsProcessingMethod: S.optional(S.Unknown).pipe(S.fromKey(\"GPSProcessingMethod\")),\n  gpsAreaInformation: S.optional(S.Unknown).pipe(S.fromKey(\"GPSAreaInformation\")),\n  gpsDateStamp: S.optional(StringArrayTag).pipe(S.fromKey(\"GPSDateStamp\")),\n  gpsDifferential: S.optional(NumberTag).pipe(S.fromKey(\"GPSDifferential\")),\n\n  // MPF tags\n  mpfVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"MPFVersion\")),\n  numberOfImages: S.optional(NumberTag).pipe(S.fromKey(\"NumberOfImages\")),\n  mpEntry: S.optional(NumberArrayTag).pipe(S.fromKey(\"MPEntry\")),\n  imageUidList: S.optional(NumberArrayTag).pipe(S.fromKey(\"ImageUIDList\")),\n  totalFrames: S.optional(NumberTag).pipe(S.fromKey(\"TotalFrames\")),\n  images: S.optional(S.Array(MPFImageTags)).pipe(S.fromKey(\"Images\")),\n\n  // IPTC tags\n  modelVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"Model Version\")),\n  destination: S.optional(NumberArrayTag).pipe(S.fromKey(\"Destination\")),\n  fileFormat: S.optional(NumberArrayTag).pipe(S.fromKey(\"File Format\")),\n  fileFormatVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"File Format Version\")),\n  serviceIdentifier: S.optional(NumberArrayTag).pipe(S.fromKey(\"Service Identifier\")),\n  envelopeNumber: S.optional(NumberArrayTag).pipe(S.fromKey(\"Envelope Number\")),\n  productId: S.optional(NumberArrayTag).pipe(S.fromKey(\"Product ID\")),\n  envelopePriority: S.optional(NumberArrayTag).pipe(S.fromKey(\"Envelope Priority\")),\n  dateSent: S.optional(NumberArrayTag).pipe(S.fromKey(\"Date Sent\")),\n  timeSent: S.optional(NumberArrayTag).pipe(S.fromKey(\"Time Sent\")),\n  codedCharacterSet: S.optional(NumberArrayTag).pipe(S.fromKey(\"Coded Character Set\")),\n  uno: S.optional(NumberArrayTag).pipe(S.fromKey(\"UNO\")),\n  armIdentifier: S.optional(NumberArrayTag).pipe(S.fromKey(\"ARM Identifier\")),\n  armVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"ARM Version\")),\n  recordVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"Record Version\")),\n  objectTypeReference: S.optional(NumberArrayTag).pipe(S.fromKey(\"Object Type Reference\")),\n  objectAttributeReference: S.optional(NumberArrayTag).pipe(S.fromKey(\"Object Attribute Reference\")),\n  objectName: S.optional(NumberArrayTag).pipe(S.fromKey(\"Object Name\")),\n  editStatus: S.optional(NumberArrayTag).pipe(S.fromKey(\"Edit Status\")),\n  editorialUpdate: S.optional(NumberArrayTag).pipe(S.fromKey(\"Editorial Update\")),\n  urgency: S.optional(NumberArrayTag).pipe(S.fromKey(\"Urgency\")),\n  subjectReference: S.optional(NumberArrayTag).pipe(S.fromKey(\"Subject Reference\")),\n  category: S.optional(NumberArrayTag).pipe(S.fromKey(\"Category\")),\n  supplementalCategory: S.optional(NumberArrayTag).pipe(S.fromKey(\"Supplemental Category\")),\n  fixtureIdentifier: S.optional(NumberArrayTag).pipe(S.fromKey(\"Fixture Identifier\")),\n  keywords: S.optional(S.Union(NumberArrayTag, S.Array(NumberArrayTag))).pipe(S.fromKey(\"Keywords\")),\n  contentLocationCode: S.optional(NumberArrayTag).pipe(S.fromKey(\"Content Location Code\")),\n  contentLocationName: S.optional(NumberArrayTag).pipe(S.fromKey(\"Content Location Name\")),\n  releaseDate: S.optional(NumberArrayTag).pipe(S.fromKey(\"Release Date\")),\n  releaseTime: S.optional(NumberArrayTag).pipe(S.fromKey(\"Release Time\")),\n  expirationDate: S.optional(NumberArrayTag).pipe(S.fromKey(\"Expiration Date\")),\n  expirationTime: S.optional(NumberArrayTag).pipe(S.fromKey(\"Expiration Time\")),\n  specialInstructions: S.optional(NumberArrayTag).pipe(S.fromKey(\"Special Instructions\")),\n  actionAdvised: S.optional(NumberArrayTag).pipe(S.fromKey(\"Action Advised\")),\n  referenceService: S.optional(NumberArrayTag).pipe(S.fromKey(\"Reference Service\")),\n  referenceDate: S.optional(NumberArrayTag).pipe(S.fromKey(\"Reference Date\")),\n  referenceNumber: S.optional(NumberArrayTag).pipe(S.fromKey(\"Reference Number\")),\n  dateCreated: S.optional(NumberArrayTag).pipe(S.fromKey(\"Date Created\")),\n  timeCreated: S.optional(NumberArrayTag).pipe(S.fromKey(\"Time Created\")),\n  digitalCreationDate: S.optional(NumberArrayTag).pipe(S.fromKey(\"Digital Creation Date\")),\n  digitalCreationTime: S.optional(NumberArrayTag).pipe(S.fromKey(\"Digital Creation Time\")),\n  originatingProgram: S.optional(NumberArrayTag).pipe(S.fromKey(\"Originating Program\")),\n  programVersion: S.optional(NumberArrayTag).pipe(S.fromKey(\"Program Version\")),\n  objectCycle: S.optional(NumberArrayTag).pipe(S.fromKey(\"Object Cycle\")),\n  byline: S.optional(NumberArrayTag).pipe(S.fromKey(\"By-line\")),\n  bylineTitle: S.optional(NumberArrayTag).pipe(S.fromKey(\"By-line Title\")),\n  city: S.optional(NumberArrayTag).pipe(S.fromKey(\"City\")),\n  subLocation: S.optional(NumberArrayTag).pipe(S.fromKey(\"Sub-location\")),\n  provinceState: S.optional(NumberArrayTag).pipe(S.fromKey(\"Province/State\")),\n  countryPrimaryLocationCode: S.optional(NumberArrayTag).pipe(S.fromKey(\"Country/Primary Location Code\")),\n  countryPrimaryLocationName: S.optional(NumberArrayTag).pipe(S.fromKey(\"Country/Primary Location Name\")),\n  originalTransmissionReference: S.optional(NumberArrayTag).pipe(S.fromKey(\"Original Transmission Reference\")),\n  headline: S.optional(NumberArrayTag).pipe(S.fromKey(\"Headline\")),\n  credit: S.optional(NumberArrayTag).pipe(S.fromKey(\"Credit\")),\n  source: S.optional(NumberArrayTag).pipe(S.fromKey(\"Source\")),\n  copyrightNotice: S.optional(NumberArrayTag).pipe(S.fromKey(\"Copyright Notice\")),\n  contact: S.optional(NumberArrayTag).pipe(S.fromKey(\"Contact\")),\n  captionAbstract: S.optional(NumberArrayTag).pipe(S.fromKey(\"Caption/Abstract\")),\n  writerEditor: S.optional(NumberArrayTag).pipe(S.fromKey(\"Writer/Editor\")),\n  rasterizedCaption: S.optional(NumberArrayTag).pipe(S.fromKey(\"Rasterized Caption\")),\n  imageType: S.optional(NumberArrayTag).pipe(S.fromKey(\"Image Type\")),\n  imageOrientation: S.optional(NumberArrayTag).pipe(S.fromKey(\"Image Orientation\")),\n  languageIdentifier: S.optional(NumberArrayTag).pipe(S.fromKey(\"Language Identifier\")),\n  audioType: S.optional(NumberArrayTag).pipe(S.fromKey(\"Audio Type\")),\n  audioSamplingRate: S.optional(NumberArrayTag).pipe(S.fromKey(\"Audio Sampling Rate\")),\n  audioSamplingResolution: S.optional(NumberArrayTag).pipe(S.fromKey(\"Audio Sampling Resolution\")),\n  audioDuration: S.optional(NumberArrayTag).pipe(S.fromKey(\"Audio Duration\")),\n  audioOutcue: S.optional(NumberArrayTag).pipe(S.fromKey(\"Audio Outcue\")),\n  shortDocumentId: S.optional(NumberArrayTag).pipe(S.fromKey(\"Short Document ID\")),\n  uniqueDocumentId: S.optional(NumberArrayTag).pipe(S.fromKey(\"Unique Document ID\")),\n  ownerId: S.optional(NumberArrayTag).pipe(S.fromKey(\"Owner ID\")),\n  objectDataPreviewFileFormat: S.optional(NumberArrayTag).pipe(S.fromKey(\"ObjectData Preview File Format\")),\n  record2Destination: S.optional(NumberArrayTag).pipe(S.fromKey(\"Record 2 destination\")),\n  objectDataPreviewFileFormatVersion: S.optional(NumberArrayTag).pipe(\n    S.fromKey(\"ObjectData Preview File Format Version\")\n  ),\n  objectDataPreviewData: S.optional(NumberArrayTag).pipe(S.fromKey(\"ObjectData Preview Data\")),\n  sizeMode: S.optional(NumberArrayTag).pipe(S.fromKey(\"Size Mode\")),\n  maxSubfileSize: S.optional(NumberArrayTag).pipe(S.fromKey(\"Max Subfile Size\")),\n  objectDataSizeAnnounced: S.optional(NumberArrayTag).pipe(S.fromKey(\"ObjectData Size Announced\")),\n  maximumObjectDataSize: S.optional(NumberArrayTag).pipe(S.fromKey(\"Maximum ObjectData Size\")),\n\n  thumbnail: S.optional(ThumbnailTags).pipe(S.fromKey(\"Thumbnail\")),\n});\n\n// Main expanded tags structure\nexport const ExpandedTags = BS.Struct({\n  file: S.optional(FileTags),\n  jfif: S.optional(JfifTags),\n  pngFile: S.optional(PngFileTags),\n  pngText: S.optional(PngTextTags),\n  png: S.optional(PngTags),\n  exif: S.optional(ExifTags),\n  iptc: S.optional(ExifTags),\n  xmp: S.optional(\n    S.Union(\n      BS.Json,\n      BS.Struct(\n        {\n          _raw: S.String,\n        },\n        S.Record({ key: S.String, value: XmpTag })\n      ),\n      S.String\n    )\n  ), // _raw field combined with dynamic XmpTag fields\n  icc: S.optional(IccTags),\n  riff: S.optional(RiffTags),\n  gif: S.optional(GifTags),\n  Thumbnail: S.optional(ThumbnailTags),\n  gps: S.optional(GpsTags),\n  photoshop: S.optional(PhotoshopTags),\n  makerNotes: S.optional(\n    BS.Struct({\n      ...CanonTags.fields,\n      ...PentaxTags.fields,\n    })\n  ),\n  composite: S.optional(CompositeTags),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/ExpandedTags\"),\n  identifier: \"ExpandedTags\",\n  title: \"Expanded EXIF Metadata\",\n  description: \"High-level structure compatible with ExifReader's expanded output across multiple containers.\",\n});\n\nexport namespace ExpandedTags {\n  export type Type = S.Schema.Type<typeof ExpandedTags>;\n  export type Encoded = S.Schema.Encoded<typeof ExpandedTags>;\n}\n// Combined tags type\nexport const Tags = BS.Struct({\n  ...XmpTags.fields,\n  ...IccTags.fields,\n  ...PngTags.fields,\n  ...RiffTags.fields,\n  ...GifTags.fields,\n  ...PhotoshopTags.fields,\n  ...CanonTags.fields,\n  ...PentaxTags.fields,\n  ...CompositeTags.fields,\n  Thumbnail: S.optional(ThumbnailTags),\n  Images: S.optional(S.Array(MPFImageTags)),\n}).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifTags/Tags\"),\n  identifier: \"Tags\",\n  title: \"Combined Tags\",\n  description: \"Flattened union of container-specific tag maps for convenience.\",\n});\n","import * as Cause from \"effect/Cause\";\nimport * as Effect from \"effect/Effect\";\nimport type { AccumulateOptions, AccumulateResult } from \"./shared\";\nimport { accumulateEffects } from \"./shared\";\n\n// Re-export shared, Node-free helpers\nexport * from \"./shared\";\n\n// =========================\n// Client-specific wrappers\n// =========================\n\nexport const withEnvLogging = <A, E, R>(self: Effect.Effect<A, E, R>) => self;\n\nexport const accumulateEffectsAndReport = <A, E, R>(\n  effects: ReadonlyArray<Effect.Effect<A, E, R>>,\n  options?: AccumulateOptions\n): Effect.Effect<AccumulateResult<A, E>, never, R> =>\n  Effect.gen(function* () {\n    const res = yield* accumulateEffects(effects, { concurrency: options?.concurrency });\n\n    yield* Effect.logInfo(\"accumulate summary\", {\n      successes: res.successes.length,\n      errors: res.errors.length,\n    });\n\n    for (const [i, cause] of res.errors.entries()) {\n      yield* Effect.logError(`accumulate error[${i}]`);\n      // Pretty print cause without server-only extras\n      yield* Effect.sync(() => console.error(Cause.pretty(cause)));\n    }\n\n    let eff: Effect.Effect<AccumulateResult<A, E>, never, R> = Effect.succeed(res);\n    if (options?.annotations) eff = eff.pipe(Effect.annotateLogs(options.annotations));\n    if (options?.spanLabel) eff = eff.pipe(Effect.withLogSpan(options.spanLabel));\n    return yield* eff;\n  });\n","import * as detectionFunctions from \"./detection\";\nimport * as validationFunctions from \"./FileTypes\";\n\nexport const fileTypeChecker = {\n  ...detectionFunctions,\n  ...validationFunctions,\n};\n","export function get64BitValue(dataView, offset) {\n    // It's a bit tricky to handle 64 bit numbers in JavaScript. Let's\n    // wait until there are real-world examples where it is necessary.\n    return dataView.getUint32(offset + 4);\n}\n","export function isMissingNamespaceError(error) {\n    const missingNamespaceStrings = [\n        // @xmldom/xmldom\n        'prefix is non-null and namespace is null',\n        // Firefox\n        'prefix not bound to a namespace', // en\n        'prefix inte bundet till en namnrymd', // sv\n        // Chrome\n        /Namespace prefix .+ is not defined/\n    ];\n\n    for (let i = 0; i < missingNamespaceStrings.length; i++) {\n        const regexp = new RegExp(missingNamespaceStrings[i]);\n        if (regexp.test(error.message)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// This should fix most missing namespace errors, but it's not a complete solution.\nexport function addMissingNamespaces(xmlString) {\n    const rootTagMatch = xmlString.match(/<([A-Za-z_][A-Za-z0-9._-]*)([^>]*)>/);\n    if (!rootTagMatch) {\n        return xmlString;\n    }\n    const rootTagName = rootTagMatch[1];\n\n    const declaredPrefixes = getAllDeclaredNamespacePrefixes(xmlString);\n    const usedPrefixes = getUsedNamespacePrefixes(xmlString);\n    const missingPrefixes = usedPrefixes.filter((prefix) => declaredPrefixes.indexOf(prefix) === -1);\n    if (missingPrefixes.length === 0) {\n        return xmlString;\n    }\n\n    const namespaceDeclarations = createNamespaceDeclarations(missingPrefixes);\n    return insertDeclarationsIntoRoot(xmlString, rootTagName, namespaceDeclarations);\n}\n\nfunction getAllDeclaredNamespacePrefixes(xmlContent) {\n    const prefixes = [];\n    const namespaceDeclarationRegex = /xmlns:([\\w-]+)=[\"'][^\"']+[\"']/g;\n    let match;\n    while ((match = namespaceDeclarationRegex.exec(xmlContent)) !== null) {\n        if (prefixes.indexOf(match[1]) === -1) {\n            prefixes.push(match[1]);\n        }\n    }\n    return prefixes;\n}\n\nfunction getUsedNamespacePrefixes(xmlContent) {\n    const prefixes = [];\n    const prefixUsageRegex = /\\b([A-Za-z_][A-Za-z0-9._-]*):[A-Za-z_][A-Za-z0-9._-]*\\b/g;\n    let match;\n    while ((match = prefixUsageRegex.exec(xmlContent)) !== null) {\n        const prefix = match[1];\n        if (prefix === 'xmlns' || prefix === 'xml') {\n            continue;\n        }\n        if (prefixes.indexOf(prefix) === -1) {\n            prefixes.push(prefix);\n        }\n    }\n    return prefixes;\n}\n\nconst KNOWN_NAMESPACE_URIS = {\n    xmp: 'http://ns.adobe.com/xap/1.0/',\n    tiff: 'http://ns.adobe.com/tiff/1.0/',\n    exif: 'http://ns.adobe.com/exif/1.0/',\n    dc: 'http://purl.org/dc/elements/1.1/',\n    xmpMM: 'http://ns.adobe.com/xap/1.0/mm/',\n    stEvt: 'http://ns.adobe.com/xap/1.0/sType/ResourceEvent#',\n    stRef: 'http://ns.adobe.com/xap/1.0/sType/ResourceRef#',\n    photoshop: 'http://ns.adobe.com/photoshop/1.0/'\n};\n\nfunction createNamespaceDeclarations(prefixes) {\n    const declarations = [];\n    for (let i = 0; i < prefixes.length; i++) {\n        const prefix = prefixes[i];\n        const uri = KNOWN_NAMESPACE_URIS[prefix] || 'http://fallback.namespace/' + prefix;\n        declarations.push(' xmlns:' + prefix + '=\"' + uri + '\"');\n    }\n    return declarations.join('');\n}\n\nfunction insertDeclarationsIntoRoot(xmlString, rootTagName, declarations) {\n    const rootTagPattern = new RegExp('<' + rootTagName + '([^>]*)>');\n    return xmlString.replace(rootTagPattern, '<' + rootTagName + '$1' + declarations + '>');\n}\n","export default class DataView {\n    constructor(buffer) {\n        if (bufferTypeIsUnsupported(buffer)) {\n            throw new Error('DataView: Passed buffer type is unsupported.');\n        }\n\n        this.buffer = buffer;\n        this.byteLength = this.buffer.length;\n    }\n\n    getUint8(offset) {\n        return this.buffer.readUInt8(offset);\n    }\n\n    getUint16(offset, littleEndian) {\n        if (littleEndian) {\n            return this.buffer.readUInt16LE(offset);\n        }\n        return this.buffer.readUInt16BE(offset);\n    }\n\n    getUint32(offset, littleEndian) {\n        if (littleEndian) {\n            return this.buffer.readUInt32LE(offset);\n        }\n        return this.buffer.readUInt32BE(offset);\n    }\n\n    getInt32(offset, littleEndian) {\n        if (littleEndian) {\n            return this.buffer.readInt32LE(offset);\n        }\n        return this.buffer.readInt32BE(offset);\n    }\n}\n\nfunction bufferTypeIsUnsupported(buffer) {\n    return typeof buffer !== 'object'\n        || buffer.length === undefined\n        || buffer.readUInt8 === undefined\n        || buffer.readUInt16LE === undefined\n        || buffer.readUInt16BE === undefined\n        || buffer.readUInt32LE === undefined\n        || buffer.readUInt32BE === undefined\n        || buffer.readInt32LE === undefined\n        || buffer.readInt32BE === undefined;\n}\n","import * as S from \"effect/Schema\";\nexport class FileSignature extends S.Class<FileSignature>(\"FileSignature\")(\n  {\n    sequence: S.Array(S.Union(S.Number, S.NonEmptyString)),\n    offset: S.optional(S.Int.pipe(S.greaterThan(0))),\n    skippedBytes: S.optional(S.Array(S.Int.pipe(S.greaterThan(0)))),\n    description: S.optional(S.NonEmptyString),\n    compatibleExtensions: S.optional(S.NonEmptyArray(S.String)),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/files-domain/value-objects/file-types/FileSignature\"),\n    identifier: \"FileSignature\",\n    title: \"File Signature\",\n    description: \"File signature\",\n  }\n) {}\n\nexport namespace FileSignature {\n  export type Type = S.Schema.Type<typeof FileSignature>;\n  export type Encoded = S.Schema.Encoded<typeof FileSignature>;\n}\n","import type { UnsafeTypes } from \"@beep/types\";\nimport * as Effect from \"effect/Effect\";\nimport * as P from \"effect/Predicate\";\nimport * as S from \"effect/Schema\";\nimport * as Struct from \"effect/Struct\";\nimport ExifReader from \"exifreader\";\nimport * as Errors from \"../../errors\";\nimport { readFileArrayBuffer } from \"../../utils\";\nimport { ExpandedTags } from \"./ExifTags\";\n\n/**\n * Fields that typically contain large binary data or images that should be omitted\n * to reduce payload size and improve performance\n */\nconst LARGE_DATA_FIELDS = [\n  \"base64\",\n  \"image\",\n  // \"thumbnail\" is intentionally excluded from exact matches to preserve container objects\n  \"thumbnailImage\",\n  \"preview\",\n  \"previewImage\",\n  \"rawImage\",\n  \"blob\",\n  \"buffer\",\n  \"data\",\n  \"binaryData\",\n  \"iccProfile\",\n  \"colorProfile\",\n  \"embeddedImage\",\n  \"makerNoteImage\",\n] as const;\n\n/**\n * Check if a field name indicates it contains large data.\n * Heuristic: matches common names like base64/image/thumbnail/preview/etc.\n */\nconst isLargeDataField = (key: string): boolean => {\n  const lowerKey = key.toLowerCase();\n  // Do not drop the entire container for `thumbnail`; clean its inner fields instead\n  if (lowerKey === \"thumbnail\") return false;\n  return (\n    LARGE_DATA_FIELDS.some((field) => lowerKey.includes(field.toLowerCase())) ||\n    lowerKey.endsWith(\"image\") ||\n    lowerKey.includes(\"base64\")\n  );\n};\n\n/**\n * Check if a value appears to be large binary data.\n * Uses simple thresholds (>1KB) and base64-like pattern detection for strings.\n */\nconst isLargeDataValue = (value: unknown): boolean => {\n  if (value instanceof ArrayBuffer || value instanceof Uint8Array) {\n    return value.byteLength > 1024; // > 1KB\n  }\n\n  if (typeof value === \"string\") {\n    // Base64 encoded data or very long strings\n    return value.length > 1024 || (/^[A-Za-z0-9+/]+=*$/.test(value) && value.length > 100);\n  }\n\n  return false;\n};\n\n/**\n * Recursively omit large data fields from an object.\n * Walks objects and arrays, removing keys that look like large binary payloads.\n */\nconst omitLargeDataFromObject = <T extends Record<string, UnsafeTypes.UnsafeAny>>(obj: T): T => {\n  const result: Record<string, UnsafeTypes.UnsafeAny> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    // Skip if field name indicates large data\n    if (isLargeDataField(key)) {\n      continue;\n    }\n\n    // Skip if value appears to be large binary data\n    if (isLargeDataValue(value)) {\n      continue;\n    }\n\n    // Recursively process nested objects\n    if (value && typeof value === \"object\" && !Array.isArray(value)) {\n      result[key] = omitLargeDataFromObject(value);\n    } else if (Array.isArray(value)) {\n      // Process arrays, filtering out large data items\n      result[key] = value\n        .filter((item) => !isLargeDataValue(item))\n        .map((item) =>\n          item && typeof item === \"object\" && !Array.isArray(item) ? omitLargeDataFromObject(item) : item\n        );\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result as T;\n};\n\n/**\n * Clean EXIF data by removing large binary fields like base64, images, etc.\n * This is useful for reducing payload size when storing or transmitting EXIF metadata.\n *\n * @param exifData - Raw EXIF data from ExifReader\n * @returns Cleaned EXIF data with large binary fields removed\n *\n * @example\n * ```typescript\n * const rawExif = ExifReader.load(imagePath, { expanded: true });\n * const cleanExif = cleanExifData(rawExif);\n * const validated = yield* S.decode(ExpandedTags)(cleanExif);\n * ```\n */\nexport const cleanExifData = <T extends Record<string, UnsafeTypes.UnsafeAny>>(exifData: T): T => {\n  if (!exifData || typeof exifData !== \"object\") {\n    return exifData;\n  }\n\n  return omitLargeDataFromObject(exifData);\n};\n\n/**\n * Clean specific known large fields from EXIF data using Effect's EffStruct.omit\n * This is a more targeted approach for known problematic fields.\n *\n * @param exifData - Raw EXIF data from ExifReader\n * @returns EXIF data with specific large fields omitted\n */\nexport const omitKnownLargeFields = <T extends Record<string, UnsafeTypes.UnsafeAny>>(exifData: T): T => {\n  let cleaned = { ...exifData };\n\n  // Clean ICC profile\n  if (P.isNotNullable(cleaned.icc) && typeof cleaned.icc === \"object\") {\n    cleaned = {\n      ...cleaned,\n      icc: Struct.omit(\"base64\", \"data\", \"buffer\")(cleaned.icc),\n    };\n  }\n\n  // Clean XMP data\n  if (P.isNotNullable(cleaned.xmp) && typeof cleaned.xmp === \"object\") {\n    cleaned = {\n      ...cleaned,\n      xmp: Struct.omit(\"base64\", \"rawXml\", \"data\")(cleaned.xmp),\n    };\n  }\n\n  // Clean IPTC data\n  if (P.isNotNullable(cleaned.iptc) && typeof cleaned.iptc === \"object\") {\n    cleaned = {\n      ...cleaned,\n      iptc: Struct.omit(\"base64\", \"data\", \"buffer\")(cleaned.iptc),\n    };\n  }\n\n  // Clean thumbnail data\n  if (P.isNotNullable(cleaned.thumbnail) && typeof cleaned.thumbnail === \"object\") {\n    cleaned = {\n      ...cleaned,\n      thumbnail: Struct.omit(\"image\", \"base64\", \"blob\", \"buffer\")(cleaned.thumbnail),\n    };\n  }\n\n  // Clean EXIF data recursively for nested structures\n  if (P.isNotNullable(cleaned.exif) && typeof cleaned.exif === \"object\") {\n    const exifCleaned = omitLargeDataFromObject(cleaned.exif);\n    cleaned = { ...cleaned, exif: exifCleaned };\n  }\n\n  return cleaned;\n};\n\nexport class ExifMetadata extends ExpandedTags.annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/exif-metadata/ExifMetadata\"),\n  identifier: \"ExifMetadata\",\n  title: \"EXIF Metadata\",\n  description: \"EXIF metadata extracted from an image file.\",\n}) {\n  static readonly cleanExifData = cleanExifData;\n  static readonly omitKnownLargeFields = omitKnownLargeFields;\n  static readonly isLargeDataField = isLargeDataField;\n  static readonly isLargeDataValue = isLargeDataValue;\n  static readonly omitLargeDataFromObject = omitLargeDataFromObject;\n\n  static readonly extractMetadata = Effect.fn(\"extractMetadata\")(function* (file: File) {\n    const arrayBuffer = yield* readFileArrayBuffer(file);\n    const raw = yield* Effect.try({\n      try: () => ExifReader.load(arrayBuffer, { expanded: true }),\n      catch: (e) =>\n        new Errors.ExifParseError({\n          message: \"Could not parse EXIF data\",\n          cause: e,\n          fileName: file.name,\n          fileType: file.type,\n          fileSize: file.size,\n          phase: \"parse\",\n        }),\n    });\n    const cleaned = cleanExifData(raw);\n    return yield* S.decodeUnknown(ExifMetadata)(cleaned).pipe(\n      Effect.mapError(\n        (e) =>\n          new Errors.ExifParseError({\n            message: \"Could not decode EXIF data to schema\",\n            cause: e,\n            fileName: file.name,\n            fileType: file.type,\n            fileSize: file.size,\n            phase: \"decode\",\n          })\n      )\n    );\n  });\n}\n","import { BS } from \"@beep/schema\";\nimport type { UnsafeTypes } from \"@beep/types\";\nimport * as A from \"effect/Array\";\nimport * as P from \"effect/Predicate\";\nimport type { FileInfo } from \"./FileInfo\";\n\n/**\n * Determine if array of numbers is a legal file chunk\n *\n * @param fileChunk File content represents in Array<number>\n *\n * @returns {boolean} True if the file content is verified, otherwise false\n */\n\nfunction isLegalChunk(fileChunk: Array<number>): boolean {\n  return fileChunk.every((num) => P.and(P.isNumber, P.not(Number.isNaN))(num));\n}\n\nexport function getFileChunk(\n  file: ReadonlyArray<number> | ArrayBuffer | Uint8Array,\n  fileChunkLength = 32 // default length - 32 bytes\n): Array<number> {\n  const fileToCheck: ReadonlyArray<number> | Uint8Array = file instanceof ArrayBuffer ? new Uint8Array(file) : file;\n  let chunk: Array<number> = [];\n  if (P.or(P.and(A.isArray, BS.ArrayOfNumbers.is), P.or(BS.ArrBuffer.is, BS.Uint8Arr.is))(file)) {\n    chunk = Array.from(fileToCheck.slice(0, fileChunkLength));\n  } else {\n    throw new TypeError(\n      `Expected the \\`file\\` argument to be of type \\`Array<number>\\`, \\`Uint8Array\\`, or \\`ArrayBuffer\\`, got \\`${typeof file}\\``\n    );\n  }\n\n  if (!isLegalChunk(chunk)) throw new TypeError(`File content contains illegal values`);\n\n  return chunk;\n}\n\n/**\n * Fetch a property of a object by its name\n *\n * @param obj The required object\n * @param prop The property name\n *\n * @returns {FileInfo} A property of the required object\n */\nexport function fetchFromObject(obj: UnsafeTypes.UnsafeAny, prop: string): FileInfo.Type {\n  const _index = prop.indexOf(\".\");\n  if (_index > -1) {\n    return fetchFromObject(obj[prop.slice(0, _index)], prop.slice(_index + 1));\n  }\n  return obj[prop];\n}\n\n/**\n * Identify whether a valid 'mkv'/'web' file is 'mkv' or 'webm'.\n * By checking for the presence of the \"DocType\" element in the 'webm' header.\n * Or by checking the presence of the \"Segment\" element in the 'mkv' header.\n *\n * @param fileChunk - A chunk from the beginning of a file content, represents in array of numbers\n *\n * @returns {string | undefined} 'webm' if found webm string A property of the required object\n */\nexport function findMatroskaDocTypeElements(fileChunk: Array<number>): string | undefined {\n  const webmString = \"webm\";\n  const mkvString = \"matroska\";\n\n  const byteString = fileChunk.map((num) => String.fromCharCode(num)).join(\"\");\n\n  if (byteString.includes(webmString)) {\n    return \"webm\";\n  }\n\n  if (byteString.includes(mkvString)) {\n    return \"mkv\";\n  }\n\n  return undefined; // File type not identified\n}\n\n/**\n * Determine if array of numbers contains the \"fytp\" string.\n * M4V files typically have a \"ftyp\" box in the first few bytes, which can be checked by searching for the string \"ftyp\" in the buffer.\n *\n * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n *\n * @returns {boolean} True if found the \"ftyp\" string in the fileChunk, otherwise false\n */\nexport function isftypStringIncluded(fileChunk: Array<number>): boolean {\n  const ftypSignature = [0x66, 0x74, 0x79, 0x70] as const; // \"ftyp\" signature\n\n  // Check the first few bytes for the \"ftyp\" signature\n  for (let i = 0; i < fileChunk.length - ftypSignature.length; i++) {\n    let found = true;\n    for (let j = 0; j < ftypSignature.length; j++) {\n      if (fileChunk[i + j] !== ftypSignature[j]) {\n        found = false;\n        break;\n      }\n    }\n    if (found) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Determine if array of numbers contains the \"FLV\" string.\n * FLV files typically have a \"FLV\" string in the first few bytes of the file, which can be checked using TextDecoder or similar.\n *\n * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n *\n * @returns {boolean} True if found the \"FLV\" string in the fileChunk, otherwise false\n */\nexport function isFlvStringIncluded(fileChunk: Array<number>): boolean {\n  const signature = fileChunk.slice(0, 3);\n  const signatureString = new TextDecoder().decode(new Uint8Array(signature));\n  return signatureString.includes(\"FLV\");\n}\n\nexport function isFileContaineJfiforExifHeader(file: number[]): boolean {\n  // Check if the fourth byte is one of the known JFIF or EXIF header markers\n  const headerMarker = file[3];\n  if (\n    headerMarker === 0xe0 || // JFIF\n    headerMarker === 0xe1 // EXIF\n  ) {\n    return true; // It's a JPEG file\n  }\n  return false;\n}\n\n/**\n * Determine if array of numbers contains the \"ftypavif\" string.\n * AVIF files typically have a \"ftypavif\" string at bytes 5-12 of the file, which can be checked using TextDecoder or similar.\n *\n * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n *\n * @returns {boolean} True if found the \"AVIF\" string in the fileChunk, otherwise false\n */\nexport function isAvifStringIncluded(fileChunk: Array<number>): boolean {\n  // Convert the relevant slice of the file chunk from hexadecimal to characters\n  const signature = fileChunk\n    .slice(4, 12)\n    .map((hex) => String.fromCharCode(hex))\n    .join(\"\");\n  return signature === \"ftypavif\";\n}\n\n/**\n * Determine if a file chunk contains a HEIC file box.\n * HEIC files typically have an 'ftyp' box with specific major brand signatures\n * such as 'heic', 'hevc', 'mif1', and 'msf1' which can be checked by searching\n * for these strings in the file chunk.\n *\n * @param fileChunk A chunk from the beginning of a file content, represented as an array of numbers.\n * @returns {boolean} True if found a HEIC signature in the fileChunk, otherwise false.\n */\nexport function isHeicSignatureIncluded(fileChunk: Array<number>): boolean {\n  // Convert the first part of the file chunk to a string to check for signatures\n  const byteString = fileChunk.map((num) => String.fromCharCode(num)).join(\"\");\n\n  // List of possible HEIC 'ftyp' signatures\n  const heicSignatures = [\"ftypheic\", \"ftyphevc\", \"ftypmif1\", \"ftypmsf1\"] as const;\n\n  // Check if any of the HEIC signatures are included in the byte string\n  return heicSignatures.some((signature) => byteString.includes(signature));\n}\n","import { withLogContext, withRootSpan, withSpanAndMetrics } from \"@beep/errors/client\";\nimport * as Effect from \"effect/Effect\";\nimport * as Metric from \"effect/Metric\";\nimport * as MetricBoundaries from \"effect/MetricBoundaries\";\n\n/**\n * Upload observability\n * - Spans, annotations, and metrics for the upload pipeline\n */\n\n// Metrics\nexport const UploadMetrics = {\n  // Per-file lifecycle\n  filesProcessedTotal: Metric.counter(\"upload.files_processed_total\"),\n  filesFailedTotal: Metric.counter(\"upload.files_failed_total\"),\n\n  // Detection & EXIF\n  detectionFailedTotal: Metric.counter(\"upload.detection_failed_total\"),\n  exifParsedTotal: Metric.counter(\"upload.exif_parsed_total\"),\n  exifFailedTotal: Metric.counter(\"upload.exif_failed_total\"),\n\n  // Durations\n  processFileDurationMs: Metric.histogram(\n    \"upload.process_file_duration_ms\",\n    MetricBoundaries.fromIterable([1, 5, 10, 25, 50, 100, 250, 500, 1000, 2000, 5000, 10_000])\n  ),\n} as const;\n\nexport type UploadAnnotation = Readonly<Record<string, unknown>>;\n\nexport const makeFileAnnotations = (file: File, extra?: UploadAnnotation): UploadAnnotation => ({\n  service: \"upload\",\n  fileName: file.name,\n  fileType: file.type,\n  fileSize: file.size,\n  ...extra,\n});\n\nexport const instrumentProcessFile =\n  (annotations?: UploadAnnotation) =>\n  <A, E, R>(self: Effect.Effect<A, E, R>) =>\n    self.pipe(\n      withLogContext({ service: \"upload\", ...annotations }),\n      withRootSpan(\"upload.processFile\"),\n      withSpanAndMetrics(\n        \"upload.processFile\",\n        {\n          successCounter: UploadMetrics.filesProcessedTotal,\n          errorCounter: UploadMetrics.filesFailedTotal,\n          durationHistogram: UploadMetrics.processFileDurationMs,\n          durationUnit: \"millis\",\n        },\n        { service: \"upload\", ...annotations }\n      )\n    );\n\n// Lightweight logging helpers (level-specific)\nexport const logInfo = (message: string, annotations?: UploadAnnotation) =>\n  Effect.logInfo(message).pipe(Effect.annotateLogs(annotations ?? {}));\nexport const logWarning = (message: string, annotations?: UploadAnnotation) =>\n  Effect.logWarning(message).pipe(Effect.annotateLogs(annotations ?? {}));\n","import * as Data from \"effect/Data\";\n\nexport class ExifParseError extends Data.TaggedError(\"ExifParseError\")<{\n  readonly message: string;\n  readonly cause: unknown;\n  readonly fileName?: string;\n  readonly fileType?: string;\n  readonly fileSize?: number;\n  readonly phase?: \"read\" | \"parse\" | \"decode\";\n}> {}\n\nexport class FileReadError extends Data.TaggedError(\"FileReadError\")<{\n  readonly message: string;\n  readonly cause: unknown;\n  readonly fileName?: string;\n  readonly fileType?: string;\n  readonly fileSize?: number;\n  readonly phase?: \"read\" | \"parse\" | \"decode\";\n}> {}\n","import {get64BitValue} from './image-header-iso-bmff-utils.js';\n\nexport function parseItemLocationBox(dataView, version, contentOffset, boxLength) {\n    const FLAGS_SIZE = 3;\n\n    const {offsets, sizes} = getItemLocationBoxOffsetsAndSizes(version, contentOffset + FLAGS_SIZE);\n\n    const offsetSize = dataView.getUint8(offsets.offsetSize) >> 4;\n    sizes.item.extent.extentOffset = offsetSize;\n    const lengthSize = dataView.getUint8(offsets.lengthSize) & 0x0f;\n    sizes.item.extent.extentLength = lengthSize;\n    const baseOffsetSize = dataView.getUint8(offsets.baseOffsetSize) >> 4;\n    sizes.item.baseOffset = baseOffsetSize;\n    const indexSize = getIndexSize(dataView, offsets.indexSize, version);\n    sizes.item.extent.extentIndex = indexSize !== undefined ? indexSize : 0;\n    const itemCount = getItemCount(dataView, offsets.itemCount, version);\n\n    return {\n        type: 'iloc',\n        items: getItems(dataView, version, offsets, sizes, offsetSize, lengthSize, indexSize, itemCount),\n        length: boxLength\n    };\n}\n\nfunction getItemLocationBoxOffsetsAndSizes(version, contentOffset) {\n    const sizes = {\n        item: {\n            dataReferenceIndex: 2,\n            extentCount: 2,\n            extent: {}\n        }\n    };\n    if (version < 2) {\n        sizes.itemCount = 2;\n        sizes.item.itemId = 2;\n    } else if (version === 2) {\n        sizes.itemCount = 4;\n        sizes.item.itemId = 4;\n    }\n    if (version === 1 || version === 2) {\n        sizes.item.constructionMethod = 2;\n    } else {\n        sizes.item.constructionMethod = 0;\n    }\n\n    const offsets = {\n        offsetSize: contentOffset,\n        lengthSize: contentOffset,\n        baseOffsetSize: contentOffset + 1,\n        indexSize: contentOffset + 1\n    };\n    offsets.itemCount = contentOffset + 2;\n    offsets.items = offsets.itemCount + sizes.itemCount;\n    offsets.item = {\n        itemId: 0\n    };\n    offsets.item.constructionMethod = offsets.item.itemId + sizes.item.itemId;\n    offsets.item.dataReferenceIndex = offsets.item.constructionMethod + sizes.item.constructionMethod;\n\n    return {offsets, sizes};\n}\n\nfunction getIndexSize(dataView, offset, version) {\n    if (version === 1 || version === 2) {\n        return dataView.getUint8(offset) & 0x0f;\n    }\n    return undefined;\n}\n\nfunction getItemCount(dataView, offset, version) {\n    if (version < 2) {\n        return dataView.getUint16(offset);\n    } else if (version === 2) {\n        return dataView.getUint32(offset);\n    }\n    return undefined;\n}\n\nfunction getItems(dataView, version, offsets, sizes, offsetSize, lengthSize, indexSize, itemCount) {\n    if (itemCount === undefined) {\n        return [];\n    }\n\n    const items = [];\n    let offset = offsets.items;\n\n    for (let i = 0; i < itemCount; i++) {\n        const item = {extents: []};\n        item.itemId = getItemId(dataView, offset, version);\n        offset += sizes.item.itemId;\n        item.constructionMethod = (version === 1) || (version === 2) ? dataView.getUint16(offset) & 0x0f : undefined;\n        offset += sizes.item.constructionMethod;\n        item.dataReferenceIndex = dataView.getUint16(offset);\n        offset += sizes.item.dataReferenceIndex;\n        item.baseOffset = getVariableSizedValue(dataView, offset, sizes.item.baseOffset);\n        offset += sizes.item.baseOffset;\n        item.extentCount = dataView.getUint16(offset);\n        offset += sizes.item.extentCount;\n        for (let j = 0; j < item.extentCount; j++) {\n            const extent = {};\n\n            extent.extentIndex = getExtentIndex(dataView, version, offset, indexSize);\n            offset += sizes.item.extent.extentIndex;\n            extent.extentOffset = getVariableSizedValue(dataView, offset, offsetSize);\n            offset += sizes.item.extent.extentOffset;\n            extent.extentLength = getVariableSizedValue(dataView, offset, lengthSize);\n            offset += sizes.item.extent.extentLength;\n\n            item.extents.push(extent);\n        }\n\n        items.push(item);\n    }\n\n    return items;\n}\n\nfunction getItemId(dataView, offset, version) {\n    if (version < 2) {\n        return dataView.getUint16(offset);\n    } else if (version === 2) {\n        return dataView.getUint32(offset);\n    }\n    return undefined;\n}\n\nfunction getExtentIndex(dataView, version, offset, indexSize) {\n    if ((version === 1 || version === 2) && indexSize > 0) {\n        return getVariableSizedValue(dataView, offset, indexSize);\n    }\n    return undefined;\n}\n\nfunction getVariableSizedValue(dataView, offset, size) {\n    if (size === 4) {\n        return dataView.getUint32(offset);\n    }\n    if (size === 8) {\n        // eslint-disable-next-line no-console\n        console.warn('This file uses an 8-bit offset which is currently not supported by ExifReader. Contact the maintainer to get it fixed.');\n        return get64BitValue(dataView, offset);\n    }\n    return 0;\n}\n","import * as S from \"effect/Schema\";\n\nexport class FileInstance extends S.declare((i: unknown): i is File => i instanceof File).annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/FileInstance\"),\n  identifier: \"FileInstance\",\n  title: \"FileInstance\",\n  description: \"Base file instance schema\",\n}) {}\n\nexport namespace FileInstance {\n  export type Type = S.Schema.Type<typeof FileInstance>;\n  export type Encoded = S.Schema.Encoded<typeof FileInstance>;\n}\n","import { View } from \"@/features/upload\";\n\nexport default function Page() {\n  return <View />;\n}\n","import { BS } from \"@beep/schema\";\nimport * as S from \"effect/Schema\";\n\nexport class FileAttributes extends BS.Class<FileAttributes>(\"FileAttributes\")(\n  {\n    size: S.NonNegativeInt,\n    type: BS.MimeType,\n    lastModifiedDate: BS.DateFromAllAcceptable,\n    lastModified: BS.DateFromAllAcceptable,\n    name: S.NonEmptyString,\n    webkitRelativePath: S.optional(S.NonEmptyString),\n    relativePath: S.optional(S.NonEmptyString),\n    path: S.optional(S.NonEmptyString),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/files-domain/value-objects/FileAttributes\"),\n    identifier: \"FileAttributes\",\n    title: \"FileAttributes\",\n    description: \"File attributes schema\",\n  }\n) {}\n\nexport namespace FileAttributes {\n  export type Type = S.Schema.Type<typeof FileAttributes>;\n  export type Encoded = S.Schema.Encoded<typeof FileAttributes>;\n}\n","import * as Effect from \"effect/Effect\";\nimport * as Errors from \"../errors\";\n\nexport const readFileArrayBuffer = Effect.fn(\"readFileArrayBuffer\")(function* (file: File) {\n  return yield* Effect.tryPromise({\n    try: () => file.arrayBuffer(),\n    catch: (e) =>\n      new Errors.FileReadError({\n        message: \"Array buffer could not be read\",\n        cause: e,\n        fileName: file.name,\n        fileType: file.type,\n        fileSize: file.size,\n        phase: \"read\",\n      }),\n  });\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport function getStringValue(value) {\n    return value.map((charCode) => String.fromCharCode(charCode)).join('');\n}\n\nexport function getEncodedString(value) {\n    if (value.length >= 8) {\n        const encoding = getStringValue(value.slice(0, 8));\n\n        if (encoding === 'ASCII\\x00\\x00\\x00') {\n            return getStringValue(value.slice(8));\n        } else if (encoding === 'JIS\\x00\\x00\\x00\\x00\\x00') {\n            return '[JIS encoded text]';\n        } else if (encoding === 'UNICODE\\x00') {\n            return '[Unicode encoded text]';\n        } else if (encoding === '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00') {\n            return '[Undefined encoding]';\n        }\n    }\n\n    return 'Undefined';\n}\n\nexport function getCalculatedGpsValue(value) {\n    return (value[0][0] / value[0][1]) + (value[1][0] / value[1][1]) / 60 + (value[2][0] / value[2][1]) / 3600;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport default {\n    get\n};\n\nfunction get(domParser) {\n    if (domParser) {\n        return domParser;\n    }\n\n    if (typeof DOMParser !== 'undefined') {\n        return new DOMParser();\n    }\n    try {\n        // eslint-disable-next-line no-undef\n        const {DOMParser, onErrorStopParsing} = __non_webpack_require__('@xmldom/xmldom');\n        return new DOMParser({onError: onErrorStopParsing});\n    } catch (error) {\n        return undefined;\n    }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport default {\n    ApertureValue: (value) => Math.pow(Math.sqrt(2), value[0] / value[1]).toFixed(2),\n    ColorSpace(value) {\n        if (value === 1) {\n            return 'sRGB';\n        } else if (value === 0xffff) {\n            return 'Uncalibrated';\n        }\n        return 'Unknown';\n    },\n    ComponentsConfiguration(value) {\n        return value.map((character) => {\n            if (character === 0x31) {\n                return 'Y';\n            } else if (character === 0x32) {\n                return 'Cb';\n            } else if (character === 0x33) {\n                return 'Cr';\n            } else if (character === 0x34) {\n                return 'R';\n            } else if (character === 0x35) {\n                return 'G';\n            } else if (character === 0x36) {\n                return 'B';\n            }\n        }).join('');\n    },\n    Contrast(value) {\n        if (value === 0) {\n            return 'Normal';\n        } else if (value === 1) {\n            return 'Soft';\n        } else if (value === 2) {\n            return 'Hard';\n        }\n        return 'Unknown';\n    },\n    CustomRendered(value) {\n        if (value === 0) {\n            return 'Normal process';\n        } else if (value === 1) {\n            return 'Custom process';\n        }\n        return 'Unknown';\n    },\n    ExposureMode(value) {\n        if (value === 0) {\n            return 'Auto exposure';\n        } else if (value === 1) {\n            return 'Manual exposure';\n        } else if (value === 2) {\n            return 'Auto bracket';\n        }\n        return 'Unknown';\n    },\n    ExposureProgram(value) {\n        if (value === 0) {\n            return 'Undefined';\n        } else if (value === 1) {\n            return 'Manual';\n        } else if (value === 2) {\n            return 'Normal program';\n        } else if (value === 3) {\n            return 'Aperture priority';\n        } else if (value === 4) {\n            return 'Shutter priority';\n        } else if (value === 5) {\n            return 'Creative program';\n        } else if (value === 6) {\n            return 'Action program';\n        } else if (value === 7) {\n            return 'Portrait mode';\n        } else if (value === 8) {\n            return 'Landscape mode';\n        } else if (value === 9) {\n            return 'Bulb';\n        }\n        return 'Unknown';\n    },\n    ExposureTime(value) {\n        if (value[0] / value[1] > 0.25) {\n            const decimal = value[0] / value[1];\n            if (Number.isInteger(decimal)) {\n                return '' + decimal;\n            }\n            return decimal.toFixed(1);\n        }\n        if (value[0] !== 0) {\n            return `1/${Math.round(value[1] / value[0])}`;\n        }\n        return `0/${value[1]}`;\n    },\n    FNumber: (value) => `f/${Number(value[0] / value[1]).toFixed(1)}`,\n    FocalLength: (value) => (value[0] / value[1]) + ' mm',\n    FocalPlaneResolutionUnit(value) {\n        if (value === 2) {\n            return 'inches';\n        } else if (value === 3) {\n            return 'centimeters';\n        } else if (value === 4) {\n            return 'millimeters';\n        }\n        return 'Unknown';\n    },\n    LightSource: (value) => {\n        if (value === 1) {\n            return 'Daylight';\n        } else if (value === 2) {\n            return 'Fluorescent';\n        } else if (value === 3) {\n            return 'Tungsten (incandescent light)';\n        } else if (value === 4) {\n            return 'Flash';\n        } else if (value === 9) {\n            return 'Fine weather';\n        } else if (value === 10) {\n            return 'Cloudy weather';\n        } else if (value === 11) {\n            return 'Shade';\n        } else if (value === 12) {\n            return 'Daylight fluorescent (D 5700  7100K)';\n        } else if (value === 13) {\n            return 'Day white fluorescent (N 4600  5400K)';\n        } else if (value === 14) {\n            return 'Cool white fluorescent (W 3900  4500K)';\n        } else if (value === 15) {\n            return 'White fluorescent (WW 3200  3700K)';\n        } else if (value === 17) {\n            return 'Standard light A';\n        } else if (value === 18) {\n            return 'Standard light B';\n        } else if (value === 19) {\n            return 'Standard light C';\n        } else if (value === 20) {\n            return 'D55';\n        } else if (value === 21) {\n            return 'D65';\n        } else if (value === 22) {\n            return 'D75';\n        } else if (value === 23) {\n            return 'D50';\n        } else if (value === 24) {\n            return 'ISO studio tungsten';\n        } else if (value === 255) {\n            return 'Other light source';\n        }\n        return 'Unknown';\n    },\n    MeteringMode(value) {\n        if (value === 1) {\n            return 'Average';\n        } else if (value === 2) {\n            return 'CenterWeightedAverage';\n        } else if (value === 3) {\n            return 'Spot';\n        } else if (value === 4) {\n            return 'MultiSpot';\n        } else if (value === 5) {\n            return 'Pattern';\n        } else if (value === 6) {\n            return 'Partial';\n        } else if (value === 255) {\n            return 'Other';\n        }\n        return 'Unknown';\n    },\n    ResolutionUnit(value) {\n        if (value === 2) {\n            return 'inches';\n        }\n        if (value === 3) {\n            return 'centimeters';\n        }\n        return 'Unknown';\n    },\n    Saturation(value) {\n        if (value === 0) {\n            return 'Normal';\n        } else if (value === 1) {\n            return 'Low saturation';\n        } else if (value === 2) {\n            return 'High saturation';\n        }\n        return 'Unknown';\n    },\n    FocalLengthIn35mmFilm(value) {\n        if (value === 0) {\n            return 'Unknown';\n        }\n        return value + ' mm';\n    },\n    SceneCaptureType(value) {\n        if (value === 0) {\n            return 'Standard';\n        } else if (value === 1) {\n            return 'Landscape';\n        } else if (value === 2) {\n            return 'Portrait';\n        } else if (value === 3) {\n            return 'Night scene';\n        }\n        return 'Unknown';\n    },\n    Sharpness(value) {\n        if (value === 0) {\n            return 'Normal';\n        } else if (value === 1) {\n            return 'Soft';\n        } else if (value === 2) {\n            return 'Hard';\n        }\n        return 'Unknown';\n    },\n    ShutterSpeedValue(value) {\n        const denominator = Math.pow(2, value[0] / value[1]);\n        if (denominator <= 1) {\n            return `${Math.round(1 / denominator)}`;\n        }\n        return `1/${Math.round(denominator)}`;\n    },\n    WhiteBalance(value) {\n        if (value === 0) {\n            return 'Auto white balance';\n        } else if (value === 1) {\n            return 'Manual white balance';\n        }\n        return 'Unknown';\n    },\n    XResolution: (value) => '' + Math.round(value[0] / value[1]),\n    YResolution: (value) => '' + Math.round(value[0] / value[1])\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport default {\n    0x0004: {\n        'name': 'ShotInfo',\n        'description': (value) => value\n    },\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport default {\n    0x0000: {\n        'name': 'PentaxVersion',\n        'description': (value) => value.join('.')\n    },\n    0x0005: 'PentaxModelID',\n    0x022b: 'LevelInfo'\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport default {\n    get\n};\n\nfunction get() {\n    if (typeof TextDecoder !== 'undefined') {\n        return TextDecoder;\n    }\n\n    return undefined;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nexport default {\n    USE_FILE: true,\n    USE_JFIF: true,\n    USE_PNG_FILE: true,\n    USE_EXIF: true,\n    USE_IPTC: true,\n    USE_XMP: true,\n    USE_ICC: true,\n    USE_MPF: true,\n    USE_PHOTOSHOP: true,\n    USE_THUMBNAIL: true,\n    USE_TIFF: true,\n    USE_JPEG: true,\n    USE_PNG: true,\n    USE_HEIC: true,\n    USE_AVIF: true,\n    USE_WEBP: true,\n    USE_GIF: true,\n    USE_MAKER_NOTES: true\n};\n","export * from \"./errors\";\nexport * from \"./observability\";\nexport * from \"./pipeline\";\nexport * from \"./UploadFileService\";\nexport * from \"./UploadModels\";\nexport * from \"./view\";\n","import Constants from './constants.js';\nimport {getNullTerminatedStringFromDataView, getStringFromDataView} from './utils.js';\n// import {get64BitValue} from './image-header-iso-bmff-utils.js';\nimport {parseItemLocationBox} from './image-header-iso-bmff-iloc.js';\n\n// HEIC and AVIF files are based on the ISO-BMFF format. This file format is\n// built up by boxes. There are boxes and full boxes. All box types have a\n// length (4 or 8 bytes) and a type (4 bytes). Full boxes also have a version\n// (1 byte) and flags (3 bytes). The boxes can be nested. Each box type has its\n// own structure that can be seen in the specification.\n//\n// For metadata we are interested in the meta box. The meta box contains sub\n// boxes. The sub box type iinf has info about which types of metadata are\n// present in the file. The item ID we get from there we then look up in the\n// iloc sub box to get the offset to the real location of the metadata.\n//\n// The ICC profiles is a bit more nested. We have to look in\n// meta > iprp > ipco > colr, and then the whole profile is stored there.\n\n// These are actually 32-bit strings, not random IDs, e.g. \"ftyp\" and \"meta\".\nconst TYPE_FTYP = 0x66747970;\nconst TYPE_IPRP = 0x69707270;\nconst TYPE_META = 0x6d657461;\nconst TYPE_ILOC = 0x696c6f63;\nconst TYPE_IINF = 0x69696e66;\nconst TYPE_INFE = 0x696e6665;\nconst TYPE_IPCO = 0x6970636f;\nconst TYPE_COLR = 0x636f6c72;\n\n// const EXTENSION_TYPE_FDEL = 0x6664656c;\n\nexport const ITEM_INFO_TYPE_EXIF = 0x45786966;\nexport const ITEM_INFO_TYPE_MIME = 0x6d696d65;\nconst ITEM_INFO_TYPE_URI = 0x75726920;\n\n/**\n * Parses a ISO-BMFF box from the provided data view starting at the given offset.\n *\n * @param {DataView} dataView - The DataView to parse.\n * @param {number} offset - The offset at which to start parsing.\n * @returns {Object} The parsed box.\n */\nexport function parseBox(dataView, offset) {\n    const BOX_TYPE_OFFSET = 4;\n    const BOX_MIN_LENGTH = 8;\n    const VERSION_SIZE = 1;\n\n    const {length, contentOffset} = getBoxLength(dataView, offset);\n    if (length < BOX_MIN_LENGTH) {\n        return undefined;\n    }\n\n    const type = dataView.getUint32(offset + BOX_TYPE_OFFSET);\n\n    if (type === TYPE_FTYP) {\n        return parseFileTypeBox(dataView, contentOffset, length);\n    }\n    if (type === TYPE_IPRP) {\n        return parseItemPropertiesBox(dataView, offset, contentOffset, length);\n    }\n    if (type === TYPE_IPCO) {\n        return parseItemPropertyContainerBox(dataView, offset, contentOffset, length);\n    }\n    if (type === TYPE_COLR) {\n        return parseColorInformationBox(dataView, contentOffset, length);\n    }\n\n    // The following are full boxes, also containing version and flags.\n    const version = dataView.getUint8(contentOffset);\n\n    if (type === TYPE_META) {\n        return parseMetadataBox(dataView, offset, contentOffset + VERSION_SIZE, length);\n    }\n    if (type === TYPE_ILOC) {\n        return parseItemLocationBox(dataView, version, contentOffset + VERSION_SIZE, length);\n    }\n    if (type === TYPE_IINF) {\n        return parseItemInformationBox(dataView, offset, version, contentOffset + VERSION_SIZE, length);\n    }\n    if (type === TYPE_INFE) {\n        return parseItemInformationEntryBox(dataView, offset, version, contentOffset + VERSION_SIZE, length);\n    }\n\n    return {\n        // type: getStringFromDataView(dataView, offset + BOX_TYPE_OFFSET, 4),\n        type: undefined,\n        length\n    };\n}\n\n/**\n * @typedef {Object} BoxLength\n * @property {number} length The length of the box including length and type.\n * @property {number} contentOffset\n */\n\n/**\n * @param {DataView} dataView\n * @param {number} offset\n * @returns {BoxLength}\n */\nfunction getBoxLength(dataView, offset) {\n    const BOX_LENGTH_SIZE = 4;\n    const BOX_TYPE_SIZE = 4;\n    const BOX_EXTENDED_SIZE = 8;\n    const BOX_EXTENDED_SIZE_LOW_OFFSET = 12;\n\n    const boxLength = dataView.getUint32(offset);\n    if (extendsToEndOfFile(boxLength)) {\n        return {\n            length: dataView.byteLength - offset,\n            contentOffset: offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE,\n        };\n    }\n    if (hasExtendedSize(boxLength)) {\n        if (hasEmptyHighBits(dataView, offset)) {\n            // It's a bit tricky to handle 64 bit numbers in JavaScript. Let's\n            // wait until there are real-world examples where it is necessary.\n            return {\n                length: dataView.getUint32(offset + BOX_EXTENDED_SIZE_LOW_OFFSET),\n                contentOffset: offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE + BOX_EXTENDED_SIZE,\n            };\n        }\n    }\n\n    return {\n        length: boxLength,\n        contentOffset: offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE,\n    };\n}\n\nfunction extendsToEndOfFile(boxLength) {\n    return boxLength === 0;\n}\n\nfunction hasExtendedSize(boxLength) {\n    return boxLength === 1;\n}\n\nfunction hasEmptyHighBits(dataView, offset) {\n    const BOX_EXTENDED_SIZE_OFFSET = 8;\n    return dataView.getUint32(offset + BOX_EXTENDED_SIZE_OFFSET) === 0;\n}\n\n/**\n * @typedef {Object} Offsets\n * @property {number} tiffHeaderOffset\n * @property {Array<Object>} xmpChunks\n * @property {Array<Object>} iccChunks\n * @property {boolean} hasAppMarkers\n */\n\n/**\n * Finds the offsets of ISO-BMFF-structued data in the provided data view.\n *\n * @param {DataView} dataView - The data view to find offsets in.\n * @returns {Offsets} An object containing the offsets of the TIFF header, XMP chunks, ICC chunks, and a boolean indicating if any of these exist.\n */\nexport function findOffsets(dataView) {\n    if (Constants.USE_EXIF || Constants.USE_XMP || Constants.USE_ICC) {\n        const offsets = {};\n        const metaBox = findMetaBox(dataView);\n\n        if (!metaBox) {\n            return {hasAppMarkers: false};\n        }\n\n        if (Constants.USE_EXIF) {\n            offsets.tiffHeaderOffset = findExifOffset(dataView, metaBox);\n        }\n        if (Constants.USE_XMP) {\n            offsets.xmpChunks = findXmpChunks(metaBox);\n        }\n        if (Constants.USE_ICC) {\n            offsets.iccChunks = findIccChunks(metaBox);\n        }\n        offsets.hasAppMarkers = (offsets.tiffHeaderOffset !== undefined) || (offsets.xmpChunks !== undefined) || (offsets.iccChunks !== undefined);\n        return offsets;\n    }\n\n    return {};\n}\n\nfunction findMetaBox(dataView) {\n    const BOX_LENGTH_SIZE = 4;\n    const BOX_TYPE_SIZE = 4;\n\n    let offset = 0;\n\n    while (offset + BOX_LENGTH_SIZE + BOX_TYPE_SIZE <= dataView.byteLength) {\n        const box = parseBox(dataView, offset);\n\n        if (box === undefined) {\n            break;\n        }\n\n        if (box.type === 'meta') {\n            return box;\n        }\n\n        offset += box.length;\n    }\n\n    return undefined;\n}\n\nfunction findExifOffset(dataView, metaBox) {\n    try {\n        const exifItemId = findIinfExifItemId(metaBox).itemId;\n        const ilocItem = findIlocItem(metaBox, exifItemId);\n        const exifOffset = ilocItem.baseOffset + ilocItem.extents[0].extentOffset;\n        return getTiffHeaderOffset(dataView, exifOffset);\n    } catch (error) {\n        return undefined;\n    }\n}\n\nfunction findIinfExifItemId(metaBox) {\n    return metaBox.subBoxes.find((box) => box.type === 'iinf').itemInfos.find((itemInfo) => itemInfo.itemType === ITEM_INFO_TYPE_EXIF);\n}\n\nfunction findIlocItem(metaBox, itemId) {\n    return metaBox.subBoxes.find((box) => box.type === 'iloc').items.find((item) => item.itemId === itemId);\n}\n\nfunction getTiffHeaderOffset(dataView, exifOffset) {\n    // ISO-BMFF formatted files store the Exif data as an \"Exif block\" where the\n    // first 32 bits is the TIFF header offset.\n    const TIFF_HEADER_OFFSET_SIZE = 4;\n    return exifOffset + TIFF_HEADER_OFFSET_SIZE + dataView.getUint32(exifOffset);\n}\n\nfunction findXmpChunks(metaBox) {\n    try {\n        const xmpItemId = findIinfXmpItemId(metaBox).itemId;\n        const ilocItem = findIlocItem(metaBox, xmpItemId);\n        const ilocItemExtent = findIlocItem(metaBox, xmpItemId).extents[0];\n        return [\n            {\n                dataOffset: ilocItem.baseOffset + ilocItemExtent.extentOffset,\n                length: ilocItemExtent.extentLength,\n            }\n        ];\n    } catch (error) {\n        return undefined;\n    }\n}\n\nfunction findIinfXmpItemId(metaBox) {\n    return metaBox.subBoxes.find((box) => box.type === 'iinf')\n        .itemInfos.find((itemInfo) => itemInfo.itemType === ITEM_INFO_TYPE_MIME && itemInfo.contentType === 'application/rdf+xml');\n}\n\nfunction findIccChunks(metaBox) {\n    // This finds the first ICC chunk, but there could be one for each image\n    // that is embedded in the file. If it turns out we need to match the ICC\n    // chunk to a specific image, we need to check the \"ipma\" in addition to the\n    // \"ipco\" (currently we only extract the \"ipco\" so more code would be\n    // needed).\n    try {\n        const icc = metaBox.subBoxes.find((box) => box.type === 'iprp')\n            .subBoxes.find((box) => box.type === 'ipco')\n            .properties.find((box) => box.type === 'colr')\n            .icc;\n        if (icc) {\n            return [icc];\n        }\n    } catch (error) {\n        // Let it pass through.\n    }\n    return undefined;\n}\n\nfunction parseFileTypeBox(dataView, contentOffset, boxLength) {\n    const MAJOR_BRAND_SIZE = 4;\n    const majorBrand = getStringFromDataView(dataView, contentOffset, MAJOR_BRAND_SIZE);\n\n    return {\n        type: 'ftyp',\n        majorBrand,\n        length: boxLength\n    };\n}\n\nfunction parseItemPropertiesBox(dataView, startOffset, contentOffset, length) {\n    return {\n        type: 'iprp',\n        subBoxes: parseSubBoxes(dataView, contentOffset, length - (contentOffset - startOffset)),\n        length,\n    };\n}\n\nfunction parseItemPropertyContainerBox(dataView, startOffset, contentOffset, length) {\n    return {\n        type: 'ipco',\n        properties: parseSubBoxes(dataView, contentOffset, length - (contentOffset - startOffset)),\n        length,\n    };\n}\n\nfunction parseColorInformationBox(dataView, contentOffset, length) {\n    return {\n        type: 'colr',\n        icc: parseIcc(dataView, contentOffset),\n        length,\n    };\n}\n\nfunction parseIcc(dataView, contentOffset) {\n    const COLOR_TYPE_SIZE = 4;\n\n    const colorType = getStringFromDataView(dataView, contentOffset, COLOR_TYPE_SIZE);\n    if (colorType !== 'prof' && colorType !== 'rICC') {\n        // Support for nclx would require some restructuring for ICC handling.\n        // Probably do it as a separate feature instead of combining with ICC.\n        // Exiftool groups it under QuickTime. The test file test.avif has nclx.\n        return undefined;\n    }\n\n    return {\n        offset: contentOffset + COLOR_TYPE_SIZE,\n        length: dataView.getUint32(contentOffset + COLOR_TYPE_SIZE),\n        chunkNumber: 1,\n        chunksTotal: 1\n    };\n}\n\nfunction parseMetadataBox(dataView, startOffset, contentOffset, length) {\n    const FLAGS_SIZE = 3;\n\n    return {\n        type: 'meta',\n        subBoxes: parseSubBoxes(dataView, contentOffset + FLAGS_SIZE, length - (contentOffset + FLAGS_SIZE - startOffset)),\n        length\n    };\n}\n\n/**\n * @param {DataView} dataView\n * @param {number} offset The offset to start parsing from.\n * @param {number} length The length of all sub boxes combined.\n * @return {Array<Object>}\n */\nfunction parseSubBoxes(dataView, offset, length) {\n    const ACCEPTED_ITEM_INFO_TYPES = [\n        ITEM_INFO_TYPE_EXIF,\n        ITEM_INFO_TYPE_MIME,\n    ];\n\n    const subBoxes = [];\n    let currentOffset = offset;\n    while (currentOffset < offset + length) {\n        const box = parseBox(dataView, currentOffset);\n        if (box === undefined) {\n            break;\n        }\n        if (box.type !== undefined && (box.itemType === undefined || ACCEPTED_ITEM_INFO_TYPES.indexOf(box.itemType) !== -1)) {\n            subBoxes.push(box);\n        }\n        currentOffset += box.length;\n    }\n    return subBoxes;\n}\n\nfunction parseItemInformationBox(dataView, startOffset, version, contentOffset, length) {\n    const {offsets} = getItemInformationBoxOffsetsAndSizes(version, contentOffset);\n\n    return {\n        type: 'iinf',\n        itemInfos: parseSubBoxes(dataView, offsets.itemInfos, length - (offsets.itemInfos - startOffset)),\n        length\n    };\n}\n\nfunction getItemInformationBoxOffsetsAndSizes(version, contentOffset) {\n    const FLAGS_SIZE = 3;\n\n    const offsets = {entryCount: contentOffset + FLAGS_SIZE};\n    const sizes = {};\n\n    if (version === 0) {\n        sizes.entryCount = 2;\n    } else {\n        sizes.entryCount = 4;\n    }\n\n    offsets.itemInfos = offsets.entryCount + sizes.entryCount;\n\n    return {offsets};\n}\n\nfunction parseItemInformationEntryBox(dataView, startOffset, version, contentOffset, length) {\n    const FLAGS_SIZE = 3;\n\n    contentOffset += FLAGS_SIZE;\n    const entry = {type: 'infe', length};\n\n    if (version === 0 || version === 1) {\n        entry.itemId = dataView.getUint16(contentOffset);\n        contentOffset += 2;\n        entry.itemProtectionIndex = dataView.getUint16(contentOffset);\n        contentOffset += 2;\n        entry.itemName = getNullTerminatedStringFromDataView(dataView, contentOffset);\n        contentOffset += entry.itemName.length + 1;\n        // entry.contentType = getNullTerminatedStringFromDataView(dataView, offset);\n        // offset += entry.contentType.length + 1;\n        // Since contentEncoding is optional we need to check the offset against length here.\n        // entry.contentEncoding = getNullTerminatedStringFromDataView(dataView, offset);\n        // offset += entry.contentEncoding.length + 1;\n    }\n    // The following code should be correct but we currently don't need it.\n    // if (version === 1) {\n    //     // Everything here is optional, check the offset against length.\n    //     entry.extensionType = dataView.getUint32(contentOffset);\n    //     contentOffset += 4;\n    //     if (entry.extensionType === EXTENSION_TYPE_FDEL) {\n    //         entry.contentLocation = getNullTerminatedStringFromDataView(dataView, contentOffset);\n    //         contentOffset += entry.contentLocation.length + 1;\n    //         entry.contentMd5 = getNullTerminatedStringFromDataView(dataView, contentOffset);\n    //         contentOffset += entry.contentMd5.length + 1;\n    //         entry.contentLength = get64BitValue(dataView, contentOffset);\n    //         contentOffset += 8;\n    //         entry.transferLength = get64BitValue(dataView, contentOffset);\n    //         contentOffset += 8;\n    //         entry.entryCount = dataView.getUint8(contentOffset);\n    //         contentOffset += 1;\n    //         entry.entries = [];\n    //         for (let i = 0; i < entry.entryCount; i++) {\n    //             entry.entries.push({groupId: dataView.getUint32(contentOffset)});\n    //             contentOffset += 4;\n    //         }\n    //     }\n    // }\n    if (version >= 2) {\n        if (version === 2) {\n            entry.itemId = dataView.getUint16(contentOffset);\n            contentOffset += 2;\n        } else if (version === 3) {\n            entry.itemId = dataView.getUint32(contentOffset);\n            contentOffset += 4;\n        }\n        entry.itemProtectionIndex = dataView.getUint16(contentOffset);\n        contentOffset += 2;\n        // entry.itemTypeAscii = getStringFromDataView(dataView, offset, 4); // For testing.\n        entry.itemType = dataView.getUint32(contentOffset);\n        contentOffset += 4;\n        entry.itemName = getNullTerminatedStringFromDataView(dataView, contentOffset);\n        contentOffset += entry.itemName.length + 1;\n        if (entry.itemType === ITEM_INFO_TYPE_MIME) {\n            entry.contentType = getNullTerminatedStringFromDataView(dataView, contentOffset);\n            contentOffset += entry.contentType.length + 1;\n            if (startOffset + length > contentOffset) {\n                entry.contentEncoding = getNullTerminatedStringFromDataView(dataView, contentOffset);\n                contentOffset += entry.contentEncoding.length + 1;\n            }\n        } else if (entry.itemType === ITEM_INFO_TYPE_URI) {\n            entry.itemUri = getNullTerminatedStringFromDataView(dataView, contentOffset);\n            contentOffset += entry.itemUri.length + 1;\n        }\n    }\n    return entry;\n}\n","import { BS } from \"@beep/schema\";\n\nimport * as S from \"effect/Schema\";\nimport { FileSignature } from \"./FileSignature\";\n\nexport class FileInfo extends S.Class<FileInfo>(\"FileInfo\")(\n  {\n    extension: BS.FileExtension,\n    mimeType: BS.MimeType,\n    description: S.NonEmptyString,\n    signatures: S.Array(FileSignature),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/files-domain/value-objects/file-types/FileInfo\"),\n    identifier: \"FileInfo\",\n    title: \"File Info\",\n    description: \"File information\",\n  }\n) {}\n\nexport namespace FileInfo {\n  export type Type = S.Schema.Type<typeof FileInfo>;\n  export type Encoded = S.Schema.Encoded<typeof FileInfo>;\n}\n\nexport class DetectedFileInfo extends S.Class<DetectedFileInfo>(\"DetectedFileInfo\")(\n  {\n    extension: BS.FileExtension,\n    mimeType: BS.MimeType,\n    description: S.String,\n    signature: FileSignature,\n  },\n  {\n    schemaId: Symbol.for(\"@beep/files-domain/value-objects/file-types/DetectedFileInfo\"),\n    identifier: \"DetectedFileInfo\",\n    title: \"Detected File Info\",\n    description: \"File information detected by signature\",\n  }\n) {}\n\nexport namespace DetectedFileInfo {\n  export type Type = S.Schema.Type<typeof DetectedFileInfo>;\n  export type Encoded = S.Schema.Encoded<typeof DetectedFileInfo>;\n}\n","/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/boundaries.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricBoundariesTypeId: unique symbol = internal.MetricBoundariesTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricBoundariesTypeId = typeof MetricBoundariesTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MetricBoundaries extends Equal.Equal, Pipeable {\n  readonly [MetricBoundariesTypeId]: MetricBoundariesTypeId\n  readonly values: ReadonlyArray<number>\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricBoundaries: (u: unknown) => u is MetricBoundaries = internal.isMetricBoundaries\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: (iterable: Iterable<number>) => MetricBoundaries = internal.fromIterable\n\n/**\n * A helper method to create histogram bucket boundaries for a histogram\n * with linear increasing values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const linear: (\n  options: {\n    readonly start: number\n    readonly width: number\n    readonly count: number\n  }\n) => MetricBoundaries = internal.linear\n\n/**\n * A helper method to create histogram bucket boundaries for a histogram\n * with exponentially increasing values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const exponential: (\n  options: {\n    readonly start: number\n    readonly factor: number\n    readonly count: number\n  }\n) => MetricBoundaries = internal.exponential\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {deferInit, getBase64Image} from './utils.js';\n\n// https://exiftool.org/TagNames/EXIF.html#Compression\nconst COMPRESSION_JPEG = [6, 7, 99];\n\nexport default {\n    get,\n};\n\nfunction get(dataView, thumbnailTags, tiffHeaderOffset) {\n    if (hasJpegThumbnail(thumbnailTags)) {\n        thumbnailTags.type = 'image/jpeg';\n        const offset = tiffHeaderOffset + thumbnailTags.JPEGInterchangeFormat.value;\n        thumbnailTags.image = dataView.buffer.slice(offset, offset + thumbnailTags.JPEGInterchangeFormatLength.value);\n        deferInit(thumbnailTags, 'base64', function () {\n            return getBase64Image(this.image);\n        });\n    }\n\n    // There is a small possibility of thumbnails in TIFF format but they are\n    // not stored as a self-contained image file and would be much more\n    // difficult to extract.\n    // https://exiftool.org/forum/index.php?topic=3273.msg14778#msg14778\n\n    return thumbnailTags;\n}\n\nfunction hasJpegThumbnail(tags) {\n    return tags && ((tags.Compression === undefined) || (COMPRESSION_JPEG.includes(tags.Compression.value)))\n        && tags.JPEGInterchangeFormat && tags.JPEGInterchangeFormat.value\n        && tags.JPEGInterchangeFormatLength && tags.JPEGInterchangeFormatLength.value;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport ByteOrder from './byte-order.js';\n\nconst typeSizes = {\n    1: 1, // BYTE\n    2: 1, // ASCII\n    3: 2, // SHORT\n    4: 4, // LONG\n    5: 8, // RATIONAL\n    7: 1, // UNDEFINED\n    9: 4, // SLONG\n    10: 8, // SRATIONAL\n    13: 4 // IFD\n};\n\nconst tagTypes = {\n    'BYTE': 1,\n    'ASCII': 2,\n    'SHORT': 3,\n    'LONG': 4,\n    'RATIONAL': 5,\n    'UNDEFINED': 7,\n    'SLONG': 9,\n    'SRATIONAL': 10,\n    'IFD': 13\n};\n\nexport default {\n    getAsciiValue,\n    getByteAt,\n    getAsciiAt,\n    getShortAt,\n    getLongAt,\n    getRationalAt,\n    getUndefinedAt,\n    getSlongAt,\n    getSrationalAt,\n    getIfdPointerAt,\n    typeSizes,\n    tagTypes,\n    getTypeSize\n};\n\nfunction getAsciiValue(charArray) {\n    return charArray.map((charCode) => String.fromCharCode(charCode));\n}\n\nfunction getByteAt(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\nfunction getAsciiAt(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\nfunction getShortAt(dataView, offset, byteOrder) {\n    return dataView.getUint16(offset, byteOrder === ByteOrder.LITTLE_ENDIAN);\n}\n\nfunction getLongAt(dataView, offset, byteOrder) {\n    return dataView.getUint32(offset, byteOrder === ByteOrder.LITTLE_ENDIAN);\n}\n\nfunction getRationalAt(dataView, offset, byteOrder) {\n    return [getLongAt(dataView, offset, byteOrder), getLongAt(dataView, offset + 4, byteOrder)];\n}\n\nfunction getUndefinedAt(dataView, offset) {\n    return getByteAt(dataView, offset);\n}\n\nfunction getSlongAt(dataView, offset, byteOrder) {\n    return dataView.getInt32(offset, byteOrder === ByteOrder.LITTLE_ENDIAN);\n}\n\nfunction getSrationalAt(dataView, offset, byteOrder) {\n    return [getSlongAt(dataView, offset, byteOrder), getSlongAt(dataView, offset + 4, byteOrder)];\n}\n\nfunction getIfdPointerAt(dataView, offset, byteOrder) {\n    return getLongAt(dataView, offset, byteOrder);\n}\n\nfunction getTypeSize(typeName) {\n    if (tagTypes[typeName] === undefined) {\n        throw new Error('No such type found.');\n    }\n\n    return typeSizes[tagTypes[typeName]];\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport TextDecoder from './text-decoder.js';\n\nconst TAG_HEADER_SIZE = 5;\n\nexport default {\n    decode,\n    TAG_HEADER_SIZE\n};\n\nfunction decode(encoding, tagValue) {\n    const Decoder = TextDecoder.get();\n    if ((typeof Decoder !== 'undefined') && (encoding !== undefined)) {\n        try {\n            return new Decoder(encoding).decode(tagValue instanceof DataView ? tagValue.buffer : Uint8Array.from(tagValue));\n        } catch (error) {\n            // Pass through and fall back to ASCII decoding.\n        }\n    }\n\n    const stringValue = tagValue.map((charCode) => String.fromCharCode(charCode)).join('');\n    return decodeAsciiValue(stringValue);\n}\n\nfunction decodeAsciiValue(asciiValue) {\n    try {\n        return decodeURIComponent(escape(asciiValue));\n    } catch (error) {\n        return asciiValue;\n    }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport TagNamesCommon from './tag-names-common.js';\n\nconst FOCAL_PLANE_RESOLUTION_UNIT = {\n    INCHES: 2,\n    CENTIMETERS: 3,\n    MILLIMETERS: 4\n};\n\nconst UNIT_FACTORS = {\n    INCHES_TO_MM: 25.4, // 1 inch = 25.4 mm\n    CM_TO_MM: 10, // 1 cm = 10 mm\n    MM_TO_MM: 1 // Already in mm\n};\n\nexport default {\n    get,\n};\n\nexport {FOCAL_PLANE_RESOLUTION_UNIT};\n\nfunction get(tags, expanded) {\n    const compositeTags = {};\n    let hasCompositeTags = false;\n\n    const focalLength = getTagValue(tags, 'exif', 'FocalLength', expanded);\n    const focalPlaneXResolution = getTagValue(tags, 'exif', 'FocalPlaneXResolution', expanded);\n    const focalPlaneYResolution = getTagValue(tags, 'exif', 'FocalPlaneYResolution', expanded);\n    const focalPlaneResolutionUnit = getTagValue(tags, 'exif', 'FocalPlaneResolutionUnit', expanded);\n    const imageWidth = getTagValue(tags, 'file', 'Image Width', expanded);\n    const imageHeight = getTagValue(tags, 'file', 'Image Height', expanded);\n    const focalLengthIn35mmFilm = getTagValue(tags, 'exif', 'FocalLengthIn35mmFilm', expanded)\n        || getFocalLengthIn35mmFilmValue(focalPlaneXResolution, focalPlaneYResolution, focalPlaneResolutionUnit, imageWidth, imageHeight, focalLength);\n\n    if (focalLengthIn35mmFilm) {\n        compositeTags.FocalLength35efl = {\n            value: focalLengthIn35mmFilm,\n            description: TagNamesCommon.FocalLengthIn35mmFilm(focalLengthIn35mmFilm)\n        };\n        hasCompositeTags = true;\n    }\n\n    const scaleFactorTo35mmEquivalent = getScaleFactorTo35mmEquivalent(focalLength, focalLengthIn35mmFilm);\n    if (scaleFactorTo35mmEquivalent) {\n        compositeTags.ScaleFactorTo35mmEquivalent = scaleFactorTo35mmEquivalent;\n        hasCompositeTags = true;\n    }\n\n    const fieldOfView = getFieldOfView(focalLengthIn35mmFilm);\n    if (fieldOfView) {\n        compositeTags.FieldOfView = fieldOfView;\n        hasCompositeTags = true;\n    }\n\n    if (hasCompositeTags) {\n        return compositeTags;\n    }\n\n    return undefined;\n}\n\nfunction getTagValue(tags, group, tagName, expanded) {\n    if (expanded && tags[group] && tags[group][tagName]) {\n        return tags[group][tagName].value;\n    }\n    if (!expanded && tags[tagName]) {\n        return tags[tagName].value;\n    }\n    return undefined;\n}\n\n/**\n * Calculates the 35mm equivalent focal length from camera sensor data.\n *\n * This function determines how the field of view of a camera's sensor compares to a\n * standard 35mm film frame (36mm  24mm). The conversion involves:\n *\n * 1. **Sensor dimensions**: Calculated from image pixel count and focal plane\n *    resolution (pixels per unit area)\n * 2. **Crop factor**: The ratio between the sensor diagonal and the standard\n *    35mm diagonal (43.27mm)\n * 3. **Equivalent focal length**: Actual focal length multiplied by the crop factor\n *\n * For example, a 50mm lens on a camera with a 1.5x crop factor gives an equivalent\n * field of view of a 75mm lens on a 35mm camera. This doesn't change the actual\n * focal length or depth of field characteristics, only the angle of view.\n */\nfunction getFocalLengthIn35mmFilmValue(focalPlaneXResolution, focalPlaneYResolution, focalPlaneResolutionUnit, imageWidth, imageHeight, focalLength) {\n    // Standard 35mm film diagonal is 43.27mm (calculated from 36mm x 24mm frame)\n    const DIAGONAL_35mm = 43.27;\n\n    if (focalPlaneXResolution && focalPlaneYResolution && focalPlaneResolutionUnit && imageWidth && imageHeight && focalLength) {\n        try {\n            let resolutionUnitFactor;\n            switch (focalPlaneResolutionUnit) {\n                case FOCAL_PLANE_RESOLUTION_UNIT.INCHES:\n                    resolutionUnitFactor = UNIT_FACTORS.INCHES_TO_MM;\n                    break;\n                case FOCAL_PLANE_RESOLUTION_UNIT.CENTIMETERS:\n                    resolutionUnitFactor = UNIT_FACTORS.CM_TO_MM;\n                    break;\n                case FOCAL_PLANE_RESOLUTION_UNIT.MILLIMETERS:\n                    resolutionUnitFactor = UNIT_FACTORS.MM_TO_MM;\n                    break;\n                default:\n                    return undefined;\n            }\n\n            const focalPlaneXResolutionMm = focalPlaneXResolution[0] / focalPlaneXResolution[1] * resolutionUnitFactor;\n            const focalPlaneYResolutionMm = focalPlaneYResolution[0] / focalPlaneYResolution[1] * resolutionUnitFactor;\n\n            const sensorWidthMm = imageWidth / focalPlaneXResolutionMm;\n            const sensorHeightMm = imageHeight / focalPlaneYResolutionMm;\n\n            const sensorDiagonal = Math.sqrt(sensorWidthMm ** 2 + sensorHeightMm ** 2);\n            const focalLength35mm = (focalLength[0] / focalLength[1]) * (DIAGONAL_35mm / sensorDiagonal);\n            return focalLength35mm;\n        } catch (error) {\n            // Ignore.\n        }\n    }\n    return undefined;\n}\n\nfunction getScaleFactorTo35mmEquivalent(focalLength, focalLengthIn35mmFilm) {\n    if (focalLength && focalLengthIn35mmFilm) {\n        try {\n            const value = focalLengthIn35mmFilm / (focalLength[0] / focalLength[1]);\n            return {\n                value,\n                description: value.toFixed(1),\n            };\n        } catch (error) {\n            // Ignore.\n        }\n    }\n    return undefined;\n}\n\nfunction getFieldOfView(focalLengthIn35mmFilm) {\n    const FULL_FRAME_SENSOR_WIDTH_MM = 36;\n\n    if (focalLengthIn35mmFilm) {\n        try {\n            const value = 2 * Math.atan(FULL_FRAME_SENSOR_WIDTH_MM / (2 * focalLengthIn35mmFilm)) * (180 / Math.PI);\n            return {\n                value,\n                description: value.toFixed(1) + ' deg',\n            };\n        } catch (error) {\n            // Ignore.\n        }\n    }\n    return undefined;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport DataViewWrapper from './dataview.js';\n\nexport function getDataView(data, byteOffset, byteLength) {\n    try {\n        return new DataView(data, byteOffset, byteLength);\n    } catch (error) {\n        return new DataViewWrapper(data, byteOffset, byteLength);\n    }\n}\n\nexport function getStringFromDataView(dataView, offset, length) {\n    const chars = [];\n    for (let i = 0; i < length && offset + i < dataView.byteLength; i++) {\n        chars.push(dataView.getUint8(offset + i));\n    }\n    return getStringValueFromArray(chars);\n}\n\nexport function getNullTerminatedStringFromDataView(dataView, offset) {\n    const chars = [];\n    let i = 0;\n    while (offset + i < dataView.byteLength) {\n        const char = dataView.getUint8(offset + i);\n        if (char === 0) {\n            break;\n        }\n        chars.push(char);\n        i++;\n    }\n    return getStringValueFromArray(chars);\n}\n\nexport function getUnicodeStringFromDataView(dataView, offset, length) {\n    const chars = [];\n    for (let i = 0; i < length && offset + i < dataView.byteLength; i += 2) {\n        chars.push(dataView.getUint16(offset + i));\n    }\n    if (chars[chars.length - 1] === 0) {\n        chars.pop();\n    }\n    return getStringValueFromArray(chars);\n}\n\nexport function getPascalStringFromDataView(dataView, offset) {\n    const size = dataView.getUint8(offset);\n    const string = getStringFromDataView(dataView, offset + 1, size);\n    return [size, string];\n}\n\nexport function getStringValueFromArray(charArray) {\n    return charArray.map((charCode) => String.fromCharCode(charCode)).join('');\n}\n\nexport function getCharacterArray(string) {\n    return string.split('').map((character) => character.charCodeAt(0));\n}\n\nexport function objectAssign() {\n    for (let i = 1; i < arguments.length; i++) {\n        for (const property in arguments[i]) {\n            arguments[0][property] = arguments[i][property];\n        }\n    }\n\n    return arguments[0];\n}\n\nexport function deferInit(object, key, initializer) {\n    let initialized = false;\n    Object.defineProperty(object, key, {\n        get() {\n            if (!initialized) {\n                initialized = true;\n                Object.defineProperty(object, key, {\n                    configurable: true,\n                    enumerable: true,\n                    value: initializer.apply(object),\n                    writable: true\n                });\n            }\n            return object[key];\n        },\n        configurable: true,\n        enumerable: true\n    });\n}\n\nexport function getBase64Image(image) {\n    if (typeof btoa !== 'undefined') {\n        if (typeof image === 'string') {\n            // This only happens during the build tests using Node 16+ (npm run test:build).\n            return btoa(image);\n        }\n        // IE11- does not implement reduce on the Uint8Array prototype.\n        return btoa(Array.prototype.reduce.call(new Uint8Array(image), (data, byte) => data + String.fromCharCode(byte), ''));\n    }\n    if (typeof Buffer === 'undefined') {\n        return undefined;\n    }\n    if (typeof Buffer.from !== 'undefined') { // eslint-disable-line no-undef\n        return Buffer.from(image).toString('base64'); // eslint-disable-line no-undef\n    }\n    return (new Buffer(image)).toString('base64'); // eslint-disable-line no-undef\n}\n\nexport function dataUriToBuffer(dataUri) {\n    const data = dataUri.substring(dataUri.indexOf(',') + 1);\n\n    if (dataUri.indexOf(';base64') !== -1) {\n        if (typeof atob !== 'undefined') {\n            return Uint8Array.from(atob(data), (char) => char.charCodeAt(0)).buffer;\n        }\n        if (typeof Buffer === 'undefined') {\n            return undefined;\n        }\n        if (typeof Buffer.from !== 'undefined') { // eslint-disable-line no-undef\n            return Buffer.from(data, 'base64'); // eslint-disable-line no-undef\n        }\n        return new Buffer(data, 'base64'); // eslint-disable-line no-undef\n    }\n\n    const decodedData = decodeURIComponent(data);\n    if (typeof Buffer !== 'undefined') {\n        if (typeof Buffer.from !== 'undefined') { // eslint-disable-line no-undef\n            return Buffer.from(decodedData); // eslint-disable-line no-undef\n        }\n        return new Buffer(decodedData); // eslint-disable-line no-undef\n    }\n    return Uint8Array.from(decodedData, (char) => char.charCodeAt(0)).buffer;\n}\n\nexport function padStart(string, length, character) {\n    const padding = strRepeat(character, length - string.length);\n    return padding + string;\n}\n\nexport function parseFloatRadix(string, radix) {\n    return parseInt(string.replace('.', ''), radix)\n        / Math.pow(radix, (string.split('.')[1] || '').length);\n}\n\nexport function strRepeat(string, num) {\n    return new Array(num + 1).join(string);\n}\n\nexport const COMPRESSION_METHOD_NONE = undefined;\nexport const COMPRESSION_METHOD_DEFLATE = 0;\n\nexport function decompress(dataView, compressionMethod, encoding, returnType = 'string') {\n    if (compressionMethod === COMPRESSION_METHOD_DEFLATE) {\n        if (typeof DecompressionStream === 'function') {\n            const decompressionStream = new DecompressionStream('deflate');\n            const decompressedStream = new Blob([dataView]).stream().pipeThrough(decompressionStream);\n            if (returnType === 'dataview') {\n                return new Response(decompressedStream).arrayBuffer().then((arrayBuffer) => new DataView(arrayBuffer));\n            }\n            return new Response(decompressedStream).arrayBuffer()\n                .then((buffer) => new TextDecoder(encoding).decode(buffer));\n        }\n    }\n    if (compressionMethod !== undefined) {\n        return Promise.reject(`Unknown compression method ${compressionMethod}.`);\n    }\n    return dataView;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringFromDataView} from './utils.js';\n\nexport const iccTags = {\n    'desc': {\n        'name': 'ICC Description',\n    },\n    'cprt': {\n        'name': 'ICC Copyright',\n    },\n    'dmdd': {\n        'name': 'ICC Device Model Description',\n    },\n    'vued': {\n        'name': 'ICC Viewing Conditions Description',\n    },\n    'dmnd': {\n        'name': 'ICC Device Manufacturer for Display',\n    },\n    'tech': {\n        'name': 'Technology',\n    },\n};\n\nexport const iccProfile = {\n    4: {\n        'name': 'Preferred CMM type',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4),\n        'description': (value) => value !== null ? toCompany(value) : '',\n    },\n    8: {\n        'name': 'Profile Version',\n        'value': (dataView, offset) => {\n            return (dataView.getUint8(offset)).toString(10) + '.'\n            + (dataView.getUint8(offset + 1) >> 4).toString(10) + '.'\n            + (dataView.getUint8(offset + 1) % 16).toString(10);\n        }\n    },\n    12: {\n        'name': 'Profile/Device class',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4),\n        'description': (value) => {\n            switch (value.toLowerCase()) {\n                case 'scnr': return 'Input Device profile';\n                case 'mntr': return 'Display Device profile';\n                case 'prtr': return 'Output Device profile';\n                case 'link': return 'DeviceLink profile';\n                case 'abst': return 'Abstract profile';\n                case 'spac': return 'ColorSpace profile';\n                case 'nmcl': return 'NamedColor profile';\n                case 'cenc': return 'ColorEncodingSpace profile';\n                case 'mid ': return 'MultiplexIdentification profile';\n                case 'mlnk': return 'MultiplexLink profile';\n                case 'mvis': return 'MultiplexVisualization profile';\n                default: return value;\n            }\n        }\n    },\n    16: {\n        'name': 'Color Space',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4)\n    },\n    20: {\n        'name': 'Connection Space',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4)\n    },\n    24: {\n        'name': 'ICC Profile Date',\n        'value': (dataView, offset) => parseDate(dataView, offset).toISOString()\n    },\n    36: {\n        'name': 'ICC Signature',\n        'value': (dataView, offset) => sliceToString(dataView.buffer.slice(offset, offset + 4))\n    },\n    40: {\n        'name': 'Primary Platform',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4),\n        'description': (value) => toCompany(value)\n    },\n    48: {\n        'name': 'Device Manufacturer',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4),\n        'description': (value) => toCompany(value)\n    },\n    52: {\n        'name': 'Device Model Number',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4)\n    },\n    64: {\n        'name': 'Rendering Intent',\n        'value': (dataView, offset) => dataView.getUint32(offset),\n        'description': (value) => {\n            switch (value) {\n                case 0: return 'Perceptual';\n                case 1: return 'Relative Colorimetric';\n                case 2: return 'Saturation';\n                case 3: return 'Absolute Colorimetric';\n                default: return value;\n            }\n        }\n    },\n\n    80: {\n        'name': 'Profile Creator',\n        'value': (dataView, offset) => getStringFromDataView(dataView, offset, 4)\n    },\n};\n\nfunction parseDate(dataView, offset) {\n    const year = dataView.getUint16(offset);\n    const month = dataView.getUint16(offset + 2) - 1;\n    const day = dataView.getUint16(offset + 4);\n    const hours = dataView.getUint16(offset + 6);\n    const minutes = dataView.getUint16(offset + 8);\n    const seconds = dataView.getUint16(offset + 10);\n    return new Date(Date.UTC(year, month, day, hours, minutes, seconds));\n}\n\nfunction sliceToString(slice) {\n    return String.fromCharCode.apply(null, new Uint8Array(slice));\n}\n\nfunction toCompany(value) {\n    switch (value.toLowerCase()) {\n        case 'appl': return 'Apple';\n        case 'adbe': return 'Adobe';\n        case 'msft': return 'Microsoft';\n        case 'sunw': return 'Sun Microsystems';\n        case 'sgi': return 'Silicon Graphics';\n        case 'tgnt': return 'Taligent';\n        default: return value;\n    }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Types from './types.js';\n\nexport default {\n    read\n};\n\nfunction read(dataView, fileDataOffset) {\n    return {\n        'Image Width': getImageWidth(dataView, fileDataOffset),\n        'Image Height': getImageHeight(dataView, fileDataOffset),\n        'Bit Depth': getBitDepth(dataView, fileDataOffset),\n        'Color Type': getColorType(dataView, fileDataOffset),\n        'Compression': getCompression(dataView, fileDataOffset),\n        'Filter': getFilter(dataView, fileDataOffset),\n        'Interlace': getInterlace(dataView, fileDataOffset)\n    };\n}\n\nfunction getImageWidth(dataView, fileDataOffset) {\n    const OFFSET = 0;\n    const SIZE = 4;\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getLongAt(dataView, fileDataOffset);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getImageHeight(dataView, fileDataOffset) {\n    const OFFSET = 4;\n    const SIZE = 4;\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getLongAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getBitDepth(dataView, fileDataOffset) {\n    const OFFSET = 8;\n    const SIZE = 1;\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: `${value}`\n    };\n}\n\nfunction getColorType(dataView, fileDataOffset) {\n    const OFFSET = 9;\n    const SIZE = 1;\n    const COLOR_TYPES = {\n        0: 'Grayscale',\n        2: 'RGB',\n        3: 'Palette',\n        4: 'Grayscale with Alpha',\n        6: 'RGB with Alpha'\n    };\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: COLOR_TYPES[value] || 'Unknown'\n    };\n}\n\nfunction getCompression(dataView, fileDataOffset) {\n    const OFFSET = 10;\n    const SIZE = 1;\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: value === 0 ? 'Deflate/Inflate' : 'Unknown'\n    };\n}\n\nfunction getFilter(dataView, fileDataOffset) {\n    const OFFSET = 11;\n    const SIZE = 1;\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: value === 0 ? 'Adaptive' : 'Unknown'\n    };\n}\n\nfunction getInterlace(dataView, fileDataOffset) {\n    const OFFSET = 12;\n    const SIZE = 1;\n    const INTERLACE_TYPES = {\n        0: 'Noninterlaced',\n        1: 'Adam7 Interlace'\n    };\n\n    if (fileDataOffset + OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: INTERLACE_TYPES[value] || 'Unknown'\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Types from './types.js';\n\nexport default {\n    read\n};\n\nconst IMAGE_WIDTH_OFFSET = 4;\nconst IMAGE_HEIGHT_OFFSET = 7;\n\n// https://developers.google.com/speed/webp/docs/riff_container#extended_file_format\nfunction read(dataView, chunkOffset) {\n    const tags = {};\n\n    const flags = Types.getByteAt(dataView, chunkOffset);\n\n    tags['Alpha'] = getAlpha(flags);\n    tags['Animation'] = getAnimation(flags);\n    tags['ImageWidth'] = getThreeByteValue(dataView, chunkOffset + IMAGE_WIDTH_OFFSET);\n    tags['ImageHeight'] = getThreeByteValue(dataView, chunkOffset + IMAGE_HEIGHT_OFFSET);\n\n    return tags;\n}\n\nfunction getAlpha(flags) {\n    const value = flags & 0x10;\n    return {\n        value: value ? 1 : 0,\n        description: value ? 'Yes' : 'No'\n    };\n}\n\nfunction getAnimation(flags) {\n    const value = flags & 0x02;\n    return {\n        value: value ? 1 : 0,\n        description: value ? 'Yes' : 'No'\n    };\n}\n\nfunction getThreeByteValue(dataView, offset) {\n    // Values are stored little-endian.\n    const value = Types.getByteAt(dataView, offset)\n        + 256 * Types.getByteAt(dataView, offset + 1)\n        + 256 * 256 * Types.getByteAt(dataView, offset + 2)\n        + 1; // Value is 1-based, i.e. a value of 7 means 8px.\n\n    return {\n        value,\n        description: value + 'px'\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringValue} from './tag-names-utils.js';\n\nexport default {\n    'iptc': {\n        0x0100: {\n            'name': 'Model Version',\n            'description': (value) => {\n                return ((value[0] << 8) + value[1]).toString();\n            }\n        },\n        0x0105: {\n            'name': 'Destination',\n            'repeatable': true\n        },\n        0x0114: {\n            'name': 'File Format',\n            'description': (value) => {\n                return ((value[0] << 8) + value[1]).toString();\n            }\n        },\n        0x0116: {\n            'name': 'File Format Version',\n            'description': (value) => {\n                return ((value[0] << 8) + value[1]).toString();\n            }\n        },\n        0x011e: 'Service Identifier',\n        0x0128: 'Envelope Number',\n        0x0132: 'Product ID',\n        0x013c: 'Envelope Priority',\n        0x0146: {\n            'name': 'Date Sent',\n            'description': getCreationDate\n        },\n        0x0150: {\n            'name': 'Time Sent',\n            'description': getCreationTime\n        },\n        0x015a: {\n            'name': 'Coded Character Set',\n            'description': getEncodingName,\n            'encoding_name': getEncodingName,\n        },\n        0x0164: 'UNO',\n        0x0178: {\n            'name': 'ARM Identifier',\n            'description': (value) => {\n                return ((value[0] << 8) + value[1]).toString();\n            }\n        },\n        0x017a: {\n            'name': 'ARM Version',\n            'description': (value) => {\n                return ((value[0] << 8) + value[1]).toString();\n            }\n        },\n        0x0200: {\n            'name': 'Record Version',\n            'description': (value) => {\n                return ((value[0] << 8) + value[1]).toString();\n            }\n        },\n        0x0203: 'Object Type Reference',\n        0x0204: 'Object Attribute Reference',\n        0x0205: 'Object Name',\n        0x0207: 'Edit Status',\n        0x0208: {\n            'name': 'Editorial Update',\n            'description': (value) => {\n                if (getStringValue(value) === '01') {\n                    return 'Additional Language';\n                }\n                return 'Unknown';\n            }\n        },\n        0x020a: 'Urgency',\n        0x020c: {\n            'name': 'Subject Reference',\n            'repeatable': true,\n            'description': (value) => {\n                const parts = getStringValue(value).split(':');\n                return parts[2] + (parts[3] ? '/' + parts[3] : '') + (parts[4] ? '/' + parts[4] : '');\n            }\n        },\n        0x020f: 'Category',\n        0x0214: {\n            'name': 'Supplemental Category',\n            'repeatable': true\n        },\n        0x0216: 'Fixture Identifier',\n        0x0219: {\n            'name': 'Keywords',\n            'repeatable': true\n        },\n        0x021a: {\n            'name': 'Content Location Code',\n            'repeatable': true\n        },\n        0x021b: {\n            'name': 'Content Location Name',\n            'repeatable': true\n        },\n        0x021e: 'Release Date',\n        0x0223: 'Release Time',\n        0x0225: 'Expiration Date',\n        0x0226: 'Expiration Time',\n        0x0228: 'Special Instructions',\n        0x022a: {\n            'name': 'Action Advised',\n            'description': (value) => {\n                const string = getStringValue(value);\n                if (string === '01') {\n                    return 'Object Kill';\n                } else if (string === '02') {\n                    return 'Object Replace';\n                } else if (string === '03') {\n                    return 'Object Append';\n                } else if (string === '04') {\n                    return 'Object Reference';\n                }\n                return 'Unknown';\n            }\n        },\n        0x022d: {\n            'name': 'Reference Service',\n            'repeatable': true\n        },\n        0x022f: {\n            'name': 'Reference Date',\n            'repeatable': true\n        },\n        0x0232: {\n            'name': 'Reference Number',\n            'repeatable': true\n        },\n        0x0237: {\n            'name': 'Date Created',\n            'description': getCreationDate\n        },\n        0x023c: {\n            'name': 'Time Created',\n            'description': getCreationTime\n        },\n        0x023e: {\n            'name': 'Digital Creation Date',\n            'description': getCreationDate\n        },\n        0x023f: {\n            'name': 'Digital Creation Time',\n            'description': getCreationTime\n        },\n        0x0241: 'Originating Program',\n        0x0246: 'Program Version',\n        0x024b: {\n            'name': 'Object Cycle',\n            'description': (value) => {\n                const string = getStringValue(value);\n                if (string === 'a') {\n                    return 'morning';\n                } else if (string === 'p') {\n                    return 'evening';\n                } else if (string === 'b') {\n                    return 'both';\n                }\n                return 'Unknown';\n            }\n        },\n        0x0250: {\n            'name': 'By-line',\n            'repeatable': true\n        },\n        0x0255: {\n            'name': 'By-line Title',\n            'repeatable': true\n        },\n        0x025a: 'City',\n        0x025c: 'Sub-location',\n        0x025f: 'Province/State',\n        0x0264: 'Country/Primary Location Code',\n        0x0265: 'Country/Primary Location Name',\n        0x0267: 'Original Transmission Reference',\n        0x0269: 'Headline',\n        0x026e: 'Credit',\n        0x0273: 'Source',\n        0x0274: 'Copyright Notice',\n        0x0276: {\n            'name': 'Contact',\n            'repeatable': true\n        },\n        0x0278: 'Caption/Abstract',\n        0x027a: {\n            'name': 'Writer/Editor',\n            'repeatable': true\n        },\n        0x027d: {\n            'name': 'Rasterized Caption',\n            'description': (value) => value\n        },\n        0x0282: 'Image Type',\n        0x0283: {\n            'name': 'Image Orientation',\n            'description': (value) => {\n                const string = getStringValue(value);\n                if (string === 'P') {\n                    return 'Portrait';\n                } else if (string === 'L') {\n                    return 'Landscape';\n                } else if (string === 'S') {\n                    return 'Square';\n                }\n                return 'Unknown';\n            }\n        },\n        0x0287: 'Language Identifier',\n        0x0296: {\n            'name': 'Audio Type',\n            'description': (value) => {\n                const stringValue = getStringValue(value);\n                const character0 = stringValue.charAt(0);\n                const character1 = stringValue.charAt(1);\n                let description = '';\n\n                if (character0 === '1') {\n                    description += 'Mono';\n                } else if (character0 === '2') {\n                    description += 'Stereo';\n                }\n\n                if (character1 === 'A') {\n                    description += ', actuality';\n                } else if (character1 === 'C') {\n                    description += ', question and answer session';\n                } else if (character1 === 'M') {\n                    description += ', music, transmitted by itself';\n                } else if (character1 === 'Q') {\n                    description += ', response to a question';\n                } else if (character1 === 'R') {\n                    description += ', raw sound';\n                } else if (character1 === 'S') {\n                    description += ', scener';\n                } else if (character1 === 'V') {\n                    description += ', voicer';\n                } else if (character1 === 'W') {\n                    description += ', wrap';\n                }\n\n                if (description !== '') {\n                    return description;\n                }\n                return stringValue;\n            }\n        },\n        0x0297: {\n            'name': 'Audio Sampling Rate',\n            'description': (value) => parseInt(getStringValue(value), 10) + ' Hz'\n        },\n        0x0298: {\n            'name': 'Audio Sampling Resolution',\n            'description': (value) => {\n                const bits = parseInt(getStringValue(value), 10);\n                return bits + (bits === 1 ? ' bit' : ' bits');\n            }\n        },\n        0x0299: {\n            'name': 'Audio Duration',\n            'description': (value) => {\n                const duration = getStringValue(value);\n                if (duration.length >= 6) {\n                    return duration.substr(0, 2) + ':' + duration.substr(2, 2) + ':' + duration.substr(4, 2);\n                }\n                return duration;\n            }\n        },\n        0x029a: 'Audio Outcue',\n        0x02ba: 'Short Document ID',\n        0x02bb: 'Unique Document ID',\n        0x02bc: 'Owner ID',\n        0x02c8: {\n            'name': (value) => {\n                if (value.length === 2) {\n                    return 'ObjectData Preview File Format';\n                }\n                return 'Record 2 destination';\n            },\n            'description': (value) => {\n                if (value.length === 2) {\n                    const intValue = (value[0] << 8) + value[1];\n                    if (intValue === 0) {\n                        return 'No ObjectData';\n                    } else if (intValue === 1) {\n                        return 'IPTC-NAA Digital Newsphoto Parameter Record';\n                    } else if (intValue === 2) {\n                        return 'IPTC7901 Recommended Message Format';\n                    } else if (intValue === 3) {\n                        return 'Tagged Image File Format (Adobe/Aldus Image data)';\n                    } else if (intValue === 4) {\n                        return 'Illustrator (Adobe Graphics data)';\n                    } else if (intValue === 5) {\n                        return 'AppleSingle (Apple Computer Inc)';\n                    } else if (intValue === 6) {\n                        return 'NAA 89-3 (ANPA 1312)';\n                    } else if (intValue === 7) {\n                        return 'MacBinary II';\n                    } else if (intValue === 8) {\n                        return 'IPTC Unstructured Character Oriented File Format (UCOFF)';\n                    } else if (intValue === 9) {\n                        return 'United Press International ANPA 1312 variant';\n                    } else if (intValue === 10) {\n                        return 'United Press International Down-Load Message';\n                    } else if (intValue === 11) {\n                        return 'JPEG File Interchange (JFIF)';\n                    } else if (intValue === 12) {\n                        return 'Photo-CD Image-Pac (Eastman Kodak)';\n                    } else if (intValue === 13) {\n                        return 'Microsoft Bit Mapped Graphics File [*.BMP]';\n                    } else if (intValue === 14) {\n                        return 'Digital Audio File [*.WAV] (Microsoft & Creative Labs)';\n                    } else if (intValue === 15) {\n                        return 'Audio plus Moving Video [*.AVI] (Microsoft)';\n                    } else if (intValue === 16) {\n                        return 'PC DOS/Windows Executable Files [*.COM][*.EXE]';\n                    } else if (intValue === 17) {\n                        return 'Compressed Binary File [*.ZIP] (PKWare Inc)';\n                    } else if (intValue === 18) {\n                        return 'Audio Interchange File Format AIFF (Apple Computer Inc)';\n                    } else if (intValue === 19) {\n                        return 'RIFF Wave (Microsoft Corporation)';\n                    } else if (intValue === 20) {\n                        return 'Freehand (Macromedia/Aldus)';\n                    } else if (intValue === 21) {\n                        return 'Hypertext Markup Language \"HTML\" (The Internet Society)';\n                    } else if (intValue === 22) {\n                        return 'MPEG 2 Audio Layer 2 (Musicom), ISO/IEC';\n                    } else if (intValue === 23) {\n                        return 'MPEG 2 Audio Layer 3, ISO/IEC';\n                    } else if (intValue === 24) {\n                        return 'Portable Document File (*.PDF) Adobe';\n                    } else if (intValue === 25) {\n                        return 'News Industry Text Format (NITF)';\n                    } else if (intValue === 26) {\n                        return 'Tape Archive (*.TAR)';\n                    } else if (intValue === 27) {\n                        return 'Tidningarnas Telegrambyr NITF version (TTNITF DTD)';\n                    } else if (intValue === 28) {\n                        return 'Ritzaus Bureau NITF version (RBNITF DTD)';\n                    } else if (intValue === 29) {\n                        return 'Corel Draw [*.CDR]';\n                    }\n                    return `Unknown format ${intValue}`;\n                }\n                return getStringValue(value);\n            }\n        },\n        0x02c9: {\n            'name': 'ObjectData Preview File Format Version',\n            'description': (value, tags) => {\n                // Format ID, Version ID, Version Description\n                const formatVersions = {\n                    '00': {'00': '1'},\n                    '01': {'01': '1', '02': '2', '03': '3', '04': '4'},\n                    '02': {'04': '4'},\n                    '03': {'01': '5.0', '02': '6.0'},\n                    '04': {'01': '1.40'},\n                    '05': {'01': '2'},\n                    '06': {'01': '1'},\n                    '11': {'01': '1.02'},\n                    '20': {'01': '3.1', '02': '4.0', '03': '5.0', '04': '5.5'},\n                    '21': {'02': '2.0'}\n                };\n                const stringValue = getStringValue(value);\n\n                if (tags['ObjectData Preview File Format']) {\n                    const objectDataPreviewFileFormat = getStringValue(tags['ObjectData Preview File Format'].value);\n                    if (formatVersions[objectDataPreviewFileFormat]\n                        && formatVersions[objectDataPreviewFileFormat][stringValue]) {\n                        return formatVersions[objectDataPreviewFileFormat][stringValue];\n                    }\n                }\n\n                return stringValue;\n            }\n        },\n        0x02ca: 'ObjectData Preview Data',\n        0x070a: {\n            'name': 'Size Mode',\n            'description': (value) => {\n                return (value[0]).toString();\n            }\n        },\n        0x0714: {\n            'name': 'Max Subfile Size',\n            'description': (value) => {\n                let n = 0;\n                for (let i = 0; i < value.length; i++) {\n                    n = (n << 8) + value[i];\n                }\n                return n.toString();\n            }\n        },\n        0x075a: {\n            'name': 'ObjectData Size Announced',\n            'description': (value) => {\n                let n = 0;\n                for (let i = 0; i < value.length; i++) {\n                    n = (n << 8) + value[i];\n                }\n                return n.toString();\n            }\n        },\n        0x075f: {\n            'name': 'Maximum ObjectData Size',\n            'description': (value) => {\n                let n = 0;\n                for (let i = 0; i < value.length; i++) {\n                    n = (n << 8) + value[i];\n                }\n                return n.toString();\n            }\n        }\n    }\n};\n\nfunction getCreationDate(value) {\n    const date = getStringValue(value);\n\n    if (date.length >= 8) {\n        return date.substr(0, 4) + '-' + date.substr(4, 2) + '-' + date.substr(6, 2);\n    }\n\n    return date;\n}\n\nfunction getCreationTime(value) {\n    const time = getStringValue(value);\n    let parsedTime = time;\n\n    if (time.length >= 6) {\n        parsedTime = time.substr(0, 2) + ':' + time.substr(2, 2) + ':' + time.substr(4, 2);\n        if (time.length === 11) {\n            parsedTime += time.substr(6, 1) + time.substr(7, 2) + ':' + time.substr(9, 2);\n        }\n    }\n\n    return parsedTime;\n}\n\nfunction getEncodingName(value) {\n    const string = getStringValue(value);\n    if (string === '\\x1b%G') {\n        return 'UTF-8';\n    } else if (string === '\\x1b%5') {\n        return 'Windows-1252';\n    } else if (string === '\\x1b%/G') {\n        return 'UTF-8 Level 1';\n    } else if (string === '\\x1b%/H') {\n        return 'UTF-8 Level 2';\n    } else if (string === '\\x1b%/I') {\n        return 'UTF-8 Level 3';\n    } else if (string === '\\x1B/A') {\n        return 'ISO-8859-1';\n    } else if (string === '\\x1B/B') {\n        return 'ISO-8859-2';\n    } else if (string === '\\x1B/C') {\n        return 'ISO-8859-3';\n    } else if (string === '\\x1B/D') {\n        return 'ISO-8859-4';\n    } else if (string === '\\x1B/@') {\n        return 'ISO-8859-5';\n    } else if (string === '\\x1B/G') {\n        return 'ISO-8859-6';\n    } else if (string === '\\x1B/F') {\n        return 'ISO-8859-7';\n    } else if (string === '\\x1B/H') {\n        return 'ISO-8859-8';\n    }\n    return 'Unknown';\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {parseBox, findOffsets} from './image-header-iso-bmff.js';\n\nexport default {\n    isHeicFile,\n    findHeicOffsets\n};\n\n/**\n * Checks if the provided data view represents a HEIC/HEIF file.\n *\n * @param {DataView} dataView - The data view to check.\n * @returns {boolean} True if the data view represents a HEIC/HEIF file, false otherwise.\n */\nfunction isHeicFile(dataView) {\n    if (!dataView) {\n        return false;\n    }\n\n    const HEIC_MAJOR_BRANDS = ['heic', 'heix', 'hevc', 'hevx', 'heim', 'heis', 'hevm', 'hevs', 'mif1'];\n\n    try {\n        const headerBox = parseBox(dataView, 0);\n        return headerBox && HEIC_MAJOR_BRANDS.indexOf(headerBox.majorBrand) !== -1;\n    } catch (error) {\n        return false;\n    }\n}\n\n/**\n * Finds the offsets of a HEIC file in the provided data view.\n *\n * @param {DataView} dataView - The data view to find offsets in.\n * @returns {Object} An object containing the offsets of the TIFF header, XMP chunks, ICC chunks, and a boolean indicating if any of these exist.\n */\nfunction findHeicOffsets(dataView) {\n    return findOffsets(dataView);\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringFromDataView} from './utils.js';\n\nexport default {\n    isGifFile,\n    findOffsets\n};\n\nconst GIF_SIGNATURE_SIZE = 6;\nconst GIF_SIGNATURES = ['GIF87a', 'GIF89a'];\n\nfunction isGifFile(dataView) {\n    return !!dataView && GIF_SIGNATURES.includes(getStringFromDataView(dataView, 0, GIF_SIGNATURE_SIZE));\n}\n\nfunction findOffsets() {\n    return {\n        gifHeaderOffset: 0\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringFromDataView} from './utils.js';\n\nexport default {\n    isXMLFile,\n    findOffsets\n};\n\nconst XML_MARKER_OFFSET = 0;\nconst XML_MARKER = '<?xpacket begin';\n\nfunction isXMLFile(dataView) {\n    return !!dataView && getStringFromDataView(dataView, XML_MARKER_OFFSET, XML_MARKER.length) === XML_MARKER;\n}\n\nfunction findOffsets(dataView) {\n    const xmpChunks = [];\n    xmpChunks.push({dataOffset: XML_MARKER_OFFSET, length: dataView.byteLength});\n    return {\n        xmpChunks,\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Types from './types.js';\n\nexport default {\n    read\n};\n\nfunction read(dataView, fileDataOffset) {\n    const length = getLength(dataView, fileDataOffset);\n    const numberOfColorComponents = getNumberOfColorComponents(dataView, fileDataOffset, length);\n    return {\n        'Bits Per Sample': getDataPrecision(dataView, fileDataOffset, length),\n        'Image Height': getImageHeight(dataView, fileDataOffset, length),\n        'Image Width': getImageWidth(dataView, fileDataOffset, length),\n        'Color Components': numberOfColorComponents,\n        'Subsampling': numberOfColorComponents && getSubsampling(dataView, fileDataOffset, numberOfColorComponents.value, length)\n    };\n}\n\nfunction getLength(dataView, fileDataOffset) {\n    return Types.getShortAt(dataView, fileDataOffset);\n}\n\nfunction getDataPrecision(dataView, fileDataOffset, length) {\n    const OFFSET = 2;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: '' + value\n    };\n}\n\nfunction getImageHeight(dataView, fileDataOffset, length) {\n    const OFFSET = 3;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getShortAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getImageWidth(dataView, fileDataOffset, length) {\n    const OFFSET = 5;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getShortAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getNumberOfColorComponents(dataView, fileDataOffset, length) {\n    const OFFSET = 7;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, fileDataOffset + OFFSET);\n    return {\n        value,\n        description: '' + value\n    };\n}\n\nfunction getSubsampling(dataView, fileDataOffset, numberOfColorComponents, length) {\n    const OFFSET = 8;\n    const SIZE = 3 * numberOfColorComponents;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const components = [];\n\n    for (let i = 0; i < numberOfColorComponents; i++) {\n        const componentOffset = fileDataOffset + OFFSET + i * 3;\n        components.push([\n            Types.getByteAt(dataView, componentOffset),\n            Types.getByteAt(dataView, componentOffset + 1),\n            Types.getByteAt(dataView, componentOffset + 2)\n        ]);\n    }\n\n    return {\n        value: components,\n        description: components.length > 1 ? getComponentIds(components) + getSamplingType(components) : ''\n    };\n}\n\nfunction getComponentIds(components) {\n    const ids = {\n        0x01: 'Y',\n        0x02: 'Cb',\n        0x03: 'Cr',\n        0x04: 'I',\n        0x05: 'Q',\n    };\n\n    return components.map((compontent) => ids[compontent[0]]).join('');\n}\n\nfunction getSamplingType(components) {\n    const types = {\n        0x11: '4:4:4 (1 1)',\n        0x12: '4:4:0 (1 2)',\n        0x14: '4:4:1 (1 4)',\n        0x21: '4:2:2 (2 1)',\n        0x22: '4:2:0 (2 2)',\n        0x24: '4:2:1 (2 4)',\n        0x41: '4:1:1 (4 1)',\n        0x42: '4:1:0 (4 2)'\n    };\n\n    if (components.length === 0 || components[0][1] === undefined || types[components[0][1]] === undefined) {\n        return '';\n    }\n\n    return types[components[0][1]];\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Types from './types.js';\n\nexport default {\n    read\n};\n\nfunction read(dataView, jfifDataOffset) {\n    const length = getLength(dataView, jfifDataOffset);\n    const thumbnailWidth = getThumbnailWidth(dataView, jfifDataOffset, length);\n    const thumbnailHeight = getThumbnailHeight(dataView, jfifDataOffset, length);\n    const tags = {\n        'JFIF Version': getVersion(dataView, jfifDataOffset, length),\n        'Resolution Unit': getResolutionUnit(dataView, jfifDataOffset, length),\n        'XResolution': getXResolution(dataView, jfifDataOffset, length),\n        'YResolution': getYResolution(dataView, jfifDataOffset, length),\n        'JFIF Thumbnail Width': thumbnailWidth,\n        'JFIF Thumbnail Height': thumbnailHeight\n    };\n\n    if (thumbnailWidth !== undefined && thumbnailHeight !== undefined) {\n        const thumbnail = getThumbnail(dataView, jfifDataOffset, 3 * thumbnailWidth.value * thumbnailHeight.value, length);\n        if (thumbnail) {\n            tags['JFIF Thumbnail'] = thumbnail;\n        }\n    }\n\n    for (const tagName in tags) {\n        if (tags[tagName] === undefined) {\n            delete tags[tagName];\n        }\n    }\n\n    return tags;\n}\n\nfunction getLength(dataView, jfifDataOffset) {\n    return Types.getShortAt(dataView, jfifDataOffset);\n}\n\nfunction getVersion(dataView, jfifDataOffset, length) {\n    const OFFSET = 7;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const majorVersion = Types.getByteAt(dataView, jfifDataOffset + OFFSET);\n    const minorVersion = Types.getByteAt(dataView, jfifDataOffset + OFFSET + 1);\n    return {\n        value: majorVersion * 0x100 + minorVersion,\n        description: majorVersion + '.' + minorVersion\n    };\n}\n\nfunction getResolutionUnit(dataView, jfifDataOffset, length) {\n    const OFFSET = 9;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, jfifDataOffset + OFFSET);\n    return {\n        value,\n        description: getResolutionUnitDescription(value)\n    };\n}\n\nfunction getResolutionUnitDescription(value) {\n    if (value === 0) {\n        return 'None';\n    }\n    if (value === 1) {\n        return 'inches';\n    }\n    if (value === 2) {\n        return 'cm';\n    }\n    return 'Unknown';\n}\n\nfunction getXResolution(dataView, jfifDataOffset, length) {\n    const OFFSET = 10;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getShortAt(dataView, jfifDataOffset + OFFSET);\n    return {\n        value,\n        description: '' + value\n    };\n}\n\nfunction getYResolution(dataView, jfifDataOffset, length) {\n    const OFFSET = 12;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getShortAt(dataView, jfifDataOffset + OFFSET);\n    return {\n        value,\n        description: '' + value\n    };\n}\n\nfunction getThumbnailWidth(dataView, jfifDataOffset, length) {\n    const OFFSET = 14;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, jfifDataOffset + OFFSET);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getThumbnailHeight(dataView, jfifDataOffset, length) {\n    const OFFSET = 15;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > length) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, jfifDataOffset + OFFSET);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getThumbnail(dataView, jfifDataOffset, thumbnailLength, length) {\n    const OFFSET = 16;\n\n    if (thumbnailLength === 0 || OFFSET + thumbnailLength > length) {\n        return undefined;\n    }\n\n    const value = dataView.buffer.slice(jfifDataOffset + OFFSET, jfifDataOffset + OFFSET + thumbnailLength);\n    return {\n        value,\n        description: '<24-bit RGB pixel data>'\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport TagNamesCommon from './tag-names-common.js';\n\nexport default {\n    'tiff:Orientation'(value) {\n        if (value === '1') {\n            return 'Horizontal (normal)';\n        }\n        if (value === '2') {\n            return 'Mirror horizontal';\n        }\n        if (value === '3') {\n            return 'Rotate 180';\n        }\n        if (value === '4') {\n            return 'Mirror vertical';\n        }\n        if (value === '5') {\n            return 'Mirror horizontal and rotate 270 CW';\n        }\n        if (value === '6') {\n            return 'Rotate 90 CW';\n        }\n        if (value === '7') {\n            return 'Mirror horizontal and rotate 90 CW';\n        }\n        if (value === '8') {\n            return 'Rotate 270 CW';\n        }\n        return value;\n    },\n    'tiff:ResolutionUnit': (value) => TagNamesCommon.ResolutionUnit(parseInt(value, 10)),\n    'tiff:XResolution': (value) => fraction(TagNamesCommon.XResolution, value),\n    'tiff:YResolution': (value) => fraction(TagNamesCommon.YResolution, value),\n    'exif:ApertureValue': (value) => fraction(TagNamesCommon.ApertureValue, value),\n    'exif:GPSLatitude': calculateGPSValue,\n    'exif:GPSLongitude': calculateGPSValue,\n    'exif:FNumber': (value) => fraction(TagNamesCommon.FNumber, value),\n    'exif:FocalLength': (value) => fraction(TagNamesCommon.FocalLength, value),\n    'exif:FocalPlaneResolutionUnit': (value) => TagNamesCommon.FocalPlaneResolutionUnit(parseInt(value, 10)),\n    'exif:ColorSpace': (value) => TagNamesCommon.ColorSpace(parseNumber(value)),\n    'exif:ComponentsConfiguration'(value, description) {\n        if (/^\\d, \\d, \\d, \\d$/.test(description)) {\n            const numbers = description.split(', ').map((number) => number.charCodeAt(0));\n            return TagNamesCommon.ComponentsConfiguration(numbers);\n        }\n        return description;\n    },\n    'exif:Contrast': (value) => TagNamesCommon.Contrast(parseInt(value, 10)),\n    'exif:CustomRendered': (value) => TagNamesCommon.CustomRendered(parseInt(value, 10)),\n    'exif:ExposureMode': (value) => TagNamesCommon.ExposureMode(parseInt(value, 10)),\n    'exif:ExposureProgram': (value) => TagNamesCommon.ExposureProgram(parseInt(value, 10)),\n    'exif:ExposureTime'(value) {\n        if (isFraction(value)) {\n            return TagNamesCommon.ExposureTime(value.split('/').map((number) => parseInt(number, 10)));\n        }\n        return value;\n    },\n    'exif:MeteringMode': (value) => TagNamesCommon.MeteringMode(parseInt(value, 10)),\n    'exif:Saturation': (value) => TagNamesCommon.Saturation(parseInt(value, 10)),\n    'exif:SceneCaptureType': (value) => TagNamesCommon.SceneCaptureType(parseInt(value, 10)),\n    'exif:Sharpness': (value) => TagNamesCommon.Sharpness(parseInt(value, 10)),\n    'exif:ShutterSpeedValue': (value) => fraction(TagNamesCommon.ShutterSpeedValue, value),\n    'exif:WhiteBalance': (value) => TagNamesCommon.WhiteBalance(parseInt(value, 10))\n};\n\nfunction fraction(func, value) {\n    if (isFraction(value)) {\n        return func(value.split('/'));\n    }\n    return value;\n}\n\nfunction parseNumber(value) {\n    if (value.substring(0, 2) === '0x') {\n        return parseInt(value.substring(2), 16);\n    }\n    return parseInt(value, 10);\n}\n\nfunction isFraction(value) {\n    return /^-?\\d+\\/-?\\d+$/.test(value);\n}\n\nfunction calculateGPSValue(value) {\n    const [degreesString, minutesString] = value.split(',');\n    if ((degreesString !== undefined) && (minutesString !== undefined)) {\n        const degrees = parseFloat(degreesString);\n        const minutes = parseFloat(minutesString);\n        const ref = minutesString.charAt(minutesString.length - 1);\n        if ((!Number.isNaN(degrees)) && (!Number.isNaN(minutes))) {\n            return '' + (degrees + minutes / 60) + ref;\n        }\n    }\n    return value;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport TagNamesCommon from './tag-names-common.js';\n\nexport default {\n    0x000b: 'ProcessingSoftware',\n    0x00fe: {\n        name: 'SubfileType',\n        description: (value) => ({\n            0x0: 'Full-resolution image',\n            0x1: 'Reduced-resolution image',\n            0x2: 'Single page of multi-page image',\n            0x3: 'Single page of multi-page reduced-resolution image',\n            0x4: 'Transparency mask',\n            0x5: 'Transparency mask of reduced-resolution image',\n            0x6: 'Transparency mask of multi-page image',\n            0x7: 'Transparency mask of reduced-resolution multi-page image',\n            0x10001: 'Alternate reduced-resolution image',\n            0xffffffff: 'Invalid'\n        })[value] || 'Unknown'\n    },\n    0x00ff: {\n        name: 'OldSubfileType',\n        description: (value) => ({\n            0: 'Full-resolution image',\n            1: 'Reduced-resolution image',\n            2: 'Single page of multi-page image'\n        })[value] || 'Unknown'\n    },\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageLength',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0107: {\n        name: 'Thresholding',\n        description: (value) => ({\n            1: 'No dithering or halftoning',\n            2: 'Ordered dither or halfton',\n            3: 'Randomized dither'\n        })[value] || 'Unknown'\n    },\n    0x0108: 'CellWidth',\n    0x0109: 'CellLength',\n    0x010a: {\n        name: 'FillOrder',\n        description: (value) => ({\n            1: 'Normal',\n            2: 'Reversed'\n        })[value] || 'Unknown'\n    },\n    0x010d: 'DocumentName',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0111: 'StripOffsets',\n    0x0112: {\n        name: 'Orientation',\n        description: (value) => {\n            if (value === 1) {\n                return 'top-left';\n            }\n            if (value === 2) {\n                return 'top-right';\n            }\n            if (value === 3) {\n                return 'bottom-right';\n            }\n            if (value === 4) {\n                return 'bottom-left';\n            }\n            if (value === 5) {\n                return 'left-top';\n            }\n            if (value === 6) {\n                return 'right-top';\n            }\n            if (value === 7) {\n                return 'right-bottom';\n            }\n            if (value === 8) {\n                return 'left-bottom';\n            }\n            return 'Undefined';\n        }\n    },\n    0x0115: 'SamplesPerPixel',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0118: 'MinSampleValue',\n    0x0119: 'MaxSampleValue',\n    0x011a: {\n        'name': 'XResolution',\n        'description': TagNamesCommon.XResolution\n    },\n    0x011b: {\n        'name': 'YResolution',\n        'description': TagNamesCommon.YResolution\n    },\n    0x011c: 'PlanarConfiguration',\n    0x011d: 'PageName',\n    0x011e: {\n        'name': 'XPosition',\n        'description': (value) => {\n            return '' + Math.round(value[0] / value[1]);\n        }\n    },\n    0x011f: {\n        'name': 'YPosition',\n        'description': (value) => {\n            return '' + Math.round(value[0] / value[1]);\n        }\n    },\n    0x0122: {\n        name: 'GrayResponseUnit',\n        description: (value) => ({\n            1: '0.1',\n            2: '0.001',\n            3: '0.0001',\n            4: '1e-05',\n            5: '1e-06'\n        })[value] || 'Unknown'\n    },\n    0x0128: {\n        name: 'ResolutionUnit',\n        description: TagNamesCommon.ResolutionUnit\n    },\n    0x0129: 'PageNumber',\n    0x012d: 'TransferFunction',\n    0x0131: 'Software',\n    0x0132: 'DateTime',\n    0x013b: 'Artist',\n    0x013c: 'HostComputer',\n    0x013d: 'Predictor',\n    0x013e: {\n        'name': 'WhitePoint',\n        'description': (values) => {\n            return values.map((value) => `${value[0]}/${value[1]}`).join(', ');\n        }\n    },\n    0x013f: {\n        'name': 'PrimaryChromaticities',\n        'description': (values) => {\n            return values.map((value) => `${value[0]}/${value[1]}`).join(', ');\n        }\n    },\n    0x0141: 'HalftoneHints',\n    0x0142: 'TileWidth',\n    0x0143: 'TileLength',\n    0x014a: 'A100DataOffset',\n    0x014c: {\n        name: 'InkSet',\n        description: (value) => ({\n            1: 'CMYK',\n            2: 'Not CMYK'\n        })[value] || 'Unknown'\n    },\n    0x0151: 'TargetPrinter',\n    0x0152: {\n        name: 'ExtraSamples',\n        description: (value) => ({\n            0: 'Unspecified',\n            1: 'Associated Alpha',\n            2: 'Unassociated Alpha',\n        })[value] || 'Unknown'\n    },\n    0x0153: {\n        name: 'SampleFormat',\n        description: (value) => {\n            const formats = {\n                1: 'Unsigned',\n                2: 'Signed',\n                3: 'Float',\n                4: 'Undefined',\n                5: 'Complex int',\n                6: 'Complex float',\n            };\n            if (!Array.isArray(value)) {\n                return 'Unknown';\n            }\n            return value.map((sample) => formats[sample] || 'Unknown').join(', ');\n        }\n    },\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x0211: {\n        'name': 'YCbCrCoefficients',\n        'description': (values) => {\n            return values.map((value) => '' + value[0] / value[1]).join('/');\n        }\n    },\n    0x0212: 'YCbCrSubSampling',\n    0x0213: {\n        name: 'YCbCrPositioning',\n        description: (value) => {\n            if (value === 1) {\n                return 'centered';\n            }\n            if (value === 2) {\n                return 'co-sited';\n            }\n            return 'undefined ' + value;\n        }\n    },\n    0x0214: {\n        'name': 'ReferenceBlackWhite',\n        'description': (values) => {\n            return values.map((value) => '' + value[0] / value[1]).join(', ');\n        }\n    },\n    0x02bc: 'ApplicationNotes',\n    0x4746: 'Rating',\n    0x4749: 'RatingPercent',\n    0x8298: {\n        name: 'Copyright',\n        description: (value) => value.join('; ')\n    },\n    0x830e: 'PixelScale',\n    0x83bb: 'IPTC-NAA',\n    0x8480: 'IntergraphMatrix',\n    0x8482: 'ModelTiePoint',\n    0x8546: 'SEMInfo',\n    0x85d8: 'ModelTransform',\n    0x8649: 'PhotoshopSettings',\n    0x8769: 'Exif IFD Pointer',\n    0x8773: 'ICC_Profile',\n    0x87af: 'GeoTiffDirectory',\n    0x87b0: 'GeoTiffDoubleParams',\n    0x87b1: 'GeoTiffAsciiParams',\n    0x8825: 'GPS Info IFD Pointer',\n    0x9c9b: {\n        name: 'XPTitle',\n        description: decodeXPValue,\n    },\n    0x9c9c: {\n        name: 'XPComment',\n        description: decodeXPValue\n    },\n    0x9c9d: {\n        name: 'XPAuthor',\n        description: decodeXPValue,\n    },\n    0x9c9e: {\n        name: 'XPKeywords',\n        description: decodeXPValue,\n    },\n    0x9c9f: {\n        name: 'XPSubject',\n        description: decodeXPValue,\n    },\n    0xa480: 'GDALMetadata',\n    0xa481: 'GDALNoData',\n    0xc4a5: 'PrintIM',\n    0xc613: 'DNGBackwardVersion',\n    0xc614: 'UniqueCameraModel',\n    0xc615: 'LocalizedCameraModel',\n    0xc621: 'ColorMatrix1',\n    0xc622: 'ColorMatrix2',\n    0xc623: 'CameraCalibration1',\n    0xc624: 'CameraCalibration2',\n    0xc625: 'ReductionMatrix1',\n    0xc626: 'ReductionMatrix2',\n    0xc627: 'AnalogBalance',\n    0xc628: 'AsShotNeutral',\n    0xc629: 'AsShotWhiteXY',\n    0xc62a: 'BaselineExposure',\n    0xc62b: 'BaselineNoise',\n    0xc62c: 'BaselineSharpness',\n    0xc62e: 'LinearResponseLimit',\n    0xc62f: 'CameraSerialNumber',\n    0xc630: 'DNGLensInfo',\n    0xc633: 'ShadowScale',\n    0xc635: {\n        name: 'MakerNoteSafety',\n        description: (value) => ({\n            0: 'Unsafe',\n            1: 'Safe'\n        })[value] || 'Unknown'\n    },\n    0xc65a: {\n        name: 'CalibrationIlluminant1',\n        description: TagNamesCommon['LightSource']\n    },\n    0xc65b: {\n        name: 'CalibrationIlluminant2',\n        description: TagNamesCommon['LightSource']\n    },\n    0xc65d: 'RawDataUniqueID',\n    0xc68b: 'OriginalRawFileName',\n    0xc68c: 'OriginalRawFileData',\n    0xc68f: 'AsShotICCProfile',\n    0xc690: 'AsShotPreProfileMatrix',\n    0xc691: 'CurrentICCProfile',\n    0xc692: 'CurrentPreProfileMatrix',\n    0xc6bf: 'ColorimetricReference',\n    0xc6c5: 'SRawType',\n    0xc6d2: 'PanasonicTitle',\n    0xc6d3: 'PanasonicTitle2',\n    0xc6f3: 'CameraCalibrationSig',\n    0xc6f4: 'ProfileCalibrationSig',\n    0xc6f5: 'ProfileIFD',\n    0xc6f6: 'AsShotProfileName',\n    0xc6f8: 'ProfileName',\n    0xc6f9: 'ProfileHueSatMapDims',\n    0xc6fa: 'ProfileHueSatMapData1',\n    0xc6fb: 'ProfileHueSatMapData2',\n    0xc6fc: 'ProfileToneCurve',\n    0xc6fd: {\n        name: 'ProfileEmbedPolicy',\n        description: (value) => ({\n            0: 'Allow Copying',\n            1: 'Embed if Used',\n            2: 'Never Embed',\n            3: 'No Restrictions'\n        })[value] || 'Unknown'\n    },\n    0xc6fe: 'ProfileCopyright',\n    0xc714: 'ForwardMatrix1',\n    0xc715: 'ForwardMatrix2',\n    0xc716: 'PreviewApplicationName',\n    0xc717: 'PreviewApplicationVersion',\n    0xc718: 'PreviewSettingsName',\n    0xc719: 'PreviewSettingsDigest',\n    0xc71a: {\n        name: 'PreviewColorSpace',\n        description: (value) => ({\n            1: 'Gray Gamma 2.2',\n            2: 'sRGB',\n            3: 'Adobe RGB',\n            4: 'ProPhoto RGB'\n        })[value] || 'Unknown'\n    },\n    0xc71b: 'PreviewDateTime',\n    0xc71c: 'RawImageDigest',\n    0xc71d: 'OriginalRawFileDigest',\n    0xc725: 'ProfileLookTableDims',\n    0xc726: 'ProfileLookTableData',\n    0xc763: 'TimeCodes',\n    0xc764: 'FrameRate',\n    0xc772: 'TStop',\n    0xc789: 'ReelName',\n    0xc791: 'OriginalDefaultFinalSize',\n    0xc792: 'OriginalBestQualitySize',\n    0xc793: 'OriginalDefaultCropSize',\n    0xc7a1: 'CameraLabel',\n    0xc7a3: {\n        name: 'ProfileHueSatMapEncoding',\n        description: (value) => ({\n            0: 'Linear',\n            1: 'sRGB'\n        })[value] || 'Unknown'\n    },\n    0xc7a4: {\n        name: 'ProfileLookTableEncoding',\n        description: (value) => ({\n            0: 'Linear',\n            1: 'sRGB'\n        })[value] || 'Unknown'\n    },\n    0xc7a5: 'BaselineExposureOffset',\n    0xc7a6: {\n        name: 'DefaultBlackRender',\n        description: (value) => ({\n            0: 'Auto',\n            1: 'None'\n        })[value] || 'Unknown'\n    },\n    0xc7a7: 'NewRawImageDigest',\n    0xc7a8: 'RawToPreviewGain'\n};\n\nfunction decodeXPValue(value) {\n    // The XP tags are encoded as UCS-2 which uses two bytes per character but\n    // it's close to UTF-16 so we can use that to decode them.\n    // https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n    const decodedValue = new TextDecoder('utf-16').decode(new Uint8Array(value));\n    // Some softwares pad the string with null characters so we remove them.\n    return decodedValue.replace(/\\u0000+$/, ''); // eslint-disable-line no-control-regex\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getEncodedString, getCalculatedGpsValue} from './tag-names-utils.js';\n\nexport default {\n    0x0000: {\n        'name': 'GPSVersionID',\n        'description': (value) => {\n            if (value[0] === 2 && value[1] === 2 && value[2] === 0 && value[3] === 0) {\n                return 'Version 2.2';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0001: {\n        'name': 'GPSLatitudeRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'N') {\n                return 'North latitude';\n            } else if (ref === 'S') {\n                return 'South latitude';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0002: {\n        'name': 'GPSLatitude',\n        'description': getCalculatedGpsValue\n    },\n    0x0003: {\n        'name': 'GPSLongitudeRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'E') {\n                return 'East longitude';\n            } else if (ref === 'W') {\n                return 'West longitude';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0004: {\n        'name': 'GPSLongitude',\n        'description': getCalculatedGpsValue\n    },\n    0x0005: {\n        'name': 'GPSAltitudeRef',\n        'description': (value) => {\n            if (value === 0) {\n                return 'Sea level';\n            } else if (value === 1) {\n                return 'Sea level reference (negative value)';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0006: {\n        'name': 'GPSAltitude',\n        'description': (value) => {\n            return (value[0] / value[1]) + ' m';\n        }\n    },\n    0x0007: {\n        'name': 'GPSTimeStamp',\n        'description': (values) => {\n            return values.map(([numerator, denominator]) => {\n                const num = numerator / denominator;\n                if (/^\\d(\\.|$)/.test(`${num}`)) {\n                    return `0${num}`;\n                }\n                return num;\n            }).join(':');\n        }\n    },\n    0x0008: 'GPSSatellites',\n    0x0009: {\n        'name': 'GPSStatus',\n        'description': (value) => {\n            const status = value.join('');\n            if (status === 'A') {\n                return 'Measurement in progress';\n            } else if (status === 'V') {\n                return 'Measurement Interoperability';\n            }\n            return 'Unknown';\n        }\n    },\n    0x000a: {\n        'name': 'GPSMeasureMode',\n        'description': (value) => {\n            const mode = value.join('');\n            if (mode === '2') {\n                return '2-dimensional measurement';\n            } else if (mode === '3') {\n                return '3-dimensional measurement';\n            }\n            return 'Unknown';\n        }\n    },\n    0x000b: 'GPSDOP',\n    0x000c: {\n        'name': 'GPSSpeedRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'K') {\n                return 'Kilometers per hour';\n            } else if (ref === 'M') {\n                return 'Miles per hour';\n            } else if (ref === 'N') {\n                return 'Knots';\n            }\n            return 'Unknown';\n        }\n    },\n    0x000d: 'GPSSpeed',\n    0x000e: {\n        'name': 'GPSTrackRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'T') {\n                return 'True direction';\n            } else if (ref === 'M') {\n                return 'Magnetic direction';\n            }\n            return 'Unknown';\n        }\n    },\n    0x000f: 'GPSTrack',\n    0x0010: {\n        'name': 'GPSImgDirectionRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'T') {\n                return 'True direction';\n            } else if (ref === 'M') {\n                return 'Magnetic direction';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: {\n        'name': 'GPSDestLatitudeRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'N') {\n                return 'North latitude';\n            } else if (ref === 'S') {\n                return 'South latitude';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0014: {\n        'name': 'GPSDestLatitude',\n        'description': (value) => {\n            return (value[0][0] / value[0][1]) + (value[1][0] / value[1][1]) / 60 + (value[2][0] / value[2][1]) / 3600;\n        }\n    },\n    0x0015: {\n        'name': 'GPSDestLongitudeRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'E') {\n                return 'East longitude';\n            } else if (ref === 'W') {\n                return 'West longitude';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0016: {\n        'name': 'GPSDestLongitude',\n        'description': (value) => {\n            return (value[0][0] / value[0][1]) + (value[1][0] / value[1][1]) / 60 + (value[2][0] / value[2][1]) / 3600;\n        }\n    },\n    0x0017: {\n        'name': 'GPSDestBearingRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'T') {\n                return 'True direction';\n            } else if (ref === 'M') {\n                return 'Magnetic direction';\n            }\n            return 'Unknown';\n        }\n    },\n    0x0018: 'GPSDestBearing',\n    0x0019: {\n        'name': 'GPSDestDistanceRef',\n        'description': (value) => {\n            const ref = value.join('');\n            if (ref === 'K') {\n                return 'Kilometers';\n            } else if (ref === 'M') {\n                return 'Miles';\n            } else if (ref === 'N') {\n                return 'Knots';\n            }\n            return 'Unknown';\n        }\n    },\n    0x001a: 'GPSDestDistance',\n    0x001b: {\n        'name': 'GPSProcessingMethod',\n        'description': getEncodedString\n    },\n    0x001c: {\n        'name': 'GPSAreaInformation',\n        'description': getEncodedString\n    },\n    0x001d: 'GPSDateStamp',\n    0x001e: {\n        'name': 'GPSDifferential',\n        'description': (value) => {\n            if (value === 0) {\n                return 'Measurement without differential correction';\n            } else if (value === 1) {\n                return 'Differential correction applied';\n            }\n            return 'Unknown';\n        }\n    },\n    0x001f: 'GPSHPositioningError'\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringValue} from './tag-names-utils.js';\n\nexport default {\n    0x0001: 'InteroperabilityIndex',\n    0x0002: {\n        name: 'InteroperabilityVersion',\n        description: (value) => getStringValue(value)\n    },\n    0x1000: 'RelatedImageFileFormat',\n    0x1001: 'RelatedImageWidth',\n    0x1002: 'RelatedImageHeight'\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringValue} from './tag-names-utils.js';\n\nexport default {\n    0xb000: {\n        'name': 'MPFVersion',\n        'description': (value) => getStringValue(value)\n    },\n    0xb001: 'NumberOfImages',\n    0xb002: 'MPEntry',\n    0xb003: 'ImageUIDList',\n    0xb004: 'TotalFrames'\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\nimport {iccTags, iccProfile} from './icc-tag-names.js';\nimport {getStringFromDataView, getUnicodeStringFromDataView, decompress, COMPRESSION_METHOD_NONE, COMPRESSION_METHOD_DEFLATE} from './utils.js';\n\nexport default {\n    read\n};\n\nconst PROFILE_HEADER_LENGTH = 84;\nconst ICC_TAG_COUNT_OFFSET = 128;\nconst ICC_SIGNATURE = 'acsp';\nconst TAG_TYPE_DESC = 'desc';\nconst TAG_TYPE_MULTI_LOCALIZED_UNICODE_TYPE = 'mluc';\nconst TAG_TYPE_TEXT = 'text';\nconst TAG_TYPE_SIGNATURE = 'sig ';\nconst TAG_TABLE_SINGLE_TAG_DATA = 12;\n\n// ICC profile data can be longer than application segment max length of ~64k.\n// so it can be split into multiple APP2 segments. Each segment includes\n// total chunk count and chunk number.\n// Here we read all chunks into single continuous array of bytes.\n// Compressed ICC profile data only has support for a single chunk.\nfunction read(dataView, iccData, async) {\n    if (async && iccData[0].compressionMethod !== COMPRESSION_METHOD_NONE) {\n        return readCompressedIcc(dataView, iccData);\n    }\n\n    return readIcc(dataView, iccData);\n}\n\nfunction readCompressedIcc(dataView, iccData) {\n    if (!compressionMethodIsSupported(iccData[0].compressionMethod)) {\n        return {};\n    }\n    const compressedDataView = new DataView(dataView.buffer.slice(iccData[0].offset, iccData[0].offset + iccData[0].length));\n    return decompress(compressedDataView, iccData[0].compressionMethod, 'utf-8', 'dataview')\n        .then(parseTags)\n        .catch(() => ({}));\n}\n\nfunction compressionMethodIsSupported(compressionMethod) {\n    return compressionMethod === COMPRESSION_METHOD_DEFLATE;\n}\n\nfunction readIcc(dataView, iccData) {\n    try {\n        const totalIccProfileLength = iccData.reduce((sum, icc) => sum + icc.length, 0);\n\n        const iccBinaryData = new Uint8Array(totalIccProfileLength);\n        let offset = 0;\n        const buffer = getBuffer(dataView);\n\n        for (let chunkNumber = 1; chunkNumber <= iccData.length; chunkNumber++) {\n            const iccDataChunk = iccData.find((x) => x.chunkNumber === chunkNumber);\n            if (!iccDataChunk) {\n                throw new Error(`ICC chunk ${chunkNumber} not found`);\n            }\n\n            const data = buffer.slice(iccDataChunk.offset, iccDataChunk.offset + iccDataChunk.length);\n            const chunkData = new Uint8Array(data);\n\n            iccBinaryData.set(chunkData, offset);\n            offset += chunkData.length;\n        }\n\n        return parseTags(new DataView(iccBinaryData.buffer));\n    } catch (error) {\n        return {};\n    }\n}\n\nfunction getBuffer(dataView) {\n    if (Array.isArray(dataView)) {\n        return (new DataView(Uint8Array.from(dataView).buffer)).buffer;\n    }\n    return dataView.buffer;\n}\n\nfunction iccDoesNotHaveTagCount(buffer) {\n    return buffer.length < (ICC_TAG_COUNT_OFFSET + 4);\n}\n\nfunction hasTagsData(buffer, tagHeaderOffset) {\n    return buffer.length < tagHeaderOffset + TAG_TABLE_SINGLE_TAG_DATA;\n}\n\nexport function parseTags(dataView) {\n    const buffer = dataView.buffer;\n\n    const length = dataView.getUint32();\n    if (dataView.byteLength !== length) {\n        throw new Error('ICC profile length not matching');\n    }\n\n    if (dataView.byteLength < PROFILE_HEADER_LENGTH) {\n        throw new Error('ICC profile too short');\n    }\n\n    const tags = {};\n\n    const iccProfileKeys = Object.keys(iccProfile);\n    for (let i = 0; i < iccProfileKeys.length; i++) {\n        const offset = iccProfileKeys[i];\n        const profileEntry = iccProfile[offset];\n        const value = profileEntry.value(dataView, parseInt(offset, 10));\n        let description = value;\n        if (profileEntry.description) {\n            description = profileEntry.description(value);\n        }\n\n        tags[profileEntry.name] = {\n            value,\n            description\n        };\n    }\n\n    const signature = sliceToString(buffer.slice(36, 40));\n    if (signature !== ICC_SIGNATURE) {\n        throw new Error('ICC profile: missing signature');\n    }\n\n    /* ICC data is incomplete but we have header parsed so lets return it */\n    if (iccDoesNotHaveTagCount(buffer)) {\n        return tags;\n    }\n\n    const tagCount = dataView.getUint32(128);\n    let tagHeaderOffset = 132;\n\n    for (let i = 0; i < tagCount; i++) {\n        if (hasTagsData(buffer, tagHeaderOffset)) {\n            // Tags are corrupted (offset too far), return what we parsed until now\n            return tags;\n        }\n        const tagSignature = getStringFromDataView(dataView, tagHeaderOffset, 4);\n        const tagOffset = dataView.getUint32(tagHeaderOffset + 4);\n        const tagSize = dataView.getUint32(tagHeaderOffset + 8);\n\n        if (tagOffset > buffer.length) {\n            // Tag data is invalid, lets return what we managed to parse\n            return tags;\n        }\n        const tagType = getStringFromDataView(dataView, tagOffset, 4);\n\n        if (tagType === TAG_TYPE_DESC) {\n            const tagValueSize = dataView.getUint32(tagOffset + 8);\n            if (tagValueSize > tagSize) {\n                // Tag data is invalid, lets return what we managed to parse\n                return tags;\n            }\n\n            const val = sliceToString(buffer.slice(tagOffset + 12, tagOffset + tagValueSize + 11));\n            addTag(tags, tagSignature, val);\n        } else if (tagType === TAG_TYPE_MULTI_LOCALIZED_UNICODE_TYPE) {\n            const numRecords = dataView.getUint32(tagOffset + 8);\n            const recordSize = dataView.getUint32(tagOffset + 12);\n            let offset = tagOffset + 16;\n            const val = [];\n            for (let recordNum = 0; recordNum < numRecords; recordNum++) {\n                const languageCode = getStringFromDataView(dataView, offset + 0, 2);\n                const countryCode = getStringFromDataView(dataView, offset + 2, 2);\n                const textLength = dataView.getUint32(offset + 4);\n                const textOffset = dataView.getUint32(offset + 8);\n\n                const text = getUnicodeStringFromDataView(dataView, tagOffset + textOffset, textLength);\n                val.push({languageCode, countryCode, text});\n                offset += recordSize;\n            }\n            if (numRecords === 1) {\n                addTag(tags, tagSignature, val[0].text);\n            } else {\n                const valObj = {};\n                for (let valIndex = 0; valIndex < val.length; valIndex++) {\n                    valObj[`${val[valIndex].languageCode}-${val[valIndex].countryCode}`] = val[valIndex].text;\n                }\n                addTag(tags, tagSignature, valObj);\n            }\n        } else if (tagType === TAG_TYPE_TEXT) {\n            const val = sliceToString(buffer.slice(tagOffset + 8, tagOffset + tagSize - 7));\n            addTag(tags, tagSignature, val);\n        } else if (tagType === TAG_TYPE_SIGNATURE) {\n            const val = sliceToString(buffer.slice(tagOffset + 8, tagOffset + 12));\n            addTag(tags, tagSignature, val);\n        }\n        tagHeaderOffset = tagHeaderOffset + 12;\n    }\n\n    return tags;\n}\n\nfunction sliceToString(slice) {\n    return String.fromCharCode.apply(null, new Uint8Array(slice));\n}\n\nfunction addTag(tags, tagSignature, value) {\n    if (iccTags[tagSignature]) {\n        tags[iccTags[tagSignature].name] = {value, description: value};\n    } else {\n        tags[tagSignature] = {value, description: value};\n    }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport IptcTagNames from './iptc-tag-names.js';\nimport TagDecoder from './tag-decoder.js';\n\nconst BYTES_8BIM = 0x3842494d;\nconst BYTES_8BIM_SIZE = 4;\nconst RESOURCE_ID_SIZE = 2;\nconst RESOURCE_NAME_SIZE_SIZE = 1;\nconst RESOURCE_NAME_MIN_SIZE = 2;\nconst RESOURCE_SIZE_SIZE = 4;\nconst RESOURCE_BLOCK_MIN_HEADER_SIZE = BYTES_8BIM_SIZE + RESOURCE_ID_SIZE + RESOURCE_NAME_MIN_SIZE + RESOURCE_SIZE_SIZE;\nconst NAA_RESOURCE_BLOCK_TYPE = 0x0404; // Sometimes called resource ID.\nconst TAG_HEADER_SIZE = 5;\n\nexport default {\n    read\n};\n\nfunction read(dataView, dataOffset, includeUnknown) {\n    try {\n        if (Array.isArray(dataView)) {\n            return parseTags(new DataView(Uint8Array.from(dataView).buffer), {size: dataView.length}, 0, includeUnknown);\n        }\n        const {naaBlock, dataOffset: newDataOffset} = getNaaResourceBlock(dataView, dataOffset);\n        return parseTags(dataView, naaBlock, newDataOffset, includeUnknown);\n    } catch (error) {\n        return {};\n    }\n}\n\nfunction getNaaResourceBlock(dataView, dataOffset) {\n    while (dataOffset + RESOURCE_BLOCK_MIN_HEADER_SIZE <= dataView.byteLength) {\n        const resourceBlock = getResourceBlock(dataView, dataOffset);\n        if (isNaaResourceBlock(resourceBlock)) {\n            return {naaBlock: resourceBlock, dataOffset: dataOffset + resourceBlock.headerSize};\n        }\n        dataOffset += resourceBlock.headerSize + resourceBlock.size + getBlockPadding(resourceBlock);\n    }\n    throw new Error('No IPTC NAA resource block.');\n}\n\nfunction getResourceBlock(dataView, dataOffset) {\n    if (dataView.getUint32(dataOffset, false) !== BYTES_8BIM) {\n        throw new Error('Not an IPTC resource block.');\n    }\n\n    // We currently do not use the resource name for anything, we just need to know the size.\n    const resourceNameSize = dataView.getUint8(dataOffset + BYTES_8BIM_SIZE + RESOURCE_ID_SIZE);\n    const resourceNameTotalSize = (resourceNameSize % 2 === 0 ? resourceNameSize + 1 : resourceNameSize) + RESOURCE_NAME_SIZE_SIZE;\n\n    return {\n        headerSize: BYTES_8BIM_SIZE + RESOURCE_ID_SIZE + resourceNameTotalSize + RESOURCE_SIZE_SIZE,\n        type: dataView.getUint16(dataOffset + BYTES_8BIM_SIZE),\n        size: dataView.getUint32(dataOffset + BYTES_8BIM_SIZE + RESOURCE_ID_SIZE + resourceNameTotalSize),\n    };\n}\n\nfunction isNaaResourceBlock(resourceBlock) {\n    return resourceBlock.type === NAA_RESOURCE_BLOCK_TYPE;\n}\n\nfunction getBlockPadding(resourceBlock) {\n    if (resourceBlock.size % 2 !== 0) {\n        return 1;\n    }\n    return 0;\n}\n\nfunction parseTags(dataView, naaBlock, dataOffset, includeUnknown) {\n    const tags = {};\n    let encoding = undefined;\n\n    const endOfBlockOffset = dataOffset + naaBlock['size'];\n\n    while ((dataOffset < endOfBlockOffset) && (dataOffset < dataView.byteLength)) {\n        const {tag, tagSize} = readTag(dataView, dataOffset, tags, encoding, includeUnknown);\n\n        if (tag === null) {\n            break;\n        }\n\n        if (tag) {\n            if ('encoding' in tag) {\n                encoding = tag.encoding;\n            }\n\n            if ((tags[tag.name] === undefined) || (tag['repeatable'] === undefined)) {\n                tags[tag.name] = {\n                    id: tag.id,\n                    value: tag.value,\n                    description: tag.description\n                };\n            } else {\n                if (!(tags[tag.name] instanceof Array)) {\n                    tags[tag.name] = [{\n                        id: tags[tag.name].id,\n                        value: tags[tag.name].value,\n                        description: tags[tag.name].description\n                    }];\n                }\n                tags[tag.name].push({\n                    id: tag.id,\n                    value: tag.value,\n                    description: tag.description\n                });\n            }\n        }\n\n        dataOffset += TAG_HEADER_SIZE + tagSize;\n    }\n\n    return tags;\n}\n\nfunction readTag(dataView, dataOffset, tags, encoding, includeUnknown) {\n    const TAG_CODE_OFFSET = 1;\n    const TAG_SIZE_OFFSET = 3;\n\n    if (leadByteIsMissing(dataView, dataOffset)) {\n        return {tag: null, tagSize: 0};\n    }\n\n    const tagCode = dataView.getUint16(dataOffset + TAG_CODE_OFFSET);\n    const tagSize = dataView.getUint16(dataOffset + TAG_SIZE_OFFSET);\n\n    if (!includeUnknown && !IptcTagNames['iptc'][tagCode]) {\n        return {tag: undefined, tagSize};\n    }\n\n    const tagValue = getTagValue(dataView, dataOffset + TAG_HEADER_SIZE, tagSize);\n\n    const tag = {\n        id: tagCode,\n        name: getTagName(IptcTagNames['iptc'][tagCode], tagCode, tagValue),\n        value: tagValue,\n        description: getTagDescription(IptcTagNames['iptc'][tagCode], tagValue, tags, encoding)\n    };\n    if (tagIsRepeatable(tagCode)) {\n        tag['repeatable'] = true;\n    }\n    if (tagContainsEncoding(tagCode)) {\n        tag['encoding'] = IptcTagNames['iptc'][tagCode]['encoding_name'](tagValue);\n    }\n\n    return {tag, tagSize};\n}\n\nfunction leadByteIsMissing(dataView, dataOffset) {\n    const TAG_LEAD_BYTE = 0x1c;\n    return dataView.getUint8(dataOffset) !== TAG_LEAD_BYTE;\n}\n\nfunction getTagValue(dataView, offset, size) {\n    const value = [];\n\n    for (let valueIndex = 0; valueIndex < size; valueIndex++) {\n        value.push(dataView.getUint8(offset + valueIndex));\n    }\n\n    return value;\n}\n\nfunction getTagName(tag, tagCode, tagValue) {\n    if (!tag) {\n        return `undefined-${tagCode}`;\n    }\n    if (tagIsName(tag)) {\n        return tag;\n    }\n    if (hasDynamicName(tag)) {\n        return tag['name'](tagValue);\n    }\n    return tag['name'];\n}\n\nfunction tagIsName(tag) {\n    return typeof tag === 'string';\n}\n\nfunction hasDynamicName(tag) {\n    return typeof (tag['name']) === 'function';\n}\n\nfunction getTagDescription(tag, tagValue, tags, encoding) {\n    if (hasDescriptionProperty(tag)) {\n        try {\n            return tag['description'](tagValue, tags);\n        } catch (error) {\n            // Fall through to next handler.\n        }\n    }\n    if (tagValueIsText(tag, tagValue)) {\n        return TagDecoder.decode(encoding, tagValue);\n    }\n    return tagValue;\n}\n\nfunction tagValueIsText(tag, tagValue) {\n    return tag && tagValue instanceof Array;\n}\n\nfunction hasDescriptionProperty(tag) {\n    return tag && tag['description'] !== undefined;\n}\n\nfunction tagIsRepeatable(tagCode) {\n    return IptcTagNames['iptc'][tagCode] && IptcTagNames['iptc'][tagCode]['repeatable'];\n}\n\nfunction tagContainsEncoding(tagCode) {\n    return IptcTagNames['iptc'][tagCode] && IptcTagNames['iptc'][tagCode]['encoding_name'] !== undefined;\n}\n","import { BS } from \"@beep/schema\";\nimport type * as S from \"effect/Schema\";\n\n/*  *\n *  BYTE (SI / DECIMAL)\n *  1 kB = 1,000 B\n *  */\nexport const ByteUnitKit = BS.stringLiteralKit(\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\");\n\nexport class ByteUnit extends ByteUnitKit.Schema.annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/ByteUnit\"),\n  identifier: \"ByteUnit\",\n  title: \"Byte Unit  SI (Decimal, base10)\",\n  description:\n    \"Byte units using SI decimal prefixes for file sizes: B, kB, MB, GB, TB, PB, EB, ZB, YB. Uses powers of 10 (1 kB = 1,000 B; 1 MB = 1,000,000 B). Prefer for storage/device specs and enduser file size displays. Casesensitive: 'B' means byte (8 bits).\",\n}) {\n  static readonly Options = ByteUnitKit.Options;\n  static readonly Enum = ByteUnitKit.Enum;\n}\n\nexport namespace ByteUnit {\n  export type Type = S.Schema.Type<typeof ByteUnit>;\n  export type Encoded = S.Schema.Encoded<typeof ByteUnit>;\n}\n\n/*  *\n *  BYTE (IEC / BINARY)\n *  1 KiB = 1,024 B\n *  */\nexport const BiByteUnitKit = BS.stringLiteralKit(\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\");\n\nexport class BiByteUnit extends BiByteUnitKit.Schema.annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/BiByteUnit\"),\n  identifier: \"BiByteUnit\",\n  title: \"Byte Unit  IEC (Binary, base2)\",\n  description:\n    \"Byte units using IEC binary prefixes: B, KiB, MiB, GiB, TiB, PiB, EiB, ZiB, YiB. Uses powers of 2 (1 KiB = 1,024 B; 1 MiB = 1,024 KiB). Prefer for memory sizes and contexts requiring exact powersoftwo semantics. Casesensitive: 'B' means byte (8 bits).\",\n}) {\n  static readonly Options = BiByteUnitKit.Options;\n  static readonly Enum = BiByteUnitKit.Enum;\n}\n\nexport namespace BiByteUnit {\n  export type Type = S.Schema.Type<typeof BiByteUnit>;\n  export type Encoded = S.Schema.Encoded<typeof BiByteUnit>;\n}\n\n/*  *\n *  BIT (SI / DECIMAL)\n *  1 kbit = 1,000 b\n *  */\nexport const BitUnitKit = BS.stringLiteralKit(\"b\", \"kbit\", \"Mbit\", \"Gbit\", \"Tbit\", \"Pbit\", \"Ebit\", \"Zbit\", \"Ybit\");\n\nexport class BitUnit extends BitUnitKit.Schema.annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/BitUnit\"),\n  identifier: \"BitUnit\",\n  title: \"Bit Unit  SI (Decimal, base10)\",\n  description:\n    \"Bit units with SI decimal prefixes, commonly used for data rates: b, kbit, Mbit, Gbit, Tbit, Pbit, Ebit, Zbit, Ybit. Uses powers of 10 (1 kbit = 1,000 b). Casesensitive: 'b' means bit; 8 bits = 1 byte. Practical rule of thumb: MB/s  Mb/s  8.\",\n}) {\n  static readonly Options = BitUnitKit.Options;\n  static readonly Enum = BitUnitKit.Enum;\n}\n\nexport namespace BitUnit {\n  export type Type = S.Schema.Type<typeof BitUnit>;\n  export type Encoded = S.Schema.Encoded<typeof BitUnit>;\n}\n\n/*  *\n *  BIT (IEC / BINARY)\n *  1 kibit = 1,024 b\n *  */\nexport const BiBitUnitKit = BS.stringLiteralKit(\n  \"b\",\n  \"kibit\",\n  \"Mibit\",\n  \"Gibit\",\n  \"Tibit\",\n  \"Pibit\",\n  \"Eibit\",\n  \"Zibit\",\n  \"Yibit\"\n);\n\nexport class BiBitUnit extends BiBitUnitKit.Schema.annotations({\n  schemaId: Symbol.for(\"@beep/files-domain/value-objects/BiBitUnit\"),\n  identifier: \"BiBitUnit\",\n  title: \"Bit Unit  IEC (Binary, base2)\",\n  description:\n    \"Bit units with IEC binary prefixes: b, kibit, Mibit, Gibit, Tibit, Pibit, Eibit, Zibit, Yibit. Uses powers of 2 (1 kibit = 1,024 b). Less common than decimal bit units; use when exact base2 bit counts are required. Casesensitive: 'b' means bit.\",\n}) {\n  static readonly Options = BiBitUnitKit.Options;\n  static readonly Enum = BiBitUnitKit.Enum;\n}\n\nexport namespace BiBitUnit {\n  export type Type = S.Schema.Type<typeof BiBitUnit>;\n  export type Encoded = S.Schema.Encoded<typeof BiBitUnit>;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringFromDataView} from './utils.js';\nimport Constants from './constants.js';\n\nexport default {\n    isWebpFile,\n    findOffsets\n};\n\nfunction isWebpFile(dataView) {\n    const RIFF_ID_OFFSET = 0;\n    const RIFF_ID = 'RIFF';\n    const WEBP_MARKER_OFFSET = 8;\n    const WEBP_MARKER = 'WEBP';\n\n    return !!dataView && getStringFromDataView(dataView, RIFF_ID_OFFSET, RIFF_ID.length) === RIFF_ID\n        && getStringFromDataView(dataView, WEBP_MARKER_OFFSET, WEBP_MARKER.length) === WEBP_MARKER;\n}\n\nfunction findOffsets(dataView) {\n    const SUB_CHUNK_START_OFFSET = 12;\n    const CHUNK_SIZE_OFFSET = 4;\n    const EXIF_IDENTIFIER = 'Exif\\x00\\x00';\n    const CHUNK_HEADER_SIZE = 8;\n\n    let offset = SUB_CHUNK_START_OFFSET;\n    let hasAppMarkers = false;\n    let tiffHeaderOffset;\n    let xmpChunks;\n    let iccChunks;\n    let vp8xChunkOffset;\n\n    while (offset + CHUNK_HEADER_SIZE < dataView.byteLength) {\n        const chunkId = getStringFromDataView(dataView, offset, 4);\n        const chunkSize = dataView.getUint32(offset + CHUNK_SIZE_OFFSET, true);\n\n        if (Constants.USE_EXIF && (chunkId === 'EXIF')) {\n            hasAppMarkers = true;\n            if (getStringFromDataView(dataView, offset + CHUNK_HEADER_SIZE, EXIF_IDENTIFIER.length) === EXIF_IDENTIFIER) {\n                tiffHeaderOffset = offset + CHUNK_HEADER_SIZE + EXIF_IDENTIFIER.length;\n            } else {\n                tiffHeaderOffset = offset + CHUNK_HEADER_SIZE;\n            }\n        } else if (Constants.USE_XMP && (chunkId === 'XMP ')) {\n            hasAppMarkers = true;\n            xmpChunks = [{\n                dataOffset: offset + CHUNK_HEADER_SIZE,\n                length: chunkSize\n            }];\n        } else if (Constants.USE_ICC && (chunkId === 'ICCP')) {\n            hasAppMarkers = true;\n            iccChunks = [{\n                offset: offset + CHUNK_HEADER_SIZE,\n                length: chunkSize,\n                chunkNumber: 1,\n                chunksTotal: 1\n            }];\n        } else if (chunkId === 'VP8X') {\n            hasAppMarkers = true;\n            vp8xChunkOffset = offset + CHUNK_HEADER_SIZE;\n        }\n\n        offset += CHUNK_HEADER_SIZE + (chunkSize % 2 === 0 ? chunkSize : chunkSize + 1);\n    }\n\n    return {\n        hasAppMarkers,\n        tiffHeaderOffset,\n        xmpChunks,\n        iccChunks,\n        vp8xChunkOffset\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport ByteOrder from './byte-order.js';\nimport Constants from './constants.js';\n\nexport default {\n    isTiffFile,\n    findTiffOffsets\n};\n\nfunction isTiffFile(dataView) {\n    const MIN_TIFF_DATA_BUFFER_LENGTH = 4;\n\n    return !!dataView && (dataView.byteLength >= MIN_TIFF_DATA_BUFFER_LENGTH) && hasTiffMarker(dataView);\n}\n\nfunction hasTiffMarker(dataView) {\n    const TIFF_ID = 0x2a;\n    const TIFF_ID_OFFSET = 2;\n\n    const littleEndian = dataView.getUint16(0) === ByteOrder.LITTLE_ENDIAN;\n    return dataView.getUint16(TIFF_ID_OFFSET, littleEndian) === TIFF_ID;\n}\n\nfunction findTiffOffsets() {\n    const TIFF_FILE_HEADER_OFFSET = 0;\n\n    if (Constants.USE_EXIF) {\n        return {\n            hasAppMarkers: true,\n            tiffHeaderOffset: TIFF_FILE_HEADER_OFFSET\n        };\n    }\n    return {};\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringFromDataView} from './utils.js';\nimport Constants from './constants.js';\n\nexport default {\n    isJpegFile,\n    findJpegOffsets\n};\n\nconst MIN_JPEG_DATA_BUFFER_LENGTH = 2;\nconst JPEG_ID = 0xffd8;\nconst JPEG_ID_SIZE = 2;\nconst APP_ID_OFFSET = 4;\nconst APP_MARKER_SIZE = 2;\nconst JFIF_DATA_OFFSET = 2; // From start of APP0 marker.\nconst TIFF_HEADER_OFFSET = 10; // From start of APP1 marker.\nconst IPTC_DATA_OFFSET = 18; // From start of APP13 marker.\nconst XMP_DATA_OFFSET = 33; // From start of APP1 marker.\nconst XMP_EXTENDED_DATA_OFFSET = 79; // From start of APP1 marker including GUID, total length, and offset.\nconst APP2_ICC_DATA_OFFSET = 18; // From start of APP2 marker including marker and chunk/chunk total numbers.\nconst MPF_DATA_OFFSET = 8;\n\nconst APP2_ICC_IDENTIFIER = 'ICC_PROFILE\\0';\nconst ICC_CHUNK_NUMBER_OFFSET = APP_ID_OFFSET + APP2_ICC_IDENTIFIER.length;\nconst ICC_TOTAL_CHUNKS_OFFSET = ICC_CHUNK_NUMBER_OFFSET + 1;\n\nconst APP2_MPF_IDENTIFIER = 'MPF\\0';\n\nconst SOF0_MARKER = 0xffc0;\nconst SOF2_MARKER = 0xffc2;\nconst DHT_MARKER = 0xffc4;\nconst DQT_MARKER = 0xffdb;\nconst DRI_MARKER = 0xffdd;\nconst SOS_MARKER = 0xffda;\n\nconst APP0_MARKER = 0xffe0;\nconst APP1_MARKER = 0xffe1;\nconst APP2_MARKER = 0xffe2;\nconst APP13_MARKER = 0xffed;\nconst APP15_MARKER = 0xffef;\nconst COMMENT_MARKER = 0xfffe;\n\n// Any number of fill bytes can be placed before an app marker. It's actually the first 0xff that is the\n// fill byte and the next 0xff is either another fill byte or the first half of the next app marker.\nconst FILL_BYTE = 0xffff;\n\nconst APP0_JFIF_IDENTIFIER = 'JFIF';\nconst APP1_EXIF_IDENTIFIER = 'Exif';\nconst APP1_XMP_IDENTIFIER = 'http://ns.adobe.com/xap/1.0/\\x00';\nconst APP1_XMP_EXTENDED_IDENTIFIER = 'http://ns.adobe.com/xmp/extension/\\x00';\nconst APP13_IPTC_IDENTIFIER = 'Photoshop 3.0';\n\nfunction isJpegFile(dataView) {\n    return !!dataView && (dataView.byteLength >= MIN_JPEG_DATA_BUFFER_LENGTH) && (dataView.getUint16(0) === JPEG_ID);\n}\n\nfunction findJpegOffsets(dataView) {\n    let appMarkerPosition = JPEG_ID_SIZE;\n    let fieldLength;\n    let sof0DataOffset;\n    let sof2DataOffset;\n    let jfifDataOffset;\n    let tiffHeaderOffset;\n    let iptcDataOffset;\n    let xmpChunks;\n    let iccChunks;\n    let mpfDataOffset;\n\n    while (appMarkerPosition + APP_ID_OFFSET + 5 <= dataView.byteLength) {\n        if (Constants.USE_FILE && isSOF0Marker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            sof0DataOffset = appMarkerPosition + APP_MARKER_SIZE;\n        } else if (Constants.USE_FILE && isSOF2Marker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            sof2DataOffset = appMarkerPosition + APP_MARKER_SIZE;\n        } else if (Constants.USE_JFIF && isApp0JfifMarker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            jfifDataOffset = appMarkerPosition + JFIF_DATA_OFFSET;\n        } else if (Constants.USE_EXIF && isApp1ExifMarker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            tiffHeaderOffset = appMarkerPosition + TIFF_HEADER_OFFSET;\n        } else if (Constants.USE_XMP && isApp1XmpMarker(dataView, appMarkerPosition)) {\n            if (!xmpChunks) {\n                xmpChunks = [];\n            }\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            xmpChunks.push(getXmpChunkDetails(appMarkerPosition, fieldLength));\n        } else if (Constants.USE_XMP && isApp1ExtendedXmpMarker(dataView, appMarkerPosition)) {\n            if (!xmpChunks) {\n                xmpChunks = [];\n            }\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            xmpChunks.push(getExtendedXmpChunkDetails(appMarkerPosition, fieldLength));\n        } else if (Constants.USE_IPTC && isApp13PhotoshopMarker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            iptcDataOffset = appMarkerPosition + IPTC_DATA_OFFSET;\n        } else if (Constants.USE_ICC && isApp2ICCMarker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            const iccDataOffset = appMarkerPosition + APP2_ICC_DATA_OFFSET;\n            const iccDataLength = fieldLength - (APP2_ICC_DATA_OFFSET - APP_MARKER_SIZE);\n\n            const iccChunkNumber = dataView.getUint8(appMarkerPosition + ICC_CHUNK_NUMBER_OFFSET);\n            const iccChunksTotal = dataView.getUint8(appMarkerPosition + ICC_TOTAL_CHUNKS_OFFSET);\n            if (!iccChunks) {\n                iccChunks = [];\n            }\n            iccChunks.push({offset: iccDataOffset, length: iccDataLength, chunkNumber: iccChunkNumber, chunksTotal: iccChunksTotal});\n        } else if (Constants.USE_MPF && isApp2MPFMarker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n            mpfDataOffset = appMarkerPosition + MPF_DATA_OFFSET;\n        } else if (isAppMarker(dataView, appMarkerPosition)) {\n            fieldLength = dataView.getUint16(appMarkerPosition + APP_MARKER_SIZE);\n        } else if (isFillByte(dataView, appMarkerPosition)) {\n            appMarkerPosition++;\n            continue;\n        } else {\n            break;\n        }\n        appMarkerPosition += APP_MARKER_SIZE + fieldLength;\n    }\n\n    return {\n        hasAppMarkers: appMarkerPosition > JPEG_ID_SIZE,\n        fileDataOffset: sof0DataOffset || sof2DataOffset,\n        jfifDataOffset,\n        tiffHeaderOffset,\n        iptcDataOffset,\n        xmpChunks,\n        iccChunks,\n        mpfDataOffset\n    };\n}\n\nfunction isSOF0Marker(dataView, appMarkerPosition) {\n    return (dataView.getUint16(appMarkerPosition) === SOF0_MARKER);\n}\n\nfunction isSOF2Marker(dataView, appMarkerPosition) {\n    return (dataView.getUint16(appMarkerPosition) === SOF2_MARKER);\n}\n\nfunction isApp2ICCMarker(dataView, appMarkerPosition) {\n    const markerIdLength = APP2_ICC_IDENTIFIER.length;\n\n    return (dataView.getUint16(appMarkerPosition) === APP2_MARKER)\n        && (getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP2_ICC_IDENTIFIER);\n}\n\nfunction isApp2MPFMarker(dataView, appMarkerPosition) {\n    const markerIdLength = APP2_MPF_IDENTIFIER.length;\n\n    return (dataView.getUint16(appMarkerPosition) === APP2_MARKER)\n        && (getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP2_MPF_IDENTIFIER);\n}\n\nfunction isApp0JfifMarker(dataView, appMarkerPosition) {\n    const markerIdLength = APP0_JFIF_IDENTIFIER.length;\n\n    return (dataView.getUint16(appMarkerPosition) === APP0_MARKER)\n        && (getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP0_JFIF_IDENTIFIER)\n        && (dataView.getUint8(appMarkerPosition + APP_ID_OFFSET + markerIdLength) === 0x00);\n}\n\nfunction isApp1ExifMarker(dataView, appMarkerPosition) {\n    const markerIdLength = APP1_EXIF_IDENTIFIER.length;\n\n    return (dataView.getUint16(appMarkerPosition) === APP1_MARKER)\n        && (getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP1_EXIF_IDENTIFIER)\n        && (dataView.getUint8(appMarkerPosition + APP_ID_OFFSET + markerIdLength) === 0x00);\n}\n\nfunction isApp1XmpMarker(dataView, appMarkerPosition) {\n    return (dataView.getUint16(appMarkerPosition) === APP1_MARKER)\n        && isXmpIdentifier(dataView, appMarkerPosition);\n}\n\nfunction isXmpIdentifier(dataView, appMarkerPosition) {\n    const markerIdLength = APP1_XMP_IDENTIFIER.length;\n    return getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP1_XMP_IDENTIFIER;\n}\n\nfunction isApp1ExtendedXmpMarker(dataView, appMarkerPosition) {\n    return (dataView.getUint16(appMarkerPosition) === APP1_MARKER)\n        && isExtendedXmpIdentifier(dataView, appMarkerPosition);\n}\n\nfunction isExtendedXmpIdentifier(dataView, appMarkerPosition) {\n    const markerIdLength = APP1_XMP_EXTENDED_IDENTIFIER.length;\n    return getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP1_XMP_EXTENDED_IDENTIFIER;\n}\n\nfunction getXmpChunkDetails(appMarkerPosition, fieldLength) {\n    return {\n        dataOffset: appMarkerPosition + XMP_DATA_OFFSET,\n        length: fieldLength - (XMP_DATA_OFFSET - APP_MARKER_SIZE)\n    };\n}\n\nfunction getExtendedXmpChunkDetails(appMarkerPosition, fieldLength) {\n    return {\n        dataOffset: appMarkerPosition + XMP_EXTENDED_DATA_OFFSET,\n        length: fieldLength - (XMP_EXTENDED_DATA_OFFSET - APP_MARKER_SIZE)\n    };\n}\n\nfunction isApp13PhotoshopMarker(dataView, appMarkerPosition) {\n    const markerIdLength = APP13_IPTC_IDENTIFIER.length;\n\n    return (dataView.getUint16(appMarkerPosition) === APP13_MARKER)\n        && (getStringFromDataView(dataView, appMarkerPosition + APP_ID_OFFSET, markerIdLength) === APP13_IPTC_IDENTIFIER)\n        && (dataView.getUint8(appMarkerPosition + APP_ID_OFFSET + markerIdLength) === 0x00);\n}\n\nfunction isAppMarker(dataView, appMarkerPosition) {\n    const appMarker = dataView.getUint16(appMarkerPosition);\n    return ((appMarker >= APP0_MARKER) && (appMarker <= APP15_MARKER))\n        || (appMarker === COMMENT_MARKER)\n        || (appMarker === SOF0_MARKER)\n        || (appMarker === SOF2_MARKER)\n        || (appMarker === DHT_MARKER)\n        || (appMarker === DQT_MARKER)\n        || (appMarker === DRI_MARKER)\n        || (appMarker === SOS_MARKER);\n}\n\nfunction isFillByte(dataView, appMarkerPosition) {\n    return dataView.getUint16(appMarkerPosition) === FILL_BYTE;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringValue, getEncodedString} from './tag-names-utils.js';\nimport TagNamesCommon from './tag-names-common.js';\n\nexport default {\n    0x829a: {\n        'name': 'ExposureTime',\n        'description': TagNamesCommon.ExposureTime\n    },\n    0x829d: {\n        'name': 'FNumber',\n        'description': TagNamesCommon.FNumber\n    },\n    0x8822: {\n        'name': 'ExposureProgram',\n        'description': TagNamesCommon.ExposureProgram\n    },\n    0x8824: 'SpectralSensitivity',\n    0x8827: 'ISOSpeedRatings',\n    0x8828: {\n        'name': 'OECF',\n        'description': () => '[Raw OECF table data]'\n    },\n    0x882a: 'TimeZoneOffset',\n    0x882b: 'SelfTimerMode',\n    0x8830: {\n        name: 'SensitivityType',\n        description: (value) => ({\n            1: 'Standard Output Sensitivity',\n            2: 'Recommended Exposure Index',\n            3: 'ISO Speed',\n            4: 'Standard Output Sensitivity and Recommended Exposure Index',\n            5: 'Standard Output Sensitivity and ISO Speed',\n            6: 'Recommended Exposure Index and ISO Speed',\n            7: 'Standard Output Sensitivity, Recommended Exposure Index and ISO Speed'\n        })[value] || 'Unknown'\n    },\n    0x8831: 'StandardOutputSensitivity',\n    0x8832: 'RecommendedExposureIndex',\n    0x8833: 'ISOSpeed',\n    0x8834: 'ISOSpeedLatitudeyyy',\n    0x8835: 'ISOSpeedLatitudezzz',\n    0x9000: {\n        'name': 'ExifVersion',\n        'description': (value) => getStringValue(value)\n    },\n    0x9003: 'DateTimeOriginal',\n    0x9004: 'DateTimeDigitized',\n    0x9009: 'GooglePlusUploadCode',\n    0x9010: 'OffsetTime',\n    0x9011: 'OffsetTimeOriginal',\n    0x9012: 'OffsetTimeDigitized',\n    0x9101: {\n        'name': 'ComponentsConfiguration',\n        'description': TagNamesCommon.ComponentsConfiguration\n    },\n    0x9102: 'CompressedBitsPerPixel',\n    0x9201: {\n        'name': 'ShutterSpeedValue',\n        'description': TagNamesCommon.ShutterSpeedValue\n    },\n    0x9202: {\n        'name': 'ApertureValue',\n        'description': TagNamesCommon.ApertureValue\n    },\n    0x9203: 'BrightnessValue',\n    0x9204: 'ExposureBiasValue',\n    0x9205: {\n        'name': 'MaxApertureValue',\n        'description': (value) => {\n            return Math.pow(Math.sqrt(2), value[0] / value[1]).toFixed(2);\n        }\n    },\n    0x9206: {\n        'name': 'SubjectDistance',\n        'description': (value) => (value[0] / value[1]) + ' m'\n    },\n    0x9207: {\n        'name': 'MeteringMode',\n        'description': TagNamesCommon.MeteringMode\n    },\n    0x9208: {\n        'name': 'LightSource',\n        description: TagNamesCommon.LightSource\n    },\n    0x9209: {\n        'name': 'Flash',\n        'description': (value) => {\n            if (value === 0x00) {\n                return 'Flash did not fire';\n            } else if (value === 0x01) {\n                return 'Flash fired';\n            } else if (value === 0x05) {\n                return 'Strobe return light not detected';\n            } else if (value === 0x07) {\n                return 'Strobe return light detected';\n            } else if (value === 0x09) {\n                return 'Flash fired, compulsory flash mode';\n            } else if (value === 0x0d) {\n                return 'Flash fired, compulsory flash mode, return light not detected';\n            } else if (value === 0x0f) {\n                return 'Flash fired, compulsory flash mode, return light detected';\n            } else if (value === 0x10) {\n                return 'Flash did not fire, compulsory flash mode';\n            } else if (value === 0x18) {\n                return 'Flash did not fire, auto mode';\n            } else if (value === 0x19) {\n                return 'Flash fired, auto mode';\n            } else if (value === 0x1d) {\n                return 'Flash fired, auto mode, return light not detected';\n            } else if (value === 0x1f) {\n                return 'Flash fired, auto mode, return light detected';\n            } else if (value === 0x20) {\n                return 'No flash function';\n            } else if (value === 0x41) {\n                return 'Flash fired, red-eye reduction mode';\n            } else if (value === 0x45) {\n                return 'Flash fired, red-eye reduction mode, return light not detected';\n            } else if (value === 0x47) {\n                return 'Flash fired, red-eye reduction mode, return light detected';\n            } else if (value === 0x49) {\n                return 'Flash fired, compulsory flash mode, red-eye reduction mode';\n            } else if (value === 0x4d) {\n                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected';\n            } else if (value === 0x4f) {\n                return 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected';\n            } else if (value === 0x59) {\n                return 'Flash fired, auto mode, red-eye reduction mode';\n            } else if (value === 0x5d) {\n                return 'Flash fired, auto mode, return light not detected, red-eye reduction mode';\n            } else if (value === 0x5f) {\n                return 'Flash fired, auto mode, return light detected, red-eye reduction mode';\n            }\n            return 'Unknown';\n        }\n    },\n    0x920a: {\n        'name': 'FocalLength',\n        'description': TagNamesCommon.FocalLength\n    },\n    0x9211: 'ImageNumber',\n    0x9212: {\n        name: 'SecurityClassification',\n        description: (value) => ({\n            'C': 'Confidential',\n            'R': 'Restricted',\n            'S': 'Secret',\n            'T': 'Top Secret',\n            'U': 'Unclassified'\n        })[value] || 'Unknown'\n    },\n    0x9213: 'ImageHistory',\n    0x9214: {\n        'name': 'SubjectArea',\n        'description': (value) => {\n            if (value.length === 2) {\n                return `Location; X: ${value[0]}, Y: ${value[1]}`;\n            } else if (value.length === 3) {\n                return `Circle; X: ${value[0]}, Y: ${value[1]}, diameter: ${value[2]}`;\n            } else if (value.length === 4) {\n                return `Rectangle; X: ${value[0]}, Y: ${value[1]}, width: ${value[2]}, height: ${value[3]}`;\n            }\n            return 'Unknown';\n        }\n    },\n    0x927c: {\n        'name': 'MakerNote',\n        'description': () => '[Raw maker note data]'\n    },\n    0x9286: {\n        'name': 'UserComment',\n        'description': getEncodedString\n    },\n    0x9290: 'SubSecTime',\n    0x9291: 'SubSecTimeOriginal',\n    0x9292: 'SubSecTimeDigitized',\n    0x935c: 'ImageSourceData',\n    0x9400: {\n        'name': 'AmbientTemperature',\n        'description': (value) => (value[0] / value[1]) + ' C'\n    },\n    0x9401: {\n        'name': 'Humidity',\n        'description': (value) => (value[0] / value[1]) + ' %'\n    },\n    0x9402: {\n        'name': 'Pressure',\n        'description': (value) => (value[0] / value[1]) + ' hPa'\n    },\n    0x9403: {\n        'name': 'WaterDepth',\n        'description': (value) => (value[0] / value[1]) + ' m'\n    },\n    0x9404: {\n        'name': 'Acceleration',\n        'description': (value) => (value[0] / value[1]) + ' mGal'\n    },\n    0x9405: {\n        'name': 'CameraElevationAngle',\n        'description': (value) => (value[0] / value[1]) + ' '\n    },\n    0xa000: {\n        'name': 'FlashpixVersion',\n        'description': (value) => value.map((charCode) => String.fromCharCode(charCode)).join('')\n    },\n    0xa001: {\n        'name': 'ColorSpace',\n        'description': TagNamesCommon.ColorSpace\n    },\n    0xa002: 'PixelXDimension',\n    0xa003: 'PixelYDimension',\n    0xa004: 'RelatedSoundFile',\n    0xa005: 'Interoperability IFD Pointer',\n    0xa20b: 'FlashEnergy',\n    0xa20c: {\n        'name': 'SpatialFrequencyResponse',\n        'description': () => '[Raw SFR table data]'\n    },\n    0xa20e: 'FocalPlaneXResolution',\n    0xa20f: 'FocalPlaneYResolution',\n    0xa210: {\n        'name': 'FocalPlaneResolutionUnit',\n        'description': TagNamesCommon.FocalPlaneResolutionUnit\n    },\n    0xa214: {\n        'name': 'SubjectLocation',\n        'description': ([x, y]) => `X: ${x}, Y: ${y}`\n    },\n    0xa215: 'ExposureIndex',\n    0xa217: {\n        'name': 'SensingMethod',\n        'description': (value) => {\n            if (value === 1) {\n                return 'Undefined';\n            } else if (value === 2) {\n                return 'One-chip color area sensor';\n            } else if (value === 3) {\n                return 'Two-chip color area sensor';\n            } else if (value === 4) {\n                return 'Three-chip color area sensor';\n            } else if (value === 5) {\n                return 'Color sequential area sensor';\n            } else if (value === 7) {\n                return 'Trilinear sensor';\n            } else if (value === 8) {\n                return 'Color sequential linear sensor';\n            }\n            return 'Unknown';\n        }\n    },\n    0xa300: {\n        'name': 'FileSource',\n        'description': (value) => {\n            if (value === 3) {\n                return 'DSC';\n            }\n            return 'Unknown';\n        }\n    },\n    0xa301: {\n        'name': 'SceneType',\n        'description': (value) => {\n            if (value === 1) {\n                return 'A directly photographed image';\n            }\n            return 'Unknown';\n        }\n    },\n    0xa302: {\n        'name': 'CFAPattern',\n        'description': () => '[Raw CFA pattern table data]'\n    },\n    0xa401: {\n        'name': 'CustomRendered',\n        'description': TagNamesCommon.CustomRendered\n    },\n    0xa402: {\n        'name': 'ExposureMode',\n        'description': TagNamesCommon.ExposureMode\n    },\n    0xa403: {\n        'name': 'WhiteBalance',\n        'description': TagNamesCommon.WhiteBalance\n    },\n    0xa404: {\n        'name': 'DigitalZoomRatio',\n        'description': (value) => {\n            if (value[0] === 0) {\n                return 'Digital zoom was not used';\n            }\n            return '' + (value[0] / value[1]);\n        }\n    },\n    0xa405: {\n        'name': 'FocalLengthIn35mmFilm', // Sometimes called FocalLengthIn35mmFormat.\n        'description': TagNamesCommon.FocalLengthIn35mmFilm\n    },\n    0xa406: {\n        'name': 'SceneCaptureType',\n        'description': TagNamesCommon.SceneCaptureType\n    },\n    0xa407: {\n        'name': 'GainControl',\n        'description': (value) => {\n            if (value === 0) {\n                return 'None';\n            } else if (value === 1) {\n                return 'Low gain up';\n            } else if (value === 2) {\n                return 'High gain up';\n            } else if (value === 3) {\n                return 'Low gain down';\n            } else if (value === 4) {\n                return 'High gain down';\n            }\n            return 'Unknown';\n        }\n    },\n    0xa408: {\n        'name': 'Contrast',\n        'description': TagNamesCommon.Contrast\n    },\n    0xa409: {\n        'name': 'Saturation',\n        'description': TagNamesCommon.Saturation\n    },\n    0xa40a: {\n        'name': 'Sharpness',\n        'description': TagNamesCommon.Sharpness\n    },\n    0xa40b: {\n        'name': 'DeviceSettingDescription',\n        'description': () => '[Raw device settings table data]'\n    },\n    0xa40c: {\n        'name': 'SubjectDistanceRange',\n        'description': (value) => {\n            if (value === 1) {\n                return 'Macro';\n            } else if (value === 2) {\n                return 'Close view';\n            } else if (value === 3) {\n                return 'Distant view';\n            }\n            return 'Unknown';\n        }\n    },\n    0xa420: 'ImageUniqueID',\n    0xa430: 'CameraOwnerName',\n    0xa431: 'BodySerialNumber',\n    0xa432: {\n        'name': 'LensSpecification',\n        'description': (value) => {\n            const focalLengthFrom = parseFloat((value[0][0] / value[0][1]).toFixed(5));\n            const focalLengthTo = parseFloat((value[1][0] / value[1][1]).toFixed(5));\n            const focalLengths = `${focalLengthFrom}-${focalLengthTo} mm`;\n            if (value[3][1] === 0) {\n                return `${focalLengths} f/?`;\n            }\n            const maxAperture = 1 / ((value[2][1] / value[2][1]) / (value[3][0] / value[3][1]));\n            return `${focalLengths} f/${parseFloat(maxAperture.toFixed(5))}`;\n        }\n    },\n    0xa433: 'LensMake',\n    0xa434: 'LensModel',\n    0xa435: 'LensSerialNumber',\n    0xa460: {\n        name: 'CompositeImage',\n        description: (value) => ({\n            1: 'Not a Composite Image',\n            2: 'General Composite Image',\n            3: 'Composite Image Captured While Shooting',\n        })[value] || 'Unknown'\n    },\n    0xa461: 'SourceImageNumberOfCompositeImage',\n    0xa462: 'SourceExposureTimesOfCompositeImage',\n    0xa500: 'Gamma',\n    0xea1c: 'Padding',\n    0xea1d: 'OffsetSchema',\n    0xfde8: 'OwnerName',\n    0xfde9: 'SerialNumber',\n    0xfdea: 'Lens',\n    0xfe4c: 'RawFile',\n    0xfe4d: 'Converter',\n    0xfe4e: 'WhiteBalance',\n    0xfe51: 'Exposure',\n    0xfe52: 'Shadows',\n    0xfe53: 'Brightness',\n    0xfe54: 'Contrast',\n    0xfe55: 'Saturation',\n    0xfe56: 'Sharpness',\n    0xfe57: 'Smoothness',\n    0xfe58: 'MoireFilter'\n};\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Constants from './constants.js';\nimport Types from './types.js';\nimport TagNames, {IFD_TYPE_0TH, IFD_TYPE_1ST, IFD_TYPE_PENTAX} from './tag-names.js';\n\nconst getTagValueAt = {\n    1: Types.getByteAt,\n    2: Types.getAsciiAt,\n    3: Types.getShortAt,\n    4: Types.getLongAt,\n    5: Types.getRationalAt,\n    7: Types.getUndefinedAt,\n    9: Types.getSlongAt,\n    10: Types.getSrationalAt,\n    13: Types.getIfdPointerAt\n};\n\nexport function get0thIfdOffset(dataView, tiffHeaderOffset, byteOrder) {\n    return tiffHeaderOffset + Types.getLongAt(dataView, tiffHeaderOffset + 4, byteOrder);\n}\n\nexport function readIfd(dataView, ifdType, offsetOrigin, offset, byteOrder, includeUnknown) {\n    const FIELD_COUNT_SIZE = Types.getTypeSize('SHORT');\n    const FIELD_SIZE = 12;\n\n    const tags = {};\n    const numberOfFields = getNumberOfFields(dataView, offset, byteOrder);\n\n    offset += FIELD_COUNT_SIZE;\n    for (let fieldIndex = 0; fieldIndex < numberOfFields; fieldIndex++) {\n        if (offset + FIELD_SIZE > dataView.byteLength) {\n            break;\n        }\n\n        const tag = readTag(dataView, ifdType, offsetOrigin, offset, byteOrder, includeUnknown);\n        if (tag !== undefined) {\n            tags[tag.name] = {\n                'id': tag.id,\n                'value': tag.value,\n                'description': tag.description\n            };\n            if (tag.name === 'MakerNote' || (ifdType === IFD_TYPE_PENTAX && tag.name === 'LevelInfo')) {\n                tags[tag.name].__offset = tag.__offset;\n            }\n        }\n\n        offset += FIELD_SIZE;\n    }\n\n    if (Constants.USE_THUMBNAIL && (offset < dataView.byteLength - Types.getTypeSize('LONG'))) {\n        const nextIfdOffset = Types.getLongAt(dataView, offset, byteOrder);\n        if (nextIfdOffset !== 0 && ifdType === IFD_TYPE_0TH) {\n            tags['Thumbnail'] = readIfd(dataView, IFD_TYPE_1ST, offsetOrigin, offsetOrigin + nextIfdOffset, byteOrder, includeUnknown);\n        }\n    }\n\n    return tags;\n}\n\nfunction getNumberOfFields(dataView, offset, byteOrder) {\n    if (offset + Types.getTypeSize('SHORT') <= dataView.byteLength) {\n        return Types.getShortAt(dataView, offset, byteOrder);\n    }\n    return 0;\n}\n\nfunction readTag(dataView, ifdType, offsetOrigin, offset, byteOrder, includeUnknown) {\n    const TAG_CODE_IPTC_NAA = 0x83bb;\n    const TAG_TYPE_OFFSET = Types.getTypeSize('SHORT');\n    const TAG_COUNT_OFFSET = TAG_TYPE_OFFSET + Types.getTypeSize('SHORT');\n    const TAG_VALUE_OFFSET = TAG_COUNT_OFFSET + Types.getTypeSize('LONG');\n\n    const tagCode = Types.getShortAt(dataView, offset, byteOrder);\n    const tagType = Types.getShortAt(dataView, offset + TAG_TYPE_OFFSET, byteOrder);\n    const tagCount = Types.getLongAt(dataView, offset + TAG_COUNT_OFFSET, byteOrder);\n    let tagValue;\n    let tagValueOffset;\n\n    if (Types.typeSizes[tagType] === undefined || (!includeUnknown && TagNames[ifdType][tagCode] === undefined)) {\n        return undefined;\n    }\n\n    if (tagValueFitsInOffsetSlot(tagType, tagCount)) {\n        tagValueOffset = offset + TAG_VALUE_OFFSET;\n        tagValue = getTagValue(dataView, tagValueOffset, tagType, tagCount, byteOrder);\n    } else {\n        tagValueOffset = Types.getLongAt(dataView, offset + TAG_VALUE_OFFSET, byteOrder);\n        if (tagValueFitsInDataView(dataView, offsetOrigin, tagValueOffset, tagType, tagCount)) {\n            const forceByteType = tagCode === TAG_CODE_IPTC_NAA;\n            tagValue = getTagValue(dataView, offsetOrigin + tagValueOffset, tagType, tagCount, byteOrder, forceByteType);\n        } else {\n            tagValue = '<faulty value>';\n        }\n    }\n\n    if (tagType === Types.tagTypes['ASCII']) {\n        tagValue = splitNullSeparatedAsciiString(tagValue);\n        tagValue = decodeAsciiValue(tagValue);\n    }\n\n    let tagName = `undefined-${tagCode}`;\n    let tagDescription = tagValue;\n\n    if (TagNames[ifdType][tagCode] !== undefined) {\n        if ((TagNames[ifdType][tagCode]['name'] !== undefined) && (TagNames[ifdType][tagCode]['description'] !== undefined)) {\n            tagName = TagNames[ifdType][tagCode]['name'];\n            try {\n                tagDescription = TagNames[ifdType][tagCode]['description'](tagValue);\n            } catch (error) {\n                tagDescription = getDescriptionFromTagValue(tagValue);\n            }\n        } else if ((tagType === Types.tagTypes['RATIONAL']) || (tagType === Types.tagTypes['SRATIONAL'])) {\n            tagName = TagNames[ifdType][tagCode];\n            tagDescription = '' + (tagValue[0] / tagValue[1]);\n        } else {\n            tagName = TagNames[ifdType][tagCode];\n            tagDescription = getDescriptionFromTagValue(tagValue);\n        }\n    }\n\n    return {\n        id: tagCode,\n        name: tagName,\n        value: tagValue,\n        description: tagDescription,\n        __offset: tagValueOffset\n    };\n}\n\nfunction tagValueFitsInOffsetSlot(tagType, tagCount) {\n    return Types.typeSizes[tagType] * tagCount <= Types.getTypeSize('LONG');\n}\n\nfunction getTagValue(dataView, offset, type, count, byteOrder, forceByteType = false) {\n    let value = [];\n\n    if (forceByteType) {\n        count = count * Types.typeSizes[type];\n        type = Types.tagTypes['BYTE'];\n    }\n    for (let valueIndex = 0; valueIndex < count; valueIndex++) {\n        value.push(getTagValueAt[type](dataView, offset, byteOrder));\n        offset += Types.typeSizes[type];\n    }\n\n    if (type === Types.tagTypes['ASCII']) {\n        value = Types.getAsciiValue(value);\n    } else if (value.length === 1) {\n        value = value[0];\n    }\n\n    return value;\n}\n\nfunction tagValueFitsInDataView(dataView, offsetOrigin, tagValueOffset, tagType, tagCount) {\n    return offsetOrigin + tagValueOffset + Types.typeSizes[tagType] * tagCount <= dataView.byteLength;\n}\n\nfunction splitNullSeparatedAsciiString(string) {\n    const tagValue = [];\n    let i = 0;\n\n    for (let j = 0; j < string.length; j++) {\n        if (string[j] === '\\x00') {\n            i++;\n            continue;\n        }\n        if (tagValue[i] === undefined) {\n            tagValue[i] = '';\n        }\n        tagValue[i] += string[j];\n    }\n\n    return tagValue;\n}\n\nfunction decodeAsciiValue(asciiValue) {\n    try {\n        return asciiValue.map((value) => decodeURIComponent(escape(value)));\n    } catch (error) {\n        return asciiValue;\n    }\n}\n\nfunction getDescriptionFromTagValue(tagValue) {\n    if (tagValue instanceof Array) {\n        return tagValue.join(', ');\n    }\n    return tagValue;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Types from './types.js';\nimport {PNG_CHUNK_LENGTH_OFFSET, PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_DATA_OFFSET, PNG_CHUNK_TYPE_SIZE, TYPE_PHYS, TYPE_TIME} from './image-header-png.js';\nimport {getStringFromDataView} from './utils.js';\n\nexport default {\n    read\n};\n\nfunction read(dataView, chunkOffsets) {\n    const tags = {};\n\n    for (let i = 0; i < chunkOffsets.length; i++) {\n        const chunkLength = Types.getLongAt(dataView, chunkOffsets[i] + PNG_CHUNK_LENGTH_OFFSET);\n        const chunkType = getStringFromDataView(dataView, chunkOffsets[i] + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n\n        if (chunkType === TYPE_PHYS) {\n            tags['Pixels Per Unit X'] = getPixelsPerUnitX(dataView, chunkOffsets[i], chunkLength);\n            tags['Pixels Per Unit Y'] = getPixelsPerUnitY(dataView, chunkOffsets[i], chunkLength);\n            tags['Pixel Units'] = getPixelUnits(dataView, chunkOffsets[i], chunkLength);\n        } else if (chunkType === TYPE_TIME) {\n            tags['Modify Date'] = getModifyDate(dataView, chunkOffsets[i], chunkLength);\n        }\n    }\n\n    return tags;\n}\n\nfunction getPixelsPerUnitX(dataView, chunkOffset, chunkLength) {\n    const TAG_OFFSET = 0;\n    const TAG_SIZE = 4;\n\n    if (!tagFitsInBuffer(dataView, chunkOffset, chunkLength, TAG_OFFSET, TAG_SIZE)) {\n        return undefined;\n    }\n\n    const value = Types.getLongAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + TAG_OFFSET);\n\n    return {\n        value,\n        description: '' + value\n    };\n}\n\nfunction getPixelsPerUnitY(dataView, chunkOffset, chunkLength) {\n    const TAG_OFFSET = 4;\n    const TAG_SIZE = 4;\n\n    if (!tagFitsInBuffer(dataView, chunkOffset, chunkLength, TAG_OFFSET, TAG_SIZE)) {\n        return undefined;\n    }\n\n    const value = Types.getLongAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + TAG_OFFSET);\n\n    return {\n        value,\n        description: '' + value\n    };\n}\n\nfunction getPixelUnits(dataView, chunkOffset, chunkLength) {\n    const TAG_OFFSET = 8;\n    const TAG_SIZE = 1;\n\n    if (!tagFitsInBuffer(dataView, chunkOffset, chunkLength, TAG_OFFSET, TAG_SIZE)) {\n        return undefined;\n    }\n\n    const value = Types.getByteAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + TAG_OFFSET);\n\n    return {\n        value,\n        description: value === 1 ? 'meters' : 'Unknown'\n    };\n}\n\nfunction getModifyDate(dataView, chunkOffset, chunkLength) {\n    const TIME_TAG_SIZE = 7;\n\n    if (!tagFitsInBuffer(dataView, chunkOffset, chunkLength, 0, TIME_TAG_SIZE)) {\n        return undefined;\n    }\n\n    const year = Types.getShortAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET);\n    const month = Types.getByteAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + 2);\n    const day = Types.getByteAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + 3);\n    const hours = Types.getByteAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + 4);\n    const minutes = Types.getByteAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + 5);\n    const seconds = Types.getByteAt(dataView, chunkOffset + PNG_CHUNK_DATA_OFFSET + 6);\n\n    return {\n        value: [year, month, day, hours, minutes, seconds],\n        description: `${pad(year, 4)}-${pad(month, 2)}-${pad(day, 2)} ${pad(hours, 2)}:${pad(minutes, 2)}:${pad(seconds, 2)}`\n    };\n}\n\nfunction tagFitsInBuffer(dataView, chunkOffset, chunkLength, tagOffset, tagSize) {\n    return tagOffset + tagSize <= chunkLength && chunkOffset + PNG_CHUNK_DATA_OFFSET + tagOffset + tagSize <= dataView.byteLength;\n}\n\nfunction pad(number, size) {\n    return `${'0'.repeat(size - ('' + number).length)}${number}`;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {objectAssign} from './utils.js';\nimport ByteOrder from './byte-order.js';\nimport {IFD_TYPE_0TH, IFD_TYPE_EXIF, IFD_TYPE_GPS, IFD_TYPE_INTEROPERABILITY} from './tag-names.js';\nimport {readIfd, get0thIfdOffset} from './tags-helpers.js';\n\nconst EXIF_IFD_POINTER_KEY = 'Exif IFD Pointer';\nconst GPS_INFO_IFD_POINTER_KEY = 'GPS Info IFD Pointer';\nconst INTEROPERABILITY_IFD_POINTER_KEY = 'Interoperability IFD Pointer';\n\nexport default {\n    read,\n};\n\nfunction read(dataView, tiffHeaderOffset, includeUnknown) {\n    const byteOrder = ByteOrder.getByteOrder(dataView, tiffHeaderOffset);\n    let tags = read0thIfd(dataView, tiffHeaderOffset, byteOrder, includeUnknown);\n    tags = readExifIfd(tags, dataView, tiffHeaderOffset, byteOrder, includeUnknown);\n    tags = readGpsIfd(tags, dataView, tiffHeaderOffset, byteOrder, includeUnknown);\n    tags = readInteroperabilityIfd(tags, dataView, tiffHeaderOffset, byteOrder, includeUnknown);\n\n    return {tags, byteOrder};\n}\n\nfunction read0thIfd(dataView, tiffHeaderOffset, byteOrder, includeUnknown) {\n    return readIfd(dataView, IFD_TYPE_0TH, tiffHeaderOffset, get0thIfdOffset(dataView, tiffHeaderOffset, byteOrder), byteOrder, includeUnknown);\n}\n\nfunction readExifIfd(tags, dataView, tiffHeaderOffset, byteOrder, includeUnknown) {\n    if (tags[EXIF_IFD_POINTER_KEY] !== undefined) {\n        return objectAssign(tags, readIfd(dataView, IFD_TYPE_EXIF, tiffHeaderOffset, tiffHeaderOffset + tags[EXIF_IFD_POINTER_KEY].value, byteOrder, includeUnknown));\n    }\n\n    return tags;\n}\n\nfunction readGpsIfd(tags, dataView, tiffHeaderOffset, byteOrder, includeUnknown) {\n    if (tags[GPS_INFO_IFD_POINTER_KEY] !== undefined) {\n        return objectAssign(tags, readIfd(dataView, IFD_TYPE_GPS, tiffHeaderOffset, tiffHeaderOffset + tags[GPS_INFO_IFD_POINTER_KEY].value, byteOrder, includeUnknown));\n    }\n\n    return tags;\n}\n\nfunction readInteroperabilityIfd(tags, dataView, tiffHeaderOffset, byteOrder, includeUnknown) {\n    if (tags[INTEROPERABILITY_IFD_POINTER_KEY] !== undefined) {\n        return objectAssign(tags, readIfd(dataView, IFD_TYPE_INTEROPERABILITY, tiffHeaderOffset, tiffHeaderOffset + tags[INTEROPERABILITY_IFD_POINTER_KEY].value, byteOrder, includeUnknown));\n    }\n\n    return tags;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Specification: http://www.libpng.org/pub/png/spec/1.2/\n\nimport {getStringFromDataView, getNullTerminatedStringFromDataView} from './utils.js';\nimport Constants from './constants.js';\n\nexport default {\n    isPngFile,\n    findPngOffsets\n};\n\nconst PNG_ID = '\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a';\nconst PNG_CHUNK_LENGTH_SIZE = 4;\nexport const PNG_CHUNK_TYPE_SIZE = 4;\nexport const PNG_CHUNK_LENGTH_OFFSET = 0;\nexport const PNG_CHUNK_TYPE_OFFSET = PNG_CHUNK_LENGTH_SIZE;\nexport const PNG_CHUNK_DATA_OFFSET = PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE;\nconst PNG_XMP_PREFIX = 'XML:com.adobe.xmp\\x00';\nexport const TYPE_TEXT = 'tEXt';\nexport const TYPE_ITXT = 'iTXt';\nexport const TYPE_ZTXT = 'zTXt';\nexport const TYPE_PHYS = 'pHYs';\nexport const TYPE_TIME = 'tIME';\nexport const TYPE_EXIF = 'eXIf';\nexport const TYPE_ICCP = 'iCCP';\n\nfunction isPngFile(dataView) {\n    return !!dataView && getStringFromDataView(dataView, 0, PNG_ID.length) === PNG_ID;\n}\n\nfunction findPngOffsets(dataView, async) {\n    const PNG_CRC_SIZE = 4;\n\n    const offsets = {\n        hasAppMarkers: false\n    };\n\n    let offset = PNG_ID.length;\n\n    while (offset + PNG_CHUNK_LENGTH_SIZE + PNG_CHUNK_TYPE_SIZE <= dataView.byteLength) {\n        if (Constants.USE_PNG_FILE && isPngImageHeaderChunk(dataView, offset)) {\n            offsets.hasAppMarkers = true;\n            offsets.pngHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;\n        } else if (Constants.USE_XMP && isPngXmpChunk(dataView, offset)) {\n            const dataOffset = getPngXmpDataOffset(dataView, offset);\n            if (dataOffset !== undefined) {\n                offsets.hasAppMarkers = true;\n                offsets.xmpChunks = [{\n                    dataOffset,\n                    length: dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET) - (dataOffset - (offset + PNG_CHUNK_DATA_OFFSET))\n                }];\n            }\n        } else if (isPngTextChunk(dataView, offset, async)) {\n            offsets.hasAppMarkers = true;\n            const chunkType = getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n            if (!offsets.pngTextChunks) {\n                offsets.pngTextChunks = [];\n            }\n            offsets.pngTextChunks.push({\n                length: dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET),\n                type: chunkType,\n                offset: offset + PNG_CHUNK_DATA_OFFSET\n            });\n        } else if (isPngExifChunk(dataView, offset)) {\n            offsets.hasAppMarkers = true;\n            offsets.tiffHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;\n        } else if (Constants.USE_ICC && async && isPngIccpChunk(dataView, offset)) {\n            offsets.hasAppMarkers = true;\n            const chunkDataLength = dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET);\n            const iccHeaderOffset = offset + PNG_CHUNK_DATA_OFFSET;\n            const {profileName, compressionMethod, compressedProfileOffset} = parseIccHeader(dataView, iccHeaderOffset);\n            if (!offsets.iccChunks) {\n                offsets.iccChunks = [];\n            }\n            offsets.iccChunks.push({\n                offset: compressedProfileOffset,\n                length: chunkDataLength - (compressedProfileOffset - iccHeaderOffset),\n                chunkNumber: 1,\n                chunksTotal: 1,\n                profileName,\n                compressionMethod\n            });\n        } else if (isPngChunk(dataView, offset)) {\n            offsets.hasAppMarkers = true;\n            if (!offsets.pngChunkOffsets) {\n                offsets.pngChunkOffsets = [];\n            }\n            offsets.pngChunkOffsets.push(offset + PNG_CHUNK_LENGTH_OFFSET);\n        }\n\n        offset += dataView.getUint32(offset + PNG_CHUNK_LENGTH_OFFSET)\n            + PNG_CHUNK_LENGTH_SIZE\n            + PNG_CHUNK_TYPE_SIZE\n            + PNG_CRC_SIZE;\n    }\n\n    return offsets;\n}\n\nfunction isPngImageHeaderChunk(dataView, offset) {\n    const PNG_CHUNK_TYPE_IMAGE_HEADER = 'IHDR';\n    return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === PNG_CHUNK_TYPE_IMAGE_HEADER;\n}\n\nfunction isPngXmpChunk(dataView, offset) {\n    return (getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === TYPE_ITXT)\n        && (getStringFromDataView(dataView, offset + PNG_CHUNK_DATA_OFFSET, PNG_XMP_PREFIX.length) === PNG_XMP_PREFIX);\n}\n\nfunction isPngTextChunk(dataView, offset, async) {\n    const chunkType = getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n    return chunkType === TYPE_TEXT || chunkType === TYPE_ITXT || (chunkType === TYPE_ZTXT && async);\n}\n\nfunction isPngExifChunk(dataView, offset) {\n    return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === TYPE_EXIF;\n}\n\nfunction isPngIccpChunk(dataView, offset) {\n    return getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE) === TYPE_ICCP;\n}\n\nfunction isPngChunk(dataView, offset) {\n    const SUPPORTED_PNG_CHUNK_TYPES = [TYPE_PHYS, TYPE_TIME];\n    const chunkType = getStringFromDataView(dataView, offset + PNG_CHUNK_TYPE_OFFSET, PNG_CHUNK_TYPE_SIZE);\n    return SUPPORTED_PNG_CHUNK_TYPES.includes(chunkType);\n}\n\nfunction getPngXmpDataOffset(dataView, offset) {\n    const COMPRESSION_FLAG_SIZE = 1;\n    const COMPRESSION_METHOD_SIZE = 1;\n\n    offset += PNG_CHUNK_DATA_OFFSET + PNG_XMP_PREFIX.length + COMPRESSION_FLAG_SIZE + COMPRESSION_METHOD_SIZE;\n\n    let numberOfNullSeparators = 0;\n    while (numberOfNullSeparators < 2 && offset < dataView.byteLength) {\n        if (dataView.getUint8(offset) === 0x00) {\n            numberOfNullSeparators++;\n        }\n        offset++;\n    }\n    if (numberOfNullSeparators < 2) {\n        return undefined;\n    }\n    return offset;\n}\n\nfunction parseIccHeader(dataView, offset) {\n    const NULL_SEPARATOR_SIZE = 1;\n    const COMPRESSION_METHOD_SIZE = 1;\n\n    const profileName = getNullTerminatedStringFromDataView(dataView, offset);\n    offset += profileName.length + NULL_SEPARATOR_SIZE;\n\n    const compressionMethod = dataView.getUint8(offset);\n    offset += COMPRESSION_METHOD_SIZE;\n\n    return {\n        profileName,\n        compressionMethod,\n        compressedProfileOffset: offset\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {getStringFromDataView, objectAssign} from './utils.js';\nimport XmpTagNames from './xmp-tag-names.js';\nimport DOMParser from './dom-parser.js';\nimport {isMissingNamespaceError, addMissingNamespaces} from './xmp-namespaces.js';\n\nexport default {\n    read\n};\n\nclass ParseError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'ParseError';\n    }\n}\n\nfunction read(dataView, chunks, domParser) {\n    const tags = {};\n\n    if (typeof dataView === 'string') {\n        readTags(tags, dataView, domParser);\n        return tags;\n    }\n\n    const [standardXmp, extendedXmp] = extractCompleteChunks(dataView, chunks);\n\n    const hasStandardTags = readTags(tags, standardXmp, domParser);\n\n    if (extendedXmp) {\n        const hasExtendedTags = readTags(tags, extendedXmp, domParser);\n\n        if (!hasStandardTags && !hasExtendedTags) {\n            // Some writers are not spec-compliant in that they split an XMP\n            // metadata tree over both the standard XMP block and the extended\n            // XMP block. If we failed parsing both of the XMPs in the regular\n            // way, we try to combine them to see if that works better.\n            delete tags._raw;\n            readTags(tags, combineChunks(dataView, chunks), domParser);\n        }\n    }\n\n    return tags;\n}\n\n// The first chunk is always the regular XMP document. Then there is something\n// called extended XMP. The extended XMP is also a single XMP document but it\n// can be divided into multiple chunks that need to be combined into one.\nfunction extractCompleteChunks(dataView, chunks) {\n    if (chunks.length === 0) {\n        return [];\n    }\n\n    const completeChunks = [combineChunks(dataView, chunks.slice(0, 1))];\n    if (chunks.length > 1) {\n        completeChunks.push(combineChunks(dataView, chunks.slice(1)));\n    }\n\n    return completeChunks;\n}\n\nfunction combineChunks(dataView, chunks) {\n    const totalLength = chunks.reduce((size, chunk) => size + chunk.length, 0);\n    const combinedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n\n    for (let i = 0; i < chunks.length; i++) {\n        const chunk = chunks[i];\n        const slice = dataView.buffer.slice(chunk.dataOffset, chunk.dataOffset + chunk.length);\n        combinedChunks.set(new Uint8Array(slice), offset);\n        offset += chunk.length;\n    }\n\n    return new DataView(combinedChunks.buffer);\n}\n\nfunction readTags(tags, chunkDataView, domParser) {\n    try {\n        const {doc, raw} = getDocument(chunkDataView, domParser);\n        tags._raw = (tags._raw || '') + raw;\n        const rdf = getRDF(doc);\n\n        objectAssign(tags, parseXMPObject(convertToObject(rdf, true)));\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\nfunction getDocument(chunkDataView, _domParser) {\n    const domParser = DOMParser.get(_domParser);\n    if (!domParser) {\n        console.warn('Warning: DOMParser is not available. It is needed to be able to parse XMP tags.'); // eslint-disable-line no-console\n        throw new Error();\n    }\n\n    const xmlString = typeof chunkDataView === 'string' ? chunkDataView : getStringFromDataView(chunkDataView, 0, chunkDataView.byteLength);\n    const doc = parseFromString(domParser, trimXmlSource(xmlString));\n\n    return {\n        doc,\n        raw: xmlString,\n    };\n}\n\nfunction trimXmlSource(xmlSource) {\n    return xmlSource.replace(/^.+(<\\?xpacket begin)/, '$1').replace(/(<\\?xpacket end=\".*\"\\?>).+$/, '$1');\n}\n\nfunction parseFromString(domParser, xmlString, isRetry = false) {\n    try {\n        const doc = domParser.parseFromString(xmlString, 'application/xml');\n        const errors = doc.getElementsByTagName('parsererror');\n        if (errors.length > 0) {\n            throw new ParseError(errors[0].textContent);\n        }\n        return doc;\n    } catch (error) {\n        if (error.name === 'ParseError' && isMissingNamespaceError(error) && !isRetry) {\n            // Retry once after trying to fix the invalid XML.\n            return parseFromString(domParser, addMissingNamespaces(xmlString), true);\n        }\n        throw error;\n    }\n}\n\nfunction getRDF(node) {\n    for (let i = 0; i < node.childNodes.length; i++) {\n        if (node.childNodes[i].tagName === 'x:xmpmeta') {\n            return getRDF(node.childNodes[i]);\n        }\n        if (node.childNodes[i].tagName === 'rdf:RDF') {\n            return node.childNodes[i];\n        }\n    }\n\n    throw new Error();\n}\n\nfunction convertToObject(node, isTopNode = false) {\n    const childNodes = getChildNodes(node);\n\n    if (hasTextOnlyContent(childNodes)) {\n        if (isTopNode) {\n            return {};\n        }\n        return getTextValue(childNodes[0]);\n    }\n\n    return getElementsFromNodes(childNodes);\n}\n\nfunction getChildNodes(node) {\n    const elements = [];\n\n    for (let i = 0; i < node.childNodes.length; i++) {\n        elements.push(node.childNodes[i]);\n    }\n\n    return elements;\n}\n\nfunction hasTextOnlyContent(nodes) {\n    return (nodes.length === 1) && (nodes[0].nodeName === '#text');\n}\n\nfunction getTextValue(node) {\n    return node.nodeValue;\n}\n\nfunction getElementsFromNodes(nodes) {\n    const elements = {};\n\n    nodes.forEach((node) => {\n        if (isElement(node)) {\n            const nodeElement = getElementFromNode(node);\n\n            if (elements[node.nodeName] !== undefined) {\n                if (!Array.isArray(elements[node.nodeName])) {\n                    elements[node.nodeName] = [elements[node.nodeName]];\n                }\n                elements[node.nodeName].push(nodeElement);\n            } else {\n                elements[node.nodeName] = nodeElement;\n            }\n        }\n    });\n\n    return elements;\n}\n\nfunction isElement(node) {\n    return (node.nodeName) && (node.nodeName !== '#text');\n}\n\nfunction getElementFromNode(node) {\n    return {\n        attributes: getAttributes(node),\n        value: convertToObject(node)\n    };\n}\n\nfunction getAttributes(element) {\n    const attributes = {};\n\n    for (let i = 0; i < element.attributes.length; i++) {\n        attributes[element.attributes[i].nodeName] = decodeURIComponent(escape(element.attributes[i].value));\n    }\n\n    return attributes;\n}\n\nfunction parseXMPObject(xmpObject) {\n    const tags = {};\n\n    if (typeof xmpObject === 'string') {\n        return xmpObject;\n    }\n\n    for (const nodeName in xmpObject) {\n        let nodes = xmpObject[nodeName];\n\n        if (!Array.isArray(nodes)) {\n            nodes = [nodes];\n        }\n\n        nodes.forEach((node) => {\n            objectAssign(tags, parseNodeAttributesAsTags(node.attributes));\n            if (typeof node.value === 'object') {\n                objectAssign(tags, parseNodeChildrenAsTags(node.value));\n            }\n        });\n    }\n\n    return tags;\n}\n\nfunction parseNodeAttributesAsTags(attributes) {\n    const tags = {};\n\n    for (const name in attributes) {\n        try {\n            if (isTagAttribute(name)) {\n                tags[getLocalName(name)] = {\n                    value: attributes[name],\n                    attributes: {},\n                    description: getDescription(attributes[name], name)\n                };\n            }\n        } catch (error) {\n            // Keep going and try to parse the rest of the tags.\n        }\n    }\n\n    return tags;\n}\n\nfunction isTagAttribute(name) {\n    return (name !== 'rdf:parseType') && (!isNamespaceDefinition(name));\n}\n\nfunction isNamespaceDefinition(name) {\n    return name.split(':')[0] === 'xmlns';\n}\n\nfunction getLocalName(name) {\n    if (/^MicrosoftPhoto(_\\d+_)?:Rating$/i.test(name)) {\n        return 'RatingPercent';\n    }\n    return name.split(':')[1];\n}\n\nfunction getDescription(value, name = undefined) {\n    if (Array.isArray(value)) {\n        const arrayDescription = getDescriptionOfArray(value);\n        if ((name) && (typeof XmpTagNames[name] === 'function')) {\n            return XmpTagNames[name](value, arrayDescription);\n        }\n        return arrayDescription;\n    }\n    if (typeof value === 'object') {\n        return getDescriptionOfObject(value);\n    }\n\n    try {\n        if ((name) && (typeof XmpTagNames[name] === 'function')) {\n            return XmpTagNames[name](value);\n        }\n        return decodeURIComponent(escape(value));\n    } catch (error) {\n        return value;\n    }\n}\n\nfunction getDescriptionOfArray(value) {\n    return value.map((item) => {\n        if (item.value !== undefined) {\n            return getDescription(item.value);\n        }\n        return getDescription(item);\n    }).join(', ');\n}\n\nfunction getDescriptionOfObject(value) {\n    const descriptions = [];\n\n    for (const key in value) {\n        descriptions.push(`${getClearTextKey(key)}: ${getDescription(value[key].value)}`);\n    }\n\n    return descriptions.join('; ');\n}\n\nfunction getClearTextKey(key) {\n    if (key === 'CiAdrCity') {\n        return 'CreatorCity';\n    }\n    if (key === 'CiAdrCtry') {\n        return 'CreatorCountry';\n    }\n    if (key === 'CiAdrExtadr') {\n        return 'CreatorAddress';\n    }\n    if (key === 'CiAdrPcode') {\n        return 'CreatorPostalCode';\n    }\n    if (key === 'CiAdrRegion') {\n        return 'CreatorRegion';\n    }\n    if (key === 'CiEmailWork') {\n        return 'CreatorWorkEmail';\n    }\n    if (key === 'CiTelWork') {\n        return 'CreatorWorkPhone';\n    }\n    if (key === 'CiUrlWork') {\n        return 'CreatorWorkUrl';\n    }\n    return key;\n}\n\nfunction parseNodeChildrenAsTags(children) {\n    const tags = {};\n\n    for (const name in children) {\n        try {\n            if (!isNamespaceDefinition(name)) {\n                tags[getLocalName(name)] = parseNodeAsTag(children[name], name);\n            }\n        } catch (error) {\n            // Keep going and try to parse the rest of the tags.\n        }\n    }\n\n    return tags;\n}\n\nfunction parseNodeAsTag(node, name) {\n    if (isDuplicateTag(node)) {\n        return parseNodeAsDuplicateTag(node, name);\n    }\n    if (isEmptyResourceTag(node)) {\n        return {value: '', attributes: {}, description: ''};\n    }\n    if (hasNestedSimpleRdfDescription(node)) {\n        return parseNodeAsSimpleRdfDescription(node, name);\n    }\n    if (hasNestedStructureRdfDescription(node)) {\n        return parseNodeAsStructureRdfDescription(node, name);\n    }\n    if (isCompactStructure(node)) {\n        return parseNodeAsCompactStructure(node, name);\n    }\n    if (isArray(node)) {\n        return parseNodeAsArray(node, name);\n    }\n    return parseNodeAsSimpleValue(node, name);\n}\n\nfunction isEmptyResourceTag(node) {\n    return (node.attributes['rdf:parseType'] === 'Resource')\n        && (typeof node.value === 'string')\n        && (node.value.trim() === '');\n}\n\nfunction isDuplicateTag(node) {\n    return Array.isArray(node);\n}\n\nfunction parseNodeAsDuplicateTag(node, name) {\n    return parseNodeAsSimpleValue(node[node.length - 1], name);\n}\n\nfunction hasNestedSimpleRdfDescription(node) {\n    return ((node.attributes['rdf:parseType'] === 'Resource') && (node.value['rdf:value'] !== undefined))\n        || ((node.value['rdf:Description'] !== undefined) && (node.value['rdf:Description'].value['rdf:value'] !== undefined));\n}\n\nfunction parseNodeAsSimpleRdfDescription(node, name) {\n    const attributes = parseNodeAttributes(node);\n\n    if (node.value['rdf:Description'] !== undefined) {\n        node = node.value['rdf:Description'];\n    }\n\n    objectAssign(attributes, parseNodeAttributes(node), parseNodeChildrenAsAttributes(node));\n\n    const value = parseRdfValue(node);\n\n    return {\n        value,\n        attributes,\n        description: getDescription(value, name)\n    };\n}\n\nfunction parseNodeAttributes(node) {\n    const attributes = {};\n\n    for (const name in node.attributes) {\n        if ((name !== 'rdf:parseType') && (name !== 'rdf:resource') && (!isNamespaceDefinition(name))) {\n            attributes[getLocalName(name)] = node.attributes[name];\n        }\n    }\n\n    return attributes;\n}\n\nfunction parseNodeChildrenAsAttributes(node) {\n    const attributes = {};\n\n    for (const name in node.value) {\n        if ((name !== 'rdf:value') && (!isNamespaceDefinition(name))) {\n            attributes[getLocalName(name)] = node.value[name].value;\n        }\n    }\n\n    return attributes;\n}\n\nfunction parseRdfValue(node) {\n    return getURIValue(node.value['rdf:value']) || node.value['rdf:value'].value;\n}\n\nfunction hasNestedStructureRdfDescription(node) {\n    return (node.attributes['rdf:parseType'] === 'Resource')\n        || ((node.value['rdf:Description'] !== undefined) && (node.value['rdf:Description'].value['rdf:value'] === undefined));\n}\n\nfunction parseNodeAsStructureRdfDescription(node, name) {\n    const tag = {\n        value: {},\n        attributes: {}\n    };\n\n    if (node.value['rdf:Description'] !== undefined) {\n        objectAssign(tag.value, parseNodeAttributesAsTags(node.value['rdf:Description'].attributes));\n        objectAssign(tag.attributes, parseNodeAttributes(node));\n        node = node.value['rdf:Description'];\n    }\n\n    objectAssign(tag.value, parseNodeChildrenAsTags(node.value));\n\n    tag.description = getDescription(tag.value, name);\n\n    return tag;\n}\n\nfunction isCompactStructure(node) {\n    return (Object.keys(node.value).length === 0)\n        && (node.attributes['xml:lang'] === undefined)\n        && (node.attributes['rdf:resource'] === undefined);\n}\n\nfunction parseNodeAsCompactStructure(node, name) {\n    const value = parseNodeAttributesAsTags(node.attributes);\n\n    return {\n        value,\n        attributes: {},\n        description: getDescription(value, name)\n    };\n}\n\nfunction isArray(node) {\n    return getArrayChild(node.value) !== undefined;\n}\n\nfunction getArrayChild(value) {\n    return value['rdf:Bag'] || value['rdf:Seq'] || value['rdf:Alt'];\n}\n\nfunction parseNodeAsArray(node, name) {\n    let items = getArrayChild(node.value).value['rdf:li'];\n    const attributes = parseNodeAttributes(node);\n    const value = [];\n\n    if (items === undefined) {\n        items = [];\n    } else if (!Array.isArray(items)) {\n        items = [items];\n    }\n\n    items.forEach((item) => {\n        value.push(parseArrayValue(item));\n    });\n\n    return {\n        value,\n        attributes,\n        description: getDescription(value, name)\n    };\n}\n\nfunction parseArrayValue(item) {\n    if (hasNestedSimpleRdfDescription(item)) {\n        return parseNodeAsSimpleRdfDescription(item);\n    }\n    if (hasNestedStructureRdfDescription(item)) {\n        return parseNodeAsStructureRdfDescription(item).value;\n    }\n    if (isCompactStructure(item)) {\n        return parseNodeAsCompactStructure(item).value;\n    }\n\n    return parseNodeAsSimpleValue(item);\n}\n\nfunction parseNodeAsSimpleValue(node, name) {\n    const value = getURIValue(node) || parseXMPObject(node.value);\n\n    return {\n        value,\n        attributes: parseNodeAttributes(node),\n        description: getDescription(value, name)\n    };\n}\n\nfunction getURIValue(node) {\n    return node.attributes && node.attributes['rdf:resource'];\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// https://www.w3.org/Graphics/GIF/spec-gif87.txt\n// https://www.w3.org/Graphics/GIF/spec-gif89a.txt\n\nimport {getStringFromDataView} from './utils.js';\n\nexport default {\n    read\n};\n\nfunction read(dataView) {\n    return {\n        'GIF Version': getGifVersion(dataView),\n        'Image Width': getImageWidth(dataView),\n        'Image Height': getImageHeight(dataView),\n        'Global Color Map': getGlobalColorMap(dataView),\n        'Bits Per Pixel': getBitDepth(dataView),\n        'Color Resolution Depth': getColorResolution(dataView)\n    };\n}\n\nfunction getGifVersion(dataView) {\n    const OFFSET = 3;\n    const SIZE = 3;\n\n    if (OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = getStringFromDataView(dataView, OFFSET, SIZE);\n    return {\n        value,\n        description: value\n    };\n}\n\nfunction getImageWidth(dataView) {\n    const OFFSET = 6;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = dataView.getUint16(OFFSET, true);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getImageHeight(dataView) {\n    const OFFSET = 8;\n    const SIZE = 2;\n\n    if (OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const value = dataView.getUint16(OFFSET, true);\n    return {\n        value,\n        description: `${value}px`\n    };\n}\n\nfunction getGlobalColorMap(dataView) {\n    const OFFSET = 10;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const byteValue = dataView.getUint8(OFFSET);\n    const value = (byteValue & 0b10000000) >>> 7;\n    return {\n        value,\n        description: value === 1 ? 'Yes' : 'No'\n    };\n}\n\nfunction getColorResolution(dataView) {\n    const OFFSET = 10;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const byteValue = dataView.getUint8(OFFSET);\n    const value = ((byteValue & 0b01110000) >>> 4) + 1; // Zero-based.\n    return {\n        value,\n        description: `${value} ${value === 1 ? 'bit' : 'bits'}`\n    };\n}\n\nfunction getBitDepth(dataView) {\n    const OFFSET = 10;\n    const SIZE = 1;\n\n    if (OFFSET + SIZE > dataView.byteLength) {\n        return undefined;\n    }\n\n    const byteValue = dataView.getUint8(OFFSET);\n    const value = (byteValue & 0b00000111) + 1; // Zero-based.\n    return {\n        value,\n        description: `${value} ${value === 1 ? 'bit' : 'bits'}`\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Specification:\n// https://aomediacodec.github.io/av1-avif\n\nimport {parseBox, findOffsets} from './image-header-iso-bmff.js';\n\nexport default {\n    isAvifFile,\n    findAvifOffsets\n};\n\n/**\n * Checks if the provided data view represents an AVIF file.\n *\n * @param {DataView} dataView - The data view to check.\n * @returns {boolean} True if the data view represents an AVIF file, false otherwise.\n */\nfunction isAvifFile(dataView) {\n    if (!dataView) {\n        return false;\n    }\n\n    try {\n        const headerBox = parseBox(dataView, 0);\n        return headerBox && headerBox.majorBrand === 'avif';\n    } catch (error) {\n        return false;\n    }\n}\n\n/**\n * Finds the offsets of an AVIF file in the provided data view.\n *\n * @param {DataView} dataView - The data view to find offsets in.\n * @returns {Object} An object containing the offsets of the TIFF header, XMP chunks, ICC chunks, and a boolean indicating if any of these exist.\n */\nfunction findAvifOffsets(dataView) {\n    return findOffsets(dataView);\n}\n","import { accumulateEffectsAndReport } from \"@beep/errors/client\";\nimport * as Effect from \"effect/Effect\";\nimport { instrumentProcessFile, makeFileAnnotations } from \"@/features/upload/observability\";\nimport { extractBasicMetadata, extractExifMetadata, validateFile } from \"@/features/upload/pipeline\";\nimport type { PipelineConfig, ProcessFilesResult, UploadResult } from \"@/features/upload/UploadModels\";\n/**\n * UploadFileService\n * - Effect service exposing high-level operations for processing one or many files\n * - Delegates to composable pipeline steps in `pipeline.ts`\n */\nexport class UploadFileService extends Effect.Service<UploadFileService>()(\"UploadFileService\", {\n  dependencies: [],\n  accessors: true,\n  effect: Effect.gen(function* () {\n    const processFile = Effect.fn(\"UploadFileService.processFile\")(function* ({\n      file,\n      config,\n    }: {\n      readonly file: File;\n      readonly config?: PipelineConfig;\n    }) {\n      const eff = Effect.gen(function* () {\n        const validated = yield* validateFile({ file, config });\n        const basic = yield* extractBasicMetadata({ file, detected: validated.detected });\n        const exif = yield* extractExifMetadata({ file, detected: basic.detected ?? validated.detected });\n\n        const result: UploadResult = {\n          file,\n          validated,\n          basic,\n          exif,\n        };\n        return result;\n      });\n      return yield* eff.pipe(instrumentProcessFile(makeFileAnnotations(file)));\n    });\n\n    const processFiles = Effect.fn(\"UploadFileService.processFiles\")(function* ({\n      files,\n      config,\n    }: {\n      readonly files: ReadonlyArray<File>;\n      readonly config?: PipelineConfig;\n    }) {\n      const effects = files.map((file) => processFile({ file, config }));\n      const result = yield* accumulateEffectsAndReport(effects, {\n        concurrency: \"unbounded\",\n        annotations: { service: \"upload\" },\n      });\n      return result satisfies ProcessFilesResult;\n    });\n\n    return { processFile, processFiles, validateFile, extractBasicMetadata, extractExifMetadata };\n  }),\n}) {}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Specification: https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/\n\nimport {getDataView, getStringFromDataView, getPascalStringFromDataView} from './utils.js';\nimport Types from './types.js';\nimport TagNames from './photoshop-tag-names.js';\n\nexport default {\n    read\n};\n\nconst SIGNATURE = '8BIM';\nconst TAG_ID_SIZE = 2;\nconst RESOURCE_LENGTH_SIZE = 4;\n\nconst SIGNATURE_SIZE = SIGNATURE.length;\n\nfunction read(bytes, includeUnknown) {\n    const dataView = getDataView(new Uint8Array(bytes).buffer);\n    const tags = {};\n    let offset = 0;\n\n    while (offset < bytes.length) {\n        const signature = getStringFromDataView(dataView, offset, SIGNATURE_SIZE);\n        offset += SIGNATURE_SIZE;\n        const tagId = Types.getShortAt(dataView, offset);\n        offset += TAG_ID_SIZE;\n        const {tagName, tagNameSize} = getTagName(dataView, offset);\n        offset += tagNameSize;\n        const resourceSize = Types.getLongAt(dataView, offset);\n        offset += RESOURCE_LENGTH_SIZE;\n        if (signature === SIGNATURE) {\n            const valueDataView = getDataView(dataView.buffer, offset, resourceSize);\n            const tag = {\n                id: tagId,\n                value: getStringFromDataView(valueDataView, 0, resourceSize),\n            };\n            if (TagNames[tagId]) {\n                try {\n                    tag.description = TagNames[tagId].description(valueDataView);\n                } catch (error) {\n                    tag.description = '<no description formatter>';\n                }\n                tags[tagName ? tagName : TagNames[tagId].name] = tag;\n            } else if (includeUnknown) {\n                tags[`undefined-${tagId}`] = tag;\n            }\n        }\n        offset += resourceSize + (resourceSize % 2);\n    }\n\n    return tags;\n}\n\nfunction getTagName(dataView, offset) {\n    // The name is encoded as a Pascal string (the string is prefixed with one\n    // byte containing the length of the string) and everything is padded with a\n    // null byte to make the size even.\n    const [stringSize, string] = getPascalStringFromDataView(dataView, offset);\n    return {\n        tagName: string,\n        tagNameSize: 1 + stringSize + (stringSize % 2 === 0 ? 1 : 0)\n    };\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport ByteOrder from './byte-order.js';\nimport Types from './types.js';\nimport {IFD_TYPE_MPF} from './tag-names.js';\nimport {deferInit, getBase64Image} from './utils.js';\nimport {readIfd, get0thIfdOffset} from './tags-helpers.js';\n\nexport default {\n    read\n};\n\nconst ENTRY_SIZE = 16;\n\nfunction read(dataView, dataOffset, includeUnknown) {\n    const byteOrder = ByteOrder.getByteOrder(dataView, dataOffset);\n    const tags = readIfd(dataView, IFD_TYPE_MPF, dataOffset, get0thIfdOffset(dataView, dataOffset, byteOrder), byteOrder, includeUnknown);\n    return addMpfImages(dataView, dataOffset, tags, byteOrder);\n}\n\nfunction addMpfImages(dataView, dataOffset, tags, byteOrder) {\n    if (!tags['MPEntry']) {\n        return tags;\n    }\n\n    const images = [];\n    for (let i = 0; i < Math.ceil(tags['MPEntry'].value.length / ENTRY_SIZE); i++) {\n        images[i] = {};\n\n        const attributes = getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE, Types.getTypeSize('LONG'), byteOrder);\n        images[i]['ImageFlags'] = getImageFlags(attributes);\n        images[i]['ImageFormat'] = getImageFormat(attributes);\n        images[i]['ImageType'] = getImageType(attributes);\n\n        const imageSize = getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE + 4, Types.getTypeSize('LONG'), byteOrder);\n        images[i]['ImageSize'] = {\n            value: imageSize,\n            description: '' + imageSize\n        };\n\n        const imageOffset = getImageOffset(i, tags['MPEntry'], byteOrder, dataOffset);\n        images[i]['ImageOffset'] = {\n            value: imageOffset,\n            description: '' + imageOffset\n        };\n\n        const dependentImage1EntryNumber =\n            getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE + 12, Types.getTypeSize('SHORT'), byteOrder);\n        images[i]['DependentImage1EntryNumber'] = {\n            value: dependentImage1EntryNumber,\n            description: '' + dependentImage1EntryNumber\n        };\n\n        const dependentImage2EntryNumber =\n            getImageNumberValue(tags['MPEntry'].value, i * ENTRY_SIZE + 14, Types.getTypeSize('SHORT'), byteOrder);\n        images[i]['DependentImage2EntryNumber'] = {\n            value: dependentImage2EntryNumber,\n            description: '' + dependentImage2EntryNumber\n        };\n\n        images[i].image = dataView.buffer.slice(imageOffset, imageOffset + imageSize);\n        deferInit(images[i], 'base64', function () {\n            return getBase64Image(this.image);\n        });\n    }\n\n    tags['Images'] = images;\n\n    return tags;\n}\n\nfunction getImageNumberValue(entries, offset, size, byteOrder) {\n    if (byteOrder === ByteOrder.LITTLE_ENDIAN) {\n        let value = 0;\n        for (let i = 0; i < size; i++) {\n            value += entries[offset + i] << (8 * i);\n        }\n        return value;\n    }\n\n    let value = 0;\n    for (let i = 0; i < size; i++) {\n        value += entries[offset + i] << (8 * (size - 1 - i));\n    }\n    return value;\n}\n\nfunction getImageFlags(attributes) {\n    const flags = [\n        (attributes >> 31) & 0x1,\n        (attributes >> 30) & 0x1,\n        (attributes >> 29) & 0x1\n    ];\n\n    const flagsDescription = [];\n\n    if (flags[0]) {\n        flagsDescription.push('Dependent Parent Image');\n    }\n    if (flags[1]) {\n        flagsDescription.push('Dependent Child Image');\n    }\n    if (flags[2]) {\n        flagsDescription.push('Representative Image');\n    }\n\n    return {\n        value: flags,\n        description: flagsDescription.join(', ') || 'None'\n    };\n}\n\nfunction getImageFormat(attributes) {\n    const imageFormat = attributes >> 24 & 0x7;\n    return {\n        value: imageFormat,\n        description: imageFormat === 0 ? 'JPEG' : 'Unknown'\n    };\n}\n\nfunction getImageType(attributes) {\n    const type = attributes & 0xffffff;\n    const descriptions = {\n        0x30000: 'Baseline MP Primary Image',\n        0x10001: 'Large Thumbnail (VGA equivalent)',\n        0x10002: 'Large Thumbnail (Full HD equivalent)',\n        0x20001: 'Multi-Frame Image (Panorama)',\n        0x20002: 'Multi-Frame Image (Disparity)',\n        0x20003: 'Multi-Frame Image (Multi-Angle)',\n        0x0: 'Undefined',\n    };\n\n    return {\n        value: type,\n        description: descriptions[type] || 'Unknown'\n    };\n}\n\nfunction getImageOffset(imageIndex, mpEntry, byteOrder, dataOffset) {\n    if (isFirstIndividualImage(imageIndex)) {\n        return 0;\n    }\n    return getImageNumberValue(mpEntry.value, imageIndex * ENTRY_SIZE + 8, Types.getTypeSize('LONG'), byteOrder) + dataOffset;\n}\n\nfunction isFirstIndividualImage(imageIndex) {\n    return imageIndex === 0;\n}\n","import { formatSize } from \"@beep/files-domain/utils\";\nimport {\n  type DetectedFileInfo,\n  ExifMetadata,\n  FileAttributes,\n  fileTypeChecker,\n  getFileChunk,\n} from \"@beep/files-domain/value-objects\";\nimport { BS } from \"@beep/schema\";\nimport * as Effect from \"effect/Effect\";\nimport * as Metric from \"effect/Metric\";\nimport * as S from \"effect/Schema\";\nimport * as Str from \"effect/String\";\nimport ExifReader from \"exifreader\";\nimport * as Errors from \"./errors\";\nimport { logInfo, logWarning, makeFileAnnotations, UploadMetrics } from \"./observability\";\nimport {\n  type BasicMetadataOutput,\n  DEFAULT_CHUNK_SIZE,\n  type PipelineConfig,\n  type ValidateFileOutput,\n} from \"./UploadModels\";\n/**\n * Validate a File against size and signature rules.\n */\nexport const validateFile = Effect.fn(\"upload.validateFile\")(function* ({\n  file,\n  config,\n}: {\n  readonly file: File;\n  readonly config?: PipelineConfig;\n}) {\n  const formattedSize = formatSize(file.size);\n  // Size check (friendly message using BS.formatSize)\n  if (typeof config?.maxSizeBytes === \"number\" && file.size > config.maxSizeBytes) {\n    const actual = formattedSize;\n    const max = formatSize(config.maxSizeBytes);\n    return yield* new Errors.ValidationError({\n      message: `File too large: ${actual} (max ${max})`,\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size,\n    });\n  }\n\n  const chunkSize = config?.chunkSize ?? DEFAULT_CHUNK_SIZE;\n  const buffer = yield* Effect.tryPromise({\n    try: async () => file.arrayBuffer(),\n    catch: (e) =>\n      new Errors.DetectionError({\n        message: \"Could not detect file type from signature\",\n        cause: e,\n        fileName: file.name,\n        fileType: file.type,\n        fileSize: file.size,\n        chunkSize,\n      }),\n  });\n  const chunk = getFileChunk(buffer, chunkSize);\n  const detected = fileTypeChecker.detectFile(chunk, { chunkSize });\n  if (!detected) {\n    // increment metric and warn before failing\n    yield* Metric.increment(UploadMetrics.detectionFailedTotal);\n    yield* logWarning(\"upload.validateFile: signature detection failed\", makeFileAnnotations(file));\n    return yield* new Errors.DetectionError({\n      message: \"Could not detect file type from signature\",\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size,\n      chunkSize,\n    });\n  }\n  // Ensure detected mime is supported by our schema; fail early with a helpful error\n  const candidate = detected?.mimeType ?? file.type;\n  yield* S.decodeUnknown(BS.MimeType)(candidate).pipe(\n    Effect.tapError((error) =>\n      logWarning(\"upload.validateFile: unsupported mime type\", {\n        ...makeFileAnnotations(file),\n        candidate,\n        error,\n      })\n    ),\n    Effect.mapError(\n      (error) =>\n        new Errors.ValidationError({\n          message: `Unsupported mime type: ${candidate}`,\n          cause: error,\n          fileName: file.name,\n          fileType: candidate,\n          fileSize: file.size,\n        })\n    )\n  );\n  if (config?.allowedMime) {\n    if (!config.allowedMime.includes(candidate)) {\n      yield* logWarning(\"upload.validateFile: disallowed MIME\", {\n        ...makeFileAnnotations(file),\n        candidate,\n        allowed: config.allowedMime,\n      });\n      return yield* new Errors.ValidationError({\n        message: `Disallowed type: ${candidate}`,\n        fileName: file.name,\n        fileType: file.type,\n        fileSize: file.size,\n        candidateMime: candidate,\n        allowedMime: config.allowedMime,\n      });\n    }\n  }\n\n  return { detected, formattedSize } satisfies ValidateFileOutput;\n});\n\n/**\n * Extract basic file metadata and optionally reuse detection result.\n * NOTE: This is a scaffolding stub. Use Effect + Schema to validate attributes when implementing.\n */\nexport const extractBasicMetadata = Effect.fn(\"upload.extractBasicMetadata\")(function* ({\n  file,\n  detected,\n}: {\n  readonly file: File;\n  readonly detected?: DetectedFileInfo.Type;\n}) {\n  // Build attributes and validate at runtime using effect/Schema\n  const wrp = file.webkitRelativePath;\n  const hasWrp = Str.isString(wrp) && wrp.length > 0;\n  const candidateType = detected?.mimeType ?? file.type;\n\n  const attributesInput = {\n    size: file.size,\n    type: candidateType,\n    // Schema expects both lastModifiedDate and lastModified as acceptable date types\n    lastModifiedDate: file.lastModified,\n    lastModified: file.lastModified,\n    name: file.name,\n    ...(hasWrp ? { webkitRelativePath: wrp, relativePath: wrp } : {}),\n  };\n\n  const attributes = yield* S.decodeUnknown(FileAttributes)(attributesInput).pipe(\n    Effect.tapError((error) =>\n      logWarning(\"upload.extractBasicMetadata: invalid file attributes\", {\n        ...makeFileAnnotations(file),\n        candidateType,\n        error,\n      })\n    ),\n    Effect.mapError(\n      (error) =>\n        new Errors.ValidationError({\n          message: \"Invalid file attributes\",\n          cause: error,\n          fileName: file.name,\n          fileType: candidateType,\n          fileSize: file.size,\n        })\n    )\n  );\n\n  return { attributes, detected } satisfies BasicMetadataOutput;\n});\n\n/**\n * Extract EXIF metadata for images (when present). Return undefined on non-images or parse failure.\n * NOTE: This is a scaffolding stub. Wire exifreader + BS.cleanExifData + S.decode(BS.ExpandedTags) in implementation.\n */\nexport const extractExifMetadata = Effect.fn(\"upload.extractExifMetadata\")(function* ({\n  file,\n  detected,\n}: {\n  readonly file: File;\n  readonly detected?: DetectedFileInfo.Type;\n}) {\n  // Simple guard: skip if not an image by MIME (prefer detected mime when available)\n  const candidateMime = detected?.mimeType ?? file.type;\n  if (!candidateMime || !candidateMime.startsWith(\"image/\")) {\n    return undefined;\n  }\n\n  // Try EXIF parse, but do not fail the pipeline: log warning and return undefined on failure\n  return yield* Effect.gen(function* () {\n    const buffer = yield* Effect.tryPromise({\n      try: () => file.arrayBuffer(),\n      catch: (e) =>\n        new Errors.ExifParseError({\n          message: \"Could not parse EXIF data because array buffer could not be read\",\n          cause: e,\n          fileName: file.name,\n          fileType: file.type,\n          fileSize: file.size,\n          phase: \"read\",\n        }),\n    });\n    const raw = yield* Effect.try({\n      try: () => ExifReader.load(buffer, { expanded: true }),\n      catch: (e) =>\n        new Errors.ExifParseError({\n          message: \"Could not parse EXIF data\",\n          cause: e,\n          fileName: file.name,\n          fileType: file.type,\n          fileSize: file.size,\n          phase: \"parse\",\n        }),\n    });\n    const cleaned = ExifMetadata.cleanExifData(raw);\n    const decoded = yield* S.decodeUnknown(ExifMetadata)(cleaned).pipe(\n      Effect.mapError(\n        (e) =>\n          new Errors.ExifParseError({\n            message: \"Could not decode EXIF data to schema\",\n            cause: e,\n            fileName: file.name,\n            fileType: file.type,\n            fileSize: file.size,\n            phase: \"decode\",\n          })\n      )\n    );\n    // success: increment metric and log\n    yield* Metric.increment(UploadMetrics.exifParsedTotal);\n    yield* logInfo(\"upload.extractExifMetadata: parsed EXIF\", makeFileAnnotations(file));\n    return decoded;\n  }).pipe(\n    Effect.catchAll((error) =>\n      Effect.gen(function* () {\n        yield* Metric.increment(UploadMetrics.exifFailedTotal);\n        yield* logWarning(\"upload.extractExifMetadata: non-fatal EXIF parse failure\", {\n          ...makeFileAnnotations(file),\n          error,\n        });\n        return undefined;\n      })\n    )\n  );\n});\n","import type { UnsafeTypes } from \"@beep/types\";\nimport type * as S from \"effect/Schema\";\nimport type * as Sizes from \"../value-objects/FileSize\";\n\n/* ============================================================================\n * Unit types inferred from your Schemas (kept in one place for clarity)\n * ========================================================================== */\ntype SiByteUnit = S.Schema.Type<typeof Sizes.ByteUnit>; // 'B' | 'kB' | ... | 'YB'\ntype IecByteUnit = S.Schema.Type<typeof Sizes.BiByteUnit>; // 'B' | 'KiB' | ... | 'YiB'\ntype SiBitUnit = S.Schema.Type<typeof Sizes.BitUnit>; // 'b' | 'kbit' | ... | 'Ybit'\ntype IecBitUnit = S.Schema.Type<typeof Sizes.BiBitUnit>; // 'b' | 'kibit' | ... | 'Yibit'\n\n/* ============================================================================\n * Runtime unit tables (type-checked against the schemas)\n * ========================================================================== */\nconst BYTE_UNITS = [\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"] as const satisfies readonly SiByteUnit[];\n\nconst BIBYTE_UNITS = [\n  \"B\",\n  \"KiB\",\n  \"MiB\",\n  \"GiB\",\n  \"TiB\",\n  \"PiB\",\n  \"EiB\",\n  \"ZiB\",\n  \"YiB\",\n] as const satisfies readonly IecByteUnit[];\n\nconst BIT_UNITS = [\n  \"b\",\n  \"kbit\",\n  \"Mbit\",\n  \"Gbit\",\n  \"Tbit\",\n  \"Pbit\",\n  \"Ebit\",\n  \"Zbit\",\n  \"Ybit\",\n] as const satisfies readonly SiBitUnit[];\n\nconst BIBIT_UNITS = [\n  \"b\",\n  \"kibit\",\n  \"Mibit\",\n  \"Gibit\",\n  \"Tibit\",\n  \"Pibit\",\n  \"Eibit\",\n  \"Zibit\",\n  \"Yibit\",\n] as const satisfies readonly IecBitUnit[];\n\nexport interface PrettyBytesOptions {\n  /**\n   * Include plus sign for positive numbers. If the difference is exactly zero a\n   * space character will be prepended instead for better alignment.\n   * @default false\n   */\n  readonly signed?: undefined | boolean;\n\n  /**\n   * - If `false`: Output won't be localized.\n   * - If `true`: Localize using the system/browser locale.\n   * - If `string`: BCP 47 language tag (e.g., 'en', 'de').\n   * - If `string[]`: List of BCP 47 language tags (e.g., ['en', 'de']).\n   * @default false\n   */\n  readonly locale?: undefined | boolean | string | readonly string[];\n\n  /**\n   * Format the number as bits instead of bytes (useful for bit-rates).\n   * @default false\n   */\n  readonly bits?: undefined | boolean;\n\n  /**\n   * Use IEC binary prefixes (KiB, MiB, ...) instead of SI decimal (kB, MB, ...).\n   * Common for memory amounts; avoid for file sizes shown to end users.\n   * @default false\n   */\n  readonly binary?: boolean;\n\n  /**\n   * Minimum fraction digits to display. If neither `minimumFractionDigits` nor\n   * `maximumFractionDigits` are set, the default is rounding to 3 significant digits.\n   */\n  readonly minimumFractionDigits?: number;\n\n  /**\n   * Maximum fraction digits to display. If neither `minimumFractionDigits` nor\n   * `maximumFractionDigits` are set, the default is rounding to 3 significant digits.\n   */\n  readonly maximumFractionDigits?: number;\n\n  /**\n   * Put a space between the number and unit.\n   * @default true\n   */\n  readonly space?: boolean;\n}\n\n/** Resolve `bits` with default `false`. */\ntype ResolveBits<O> = O extends { bits?: infer B } ? (B extends boolean ? B : false) : false;\n\n/** Resolve `binary` with default `false`. */\ntype ResolveBinary<O> = O extends { binary?: infer B } ? (B extends boolean ? B : false) : false;\n\n/** Resolve `space` with default `true`. */\ntype ResolveSpace<O> = O extends { space?: infer S } ? (S extends boolean ? S : true) : true;\n\n/** Pick the unit family based on options. */\ntype UnitFor<Bits extends boolean, Binary extends boolean> = Bits extends true\n  ? Binary extends true\n    ? IecBitUnit\n    : SiBitUnit\n  : Binary extends true\n    ? IecByteUnit\n    : SiByteUnit;\n\n/** Unit family for a concrete options type. */\ntype UnitForOptions<O> = UnitFor<ResolveBits<O>, ResolveBinary<O>>;\n\n/** Separator based on options.space ('' | ' '). */\ntype SpaceForOptions<O> = ResolveSpace<O> extends false ? \"\" : \" \";\n\n/**\n * Template literal string type that ensures the unit part is always one of\n * the valid units for the provided options.\n */\nexport type PrettyBytesString<O extends PrettyBytesOptions | undefined> =\n  `${string}${SpaceForOptions<O>}${UnitForOptions<O>}`;\n\n/* ============================================================================\n * Internal helpers (locale/BigInt-safe log/divide)\n * ========================================================================== */\n\n/**\n * Formats the given number using `Number#toLocaleString`.\n * - If locale is a string (or array), it's a BCP 47 tag (or list of tags).\n * - If locale is true, the system default locale is used.\n * - If no locale specified, returns the number formatted with default JS rules.\n */\nconst toLocaleStr = (\n  value: number,\n  locale: PrettyBytesOptions[\"locale\"],\n  options?: Intl.NumberFormatOptions\n): string => {\n  if (typeof locale === \"string\" || Array.isArray(locale)) {\n    return value.toLocaleString(locale as UnsafeTypes.UnsafeAny, options);\n  }\n  if (locale === true || options !== undefined) {\n    return value.toLocaleString(undefined, options);\n  }\n  return String(value);\n};\n\nconst log10 = (n: number | bigint): number => {\n  if (typeof n === \"number\") {\n    return Math.log10(n);\n  }\n  // BigInt: approximate log10 using length + first digits\n  const s = n.toString(10);\n  return s.length + Math.log10(Number.parseFloat(`0.${s.slice(0, 15)}`));\n};\n\nconst ln = (n: number | bigint): number => {\n  if (typeof n === \"number\") {\n    return Math.log(n);\n  }\n  return log10(n) * Math.log(10);\n};\n\nconst divide = (n: number | bigint, divisor: number): number => {\n  if (typeof n === \"number\") {\n    return n / divisor;\n  }\n  const i = n / BigInt(divisor);\n  const r = n % BigInt(divisor);\n  return Number(i) + Number(r) / divisor;\n};\n\n/* ============================================================================\n * Implementation\n * ========================================================================== */\n\n/**\n * Convert bytes (or bits) to a humanreadable string: `1337`  `'1.34 kB'`.\n *\n * Returns a template-literal string whose **unit is typesafe** given the\n * provided options:\n *\n * - `{ bits: false, binary: false }`  SI **bytes** (B, kB, MB, )\n * - `{ bits: false, binary: true }`   IEC **bytes** (B, KiB, MiB, )\n * - `{ bits: true,  binary: false }`  SI **bits** (b, kbit, Mbit, )\n * - `{ bits: true,  binary: true }`   IEC **bits** (b, kibit, Mibit, )\n *\n * Defaults: `bits=false`, `binary=false`, `space=true`.\n *\n * @example\n * prettyBytes(1337)                      // '1.34 kB'\n * prettyBytes(100)                       // '100 B'\n * prettyBytes(42, { signed: true })      // '+42 B'\n * prettyBytes(1337, { locale: 'de' })    // '1,34 kB'\n * prettyBytes(1337, { bits: true })      // '1.34 kbit'\n * prettyBytes(1024, { binary: true })    // '1 KiB'\n * prettyBytes(1920, { space: false })    // '1.92kB'\n */\nexport function formatSize<O extends PrettyBytesOptions | undefined = undefined>(\n  value: number | bigint,\n  options?: O\n): PrettyBytesString<O> {\n  if (typeof value !== \"bigint\" && !Number.isFinite(value)) {\n    // Keep the original error semantics\n    throw new TypeError(`Expected a finite number, got ${typeof value}: ${value}`);\n  }\n\n  const opts: Required<Pick<PrettyBytesOptions, \"bits\" | \"binary\" | \"space\">> &\n    Omit<PrettyBytesOptions, \"bits\" | \"binary\" | \"space\"> = {\n    bits: false,\n    binary: false,\n    space: true,\n    ...options,\n  };\n\n  const UNITS = opts.bits ? (opts.binary ? BIBIT_UNITS : BIT_UNITS) : opts.binary ? BIBYTE_UNITS : BYTE_UNITS;\n\n  const separator = opts.space ? \" \" : \"\";\n\n  // Special aligned zero when signed is true\n  if (opts.signed && (typeof value === \"number\" ? value === 0 : value === 0n)) {\n    return ` 0${separator}${UNITS[0]}` as PrettyBytesString<O>;\n    // ^ leading space matches original library behavior\n  }\n\n  const isNegative = value < 0;\n  const prefix = isNegative ? \"-\" : opts.signed ? \"+\" : \"\";\n\n  if (isNegative) {\n    value = typeof value === \"number\" ? -value : -value;\n  }\n\n  let localeOptions: Intl.NumberFormatOptions | undefined;\n  if (opts.minimumFractionDigits !== undefined) {\n    localeOptions = { minimumFractionDigits: opts.minimumFractionDigits };\n  }\n  if (opts.maximumFractionDigits !== undefined) {\n    localeOptions = {\n      maximumFractionDigits: opts.maximumFractionDigits,\n      ...localeOptions,\n    };\n  }\n\n  // For magnitudes < 1, don't scale  just attach the base unit.\n  if (typeof value === \"number\" ? value < 1 : value < 1n) {\n    const numberString = toLocaleStr(typeof value === \"number\" ? value : Number(value), opts.locale, localeOptions);\n    return (prefix + numberString + separator + UNITS[0]) as PrettyBytesString<O>;\n  }\n\n  // Compute exponent for either base 1000 (SI) or 1024 (IEC)\n  const base = opts.binary ? 1024 : 1000;\n  const exp = Math.min(Math.floor(opts.binary ? ln(value) / Math.log(1024) : log10(value) / 3), UNITS.length - 1);\n\n  let scaled = divide(value, base ** exp);\n\n  // Default behavior: round to 3 significant digits if no explicit fraction-digit policy\n  if (!localeOptions) {\n    const intLen = Number.parseInt(String(scaled), 10).toString().length;\n    const minPrecision = Math.max(3, intLen);\n    scaled = Number(scaled.toPrecision(minPrecision));\n  }\n\n  const numberString = toLocaleStr(Number(scaled), opts.locale, localeOptions);\n\n  const unit = UNITS[exp];\n  return (prefix + numberString + separator + unit) as PrettyBytesString<O>;\n}\n\n/* ============================================================================\n * Handy re-exports (optional)\n * ========================================================================== */\n\nexport type { SiByteUnit, IecByteUnit, SiBitUnit, IecBitUnit };\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Specification: http://www.libpng.org/pub/png/spec/1.2/\n\nimport {getStringValueFromArray, getStringFromDataView, decompress, COMPRESSION_METHOD_NONE} from './utils.js';\nimport TagDecoder from './tag-decoder.js';\nimport {TYPE_TEXT, TYPE_ITXT, TYPE_ZTXT} from './image-header-png.js';\nimport Tags from './tags.js';\nimport IptcTags from './iptc-tags.js';\nimport Constants from './constants.js';\n\nexport default {\n    read\n};\n\nconst STATE_KEYWORD = 'STATE_KEYWORD';\nconst STATE_COMPRESSION = 'STATE_COMPRESSION';\nconst STATE_LANG = 'STATE_LANG';\nconst STATE_TRANSLATED_KEYWORD = 'STATE_TRANSLATED_KEYWORD';\nconst STATE_TEXT = 'STATE_TEXT';\nconst COMPRESSION_SECTION_ITXT_EXTRA_BYTE = 1;\nconst COMPRESSION_FLAG_COMPRESSED = 1;\nconst EXIF_OFFSET = 6;\n\nfunction read(dataView, pngTextChunks, async, includeUnknown) {\n    const tags = {};\n    const tagsPromises = [];\n    for (let i = 0; i < pngTextChunks.length; i++) {\n        const {offset, length, type} = pngTextChunks[i];\n        const nameAndValue = getNameAndValue(dataView, offset, length, type, async);\n        if (nameAndValue instanceof Promise) {\n            tagsPromises.push(nameAndValue.then(({name, value, description}) => {\n                try {\n                    if (Constants.USE_EXIF && isExifGroupTag(name, value)) {\n                        return {\n                            __exif: Tags.read(decodeRawData(value), EXIF_OFFSET, includeUnknown).tags\n                        };\n                    } else if (Constants.USE_IPTC && isIptcGroupTag(name, value)) {\n                        return {\n                            __iptc: IptcTags.read(decodeRawData(value), 0, includeUnknown)\n                        };\n                    } else if (name && !isExifGroupTag(name, value) && !isIptcGroupTag(name, value)) {\n                        return {\n                            [name]: {\n                                value,\n                                description\n                            }\n                        };\n                    }\n                } catch (error) {\n                    // Ignore the broken tag.\n                }\n                return {};\n            }));\n        } else {\n            const {name, value, description} = nameAndValue;\n            if (name) {\n                tags[name] = {\n                    value,\n                    description\n                };\n            }\n        }\n    }\n\n    return {\n        readTags: tags,\n        readTagsPromise: tagsPromises.length > 0 ? Promise.all(tagsPromises) : undefined\n    };\n}\n\nfunction getNameAndValue(dataView, offset, length, type, async) {\n    const keywordChars = [];\n    const langChars = [];\n    const translatedKeywordChars = [];\n    let valueChars;\n    let parsingState = STATE_KEYWORD;\n    let compressionMethod = COMPRESSION_METHOD_NONE;\n\n    for (let i = 0; i < length && offset + i < dataView.byteLength; i++) {\n        if (parsingState === STATE_COMPRESSION) {\n            compressionMethod = getCompressionMethod({type, dataView, offset: offset + i});\n            if (type === TYPE_ITXT) {\n                i += COMPRESSION_SECTION_ITXT_EXTRA_BYTE;\n            }\n            parsingState = moveToNextState(type, parsingState);\n            continue;\n        } else if (parsingState === STATE_TEXT) {\n            valueChars = new DataView(dataView.buffer.slice(offset + i, offset + length));\n            break;\n        }\n        const byte = dataView.getUint8(offset + i);\n        if (byte === 0) {\n            parsingState = moveToNextState(type, parsingState);\n        } else if (parsingState === STATE_KEYWORD) {\n            keywordChars.push(byte);\n        } else if (parsingState === STATE_LANG) {\n            langChars.push(byte);\n        } else if (parsingState === STATE_TRANSLATED_KEYWORD) {\n            translatedKeywordChars.push(byte);\n        }\n    }\n\n    if (compressionMethod !== COMPRESSION_METHOD_NONE && !async) {\n        return {};\n    }\n    const decompressedValueChars = decompress(valueChars, compressionMethod, getEncodingFromType(type));\n    if (decompressedValueChars instanceof Promise) {\n        return decompressedValueChars\n            .then((_decompressedValueChars) => constructTag(_decompressedValueChars, type, langChars, keywordChars))\n            .catch(() => constructTag('<text using unknown compression>'.split(''), type, langChars, keywordChars));\n    }\n    return constructTag(decompressedValueChars, type, langChars, keywordChars);\n}\n\nfunction getCompressionMethod({type, dataView, offset}) {\n    if (type === TYPE_ITXT) {\n        if (dataView.getUint8(offset) === COMPRESSION_FLAG_COMPRESSED) {\n            return dataView.getUint8(offset + 1);\n        }\n    } else if (type === TYPE_ZTXT) {\n        return dataView.getUint8(offset);\n    }\n    return COMPRESSION_METHOD_NONE;\n}\n\nfunction moveToNextState(type, parsingState) {\n    if (parsingState === STATE_KEYWORD && [TYPE_ITXT, TYPE_ZTXT].includes(type)) {\n        return STATE_COMPRESSION;\n    }\n    if (parsingState === STATE_COMPRESSION) {\n        if (type === TYPE_ITXT) {\n            return STATE_LANG;\n        }\n        return STATE_TEXT;\n    }\n    if (parsingState === STATE_LANG) {\n        return STATE_TRANSLATED_KEYWORD;\n    }\n    return STATE_TEXT;\n}\n\nfunction getEncodingFromType(type) {\n    if (type === TYPE_TEXT || type === TYPE_ZTXT) {\n        return 'latin1';\n    }\n    return 'utf-8';\n}\n\nfunction constructTag(valueChars, type, langChars, keywordChars) {\n    const value = getValue(valueChars);\n    return {\n        name: getName(type, langChars, keywordChars),\n        value,\n        description: type === TYPE_ITXT ? getDescription(valueChars) : value\n    };\n}\n\nfunction getName(type, langChars, keywordChars) {\n    const name = getStringValueFromArray(keywordChars);\n    if (type === TYPE_TEXT || langChars.length === 0) {\n        return name;\n    }\n    const lang = getStringValueFromArray(langChars);\n    return `${name} (${lang})`;\n}\n\nfunction getValue(valueChars) {\n    if (valueChars instanceof DataView) {\n        return getStringFromDataView(valueChars, 0, valueChars.byteLength);\n    }\n    return valueChars;\n}\n\nfunction getDescription(valueChars) {\n    return TagDecoder.decode('UTF-8', valueChars);\n}\n\nfunction isExifGroupTag(name, value) {\n    return name.toLowerCase() === 'raw profile type exif' && value.substring(1, 5) === 'exif';\n}\n\nfunction isIptcGroupTag(name, value) {\n    return name.toLowerCase() === 'raw profile type iptc' && value.substring(1, 5) === 'iptc';\n}\n\nfunction decodeRawData(value) {\n    const parts = value.match(/\\n(exif|iptc)\\n\\s*\\d+\\n([\\s\\S]*)$/);\n    return hexToDataView(parts[2].replace(/\\n/g, ''));\n}\n\nfunction hexToDataView(hex) {\n    const dataView = new DataView(new ArrayBuffer(hex.length / 2));\n    for (let i = 0; i < hex.length; i += 2) {\n        dataView.setUint8(i / 2, parseInt(hex.substring(i, i + 2), 16));\n    }\n    return dataView;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Reverse-engineered docs:\n// https://exiftool.org/makernote_types.html\n// https://exiv2.org/makernote.html\n// https://exiftool.org/TagNames/Pentax.html\n\nimport ByteOrder from './byte-order.js';\nimport {objectAssign} from './utils.js';\nimport {readIfd} from './tags-helpers.js';\nimport {IFD_TYPE_PENTAX} from './tag-names.js';\n\nconst BYTE_ORDER_OFFSET = 8; // Pentax5: https://exiftool.org/makernote_types.html\nconst PENTAX_IFD_OFFSET = BYTE_ORDER_OFFSET + 2; // https://exiftool.org/makernote_types.html\n\nconst MODEL_ID = {\n    K3_III: 0x13254,\n};\nconst LIK3III = {\n    CAMERA_ORIENTATION: 1,\n    ROLL_ANGLE: 3,\n    PITCH_ANGLE: 5\n};\n\nexport default {\n    read,\n    PENTAX_IFD_OFFSET,\n    MODEL_ID,\n    LIK3III\n};\n\nfunction read(dataView, tiffHeaderOffset, offset, includeUnknown) {\n    // Pentax does not use the standard TIFF header offset as base for tag\n    // offsets but instead uses the start of the IFD, i.e. directly after the\n    // two byte order bytes. originOffset below is this offset.\n    const byteOrder = ByteOrder.getByteOrder(dataView, tiffHeaderOffset + offset + BYTE_ORDER_OFFSET);\n    const originOffset = tiffHeaderOffset + offset;\n    let tags = readIfd(dataView, IFD_TYPE_PENTAX, originOffset, originOffset + PENTAX_IFD_OFFSET, byteOrder, includeUnknown, true);\n\n    if (hasLevelInfoK3III(tags)) {\n        tags = objectAssign({}, tags, parseLevelInfoK3III(dataView, originOffset + tags['LevelInfo'].__offset, byteOrder));\n        delete tags['LevelInfo'];\n    }\n\n    return tags;\n}\n\nfunction hasLevelInfoK3III(tags) {\n    return tags['PentaxModelID'] && tags['PentaxModelID'].value === MODEL_ID.K3_III && tags['LevelInfo'];\n}\n\nfunction parseLevelInfoK3III(dataView, levelInfoOffset, byteOrder) {\n    const tags = {};\n\n    if (levelInfoOffset + 7 > dataView.byteLength) {\n        return tags;\n    }\n\n    const cameraOrientation = dataView.getInt8(levelInfoOffset + LIK3III.CAMERA_ORIENTATION);\n    tags['CameraOrientation'] = {\n        value: cameraOrientation,\n        description: getOrientationDescription(cameraOrientation)\n    };\n\n    const rollAngle = dataView.getInt16(levelInfoOffset + LIK3III.ROLL_ANGLE, byteOrder === ByteOrder.LITTLE_ENDIAN);\n    tags['RollAngle'] = {\n        value: rollAngle,\n        description: getRollAngleDescription(rollAngle)\n    };\n\n    const pitchAngle = dataView.getInt16(levelInfoOffset + LIK3III.PITCH_ANGLE, byteOrder === ByteOrder.LITTLE_ENDIAN);\n    tags['PitchAngle'] = {\n        value: pitchAngle,\n        description: getPitchAngleDescription(pitchAngle)\n    };\n\n    return tags;\n}\n\nfunction getOrientationDescription(orientation) {\n    if (orientation === 0) {\n        return 'Horizontal (normal)';\n    }\n    if (orientation === 1) {\n        return 'Rotate 270 CW';\n    }\n    if (orientation === 2) {\n        return 'Rotate 180';\n    }\n    if (orientation === 3) {\n        return 'Rotate 90 CW';\n    }\n    if (orientation === 4) {\n        return 'Upwards';\n    }\n    if (orientation === 5) {\n        return 'Downwards';\n    }\n    return 'Unknown';\n}\n\nfunction getRollAngleDescription(rollAngle) {\n    return '' + (rollAngle * -0.5);\n}\n\nfunction getPitchAngleDescription(pitchAngle) {\n    return '' + (pitchAngle * -0.5);\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport {objectAssign} from './utils.js';\nimport Constants from './constants.js';\nimport TagNames0thIfd from './tag-names-0th-ifd.js';\nimport TagNamesExifIfd from './tag-names-exif-ifd.js';\nimport TagNamesGpsIfd from './tag-names-gps-ifd.js';\nimport TagNamesInteroperabilityIfd from './tag-names-interoperability-ifd.js';\nimport TagNamesMpfIfd from './tag-names-mpf-ifd.js';\nimport TagNamesCanonIfd from './tag-names-canon-ifd.js';\nimport TagNamesPentaxIfd from './tag-names-pentax-ifd.js';\n\nconst tagNames0thExifIfds = objectAssign({}, TagNames0thIfd, TagNamesExifIfd);\n\nexport const IFD_TYPE_0TH = '0th';\nexport const IFD_TYPE_1ST = '1st';\nexport const IFD_TYPE_EXIF = 'exif';\nexport const IFD_TYPE_GPS = 'gps';\nexport const IFD_TYPE_INTEROPERABILITY = 'interoperability';\nexport const IFD_TYPE_MPF = 'mpf';\nexport const IFD_TYPE_CANON = 'canon';\nexport const IFD_TYPE_PENTAX = 'pentax';\n\nexport default {\n    [IFD_TYPE_0TH]: tagNames0thExifIfds,\n    [IFD_TYPE_1ST]: TagNames0thIfd,\n    [IFD_TYPE_EXIF]: tagNames0thExifIfds,\n    [IFD_TYPE_GPS]: TagNamesGpsIfd,\n    [IFD_TYPE_INTEROPERABILITY]: TagNamesInteroperabilityIfd,\n    [IFD_TYPE_MPF]: Constants.USE_MPF ? TagNamesMpfIfd : {},\n    [IFD_TYPE_CANON]: Constants.USE_MAKER_NOTES ? TagNamesCanonIfd : {},\n    [IFD_TYPE_PENTAX]: Constants.USE_MAKER_NOTES ? TagNamesPentaxIfd : {},\n};\n","import type { DetectedFileInfo, FileInfo } from \"./FileInfo\";\nimport type { FileSignature } from \"./FileSignature\";\nimport { FILE_TYPES_REQUIRED_ADDITIONAL_CHECK, FileTypes } from \"./FileTypes\";\nimport type { DetectFileOptions } from \"./types\";\nimport { getFileChunk } from \"./utils\";\n\n/**\n * Detect a file by searching for a valid file signature inside the file content\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n * @param options Optional parameters for additional actions\n *\n * @returns {DetectedFileInfo | undefined} DetectedFileInfo if detected a valid signature inside the file contentof, otherwise undefined\n */\nexport function detectFile(\n  file: Array<number> | ArrayBuffer | Uint8Array,\n  options?: DetectFileOptions\n): DetectedFileInfo | undefined {\n  if (options && Object.prototype.hasOwnProperty.call(options, \"chunkSize\") && (options?.chunkSize ?? 0) <= 0)\n    throw new RangeError(\"chunkSize must be bigger than zero\");\n\n  const fileChunk: Array<number> = getFileChunk(file, options?.chunkSize || 64); // Take chunk from the beginning of the file\n  if (fileChunk.length === 0) return undefined;\n\n  const detectedFiles: DetectedFileInfo[] = [];\n  const filesRequiredAdditionalCheck: string[] = [];\n\n  for (const type in FileTypes) {\n    if (Object.prototype.hasOwnProperty.call(FileTypes, type)) {\n      const signatures: ReadonlyArray<FileSignature.Type> = FileTypes.getSignaturesByName(type);\n      const matchedSignature = FileTypes.detectBySignatures(fileChunk, signatures);\n      if (matchedSignature) {\n        const fileType: FileInfo.Type = FileTypes.getInfoByName(type);\n        if (FILE_TYPES_REQUIRED_ADDITIONAL_CHECK.includes(fileType.extension)) {\n          filesRequiredAdditionalCheck.push(fileType.extension);\n        }\n        const fileInfo: DetectedFileInfo.Type = {\n          extension: fileType.extension,\n          mimeType: fileType.mimeType,\n          description: fileType.description,\n          signature: {\n            ...matchedSignature,\n            sequence: matchedSignature.sequence.map((num) => num.toString(16)),\n          },\n        };\n        detectedFiles.push(fileInfo);\n      }\n    }\n  }\n\n  if (detectedFiles.length === 0) return undefined;\n  if (detectedFiles.length === 1 && filesRequiredAdditionalCheck.length === 0) return detectedFiles[0];\n\n  // Some files share the same signature. Additional check required\n  const detectedType = FileTypes.detectTypeByAdditionalCheck(fileChunk, detectedFiles);\n  if (!detectedType) return undefined;\n\n  return detectedFiles.find((df) => df.extension === detectedType);\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n// Reverse-engineered docs:\n// https://exiftool.org/makernote_types.html\n// https://exiv2.org/makernote.html\n// https://exiv2.org/tags-canon.html\n// https://gist.github.com/redaktor/bae0ef2377ab70bc5276\n// https://www.ozhiker.com/electronics/pjmt/jpeg_info/canon_mn.html\n\nimport {objectAssign} from './utils.js';\nimport {readIfd} from './tags-helpers.js';\nimport {IFD_TYPE_CANON} from './tag-names.js';\n\nconst SHOT_INFO_AUTO_ROTATE = 27; // First position is size.\n\nexport default {\n    read,\n    SHOT_INFO_AUTO_ROTATE\n};\n\nfunction read(dataView, tiffHeaderOffset, offset, byteOrder, includeUnknown) {\n    let tags = readIfd(dataView, IFD_TYPE_CANON, tiffHeaderOffset, tiffHeaderOffset + offset, byteOrder, includeUnknown);\n\n    if (tags['ShotInfo']) {\n        tags = objectAssign({}, tags, parseShotInfo(tags['ShotInfo'].value));\n        delete tags['ShotInfo'];\n    }\n\n    return tags;\n}\n\nfunction parseShotInfo(shotInfoData) {\n    const tags = {};\n\n    if (shotInfoData[SHOT_INFO_AUTO_ROTATE] !== undefined) {\n        tags['AutoRotate'] = {\n            value: shotInfoData[SHOT_INFO_AUTO_ROTATE],\n            description: getAutoRotateDescription(shotInfoData[SHOT_INFO_AUTO_ROTATE])\n        };\n    }\n\n    return tags;\n}\n\nfunction getAutoRotateDescription(autoRotate) {\n    if (autoRotate === 0) {\n        return 'None';\n    }\n    if (autoRotate === 1) {\n        return 'Rotate 90 CW';\n    }\n    if (autoRotate === 2) {\n        return 'Rotate 180';\n    }\n    if (autoRotate === 3) {\n        return 'Rotate 270 CW';\n    }\n    return 'Unknown';\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Constants from './constants.js';\nimport Tiff from './image-header-tiff.js';\nimport Jpeg from './image-header-jpeg.js';\nimport Png from './image-header-png.js';\nimport Heic from './image-header-heic.js';\nimport Avif from './image-header-avif.js';\nimport Webp from './image-header-webp.js';\nimport Gif from './image-header-gif.js';\nimport Xml from './xml.js';\nimport {objectAssign} from './utils.js';\n\nexport default {\n    parseAppMarkers\n};\n\nfunction parseAppMarkers(dataView, async) {\n    if (Constants.USE_TIFF && Tiff.isTiffFile(dataView)) {\n        return addFileType(Tiff.findTiffOffsets(), 'tiff', 'TIFF');\n    }\n\n    if (Constants.USE_JPEG && Jpeg.isJpegFile(dataView)) {\n        return addFileType(Jpeg.findJpegOffsets(dataView), 'jpeg', 'JPEG');\n    }\n\n    if (Constants.USE_PNG && Png.isPngFile(dataView)) {\n        return addFileType(Png.findPngOffsets(dataView, async), 'png', 'PNG');\n    }\n\n    if (Constants.USE_HEIC && Heic.isHeicFile(dataView)) {\n        return addFileType(Heic.findHeicOffsets(dataView), 'heic', 'HEIC');\n    }\n\n    if (Constants.USE_AVIF && Avif.isAvifFile(dataView)) {\n        return addFileType(Avif.findAvifOffsets(dataView), 'avif', 'AVIF');\n    }\n\n    if (Constants.USE_WEBP && Webp.isWebpFile(dataView)) {\n        return addFileType(Webp.findOffsets(dataView), 'webp', 'WebP');\n    }\n\n    if (Constants.USE_GIF && Gif.isGifFile(dataView)) {\n        return addFileType(Gif.findOffsets(dataView), 'gif', 'GIF');\n    }\n\n    if (Constants.USE_XMP && Xml.isXMLFile(dataView)) {\n        return addFileType(Xml.findOffsets(dataView), 'xml', 'XML');\n    }\n\n    throw new Error('Invalid image format');\n}\n\nfunction addFileType(offsets, fileType, fileTypeDescription) {\n    return objectAssign({}, offsets, {fileType: {value: fileType, description: fileTypeDescription}});\n}\n","import { BS } from \"@beep/schema\";\nimport * as Data from \"effect/Data\";\nimport type { DetectedFileInfo } from \"./FileInfo\";\nimport { FileInfo } from \"./FileInfo\";\nimport { FileSignature } from \"./FileSignature\";\nimport type { FileValidatorOptions, ValidateFileTypeOptions, ZipValidatorOptions } from \"./types\";\nimport {\n  fetchFromObject,\n  findMatroskaDocTypeElements,\n  getFileChunk,\n  isAvifStringIncluded,\n  isFlvStringIncluded,\n  isftypStringIncluded,\n  isHeicSignatureIncluded,\n} from \"./utils\";\n\n/**\n * Video files information with their unique signatures\n */\nexport class VideoTypes extends Data.TaggedClass(\"VideoTypes\") {\n  static readonly AVI = FileInfo.make({\n    extension: \"avi\",\n    mimeType: \"video/x-msvideo\",\n    description: \"Audio Video Interleave video format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x52, 0x49, 0x46, 0x46, 0x41, 0x56, 0x49, 0x20, 0x4c, 0x49, 0x53, 0x54],\n        skippedBytes: [4, 5, 6, 7],\n      }),\n    ],\n  });\n\n  static readonly FLV = FileInfo.make({\n    extension: \"flv\",\n    mimeType: \"video/x-flv\",\n    description: \"Flash Video file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x46, 0x4c, 0x56, 0x01],\n      }),\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x4d, 0x34, 0x56, 0x20],\n        description: \"ISO Media, MPEG v4 system, or iTunes AVC-LC file\",\n        offset: 4,\n        compatibleExtensions: [\"mp4\", \"m4v\"],\n      }),\n    ],\n  });\n\n  static readonly M4V = FileInfo.make({\n    extension: \"m4v\",\n    mimeType: \"video/x-m4v\",\n    description: \"Apple's video container format, very similar to MP4\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x6d, 0x70, 0x34, 0x32],\n        description: \"MPEG-4 video | QuickTime file\",\n        offset: 4,\n        compatibleExtensions: [\"mp4\"],\n      }),\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x4d, 0x34, 0x56, 0x20],\n        description: \"ISO Media, MPEG v4 system, or iTunes AVC-LC file\",\n        offset: 4,\n        compatibleExtensions: [\"mp4\", \"flv\"],\n      }),\n    ],\n  });\n\n  static readonly MKV = FileInfo.make({\n    extension: \"mkv\",\n    mimeType: \"video/x-matroska\",\n    description:\n      \"MKV (Matroska Video) is a flexible, open-source media container format that supports multiple audio, video, and subtitle streams in a single file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x1a, 0x45, 0xdf, 0xa3],\n        description: \"EBML identifier\",\n        compatibleExtensions: [\"webm\", \"mka\", \"mks\", \"mk3d\"],\n      }),\n    ],\n  });\n\n  static readonly MOV = FileInfo.make({\n    extension: \"mov\",\n    mimeType: \"video/quicktime\",\n    description: \"QuickTime movie file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20],\n        offset: 4,\n      }),\n      FileSignature.make({\n        sequence: [0x6d, 0x6f, 0x6f, 0x76],\n        offset: 4,\n      }),\n    ],\n  });\n\n  static readonly MP4 = FileInfo.make({\n    extension: \"mp4\",\n    mimeType: \"video/mp4\",\n    description:\n      \"A multimedia container format widely used for storing audio, video, and other data, and is known for its high compression efficiency and compatibility with many devices\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x4d, 0x53, 0x4e, 0x56],\n        description: \"MPEG-4 video file\",\n        offset: 4,\n      }),\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6f, 0x6d],\n        description: \"ISO Base Media file (MPEG-4) v1\",\n        offset: 4,\n      }),\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x4d, 0x34, 0x56, 0x20],\n        description: \"ISO Media, MPEG v4 system, or iTunes AVC-LC file\",\n        offset: 4,\n        compatibleExtensions: [\"m4v\", \"flv\"],\n      }),\n    ],\n  });\n\n  static readonly OGG = FileInfo.make({\n    extension: \"ogg\",\n    mimeType: \"video/ogg\",\n    description: \"Ogg Vorbis Codec compressed Multimedia file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x4f, 0x67, 0x67, 0x53, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],\n        compatibleExtensions: [\"oga\", \"ogv\", \"ogx\"],\n      }),\n    ],\n  });\n\n  static readonly SWF = FileInfo.make({\n    extension: \"swf\",\n    mimeType: \"application/x-shockwave-flash\",\n    description:\n      \"SWF (Shockwave Flash) is a file format for multimedia, vector graphics, and ActionScript, used for creating and delivering animations, games, and other interactive web-based content\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x43, 0x57, 0x53],\n        description: \"Macromedia Shockwave Flash player file (zlib compressed, SWF 6 and later)\",\n      }),\n      FileSignature.make({\n        sequence: [0x46, 0x57, 0x53],\n        description: \"Macromedia Shockwave Flash player file (uncompressed)\",\n      }),\n      FileSignature.make({\n        sequence: [0x5a, 0x57, 0x53],\n        description: \"Macromedia Shockwave Flash player file (uncompressed)\",\n      }),\n    ],\n  });\n\n  static readonly WEBM = FileInfo.make({\n    extension: \"webm\",\n    mimeType: \"video/webm\",\n    description:\n      \"WebM is a royalty-free, open-source media file format optimized for web delivery, using efficient VP8 video and Vorbis audio codecs\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x1a, 0x45, 0xdf, 0xa3],\n        description: \"EBML identifier\",\n        compatibleExtensions: [\"mkv\"],\n      }),\n    ],\n  });\n}\n\n/**\n * Other files information with their unique signatures\n */\nexport class OtherTypes {\n  static readonly BLEND = FileInfo.make({\n    extension: \"blend\",\n    mimeType: \"application/x-blender\",\n    description: \"Blender File Format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x42, 0x4c, 0x45, 0x4e, 0x44, 0x45, 0x52],\n      }),\n    ],\n  });\n\n  static readonly DOC = FileInfo.make({\n    extension: \"doc\",\n    mimeType: \"application/msword\",\n    description: \"Old Microsoft Word documents\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1], // Word 97-2003 for OLECF\n        compatibleExtensions: [\"xls\", \"ppt\", \"msi\", \"msg\", \"dot\", \"pps\", \"xla\", \"wiz\"],\n        description:\n          \"An Object Linking and Embedding (OLE) Compound File (CF) (i.e., OLECF) file format, known as Compound Binary File format by Microsoft, used by Microsoft Office 97-2003 applications\",\n      }),\n      FileSignature.make({\n        sequence: [0xdb, 0xa5, 0x2d, 0x00],\n        description: \"Microsoft Word 2.0 file format\",\n      }),\n    ],\n  });\n\n  static readonly ELF = FileInfo.make({\n    extension: \"elf\",\n    mimeType: \"application/x-executable\",\n    description: \"Executable and Linking Format executable file (Linux/Unix)\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x7f, 0x45, 0x4c, 0x46],\n      }),\n    ],\n  });\n\n  static readonly EXE = FileInfo.make({\n    extension: \"exe\",\n    mimeType: \"application/x-msdownload\", // 'application/x-dosexec' is a subtype of 'application/x-msdownload', therefore it is not necessary to include it (https://web.archive.org/web/20160629113130/http://www.webarchive.org.uk/interject/types/application/x-dosexec)\n    description: \"Windows/DOS executable file and its descendants\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x4d, 0x5a],\n        compatibleExtensions: [\n          \"acm\",\n          \"ax\",\n          \"cpl\",\n          \"com\",\n          \"dll\",\n          \"drv\",\n          \"efi\",\n          \"fon\",\n          \"iec\",\n          \"ime\",\n          \"mui\",\n          \"ocx\",\n          \"olb\",\n          \"pif\",\n          \"qts\",\n          \"qtx\",\n          \"rs\",\n          \"sys\",\n          \"scr\",\n          \"tsp\",\n          \"vbx\",\n          \"vxd\",\n        ],\n      }),\n      FileSignature.make({\n        sequence: [0x5a, 0x4d],\n        description: \"DOS ZM executable (rare)\",\n      }),\n    ],\n  });\n\n  static readonly INDD = FileInfo.make({\n    extension: \"indd\",\n    mimeType: \"application/x-indesign\",\n    description: \"Adobe InDesign document\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x06, 0x06, 0xed, 0xf5, 0xd8, 0x1d, 0x46, 0xe5, 0xbd, 0x31, 0xef, 0xe7, 0xfe, 0x74, 0xb7, 0x1d],\n        compatibleExtensions: [\"indt\"],\n      }),\n    ],\n  });\n\n  static readonly MACHO = FileInfo.make({\n    extension: \"macho\",\n    mimeType: \"application/x-mach-binary\",\n    description: \"Apple OS X ABI Mach-O binary file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0xfe, 0xed, 0xfa, 0xce],\n        description: \"32-bit\",\n      }),\n      FileSignature.make({\n        sequence: [0xce, 0xfa, 0xed, 0xfe],\n        description: \"32-bit, where target system has reverse byte ordering from host running compiler\",\n      }),\n      FileSignature.make({\n        sequence: [0xfe, 0xed, 0xfa, 0xcf],\n        description: \"64-bit\",\n      }),\n      FileSignature.make({\n        sequence: [0xcf, 0xfa, 0xed, 0xfe],\n        description: \"64-bit, where target system has reverse byte ordering from host running compiler\",\n      }),\n      FileSignature.make({\n        sequence: [0xca, 0xfe, 0xba, 0xbe],\n        description: \"Mach-O Fat Binary\",\n      }),\n    ],\n  });\n\n  static readonly PDF = FileInfo.make({\n    extension: \"pdf\",\n    mimeType: \"application/pdf\",\n    description: \"Portable Document Format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x25, 0x50, 0x44, 0x46, 0x2d],\n      }),\n    ],\n  });\n\n  static readonly ORC = FileInfo.make({\n    extension: \"orc\",\n    mimeType: \"application/x-orc\",\n    description: \"Apache ORC (Optimized Row Columnar) file format for columnar storage\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x4f, 0x52, 0x43],\n      }),\n    ],\n  });\n\n  static readonly PARQUET = FileInfo.make({\n    extension: \"parquet\",\n    mimeType: \"application/vnd.apache.parquet\",\n    description: \"Apache Parquet file format for columnar storage\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x50, 0x41, 0x52, 0x31],\n      }),\n    ],\n  });\n\n  static readonly PS = FileInfo.make({\n    extension: \"ps\",\n    mimeType: \"application/postscript\",\n    description: \"PostScript document\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x25, 0x21, 0x50, 0x53],\n      }),\n    ],\n  });\n\n  static readonly RTF = FileInfo.make({\n    extension: \"rtf\",\n    mimeType: \"application/rtf\",\n    description: \"Rich Text Format word processing file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x7b, 0x5c, 0x72, 0x74, 0x66, 0x31],\n      }),\n    ],\n  });\n\n  static readonly SQLITE = FileInfo.make({\n    extension: \"sqlite\",\n    mimeType: \"application/x-sqlite3\",\n    description: \"SQLite database file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x53, 0x51, 0x4c, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x33, 0x00],\n      }),\n    ],\n  });\n\n  static readonly STL = FileInfo.make({\n    extension: \"stl\",\n    mimeType: \"application/sla\",\n    description: \"ASCII STL (STereoLithography) file for 3D printing\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x73, 0x6f, 0x6c, 0x69, 0x64],\n      }),\n    ],\n  });\n\n  static readonly TTF = FileInfo.make({\n    extension: \"ttf\",\n    mimeType: \"application/x-font-ttf\",\n    description: \"TrueType font file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x74, 0x72, 0x75, 0x65, 0x00],\n      }),\n      FileSignature.make({\n        sequence: [0x00, 0x01, 0x00, 0x00, 0x00],\n        compatibleExtensions: [\"tte, dfont\"],\n      }),\n    ],\n  });\n\n  static readonly PCAP = FileInfo.make({\n    extension: \"pcap\",\n    mimeType: \"application/vnd.tcpdump.pcap\",\n    description: \"Libpcap File Format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0xd4, 0xc3, 0xb2, 0xa1],\n      }),\n      FileSignature.make({\n        sequence: [0x4d, 0x3c, 0xb2, 0xa1],\n        description: \"Nanosecond resolution\",\n      }),\n    ],\n  });\n}\n\n/**\n * Image files information with their unique signatures\n */\nexport class ImageTypes extends Data.TaggedClass(\"FileInfo\") {\n  static readonly AVIF = FileInfo.make({\n    extension: \"avif\",\n    mimeType: \"image/avif\",\n    description: \"Alliance for Open Media (AOMedia) Video 1 (AV1) Image File\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x00, 0x00, 0x00],\n      }),\n    ],\n  });\n\n  static readonly BMP = FileInfo.make({\n    extension: \"bmp\",\n    mimeType: \"image/bmp\",\n    description: \"A bitmap format used mostly in Windows\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x42, 0x4d],\n        compatibleExtensions: [\"dib\"],\n      }),\n    ],\n  });\n\n  static readonly BPG = FileInfo.make({\n    extension: \"bpg\",\n    mimeType: \"image/bpg\",\n    description: \"Better Portable Graphics image format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x42, 0x50, 0x47, 0xfb],\n      }),\n    ],\n  });\n\n  static readonly CR2 = FileInfo.make({\n    extension: \"cr2\",\n    mimeType: \"image/x-canon-cr2\",\n    description: \"Canon digital camera RAW file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x49, 0x49, 0x2a, 0x00, 0x10, 0x00, 0x00, 0x00, 0x43, 0x52],\n      }),\n    ],\n  });\n\n  static readonly EXR = FileInfo.make({\n    extension: \"exr\",\n    mimeType: \"image/x-exr\",\n    description: \"OpenEXR bitmap image format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x76, 0x2f, 0x31, 0x01],\n      }),\n    ],\n  });\n\n  static readonly GIF = FileInfo.make({\n    extension: \"gif\",\n    mimeType: \"image/gif\",\n    description: \"Image file encoded in the Graphics Interchange Format (GIF)\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61],\n      }),\n      FileSignature.make({\n        sequence: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61],\n      }),\n    ],\n  });\n\n  static readonly HEIC = FileInfo.make({\n    extension: \"heic\",\n    mimeType: \"image/heic\",\n    description: \"A variant of the HEIF (High Efficiency Image Format) that store images on the latest Apple devices.\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63],\n        offset: 4,\n      }),\n      FileSignature.make({\n        sequence: [0x66, 0x74, 0x79, 0x70, 0x6d],\n        offset: 4,\n      }),\n    ],\n  });\n\n  static readonly ICO = FileInfo.make({\n    extension: \"ico\",\n    mimeType: \"image/x-icon\",\n    description: \"Computer icon encoded in ICO file format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x00, 0x00, 0x01, 0x00],\n        compatibleExtensions: [\"spl\"],\n      }),\n    ],\n  });\n\n  static readonly JPEG = FileInfo.make({\n    extension: \"jpeg\",\n    mimeType: \"image/jpeg\",\n    description: \"JPEG (Joint Photographic Experts Group) is a widely used lossy image compression format.\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xe1, 0x45, 0x78, 0x69, 0x66, 0x00],\n        skippedBytes: [4, 5],\n        description: \"Digital camera JPG using Exchangeable Image File Format (EXIF)\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xe8, 0x53, 0x50, 0x49, 0x46, 0x46, 0x00],\n        skippedBytes: [4, 5],\n        description: \"Still Picture Interchange File Format (SPIFF)\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x00],\n        description: \"JPEG raw or in the JFIF or Exif file format\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xee],\n        description: \"JPEG raw or in the JFIF or Exif file format\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xe1, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00],\n        skippedBytes: [4, 5],\n        description: \"JPEG raw or in the JFIF or Exif file format\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xe0, 0x4a, 0x46, 0x49, 0x46, 0x00],\n        skippedBytes: [4, 5],\n        description: \"JPEG/JFIF graphics file\",\n        compatibleExtensions: [\"jfif\", \"jpe\"],\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8, 0xff, 0xe0],\n        description: \"JPEG raw or in the JFIF or Exif file format\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xd8],\n        description: \"Generic JPEGimage file\",\n        compatibleExtensions: [\"jpe\"],\n      }),\n    ],\n  });\n\n  static readonly PBM = FileInfo.make({\n    extension: \"pbm\",\n    mimeType: \"image/x-portable-bitmap\",\n    description:\n      \"PBM (Portable Bitmap) is a simple monochrome bitmap image format that uses plain text ASCII characters to represent binary image data\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x50, 0x31, 0x0a],\n        description: \"Portable bitmap ASCII\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x34, 0x0a],\n        description: \"Portable bitmap binary\",\n      }),\n    ],\n  });\n\n  static readonly PGM = FileInfo.make({\n    extension: \"pgm\",\n    mimeType: \"image/x-portable-graymap\",\n    description:\n      \"PGM (Portable Graymap) is a simple grayscale image format that uses ASCII text characters to represent binary image data.\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x50, 0x32, 0x0a],\n        description: \"Portable Gray Map ASCII\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x35, 0x0a],\n        description: \"Portable Gray Map binary\",\n      }),\n    ],\n  });\n\n  static readonly PNG = FileInfo.make({\n    extension: \"png\",\n    mimeType: \"image/png\",\n    description:\n      \"PNG (Portable Network Graphics) is a lossless image compression format that supports a wide range of color depths and transparency and is widely used for high-quality graphics.\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],\n      }),\n    ],\n  });\n\n  static readonly PPM = FileInfo.make({\n    extension: \"ppm\",\n    mimeType: \"image/x-portable-pixmap\",\n    description: \"PPM (Portable Pixmap) is a simple color image format in the Portable Network Graphics (PNG) suite.\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x50, 0x33, 0x0a],\n        description: \"Portable Pixmap ASCII\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x36, 0x0a],\n        description: \"Portable Pixmap binary\",\n      }),\n    ],\n  });\n\n  static readonly PSD = FileInfo.make({\n    extension: \"psd\",\n    mimeType: \"image/vnd.adobe.photoshop\",\n    description: \"PSD (Photoshop Document) is an Adobe Photoshop image file format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x38, 0x42, 0x50, 0x53],\n      }),\n    ],\n  });\n\n  static readonly WEBP = FileInfo.make({\n    extension: \"webp\",\n    mimeType: \"image/webp\",\n    description: \"A modern image format that provides superior lossless and lossy compression for images on the web\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x52, 0x49, 0x46, 0x46, 0x57, 0x45, 0x42, 0x50],\n        skippedBytes: [4, 5, 6, 7],\n      }),\n    ],\n  });\n}\n\n/**\n * Compressed files information with their unique signatures\n */\nexport class CompressedTypes extends Data.TaggedClass(\"CompressedTypes\") {\n  static readonly _7Z = FileInfo.make({\n    extension: \"7z\",\n    mimeType: \"application/x-7z-compressed\",\n    description: \"7-Zip compressed file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x37, 0x7a, 0xbc, 0xaf, 0x27, 0x1c],\n      }),\n    ],\n  });\n\n  static readonly LZH = FileInfo.make({\n    extension: \"lzh\",\n    mimeType: \"application/x-lzh-compressed\",\n    description: \"Compressed file using Lempel-Ziv and Haruyasu (LZH) compression algorithm\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x2d, 0x68, 0x6c, 0x30, 0x2d],\n        description: \"Lempel Ziv Huffman archive file Method 0 (No compression)\",\n        compatibleExtensions: [\"lha\"],\n      }),\n      FileSignature.make({\n        sequence: [0x2d, 0x68, 0x6c, 0x35, 0x2d],\n        description: \"Lempel Ziv Huffman archive file Method 5 (8KiB sliding window)\",\n        compatibleExtensions: [\"lha\"],\n      }),\n    ],\n  });\n\n  static readonly RAR = FileInfo.make({\n    extension: \"rar\",\n    mimeType: \"application/x-rar-compressed\",\n    description: \"Roshal ARchive compressed archive file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00],\n        description: \"Compressed archive v5.00 onwards\",\n      }),\n      FileSignature.make({\n        sequence: [0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x01, 0x00],\n        description: \"Compressed archive v1.50 onwards\",\n      }),\n    ],\n  });\n\n  static readonly ZIP = FileInfo.make({\n    extension: \"zip\",\n    mimeType: \"application/zip\",\n    description: \"Compressed archive file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x57, 0x69, 0x6e, 0x5a, 0x69, 0x70],\n        offset: 29152,\n        description: \"WinZip compressed archive\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x01, 0x00, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00],\n        description: \"ZLock Pro encrypted ZIP\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x4b, 0x4c, 0x49, 0x54, 0x45],\n        offset: 30,\n        description: \"PKLITE compressed ZIP archive (see also PKZIP)\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x4b, 0x53, 0x70, 0x58],\n        offset: 526,\n        description: \"PKSFX self-extracting executable compressed file (see also PKZIP)\",\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x4b, 0x03, 0x04],\n        description: \"PKZIP archive file - zip file format and multiple formats based on it\",\n        compatibleExtensions: [\n          \"aar\",\n          \"apk\",\n          \"docx\",\n          \"epub\",\n          \"ipa\",\n          \"jar\",\n          \"kmz\",\n          \"maff\",\n          \"msix\",\n          \"odp\",\n          \"ods\",\n          \"odt\",\n          \"pk3\",\n          \"pk4\",\n          \"pptx\",\n          \"usdz\",\n          \"vsdx\",\n          \"xlsx\",\n          \"xpi\",\n        ],\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x4b, 0x05, 0x06],\n        description: \"PKZIP empty archive file - zip file format and multiple formats based on it\",\n        compatibleExtensions: [\n          \"aar\",\n          \"apk\",\n          \"docx\",\n          \"epub\",\n          \"ipa\",\n          \"jar\",\n          \"kmz\",\n          \"maff\",\n          \"msix\",\n          \"odp\",\n          \"ods\",\n          \"odt\",\n          \"pk3\",\n          \"pk4\",\n          \"pptx\",\n          \"usdz\",\n          \"vsdx\",\n          \"xlsx\",\n          \"xpi\",\n        ],\n      }),\n      FileSignature.make({\n        sequence: [0x50, 0x4b, 0x07, 0x08],\n        description: \"PKZIP multivolume archive file - zip file format and multiple formats based on it\",\n        compatibleExtensions: [\n          \"aar\",\n          \"apk\",\n          \"docx\",\n          \"epub\",\n          \"ipa\",\n          \"jar\",\n          \"kmz\",\n          \"maff\",\n          \"msix\",\n          \"odp\",\n          \"ods\",\n          \"odt\",\n          \"pk3\",\n          \"pk4\",\n          \"pptx\",\n          \"usdz\",\n          \"vsdx\",\n          \"xlsx\",\n          \"xpi\",\n        ],\n      }),\n    ],\n  });\n}\n\nexport class AudioTypes extends Data.TaggedClass(\"AudioTypes\") {\n  static readonly AAC = FileInfo.make({\n    extension: \"aac\",\n    mimeType: \"audio/aac\",\n    description: \"Advanced Audio Coding (AAC) is an audio coding standard for lossy digital audio compression\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0xff, 0xf1],\n        description: \"MPEG-4 Advanced Audio Coding (AAC) Low Complexity (LC) audio file\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xf9],\n        description: \"MPEG-2 Advanced Audio Coding (AAC) Low Complexity (LC) audio file\",\n      }),\n    ],\n  });\n  static readonly AMR = FileInfo.make({\n    extension: \"amr\",\n    mimeType: \"audio/amr\",\n    description:\n      \"Adaptive Multi-Rate ACELP (Algebraic Code Excited Linear Prediction) Codec, commonly audio format with GSM cell phones\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x23, 0x21, 0x41, 0x4d, 0x52],\n      }),\n    ],\n  });\n\n  static readonly FLAC = FileInfo.make({\n    extension: \"flac\",\n    mimeType: \"audio/x-flac\",\n    description: \"Free Lossless Audio Codec file\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x66, 0x4c, 0x61, 0x43, 0x00, 0x00, 0x00, 0x22],\n      }),\n    ],\n  });\n\n  static readonly M4A = FileInfo.make({\n    extension: \"m4a\",\n    mimeType: \"audio/x-m4a\",\n    description: \"Apple Lossless Audio Codec file\",\n    signatures: [\n      FileSignature.make(\n        {\n          sequence: [0x66, 0x74, 0x79, 0x70, 0x4d, 0x34, 0x41, 0x20],\n          offset: 4,\n          compatibleExtensions: [\"aac\"],\n        },\n        {\n          disableValidation: true,\n        }\n      ),\n    ],\n  });\n\n  static readonly MP3 = FileInfo.make({\n    extension: \"mp3\",\n    mimeType: \"audio/mpeg\",\n    description:\n      \"A digital audio file format that uses compression to reduce file size while maintaining high quality sound\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0xff, 0xfb],\n        description:\n          \"MPEG-1 Layer 3 file without an ID3 tag or with an ID3v1 tag (which is appended at the end of the file)\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xf3],\n        description:\n          \"MPEG-1 Layer 3 file without an ID3 tag or with an ID3v1 tag (which is appended at the end of the file)\",\n      }),\n      FileSignature.make({\n        sequence: [0xff, 0xf2],\n        description:\n          \"MPEG-1 Layer 3 file without an ID3 tag or with an ID3v1 tag (which is appended at the end of the file)\",\n      }),\n      FileSignature.make({\n        sequence: [0x49, 0x44, 0x33],\n        description: \"MP3 file with an ID3v2 container\",\n      }),\n    ],\n  });\n\n  static readonly WAV = FileInfo.make({\n    extension: \"wav\",\n    mimeType: \"audio/wav\",\n    description: \"Waveform Audio File Format\",\n    signatures: [\n      FileSignature.make({\n        sequence: [0x52, 0x49, 0x46, 0x46, 0x57, 0x41, 0x56, 0x45, 0x66, 0x6d, 0x74, 0x20],\n        skippedBytes: [4, 5, 6, 7],\n      }),\n    ],\n  });\n}\n\nexport const FILE_TYPES_REQUIRED_ADDITIONAL_CHECK = [\n  ...(BS.FileExtensionKit.pick(\"m4v\", \"flv\", \"mp4\", \"mkv\", \"webm\", \"avif\", \"heic\") as ReadonlyArray<string>),\n];\n\n/**\n * A class hold all supported file typs with their unique signatures\n */\nexport class FileTypes extends Data.TaggedClass(\"FileTypes\") {\n  // audio\n  static readonly AAC = AudioTypes.AAC;\n  static readonly AMR = AudioTypes.AMR;\n  static readonly FLAC = AudioTypes.FLAC;\n  static readonly M4A = AudioTypes.M4A;\n  static readonly MP3 = AudioTypes.MP3;\n  static readonly WAV = AudioTypes.WAV;\n\n  // image\n  static readonly AVIF = ImageTypes.AVIF;\n  static readonly BMP = ImageTypes.BMP;\n  static readonly BPG = ImageTypes.BPG;\n  static readonly CR2 = ImageTypes.CR2;\n  static readonly EXR = ImageTypes.EXR;\n  static readonly GIF = ImageTypes.GIF;\n  static readonly ICO = ImageTypes.ICO;\n  static readonly JPEG = ImageTypes.JPEG;\n  static readonly PBM = ImageTypes.PBM;\n  static readonly PGM = ImageTypes.PGM;\n  static readonly PNG = ImageTypes.PNG;\n  static readonly PPM = ImageTypes.PPM;\n  static readonly PSD = ImageTypes.PSD;\n  static readonly WEBP = ImageTypes.WEBP;\n  static readonly HEIC = ImageTypes.HEIC;\n\n  // video\n  static readonly AVI = VideoTypes.AVI;\n  static readonly FLV = VideoTypes.FLV;\n  static readonly M4V = VideoTypes.M4V;\n  static readonly MKV = VideoTypes.MKV;\n  static readonly MOV = VideoTypes.MOV;\n  static readonly MP4 = VideoTypes.MP4;\n  static readonly OGG = VideoTypes.OGG;\n  static readonly SWF = VideoTypes.SWF;\n  static readonly WEBM = VideoTypes.WEBM;\n\n  // compressed\n  static readonly _7Z = CompressedTypes._7Z;\n  static readonly LZH = CompressedTypes.LZH;\n  static readonly RAR = CompressedTypes.RAR;\n  static readonly ZIP = CompressedTypes.ZIP;\n\n  // other\n  static readonly BLEND = OtherTypes.BLEND;\n  static readonly DOC = OtherTypes.DOC;\n  static readonly ELF = OtherTypes.ELF;\n  static readonly EXE = OtherTypes.EXE;\n  static readonly INDD = OtherTypes.INDD;\n  static readonly MACHO = OtherTypes.MACHO;\n  static readonly ORC = OtherTypes.ORC;\n  static readonly PARQUET = OtherTypes.PARQUET;\n  static readonly PCAP = OtherTypes.PCAP;\n  static readonly PDF = OtherTypes.PDF;\n  static readonly PS = OtherTypes.PS;\n  static readonly RTF = OtherTypes.RTF;\n  static readonly SQLITE = OtherTypes.SQLITE;\n  static readonly STL = OtherTypes.STL;\n  static readonly TTF = OtherTypes.TTF;\n\n  /**\n   * Receive information on a file type by its property name from FileTypes class\n   *\n   * @param propertyName Property name from FileTypes class\n   *\n   * @returns {FileInfo} File type information\n   */\n  public static getInfoByName(propertyName: string) {\n    const file = fetchFromObject(FileTypes, propertyName.toUpperCase());\n    return file;\n  }\n\n  /**\n   * Receive an array of file type signatures by its property name from FileTypes class\n   *\n   * @param propertyName Property name from FileTypes class\n   *\n   * @returns {Array<FileSignature>} All unique signatures with their information\n   */\n  public static getSignaturesByName(propertyName: string): ReadonlyArray<FileSignature.Type> {\n    const { signatures } = fetchFromObject(FileTypes, propertyName.toUpperCase());\n    return signatures;\n  }\n\n  /**\n   * Determine if a valid signature exist in a file chunk\n   *\n   * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n   * @param acceptedSignatures Valid signatures to search for in fileChunk\n   *\n   * @returns {boolean} True if found a valid signature inside the chunk, otherwise false\n   */\n  public static detectSignature(\n    fileChunk: Array<number>,\n    acceptedSignatures: ReadonlyArray<FileSignature.Type>\n  ): FileSignature.Type | undefined {\n    for (const signature of acceptedSignatures) {\n      let found = true;\n      const offset = signature.offset || 0;\n      let skippedBytes = 0;\n      for (let i = 0; i < signature.sequence.length; i++) {\n        if (signature.skippedBytes?.includes(i)) {\n          skippedBytes++;\n          continue;\n        }\n        if (fileChunk[offset + i] !== signature.sequence[i - skippedBytes]) {\n          found = false;\n          break;\n        }\n      }\n      if (found) {\n        return signature;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Perfomrs an additional check for detected file types by their unique structure\n   *\n   * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n   * @param detectedFiles A list of detected files\n   * @returns {string | undefined} File type extension if found, otherwise undefined\n   */\n  public static detectTypeByAdditionalCheck(\n    fileChunk: Array<number>,\n    detectedFiles: Array<DetectedFileInfo.Type | FileInfo.Type>\n  ): string | undefined {\n    const detectedExtensions = detectedFiles.map((df) => df.extension);\n\n    if (detectedExtensions.some((de) => [\"m4v\", \"flv\", \"mp4\", \"heic\"].includes(de))) {\n      if (detectedExtensions.includes(\"heic\") && isHEIC(fileChunk)) return \"heic\";\n      const isFlv = isFLV(fileChunk);\n      if (isFlv) return \"flv\";\n      const isM4v = isM4V(fileChunk) && !isHEIC(fileChunk);\n      if (isM4v) return \"m4v\";\n      return \"mp4\";\n    }\n    if (detectedExtensions.some((de) => [\"mkv\", \"webm\"].includes(de))) {\n      const matroskaDocTypeElement = findMatroskaDocTypeElements(fileChunk);\n      if (matroskaDocTypeElement === \"mkv\" && isMKV(fileChunk)) return \"mkv\";\n      if (matroskaDocTypeElement === \"webm\" && isWEBM(fileChunk)) return \"webm\";\n      return undefined;\n    }\n    if (detectedExtensions.some((de) => [\"avif\"].includes(de))) {\n      const isAvif = isAvifStringIncluded(fileChunk);\n      if (isAvif) return \"avif\";\n    }\n    return undefined;\n  }\n\n  /**\n   * Determine if a file chunk contains a valid signature and return the file signature if exist\n   *\n   * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n   * @param acceptedSignatures Valid signatures to search for in fileChunk\n   *\n   * @returns {FileSignature | undefined } FileSignature if found a valid signature, otherwise undefined\n   */\n  public static detectBySignatures(\n    fileChunk: Array<number>,\n    acceptedSignatures: ReadonlyArray<FileSignature.Type>\n  ): FileSignature.Type | undefined {\n    for (const signature of acceptedSignatures) {\n      let skippedBytes = 0;\n      let found = true;\n      const offset = signature.offset || 0;\n      const signatureLength = signature?.skippedBytes\n        ? signature.sequence.length + signature.skippedBytes.length\n        : signature.sequence.length;\n      for (let i = 0; i < signatureLength; i++) {\n        if (signature.skippedBytes?.includes(i)) {\n          skippedBytes++;\n          continue;\n        }\n        if (fileChunk[offset + i] !== signature.sequence[i - skippedBytes]) {\n          found = false;\n          break;\n        }\n      }\n      if (found) {\n        return signature;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Determine if file content contains a valid signature of a required type\n   *\n   * @param fileChunk A chunk from the beginning of a file content, represents in array of numbers\n   * @param type The file type to match against\n   *\n   * @returns {boolean} True if found a signature of the type in file content, otherwise false\n   */\n  public static checkByFileType(fileChunk: Array<number>, type: string): boolean {\n    if (Object.prototype.hasOwnProperty.call(FileTypes, type.toUpperCase())) {\n      const acceptedSignatures: ReadonlyArray<FileSignature.Type> = FileTypes.getSignaturesByName(type.toUpperCase());\n\n      const detectedSignature = FileTypes.detectSignature(fileChunk, acceptedSignatures);\n      if (detectedSignature) return true;\n    }\n    return false;\n  }\n}\n\n/**\n * Determine if file content contains a valid 'aac' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n * @param options parameters for additional actions\n *\n * @returns {boolean} True if found a signature of type 'aac' in file content, otherwise false\n */\nexport function isAAC(file: Array<number> | ArrayBuffer | Uint8Array, options?: FileValidatorOptions): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  const iaAac = FileTypes.checkByFileType(fileChunk, \"aac\");\n\n  if (!iaAac) {\n    if (options?.excludeSimilarTypes) return false;\n    return isM4A(fileChunk); // since 'm4a' is very similar to 'aac'\n  }\n\n  return true;\n}\n\n/**\n * Determine if file content contains a valid 'amr' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'amr' in file content, otherwise false\n */\nexport function isAMR(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"amr\");\n}\n\n/**\n * Determine if file content contains a valid 'flac' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'flac' in file content, otherwise false\n */\nexport function isFLAC(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"flac\");\n}\n\n/**\n * Determine if file content contains a valid 'm4a' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'm4a' in file content, otherwise false\n */\nexport function isM4A(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"m4a\");\n}\n\n/**\n * Determine if file content contains a valid 'mp3' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'mp3' in file content, otherwise false\n */\nexport function isMP3(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"mp3\");\n}\n\n/**\n * Determine if file content contains a valid 'wav' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'wav' in file content, otherwise false\n */\nexport function isWAV(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"wav\");\n}\n\n/**\n * Determine if file content contains a valid '7z' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type '7z' in file content, otherwise false\n */\nexport function is7Z(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"_7z\");\n}\n\n/**\n * Determine if file content contains a valid 'lzh' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'lzh' in file content, otherwise false\n */\nexport function isLZH(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"lzh\");\n}\n\n/**\n * Determine if file content contains a valid 'rar' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'rar' in file content, otherwise false\n */\nexport function isRAR(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"rar\");\n}\n\n/**\n * Determine if file content contains a valid 'zip' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n * @param options parameters for additional actions\n *\n * @returns {boolean} True if found a signature of type 'zip' in file content, otherwise false\n */\nexport function isZIP(file: Array<number> | ArrayBuffer | Uint8Array, options?: ZipValidatorOptions): boolean {\n  const fileChunk: Array<number> = getFileChunk(file, options?.chunkSize || 64);\n  return FileTypes.checkByFileType(fileChunk, \"zip\");\n}\n\n/**\n * Determine if file content contains a valid 'avif' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'avif' in file content, otherwise false\n */\nexport function isAVIF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  const isAVIF = FileTypes.checkByFileType(fileChunk, \"avif\");\n  if (!isAVIF) return false;\n\n  // Search for the presence of the \"ftypavif\" at bytes 5-12\n  return isAvifStringIncluded(fileChunk);\n}\n\n/**\n * Determine if file content contains a valid 'bmp' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'bmp' in file content, otherwise false\n */\nexport function isBMP(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"bmp\");\n}\n\n/**\n * Determine if file content contains a valid 'bpg' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'bpg' in file content, otherwise false\n */\nexport function isBPG(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"bpg\");\n}\n\n/**\n * Determine if file content contains a valid 'cr2' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'cr2' in file content, otherwise false\n */\nexport function isCR2(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"cr2\");\n}\n\n/**\n * Determine if file content contains a valid 'exr' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'exr' in file content, otherwise false\n */\nexport function isEXR(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"exr\");\n}\n\n/**\n * Determine if file content contains a valid 'gif' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'gif' in file content, otherwise false\n */\nexport function isGIF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"gif\");\n}\n\n/**\n * Determine if file content contains a valid 'heic' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'heic' in file content, otherwise false\n */\nexport function isHEIC(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  const isHEIC = FileTypes.checkByFileType(fileChunk, \"avif\");\n  if (!isHEIC) return false;\n\n  // Determine if a file chunk contains a HEIC file box\n  return isHeicSignatureIncluded(fileChunk);\n}\n\n/**\n * Determine if file content contains a valid 'ico' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'ico' in file content, otherwise false\n */\nexport function isICO(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"ico\");\n}\n\n/**\n * Determine if file content contains a valid 'jpeg' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'jpeg' in file content, otherwise false\n */\nexport function isJPEG(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"jpeg\");\n}\n\n/**\n * Determine if file content contains a valid 'pbm' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'pbm' in file content, otherwise false\n */\nexport function isPBM(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"pbm\");\n}\n\n/**\n * Determine if file content contains a valid 'pgm' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'pgm' in file content, otherwise false\n */\nexport function isPGM(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"pgm\");\n}\n\n/**\n * Determine if file content contains a valid 'png' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'png' in file content, otherwise false\n */\nexport function isPNG(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"png\");\n}\n\n/**\n * Determine if file content contains a valid 'ppm' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'ppm' in file content, otherwise false\n */\nexport function isPPM(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"ppm\");\n}\n\n/**\n * Determine if file content contains a valid 'psd' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'psd' in file content, otherwise false\n */\nexport function isPSD(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"psd\");\n}\n\n/**\n * Determine if file content contains a valid 'webp' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'webp' in file content, otherwise false\n */\nexport function isWEBP(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"webp\");\n}\n\n/**\n * Determine if file content contains a valid 'blend' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'blend' in file content, otherwise false\n */\nexport function isBLEND(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"blend\");\n}\n\n/**\n * Determine if file content contains a valid 'elf' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'elf' in file content, otherwise false\n */\nexport function isELF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"elf\");\n}\n\n/**\n * Determine if file content contains a valid 'exe' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'exe' in file content, otherwise false\n */\nexport function isEXE(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"exe\");\n}\n\n/**\n * Determine if file content contains a valid 'mach-o' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'mach-o' in file content, otherwise false\n */\nexport function isMACHO(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"macho\");\n}\n\n/**\n * Determine if file content contains a valid 'indd' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'indd' in file content, otherwise false\n */\nexport function isINDD(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"indd\");\n}\n\n/**\n * Determine if file content contains a valid 'orc' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'orc' in file content, otherwise false\n */\nexport function isORC(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"orc\");\n}\n\n/**\n * Determine if file content contains a valid 'parquet' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'parquet' in file content, otherwise false\n */\nexport function isPARQUET(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"parquet\");\n}\n\n/**\n * Determine if file content contains a valid 'pdf' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'pdf' in file content, otherwise false\n */\nexport function isPDF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"pdf\");\n}\n\n/**\n * Determine if file content contains a valid 'ps' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'ps' in file content, otherwise false\n */\nexport function isPS(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"ps\");\n}\n\n/**\n * Determine if file content contains a valid 'rtf' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'rtf' in file content, otherwise false\n */\nexport function isRTF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"rtf\");\n}\n\n/**\n * Determine if file content contains a valid 'sqlite' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'sqlite' in file content, otherwise false\n */\nexport function isSQLITE(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"sqlite\");\n}\n\n/**\n * Determine if file content contains a valid 'stl' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'stl' in file content, otherwise false\n */\nexport function isSTL(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"stl\");\n}\n\n/**\n * Determine if file content contains a valid 'ttf' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'ttf' in file content, otherwise false\n */\nexport function isTTF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"ttf\");\n}\n\n/**\n * Determine if file content contains a valid 'doc' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'doc' in file content, otherwise false\n */\nexport function isDOC(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"doc\");\n}\n\n/**\n * Determine if file content contains a valid 'pcap' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'pcap' in file content, otherwise false\n */\nexport function isPCAP(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"pcap\");\n}\n\n/**\n * Determine if file content contains a valid 'avi' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'avi' in file content, otherwise false\n */\nexport function isAVI(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"avi\");\n}\n\n/**\n * Determine if file content contains a valid 'flv' file signature.\n * Since 'flv' and 'm4v' share the same signature - additional check required - check if file content contains a \"flv\" string in the first few bytes of the file\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'flv' & \"flv\" string in file content, otherwise false\n */\nexport function isFLV(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  const isFlvSignature = FileTypes.checkByFileType(fileChunk, \"flv\");\n  if (!isFlvSignature) return false;\n\n  // Check if file content contains a \"flv\" string\n  return isFlvStringIncluded(fileChunk);\n}\n\n/**\n * Determine if file content contains a valid 'm4v' file signature.\n * Since 'flv' and 'm4v' share the same signature - additional check required - check if file content contains a \"ftyp\" string in the first few bytes of the file\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'm4v' & \"ftyp\" string in file content, otherwise false\n */\nexport function isM4V(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  const isM4vSignature = FileTypes.checkByFileType(fileChunk, \"m4v\");\n  if (!isM4vSignature) return false;\n\n  // Check if file content contains a \"ftyp\" string\n  return isftypStringIncluded(fileChunk);\n}\n\n/**\n * Determine if file content contains a valid 'mkv' file signature.\n * Since 'mkv' and 'webm' share the same signature - additional check required - search for the presence of the \"Segment\" element in the mkv header\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'mkv' & \"ftyp\" string in file content, otherwise false\n */\nexport function isMKV(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file, 64); // Check the first 64 bytes of the file\n  const isMkvSignature = FileTypes.checkByFileType(fileChunk, \"mkv\");\n  if (!isMkvSignature) return false;\n\n  // Search for the presence of the \"Segment\" element in the mkv header\n  return findMatroskaDocTypeElements(fileChunk) === \"mkv\";\n}\n\n/**\n * Determine if file content contains a valid 'mov' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'mov' in file content, otherwise false\n */\nexport function isMOV(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"mov\");\n}\n\n/**\n * Determine if file content contains a valid 'mp4' file signature.\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n * @param options parameters for additional actions\n *\n * @returns {boolean} True if found a signature of type 'mp4' in file content, otherwise false\n */\nexport function isMP4(file: Array<number> | ArrayBuffer | Uint8Array, options?: FileValidatorOptions): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  const isMp4 = FileTypes.checkByFileType(fileChunk, \"mp4\");\n\n  if (!isMp4) {\n    if (options?.excludeSimilarTypes) return false;\n    return isM4V(fileChunk); // since 'm4v' is very similar to 'mp4'\n  }\n\n  return true;\n}\n\n/**\n * Determine if file content contains a valid 'ogg' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'ogg' in file content, otherwise false\n */\nexport function isOGG(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"ogg\");\n}\n\n/**\n * Determine if file content contains a valid 'swf' file signature\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'swf' in file content, otherwise false\n */\nexport function isSWF(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file);\n  return FileTypes.checkByFileType(fileChunk, \"swf\");\n}\n\n/**\n * Determine if file content contains a valid 'webm' file signature.\n * Since 'mkv' and 'webm' share the same signature - additional check required - search for the presence of the \"DocType\" element in the webm header\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n *\n * @returns {boolean} True if found a signature of type 'webm' & \"ftyp\" string in file content, otherwise false\n */\nexport function isWEBM(file: Array<number> | ArrayBuffer | Uint8Array): boolean {\n  const fileChunk: Array<number> = getFileChunk(file, 64); // Check the first 64 bytes of the file\n  const isWebmSignature = FileTypes.checkByFileType(fileChunk, \"webm\");\n  if (!isWebmSignature) return false;\n\n  // Search for the presence of the \"DocType\" element in the webm header\n  return findMatroskaDocTypeElements(fileChunk) === \"webm\";\n}\n\n/**\n * Validates the requested file signature against a list of accepted file types\n *\n * @param file File content represents in Array<number> / ArrayBuffer / Uint8Array\n * @param types A list of accepted file types\n * @param options parameters for additional actions\n *\n * @returns {boolean} True if found a type signature from the accepted file types, otherwise false\n */\nexport function validateFileType(\n  file: Array<number> | ArrayBuffer | Uint8Array,\n  types: Array<string>,\n  options?: ValidateFileTypeOptions\n): boolean {\n  let typeExtensions: Array<string> = [];\n  const uniqueTypes = [\n    ...new Set(\n      types.map((type) => {\n        const normalizedType = type.split(\".\").join(\"\").toUpperCase();\n        if (normalizedType === \"7Z\") return `_${normalizedType}`;\n        return normalizedType;\n      })\n    ),\n  ];\n  for (const type of uniqueTypes) {\n    if (!Object.prototype.hasOwnProperty.call(FileTypes, type))\n      throw new TypeError(\n        `Type \\`${type.toLowerCase()}\\` is not supported. Please make sure that \\`types\\` list conatins only supported files`\n      );\n    typeExtensions.push(type);\n  }\n\n  if (options && Object.prototype.hasOwnProperty.call(options, \"chunkSize\") && (options?.chunkSize ?? 0) <= 0)\n    throw new RangeError(\"chunkSize must be bigger than zero\");\n\n  if (!options || !options?.excludeSimilarTypes) {\n    const similarTypes: Array<string> = addSimilarTypes(typeExtensions);\n    if (similarTypes.length > 0) typeExtensions = typeExtensions.concat(similarTypes);\n  }\n\n  let acceptedSignatures: Array<FileSignature> = [];\n  const filesRequiredAdditionalCheck: Array<FileInfo> = [];\n  for (const type of typeExtensions) {\n    const extensionSignatures: ReadonlyArray<FileSignature.Type> = FileTypes.getSignaturesByName(type);\n    acceptedSignatures = acceptedSignatures.concat(extensionSignatures);\n    if (FILE_TYPES_REQUIRED_ADDITIONAL_CHECK.includes(type.toLowerCase())) {\n      filesRequiredAdditionalCheck.push(FileTypes.getInfoByName(type));\n    }\n  }\n\n  const fileChunk: Array<number> = getFileChunk(file, options?.chunkSize || 64);\n\n  const detectedSignature = FileTypes.detectSignature(fileChunk, acceptedSignatures);\n\n  if (!detectedSignature) return false;\n\n  if (filesRequiredAdditionalCheck.length > 0) {\n    const detectedFilesForAdditionalCheck: Array<FileInfo.Type> = filesRequiredAdditionalCheck.filter((frac) =>\n      frac.signatures.includes(detectedSignature)\n    );\n    if (detectedFilesForAdditionalCheck.length > 0) {\n      // Some files share the same signature. Additional check required\n      const detectedType = FileTypes.detectTypeByAdditionalCheck(fileChunk, detectedFilesForAdditionalCheck);\n      if (!detectedType) return false;\n\n      return typeExtensions.some((df) => df.toLowerCase() === detectedType);\n    }\n  }\n\n  return true;\n}\n\nfunction addSimilarTypes(requiredTypes: Array<string>): Array<string> {\n  if (requiredTypes.some((type) => type === \"MP4\")) return [\"M4V\"];\n  if (requiredTypes.some((type) => type === \"AAC\")) return [\"M4A\"];\n\n  return [];\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\nimport Types from './types.js';\nimport {\n    getPascalStringFromDataView,\n    padStart,\n    parseFloatRadix,\n    strRepeat\n} from './utils.js';\n\n// export const OsTypeKeys = {\n//     OBJC: 'Objc',\n//     DOUB: 'doub',\n//     UNTF: 'UntF',\n//     TEXT: 'TEXT',\n//     BOOL: 'bool',\n//     ENUM: 'enum',\n//     LONG: 'long'\n// };\n\nexport const PathRecordTypes = {\n    CLOSED_SUBPATH_LENGTH: 0,\n    CLOSED_SUBPATH_BEZIER_LINKED: 1,\n    CLOSED_SUBPATH_BEZIER_UNLINKED: 2,\n    OPEN_SUBPATH_LENGTH: 3,\n    OPEN_SUBPATH_BEZIER_LINKED: 4,\n    OPEN_SUBPATH_BEZIER_UNLINKED: 5,\n    FILL_RULE: 6,\n    CLIPBOARD: 7,\n    INITIAL_FILL_RULE: 8\n};\n\nconst PATH_RECORD_SIZE = 24;\n\nexport default {\n    // 0x0425: {\n    //     name: 'CaptionDigest',\n    //     description(dataView) {\n    //         let description = '';\n    //         for (let i = 0; i < dataView.byteLength; i++) {\n    //             const byte = dataView.getUint8(i);\n    //             description += padStart(byte.toString(16), 2, '0');\n    //         }\n    //         return description;\n    //     }\n    // },\n    // Commented out for now to lower bundle size until someone asks for it.\n    // 0x043a: {\n    //     name: 'PrintInformation',\n    //     description: parseDescriptor\n    // },\n    // 0x043b: {\n    //     name: 'PrintStyle',\n    //     description: parseDescriptor\n    // },\n    0x07d0: {\n        name: 'PathInformation',\n        description: pathResource\n    },\n    0x0bb7: {\n        name: 'ClippingPathName',\n        description(dataView) {\n            const [, string] = getPascalStringFromDataView(dataView, 0);\n            return string;\n        }\n    },\n};\n\n// function parseDescriptor(dataView) {\n//     const DESCRIPTOR_VERSION_SIZE = 4;\n//     // This is a unicode string terminated with null. Unsure about the format though since in my example image it starts with 0x0000.\n//     const UNCLEAR_CLASS_ID_NAME_PART_SIZE = 6;\n//     let offset = 0;\n//     offset += DESCRIPTOR_VERSION_SIZE + UNCLEAR_CLASS_ID_NAME_PART_SIZE;\n//     const [classId, classIdSize] = getBlockValue(dataView, offset);\n//     offset += classIdSize;\n//     const numItems = Types.getLongAt(dataView, offset);\n//     offset += 4;\n//     const descriptor = {[classId]: {}};\n//     for (let i = 0; i < numItems; i++) {\n//         const [itemKey, itemKeySize] = getBlockValue(dataView, offset);\n//         offset += itemKeySize;\n//         const osTypeKey = getStringFromDataView(dataView, offset, 4);\n//         offset += 4;\n//         try {\n//             const {itemValue, itemSize} = getItemValue(dataView, offset, osTypeKey);\n//             offset += itemSize;\n//             descriptor[classId][ITEM_KEY_TERMS[itemKey] || itemKey] = itemValue;\n//         } catch (error) {\n//             // We can't recover from unknown OS type key since we don't know\n//             // where the next one starts.\n//             break;\n//         }\n//     }\n//     return JSON.stringify(descriptor);\n// }\n\n// function getBlockValue(dataView, offset, unicode = false) {\n//     const length = (unicode ? 2 : 1) * Types.getLongAt(dataView, offset) || 4;\n//     offset += 4;\n//     const value = (unicode ? getUnicodeStringFromDataView : getStringFromDataView)(dataView, offset, length);\n//     offset += length;\n//     return [value, 4 + length];\n// }\n\n// function getItemValue(dataView, offset, osTypeKey) {\n//     // Not all OSType keys are implemented yet because they are missing in the example image.\n//     if (osTypeKey === OsTypeKeys.OBJC) {\n//         const [classIdName, classIdNameSize] = getBlockValue(dataView, offset, true);\n//         offset += classIdNameSize;\n//         const [classId, classIdSize] = getBlockValue(dataView, offset);\n//         offset += classIdSize;\n//         const _offset = Types.getLongAt(dataView, offset);\n//         return {\n//             itemValue: {[classIdName]: {[classId]: _offset}},\n//             itemSize: classIdNameSize + classIdSize + 4\n//         };\n//     }\n//     if (osTypeKey === OsTypeKeys.DOUB) {\n//         return {\n//             itemValue: parseDouble(dataView, offset),\n//             itemSize: 8\n//         };\n//     }\n//     if (osTypeKey === OsTypeKeys.UNTF) {\n//         const unit = getStringFromDataView(dataView, offset, 4);\n//         return {\n//             itemValue: {unit, value: parseDouble(dataView, offset + 4)},\n//             itemSize: unit.length + 8\n//         };\n//     }\n//     if (osTypeKey === OsTypeKeys.TEXT) {\n//         const length = 2 * Types.getLongAt(dataView, offset);\n//         offset += 4;\n//         const text = getUnicodeStringFromDataView(dataView, offset, length);\n//         return {\n//             itemValue: text,\n//             itemSize: 4 + length\n//         };\n//     }\n//     if (osTypeKey === OsTypeKeys.BOOL) {\n//         return {\n//             itemValue: Types.getByteAt(dataView, offset) === 1,\n//             itemSize: 1\n//         };\n//     }\n//     if (osTypeKey === OsTypeKeys.ENUM) {\n//         const [type, typeSize] = getBlockValue(dataView, offset);\n//         offset += typeSize;\n//         const [enumName, enumSize] = getBlockValue(dataView, offset);\n//         return {\n//             itemValue: {[type]: enumName},\n//             itemSize: typeSize + enumSize\n//         };\n//     }\n//     if (osTypeKey === OsTypeKeys.LONG) {\n//         return {\n//             itemValue: Types.getLongAt(dataView, offset),\n//             itemSize: 4\n//         };\n//     }\n//     throw new Error(`Unknown OS type key: ${osTypeKey}`);\n// }\n\n// function parseDouble(dataView, offset) {\n//     const BIAS = 1023;\n//     const sign = (Types.getByteAt(dataView, offset) & parseInt('10000000', 2)) === 0 ? 1 : -1;\n//     const exponent = ((Types.getShortAt(dataView, offset) & parseInt('0111111111110000', 2)) >> 4) - BIAS;\n//     const fractionHigh = padStart((Types.getLongAt(dataView, offset) & parseInt('00000000000011111111111111111111', 2)).toString(2), 20, '0');\n//     const fractionLow = padStart(Types.getLongAt(dataView, offset + 4).toString(2), 32, '0');\n//     const fraction = parseFloatRadix('1.' + fractionHigh + fractionLow, 2);\n//     return sign * fraction * Math.pow(2, exponent);\n// }\n\nfunction pathResource(dataView) {\n    const TYPE_SIZE = 2;\n    const types = {};\n    const paths = [];\n\n    for (let offset = 0; offset < dataView.byteLength; offset += TYPE_SIZE + PATH_RECORD_SIZE) {\n        const type = Types.getShortAt(dataView, offset);\n        if (PATH_RECORD_TYPES[type]) {\n            if (!types[type]) {\n                types[type] = PATH_RECORD_TYPES[type].description;\n            }\n            paths.push({\n                type,\n                path: PATH_RECORD_TYPES[type].path(dataView, offset + TYPE_SIZE)\n            });\n        }\n    }\n    return JSON.stringify({types, paths});\n}\n\nconst PATH_RECORD_TYPES = {\n    [PathRecordTypes.CLOSED_SUBPATH_LENGTH]: {\n        description: 'Closed subpath length',\n        path: (dataView, offset) => [Types.getShortAt(dataView, offset)]\n    },\n    [PathRecordTypes.CLOSED_SUBPATH_BEZIER_LINKED]: {\n        description: 'Closed subpath Bezier knot, linked',\n        path: parseBezierKnot\n    },\n    [PathRecordTypes.CLOSED_SUBPATH_BEZIER_UNLINKED]: {\n        description: 'Closed subpath Bezier knot, unlinked',\n        path: parseBezierKnot\n    },\n    [PathRecordTypes.OPEN_SUBPATH_LENGTH]: {\n        description: 'Open subpath length',\n        path: (dataView, offset) => [Types.getShortAt(dataView, offset)]\n    },\n    [PathRecordTypes.OPEN_SUBPATH_BEZIER_LINKED]: {\n        description: 'Open subpath Bezier knot, linked',\n        path: parseBezierKnot\n    },\n    [PathRecordTypes.OPEN_SUBPATH_BEZIER_UNLINKED]: {\n        description: 'Open subpath Bezier knot, unlinked',\n        path: parseBezierKnot\n    },\n    [PathRecordTypes.FILL_RULE]: {\n        description: 'Path fill rule',\n        path: () => []\n    },\n    [PathRecordTypes.INITIAL_FILL_RULE]: {\n        description: 'Initial fill rule',\n        path: (dataView, offset) => [Types.getShortAt(dataView, offset)]\n    },\n    [PathRecordTypes.CLIPBOARD]: {\n        description: 'Clipboard',\n        path: parseClipboard\n    }\n};\n\nfunction parseBezierKnot(dataView, offset) {\n    const PATH_POINT_SIZE = 8;\n    const path = [];\n    for (let i = 0; i < PATH_RECORD_SIZE; i += PATH_POINT_SIZE) {\n        path.push(parsePathPoint(dataView, offset + i));\n    }\n    return path;\n}\n\nfunction parsePathPoint(dataView, offset) {\n    const vertical = getFixedPointNumber(dataView, offset, 8);\n    const horizontal = getFixedPointNumber(dataView, offset + 4, 8);\n    return [horizontal, vertical];\n}\n\nfunction parseClipboard(dataView, offset) {\n    return [\n        [\n            getFixedPointNumber(dataView, offset, 8), // Top\n            getFixedPointNumber(dataView, offset + 4, 8), // Left\n            getFixedPointNumber(dataView, offset + 8, 8), // Botton\n            getFixedPointNumber(dataView, offset + 12, 8), // Right\n        ],\n        getFixedPointNumber(dataView, offset + 16, 8) // Resolution\n    ];\n}\n\nfunction getFixedPointNumber(dataView, offset, binaryPoint) {\n    const number = Types.getLongAt(dataView, offset);\n\n    const sign = (number >>> 31) === 0 ? 1 : -1;\n    const integer = (number & 0x7f000000) >>> (32 - binaryPoint);\n    const fraction = number & parseInt(strRepeat('1', 32 - binaryPoint), 2);\n\n    return sign * parseFloatRadix(integer.toString(2) + '.' + padStart(fraction.toString(2), 32 - binaryPoint, '0'), 2);\n}\n\n// Item key terminology: https://psd-tools.readthedocs.io/en/latest/reference/psd_tools.terminology.html\n// Are these correct? There are collisions that are commented out. A lot of code for little gain?\n// const ITEM_KEY_TERMS = {\n//     'A   ': 'A',\n//     'Adjs': 'Adjustment',\n//     'Algd': 'Aligned',\n//     'Algn': 'Alignment',\n//     'AllE': 'AllExcept',\n//     'All ': 'AllPS',\n//     'AlTl': 'AllToolOptions',\n//     'AChn': 'AlphaChannelOptions',\n//     'AlpC': 'AlphaChannels',\n//     'AmbB': 'AmbientBrightness',\n//     'AmbC': 'AmbientColor',\n//     'Amnt': 'Amount',\n//     'AmMx': 'AmplitudeMax',\n//     'AmMn': 'AmplitudeMin',\n//     'Anch': 'Anchor',\n//     'Angl': 'Angle',\n//     'Ang1': 'Angle1',\n//     'Ang2': 'Angle2',\n//     'Ang3': 'Angle3',\n//     'Ang4': 'Angle4',\n//     'AntA': 'AntiAlias',\n//     'Appe': 'Append',\n//     'Aply': 'Apply',\n//     'Ar  ': 'Area',\n//     'Arrw': 'Arrowhead',\n//     'As  ': 'As',\n//     'Asst': 'AssetBin',\n//     'AssC': 'AssumedCMYK',\n//     'AssG': 'AssumedGray',\n//     'AssR': 'AssumedRGB',\n//     'At  ': 'At',\n//     'Auto': 'Auto',\n//     'AuCo': 'AutoContrast',\n//     'Atrs': 'AutoErase',\n//     'AtKr': 'AutoKern',\n//     'AtUp': 'AutoUpdate',\n//     'Axis': 'Axis',\n//     'B   ': 'B',\n//     'Bckg': 'Background',\n//     'BckC': 'BackgroundColor',\n//     'BckL': 'BackgroundLevel',\n//     'Bwd ': 'Backward',\n//     'Blnc': 'Balance',\n//     'Bsln': 'BaselineShift',\n//     'BpWh': 'BeepWhenDone',\n//     'BgnR': 'BeginRamp',\n//     'BgnS': 'BeginSustain',\n//     'bvlD': 'BevelDirection',\n//     'ebbl': 'BevelEmboss',\n//     'bvlS': 'BevelStyle',\n//     'bvlT': 'BevelTechnique',\n//     'BgNH': 'BigNudgeH',\n//     'BgNV': 'BigNudgeV',\n//     'BtDp': 'BitDepth',\n//     'Blck': 'Black',\n//     'BlcC': 'BlackClip',\n//     'Blcn': 'BlackGeneration',\n//     'BlcG': 'BlackGenerationCurve',\n//     'BlcI': 'BlackIntensity',\n//     'BlcL': 'BlackLevel',\n//     // 'BlcL': 'BlackLimit',\n//     'Bld ': 'Bleed',\n//     'Blnd': 'BlendRange',\n//     'Bl  ': 'Blue',\n//     'BlBl': 'BlueBlackPoint',\n//     'blueFloat': 'BlueFloat',\n//     'BlGm': 'BlueGamma',\n//     'BlWh': 'BlueWhitePoint',\n//     'BlX ': 'BlueX',\n//     'BlY ': 'BlueY',\n//     'blur': 'Blur',\n//     'BlrM': 'BlurMethod',\n//     'BlrQ': 'BlurQuality',\n//     'Bk  ': 'Book',\n//     'BrdT': 'BorderThickness',\n//     'Btom': 'Bottom',\n//     'Brgh': 'Brightness',\n//     'BrsD': 'BrushDetail',\n//     'BrsS': 'BrushSize',\n//     'BrsT': 'BrushType',\n//     'Brsh': 'Brushes',\n//     'BmpA': 'BumpAmplitude',\n//     'BmpC': 'BumpChannel',\n//     'By  ': 'By',\n//     'Byln': 'Byline',\n//     'BylT': 'BylineTitle',\n//     'BytO': 'ByteOrder',\n//     'CMYS': 'CMYKSetup',\n//     'CchP': 'CachePrefs',\n//     'Clcl': 'Calculation',\n//     'Clbr': 'CalibrationBars',\n//     'Cptn': 'Caption',\n//     'CptW': 'CaptionWriter',\n//     'Ctgr': 'Category',\n//     'ClSz': 'CellSize',\n//     'Cntr': 'Center',\n//     'CntC': 'CenterCropMarks',\n//     'ChlA': 'ChalkArea',\n//     'Chnl': 'Channel',\n//     'ChMx': 'ChannelMatrix',\n//     'ChnN': 'ChannelName',\n//     'Chns': 'Channels',\n//     'ChnI': 'ChannelsInterleaved',\n//     'ChAm': 'CharcoalAmount',\n//     'ChrA': 'CharcoalArea',\n//     'Ckmt': 'ChokeMatte',\n//     'ChFX': 'ChromeFX',\n//     'City': 'City',\n//     'ClrA': 'ClearAmount',\n//     'ClPt': 'ClippingPath',\n//     'ClpP': 'ClippingPathEPS',\n//     'ClpF': 'ClippingPathFlatness',\n//     'ClpI': 'ClippingPathIndex',\n//     'Clpg': 'ClippingPathInfo',\n//     'ClnS': 'CloneSource',\n//     'Clsp': 'ClosedSubpath',\n//     'Clr ': 'Color',\n//     'Clrh': 'ColorChannels',\n//     'ClrC': 'ColorCorrection',\n//     'ClrI': 'ColorIndicates',\n//     'ClMg': 'ColorManagement',\n//     'Clrr': 'ColorPickerPrefs',\n//     'ClrS': 'ColorSpace',\n//     'ClrT': 'ColorTable',\n//     'Clrz': 'Colorize',\n//     'Clrs': 'Colors',\n//     'ClrL': 'ColorsList',\n//     'ClmW': 'ColumnWidth',\n//     'CmdK': 'CommandKey',\n//     'Cmpn': 'Compensation',\n//     'Cmpr': 'Compression',\n//     'Cncv': 'Concavity',\n//     'Cndt': 'Condition',\n//     'Cnst': 'Constant',\n//     // 'Cnst': 'Constrain',\n//     'CnsP': 'ConstrainProportions',\n//     'Cfov': 'ConstructionFOV',\n//     'Cntg': 'Contiguous',\n//     'Cntn': 'Continue',\n//     'Cnty': 'Continuity',\n//     'ShpC': 'ContourType',\n//     // 'Cntr': 'Contrast',\n//     'Cnvr': 'Convert',\n//     'Cpy ': 'Copy',\n//     'Cpyr': 'Copyright',\n//     'CprN': 'CopyrightNotice',\n//     'CrnC': 'CornerCropMarks',\n//     'Cnt ': 'Count',\n//     'CntN': 'CountryName',\n//     'CrcB': 'CrackBrightness',\n//     'CrcD': 'CrackDepth',\n//     'CrcS': 'CrackSpacing',\n//     'blfl': 'CreateLayersFromLayerFX',\n//     'Crdt': 'Credit',\n//     'Crss': 'Crossover',\n//     'Crnt': 'Current',\n//     'CrnH': 'CurrentHistoryState',\n//     'CrnL': 'CurrentLight',\n//     'CrnT': 'CurrentToolOptions',\n//     'Crv ': 'Curve',\n//     'CrvF': 'CurveFile',\n//     'Cstm': 'Custom',\n//     'CstF': 'CustomForced',\n//     'CstM': 'CustomMatte',\n//     'CstP': 'CustomPalette',\n//     'Cyn ': 'Cyan',\n//     'DCS ': 'DCS',\n//     'DPXf': 'DPXFormat',\n//     'DrkI': 'DarkIntensity',\n//     'Drkn': 'Darkness',\n//     'DtCr': 'DateCreated',\n//     'Dt ': 'Datum',\n//     'Dfnt': 'Definition',\n//     'Dnst': 'Density',\n//     'Dpth': 'Depth',\n//     'Dstl': 'DestBlackMax',\n//     'DstB': 'DestBlackMin',\n//     'Dstt': 'DestWhiteMax',\n//     'DstW': 'DestWhiteMin',\n//     'DstM': 'DestinationMode',\n//     'Dtl ': 'Detail',\n//     'Dmtr': 'Diameter',\n//     'DffD': 'DiffusionDither',\n//     'Drct': 'Direction',\n//     'DrcB': 'DirectionBalance',\n//     'DspF': 'DisplaceFile',\n//     'DspM': 'DisplacementMap',\n//     'DspP': 'DisplayPrefs',\n//     'Dstn': 'Distance',\n//     // 'Dstr': 'Distortion',\n//     // 'Dstr': 'Distribution',\n//     'Dthr': 'Dither',\n//     'DthA': 'DitherAmount',\n//     'Dthp': 'DitherPreserve',\n//     'Dthq': 'DitherQuality',\n//     'DocI': 'DocumentID',\n//     'DtGn': 'DotGain',\n//     'DtGC': 'DotGainCurves',\n//     'DrSh': 'DropShadow',\n//     'Dplc': 'Duplicate',\n//     'DnmC': 'DynamicColorSliders',\n//     'Edg ': 'Edge',\n//     'EdgB': 'EdgeBrightness',\n//     'EdgF': 'EdgeFidelity',\n//     'EdgI': 'EdgeIntensity',\n//     'EdgS': 'EdgeSimplicity',\n//     'EdgT': 'EdgeThickness',\n//     'EdgW': 'EdgeWidth',\n//     'Effc': 'Effect',\n//     'EmbC': 'EmbedCMYK',\n//     'EmbG': 'EmbedGray',\n//     'EmbL': 'EmbedLab',\n//     'EmbP': 'EmbedProfiles',\n//     'EmbR': 'EmbedRGB',\n//     'EmlD': 'EmulsionDown',\n//     'EGst': 'EnableGestures',\n//     'enab': 'Enabled',\n//     'Encd': 'Encoding',\n//     'End ': 'End',\n//     'EndA': 'EndArrowhead',\n//     'EndR': 'EndRamp',\n//     'EndS': 'EndSustain',\n//     'Engn': 'Engine',\n//     'ErsT': 'EraseToHistory',\n//     'ErsK': 'EraserKind',\n//     'ExcP': 'ExactPoints',\n//     'Expr': 'Export',\n//     'ExpC': 'ExportClipboard',\n//     'Exps': 'Exposure',\n//     'Extd': 'Extend',\n//     'EQlt': 'ExtendedQuality',\n//     'Extn': 'Extension',\n//     'ExtQ': 'ExtensionsQuery',\n//     'ExtD': 'ExtrudeDepth',\n//     'ExtM': 'ExtrudeMaskIncomplete',\n//     'ExtR': 'ExtrudeRandom',\n//     'ExtS': 'ExtrudeSize',\n//     'ExtF': 'ExtrudeSolidFace',\n//     'ExtT': 'ExtrudeType',\n//     'EyDr': 'EyeDropperSample',\n//     'FxCm': 'FPXCompress',\n//     'FxQl': 'FPXQuality',\n//     'FxSz': 'FPXSize',\n//     'FxVw': 'FPXView',\n//     'FdT ': 'FadeTo',\n//     'FdtS': 'FadeoutSteps',\n//     'FlOf': 'Falloff',\n//     'Fthr': 'Feather',\n//     'FbrL': 'FiberLength',\n//     'File': 'File',\n//     'FlCr': 'FileCreator',\n//     'FlIn': 'FileInfo',\n//     'FilR': 'FileReference',\n//     'FlSP': 'FileSavePrefs',\n//     'FlTy': 'FileType',\n//     'flst': 'FilesList',\n//     'Fl  ': 'Fill',\n//     'FlCl': 'FillColor',\n//     'FlNt': 'FillNeutral',\n//     'FlPd': 'FilterLayerPersistentData',\n//     'FlRs': 'FilterLayerRandomSeed',\n//     'Fngr': 'Fingerpainting',\n//     'FlrC': 'FlareCenter',\n//     'Fltn': 'Flatness',\n//     'Fltt': 'Flatten',\n//     'FlpV': 'FlipVertical',\n//     'Fcs ': 'Focus',\n//     'Fldr': 'Folders',\n//     'FntD': 'FontDesignAxes',\n//     'FntV': 'FontDesignAxesVectors',\n//     'FntN': 'FontName',\n//     'Scrp': 'FontScript',\n//     'FntS': 'FontStyleName',\n//     'FntT': 'FontTechnology',\n//     'FrcC': 'ForcedColors',\n//     'FrgC': 'ForegroundColor',\n//     'FrgL': 'ForegroundLevel',\n//     'Fmt ': 'Format',\n//     'Fwd ': 'Forward',\n//     'FrFX': 'FrameFX',\n//     'FrmW': 'FrameWidth',\n//     'FTcs': 'FreeTransformCenterState',\n//     'Frqn': 'Frequency',\n//     'From': 'From',\n//     'FrmB': 'FromBuiltin',\n//     'FrmM': 'FromMode',\n//     'FncK': 'FunctionKey',\n//     'Fzns': 'Fuzziness',\n//     'GCR ': 'GCR',\n//     'GFPT': 'GIFColorFileType',\n//     'GFCL': 'GIFColorLimit',\n//     'GFEC': 'GIFExportCaption',\n//     'GFMI': 'GIFMaskChannelIndex',\n//     'GFMV': 'GIFMaskChannelInverted',\n//     'GFPF': 'GIFPaletteFile',\n//     'GFPL': 'GIFPaletteType',\n//     'GFCS': 'GIFRequiredColorSpaceType',\n//     'GFIT': 'GIFRowOrderType',\n//     'GFTC': 'GIFTransparentColor',\n//     'GFTB': 'GIFTransparentIndexBlue',\n//     'GFTG': 'GIFTransparentIndexGreen',\n//     'GFTR': 'GIFTransparentIndexRed',\n//     'GFBM': 'GIFUseBestMatch',\n//     'Gmm ': 'Gamma',\n//     'GmtW': 'GamutWarning',\n//     'GnrP': 'GeneralPrefs',\n//     'gblA': 'GlobalAngle',\n//     'gagl': 'GlobalLightingAngle',\n//     'Glos': 'Gloss',\n//     'GlwA': 'GlowAmount',\n//     'GlwT': 'GlowTechnique',\n//     'Grad': 'Gradient',\n//     'Grdf': 'GradientFill',\n//     // 'Grn ': 'Grain',\n//     'Grnt': 'GrainType',\n//     'Grns': 'Graininess',\n//     'Gry ': 'Gray',\n//     'GrBh': 'GrayBehavior',\n//     'GrSt': 'GraySetup',\n//     'Grn ': 'Green',\n//     'GrnB': 'GreenBlackPoint',\n//     'greenFloat': 'GreenFloat',\n//     'GrnG': 'GreenGamma',\n//     'GrnW': 'GreenWhitePoint',\n//     'GrnX': 'GreenX',\n//     'GrnY': 'GreenY',\n//     'GrdC': 'GridColor',\n//     'Grds': 'GridCustomColor',\n//     'GrdM': 'GridMajor',\n//     'Grdn': 'GridMinor',\n//     'GrdS': 'GridStyle',\n//     'Grdt': 'GridUnits',\n//     'Grup': 'Group',\n//     'GrtW': 'GroutWidth',\n//     'GrwS': 'GrowSelection',\n//     'Gdes': 'Guides',\n//     'GdsC': 'GuidesColor',\n//     'Gdss': 'GuidesCustomColor',\n//     'GdPr': 'GuidesPrefs',\n//     'GdsS': 'GuidesStyle',\n//     'GttW': 'GutterWidth',\n//     'HlfF': 'HalftoneFile',\n//     'HlfS': 'HalftoneScreen',\n//     'HlSz': 'HalftoneSize',\n//     'Hlfp': 'HalftoneSpec',\n//     'Hrdn': 'Hardness',\n//     'HCdH': 'HasCmdHPreference',\n//     'Hdr ': 'Header',\n//     'Hdln': 'Headline',\n//     'Hght': 'Height',\n//     'HghA': 'HighlightArea',\n//     'hglC': 'HighlightColor',\n//     'HghL': 'HighlightLevels',\n//     'hglM': 'HighlightMode',\n//     'hglO': 'HighlightOpacity',\n//     'HghS': 'HighlightStrength',\n//     'HstB': 'HistoryBrushSource',\n//     'HstP': 'HistoryPrefs',\n//     'HsSS': 'HistoryStateSource',\n//     'HsSt': 'HistoryStates',\n//     'Hrzn': 'Horizontal',\n//     'HrzS': 'HorizontalScale',\n//     'HstN': 'HostName',\n//     'HstV': 'HostVersion',\n//     'H   ': 'Hue',\n//     'ICCE': 'ICCEngine',\n//     'ICCt': 'ICCSetupName',\n//     'Idnt': 'ID',\n//     'Idle': 'Idle',\n//     'ImgB': 'ImageBalance',\n//     'Impr': 'Import',\n//     'Imps': 'Impressionist',\n//     'In  ': 'In',\n//     'c@#^': 'Inherits',\n//     'InkC': 'InkColors',\n//     'Inks': 'Inks',\n//     'IrGl': 'InnerGlow',\n//     'glwS': 'InnerGlowSource',\n//     'IrSh': 'InnerShadow',\n//     'Inpt': 'Input',\n//     'kIBP': 'InputBlackPoint',\n//     'Inmr': 'InputMapRange',\n//     'Inpr': 'InputRange',\n//     'kIWP': 'InputWhitePoint',\n//     'Intn': 'Intensity',\n//     'Inte': 'Intent',\n//     'IntH': 'InterfaceBevelHighlight',\n//     'Intv': 'InterfaceBevelShadow',\n//     'IntB': 'InterfaceBlack',\n//     'Intd': 'InterfaceBorder',\n//     'Intk': 'InterfaceButtonDarkShadow',\n//     'Intt': 'InterfaceButtonDownFill',\n//     'InBF': 'InterfaceButtonUpFill',\n//     'ICBL': 'InterfaceColorBlue2',\n//     'ICBH': 'InterfaceColorBlue32',\n//     'ICGL': 'InterfaceColorGreen2',\n//     'ICGH': 'InterfaceColorGreen32',\n//     'ICRL': 'InterfaceColorRed2',\n//     'ICRH': 'InterfaceColorRed32',\n//     'IntI': 'InterfaceIconFillActive',\n//     'IntF': 'InterfaceIconFillDimmed',\n//     'Intc': 'InterfaceIconFillSelected',\n//     'Intm': 'InterfaceIconFrameActive',\n//     // 'Intr': 'InterfaceIconFrameDimmed',\n//     'IntS': 'InterfaceIconFrameSelected',\n//     'IntP': 'InterfacePaletteFill',\n//     'IntR': 'InterfaceRed',\n//     'IntT': 'InterfaceToolTipBackground',\n//     'ITTT': 'InterfaceToolTipText',\n//     'ITBg': 'InterfaceTransparencyBackground',\n//     'ITFg': 'InterfaceTransparencyForeground',\n//     'IntW': 'InterfaceWhite',\n//     // 'Intr': 'Interlace',\n//     'IntC': 'InterlaceCreateType',\n//     'IntE': 'InterlaceEliminateType',\n//     // 'Intr': 'Interpolation',\n//     'IntM': 'InterpolationMethod',\n//     'Invr': 'Invert',\n//     'InvM': 'InvertMask',\n//     'InvS': 'InvertSource2',\n//     'InvT': 'InvertTexture',\n//     'IsDr': 'IsDirty',\n//     'ItmI': 'ItemIndex',\n//     'JPEQ': 'JPEGQuality',\n//     'Krng': 'Kerning',\n//     'Kywd': 'Keywords',\n//     'Knd ': 'Kind',\n//     'LTnm': 'LUTAnimation',\n//     'LZWC': 'LZWCompression',\n//     'Lbls': 'Labels',\n//     'Lnds': 'Landscape',\n//     'LstT': 'LastTransform',\n//     'Lyr ': 'Layer',\n//     'Lefx': 'LayerEffects',\n//     'lfxv': 'LayerFXVisible',\n//     'LyrI': 'LayerID',\n//     'LyrN': 'LayerName',\n//     'Lyrs': 'Layers',\n//     'Ldng': 'Leading',\n//     'Left': 'Left',\n//     'lSNs': 'LegacySerialString',\n//     // 'Lngt': 'Length',\n//     'Lns ': 'Lens',\n//     'Lvl ': 'Level',\n//     'Lvls': 'Levels',\n//     'LgDr': 'LightDark',\n//     'LghD': 'LightDirection',\n//     'LghI': 'LightIntensity',\n//     'LghP': 'LightPosition',\n//     'LghS': 'LightSource',\n//     'LghT': 'LightType',\n//     'LghG': 'LightenGrout',\n//     'Lght': 'Lightness',\n//     'Line': 'Line',\n//     'lnkE': 'LinkEnable',\n//     'LnkL': 'LinkedLayerIDs',\n//     'Lald': 'LocalLightingAltitude',\n//     'lagl': 'LocalLightingAngle',\n//     'LclR': 'LocalRange',\n//     'Lctn': 'Location',\n//     'Log ': 'Log',\n//     'kLog': 'Logarithmic',\n//     'LwCs': 'LowerCase',\n//     'Lmnc': 'Luminance',\n//     'Mgnt': 'Magenta',\n//     'MkVs': 'MakeVisible',\n//     'Mfov': 'ManipulationFOV',\n//     'MpBl': 'MapBlack',\n//     'Mpng': 'Mapping',\n//     'MpgS': 'MappingShape',\n//     'Mtrl': 'Material',\n//     'Mtrx': 'Matrix',\n//     'MttC': 'MatteColor',\n//     'Mxm ': 'Maximum',\n//     'MxmS': 'MaximumStates',\n//     'MmrU': 'MemoryUsagePercent',\n//     'Mrge': 'Merge',\n//     'Mrgd': 'Merged',\n//     'Msge': 'Message',\n//     'Mthd': 'Method',\n//     'MztT': 'MezzotintType',\n//     'Mdpn': 'Midpoint',\n//     'MdtL': 'MidtoneLevels',\n//     'Mnm ': 'Minimum',\n//     'MsmC': 'MismatchCMYK',\n//     'MsmG': 'MismatchGray',\n//     'MsmR': 'MismatchRGB',\n//     'Md  ': 'Mode',\n//     'Mnch': 'Monochromatic',\n//     'MvT ': 'MoveTo',\n//     'Nm  ': 'Name',\n//     'Ngtv': 'Negative',\n//     'Nw  ': 'New',\n//     'Nose': 'Noise',\n//     'NnIm': 'NonImageData',\n//     'NnLn': 'NonLinear',\n//     'null': 'Null',\n//     'Nm L': 'NumLights',\n//     'Nmbr': 'Number',\n//     'NCch': 'NumberOfCacheLevels',\n//     'NC64': 'NumberOfCacheLevels64',\n//     'NmbO': 'NumberOfChannels',\n//     'NmbC': 'NumberOfChildren',\n//     'NmbD': 'NumberOfDocuments',\n//     'NmbG': 'NumberOfGenerators',\n//     // 'NmbL': 'NumberOfLayers',\n//     // 'NmbL': 'NumberOfLevels',\n//     'NmbP': 'NumberOfPaths',\n//     'NmbR': 'NumberOfRipples',\n//     'NmbS': 'NumberOfSiblings',\n//     'ObjN': 'ObjectName',\n//     'Ofst': 'Offset',\n//     'Sftt': 'OldSmallFontType',\n//     'On  ': 'On',\n//     'Opct': 'Opacity',\n//     'Optm': 'Optimized',\n//     'Ornt': 'Orientation',\n//     'OrgH': 'OriginalHeader',\n//     'OrgT': 'OriginalTransmissionReference',\n//     'OthC': 'OtherCursors',\n//     'OrGl': 'OuterGlow',\n//     'Otpt': 'Output',\n//     'kOBP': 'OutputBlackPoint',\n//     'kOWP': 'OutputWhitePoint',\n//     'OvrC': 'OverprintColors',\n//     'OvrO': 'OverrideOpen',\n//     'ObrP': 'OverridePrinter',\n//     'Ovrd': 'OverrideSave',\n//     'PNGf': 'PNGFilter',\n//     'PGIT': 'PNGInterlaceType',\n//     'PMpf': 'PageFormat',\n//     'PgNm': 'PageNumber',\n//     'PgPs': 'PagePosition',\n//     'PgSt': 'PageSetup',\n//     'PnCK': 'PaintCursorKind',\n//     'PntT': 'PaintType',\n//     'PntC': 'PaintingCursors',\n//     'Plt ': 'Palette',\n//     'PltF': 'PaletteFile',\n//     'PprB': 'PaperBrightness',\n//     'PrIn': 'ParentIndex',\n//     'PrNm': 'ParentName',\n//     'Path': 'Path',\n//     'PthC': 'PathContents',\n//     'PthN': 'PathName',\n//     'Pttn': 'Pattern',\n//     'Pncl': 'PencilWidth',\n//     'Prsp': 'PerspectiveIndex',\n//     'Phsp': 'Phosphors',\n//     'PckI': 'PickerID',\n//     'Pckr': 'PickerKind',\n//     'PPSz': 'PixelPaintSize',\n//     'Pltf': 'Platform',\n//     'PlgF': 'PluginFolder',\n//     'PlgP': 'PluginPrefs',\n//     'Pts ': 'Points',\n//     'Pstn': 'Position',\n//     'PstS': 'PostScriptColor',\n//     'Pstr': 'Posterization',\n//     'PrdC': 'PredefinedColors',\n//     'PrfB': 'PreferBuiltin',\n//     'Prfr': 'Preferences',\n//     'PrsA': 'PreserveAdditional',\n//     'PrsL': 'PreserveLuminosity',\n//     'PrsT': 'PreserveTransparency',\n//     'Prs ': 'Pressure',\n//     'Prvw': 'Preview',\n//     'PrvK': 'PreviewCMYK',\n//     'PrvF': 'PreviewFullSize',\n//     'PrvI': 'PreviewIcon',\n//     'PrvM': 'PreviewMacThumbnail',\n//     'PrvW': 'PreviewWinThumbnail',\n//     'PrvQ': 'PreviewsQuery',\n//     'PMps': 'PrintSettings',\n//     'PrfS': 'ProfileSetup',\n//     'PrvS': 'ProvinceState',\n//     'Qlty': 'Quality',\n//     'QucM': 'QuickMask',\n//     'RGBS': 'RGBSetup',\n//     'Rds ': 'Radius',\n//     'RndS': 'RandomSeed',\n//     'Rt  ': 'Ratio',\n//     'Rcnf': 'RecentFiles',\n//     'Rd  ': 'Red',\n//     'RdBl': 'RedBlackPoint',\n//     'redFloat': 'RedFloat',\n//     'RdGm': 'RedGamma',\n//     'RdWh': 'RedWhitePoint',\n//     'RdX ': 'RedX',\n//     'RdY ': 'RedY',\n//     'RgsM': 'RegistrationMarks',\n//     'Rltv': 'Relative',\n//     'Rlf ': 'Relief',\n//     'Rfid': 'RenderFidelity',\n//     'Rsmp': 'Resample',\n//     'RWOZ': 'ResizeWindowsOnZoom',\n//     'Rslt': 'Resolution',\n//     'RsrI': 'ResourceID',\n//     'Rspn': 'Response',\n//     'RtnH': 'RetainHeader',\n//     'Rvrs': 'Reverse',\n//     'Rght': 'Right',\n//     'RplM': 'RippleMagnitude',\n//     'RplS': 'RippleSize',\n//     'Rtt ': 'Rotate',\n//     'Rndn': 'Roundness',\n//     'RlrH': 'RulerOriginH',\n//     'RlrV': 'RulerOriginV',\n//     'RlrU': 'RulerUnits',\n//     // 'Strt': 'Saturation',\n//     'SvAn': 'SaveAndClose',\n//     'SvCm': 'SaveComposite',\n//     'PltL': 'SavePaletteLocations',\n//     'SvPt': 'SavePaths',\n//     'SvPy': 'SavePyramids',\n//     'Svng': 'Saving',\n//     'Scl ': 'Scale',\n//     'SclH': 'ScaleHorizontal',\n//     'SclV': 'ScaleVertical',\n//     'Scln': 'Scaling',\n//     'Scns': 'Scans',\n//     'ScrD': 'ScratchDisks',\n//     'ScrF': 'ScreenFile',\n//     'ScrT': 'ScreenType',\n//     'Sprt': 'Separations',\n//     'SrlS': 'SerialString',\n//     // 'ShdI': 'ShadingIntensity',\n//     'ShdN': 'ShadingNoise',\n//     'ShdS': 'ShadingShape',\n//     'sdwC': 'ShadowColor',\n//     // 'ShdI': 'ShadowIntensity',\n//     'ShdL': 'ShadowLevels',\n//     'sdwM': 'ShadowMode',\n//     'sdwO': 'ShadowOpacity',\n//     'Shp ': 'Shape',\n//     'Shrp': 'Sharpness',\n//     'ShrE': 'ShearEd',\n//     'ShrP': 'ShearPoints',\n//     'ShrS': 'ShearSt',\n//     'ShfK': 'ShiftKey',\n//     'ShKT': 'ShiftKeyToolSwitch',\n//     'ShrN': 'ShortNames',\n//     'ShwE': 'ShowEnglishFontNames',\n//     'SwMC': 'ShowMenuColors',\n//     'ShwT': 'ShowToolTips',\n//     'ShTr': 'ShowTransparency',\n//     'Sz  ': 'SizeKey',\n//     'Skew': 'Skew',\n//     'Sfts': 'SmallFontType',\n//     'SmBM': 'SmartBlurMode',\n//     'SmBQ': 'SmartBlurQuality',\n//     'Smoo': 'Smooth',\n//     'Smth': 'Smoothness',\n//     'SnpI': 'SnapshotInitial',\n//     'SfCl': 'SoftClip',\n//     'Sftn': 'Softness',\n//     'SoFi': 'SolidFill',\n//     'Srce': 'Source',\n//     'Src2': 'Source2',\n//     'SrcM': 'SourceMode',\n//     'Spcn': 'Spacing',\n//     'SpcI': 'SpecialInstructions',\n//     'SphM': 'SpherizeMode',\n//     'Spot': 'Spot',\n//     'SprR': 'SprayRadius',\n//     'SqrS': 'SquareSize',\n//     'Srcl': 'SrcBlackMax',\n//     'SrcB': 'SrcBlackMin',\n//     'Srcm': 'SrcWhiteMax',\n//     'SrcW': 'SrcWhiteMin',\n//     // 'Strt': 'Start',\n//     'StrA': 'StartArrowhead',\n//     'Stte': 'State',\n//     'srgh': 'Strength',\n//     'srgR': 'StrengthRatio',\n//     'Strg': 'Strength_PLUGIN',\n//     'StDt': 'StrokeDetail',\n//     'SDir': 'StrokeDirection',\n//     'StrL': 'StrokeLength',\n//     'StrP': 'StrokePressure',\n//     'StrS': 'StrokeSize',\n//     'StrW': 'StrokeWidth',\n//     'Styl': 'Style',\n//     'Stys': 'Styles',\n//     'StlC': 'StylusIsColor',\n//     'StlO': 'StylusIsOpacity',\n//     'StlP': 'StylusIsPressure',\n//     'StlS': 'StylusIsSize',\n//     'SbpL': 'SubPathList',\n//     'SplC': 'SupplementalCategories',\n//     'SstI': 'SystemInfo',\n//     'SstP': 'SystemPalette',\n//     // 'null': 'Target',\n//     'Trgp': 'TargetPath',\n//     'TrgP': 'TargetPathIndex',\n//     // 'Lngt': 'TermLength',\n//     'Txt ': 'Text',\n//     // 'TxtC': 'TextClickPoint',\n//     'TxtD': 'TextData',\n//     'TxtS': 'TextStyle',\n//     'Txtt': 'TextStyleRange',\n//     'Txtr': 'Texture',\n//     // 'TxtC': 'TextureCoverage',\n//     'TxtF': 'TextureFile',\n//     'TxtT': 'TextureType',\n//     'Thsh': 'Threshold',\n//     'TlNm': 'TileNumber',\n//     'TlOf': 'TileOffset',\n//     'TlSz': 'TileSize',\n//     'Ttl ': 'Title',\n//     'T   ': 'To',\n//     'TBl ': 'ToBuiltin',\n//     'ToLk': 'ToLinked',\n//     'TMd ': 'ToMode',\n//     'TglO': 'ToggleOthers',\n//     'Tlrn': 'Tolerance',\n//     'Top ': 'Top',\n//     'TtlL': 'TotalLimit',\n//     'Trck': 'Tracking',\n//     'TrnF': 'TransferFunction',\n//     // 'TrnS': 'TransferSpec',\n//     'Trns': 'Transparency',\n//     // 'TrnG': 'TransparencyGrid',\n//     'TrnC': 'TransparencyGridColors',\n//     // 'TrnG': 'TransparencyGridSize',\n//     'TrnP': 'TransparencyPrefs',\n//     // 'TrnS': 'TransparencyShape',\n//     'TrnI': 'TransparentIndex',\n//     'TrnW': 'TransparentWhites',\n//     'Twst': 'Twist',\n//     'Type': 'Type',\n//     'UC  ': 'UCA',\n//     'URL ': 'URL',\n//     'UndA': 'UndefinedArea',\n//     'Undl': 'Underline',\n//     'UntP': 'UnitsPrefs',\n//     'Untl': 'Untitled',\n//     'UppY': 'UpperY',\n//     'Urgn': 'Urgency',\n//     'AcrS': 'UseAccurateScreens',\n//     'AdPl': 'UseAdditionalPlugins',\n//     'UsCc': 'UseCacheForHistograms',\n//     'UsCr': 'UseCurves',\n//     'UsDf': 'UseDefault',\n//     'uglg': 'UseGlobalAngle',\n//     'UsIC': 'UseICCProfile',\n//     'UsMs': 'UseMask',\n//     'UsrM': 'UserMaskEnabled',\n//     'Usrs': 'UserMaskLinked',\n//     'Usng': 'Using',\n//     'Vl  ': 'Value',\n//     'Vrnc': 'Variance',\n//     'Vct0': 'Vector0',\n//     'Vct1': 'Vector1',\n//     'VctC': 'VectorColor',\n//     'VrsF': 'VersionFix',\n//     'VrsM': 'VersionMajor',\n//     'VrsN': 'VersionMinor',\n//     'Vrtc': 'Vertical',\n//     'VrtS': 'VerticalScale',\n//     'Vdlp': 'VideoAlpha',\n//     'Vsbl': 'Visible',\n//     'WtcS': 'WatchSuspension',\n//     'watr': 'Watermark',\n//     'Wvtp': 'WaveType',\n//     'WLMx': 'WavelengthMax',\n//     'WLMn': 'WavelengthMin',\n//     'WbdP': 'WebdavPrefs',\n//     'Wtdg': 'WetEdges',\n//     'What': 'What',\n//     'WhtC': 'WhiteClip',\n//     'WhtI': 'WhiteIntensity',\n//     'WhHi': 'WhiteIsHigh',\n//     'WhtL': 'WhiteLevel',\n//     'WhtP': 'WhitePoint',\n//     'WhPt': 'WholePath',\n//     'Wdth': 'Width',\n//     'WndM': 'WindMethod',\n//     'With': 'With',\n//     'WrPt': 'WorkPath',\n//     'WrkP': 'WorkPathIndex',\n//     'X   ': 'X',\n//     'Y   ': 'Y',\n//     'Ylw ': 'Yellow',\n//     'ZZTy': 'ZigZagType',\n//     'Alis': '_3DAntiAlias',\n// };\n","/**\n * ExifReader\n * http://github.com/mattiasw/exifreader\n * Copyright (C) 2011-2023  Mattias Wallander <mattias@wallander.eu>\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/* global Buffer, __non_webpack_require__ */\n\nimport {objectAssign, dataUriToBuffer} from './utils.js';\nimport DataViewWrapper from './dataview.js';\nimport Constants from './constants.js';\nimport {getStringValueFromArray} from './utils.js';\nimport {getCalculatedGpsValue} from './tag-names-utils.js';\nimport ImageHeader from './image-header.js';\nimport Tags from './tags.js';\nimport MpfTags from './mpf-tags.js';\nimport FileTags from './file-tags.js';\nimport JfifTags from './jfif-tags.js';\nimport IptcTags from './iptc-tags.js';\nimport XmpTags from './xmp-tags.js';\nimport PhotoshopTags from './photoshop-tags.js';\nimport IccTags from './icc-tags.js';\nimport CanonTags from './canon-tags.js';\nimport PentaxTags from './pentax-tags.js';\nimport PngFileTags from './png-file-tags.js';\nimport PngTextTags from './png-text-tags.js';\nimport PngTags from './png-tags.js';\nimport Vp8xTags from './vp8x-tags.js';\nimport GifFileTags from './gif-file-tags.js';\nimport Thumbnail from './thumbnail.js';\nimport Composite from './composite.js';\nimport exifErrors from './errors.js';\n\nexport default {\n    load,\n    loadView,\n    errors: exifErrors,\n};\n\nexport const errors = exifErrors;\n\nexport function load(data, options = {}) {\n    if (isFilePathOrURL(data)) {\n        options.async = true;\n        return loadFile(data, options).then((fileContents) => loadFromData(fileContents, options));\n    }\n    if (isBrowserFileObject(data)) {\n        options.async = true;\n        return loadFileObject(data).then((fileContents) => loadFromData(fileContents, options));\n    }\n    return loadFromData(data, options);\n}\n\nfunction isFilePathOrURL(data) {\n    return typeof data === 'string';\n}\n\nfunction loadFile(filename, options) {\n    if (/^\\w+:\\/\\//.test(filename)) {\n        if (typeof fetch !== 'undefined') {\n            return fetchRemoteFile(filename, options);\n        }\n\n        return nodeGetRemoteFile(filename, options);\n    }\n\n    if (isDataUri(filename)) {\n        return Promise.resolve(dataUriToBuffer(filename));\n    }\n\n    return loadLocalFile(filename, options);\n}\n\nfunction fetchRemoteFile(url, {length} = {}) {\n    const options = {method: 'GET'};\n    if (Number.isInteger(length) && length >= 0) {\n        options.headers = {\n            range: `bytes=0-${length - 1}`,\n        };\n    }\n    return fetch(url, options).then((response) => response.arrayBuffer());\n}\n\nfunction nodeGetRemoteFile(url, {length} = {}) {\n    return new Promise((resolve, reject) => {\n        const options = {};\n        if (Number.isInteger(length) && length >= 0) {\n            options.headers = {\n                range: `bytes=0-${length - 1}`,\n            };\n        }\n\n        const get = requireNodeGet(url);\n        get(url, options, (response) => {\n            if ((response.statusCode >= 200) && (response.statusCode <= 299)) {\n                const data = [];\n                response.on('data', (chunk) => data.push(Buffer.from(chunk)));\n                response.on('error', (error) => reject(error));\n                response.on('end', () => resolve(Buffer.concat(data)));\n            } else {\n                reject(`Could not fetch file: ${response.statusCode} ${response.statusMessage}`);\n                response.resume();\n            }\n        }).on('error', (error) => reject(error));\n    });\n}\n\nfunction requireNodeGet(url) {\n    if (/^https:\\/\\//.test(url)) {\n        return __non_webpack_require__('https').get;\n    }\n    return __non_webpack_require__('http').get;\n}\n\nfunction isDataUri(filename) {\n    return /^data:[^;,]*(;base64)?,/.test(filename);\n}\n\nfunction loadLocalFile(filename, {length} = {}) {\n    return new Promise((resolve, reject) => {\n        const fs = requireNodeFs();\n        fs.open(filename, (error, fd) => {\n            if (error) {\n                reject(error);\n            } else {\n                fs.stat(filename, (error, stat) => {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        const size = Math.min(stat.size, length !== undefined ? length : stat.size);\n                        const buffer = Buffer.alloc(size);\n                        const options = {\n                            buffer,\n                            length: size\n                        };\n                        fs.read(fd, options, (error) => {\n                            if (error) {\n                                reject(error);\n                            } else {\n                                fs.close(fd, (error) => {\n                                    if (error) {\n                                        console.warn(`Could not close file ${filename}:`, error); // eslint-disable-line no-console\n                                    }\n                                    resolve(buffer);\n                                });\n                            }\n                        });\n                    }\n                });\n            }\n        });\n    });\n}\n\nfunction requireNodeFs() {\n    try {\n        return __non_webpack_require__('fs');\n    } catch (error) {\n        return undefined;\n    }\n}\n\nfunction isBrowserFileObject(data) {\n    return (typeof File !== 'undefined') && (data instanceof File);\n}\n\nfunction loadFileObject(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => resolve(readerEvent.target.result);\n        reader.onerror = () => reject(reader.error);\n        reader.readAsArrayBuffer(file);\n    });\n}\n\nfunction loadFromData(data, options) {\n    if (isNodeBuffer(data)) {\n        // File data read in Node can share the underlying buffer with other\n        // data. Therefore it's safest to get a new one to avoid weird bugs.\n        data = (new Uint8Array(data)).buffer;\n    }\n    return loadView(getDataView(data), options);\n}\n\nfunction isNodeBuffer(data) {\n    try {\n        return Buffer.isBuffer(data);\n    } catch (error) {\n        return false;\n    }\n}\n\nfunction getDataView(data) {\n    try {\n        return new DataView(data);\n    } catch (error) {\n        return new DataViewWrapper(data);\n    }\n}\n\nexport function loadView(\n    dataView,\n    {\n        expanded = false,\n        async = false,\n        includeUnknown = false,\n        domParser = undefined,\n    } = {\n        expanded: false,\n        async: false,\n        includeUnknown: false,\n        domParser: undefined,\n    }\n) {\n    let foundMetaData = false;\n    let tags = {};\n    const tagsPromises = [];\n\n    const {\n        fileType,\n        fileDataOffset,\n        jfifDataOffset,\n        tiffHeaderOffset,\n        iptcDataOffset,\n        xmpChunks,\n        iccChunks,\n        mpfDataOffset,\n        pngHeaderOffset,\n        pngTextChunks,\n        pngChunkOffsets,\n        vp8xChunkOffset,\n        gifHeaderOffset\n    } = ImageHeader.parseAppMarkers(dataView, async);\n\n    if (Constants.USE_JPEG && Constants.USE_FILE && hasFileData(fileDataOffset)) {\n        foundMetaData = true;\n        const readTags = FileTags.read(dataView, fileDataOffset);\n        if (expanded) {\n            tags.file = readTags;\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if (Constants.USE_JPEG && Constants.USE_JFIF && hasJfifData(jfifDataOffset)) {\n        foundMetaData = true;\n        const readTags = JfifTags.read(dataView, jfifDataOffset);\n        if (expanded) {\n            tags.jfif = readTags;\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if (Constants.USE_EXIF && hasExifData(tiffHeaderOffset)) {\n        foundMetaData = true;\n        const {tags: readTags, byteOrder} = Tags.read(dataView, tiffHeaderOffset, includeUnknown);\n        if (readTags.Thumbnail) {\n            tags.Thumbnail = readTags.Thumbnail;\n            delete readTags.Thumbnail;\n        }\n\n        if (expanded) {\n            tags.exif = readTags;\n            addGpsGroup(tags);\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n\n        if (Constants.USE_TIFF && Constants.USE_IPTC && readTags['IPTC-NAA'] && !hasIptcData(iptcDataOffset)) {\n            const readIptcTags = IptcTags.read(readTags['IPTC-NAA'].value, 0, includeUnknown);\n            if (expanded) {\n                tags.iptc = readIptcTags;\n            } else {\n                tags = objectAssign({}, tags, readIptcTags);\n            }\n        }\n\n        if (Constants.USE_TIFF && Constants.USE_XMP && readTags['ApplicationNotes'] && !hasXmpData(xmpChunks)) {\n            const readXmpTags = XmpTags.read(getStringValueFromArray(readTags['ApplicationNotes'].value), undefined, domParser);\n            if (expanded) {\n                tags.xmp = readXmpTags;\n            } else {\n                delete readXmpTags._raw;\n                tags = objectAssign({}, tags, readXmpTags);\n            }\n        }\n\n        if (Constants.USE_PHOTOSHOP && readTags['ImageSourceData'] && readTags['PhotoshopSettings']) {\n            const readPhotoshopTags = PhotoshopTags.read(readTags['PhotoshopSettings'].value, includeUnknown);\n            if (expanded) {\n                tags.photoshop = readPhotoshopTags;\n            } else {\n                tags = objectAssign({}, tags, readPhotoshopTags);\n            }\n        }\n\n        if (Constants.USE_TIFF && Constants.USE_ICC && readTags['ICC_Profile'] && !hasIccData(iccChunks)) {\n            const readIccTags = IccTags.read(\n                readTags['ICC_Profile'].value,\n                [{\n                    offset: 0,\n                    length: readTags['ICC_Profile'].value.length,\n                    chunkNumber: 1,\n                    chunksTotal: 1\n                }]\n            );\n            if (expanded) {\n                tags.icc = readIccTags;\n            } else {\n                tags = objectAssign({}, tags, readIccTags);\n            }\n        }\n\n        if (Constants.USE_MAKER_NOTES && readTags['MakerNote']) {\n            if (hasCanonData(readTags)) {\n                const readCanonTags = CanonTags.read(dataView, tiffHeaderOffset, readTags['MakerNote'].__offset, byteOrder, includeUnknown);\n                if (expanded) {\n                    tags.makerNotes = readCanonTags;\n                } else {\n                    tags = objectAssign({}, tags, readCanonTags);\n                }\n            } else if (hasPentaxType1Data(readTags)) {\n                const readPentaxTags = PentaxTags.read(dataView, tiffHeaderOffset, readTags['MakerNote'].__offset, includeUnknown);\n                if (expanded) {\n                    tags.makerNotes = readPentaxTags;\n                } else {\n                    tags = objectAssign({}, tags, readPentaxTags);\n                }\n            }\n        }\n\n        if (readTags['MakerNote']) {\n            delete readTags['MakerNote'].__offset;\n        }\n    }\n\n    if (Constants.USE_JPEG && Constants.USE_IPTC && hasIptcData(iptcDataOffset)) {\n        foundMetaData = true;\n        const readTags = IptcTags.read(dataView, iptcDataOffset, includeUnknown);\n        if (expanded) {\n            tags.iptc = readTags;\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if (Constants.USE_XMP && hasXmpData(xmpChunks)) {\n        foundMetaData = true;\n        const readTags = XmpTags.read(dataView, xmpChunks, domParser);\n        if (expanded) {\n            tags.xmp = readTags;\n        } else {\n            delete readTags._raw;\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if ((Constants.USE_JPEG || Constants.USE_WEBP) && Constants.USE_ICC && hasIccData(iccChunks)) {\n        foundMetaData = true;\n        const readTags = IccTags.read(dataView, iccChunks, async);\n        if (readTags instanceof Promise) {\n            tagsPromises.push(readTags.then(addIccTags));\n        } else {\n            addIccTags(readTags);\n        }\n    }\n\n    if (Constants.USE_MPF && hasMpfData(mpfDataOffset)) {\n        foundMetaData = true;\n        const readMpfTags = MpfTags.read(dataView, mpfDataOffset, includeUnknown);\n        if (expanded) {\n            tags.mpf = readMpfTags;\n        } else {\n            tags = objectAssign({}, tags, readMpfTags);\n        }\n    }\n\n    if (Constants.USE_PNG && Constants.USE_PNG_FILE && hasPngFileData(pngHeaderOffset)) {\n        foundMetaData = true;\n        const readTags = PngFileTags.read(dataView, pngHeaderOffset);\n        if (expanded) {\n            tags.png = !tags.png ? readTags : objectAssign({}, tags.png, readTags);\n            tags.pngFile = readTags;\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if (Constants.USE_PNG && hasPngTextData(pngTextChunks)) {\n        foundMetaData = true;\n        const {readTags, readTagsPromise} = PngTextTags.read(dataView, pngTextChunks, async, includeUnknown);\n        addPngTextTags(readTags);\n        if (readTagsPromise) {\n            tagsPromises.push(readTagsPromise.then((tagList) => tagList.forEach(addPngTextTags)));\n        }\n    }\n\n    if (Constants.USE_PNG && hasPngData(pngChunkOffsets)) {\n        foundMetaData = true;\n        const readTags = PngTags.read(dataView, pngChunkOffsets);\n        if (expanded) {\n            tags.png = !tags.png ? readTags : objectAssign({}, tags.png, readTags);\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if (Constants.USE_WEBP && hasVp8xData(vp8xChunkOffset)) {\n        foundMetaData = true;\n        const readTags = Vp8xTags.read(dataView, vp8xChunkOffset);\n        if (expanded) {\n            tags.riff = !tags.riff ? readTags : objectAssign({}, tags.riff, readTags);\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    if (Constants.USE_GIF && hasGifFileData(gifHeaderOffset)) {\n        foundMetaData = true;\n        const readTags = GifFileTags.read(dataView, gifHeaderOffset);\n        if (expanded) {\n            tags.gif = !tags.gif ? readTags : objectAssign({}, tags.gif, readTags);\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    const composite = Composite.get(tags, expanded);\n    if (composite) {\n        if (expanded) {\n            tags.composite = composite;\n        } else {\n            tags = objectAssign({}, tags, composite);\n        }\n    }\n\n    const thumbnail = (Constants.USE_JPEG || Constants.USE_WEBP)\n        && Constants.USE_EXIF\n        && Constants.USE_THUMBNAIL\n        && Thumbnail.get(dataView, tags.Thumbnail, tiffHeaderOffset);\n    if (thumbnail) {\n        foundMetaData = true;\n        tags.Thumbnail = thumbnail;\n    } else {\n        delete tags.Thumbnail;\n    }\n\n    if (fileType) {\n        if (expanded) {\n            if (!tags.file) {\n                tags.file = {};\n            }\n            tags.file.FileType = fileType;\n        } else {\n            tags.FileType = fileType;\n        }\n        foundMetaData = true;\n    }\n\n    if (!foundMetaData) {\n        throw new exifErrors.MetadataMissingError();\n    }\n\n    if (async) {\n        return Promise.all(tagsPromises).then(() => tags);\n    }\n    return tags;\n\n    function addIccTags(readTags) {\n        if (expanded) {\n            tags.icc = readTags;\n        } else {\n            tags = objectAssign({}, tags, readTags);\n        }\n    }\n\n    function addPngTextTags(readTags) {\n        if (expanded) {\n            for (const group of ['exif', 'iptc']) {\n                const groupKey = `__${group}`;\n                if (readTags[groupKey]) {\n                    tags[group] = !tags[group] ? readTags[groupKey] : objectAssign({}, tags.exif, readTags[groupKey]);\n                    delete readTags[groupKey];\n                }\n            }\n            tags.png = !tags.png ? readTags : objectAssign({}, tags.png, readTags);\n            tags.pngText = !tags.pngText ? readTags : objectAssign({}, tags.png, readTags);\n        } else {\n            tags = objectAssign(\n                {},\n                tags,\n                readTags.__exif ? readTags.__exif : {},\n                readTags.__iptc ? readTags.__iptc : {},\n                readTags\n            );\n            delete tags.__exif;\n            delete tags.__iptc;\n        }\n    }\n}\n\nfunction hasFileData(fileDataOffset) {\n    return fileDataOffset !== undefined;\n}\n\nfunction hasJfifData(jfifDataOffset) {\n    return jfifDataOffset !== undefined;\n}\n\nfunction hasExifData(tiffHeaderOffset) {\n    return tiffHeaderOffset !== undefined;\n}\n\nfunction addGpsGroup(tags) {\n    if (tags.exif) {\n        if (tags.exif.GPSLatitude && tags.exif.GPSLatitudeRef) {\n            try {\n                tags.gps = tags.gps || {};\n                tags.gps.Latitude = getCalculatedGpsValue(tags.exif.GPSLatitude.value);\n                if (tags.exif.GPSLatitudeRef.value.join('') === 'S') {\n                    tags.gps.Latitude = -tags.gps.Latitude;\n                }\n            } catch (error) {\n                // Ignore.\n            }\n        }\n\n        if (tags.exif.GPSLongitude && tags.exif.GPSLongitudeRef) {\n            try {\n                tags.gps = tags.gps || {};\n                tags.gps.Longitude = getCalculatedGpsValue(tags.exif.GPSLongitude.value);\n                if (tags.exif.GPSLongitudeRef.value.join('') === 'W') {\n                    tags.gps.Longitude = -tags.gps.Longitude;\n                }\n            } catch (error) {\n                // Ignore.\n            }\n        }\n\n        if (tags.exif.GPSAltitude && tags.exif.GPSAltitudeRef) {\n            try {\n                tags.gps = tags.gps || {};\n                tags.gps.Altitude = tags.exif.GPSAltitude.value[0] / tags.exif.GPSAltitude.value[1];\n                if (tags.exif.GPSAltitudeRef.value === 1) {\n                    tags.gps.Altitude = -tags.gps.Altitude;\n                }\n            } catch (error) {\n                // Ignore.\n            }\n        }\n    }\n}\n\nfunction hasIptcData(iptcDataOffset) {\n    return iptcDataOffset !== undefined;\n}\n\nfunction hasXmpData(xmpChunks) {\n    return Array.isArray(xmpChunks) && xmpChunks.length > 0;\n}\n\nfunction hasIccData(iccDataOffsets) {\n    return Array.isArray(iccDataOffsets) && iccDataOffsets.length > 0;\n}\n\nfunction hasCanonData(tags) {\n    return tags['Make'] && tags['Make'].value && Array.isArray(tags['Make'].value) && tags['Make'].value[0] === 'Canon'\n        && tags['MakerNote'] && tags['MakerNote'].__offset;\n}\n\nfunction hasPentaxType1Data(tags) {\n    const PENTAX_ID_STRING = 'PENTAX ';\n    return tags['MakerNote'].value.length > PENTAX_ID_STRING.length\n        && getStringValueFromArray(tags['MakerNote'].value.slice(0, PENTAX_ID_STRING.length)) === PENTAX_ID_STRING\n        && tags['MakerNote'].__offset;\n}\n\nfunction hasMpfData(mpfDataOffset) {\n    return mpfDataOffset !== undefined;\n}\n\nfunction hasPngFileData(pngFileDataOffset) {\n    return pngFileDataOffset !== undefined;\n}\n\nfunction hasPngTextData(pngTextChunks) {\n    return pngTextChunks !== undefined;\n}\n\nfunction hasPngData(pngChunkOffsets) {\n    return pngChunkOffsets !== undefined;\n}\n\nfunction hasVp8xData(vp8xChunkOffset) {\n    return vp8xChunkOffset !== undefined;\n}\n\nfunction hasGifFileData(gifHeaderOffset) {\n    return gifHeaderOffset !== undefined;\n}\n","import type { AccumulateResult } from \"@beep/errors/client\";\nimport type { DetectedFileInfo, ExifMetadata, FileAttributes } from \"@beep/files-domain/value-objects\";\nimport type * as Errors from \"./errors\";\n/**************\n * Upload pipeline shared models (scaffolding)\n * - Keep types colocated with the feature in apps/web/src/features/upload\n * - Reuse shared schemas via @beep/schema (BS namespace)\n **************/\n\nexport interface PipelineConfig {\n  readonly maxSizeBytes?: number; // e.g., 3_145_728\n  readonly allowedMime?: ReadonlyArray<string>; // e.g., ['image/jpeg', 'image/png']\n  readonly chunkSize?: number; // default 64\n  readonly excludeSimilarTypes?: boolean; // if helpers support it\n}\n\n// Step outputs\nexport interface ValidateFileOutput {\n  readonly detected?: DetectedFileInfo.Type;\n  readonly formattedSize: string;\n}\n\nexport interface BasicMetadataOutput {\n  readonly attributes: FileAttributes.Type;\n  readonly detected?: DetectedFileInfo.Type;\n}\n\nexport type ExifMetadataOutput = typeof ExifMetadata.Type | undefined;\n\n// Union of domain failures (scaffolding)\nexport type UploadError = Errors.ValidationError | Errors.DetectionError | Errors.ExifParseError;\n\nexport interface UploadResult {\n  readonly file: File;\n  readonly validated: ValidateFileOutput;\n  readonly basic: BasicMetadataOutput;\n  readonly exif: ExifMetadataOutput; // cleaned/validated EXIF (images only)\n}\n\nexport type ProcessFilesResult = AccumulateResult<UploadResult, UploadError>;\n\nexport const DEFAULT_CHUNK_SIZE = 64 as const;\n"],"names":["internal"],"mappings":"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","ignoreList":[0,1,3,7,8,9,15,20,21,22,23,24,25,26,28,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,62,63,65,66,69,70,71,73,74,76,77]}