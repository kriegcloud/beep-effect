{"version":3,"sources":["turbopack:///[project]/node_modules/@mui/system/esm/useTheme/useTheme.js","turbopack:///[project]/node_modules/@mui/system/esm/useThemeWithoutDefault/useThemeWithoutDefault.js","turbopack:///[project]/node_modules/@mui/system/esm/createBox/createBox.js","turbopack:///[project]/node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js","turbopack:///[project]/node_modules/@mui/material/esm/Box/Box.js","turbopack:///[project]/node_modules/@mui/material/esm/Box/boxClasses.js","turbopack:///[project]/node_modules/effect/src/Struct.ts","turbopack:///[project]/node_modules/effect/src/Match.ts","turbopack:///[project]/node_modules/effect/src/internal/matcher.ts","turbopack:///[project]/node_modules/@mui/system/esm/GlobalStyles/GlobalStyles.js","turbopack:///[project]/node_modules/@mui/styled-engine/esm/GlobalStyles/GlobalStyles.js","turbopack:///[project]/node_modules/@mui/material/esm/styles/useTheme.js","turbopack:///[project]/node_modules/@mui/material/esm/GlobalStyles/GlobalStyles.js","turbopack:///[project]/node_modules/@mui/material/esm/Typography/Typography.js","turbopack:///[project]/node_modules/@mui/material/esm/zero-styled/index.js","turbopack:///[project]/node_modules/@mui/material/esm/Typography/typographyClasses.js"],"sourcesContent":["'use client';\n\nimport createTheme from \"../createTheme/index.js\";\nimport useThemeWithoutDefault from \"../useThemeWithoutDefault/index.js\";\nexport const systemDefaultTheme = createTheme();\nfunction useTheme(defaultTheme = systemDefaultTheme) {\n  return useThemeWithoutDefault(defaultTheme);\n}\nexport default useTheme;","'use client';\n\nimport * as React from 'react';\nimport { ThemeContext } from '@mui/styled-engine';\nfunction isObjectEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction useTheme(defaultTheme = null) {\n  const contextTheme = React.useContext(ThemeContext);\n  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme : contextTheme;\n}\nexport default useTheme;","'use client';\n\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport styled from '@mui/styled-engine';\nimport styleFunctionSx, { extendSxProp } from \"../styleFunctionSx/index.js\";\nimport useTheme from \"../useTheme/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default function createBox(options = {}) {\n  const {\n    themeId,\n    defaultTheme,\n    defaultClassName = 'MuiBox-root',\n    generateClassName\n  } = options;\n  const BoxRoot = styled('div', {\n    shouldForwardProp: prop => prop !== 'theme' && prop !== 'sx' && prop !== 'as'\n  })(styleFunctionSx);\n  const Box = /*#__PURE__*/React.forwardRef(function Box(inProps, ref) {\n    const theme = useTheme(defaultTheme);\n    const {\n      className,\n      component = 'div',\n      ...other\n    } = extendSxProp(inProps);\n    return /*#__PURE__*/_jsx(BoxRoot, {\n      as: component,\n      ref: ref,\n      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),\n      theme: themeId ? theme[themeId] || theme : theme,\n      ...other\n    });\n  });\n  return Box;\n}","import { isPlainObject } from '@mui/utils/deepmerge';\nimport defaultSxConfig from \"./defaultSxConfig.js\";\nconst splitProps = props => {\n  const result = {\n    systemProps: {},\n    otherProps: {}\n  };\n  const config = props?.theme?.unstable_sxConfig ?? defaultSxConfig;\n  Object.keys(props).forEach(prop => {\n    if (config[prop]) {\n      result.systemProps[prop] = props[prop];\n    } else {\n      result.otherProps[prop] = props[prop];\n    }\n  });\n  return result;\n};\nexport default function extendSxProp(props) {\n  const {\n    sx: inSx,\n    ...other\n  } = props;\n  const {\n    systemProps,\n    otherProps\n  } = splitProps(other);\n  let finalSx;\n  if (Array.isArray(inSx)) {\n    finalSx = [systemProps, ...inSx];\n  } else if (typeof inSx === 'function') {\n    finalSx = (...args) => {\n      const result = inSx(...args);\n      if (!isPlainObject(result)) {\n        return systemProps;\n      }\n      return {\n        ...systemProps,\n        ...result\n      };\n    };\n  } else {\n    finalSx = {\n      ...systemProps,\n      ...inSx\n    };\n  }\n  return {\n    ...otherProps,\n    sx: finalSx\n  };\n}","'use client';\n\nimport { createBox } from '@mui/system';\nimport PropTypes from 'prop-types';\nimport { unstable_ClassNameGenerator as ClassNameGenerator } from \"../className/index.js\";\nimport { createTheme } from \"../styles/index.js\";\nimport THEME_ID from \"../styles/identifier.js\";\nimport boxClasses from \"./boxClasses.js\";\nconst defaultTheme = createTheme();\nconst Box = createBox({\n  themeId: THEME_ID,\n  defaultTheme,\n  defaultClassName: boxClasses.root,\n  generateClassName: ClassNameGenerator.generate\n});\nprocess.env.NODE_ENV !== \"production\" ? Box.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * @ignore\n   */\n  children: PropTypes.node,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default Box;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nconst boxClasses = generateUtilityClasses('MuiBox', ['root']);\nexport default boxClasses;","/**\n * This module provides utility functions for working with structs in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport * as Equivalence from \"./Equivalence.js\"\nimport { dual } from \"./Function.js\"\nimport * as order from \"./Order.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type { MatchRecord, Simplify } from \"./Types.js\"\n\n/**\n * Create a new object by picking properties of an existing object.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Struct } from \"effect\"\n *\n * assert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.pick(\"a\", \"b\")), { a: \"a\", b: 1 })\n * assert.deepStrictEqual(Struct.pick({ a: \"a\", b: 1, c: true }, \"a\", \"b\"), { a: \"a\", b: 1 })\n * ```\n *\n * @since 2.0.0\n */\nexport const pick: {\n  /**\n   * Create a new object by picking properties of an existing object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Struct } from \"effect\"\n   *\n   * assert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.pick(\"a\", \"b\")), { a: \"a\", b: 1 })\n   * assert.deepStrictEqual(Struct.pick({ a: \"a\", b: 1, c: true }, \"a\", \"b\"), { a: \"a\", b: 1 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any }>(\n    s: S\n  ) => MatchRecord<S, { [K in Keys[number]]?: S[K] }, Simplify<Pick<S, Keys[number]>>>\n  /**\n   * Create a new object by picking properties of an existing object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Struct } from \"effect\"\n   *\n   * assert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.pick(\"a\", \"b\")), { a: \"a\", b: 1 })\n   * assert.deepStrictEqual(Struct.pick({ a: \"a\", b: 1, c: true }, \"a\", \"b\"), { a: \"a\", b: 1 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): MatchRecord<S, { [K in Keys[number]]?: S[K] }, Simplify<Pick<S, Keys[number]>>>\n} = dual(\n  (args) => Predicate.isObject(args[0]),\n  <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys) => {\n    const out: any = {}\n    for (const k of keys) {\n      if (k in s) {\n        out[k] = (s as any)[k]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Create a new object by omitting properties of an existing object.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Struct } from \"effect\"\n *\n * assert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.omit(\"c\")), { a: \"a\", b: 1 })\n * assert.deepStrictEqual(Struct.omit({ a: \"a\", b: 1, c: true }, \"c\"), { a: \"a\", b: 1 })\n * ```\n *\n * @since 2.0.0\n */\nexport const omit: {\n  /**\n   * Create a new object by omitting properties of an existing object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Struct } from \"effect\"\n   *\n   * assert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.omit(\"c\")), { a: \"a\", b: 1 })\n   * assert.deepStrictEqual(Struct.omit({ a: \"a\", b: 1, c: true }, \"c\"), { a: \"a\", b: 1 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any }>(s: S) => Simplify<Omit<S, Keys[number]>>\n  /**\n   * Create a new object by omitting properties of an existing object.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Struct } from \"effect\"\n   *\n   * assert.deepStrictEqual(pipe({ a: \"a\", b: 1, c: true }, Struct.omit(\"c\")), { a: \"a\", b: 1 })\n   * assert.deepStrictEqual(Struct.omit({ a: \"a\", b: 1, c: true }, \"c\"), { a: \"a\", b: 1 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>\n} = dual(\n  (args) => Predicate.isObject(args[0]),\n  <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys) => {\n    const out: any = { ...s }\n    for (const k of keys) {\n      delete out[k]\n    }\n    return out\n  }\n)\n\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * Alias of {@link Equivalence.struct}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Struct, String, Number } from \"effect\"\n *\n * const PersonEquivalence = Struct.getEquivalence({\n *   name: String.Equivalence,\n *   age: Number.Equivalence\n * })\n *\n * assert.deepStrictEqual(\n *   PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 25 }),\n *   true\n * )\n * assert.deepStrictEqual(\n *   PersonEquivalence({ name: \"John\", age: 25 }, { name: \"John\", age: 40 }),\n *   false\n * )\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(\n  isEquivalents: R\n) => Equivalence.Equivalence<\n  { readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never }\n> = Equivalence.struct\n\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * Alias of {@link order.struct}.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const getOrder: <R extends { readonly [x: string]: order.Order<any> }>(\n  fields: R\n) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never }> = order.struct\n\ntype Transformed<O, T> =\n  & unknown\n  & {\n    [K in keyof O]: K extends keyof T ? (T[K] extends (...a: any) => any ? ReturnType<T[K]> : O[K]) : O[K]\n  }\ntype PartialTransform<O, T> = {\n  [K in keyof T]: T[K] extends (a: O[K & keyof O]) => any ? T[K] : (a: O[K & keyof O]) => unknown\n}\n/**\n * Transforms the values of a Struct provided a transformation function for each key.\n * If no transformation function is provided for a key, it will return the original value for that key.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Struct } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     { a: 'a', b: 1, c: 3 },\n *     Struct.evolve({\n *       a: (a) => a.length,\n *       b: (b) => b * 2\n *     })\n *   ),\n *   { a: 1, b: 2, c: 3 }\n * )\n * ```\n *\n * @since 2.0.0\n */\nexport const evolve: {\n  /**\n   * Transforms the values of a Struct provided a transformation function for each key.\n   * If no transformation function is provided for a key, it will return the original value for that key.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Struct } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     { a: 'a', b: 1, c: 3 },\n   *     Struct.evolve({\n   *       a: (a) => a.length,\n   *       b: (b) => b * 2\n   *     })\n   *   ),\n   *   { a: 1, b: 2, c: 3 }\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>\n  /**\n   * Transforms the values of a Struct provided a transformation function for each key.\n   * If no transformation function is provided for a key, it will return the original value for that key.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Struct } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     { a: 'a', b: 1, c: 3 },\n   *     Struct.evolve({\n   *       a: (a) => a.length,\n   *       b: (b) => b * 2\n   *     })\n   *   ),\n   *   { a: 1, b: 2, c: 3 }\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>\n} = dual(\n  2,\n  <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T> => {\n    const out = { ...obj }\n    for (const k in t) {\n      if (Object.prototype.hasOwnProperty.call(obj, k)) {\n        // @ts-expect-error\n        out[k] = t[k](obj[k])\n      }\n    }\n    return out as any\n  }\n)\n\n/**\n * Retrieves the value associated with the specified key from a struct.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Struct } from \"effect\"\n *\n * const value = pipe({ a: 1, b: 2 }, Struct.get(\"a\"))\n *\n * assert.deepStrictEqual(value, 1)\n * ```\n *\n * @since 2.0.0\n */\nexport const get =\n  <K extends PropertyKey>(key: K) => <S extends { [P in K]?: any }>(s: S): MatchRecord<S, S[K] | undefined, S[K]> =>\n    s[key]\n\n/**\n * Retrieves the object keys that are strings in a typed manner\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Struct } from \"effect\"\n *\n * const symbol: unique symbol = Symbol()\n *\n * const value = {\n *   a: 1,\n *   b: 2,\n *   [symbol]: 3\n * }\n *\n * const keys: Array<\"a\" | \"b\"> = Struct.keys(value)\n *\n * assert.deepStrictEqual(keys, [\"a\", \"b\"])\n * ```\n *\n * @since 3.6.0\n */\nexport const keys = <T extends {}>(o: T): Array<(keyof T) & string> => Object.keys(o) as Array<(keyof T) & string>\n\n/**\n * Retrieves the entries (key-value pairs) of an object, where keys are strings,\n * in a type-safe manner. Symbol keys are excluded from the result.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Struct } from \"effect\"\n *\n * const c = Symbol(\"c\")\n * const value = { a: \"foo\", b: 1, [c]: true }\n *\n * const entries: Array<[\"a\" | \"b\", string | number]> = Struct.entries(value)\n *\n * assert.deepStrictEqual(entries, [[\"a\", \"foo\"], [\"b\", 1]])\n * ```\n *\n * @since 3.17.0\n */\nexport const entries = <const R>(obj: R): Array<[keyof R & string, R[keyof R & string]]> =>\n  Object.entries(obj as any) as any\n","/**\n * The `effect/match` module provides a type-safe pattern matching system for\n * TypeScript. Inspired by functional programming, it simplifies conditional\n * logic by replacing verbose if/else or switch statements with a structured and\n * expressive API.\n *\n * This module supports matching against types, values, and discriminated unions\n * while enforcing exhaustiveness checking to ensure all cases are handled.\n *\n * Although pattern matching is not yet a native JavaScript feature,\n * `effect/match` offers a reliable implementation that is available today.\n *\n * **How Pattern Matching Works**\n *\n * Pattern matching follows a structured process:\n *\n * - **Creating a matcher**: Define a `Matcher` that operates on either a\n *   specific `Match.type` or `Match.value`.\n *\n * - **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n *   and `Match.tag` to specify matching conditions.\n *\n * - **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n *   `Match.orElse`, or `Match.option` to determine how unmatched cases should\n *   be handled.\n *\n * @since 1.0.0\n */\nimport type * as Either from \"./Either.js\"\nimport * as internal from \"./internal/matcher.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as T from \"./Types.js\"\nimport type { Unify } from \"./Unify.js\"\n\n/**\n * @category Symbols\n * @since 1.0.0\n */\nexport const MatcherTypeId: unique symbol = internal.TypeId\n\n/**\n * @category Symbols\n * @since 1.0.0\n */\nexport type MatcherTypeId = typeof MatcherTypeId\n\n/**\n * Pattern matching follows a structured process:\n *\n * - **Creating a matcher**: Define a `Matcher` that operates on either a\n *   specific `Match.type` or `Match.value`.\n *\n * - **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n *   and `Match.tag` to specify matching conditions.\n *\n * - **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n *   `Match.orElse`, or `Match.option` to determine how unmatched cases should\n *   be handled.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Simulated dynamic input that can be a string or a number\n * const input: string | number = \"some input\"\n *\n * //      ┌─── string\n * //      ▼\n * const result = Match.value(input).pipe(\n *   // Match if the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Match if the value is a string\n *   Match.when(Match.string, (s) => `string: ${s}`),\n *   // Ensure all possible cases are covered\n *   Match.exhaustive\n * )\n *\n * console.log(result)\n * // Output: \"string: some input\"\n * ```\n *\n * @category Model\n * @since 1.0.0\n */\nexport type Matcher<Input, Filters, RemainingApplied, Result, Provided, Return = any> =\n  | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>\n  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface TypeMatcher<in Input, out Filters, out Remaining, out Result, out Return = any> extends Pipeable {\n  readonly _tag: \"TypeMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _remaining: T.Covariant<Remaining>\n    readonly _result: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly cases: ReadonlyArray<Case>\n  add<I, R, RA, A>(_case: Case): TypeMatcher<I, R, RA, A>\n}\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface ValueMatcher<in Input, out Filters, out Remaining, out Result, out Provided, out Return = any>\n  extends Pipeable\n{\n  readonly _tag: \"ValueMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _remaining: T.Covariant<Remaining>\n    readonly _result: T.Covariant<Result>\n    readonly _provided: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly provided: Provided\n  readonly value: Either.Either<Provided, Remaining>\n  add<I, R, RA, A, Pr>(_case: Case): ValueMatcher<I, R, RA, A, Pr>\n}\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport type Case = When | Not\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface When {\n  readonly _tag: \"When\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface Not {\n  readonly _tag: \"Not\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}\n\n/**\n * Creates a matcher for a specific type.\n *\n * **Details**\n *\n * This function defines a `Matcher` that operates on a given type, allowing you\n * to specify conditions for handling different cases. Once the matcher is\n * created, you can use pattern-matching functions like {@link when} to define\n * how different values should be processed.\n *\n * **Example** (Matching Numbers and Strings)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for values that are either strings or numbers\n * //\n * //      ┌─── (u: string | number) => string\n * //      ▼\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Match when the value is a string\n *   Match.when(Match.string, (s) => `string: ${s}`),\n *   // Ensure all possible cases are handled\n *   Match.exhaustive\n * )\n *\n * console.log(match(0))\n * // Output: \"number: 0\"\n *\n * console.log(match(\"hello\"))\n * // Output: \"string: hello\"\n * ```\n *\n * @see {@link value} for creating a matcher from a specific value.\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const type: <I>() => Matcher<I, Types.Without<never>, I, never, never> = internal.type\n\n/**\n * Creates a matcher from a specific value.\n *\n * **Details**\n *\n * This function allows you to define a `Matcher` directly from a given value,\n * rather than from a type. This is useful when working with known values,\n * enabling structured pattern matching on objects, primitives, or any data\n * structure.\n *\n * Once the matcher is created, you can use pattern-matching functions like\n * {@link when} to define how different cases should be handled.\n *\n * **Example** (Matching an Object by Property)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * const input = { name: \"John\", age: 30 }\n *\n * // Create a matcher for the specific object\n * const result = Match.value(input).pipe(\n *   // Match when the 'name' property is \"John\"\n *   Match.when(\n *     { name: \"John\" },\n *     (user) => `${user.name} is ${user.age} years old`\n *   ),\n *   // Provide a fallback if no match is found\n *   Match.orElse(() => \"Oh, not John\")\n * )\n *\n * console.log(result)\n * // Output: \"John is 30 years old\"\n * ```\n *\n * @see {@link type} for creating a matcher from a specific type.\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const value: <const I>(\n  i: I\n) => Matcher<I, Types.Without<never>, I, never, I> = internal.value\n\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const valueTags: {\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P): (input: I) => Unify<ReturnType<P[keyof P]>>\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(input: I, fields: P): Unify<ReturnType<P[keyof P]>>\n} = internal.valueTags\n\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const typeTags: {\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <I, Ret>(): <\n    P extends\n      & {\n        readonly [Tag in Types.Tags<\"_tag\", I> & string]: (\n          _: Extract<I, { readonly _tag: Tag }>\n        ) => Ret\n      }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P) => (input: I) => Ret\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <I>(): <\n    P extends\n      & {\n        readonly [Tag in Types.Tags<\"_tag\", I> & string]: (\n          _: Extract<I, { readonly _tag: Tag }>\n        ) => any\n      }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>\n} = internal.typeTags\n\n/**\n * Ensures that all branches of a matcher return a specific type.\n *\n * **Details**\n *\n * This function enforces a consistent return type across all pattern-matching\n * branches. By specifying a return type, TypeScript will check that every\n * matching condition produces a value of the expected type.\n *\n * **Important:** This function must be the first step in the matcher pipeline.\n * If used later, TypeScript will not enforce type consistency correctly.\n *\n * **Example** (Validating Return Type Consistency)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * const match = Match.type<{ a: number } | { b: string }>().pipe(\n *   // Ensure all branches return a string\n *   Match.withReturnType<string>(),\n *   // ❌ Type error: 'number' is not assignable to type 'string'\n *   // @ts-expect-error\n *   Match.when({ a: Match.number }, (_) => _.a),\n *   // ✅ Correct: returns a string\n *   Match.when({ b: Match.string }, (_) => _.b),\n *   Match.exhaustive\n * )\n * ```\n *\n * @since 1.0.0\n */\nexport const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(\n  self: Matcher<I, F, R, A, Pr, _>\n) => [Ret] extends [[A] extends [never] ? any : A] ? Matcher<I, F, R, A, Pr, Ret>\n  : \"withReturnType constraint does not extend Result type\" = internal.withReturnType\n\n/**\n * Defines a condition for matching values.\n *\n * **Details**\n *\n * This function enables pattern matching by checking whether a given value\n * satisfies a condition. It supports both direct value comparisons and\n * predicate functions. If the condition is met, the associated function is\n * executed.\n *\n * This function is useful when defining matchers that need to check for\n * specific values or apply logical conditions to determine a match. It works\n * well with structured objects and primitive types.\n *\n * **Example** (Matching with Values and Predicates)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for objects with an \"age\" property\n * const match = Match.type<{ age: number }>().pipe(\n *   // Match when age is greater than 18\n *   Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n *   // Match when age is exactly 18\n *   Match.when({ age: 18 }, () => \"You can vote\"),\n *   // Fallback case for all other ages\n *   Match.orElse((user) => `${user.age} is too young`)\n * )\n *\n * console.log(match({ age: 20 }))\n * // Output: \"Age: 20\"\n *\n * console.log(match({ age: 18 }))\n * // Output: \"You can vote\"\n *\n * console.log(match({ age: 4 }))\n * // Output: \"4 is too young\"\n * ```\n *\n * @see {@link whenOr} Use this when multiple patterns should match in a single\n * condition.\n * @see {@link whenAnd} Use this when a value must match all provided patterns.\n * @see {@link orElse} Provides a fallback when no patterns match.\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const when: <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.when\n\n/**\n * Matches one of multiple patterns in a single condition.\n *\n * **Details**\n *\n * This function allows defining a condition where a value matches any of the\n * provided patterns. If a match is found, the associated function is executed.\n * It simplifies cases where multiple patterns share the same handling logic.\n *\n * Unlike {@link when}, which requires separate conditions for each pattern,\n * this function enables combining them into a single statement, making the\n * matcher more concise.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type ErrorType =\n *   | { readonly _tag: \"NetworkError\"; readonly message: string }\n *   | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n *   | { readonly _tag: \"ValidationError\"; readonly field: string }\n *\n * const handleError = Match.type<ErrorType>().pipe(\n *   Match.whenOr(\n *     { _tag: \"NetworkError\" },\n *     { _tag: \"TimeoutError\" },\n *     () => \"Retry the request\"\n *   ),\n *   Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n *   Match.exhaustive\n * )\n *\n * console.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n * // Output: \"Retry the request\"\n *\n * console.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n * // Output: \"Invalid field: email\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenOr: <\n  R,\n  const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P[number]>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.whenOr\n\n/**\n * Matches a value that satisfies all provided patterns.\n *\n * **Details**\n *\n * This function allows defining a condition where a value must match all the\n * given patterns simultaneously. If the value satisfies every pattern, the\n * associated function is executed.\n *\n * Unlike {@link when}, which matches a single pattern at a time, this function\n * ensures that multiple conditions are met before executing the callback. It is\n * useful when checking for values that need to fulfill multiple criteria at\n * once.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n *\n * const checkUser = Match.type<User>().pipe(\n *   Match.whenAnd(\n *     { age: (n) => n >= 18 },\n *     { role: \"admin\" },\n *     () => \"Admin access granted\"\n *   ),\n *   Match.orElse(() => \"Access denied\")\n * )\n *\n * console.log(checkUser({ age: 20, role: \"admin\" }))\n * // Output: \"Admin access granted\"\n *\n * console.log(checkUser({ age: 20, role: \"user\" }))\n * // Output: \"Access denied\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenAnd: <\n  R,\n  const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>,\n  A | ReturnType<Fn>,\n  Pr\n> = internal.whenAnd\n\n/**\n * Matches values based on a specified discriminant field.\n *\n * **Details**\n *\n * This function is used to define pattern matching on objects that follow a\n * **discriminated union** structure, where a specific field (e.g., `type`,\n * `kind`, `_tag`) determines the variant of the object. It allows matching\n * multiple values of the discriminant and provides a function to handle the\n * matched cases.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n *   Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminator: <D extends string>(\n  field: D\n) => <R, P extends Types.Tags<D, R> & string, Ret, Fn extends (_: Extract<R, Record<D, P>>) => Ret>(\n  ...pattern: [first: P, ...values: Array<P>, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<D, P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.discriminator\n\n/**\n * Matches values where a specified field starts with a given prefix.\n *\n * **Details**\n *\n * This function is useful for working with discriminated unions where the\n * discriminant field follows a hierarchical or namespaced structure. It allows\n * you to match values based on whether the specified field starts with a given\n * prefix, making it easier to handle grouped cases.\n *\n * Instead of checking for exact matches, this function lets you match values\n * that share a common prefix. For example, if your discriminant field contains\n * hierarchical names like `\"A\"`, `\"A.A\"`, and `\"B\"`, you can match all values\n * starting with `\"A\"` using a single rule.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n *   Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n *   Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ type: \"A\" })) // 1\n * console.log(match({ type: \"B\" })) // 2\n * console.log(match({ type: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorStartsWith: <D extends string>(\n  field: D\n) => <R, P extends string, Ret, Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.discriminatorStartsWith\n\n/**\n * Matches values based on a field that serves as a discriminator, mapping each\n * possible value to a corresponding handler.\n *\n * **Details**\n *\n * This function simplifies working with discriminated unions by letting you\n * define a set of handlers for each possible value of a given field. Instead of\n * chaining multiple calls to {@link discriminator}, this function allows\n * defining all possible cases at once using an object where the keys are the\n * possible values of the field, and the values are the corresponding handler\n * functions.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminators(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminators: <D extends string>(\n  field: D\n) => <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<D, keyof P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>,\n  A | ReturnType<P[keyof P] & {}>,\n  Pr,\n  Ret\n> = internal.discriminators\n\n/**\n * Matches values based on a discriminator field and **ensures all cases are\n * handled**.\n *\n * **Details*+\n *\n * This function is similar to {@link discriminators}, but **requires that all\n * possible cases** are explicitly handled. It is useful when working with\n * discriminated unions, where a specific field (e.g., `\"type\"`) determines the\n * shape of an object. Each possible value of the field must have a\n * corresponding handler, ensuring **exhaustiveness checking** at compile time.\n *\n * This function **does not require** `Match.exhaustive` at the end of the\n * pipeline because it enforces exhaustiveness by design.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminatorsExhaustive(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorsExhaustive: <D extends string>(\n  field: D\n) => <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>> =\n  internal.discriminatorsExhaustive\n\n/**\n * The `Match.tag` function allows pattern matching based on the `_tag` field in\n * a [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).\n * You can specify multiple tags to match within a single pattern.\n *\n * **Note**\n *\n * The `Match.tag` function relies on the convention within the Effect ecosystem\n * of naming the tag field as `\"_tag\"`. Ensure that your discriminated unions\n * follow this naming convention for proper functionality.\n *\n * **Example** (Matching a Discriminated Union by Tag)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type Event =\n *   | { readonly _tag: \"fetch\" }\n *   | { readonly _tag: \"success\"; readonly data: string }\n *   | { readonly _tag: \"error\"; readonly error: Error }\n *   | { readonly _tag: \"cancel\" }\n *\n * // Create a Matcher for Either<number, string>\n * const match = Match.type<Event>().pipe(\n *   // Match either \"fetch\" or \"success\"\n *   Match.tag(\"fetch\", \"success\", () => `Ok!`),\n *   // Match \"error\" and extract the error message\n *   Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n *   // Match \"cancel\"\n *   Match.tag(\"cancel\", () => \"Cancelled\"),\n *   Match.exhaustive\n * )\n *\n * console.log(match({ _tag: \"success\", data: \"Hello\" }))\n * // Output: \"Ok!\"\n *\n * console.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n * // Output: \"Error: Oops!\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tag: <\n  R,\n  P extends Types.Tags<\"_tag\", R> & string,\n  Ret,\n  Fn extends (_: Extract<R, Record<\"_tag\", P>>) => Ret\n>(\n  ...pattern: [first: P, ...values: Array<P>, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>,\n  ReturnType<Fn> | A,\n  Pr,\n  Ret\n> = internal.tag\n\n/**\n * Matches values where the `_tag` field starts with a given prefix.\n *\n * **Details**\n *\n * This function allows you to match on values in a **discriminated union**\n * based on whether the `_tag` field starts with a specified prefix. It is\n * useful for handling hierarchical or namespaced tags, where multiple related\n * cases share a common prefix.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n *   Match.tagStartsWith(\"A\", (_) => 1 as const),\n *   Match.tagStartsWith(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ _tag: \"A\" })) // 1\n * console.log(match({ _tag: \"B\" })) // 2\n * console.log(match({ _tag: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagStartsWith: <\n  R,\n  P extends string,\n  Ret,\n  Fn extends (_: Extract<R, Record<\"_tag\", `${P}${string}`>>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>>,\n  ReturnType<Fn> | A,\n  Pr,\n  Ret\n> = internal.tagStartsWith\n\n/**\n * Matches values based on their `_tag` field, mapping each tag to a\n * corresponding handler.\n *\n * **Details**\n *\n * This function provides a way to handle discriminated unions by mapping `_tag`\n * values to specific functions. Each handler receives the matched value and\n * returns a transformed result. If all possible tags are handled, you can\n * enforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tags({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tags: <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<\"_tag\", R> & string]?: ((_: Extract<R, Record<\"_tag\", Tag>>) => Ret) | undefined }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>>,\n  A | ReturnType<P[keyof P] & {}>,\n  Pr,\n  Ret\n> = internal.tags\n\n/**\n * Matches values based on their `_tag` field and requires handling of all\n * possible cases.\n *\n * **Details**\n *\n * This function is designed for **discriminated unions** where every possible\n * `_tag` value must have a corresponding handler. Unlike {@link tags}, this\n * function ensures **exhaustiveness**, meaning all cases must be explicitly\n * handled. If a `_tag` value is missing from the mapping, TypeScript will\n * report an error.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tagsExhaustive({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagsExhaustive: <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<\"_tag\", R> & string]: (_: Extract<R, Record<\"_tag\", Tag>>) => Ret }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>> =\n  internal.tagsExhaustive\n\n/**\n * Excludes a specific value from matching while allowing all others.\n *\n * **Details**\n *\n * This function is useful when you need to **handle all values except one or\n * more specific cases**. Instead of listing all possible matches manually, this\n * function simplifies the logic by allowing you to specify values to exclude.\n * Any excluded value will bypass the provided function and continue matching\n * through other cases.\n *\n * **Example** (Ignoring a Specific Value)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match any value except \"hi\", returning \"ok\"\n *   Match.not(\"hi\", () => \"ok\"),\n *   // Fallback case for when the value is \"hi\"\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"hello\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"hi\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const not: <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.NotMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddOnly<F, Types.WhenMatch<R, P>>,\n  Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.not\n\n/**\n * Matches non-empty strings.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const nonEmptyString: SafeRefinement<string, never> = internal.nonEmptyString\n\n/**\n * Matches a specific set of literal values (e.g., `Match.is(\"a\", 42, true)`).\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const is: <\n  Literals extends ReadonlyArray<string | number | bigint | boolean | null>\n>(...literals: Literals) => SafeRefinement<Literals[number]> = internal.is\n\n/**\n * Matches values of type `string`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const string: Predicate.Refinement<unknown, string> = Predicate.isString\n\n/**\n * Matches values of type `number`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const number: Predicate.Refinement<unknown, number> = Predicate.isNumber\n\n/**\n * Matches any value without restrictions.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const any: SafeRefinement<unknown, any> = internal.any\n\n/**\n * Matches any defined (non-null and non-undefined) value.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const defined: <A>(u: A) => u is A & {} = internal.defined\n\n/**\n * Matches values of type `boolean`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const boolean: Predicate.Refinement<unknown, boolean> = Predicate.isBoolean\n\nconst _undefined: Predicate.Refinement<unknown, undefined> = Predicate.isUndefined\nexport {\n  /**\n   * Matches the value `undefined`.\n   *\n   * @category Predicates\n   * @since 1.0.0\n   */\n  _undefined as undefined\n}\n\nconst _null: Predicate.Refinement<unknown, null> = Predicate.isNull\nexport {\n  /**\n   * Matches the value `null`.\n   *\n   * @category Predicates\n   * @since 1.0.0\n   */\n  _null as null\n}\n\n/**\n * Matches values of type `bigint`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const bigint: Predicate.Refinement<unknown, bigint> = Predicate.isBigInt\n\n/**\n * Matches values of type `symbol`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const symbol: Predicate.Refinement<unknown, symbol> = Predicate.isSymbol\n\n/**\n * Matches values that are instances of `Date`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const date: Predicate.Refinement<unknown, Date> = Predicate.isDate\n\n/**\n * Matches objects where keys are `string` or `symbol` and values are `unknown`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const record: Predicate.Refinement<unknown, { [x: string | symbol]: unknown }> = Predicate.isRecord\n\n/**\n * Matches instances of a given class.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOf: <A extends abstract new(...args: any) => any>(\n  constructor: A\n) => SafeRefinement<InstanceType<A>, never> = internal.instanceOf\n\n/**\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOfUnsafe: <A extends abstract new(...args: any) => any>(\n  constructor: A\n) => SafeRefinement<InstanceType<A>, InstanceType<A>> = internal.instanceOf\n\n/**\n * Provides a fallback value when no patterns match.\n *\n * **Details**\n *\n * This function ensures that a matcher always returns a valid result, even if\n * no defined patterns match. It acts as a default case, similar to the\n * `default` clause in a `switch` statement or the final `else` in an `if-else`\n * chain.\n *\n * **Example** (Providing a Default Value When No Patterns Match)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is \"a\"\n *   Match.when(\"a\", () => \"ok\"),\n *   // Fallback when no patterns match\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"a\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"b\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElse: <RA, Ret, F extends (_: RA) => Ret>(\n  f: F\n) => <I, R, A, Pr>(\n  self: Matcher<I, R, RA, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A> = internal.orElse\n\n// TODO(4.0): Rename to \"orThrow\"? Like Either.getOrThrow\n/**\n * Throws an error if no pattern matches.\n *\n * **Details**\n *\n * This function finalizes a matcher by ensuring that if no patterns match, an\n * error is thrown. It is useful when all cases should be covered, and any\n * unexpected input should trigger an error instead of returning a default\n * value.\n *\n * When used, this function removes the need for an explicit fallback case and\n * ensures that an unmatched value is never silently ignored.\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElseAbsurd: <I, R, RA, A, Pr, Ret>(\n  self: Matcher<I, R, RA, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A> = internal.orElseAbsurd\n\n/**\n * Wraps the match result in an `Either`, distinguishing matched and unmatched\n * cases.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is always wrapped in an\n * `Either`, allowing clear differentiation between successful matches\n * (`Right(value)`) and cases where no pattern matched (`Left(unmatched\n * value)`).\n *\n * This approach is particularly useful when handling optional values or when an\n * unmatched case should be explicitly handled rather than returning a default\n * value or throwing an error.\n *\n * **Example** (Extracting a User Role with `Match.either`)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.either // Wrap the result in an Either\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const either: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R> = internal.either\n\n/**\n * Wraps the match result in an `Option`, representing an optional match.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is wrapped in an `Option`,\n * making it easy to handle cases where no pattern matches. If a match is found,\n * it returns `Some(value)`, otherwise, it returns `None`.\n *\n * This is useful in cases where a missing match is expected and should be\n * handled explicitly rather than throwing an error or returning a default\n * value.\n *\n * **Example** (Extracting a User Role with `Match.option`)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.option // Wrap the result in an Option\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const option: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>> = internal.option\n\n/**\n * The `Match.exhaustive` method finalizes the pattern matching process by\n * ensuring that all possible cases are accounted for. If any case is missing,\n * TypeScript will produce a type error. This is particularly useful when\n * working with unions, as it helps prevent unintended gaps in pattern matching.\n *\n * **Example** (Ensuring All Cases Are Covered)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Mark the match as exhaustive, ensuring all cases are handled\n *   // TypeScript will throw an error if any case is missing\n *   // @ts-expect-error Type 'string' is not assignable to type 'never'\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const exhaustive: <I, F, A, Pr, Ret>(\n  self: Matcher<I, F, never, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A> = internal.exhaustive\n\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport const SafeRefinementId = Symbol.for(\"effect/SafeRefinement\")\n\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport type SafeRefinementId = typeof SafeRefinementId\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface SafeRefinement<in A, out R = A> {\n  readonly [SafeRefinementId]: (a: A) => R\n}\n\nconst Fail = Symbol.for(\"effect/Fail\")\ntype Fail = typeof Fail\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Types {\n  /**\n   * @since 1.0.0\n   */\n  export type WhenMatch<R, P> =\n    // check for any\n    [0] extends [1 & R] ? ResolvePred<P> :\n      P extends SafeRefinement<infer SP, never> ? SP\n      : P extends Predicate.Refinement<infer _R, infer RP>\n      // try to narrow refinement\n        ? [Extract<R, RP>] extends [infer X] ? [X] extends [never]\n            // fallback to original refinement\n            ? RP\n          : X\n        : never\n      : P extends PredicateA<infer PP> ? PP\n      : ExtractMatch<R, P>\n\n  /**\n   * @since 1.0.0\n   */\n  export type NotMatch<R, P> = Exclude<R, ExtractMatch<R, PForNotMatch<P>>>\n\n  type PForNotMatch<P> = [ToInvertedRefinement<P>] extends [infer X] ? X\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type PForMatch<P> = [ResolvePred<P>] extends [infer X] ? X\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type PForExclude<P> = [SafeRefinementR<ToSafeRefinement<P>>] extends [infer X] ? X\n    : never\n\n  // utilities\n  type PredicateA<A> = Predicate.Predicate<A> | Predicate.Refinement<A, A>\n\n  type SafeRefinementR<A> = A extends never ? never\n    : A extends SafeRefinement<infer _, infer R> ? R\n    : A extends Function ? A\n    : A extends Record<string, any> ? { [K in keyof A]: SafeRefinementR<A[K]> }\n    : A\n\n  type ResolvePred<A, Input = any> = A extends never ? never\n    : A extends SafeRefinement<infer _A, infer _R> ? _A\n    : A extends Predicate.Refinement<Input, infer P> ? P\n    : A extends Predicate.Predicate<infer P> ? P\n    : A extends Record<string, any> ? { [K in keyof A]: ResolvePred<A[K]> }\n    : A\n\n  type ToSafeRefinement<A> = A extends never ? never\n    : A extends Predicate.Refinement<any, infer P> ? SafeRefinement<P, P>\n    : A extends Predicate.Predicate<infer P> ? SafeRefinement<P, never>\n    : A extends SafeRefinement<any> ? A\n    : A extends Record<string, any> ? { [K in keyof A]: ToSafeRefinement<A[K]> }\n    : NonLiteralsTo<A, never>\n\n  type ToInvertedRefinement<A> = A extends never ? never\n    : A extends Predicate.Refinement<any, infer P> ? SafeRefinement<P>\n    : A extends Predicate.Predicate<infer _P> ? SafeRefinement<never>\n    : A extends SafeRefinement<infer _A, infer _R> ? SafeRefinement<_R>\n    : A extends Record<string, any> ? { [K in keyof A]: ToInvertedRefinement<A[K]> }\n    : NonLiteralsTo<A, never>\n\n  type NonLiteralsTo<A, T> = [A] extends [string | number | boolean | bigint] ? [string] extends [A] ? T\n    : [number] extends [A] ? T\n    : [boolean] extends [A] ? T\n    : [bigint] extends [A] ? T\n    : A\n    : A\n\n  /**\n   * @since 1.0.0\n   */\n  export type PatternBase<A> = A extends ReadonlyArray<infer _T> ? ReadonlyArray<any> | PatternPrimitive<A>\n    : A extends Record<string, any> ? Partial<\n        { [K in keyof A]: PatternPrimitive<A[K] & {}> | PatternBase<A[K] & {}> }\n      >\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type PatternPrimitive<A> = PredicateA<A> | A | SafeRefinement<any>\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Without<out X> {\n    readonly _tag: \"Without\"\n    readonly _X: X\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Only<out X> {\n    readonly _tag: \"Only\"\n    readonly _X: X\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export type AddWithout<A, X> = [A] extends [Without<infer WX>] ? Without<X | WX>\n    : [A] extends [Only<infer OX>] ? Only<Exclude<OX, X>>\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type AddOnly<A, X> = [A] extends [Without<infer WX>] ? [X] extends [WX] ? never\n    : Only<X>\n    : [A] extends [Only<infer OX>] ? [X] extends [OX] ? Only<X>\n      : never\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type ApplyFilters<I, A> = A extends Only<infer X> ? X\n    : A extends Without<infer X> ? Exclude<I, X>\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type Tags<D extends string, P> = P extends Record<D, infer X> ? X : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type ArrayToIntersection<A extends ReadonlyArray<any>> = T.UnionToIntersection<\n    A[number]\n  >\n\n  /**\n   * @since 1.0.0\n   */\n  export type ExtractMatch<I, P> = [ExtractAndNarrow<I, P>] extends [infer EI] ? EI\n    : never\n\n  type Replace<A, B> = A extends Function ? A\n    : A extends Record<string | number, any> ? { [K in keyof A]: K extends keyof B ? Replace<A[K], B[K]> : A[K] }\n    : [B] extends [A] ? B\n    : A\n\n  type MaybeReplace<I, P> = [P] extends [I] ? P\n    : [I] extends [P] ? Replace<I, P>\n    : Fail\n\n  type BuiltInObjects =\n    | Function\n    | Date\n    | RegExp\n    | Generator\n    | { readonly [Symbol.toStringTag]: string }\n\n  type IsPlainObject<T> = T extends BuiltInObjects ? false\n    : T extends Record<string, any> ? true\n    : false\n\n  type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n  type ExtractAndNarrow<Input, P> = P extends Predicate.Refinement<infer _In, infer _Out> ?\n    _Out extends Input ? Extract<_Out, Input>\n    : Extract<Input, _Out> :\n    P extends SafeRefinement<infer _In, infer _R> ? [0] extends [1 & _R] ? Input\n      : _In extends Input ? Extract<_In, Input>\n      : Extract<Input, _In>\n    : P extends Predicate.Predicate<infer _In> ? Extract<Input, _In>\n    : Input extends infer I ? Exclude<\n        I extends ReadonlyArray<any> ? P extends ReadonlyArray<any> ? {\n              readonly [K in keyof I]: K extends keyof P ? ExtractAndNarrow<I[K], P[K]>\n                : I[K]\n            } extends infer R ? Fail extends R[keyof R] ? never\n              : R\n            : never\n          : never\n          : IsPlainObject<I> extends true ? string extends keyof I ? I extends P ? I\n              : never\n            : symbol extends keyof I ? I extends P ? I\n              : never\n            : Simplify<\n              & { [RK in Extract<keyof I, keyof P>]-?: ExtractAndNarrow<I[RK], P[RK]> }\n              & Omit<I, keyof P>\n            > extends infer R ? keyof P extends NonFailKeys<R> ? R\n              : never\n            : never\n          : MaybeReplace<I, P> extends infer R ? [I] extends [R] ? I\n            : R\n          : never,\n        Fail\n      > :\n    never\n\n  type NonFailKeys<A> = keyof A & {} extends infer K ? K extends keyof A ? A[K] extends Fail ? never : K\n    : never :\n    never\n}\n","import * as Either from \"../Either.js\"\nimport { dual, identity } from \"../Function.js\"\nimport type {\n  Case,\n  Matcher,\n  MatcherTypeId,\n  Not,\n  SafeRefinement,\n  TypeMatcher,\n  Types,\n  ValueMatcher,\n  When\n} from \"../Match.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type * as Predicate from \"../Predicate.js\"\nimport type { Unify } from \"../Unify.js\"\n\n/** @internal */\nexport const TypeId: MatcherTypeId = Symbol.for(\n  \"@effect/matcher/Matcher\"\n) as MatcherTypeId\n\nconst TypeMatcherProto: Omit<TypeMatcher<any, any, any, any>, \"cases\"> = {\n  [TypeId]: {\n    _input: identity,\n    _filters: identity,\n    _remaining: identity,\n    _result: identity,\n    _return: identity\n  },\n  _tag: \"TypeMatcher\",\n  add<I, R, RA, A>(\n    this: TypeMatcher<any, any, any, any>,\n    _case: Case\n  ): TypeMatcher<I, R, RA, A> {\n    return makeTypeMatcher([...this.cases, _case])\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nfunction makeTypeMatcher<I, R, RA, A>(\n  cases: ReadonlyArray<Case>\n): TypeMatcher<I, R, RA, A> {\n  const matcher = Object.create(TypeMatcherProto)\n  matcher.cases = cases\n  return matcher\n}\n\nconst ValueMatcherProto: Omit<\n  ValueMatcher<any, any, any, any, any>,\n  \"provided\" | \"value\"\n> = {\n  [TypeId]: {\n    _input: identity,\n    _filters: identity,\n    _remaining: identity,\n    _result: identity,\n    _provided: identity,\n    _return: identity\n  },\n  _tag: \"ValueMatcher\",\n  add<I, R, RA, A, Pr>(\n    this: ValueMatcher<any, any, any, any, any>,\n    _case: Case\n  ): ValueMatcher<I, R, RA, A, Pr> {\n    if (this.value._tag === \"Right\") {\n      return this\n    }\n\n    if (_case._tag === \"When\" && _case.guard(this.provided) === true) {\n      return makeValueMatcher(\n        this.provided,\n        Either.right(_case.evaluate(this.provided))\n      )\n    } else if (_case._tag === \"Not\" && _case.guard(this.provided) === false) {\n      return makeValueMatcher(\n        this.provided,\n        Either.right(_case.evaluate(this.provided))\n      )\n    }\n\n    return this\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nfunction makeValueMatcher<I, R, RA, A, Pr>(\n  provided: Pr,\n  value: Either.Either<Pr, RA>\n): ValueMatcher<I, R, RA, A, Pr> {\n  const matcher = Object.create(ValueMatcherProto)\n  matcher.provided = provided\n  matcher.value = value\n  return matcher\n}\n\nconst makeWhen = (\n  guard: (u: unknown) => boolean,\n  evaluate: (input: unknown) => any\n): When => ({\n  _tag: \"When\",\n  guard,\n  evaluate\n})\n\nconst makeNot = (\n  guard: (u: unknown) => boolean,\n  evaluate: (input: unknown) => any\n): Not => ({\n  _tag: \"Not\",\n  guard,\n  evaluate\n})\n\nconst makePredicate = (pattern: unknown): Predicate.Predicate<unknown> => {\n  if (typeof pattern === \"function\") {\n    return pattern as Predicate.Predicate<unknown>\n  } else if (Array.isArray(pattern)) {\n    const predicates = pattern.map(makePredicate)\n    const len = predicates.length\n\n    return (u: unknown) => {\n      if (!Array.isArray(u)) {\n        return false\n      }\n\n      for (let i = 0; i < len; i++) {\n        if (predicates[i](u[i]) === false) {\n          return false\n        }\n      }\n\n      return true\n    }\n  } else if (pattern !== null && typeof pattern === \"object\") {\n    const keysAndPredicates = Object.entries(pattern).map(\n      ([k, p]) => [k, makePredicate(p)] as const\n    )\n    const len = keysAndPredicates.length\n\n    return (u: unknown) => {\n      if (typeof u !== \"object\" || u === null) {\n        return false\n      }\n\n      for (let i = 0; i < len; i++) {\n        const [key, predicate] = keysAndPredicates[i]\n        if (!(key in u) || predicate((u as any)[key]) === false) {\n          return false\n        }\n      }\n\n      return true\n    }\n  }\n\n  return (u: unknown) => u === pattern\n}\n\nconst makeOrPredicate = (\n  patterns: ReadonlyArray<unknown>\n): Predicate.Predicate<unknown> => {\n  const predicates = patterns.map(makePredicate)\n  const len = predicates.length\n\n  return (u: unknown) => {\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](u) === true) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nconst makeAndPredicate = (\n  patterns: ReadonlyArray<unknown>\n): Predicate.Predicate<unknown> => {\n  const predicates = patterns.map(makePredicate)\n  const len = predicates.length\n\n  return (u: unknown) => {\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](u) === false) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n/** @internal */\nexport const type = <I>(): Matcher<\n  I,\n  Types.Without<never>,\n  I,\n  never,\n  never\n> => makeTypeMatcher([])\n\n/** @internal */\nexport const value = <const I>(\n  i: I\n): Matcher<I, Types.Without<never>, I, never, I> => makeValueMatcher(i, Either.left(i))\n\n/** @internal */\nexport const valueTags: {\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P): (input: I) => Unify<ReturnType<P[keyof P]>>\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(input: I, fields: P): Unify<ReturnType<P[keyof P]>>\n} = dual(\n  2,\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(input: I, fields: P): Unify<ReturnType<P[keyof P]>> => {\n    const match: any = tagsExhaustive(fields as any)(makeTypeMatcher([]))\n    return match(input)\n  }\n)\n\n/** @internal */\nexport const typeTags = <I>() =>\n<\n  P extends {\n    readonly [Tag in Types.Tags<\"_tag\", I> & string]: (\n      _: Extract<I, { readonly _tag: Tag }>\n    ) => any\n  }\n>(\n  fields: P\n) => {\n  const match: any = tagsExhaustive(fields as any)(makeTypeMatcher([]))\n  return (input: I): Unify<ReturnType<P[keyof P]>> => match(input)\n}\n\n/** @internal */\nexport const withReturnType = <Ret>() =>\n<I, F, R, A, Pr, _>(self: Matcher<I, F, R, A, Pr, _>): [Ret] extends [\n  [A] extends [never] ? any : A\n] ? Matcher<I, F, R, A, Pr, Ret>\n  : \"withReturnType constraint does not extend Result type\" => self as any\n\n/** @internal */\nexport const when = <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> => (self as any).add(makeWhen(makePredicate(pattern), f as any))\n\n/** @internal */\nexport const whenOr = <\n  R,\n  const P extends ReadonlyArray<\n    Types.PatternPrimitive<R> | Types.PatternBase<R>\n  >,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P[number]>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> => {\n  const onMatch = args[args.length - 1] as any\n  const patterns = args.slice(0, -1) as unknown as P\n  return (self as any).add(makeWhen(makeOrPredicate(patterns), onMatch))\n}\n\n/** @internal */\nexport const whenAnd = <\n  R,\n  const P extends ReadonlyArray<\n    Types.PatternPrimitive<R> | Types.PatternBase<R>\n  >,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, Types.ArrayToIntersection<P>>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<Types.ArrayToIntersection<P>>>,\n  Types.ApplyFilters<\n    I,\n    Types.AddWithout<F, Types.PForExclude<Types.ArrayToIntersection<P>>>\n  >,\n  A | ReturnType<Fn>,\n  Pr\n> => {\n  const onMatch = args[args.length - 1] as any\n  const patterns = args.slice(0, -1) as unknown as P\n  return (self as any).add(makeWhen(makeAndPredicate(patterns), onMatch))\n}\n\n/** @internal */\nexport const discriminator = <D extends string>(field: D) =>\n<\n  R,\n  P extends Types.Tags<D, R> & string,\n  Ret,\n  Fn extends (_: Extract<R, Record<D, P>>) => Ret\n>(\n  ...pattern: [\n    first: P,\n    ...values: Array<P>,\n    f: Fn\n  ]\n) => {\n  const f = pattern[pattern.length - 1]\n  const values: Array<P> = pattern.slice(0, -1) as any\n  const pred = values.length === 1\n    ? (_: any) => _[field] === values[0]\n    : (_: any) => values.includes(_[field])\n\n  return <I, F, A, Pr>(\n    self: Matcher<I, F, R, A, Pr, Ret>\n  ): Matcher<\n    I,\n    Types.AddWithout<F, Extract<R, Record<D, P>>>,\n    Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>,\n    A | ReturnType<Fn>,\n    Pr,\n    Ret\n  > => (self as any).add(makeWhen(pred, f as any)) as any\n}\n\n/** @internal */\nexport const discriminatorStartsWith = <D extends string>(field: D) =>\n<\n  R,\n  P extends string,\n  Ret,\n  Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => {\n  const pred = (_: any) => typeof _[field] === \"string\" && _[field].startsWith(pattern)\n\n  return <I, F, A, Pr>(\n    self: Matcher<I, F, R, A, Pr, Ret>\n  ): Matcher<\n    I,\n    Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>,\n    Types.ApplyFilters<\n      I,\n      Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>\n    >,\n    A | ReturnType<Fn>,\n    Pr,\n    Ret\n  > => (self as any).add(makeWhen(pred, f as any)) as any\n}\n\n/** @internal */\nexport const discriminators = <D extends string>(field: D) =>\n<\n  R,\n  Ret,\n  P extends\n    & {\n      readonly [Tag in Types.Tags<D, R> & string]?:\n        | ((_: Extract<R, Record<D, Tag>>) => Ret)\n        | undefined\n    }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => {\n  const predicate = makeWhen(\n    (arg: any) => arg != null && arg[field] in fields,\n    (data: any) => (fields as any)[data[field]](data)\n  )\n\n  return <I, F, A, Pr>(\n    self: Matcher<I, F, R, A, Pr, Ret>\n  ): Matcher<\n    I,\n    Types.AddWithout<F, Extract<R, Record<D, keyof P>>>,\n    Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>,\n    A | ReturnType<P[keyof P] & {}>,\n    Pr,\n    Ret\n  > => (self as any).add(predicate)\n}\n\n/** @internal */\nexport const discriminatorsExhaustive: <D extends string>(\n  field: D\n) => <\n  R,\n  Ret,\n  P extends\n    & {\n      readonly [Tag in Types.Tags<D, R> & string]: (\n        _: Extract<R, Record<D, Tag>>\n      ) => Ret\n    }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>>\n  : Unify<A | ReturnType<P[keyof P]>> = (field: string) => (fields: object) => {\n    const addCases = discriminators(field)(fields)\n    return (matcher: any) => exhaustive(addCases(matcher))\n  }\n\n/** @internal */\nexport const tag: <\n  R,\n  P extends Types.Tags<\"_tag\", R> & string,\n  Ret,\n  Fn extends (_: Extract<R, Record<\"_tag\", P>>) => Ret\n>(\n  ...pattern: [\n    first: P,\n    ...values: Array<P>,\n    f: Fn\n  ]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>,\n  ReturnType<Fn> | A,\n  Pr,\n  Ret\n> = discriminator(\"_tag\")\n\n/** @internal */\nexport const tagStartsWith = discriminatorStartsWith(\"_tag\")\n\n/** @internal */\nexport const tags = discriminators(\"_tag\")\n\n/** @internal */\nexport const tagsExhaustive = discriminatorsExhaustive(\"_tag\")\n\n/** @internal */\nexport const not = <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.NotMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddOnly<F, Types.WhenMatch<R, P>>,\n  Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> => (self as any).add(makeNot(makePredicate(pattern), f as any))\n\n/** @internal */\nexport const nonEmptyString: SafeRefinement<string, never> =\n  ((u: unknown) => typeof u === \"string\" && u.length > 0) as any\n\n/** @internal */\nexport const is: <\n  Literals extends ReadonlyArray<string | number | boolean | null | bigint>\n>(\n  ...literals: Literals\n) => SafeRefinement<Literals[number]> = (...literals): any => {\n  const len = literals.length\n  return (u: unknown) => {\n    for (let i = 0; i < len; i++) {\n      if (u === literals[i]) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\n/** @internal */\nexport const any: SafeRefinement<unknown, any> = (() => true) as any\n\n/** @internal */\nexport const defined = <A>(u: A): u is A & {} => (u !== undefined && u !== null) as any\n\n/** @internal */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A\n): SafeRefinement<InstanceType<A>, never> => ((u: unknown) => u instanceof constructor) as any\n\n/** @internal */\nexport const instanceOfUnsafe: <A extends abstract new(...args: any) => any>(\n  constructor: A\n) => SafeRefinement<InstanceType<A>, InstanceType<A>> = instanceOf\n\n/** @internal */\nexport const orElse =\n  <RA, Ret, F extends (_: RA) => Ret>(f: F) =>\n  <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>): [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A>\n    : Unify<ReturnType<F> | A> =>\n  {\n    const result = either(self)\n\n    if (Either.isEither(result)) {\n      // @ts-expect-error\n      return result._tag === \"Right\" ? result.right : f(result.left)\n    }\n\n    // @ts-expect-error\n    return (input: I) => {\n      const a = result(input)\n      return a._tag === \"Right\" ? a.right : f(a.left)\n    }\n  }\n\n/** @internal */\nexport const orElseAbsurd = <I, R, RA, A, Pr, Ret>(\n  self: Matcher<I, R, RA, A, Pr, Ret>\n): [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A> =>\n  orElse(() => {\n    throw new Error(\"effect/Match/orElseAbsurd: absurd\")\n  })(self)\n\n/** @internal */\nexport const either: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R>\n  : Either.Either<Unify<A>, R> = (<I, R, RA, A>(self: Matcher<I, R, RA, A, I>) => {\n    if (self._tag === \"ValueMatcher\") {\n      return self.value\n    }\n\n    const len = self.cases.length\n    if (len === 1) {\n      const _case = self.cases[0]\n      return (input: I): Either.Either<A, RA> => {\n        if (_case._tag === \"When\" && _case.guard(input) === true) {\n          return Either.right(_case.evaluate(input))\n        } else if (_case._tag === \"Not\" && _case.guard(input) === false) {\n          return Either.right(_case.evaluate(input))\n        }\n        return Either.left(input as any)\n      }\n    }\n    return (input: I): Either.Either<A, RA> => {\n      for (let i = 0; i < len; i++) {\n        const _case = self.cases[i]\n        if (_case._tag === \"When\" && _case.guard(input) === true) {\n          return Either.right(_case.evaluate(input))\n        } else if (_case._tag === \"Not\" && _case.guard(input) === false) {\n          return Either.right(_case.evaluate(input))\n        }\n      }\n\n      return Either.left(input as any)\n    }\n  }) as any\n\n/** @internal */\nexport const option: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>>\n  : Option.Option<Unify<A>> = (<I, A>(self: Matcher<I, any, any, A, I>) => {\n    const toEither = either(self)\n    if (Either.isEither(toEither)) {\n      return Either.match(toEither, {\n        onLeft: () => Option.none(),\n        onRight: Option.some\n      })\n    }\n    return (input: I): Option.Option<A> =>\n      Either.match((toEither as any)(input), {\n        onLeft: () => Option.none(),\n        onRight: Option.some as any\n      })\n  }) as any\n\nconst getExhaustiveAbsurdErrorMessage = \"effect/Match/exhaustive: absurd\"\n\n/** @internal */\nexport const exhaustive: <I, F, A, Pr, Ret>(\n  self: Matcher<I, F, never, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A> = (<I, F, A>(\n  self: Matcher<I, F, never, A, I>\n) => {\n  const toEither = either(self as any)\n\n  if (Either.isEither(toEither)) {\n    if (toEither._tag === \"Right\") {\n      return toEither.right\n    }\n\n    throw new Error(getExhaustiveAbsurdErrorMessage)\n  }\n\n  return (u: I): A => {\n    // @ts-expect-error\n    const result = toEither(u)\n\n    if (result._tag === \"Right\") {\n      return result.right as any\n    }\n\n    throw new Error(getExhaustiveAbsurdErrorMessage)\n  }\n}) as any\n","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { GlobalStyles as MuiGlobalStyles, internal_serializeStyles as serializeStyles } from '@mui/styled-engine';\nimport useTheme from \"../useTheme/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction wrapGlobalLayer(styles) {\n  const serialized = serializeStyles(styles);\n  if (styles !== serialized && serialized.styles) {\n    if (!serialized.styles.match(/^@layer\\s+[^{]*$/)) {\n      // If the styles are not already wrapped in a layer, wrap them in a global layer.\n      serialized.styles = `@layer global{${serialized.styles}}`;\n    }\n    return serialized;\n  }\n  return styles;\n}\nfunction GlobalStyles({\n  styles,\n  themeId,\n  defaultTheme = {}\n}) {\n  const upperTheme = useTheme(defaultTheme);\n  const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;\n  let globalStyles = typeof styles === 'function' ? styles(resolvedTheme) : styles;\n  if (resolvedTheme.modularCssLayers) {\n    if (Array.isArray(globalStyles)) {\n      globalStyles = globalStyles.map(styleArg => {\n        if (typeof styleArg === 'function') {\n          return wrapGlobalLayer(styleArg(resolvedTheme));\n        }\n        return wrapGlobalLayer(styleArg);\n      });\n    } else {\n      globalStyles = wrapGlobalLayer(globalStyles);\n    }\n  }\n  return /*#__PURE__*/_jsx(MuiGlobalStyles, {\n    styles: globalStyles\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? GlobalStyles.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * @ignore\n   */\n  defaultTheme: PropTypes.object,\n  /**\n   * @ignore\n   */\n  styles: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.array, PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.bool]),\n  /**\n   * @ignore\n   */\n  themeId: PropTypes.string\n} : void 0;\nexport default GlobalStyles;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Global } from '@emotion/react';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction isEmpty(obj) {\n  return obj === undefined || obj === null || Object.keys(obj).length === 0;\n}\nexport default function GlobalStyles(props) {\n  const {\n    styles,\n    defaultTheme = {}\n  } = props;\n  const globalStyles = typeof styles === 'function' ? themeInput => styles(isEmpty(themeInput) ? defaultTheme : themeInput) : styles;\n  return /*#__PURE__*/_jsx(Global, {\n    styles: globalStyles\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? GlobalStyles.propTypes = {\n  defaultTheme: PropTypes.object,\n  styles: PropTypes.oneOfType([PropTypes.array, PropTypes.string, PropTypes.object, PropTypes.func])\n} : void 0;","'use client';\n\nimport * as React from 'react';\nimport { useTheme as useThemeSystem } from '@mui/system';\nimport defaultTheme from \"./defaultTheme.js\";\nimport THEME_ID from \"./identifier.js\";\nexport default function useTheme() {\n  const theme = useThemeSystem(defaultTheme);\n  if (process.env.NODE_ENV !== 'production') {\n    // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useDebugValue(theme);\n  }\n  return theme[THEME_ID] || theme;\n}","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { GlobalStyles as SystemGlobalStyles } from '@mui/system';\nimport defaultTheme from \"../styles/defaultTheme.js\";\nimport THEME_ID from \"../styles/identifier.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction GlobalStyles(props) {\n  return /*#__PURE__*/_jsx(SystemGlobalStyles, {\n    ...props,\n    defaultTheme: defaultTheme,\n    themeId: THEME_ID\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? GlobalStyles.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * The styles you want to apply globally.\n   */\n  styles: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.array, PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.bool])\n} : void 0;\nexport default GlobalStyles;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { styled, internal_createExtendSxProp } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport { getTypographyUtilityClass } from \"./typographyClasses.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst v6Colors = {\n  primary: true,\n  secondary: true,\n  error: true,\n  info: true,\n  success: true,\n  warning: true,\n  textPrimary: true,\n  textSecondary: true,\n  textDisabled: true\n};\nconst extendSxProp = internal_createExtendSxProp();\nconst useUtilityClasses = ownerState => {\n  const {\n    align,\n    gutterBottom,\n    noWrap,\n    paragraph,\n    variant,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', variant, ownerState.align !== 'inherit' && `align${capitalize(align)}`, gutterBottom && 'gutterBottom', noWrap && 'noWrap', paragraph && 'paragraph']\n  };\n  return composeClasses(slots, getTypographyUtilityClass, classes);\n};\nexport const TypographyRoot = styled('span', {\n  name: 'MuiTypography',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.variant && styles[ownerState.variant], ownerState.align !== 'inherit' && styles[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles.noWrap, ownerState.gutterBottom && styles.gutterBottom, ownerState.paragraph && styles.paragraph];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  margin: 0,\n  variants: [{\n    props: {\n      variant: 'inherit'\n    },\n    style: {\n      // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.\n      font: 'inherit',\n      lineHeight: 'inherit',\n      letterSpacing: 'inherit'\n    }\n  }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== 'inherit' && value && typeof value === 'object').map(([variant, value]) => ({\n    props: {\n      variant\n    },\n    style: value\n  })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      color: (theme.vars || theme).palette[color].main\n    }\n  })), ...Object.entries(theme.palette?.text || {}).filter(([, value]) => typeof value === 'string').map(([color]) => ({\n    props: {\n      color: `text${capitalize(color)}`\n    },\n    style: {\n      color: (theme.vars || theme).palette.text[color]\n    }\n  })), {\n    props: ({\n      ownerState\n    }) => ownerState.align !== 'inherit',\n    style: {\n      textAlign: 'var(--Typography-textAlign)'\n    }\n  }, {\n    props: ({\n      ownerState\n    }) => ownerState.noWrap,\n    style: {\n      overflow: 'hidden',\n      textOverflow: 'ellipsis',\n      whiteSpace: 'nowrap'\n    }\n  }, {\n    props: ({\n      ownerState\n    }) => ownerState.gutterBottom,\n    style: {\n      marginBottom: '0.35em'\n    }\n  }, {\n    props: ({\n      ownerState\n    }) => ownerState.paragraph,\n    style: {\n      marginBottom: 16\n    }\n  }]\n})));\nconst defaultVariantMapping = {\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  subtitle1: 'h6',\n  subtitle2: 'h6',\n  body1: 'p',\n  body2: 'p',\n  inherit: 'p'\n};\nconst Typography = /*#__PURE__*/React.forwardRef(function Typography(inProps, ref) {\n  const {\n    color,\n    ...themeProps\n  } = useDefaultProps({\n    props: inProps,\n    name: 'MuiTypography'\n  });\n  const isSxColor = !v6Colors[color];\n  // TODO: Remove `extendSxProp` in v7\n  const props = extendSxProp({\n    ...themeProps,\n    ...(isSxColor && {\n      color\n    })\n  });\n  const {\n    align = 'inherit',\n    className,\n    component,\n    gutterBottom = false,\n    noWrap = false,\n    paragraph = false,\n    variant = 'body1',\n    variantMapping = defaultVariantMapping,\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    align,\n    color,\n    className,\n    component,\n    gutterBottom,\n    noWrap,\n    paragraph,\n    variant,\n    variantMapping\n  };\n  const Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(TypographyRoot, {\n    as: Component,\n    ref: ref,\n    className: clsx(classes.root, className),\n    ...other,\n    ownerState: ownerState,\n    style: {\n      ...(align !== 'inherit' && {\n        '--Typography-textAlign': align\n      }),\n      ...other.style\n    }\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? Typography.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * Set the text-align on the component.\n   * @default 'inherit'\n   */\n  align: PropTypes.oneOf(['center', 'inherit', 'justify', 'left', 'right']),\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['primary', 'secondary', 'success', 'error', 'info', 'warning', 'textPrimary', 'textSecondary', 'textDisabled']), PropTypes.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * If `true`, the text will have a bottom margin.\n   * @default false\n   */\n  gutterBottom: PropTypes.bool,\n  /**\n   * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.\n   *\n   * Note that text overflow can only happen with block or inline-block level elements\n   * (the element needs to have a width in order to overflow).\n   * @default false\n   */\n  noWrap: PropTypes.bool,\n  /**\n   * If `true`, the element will be a paragraph element.\n   * @default false\n   * @deprecated Use the `component` prop instead. This prop will be removed in a future major release. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.\n   */\n  paragraph: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  style: PropTypes.object,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * Applies the theme typography styles.\n   * @default 'body1'\n   */\n  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['body1', 'body2', 'button', 'caption', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'inherit', 'overline', 'subtitle1', 'subtitle2']), PropTypes.string]),\n  /**\n   * The component maps the variant prop to a range of different HTML element types.\n   * For instance, subtitle1 to `<h6>`.\n   * If you wish to change that mapping, you can provide your own.\n   * Alternatively, you can use the `component` prop.\n   * @default {\n   *   h1: 'h1',\n   *   h2: 'h2',\n   *   h3: 'h3',\n   *   h4: 'h4',\n   *   h5: 'h5',\n   *   h6: 'h6',\n   *   subtitle1: 'h6',\n   *   subtitle2: 'h6',\n   *   body1: 'p',\n   *   body2: 'p',\n   *   inherit: 'p',\n   * }\n   */\n  variantMapping: PropTypes /* @typescript-to-proptypes-ignore */.object\n} : void 0;\nexport default Typography;","import * as React from 'react';\nimport { extendSxProp } from '@mui/system/styleFunctionSx';\nimport useTheme from \"../styles/useTheme.js\";\nimport GlobalStyles from \"../GlobalStyles/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport { css, keyframes } from '@mui/system';\nexport { default as styled } from \"../styles/styled.js\";\nexport function globalCss(styles) {\n  return function GlobalStylesWrapper(props) {\n    return (\n      /*#__PURE__*/\n      // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.\n      _jsx(GlobalStyles, {\n        styles: typeof styles === 'function' ? theme => styles({\n          theme,\n          ...props\n        }) : styles\n      })\n    );\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function internal_createExtendSxProp() {\n  return extendSxProp;\n}\nexport { useTheme };","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getTypographyUtilityClass(slot) {\n  return generateUtilityClass('MuiTypography', slot);\n}\nconst typographyClasses = generateUtilityClasses('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph']);\nexport default typographyClasses;"],"names":["Equivalence","dual","order","Predicate","pick","args","isObject","s","keys","out","k","omit","getEquivalence","struct","getOrder","evolve","obj","t","Object","prototype","hasOwnProperty","call","get","key","o","entries","identity","Option","pipeArguments","TypeId","Symbol","for","TypeMatcherProto","MatcherTypeId","internal","_input","_filters","_remaining","_result","_return","_tag","add","_case","makeTypeMatcher","cases","pipe","arguments","matcher","create","ValueMatcherProto","_provided","value","guard","provided","makeValueMatcher","Either","right","evaluate","type","makeWhen","makeNot","makePredicate","pattern","Array","isArray","predicates","map","len","length","u","i","keysAndPredicates","p","valueTags","predicate","typeTags","makeOrPredicate","patterns","makeAndPredicate","withReturnType","left","input","fields","match","tagsExhaustive","self","when","f","whenOr","onMatch","slice","whenAnd","discriminator","field","values","pred","_","includes","discriminatorStartsWith","startsWith","discriminators","arg","data","discriminatorsExhaustive","addCases","exhaustive","tag","tagStartsWith","tags","not","nonEmptyString","is","literals","any","defined","undefined","instanceOf","constructor","instanceOfUnsafe","orElse","result","either","isEither","a","orElseAbsurd","Error","option","toEither","onLeft","none","onRight","some","getExhaustiveAbsurdErrorMessage","string","isString","number","isNumber","boolean","isBoolean","_undefined","isUndefined","_null","isNull","bigint","isBigInt","symbol","isSymbol","date","isDate","record","isRecord","SafeRefinementId","Fail"],"mappings":"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","ignoreList":[0,1,2,3,4,5,7,8,9,10,11,12,13,14,15]}