{"version":3,"sources":["turbopack:///[project]/packages/iam/sdk/src/errors.ts","turbopack:///[project]/node_modules/@better-auth/stripe/dist/client.mjs","turbopack:///[project]/node_modules/@better-fetch/fetch/dist/index.js","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.CiuwFiHM.mjs","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.DdzSJf-n.mjs","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.DaEBQJp_.mjs","turbopack:///[project]/packages/iam/sdk/src/contractkit/IamError.ts","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.Ddw8bVyV.mjs","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.BpA03GIs.mjs","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.msGOU0m9.mjs","turbopack:///[project]/packages/iam/sdk/src/adapters/better-auth/client.ts","turbopack:///[project]/packages/iam/sdk/src/clients/sign-in/sign-in.contracts.ts","turbopack:///[project]/node_modules/nanostores/listen-keys/index.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js","turbopack:///[project]/packages/iam/sdk/src/clients/organization/organization.contracts.ts","turbopack:///[project]/node_modules/better-auth/dist/plugins/access/index.mjs","turbopack:///[project]/node_modules/nanostores/atom/index.js","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.bkwPl2G4.mjs","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.BYWGbmZ5.mjs","turbopack:///[project]/node_modules/better-auth/dist/client/react/index.mjs","turbopack:///[project]/packages/iam/sdk/src/clients/recover/recover.contracts.ts","turbopack:///[project]/packages/iam/sdk/src/adapters/better-auth/errors.ts","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.BRFtaovt.mjs","turbopack:///[project]/packages/iam/sdk/src/clients/sign-up/sign-up.contracts.ts","turbopack:///[project]/node_modules/better-auth/dist/plugins/admin/access/index.mjs","turbopack:///[project]/node_modules/better-auth/dist/plugins/organization/access/index.mjs","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js","turbopack:///[project]/packages/iam/sdk/src/clients/oauth/oauth.contracts.ts","turbopack:///[project]/packages/iam/sdk/src/clients/sign-out/sign-out.contracts.ts","turbopack:///[project]/packages/iam/sdk/src/clients/two-factor/two-factor.contracts.ts","turbopack:///[project]/packages/iam/sdk/src/clients/verify/verify.contracts.ts","turbopack:///[project]/node_modules/better-auth/dist/shared/better-auth.DLt6eN7D.mjs","turbopack:///[project]/packages/iam/sdk/src/clients/organization/organization.implementations.ts","turbopack:///[project]/packages/iam/sdk/src/clients/sign-out/sign-out.implementations.ts","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js","turbopack:///[project]/packages/iam/sdk/src/clients/oauth/oauth.implementations.ts","turbopack:///[project]/packages/iam/sdk/src/clients/two-factor/two-factor.implementations.ts","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/platformAuthenticatorIsAvailable.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js","turbopack:///[project]/packages/iam/sdk/src/clients/sign-up/sign-up.implementations.ts","turbopack:///[project]/packages/iam/sdk/src/clients/verify/verify.implementations.ts","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js","turbopack:///[project]/packages/iam/sdk/src/clients/recover/recover.implementations.ts","turbopack:///[project]/packages/iam/sdk/src/clients/sign-in/sign-in.implementations.ts","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js","turbopack:///[project]/node_modules/better-auth/dist/client/plugins/index.mjs","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js","turbopack:///[project]/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js","turbopack:///[project]/packages/iam/sdk/src/contractkit/failure-continuation.ts","turbopack:///[project]/packages/iam/sdk/src/contractkit/Contract.ts","turbopack:///[project]/packages/iam/sdk/src/contractkit/ContractSet.ts","turbopack:///[project]/packages/iam/sdk/src/index.ts","turbopack:///[project]/packages/iam/sdk/src/constants/AuthCallback/AuthCallback.ts"],"sourcesContent":["import { BeepError } from \"@beep/errors/client\";\nimport * as Data from \"effect/Data\";\nimport * as P from \"effect/Predicate\";\nimport { BetterAuthError } from \"./adapters\";\n\nexport interface IamErrorMetadata {\n  readonly code?: string;\n  readonly status?: number;\n  readonly statusText?: string;\n  readonly plugin?: string;\n  readonly method?: string;\n  readonly authCause?: unknown;\n}\n\nexport class IamError extends Data.TaggedError(\"IamError\")<{\n  readonly customMessage: string;\n  readonly cause: unknown;\n  readonly code?: string;\n  readonly status?: number;\n  readonly statusText?: string;\n  readonly plugin?: string;\n  readonly method?: string;\n  readonly authCause?: unknown;\n}> {\n  readonly code?: string;\n  readonly status?: number;\n  readonly statusText?: string;\n  readonly plugin?: string;\n  readonly method?: string;\n  readonly authCause?: unknown;\n\n  constructor(\n    readonly cause: unknown,\n    readonly customMessage: string,\n    readonly metadata: IamErrorMetadata = {}\n  ) {\n    const normalizedMessage = customMessage ?? \"Unknown Error has occurred\";\n    super({\n      customMessage: normalizedMessage,\n      cause,\n      ...metadata,\n    });\n\n    this.code = metadata.code;\n    this.status = metadata.status;\n    this.statusText = metadata.statusText;\n    this.plugin = metadata.plugin;\n    this.method = metadata.method;\n    this.authCause = metadata.authCause;\n  }\n\n  static readonly match = (error: unknown, metadata: IamErrorMetadata = {}) => {\n    if (error instanceof BetterAuthError) {\n      return new IamError(error.cause, error.message, metadata);\n    }\n\n    const customMessage =\n      P.hasProperty(\"message\")(error) && P.isString(error.message) ? error.message : \"Unknown Error has occurred\";\n    const cause = new BeepError.UnknownError({\n      cause: error,\n      customMessage,\n    });\n\n    return new IamError(cause, customMessage, metadata);\n  };\n\n  get message() {\n    return this.customMessage ?? \"Unknown Error has occurred\";\n  }\n}\n","const stripeClient = (options) => {\n  return {\n    id: \"stripe-client\",\n    $InferServerPlugin: {},\n    pathMethods: {\n      \"/subscription/restore\": \"POST\",\n      \"/subscription/billing-portal\": \"POST\"\n    }\n  };\n};\n\nexport { stripeClient };\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/error.ts\nvar BetterFetchError = class extends Error {\n  constructor(status, statusText, error) {\n    super(statusText || status.toString(), {\n      cause: error\n    });\n    this.status = status;\n    this.statusText = statusText;\n    this.error = error;\n  }\n};\n\n// src/plugins.ts\nvar initializePlugins = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f;\n  let opts = options || {};\n  const hooks = {\n    onRequest: [options == null ? void 0 : options.onRequest],\n    onResponse: [options == null ? void 0 : options.onResponse],\n    onSuccess: [options == null ? void 0 : options.onSuccess],\n    onError: [options == null ? void 0 : options.onError],\n    onRetry: [options == null ? void 0 : options.onRetry]\n  };\n  if (!options || !(options == null ? void 0 : options.plugins)) {\n    return {\n      url,\n      options: opts,\n      hooks\n    };\n  }\n  for (const plugin of (options == null ? void 0 : options.plugins) || []) {\n    if (plugin.init) {\n      const pluginRes = await ((_a = plugin.init) == null ? void 0 : _a.call(plugin, url.toString(), options));\n      opts = pluginRes.options || opts;\n      url = pluginRes.url;\n    }\n    hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);\n    hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);\n    hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);\n    hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);\n    hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);\n  }\n  return {\n    url,\n    options: opts,\n    hooks\n  };\n};\n\n// src/retry.ts\nvar LinearRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay() {\n    return this.options.delay;\n  }\n};\nvar ExponentialRetryStrategy = class {\n  constructor(options) {\n    this.options = options;\n  }\n  shouldAttemptRetry(attempt, response) {\n    if (this.options.shouldRetry) {\n      return Promise.resolve(\n        attempt < this.options.attempts && this.options.shouldRetry(response)\n      );\n    }\n    return Promise.resolve(attempt < this.options.attempts);\n  }\n  getDelay(attempt) {\n    const delay = Math.min(\n      this.options.maxDelay,\n      this.options.baseDelay * 2 ** attempt\n    );\n    return delay;\n  }\n};\nfunction createRetryStrategy(options) {\n  if (typeof options === \"number\") {\n    return new LinearRetryStrategy({\n      type: \"linear\",\n      attempts: options,\n      delay: 1e3\n    });\n  }\n  switch (options.type) {\n    case \"linear\":\n      return new LinearRetryStrategy(options);\n    case \"exponential\":\n      return new ExponentialRetryStrategy(options);\n    default:\n      throw new Error(\"Invalid retry strategy\");\n  }\n}\n\n// src/auth.ts\nvar getAuthHeader = async (options) => {\n  const headers = {};\n  const getValue = async (value) => typeof value === \"function\" ? await value() : value;\n  if (options == null ? void 0 : options.auth) {\n    if (options.auth.type === \"Bearer\") {\n      const token = await getValue(options.auth.token);\n      if (!token) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Bearer ${token}`;\n    } else if (options.auth.type === \"Basic\") {\n      const username = getValue(options.auth.username);\n      const password = getValue(options.auth.password);\n      if (!username || !password) {\n        return headers;\n      }\n      headers[\"authorization\"] = `Basic ${btoa(`${username}:${password}`)}`;\n    } else if (options.auth.type === \"Custom\") {\n      const value = getValue(options.auth.value);\n      if (!value) {\n        return headers;\n      }\n      headers[\"authorization\"] = `${getValue(options.auth.prefix)} ${value}`;\n    }\n  }\n  return headers;\n};\n\n// src/utils.ts\nvar JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(request) {\n  const _contentType = request.headers.get(\"content-type\");\n  const textTypes = /* @__PURE__ */ new Set([\n    \"image/svg\",\n    \"application/xml\",\n    \"application/xhtml\",\n    \"application/html\"\n  ]);\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction isJSONParsable(value) {\n  try {\n    JSON.parse(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction jsonParse(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return text;\n  }\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction getFetch(options) {\n  if (options == null ? void 0 : options.customFetchImpl) {\n    return options.customFetchImpl;\n  }\n  if (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n    return globalThis.fetch;\n  }\n  if (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n    return window.fetch;\n  }\n  throw new Error(\"No fetch implementation found\");\n}\nfunction isPayloadMethod(method) {\n  if (!method) {\n    return false;\n  }\n  const payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  return payloadMethod.includes(method.toUpperCase());\n}\nfunction isRouteMethod(method) {\n  const routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n  if (!method) {\n    return false;\n  }\n  return routeMethod.includes(method.toUpperCase());\n}\nasync function getHeaders(opts) {\n  const headers = new Headers(opts == null ? void 0 : opts.headers);\n  const authHeader = await getAuthHeader(opts);\n  for (const [key, value] of Object.entries(authHeader || {})) {\n    headers.set(key, value);\n  }\n  if (!headers.has(\"content-type\")) {\n    const t = detectContentType(opts == null ? void 0 : opts.body);\n    if (t) {\n      headers.set(\"content-type\", t);\n    }\n  }\n  return headers;\n}\nfunction getURL(url, options) {\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  let _url;\n  try {\n    if (url.startsWith(\"http\")) {\n      _url = url;\n    } else {\n      let baseURL = options == null ? void 0 : options.baseURL;\n      if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith(\"/\"))) {\n        baseURL = baseURL + \"/\";\n      }\n      if (url.startsWith(\"/\")) {\n        _url = new URL(url.substring(1), baseURL);\n      } else {\n        _url = new URL(url, options == null ? void 0 : options.baseURL);\n      }\n    }\n  } catch (e) {\n    if (e instanceof TypeError) {\n      if (!(options == null ? void 0 : options.baseURL)) {\n        throw TypeError(\n          `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`\n        );\n      }\n      throw TypeError(\n        `Invalid URL ${url}. Please validate that you are passing the correct input.`\n      );\n    }\n    throw e;\n  }\n  if (options == null ? void 0 : options.params) {\n    if (Array.isArray(options == null ? void 0 : options.params)) {\n      const params = (options == null ? void 0 : options.params) ? Array.isArray(options.params) ? `/${options.params.join(\"/\")}` : `/${Object.values(options.params).join(\"/\")}` : \"\";\n      _url = _url.toString().split(\"/:\")[0];\n      _url = `${_url.toString()}${params}`;\n    } else {\n      for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {\n        _url = _url.toString().replace(`:${key}`, String(value));\n      }\n    }\n  }\n  const __url = new URL(_url);\n  const queryParams = options == null ? void 0 : options.query;\n  if (queryParams) {\n    for (const [key, value] of Object.entries(queryParams)) {\n      __url.searchParams.append(key, String(value));\n    }\n  }\n  return __url;\n}\nfunction detectContentType(body) {\n  if (isJSONSerializable(body)) {\n    return \"application/json\";\n  }\n  return null;\n}\nfunction getBody(options) {\n  if (!(options == null ? void 0 : options.body)) {\n    return null;\n  }\n  const headers = new Headers(options == null ? void 0 : options.headers);\n  if (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n    for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {\n      if (value instanceof Date) {\n        options.body[key] = value.toISOString();\n      }\n    }\n    return JSON.stringify(options.body);\n  }\n  return options.body;\n}\nfunction getMethod(url, options) {\n  var _a;\n  if (options == null ? void 0 : options.method) {\n    return options.method.toUpperCase();\n  }\n  if (url.startsWith(\"@\")) {\n    const pMethod = (_a = url.split(\"@\")[1]) == null ? void 0 : _a.split(\"/\")[0];\n    if (!methods.includes(pMethod)) {\n      return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n    }\n    return pMethod.toUpperCase();\n  }\n  return (options == null ? void 0 : options.body) ? \"POST\" : \"GET\";\n}\nfunction getTimeout(options, controller) {\n  let abortTimeout;\n  if (!(options == null ? void 0 : options.signal) && (options == null ? void 0 : options.timeout)) {\n    abortTimeout = setTimeout(() => controller == null ? void 0 : controller.abort(), options == null ? void 0 : options.timeout);\n  }\n  return {\n    abortTimeout,\n    clearTimeout: () => {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n  };\n}\nfunction bodyParser(data, responseType) {\n  if (responseType === \"json\") {\n    return JSON.parse(data);\n  }\n  return data;\n}\nvar ValidationError = class _ValidationError extends Error {\n  constructor(issues, message) {\n    super(message || JSON.stringify(issues, null, 2));\n    this.issues = issues;\n    Object.setPrototypeOf(this, _ValidationError.prototype);\n  }\n};\nasync function parseStandardSchema(schema, input) {\n  let result = await schema[\"~standard\"].validate(input);\n  if (result.issues) {\n    throw new ValidationError(result.issues);\n  }\n  return result.value;\n}\n\n// src/create-fetch/schema.ts\nvar methods = [\"get\", \"post\", \"put\", \"patch\", \"delete\"];\nvar createSchema = (schema, config) => {\n  return {\n    schema,\n    config\n  };\n};\n\n// src/create-fetch/index.ts\nvar applySchemaPlugin = (config) => ({\n  id: \"apply-schema\",\n  name: \"Apply Schema\",\n  version: \"1.0.0\",\n  async init(url, options) {\n    var _a, _b, _c, _d;\n    const schema = ((_b = (_a = config.plugins) == null ? void 0 : _a.find(\n      (plugin) => {\n        var _a2;\n        return ((_a2 = plugin.schema) == null ? void 0 : _a2.config) ? url.startsWith(plugin.schema.config.baseURL || \"\") || url.startsWith(plugin.schema.config.prefix || \"\") : false;\n      }\n    )) == null ? void 0 : _b.schema) || config.schema;\n    if (schema) {\n      let urlKey = url;\n      if ((_c = schema.config) == null ? void 0 : _c.prefix) {\n        if (urlKey.startsWith(schema.config.prefix)) {\n          urlKey = urlKey.replace(schema.config.prefix, \"\");\n          if (schema.config.baseURL) {\n            url = url.replace(schema.config.prefix, schema.config.baseURL);\n          }\n        }\n      }\n      if ((_d = schema.config) == null ? void 0 : _d.baseURL) {\n        if (urlKey.startsWith(schema.config.baseURL)) {\n          urlKey = urlKey.replace(schema.config.baseURL, \"\");\n        }\n      }\n      const keySchema = schema.schema[urlKey];\n      if (keySchema) {\n        let opts = __spreadProps(__spreadValues({}, options), {\n          method: keySchema.method,\n          output: keySchema.output\n        });\n        if (!(options == null ? void 0 : options.disableValidation)) {\n          opts = __spreadProps(__spreadValues({}, opts), {\n            body: keySchema.input ? await parseStandardSchema(keySchema.input, options == null ? void 0 : options.body) : options == null ? void 0 : options.body,\n            params: keySchema.params ? await parseStandardSchema(keySchema.params, options == null ? void 0 : options.params) : options == null ? void 0 : options.params,\n            query: keySchema.query ? await parseStandardSchema(keySchema.query, options == null ? void 0 : options.query) : options == null ? void 0 : options.query\n          });\n        }\n        return {\n          url,\n          options: opts\n        };\n      }\n    }\n    return {\n      url,\n      options\n    };\n  }\n});\nvar createFetch = (config) => {\n  async function $fetch(url, options) {\n    const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {\n      plugins: [...(config == null ? void 0 : config.plugins) || [], applySchemaPlugin(config || {})]\n    });\n    if (config == null ? void 0 : config.catchAllError) {\n      try {\n        return await betterFetch(url, opts);\n      } catch (error) {\n        return {\n          data: null,\n          error: {\n            status: 500,\n            statusText: \"Fetch Error\",\n            message: \"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n            error\n          }\n        };\n      }\n    }\n    return await betterFetch(url, opts);\n  }\n  return $fetch;\n};\n\n// src/url.ts\nfunction getURL2(url, option) {\n  let { baseURL, params, query } = option || {\n    query: {},\n    params: {},\n    baseURL: \"\"\n  };\n  let basePath = url.startsWith(\"http\") ? url.split(\"/\").slice(0, 3).join(\"/\") : baseURL || \"\";\n  if (url.startsWith(\"@\")) {\n    const m = url.toString().split(\"@\")[1].split(\"/\")[0];\n    if (methods.includes(m)) {\n      url = url.replace(`@${m}/`, \"/\");\n    }\n  }\n  if (!basePath.endsWith(\"/\")) basePath += \"/\";\n  let [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n  const queryParams = new URLSearchParams(urlQuery);\n  for (const [key, value] of Object.entries(query || {})) {\n    if (value == null) continue;\n    queryParams.set(key, String(value));\n  }\n  if (params) {\n    if (Array.isArray(params)) {\n      const paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n      for (const [index, key] of paramPaths.entries()) {\n        const value = params[index];\n        path = path.replace(key, value);\n      }\n    } else {\n      for (const [key, value] of Object.entries(params)) {\n        path = path.replace(`:${key}`, String(value));\n      }\n    }\n  }\n  path = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n  if (path.startsWith(\"/\")) path = path.slice(1);\n  let queryParamString = queryParams.toString();\n  queryParamString = queryParamString.length > 0 ? `?${queryParamString}`.replace(/\\+/g, \"%20\") : \"\";\n  if (!basePath.startsWith(\"http\")) {\n    return `${basePath}${path}${queryParamString}`;\n  }\n  const _url = new URL(`${path}${queryParamString}`, basePath);\n  return _url;\n}\n\n// src/fetch.ts\nvar betterFetch = async (url, options) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const {\n    hooks,\n    url: __url,\n    options: opts\n  } = await initializePlugins(url, options);\n  const fetch = getFetch(opts);\n  const controller = new AbortController();\n  const signal = (_a = opts.signal) != null ? _a : controller.signal;\n  const _url = getURL2(__url, opts);\n  const body = getBody(opts);\n  const headers = await getHeaders(opts);\n  const method = getMethod(__url, opts);\n  let context = __spreadProps(__spreadValues({}, opts), {\n    url: _url,\n    headers,\n    body,\n    method,\n    signal\n  });\n  for (const onRequest of hooks.onRequest) {\n    if (onRequest) {\n      const res = await onRequest(context);\n      if (res instanceof Object) {\n        context = res;\n      }\n    }\n  }\n  if (\"pipeTo\" in context && typeof context.pipeTo === \"function\" || typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) === \"function\") {\n    if (!(\"duplex\" in context)) {\n      context.duplex = \"half\";\n    }\n  }\n  const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);\n  let response = await fetch(context.url, context);\n  clearTimeout2();\n  const responseContext = {\n    response,\n    request: context\n  };\n  for (const onResponse of hooks.onResponse) {\n    if (onResponse) {\n      const r = await onResponse(__spreadProps(__spreadValues({}, responseContext), {\n        response: ((_c = options == null ? void 0 : options.hookOptions) == null ? void 0 : _c.cloneResponse) ? response.clone() : response\n      }));\n      if (r instanceof Response) {\n        response = r;\n      } else if (r instanceof Object) {\n        response = r.response;\n      }\n    }\n  }\n  if (response.ok) {\n    const hasBody = context.method !== \"HEAD\";\n    if (!hasBody) {\n      return {\n        data: \"\",\n        error: null\n      };\n    }\n    const responseType = detectResponseType(response);\n    const successContext = {\n      data: \"\",\n      response,\n      request: context\n    };\n    if (responseType === \"json\" || responseType === \"text\") {\n      const text = await response.text();\n      const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;\n      const data = await parser2(text);\n      successContext.data = data;\n    } else {\n      successContext.data = await response[responseType]();\n    }\n    if (context == null ? void 0 : context.output) {\n      if (context.output && !context.disableValidation) {\n        successContext.data = await parseStandardSchema(\n          context.output,\n          successContext.data\n        );\n      }\n    }\n    for (const onSuccess of hooks.onSuccess) {\n      if (onSuccess) {\n        await onSuccess(__spreadProps(__spreadValues({}, successContext), {\n          response: ((_e = options == null ? void 0 : options.hookOptions) == null ? void 0 : _e.cloneResponse) ? response.clone() : response\n        }));\n      }\n    }\n    if (options == null ? void 0 : options.throw) {\n      return successContext.data;\n    }\n    return {\n      data: successContext.data,\n      error: null\n    };\n  }\n  const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;\n  const responseText = await response.text();\n  const isJSONResponse = isJSONParsable(responseText);\n  const errorObject = isJSONResponse ? await parser(responseText) : null;\n  const errorContext = {\n    response,\n    responseText,\n    request: context,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n  for (const onError of hooks.onError) {\n    if (onError) {\n      await onError(__spreadProps(__spreadValues({}, errorContext), {\n        response: ((_g = options == null ? void 0 : options.hookOptions) == null ? void 0 : _g.cloneResponse) ? response.clone() : response\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.retry) {\n    const retryStrategy = createRetryStrategy(options.retry);\n    const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;\n    if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {\n      for (const onRetry of hooks.onRetry) {\n        if (onRetry) {\n          await onRetry(responseContext);\n        }\n      }\n      const delay = retryStrategy.getDelay(_retryAttempt);\n      await new Promise((resolve) => setTimeout(resolve, delay));\n      return await betterFetch(url, __spreadProps(__spreadValues({}, options), {\n        retryAttempt: _retryAttempt + 1\n      }));\n    }\n  }\n  if (options == null ? void 0 : options.throw) {\n    throw new BetterFetchError(\n      response.status,\n      response.statusText,\n      isJSONResponse ? errorObject : responseText\n    );\n  }\n  return {\n    data: null,\n    error: __spreadProps(__spreadValues({}, errorObject), {\n      status: response.status,\n      statusText: response.statusText\n    })\n  };\n};\nexport {\n  BetterFetchError,\n  ValidationError,\n  applySchemaPlugin,\n  betterFetch,\n  bodyParser,\n  createFetch,\n  createRetryStrategy,\n  createSchema,\n  detectContentType,\n  detectResponseType,\n  getBody,\n  getFetch,\n  getHeaders,\n  getMethod,\n  getTimeout,\n  getURL,\n  initializePlugins,\n  isFunction,\n  isJSONParsable,\n  isJSONSerializable,\n  isPayloadMethod,\n  isRouteMethod,\n  jsonParse,\n  methods,\n  parseStandardSchema\n};\n//# sourceMappingURL=index.js.map","const _envShim = /* @__PURE__ */ Object.create(null);\nconst _getEnv = (useShim) => globalThis.process?.env || //@ts-expect-error\nglobalThis.Deno?.env.toObject() || //@ts-expect-error\nglobalThis.__env__ || (useShim ? _envShim : globalThis);\nconst env = new Proxy(_envShim, {\n  get(_, prop) {\n    const env2 = _getEnv();\n    return env2[prop] ?? _envShim[prop];\n  },\n  has(_, prop) {\n    const env2 = _getEnv();\n    return prop in env2 || prop in _envShim;\n  },\n  set(_, prop, value) {\n    const env2 = _getEnv(true);\n    env2[prop] = value;\n    return true;\n  },\n  deleteProperty(_, prop) {\n    if (!prop) {\n      return false;\n    }\n    const env2 = _getEnv(true);\n    delete env2[prop];\n    return true;\n  },\n  ownKeys() {\n    const env2 = _getEnv(true);\n    return Object.keys(env2);\n  }\n});\nfunction toBoolean(val) {\n  return val ? val !== \"false\" : false;\n}\nconst nodeENV = typeof process !== \"undefined\" && process.env && process.env.NODE_ENV || \"\";\nconst isProduction = nodeENV === \"production\";\nconst isDevelopment = nodeENV === \"dev\" || nodeENV === \"development\";\nconst isTest = () => nodeENV === \"test\" || toBoolean(env.TEST);\nfunction getEnvVar(key, fallback) {\n  if (typeof process !== \"undefined\" && process.env) {\n    return process.env[key] ?? fallback;\n  }\n  if (typeof Deno !== \"undefined\") {\n    return Deno.env.get(key) ?? fallback;\n  }\n  if (typeof Bun !== \"undefined\") {\n    return Bun.env[key] ?? fallback;\n  }\n  return fallback;\n}\nfunction getBooleanEnvVar(key, fallback = true) {\n  const value = getEnvVar(key);\n  if (!value) return fallback;\n  return value !== \"0\" && value.toLowerCase() !== \"false\" && value !== \"\";\n}\nconst ENV = {\n  get BETTER_AUTH_TELEMETRY_ENDPOINT() {\n    return getEnvVar(\n      \"BETTER_AUTH_TELEMETRY_ENDPOINT\",\n      \"https://telemetry.better-auth.com/v1/track\"\n    );\n  }\n};\n\nexport { ENV as E, isDevelopment as a, isProduction as b, getBooleanEnvVar as c, env as e, getEnvVar as g, isTest as i };\n","class BetterAuthError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.name = \"BetterAuthError\";\n    this.message = message;\n    this.cause = cause;\n    this.stack = \"\";\n  }\n}\nclass MissingDependencyError extends BetterAuthError {\n  constructor(pkgName) {\n    super(\n      `The package \"${pkgName}\" is required. Make sure it is installed.`,\n      pkgName\n    );\n  }\n}\n\nexport { BetterAuthError as B, MissingDependencyError as M };\n","const hasPermissionFn = (input, acRoles) => {\n  if (!input.permissions && !input.permission) return false;\n  const roles = input.role.split(\",\");\n  const creatorRole = input.options.creatorRole || \"owner\";\n  const isCreator = roles.includes(creatorRole);\n  const allowCreatorsAllPermissions = input.allowCreatorAllPermissions || false;\n  if (isCreator && allowCreatorsAllPermissions) return true;\n  for (const role of roles) {\n    const _role = acRoles[role];\n    const result = _role?.authorize(input.permissions ?? input.permission);\n    if (result?.success) {\n      return true;\n    }\n  }\n  return false;\n};\nlet cacheAllRoles = /* @__PURE__ */ new Map();\n\nexport { cacheAllRoles as c, hasPermissionFn as h };\n","import { BS } from \"@beep/schema\";\nimport { HttpRequestDetails } from \"@beep/schema/http\";\nimport type { UnsafeTypes } from \"@beep/types\";\nimport type * as HttpClientError from \"@effect/platform/HttpClientError\";\nimport * as Effect from \"effect/Effect\";\nimport * as Inspectable from \"effect/Inspectable\";\nimport * as Match from \"effect/Match\";\nimport type { ParseError } from \"effect/ParseResult\";\nimport * as P from \"effect/Predicate\";\nimport * as S from \"effect/Schema\";\n\n/**\n * Unique identifier for IAM errors.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport const TypeId = Symbol.for(\"@beep/iam/IamError\");\n\n/**\n * Type-level representation of the IAM error identifier.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport type TypeId = typeof TypeId;\n\n/**\n * Type guard to check if a value is an IAM error.\n *\n * @param u - The value to check\n * @returns `true` if the value is an `IamError`, `false` otherwise\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n *\n * const someError = new Error(\"generic error\")\n * const iamError = new IamError.UnknownError({\n *   module: \"Test\",\n *   method: \"example\"\n * })\n *\n * console.log(IamError.isIamError(someError)) // false\n * console.log(IamError.isIamError(aiError))   // true\n * ```\n *\n * @since 1.0.0\n * @category Guards\n */\n// export const isIamError = (u: unknown): u is Iam\n\n// =====================================================================================================================\n// IamError Utils\n// =====================================================================================================================\n/**\n * Returns a suggestion for handling an HTTP response error based on the status code.\n *\n * @param statusCode - The HTTP status code\n * @returns A suggestion for handling the error\n */\nconst getStatusCodeSuggestion = (statusCode: number): string => {\n  if (statusCode >= 400 && statusCode < 500) {\n    return Match.value(statusCode).pipe(\n      Match.when(\n        400,\n        () => \"Bad Request - Check request parameters, headers, and body format against API documentation.\"\n      ),\n      Match.when(401, () => \"Unauthorized - Verify API key, authentication credentials, or token expiration.\"),\n      Match.when(403, () => \"Forbidden - Check API permissions, usage limits, or resource access rights.\"),\n      Match.when(404, () => \"Not Found - Verify the endpoint URL, API version, and resource identifiers.\"),\n      Match.when(408, () => \"Request Timeout - Consider increasing timeout duration or implementing retry logic.\"),\n      Match.when(422, () => \"Unprocessable Entity - Check request data validation, required fields, and data formats.\"),\n      Match.when(429, () => \"Rate Limited - Implement exponential backoff or reduce request frequency.\"),\n      Match.orElse(() => \"Client error - Review request format, parameters, and API documentation.\")\n    );\n  }\n  if (statusCode >= 500) {\n    return \"Server error - This is likely temporary. Implement retry logic with exponential backoff.\";\n  }\n  return \"Check API documentation for this status code.\";\n};\n\n// =====================================================================================================================\n// Http Request Error\n// =====================================================================================================================\n\nexport const HttpRequestErrorReasonKit = BS.stringLiteralKit(\"Transport\", \"Encode\", \"InvalidUrl\");\n\nexport class HttpRequestErrorReason extends HttpRequestErrorReasonKit.Schema.annotations({\n  schemaId: Symbol.for(\"@beep/iam/IamError/HttpRequestErrorReason\"),\n  identifier: \"HttpRequestErrorReason\",\n  title: \"HTTP Request Error Reason\",\n  description: \"Reason for an HTTP request error.\",\n}) {\n  static readonly Options = HttpRequestErrorReasonKit.Options;\n  static readonly Enum = HttpRequestErrorReasonKit.Enum;\n}\n\nexport declare namespace HttpRequestErrorReason {\n  export type Type = typeof HttpRequestErrorReason.Type;\n  export type Encoded = typeof HttpRequestErrorReason.Encoded;\n}\n\n/**\n * Error that occurs during HTTP request processing.\n *\n * This error is raised when issues arise before receiving an HTTP response,\n * such as network connectivity problems, request encoding issues, or invalid\n * URLs.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n * import { Effect } from \"effect\"\n *\n * const handleNetworkError = Effect.gen(function* () {\n *   const error = new IamError.HttpRequestError({\n *     module: \"OpenAI\",\n *     method: \"createCompletion\",\n *     reason: \"Transport\",\n *     request: {\n *       method: \"POST\",\n *       url: BS.URLString.make(\"https://api.openai.com/v1/completions\"),\n *       urlParams: [],\n *       hash: Option.none(),\n *       headers: { \"Content-Type\": \"application/json\" }\n *     },\n *     description: \"Connection timeout after 30 seconds\"\n *   })\n *\n *   console.log(error.message)\n *   // \"Transport: Connection timeout after 30 seconds (POST https://api.openai.com/v1/completions)\"\n * })\n * ```\n *\n * @since 1.0.0\n * @category Errors\n */\nexport class HttpRequestError extends S.TaggedError<HttpRequestError>(\"@beep/iam-sdk/IamError/HttpRequestError\")(\n  \"HttpRequestError\",\n  {\n    module: S.String,\n    method: S.String,\n    reason: HttpRequestErrorReason,\n    request: BS.HttpRequestDetails,\n    description: S.optional(S.String),\n    cause: S.optional(S.Defect),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/IamError/HttpRequestError\"),\n    identifier: \"HttpRequestError\",\n    title: \"HTTP Request Error\",\n    description: \"Error that occurs during HTTP request processing.\",\n  }\n) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: TypeId = TypeId;\n\n  /**\n   * Creates an HttpRequestError from a platform HttpClientError.RequestError.\n   *\n   * @example\n   * ```ts\n   * import { IamError } from \"@beep/iam-sdk\"\n   * import { HttpClientError } from \"@effect/platform\"\n   * import * as O from \"effect/Option\"\n   *\n   * declare const platformError: HttpClientError.RequestError\n   *\n   * const iamError = IamError.HttpRequestError.fromRequestError({\n   *   module: \"ChatGPT\",\n   *   method: \"sendMessage\",\n   *   error: platformError\n   * })\n   * ```\n   *\n   * @since 1.0.0\n   * @category Constructors\n   */\n  static readonly fromRequestError = ({\n    error,\n    ...params\n  }: {\n    readonly module: string;\n    readonly method: string;\n    readonly error: HttpClientError.RequestError;\n  }): HttpRequestError =>\n    new HttpRequestError({\n      ...params,\n      cause: error,\n      description: error.description,\n      reason: error.reason,\n      request: {\n        hash: error.request.hash,\n        headers: Inspectable.redact(error.request.headers) as UnsafeTypes.UnsafeAny,\n        method: error.request.method,\n        url: BS.URLString.make(error.request.url),\n        urlParams: error.request.urlParams,\n      },\n    });\n\n  get message(): string {\n    const methodAndUrl = `${this.request.method} ${this.request.url}` as const;\n\n    let baseMessage = this.description\n      ? (`${this.reason}: ${this.description}` as const)\n      : `${this.reason}: An HTTP request error occurred.`;\n\n    baseMessage += ` (${methodAndUrl})`;\n\n    let suggestion = \"\";\n\n    Match.value(this.reason).pipe(\n      Match.when(HttpRequestErrorReason.Enum.Encode, () => {\n        suggestion += \"Check the request body for any invalid data.\";\n      }),\n      Match.when(HttpRequestErrorReason.Enum.InvalidUrl, () => {\n        suggestion += \"Verify that the URL format is correct and that all required parameters have been provided.\";\n        suggestion += \" Check for any special characters that may need encoding.\";\n      }),\n      Match.when(HttpRequestErrorReason.Enum.Transport, () => {\n        suggestion += \"Check your network connection and try again.\";\n      }),\n      Match.exhaustive\n    );\n\n    baseMessage += `\\n\\nSuggestion: ${suggestion}`;\n\n    return baseMessage;\n  }\n}\n\n// =====================================================================================================================\n// Http Response Error\n// =====================================================================================================================\n\n/**\n * Schema for HTTP response details used in error reporting.\n *\n * Captures essential information about HTTP responses that caused errors,\n * including status codes and headers for debugging purposes.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n *\n * const responseDetails: typeof IamError.HttpResponseDetails.Type = {\n *   status: 429,\n *   headers: {\n *     \"Content-Type\": \"application/json\",\n *     \"X-RateLimit-Remaining\": \"0\",\n *     \"Retry-After\": \"60\"\n *   }\n * }\n * ```\n *\n * @since 1.0.0\n * @category Schemas\n */\nexport class HttpResponseDetails extends BS.Class<HttpResponseDetails>(\"HttpResponseDetails\")(\n  {\n    status: S.Number,\n    headers: S.Record({ key: S.String, value: S.String }),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/IamError/HttpResponseDetails\"),\n    identifier: \"HttpResponseDetails\",\n    title: \"HTTP Response Details\",\n    description: \"Details about an HTTP response that caused an error.\",\n  }\n) {}\n\nexport declare namespace HttpResponseDetails {\n  export type Type = S.Schema.Type<typeof HttpResponseDetails>;\n  export type Encoded = S.Schema.Encoded<typeof HttpResponseDetails>;\n}\n\nexport const HttpResponseErrorReasonKit = BS.stringLiteralKit(\"StatusCode\", \"Decode\", \"EmptyBody\");\n\nexport class HttpResponseErrorReason extends HttpResponseErrorReasonKit.Schema.annotations({\n  schemaId: Symbol.for(\"@beep/iam-sdk/IamError/HttpResponseErrorReason\"),\n  identifier: \"HttpResponseErrorReason\",\n  title: \"HTTP Response Error Reason\",\n  description: \"Reason for an HTTP response error.\",\n}) {\n  static readonly Options = HttpResponseErrorReasonKit.Options;\n  static readonly Enum = HttpResponseErrorReasonKit.Enum;\n}\n\nexport declare namespace HttpResponseErrorReason {\n  export type Type = typeof HttpRequestErrorReason.Type;\n  export type Encoded = typeof HttpRequestErrorReason.Encoded;\n}\n\n/**\n * Error that occurs during HTTP response processing.\n *\n * This error is thrown when issues arise after receiving an HTTP response,\n * such as unexpected status codes, response decoding failures, or empty\n * response bodies.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n * import * as O from \"effect\"\n *\n * const responseError = new IamError.HttpResponseError({\n *   module: \"OpenAI\",\n *   method: \"createCompletion\",\n *   reason: \"StatusCode\",\n *   request: {\n *     method: \"POST\",\n *     url: BS.URLString.make(\"https://api.openai.com/v1/completions\",\n *     urlParams: [],\n *     hash: O.none(),\n *     headers: { \"Content-Type\": \"application/json\" }\n *   },\n *   response: {\n *     status: 429,\n *     headers: { \"X-RateLimit-Remaining\": \"0\" }\n *   },\n *   description: \"Rate limit exceeded\"\n * })\n *\n * console.log(responseError.message)\n * // \"StatusCode: Rate limit exceeded (429 POST https://api.openai.com/v1/completions)\"\n * ```\n *\n * @since 1.0.0\n * @category Errors\n */\nexport class HttpResponseError extends S.TaggedError<HttpResponseError>(\"@beep/iam-sdk/IamError/HttpResponseError\")(\n  \"HttpResponseError\",\n  {\n    module: S.String,\n    method: S.String,\n    request: HttpRequestDetails,\n    response: HttpResponseDetails,\n    body: S.optional(S.String),\n    reason: HttpResponseErrorReason,\n    description: S.optional(S.String),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/IamError/HttpResponseError\"),\n    identifier: \"HttpResponseError\",\n    title: \"HTTP Response Error\",\n    description: \"Error that occurs during HTTP response processing.\",\n  }\n) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: TypeId = TypeId;\n\n  /**\n   * Creates an HttpResponseError from a platform HttpClientError.ResponseError.\n   *\n   * @example\n   * ```ts\n   * import { IamError } from \"@beep/iam-sdk\"\n   * import { Headers, HttpClientError } from \"@effect/platform\"\n   * import * as O from \"effect/Option\"\n   *\n   * declare const platformError: HttpClientError.ResponseError\n   *\n   * const iamError = IamError.HttpResponseError.fromResponseError({\n   *   module: \"OpenAI\",\n   *   method: \"completion\",\n   *   error: platformError\n   * })\n   * ```\n   *\n   * @since 1.0.0\n   * @category Constructors\n   */\n  static fromResponseError = ({\n    error,\n    ...params\n  }: {\n    readonly module: string;\n    readonly method: string;\n    readonly error: HttpClientError.ResponseError;\n  }): Effect.Effect<never, HttpResponseError> => {\n    let body: Effect.Effect<unknown, HttpClientError.ResponseError> = Effect.void;\n    const contentType = error.response.headers[\"content-type\"] ?? \"\";\n    if (contentType.includes(\"application/json\")) {\n      body = error.response.json;\n    } else if (contentType.includes(\"text/\") || contentType.includes(\"urlencoded\")) {\n      body = error.response.text;\n    }\n    return Effect.flatMap(\n      Effect.merge(body),\n      (body) =>\n        new HttpResponseError({\n          ...params,\n          description: error.description,\n          reason: error.reason,\n          request: {\n            hash: error.request.hash,\n            headers: Inspectable.redact(error.request.headers) as any,\n            method: error.request.method,\n            url: BS.URLString.make(error.request.url),\n            urlParams: error.request.urlParams,\n          },\n          response: {\n            headers: Inspectable.redact(error.response.headers) as any,\n            status: error.response.status,\n          },\n          body: Inspectable.format(body),\n        })\n    );\n  };\n\n  get message(): string {\n    const methodUrlStatus = `${this.response.status} ${this.request.method} ${this.request.url}` as const;\n\n    let baseMessage = this.description\n      ? (`${this.reason}: ${this.description}` as const)\n      : (`${this.reason}: An HTTP response error occurred.` as const);\n\n    baseMessage += ` (${methodUrlStatus})` as const;\n\n    let suggestion = \"\";\n    Match.value(this.reason).pipe(\n      Match.when(HttpResponseErrorReason.Enum.Decode, () => {\n        suggestion +=\n          \"The response format does not match what is expected. \" +\n          \"Verify API version compatibility, check response content-type, \" +\n          \"and/or examine if the endpoint schema has changed.\";\n      }),\n      Match.when(HttpResponseErrorReason.Enum.EmptyBody, () => {\n        suggestion +=\n          \"The response body was empty. This may indicate a server \" +\n          \"issue, API version mismatch, or the endpoint may have changed its response format.\";\n      }),\n      Match.when(HttpResponseErrorReason.Enum.StatusCode, () => {\n        suggestion += getStatusCodeSuggestion(this.response.status);\n      }),\n      Match.exhaustive\n    );\n    switch (this.reason) {\n      case \"Decode\": {\n        suggestion +=\n          \"The response format does not match what is expected. \" +\n          \"Verify API version compatibility, check response content-type, \" +\n          \"and/or examine if the endpoint schema has changed.\";\n        break;\n      }\n      case \"EmptyBody\": {\n        suggestion +=\n          \"The response body was empty. This may indicate a server \" +\n          \"issue, API version mismatch, or the endpoint may have changed its response format.\";\n        break;\n      }\n      case \"StatusCode\": {\n        suggestion += getStatusCodeSuggestion(this.response.status);\n        break;\n      }\n    }\n\n    baseMessage += `\\n\\n${suggestion}`;\n\n    if (P.isNotUndefined(this.body)) {\n      baseMessage += `\\n\\nResponse Body: ${this.body}`;\n    }\n\n    return baseMessage;\n  }\n}\n\n// =============================================================================\n// Malformed Input Error\n// =============================================================================\n\n/**\n * Error thrown when input data doesn't match the expected format or schema.\n *\n * This error occurs when the data provided to an AI operation fails validation,\n * is missing required fields, or doesn't conform to the expected structure.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n * import * as Effect from \"effect/Effect\"\n *\n * const validateInput = (data: unknown) =>\n *   typeof data === \"string\" && data.length > 0\n *     ? Effect.succeed(data)\n *     : Effect.fail(new IamError.MalformedInput({\n *         module: \"ChatBot\",\n *         method: \"processMessage\",\n *         description: \"Input must be a non-empty string\"\n *       }))\n *\n * const program = validateInput(\"\").pipe(\n *   Effect.catchTag(\"MalformedInput\", (error) => {\n *     console.log(`Input validation failed: ${error.description}`)\n *     return Effect.succeed(\"Please provide a valid message\")\n *   })\n * )\n * ```\n *\n * @since 1.0.0\n * @category Errors\n */\nexport class MalformedInput extends S.TaggedError<MalformedInput>(\"@beep/iam-sdk/IamError/MalformedInput\")(\n  \"MalformedInput\",\n  {\n    module: S.String,\n    method: S.String,\n    description: S.optional(S.String),\n    cause: S.optional(S.Defect),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/IamError/MalformedInput\"),\n    identifier: \"MalformedInput\",\n    title: \"Malformed Input Error\",\n    description: \"Error thrown when input data doesn't match the expected format or schema.\",\n  }\n) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: TypeId = TypeId;\n}\n\n// =============================================================================\n// Malformed Output Error\n// =============================================================================\n\n/**\n * Error thrown when output data can't be parsed or validated.\n *\n * This error occurs when AI service responses don't match the expected format,\n * contain invalid data structures, or fail schema validation during parsing.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n * import * as S from \"effect/Schema\";\n * import * as Effect from \"effect/Effect\"\n *\n * const ResponseSchema = S.Struct({\n *   message: S.String,\n *   tokens: S.Number\n * })\n *\n * const parseResponse = (data: unknown) =>\n *   S.decodeUnknown(ResponseSchema)(data).pipe(\n *     Effect.mapError(parseError =>\n *       new IamError.MalformedOutput({\n *         module: \"OpenAI\",\n *         method: \"completion\",\n *         description: \"Response doesn't match expected schema\",\n *         cause: parseError\n *       })\n *     )\n *   )\n *\n * const program = parseResponse({ invalid: \"data\" }).pipe(\n *   Effect.catchTag(\"MalformedOutput\", (error) => {\n *     console.log(`Parsing failed: ${error.description}`)\n *     return Effect.succeed({ message: \"Error\", tokens: 0 })\n *   })\n * )\n * ```\n *\n * @since 1.0.0\n * @category Errors\n */\nexport class MalformedOutput extends S.TaggedError<MalformedOutput>(\"@beep/iam-sdk/IamError/MalformedOutput\")(\n  \"MalformedOutput\",\n  {\n    module: S.String,\n    method: S.String,\n    description: S.optional(S.String),\n    cause: S.optional(S.Defect),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/IamError/MalformedOutput\"),\n    identifier: \"MalformedOutput\",\n    title: \"Malformed Output Error\",\n    description: \"Error thrown when output data can't be parsed or validated.\",\n  }\n) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: TypeId = TypeId;\n\n  /**\n   * Creates a MalformedOutput error from a Schema ParseError.\n   *\n   * @example\n   * ```ts\n   * import { IamError } from \"@beep/iam-sdk\";\n   * import * as Effect from \"effect/Effect\";\n   * import * as S from \"effect/Schema\"\n   *\n   * const UserSchema = S.Struct({\n   *   name: S.String,\n   *   age: S.Number\n   * })\n   *\n   * const parseUser = (data: unknown) =>\n   *   S.decodeUnknown(UserSchema)(data).pipe(\n   *     Effect.mapError((parseError) =>\n   *       IamError.MalformedOutput.fromParseError({\n   *         module: \"UserService\",\n   *         method: \"parseUserData\",\n   *         error: parseError\n   *       })\n   *     )\n   *   )\n   * ```\n   *\n   * @since 1.0.0\n   * @category Constructors\n   */\n  static fromParseError({\n    error,\n    ...params\n  }: {\n    readonly module: string;\n    readonly method: string;\n    readonly description?: string;\n    readonly error: ParseError;\n  }): MalformedOutput {\n    return new MalformedOutput({\n      ...params,\n      cause: error,\n    });\n  }\n}\n\n// =============================================================================\n// Unknown Error\n// =============================================================================\n\n/**\n * Catch-all error for unexpected runtime errors in AI operations.\n *\n * This error is used when an unexpected exception occurs that doesn't fit\n * into the other specific error categories. It provides context about where\n * the error occurred and preserves the original cause for debugging.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n * import * as Effect from \"effect/Effect\"\n *\n * const riskyOperation = () => {\n *   try {\n *     // Some operation that might throw\n *     throw new Error(\"Unexpected network issue\")\n *   } catch (cause) {\n *     return Effect.fail(new IamError.UnknownError({\n *       module: \"ChatService\",\n *       method: \"sendMessage\",\n *       description: \"An unexpected error occurred during message processing\",\n *       cause\n *     }))\n *   }\n * }\n *\n * const program = riskyOperation().pipe(\n *   Effect.catchTag(\"UnknownError\", (error) => {\n *     console.log(error.message)\n *     // \"ChatService.sendMessage: An unexpected error occurred during message processing\"\n *     return Effect.succeed(\"Service temporarily unavailable\")\n *   })\n * )\n * ```\n *\n * @since 1.0.0\n * @category Errors\n */\nexport class UnknownError extends S.TaggedError<UnknownError>(\"@beep/iam-sdk/UnknownError\")(\n  \"UnknownError\",\n  {\n    module: S.String,\n    method: S.String,\n    description: S.optional(S.String),\n    cause: S.optional(S.Defect),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/UnknownError\"),\n    identifier: \"UnknownError\",\n    title: \"Unknown Error\",\n    description: \"Catch-all error for unexpected runtime errors in AI operations.\",\n  }\n) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: TypeId = TypeId;\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    const moduleMethod = `${this.module}.${this.method}`;\n    return P.isUndefined(this.description)\n      ? `${moduleMethod}: An error occurred`\n      : `${moduleMethod}: ${this.description}`;\n  }\n}\n\n// =============================================================================\n// IamError\n// =============================================================================\n\n/**\n * Schema for validating and parsing AI errors.\n *\n * This schema can be used to decode unknown values into properly typed AI\n * errors, ensuring type safety when handling errors from external sources or\n * serialized data.\n *\n * @example\n * ```ts\n * import { IamError } from \"@beep/iam-sdk\"\n * import * as S from \"effect/Schema\";\n * import * as Effect from \"effect/Effect\";\n *\n * const parseIamError = (data: unknown) =>\n *   S.decodeUnknown(IamError.IamError)(data).pipe(\n *     Effect.map(error => {\n *       console.log(`Parsed AI error: ${error._tag}`)\n *       return error\n *     }),\n *     Effect.catchAll(() =>\n *       Effect.succeed(new IamError.UnknownError({\n *         module: \"Parser\",\n *         method: \"parseIamError\",\n *         description: \"Failed to parse error data\"\n *       }))\n *     )\n *   )\n * ```\n *\n * @since 1.0.0\n * @category Schemas\n */\n\nexport class IamError extends S.Union(\n  HttpRequestError,\n  HttpResponseError,\n  MalformedInput,\n  MalformedOutput,\n  UnknownError\n).annotations({\n  schemaId: Symbol.for(\"@beep/iam-sdk/IamError\"),\n  identifier: \"IamError\",\n  title: \"IamError\",\n  description: \"Union type representing all possible AI operation errors.\",\n}) {}\n\nexport declare namespace IamError {\n  /**\n   * Union type representing all possible AI operation errors.\n   *\n   * This type encompasses all error cases that can occur during AI operations,\n   * providing a comprehensive error handling surface for applications.\n   *\n   * @example\n   * ```ts\n   * import { IamError } from \"@beep/iam-sdk\"\n   * import * as Effect from \"effect/Effect\";\n   * import * as Match from \"effect/Match\";\n   * const handleAnyIamError = Match.type<IamError.IamError>().pipe(\n   *   Match.tag(\"HttpRequestError\", (err) =>\n   *     `Network error: ${err.reason}`\n   *   ),\n   *   Match.tag(\"HttpResponseError\", (err) =>\n   *     `Server error: HTTP ${err.response.status}`\n   *   ),\n   *   Match.tag(\"MalformedInput\", (err) =>\n   *     `Invalid input: ${err.description || \"Data validation failed\"}`\n   *   ),\n   *   Match.tag(\"MalformedOutput\", (err) =>\n   *     `Invalid response: ${err.description || \"Response parsing failed\"}`\n   *   ),\n   *   Match.orElse((err) =>\n   *     `Unknown error: ${err.message}`\n   *   )\n   * )\n   * ```\n   *\n   * @since 1.0.0\n   * @category Models\n   */\n  export type Type = S.Schema.Type<typeof IamError>;\n  export type Encoded = S.Schema.Encoded<typeof IamError>;\n}\n\nexport { HttpRequestDetails };\n","class BaseWebAuthnAbortService {\n    constructor() {\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.\n *\n * Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.\n * developers building projects that use client-side routing to better control the behavior of\n * their UX in response to router navigation events.\n */\nexport const WebAuthnAbortService = new BaseWebAuthnAbortService();\n","const attachments = ['cross-platform', 'platform'];\n/**\n * If possible coerce a `string` value into a known `AuthenticatorAttachment`\n */\nexport function toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n","const twoFactorClient = (options) => {\n  return {\n    id: \"two-factor\",\n    $InferServerPlugin: {},\n    atomListeners: [\n      {\n        matcher: (path) => path.startsWith(\"/two-factor/\"),\n        signal: \"$sessionSignal\"\n      }\n    ],\n    pathMethods: {\n      \"/two-factor/disable\": \"POST\",\n      \"/two-factor/enable\": \"POST\",\n      \"/two-factor/send-otp\": \"POST\",\n      \"/two-factor/generate-backup-codes\": \"POST\"\n    },\n    fetchPlugins: [\n      {\n        id: \"two-factor\",\n        name: \"two-factor\",\n        hooks: {\n          async onSuccess(context) {\n            if (context.data?.twoFactorRedirect) {\n              if (options?.onTwoFactorRedirect) {\n                await options.onTwoFactorRedirect();\n              }\n            }\n          }\n        }\n      }\n    ]\n  };\n};\n\nexport { twoFactorClient as t };\n","const deviceAuthorizationClient = () => {\n  return {\n    id: \"device-authorization\",\n    $InferServerPlugin: {},\n    pathMethods: {\n      \"/device/code\": \"POST\",\n      \"/device/token\": \"POST\",\n      \"/device\": \"GET\",\n      \"/device/approve\": \"POST\",\n      \"/device/deny\": \"POST\"\n    }\n  };\n};\n\nexport { deviceAuthorizationClient as d };\n","const PROTO_POLLUTION_PATTERNS = {\n  proto: /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/,\n  constructor: /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/,\n  protoShort: /\"__proto__\"\\s*:/,\n  constructorShort: /\"constructor\"\\s*:/\n};\nconst JSON_SIGNATURE = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nconst SPECIAL_VALUES = {\n  true: true,\n  false: false,\n  null: null,\n  undefined: void 0,\n  nan: Number.NaN,\n  infinity: Number.POSITIVE_INFINITY,\n  \"-infinity\": Number.NEGATIVE_INFINITY\n};\nconst ISO_DATE_REGEX = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,7}))?(?:Z|([+-])(\\d{2}):(\\d{2}))$/;\nfunction isValidDate(date) {\n  return date instanceof Date && !isNaN(date.getTime());\n}\nfunction parseISODate(value) {\n  const match = ISO_DATE_REGEX.exec(value);\n  if (!match) return null;\n  const [\n    ,\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    ms,\n    offsetSign,\n    offsetHour,\n    offsetMinute\n  ] = match;\n  let date = new Date(\n    Date.UTC(\n      parseInt(year, 10),\n      parseInt(month, 10) - 1,\n      parseInt(day, 10),\n      parseInt(hour, 10),\n      parseInt(minute, 10),\n      parseInt(second, 10),\n      ms ? parseInt(ms.padEnd(3, \"0\"), 10) : 0\n    )\n  );\n  if (offsetSign) {\n    const offset = (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) * (offsetSign === \"+\" ? -1 : 1);\n    date.setUTCMinutes(date.getUTCMinutes() + offset);\n  }\n  return isValidDate(date) ? date : null;\n}\nfunction betterJSONParse(value, options = {}) {\n  const {\n    strict = false,\n    warnings = false,\n    reviver,\n    parseDates = true\n  } = options;\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const trimmed = value.trim();\n  if (trimmed.length > 0 && trimmed[0] === '\"' && trimmed.endsWith('\"') && !trimmed.slice(1, -1).includes('\"')) {\n    return trimmed.slice(1, -1);\n  }\n  const lowerValue = trimmed.toLowerCase();\n  if (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) {\n    return SPECIAL_VALUES[lowerValue];\n  }\n  if (!JSON_SIGNATURE.test(trimmed)) {\n    if (strict) {\n      throw new SyntaxError(\"[better-json] Invalid JSON\");\n    }\n    return value;\n  }\n  const hasProtoPattern = Object.entries(PROTO_POLLUTION_PATTERNS).some(\n    ([key, pattern]) => {\n      const matches = pattern.test(trimmed);\n      if (matches && warnings) {\n        console.warn(\n          `[better-json] Detected potential prototype pollution attempt using ${key} pattern`\n        );\n      }\n      return matches;\n    }\n  );\n  if (hasProtoPattern && strict) {\n    throw new Error(\n      \"[better-json] Potential prototype pollution attempt detected\"\n    );\n  }\n  try {\n    const secureReviver = (key, value2) => {\n      if (key === \"__proto__\" || key === \"constructor\" && value2 && typeof value2 === \"object\" && \"prototype\" in value2) {\n        if (warnings) {\n          console.warn(\n            `[better-json] Dropping \"${key}\" key to prevent prototype pollution`\n          );\n        }\n        return void 0;\n      }\n      if (parseDates && typeof value2 === \"string\") {\n        const date = parseISODate(value2);\n        if (date) {\n          return date;\n        }\n      }\n      return reviver ? reviver(key, value2) : value2;\n    };\n    return JSON.parse(trimmed, secureReviver);\n  } catch (error) {\n    if (strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction parseJSON(value, options = { strict: true }) {\n  return betterJSONParse(value, options);\n}\n\nexport { parseJSON as p };\n","import { clientEnv } from \"@beep/core-env/client\";\nimport { stripeClient } from \"@better-auth/stripe/client\";\nimport {\n  adminClient,\n  anonymousClient,\n  apiKeyClient,\n  customSessionClient,\n  deviceAuthorizationClient,\n  genericOAuthClient,\n  jwtClient,\n  lastLoginMethodClient,\n  multiSessionClient,\n  oidcClient,\n  oneTapClient,\n  oneTimeTokenClient,\n  organizationClient,\n  passkeyClient,\n  phoneNumberClient,\n  siweClient,\n  ssoClient,\n  twoFactorClient,\n  usernameClient,\n} from \"better-auth/client/plugins\";\nimport { createAuthClient } from \"better-auth/react\";\n\nexport const client = createAuthClient({\n  baseURL: clientEnv.authUrl,\n  basePath: clientEnv.authPath,\n  plugins: [\n    adminClient(),\n    anonymousClient(),\n    apiKeyClient(),\n    customSessionClient(),\n    genericOAuthClient(),\n    jwtClient(),\n    multiSessionClient(),\n    oidcClient(),\n    oneTapClient({\n      clientId: clientEnv.googleClientId,\n      promptOptions: {\n        maxAttempts: 1,\n      },\n    }),\n    oneTimeTokenClient(),\n    organizationClient({\n      teams: {\n        enabled: true,\n      },\n      dynamicAccessControl: {\n        enabled: true,\n      },\n    }),\n    passkeyClient(),\n    phoneNumberClient(),\n    siweClient(),\n    ssoClient(),\n    twoFactorClient(),\n    usernameClient(),\n    stripeClient({\n      subscription: true,\n    }),\n    deviceAuthorizationClient(),\n    lastLoginMethodClient(),\n  ],\n});\n\nexport const { $store, signIn } = client;\n\n$store.listen(\"$sessionSignal\", async () => {});\n","import { AuthProviderNameValue } from \"@beep/constants\";\nimport { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\n// =====================================================================================================================\n// SIGN IN EMAIL CONTRACT\n// =====================================================================================================================\nexport class SignInEmailPayload extends BS.Class<SignInEmailPayload>(\"SignInEmailPayload\")(\n  {\n    email: BS.Email,\n    password: BS.Password,\n    rememberMe: BS.BoolWithDefault(false),\n    captchaResponse: S.Redacted(S.String),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignInEmailPayload\"),\n    identifier: \"SignInEmailPayload\",\n    description: \"Payload for signing in with email and password\",\n  }\n) {}\n\nexport declare namespace SignInEmailPayload {\n  export type Type = S.Schema.Type<typeof SignInEmailPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignInEmailPayload>;\n}\n\nexport const SignInEmailContract = Contract.make(\"SignInEmail\", {\n  description: \"Signs the user in using email\",\n  parameters: SignInEmailPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\n// =====================================================================================================================\n// SIGN IN SOCIAL CONTRACT\n// =====================================================================================================================\nexport class SignInSocialPayload extends BS.Class<SignInSocialPayload>(\"SignInSocialPayload\")(\n  {\n    provider: AuthProviderNameValue,\n    callbackURL: S.optional(BS.URLString),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignInSocialPayload\"),\n    identifier: \"SignInSocialPayload\",\n    description: \"Payload for signing in with a supported social provider\",\n  }\n) {}\n\nexport declare namespace SignInSocialPayload {\n  export type Type = S.Schema.Type<typeof SignInSocialPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignInSocialPayload>;\n}\n\nexport const SignInSocialContract = Contract.make(\"SignInSocial\", {\n  description: \"Contract for signing in a user with a social auth provider.\",\n  parameters: SignInSocialPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\n// =====================================================================================================================\n// SIGN IN USERNAME CONTRACT\n// =====================================================================================================================\nexport class SignInUsernamePayload extends BS.Class<SignInUsernamePayload>(\"SignInUsernamePayload\")(\n  {\n    username: S.NonEmptyTrimmedString,\n    password: BS.Password,\n    rememberMe: BS.BoolWithDefault(false),\n    captchaResponse: S.Redacted(S.String),\n    callbackURL: S.optional(BS.URLString),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignInUsernamePayload\"),\n    identifier: \"SignInUsernamePayload\",\n    description: \"Payload for signing in with username and password\",\n  }\n) {}\n\nexport declare namespace SignInUsernamePayload {\n  export type Type = S.Schema.Type<typeof SignInUsernamePayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignInUsernamePayload>;\n}\n\nexport const SignInUsernameContract = Contract.make(\"SignInUsername\", {\n  description: \"Signs the user in using their username.\",\n  parameters: SignInUsernamePayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\n// =====================================================================================================================\n// SIGN IN PHONE NUMBER CONTRACT\n// =====================================================================================================================\nexport class SignInPhoneNumberPayload extends BS.Class<SignInPhoneNumberPayload>(\"SignInPhoneNumberPayload\")(\n  {\n    phoneNumber: BS.Phone,\n    password: BS.Password,\n    rememberMe: BS.BoolWithDefault(false),\n    captchaResponse: S.Redacted(S.String),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignInPhoneNumberPayload\"),\n    identifier: \"SignInPhoneNumberPayload\",\n    description: \"Payload for signing in with a phone number and password\",\n  }\n) {}\n\nexport declare namespace SignInPhoneNumberPayload {\n  export type Type = S.Schema.Type<typeof SignInPhoneNumberPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignInPhoneNumberPayload>;\n}\n\nexport const SignInPhoneNumberContract = Contract.make(\"SignInPhoneNumber\", {\n  description: \"Signs the user in using their phone number.\",\n  parameters: SignInPhoneNumberPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\n// =====================================================================================================================\n// SIGN IN PASSKEY CONTRACT\n// =====================================================================================================================\nexport class SignInPasskeyPayload extends BS.Class<SignInPasskeyPayload>(\"SignInPasskeyPayload\")(\n  {},\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignInPasskeyPayload\"),\n    identifier: \"SignInPasskeyPayload\",\n    description: \"Payload for signing in with a passkey\",\n    title: \"Sign in with passkey\",\n  }\n) {}\n\nexport declare namespace SignInPasskeyPayload {\n  export type Type = S.Schema.Type<typeof SignInPasskeyPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignInPasskeyPayload>;\n}\n\nexport const SignInPasskeyContract = Contract.make(\"SignInPasskey\", {\n  description: \"Signs the user in using a passkey.\",\n  parameters: SignInPasskeyPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\n// =====================================================================================================================\n// Signin OneTap\n// =====================================================================================================================\nexport const SignInOneTapPayload = S.Struct({});\nexport declare namespace SignInOneTapPayload {\n  export type Type = S.Schema.Type<typeof SignInOneTapPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignInOneTapPayload>;\n}\nexport const SignInOneTapContract = Contract.make(\"SignInOneTap\", {\n  description: \"Signs the user in using a one tap.\",\n  parameters: SignInOneTapPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const SignInContractSet = ContractSet.make(\n  SignInEmailContract,\n  SignInSocialContract,\n  SignInUsernameContract,\n  SignInPhoneNumberContract,\n  SignInPasskeyContract,\n  SignInOneTapContract\n);\n","export function listenKeys($store, keys, listener) {\n  let keysSet = new Set(keys).add(undefined)\n  return $store.listen((value, oldValue, changed) => {\n    if (keysSet.has(changed)) {\n      listener(value, oldValue, changed)\n    }\n  })\n}\n\nexport function subscribeKeys($store, keys, listener) {\n  let unbind = listenKeys($store, keys, listener)\n  listener($store.value)\n  return unbind\n}\n","import { base64URLStringToBuffer } from './base64URLStringToBuffer.js';\nexport function toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        /**\n         * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer\n         * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports\n         * are fine to pass to WebAuthn since browsers will recognize the new value.\n         */\n        transports: descriptor.transports,\n    };\n}\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport { IamEntityIds } from \"@beep/shared-domain\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\nexport class AcceptInvitationPayload extends BS.Class<AcceptInvitationPayload>(\"AcceptInvitationPayload\")(\n  {\n    invitationId: IamEntityIds.InvitationId,\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/AcceptInvitationPayload\"),\n    identifier: \"AcceptInvitationPayload\",\n    description: \"Payload for accepting an organization invitation.\",\n  }\n) {}\n\nexport declare namespace AcceptInvitationPayload {\n  export type Type = S.Schema.Type<typeof AcceptInvitationPayload>;\n  export type Encoded = S.Schema.Encoded<typeof AcceptInvitationPayload>;\n}\n\nexport const AcceptInvitationContract = Contract.make(\"AcceptInvitationContract\", {\n  description: \"Accepts an organization invitation.\",\n  parameters: AcceptInvitationPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const OrganizationContractSet = ContractSet.make(AcceptInvitationContract);\n","import { B as BetterAuthError } from '../../shared/better-auth.DdzSJf-n.mjs';\n\nfunction role(statements) {\n  return {\n    authorize(request, connector = \"AND\") {\n      let success = false;\n      for (const [requestedResource, requestedActions] of Object.entries(\n        request\n      )) {\n        const allowedActions = statements[requestedResource];\n        if (!allowedActions) {\n          return {\n            success: false,\n            error: `You are not allowed to access resource: ${requestedResource}`\n          };\n        }\n        if (Array.isArray(requestedActions)) {\n          success = requestedActions.every(\n            (requestedAction) => allowedActions.includes(requestedAction)\n          );\n        } else {\n          if (typeof requestedActions === \"object\") {\n            const actions = requestedActions;\n            if (actions.connector === \"OR\") {\n              success = actions.actions.some(\n                (requestedAction) => allowedActions.includes(requestedAction)\n              );\n            } else {\n              success = actions.actions.every(\n                (requestedAction) => allowedActions.includes(requestedAction)\n              );\n            }\n          } else {\n            throw new BetterAuthError(\"Invalid access control request\");\n          }\n        }\n        if (success && connector === \"OR\") {\n          return { success };\n        }\n        if (!success && connector === \"AND\") {\n          return {\n            success: false,\n            error: `unauthorized to access resource \"${requestedResource}\"`\n          };\n        }\n      }\n      if (success) {\n        return {\n          success\n        };\n      }\n      return {\n        success: false,\n        error: \"Not authorized\"\n      };\n    },\n    statements\n  };\n}\nfunction createAccessControl(s) {\n  return {\n    newRole(statements) {\n      return role(statements);\n    },\n    statements: s\n  };\n}\n\nexport { createAccessControl, role };\n","import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\nexport let atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n","import { defaultRoles } from '../plugins/admin/access/index.mjs';\n\nconst hasPermission = (input) => {\n  if (input.userId && input.options?.adminUserIds?.includes(input.userId)) {\n    return true;\n  }\n  if (!input.permissions && !input.permission) {\n    return false;\n  }\n  const roles = (input.role || input.options?.defaultRole || \"user\").split(\",\");\n  const acRoles = input.options?.roles || defaultRoles;\n  for (const role of roles) {\n    const _role = acRoles[role];\n    const result = _role?.authorize(input.permission ?? input.permissions);\n    if (result?.success) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport { hasPermission as h };\n","import { atom, onMount } from 'nanostores';\n\nconst isServer = typeof window === \"undefined\";\nconst useAuthQuery = (initializedAtom, path, $fetch, options) => {\n  const value = atom({\n    data: null,\n    error: null,\n    isPending: true,\n    isRefetching: false,\n    refetch: (queryParams) => {\n      return fn(queryParams);\n    }\n  });\n  const fn = (queryParams) => {\n    const opts = typeof options === \"function\" ? options({\n      data: value.get().data,\n      error: value.get().error,\n      isPending: value.get().isPending\n    }) : options;\n    $fetch(path, {\n      ...opts,\n      query: {\n        ...opts?.query,\n        ...queryParams?.query\n      },\n      async onSuccess(context) {\n        value.set({\n          data: context.data,\n          error: null,\n          isPending: false,\n          isRefetching: false,\n          refetch: value.value.refetch\n        });\n        await opts?.onSuccess?.(context);\n      },\n      async onError(context) {\n        const { request } = context;\n        const retryAttempts = typeof request.retry === \"number\" ? request.retry : request.retry?.attempts;\n        const retryAttempt = request.retryAttempt || 0;\n        if (retryAttempts && retryAttempt < retryAttempts) return;\n        value.set({\n          error: context.error,\n          data: null,\n          isPending: false,\n          isRefetching: false,\n          refetch: value.value.refetch\n        });\n        await opts?.onError?.(context);\n      },\n      async onRequest(context) {\n        const currentValue = value.get();\n        value.set({\n          isPending: currentValue.data === null,\n          data: currentValue.data,\n          error: null,\n          isRefetching: true,\n          refetch: value.value.refetch\n        });\n        await opts?.onRequest?.(context);\n      }\n    }).catch((error) => {\n      value.set({\n        error,\n        data: null,\n        isPending: false,\n        isRefetching: false,\n        refetch: value.value.refetch\n      });\n    });\n  };\n  initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];\n  let isMounted = false;\n  for (const initAtom of initializedAtom) {\n    initAtom.subscribe(() => {\n      if (isServer) {\n        return;\n      }\n      if (isMounted) {\n        fn();\n      } else {\n        onMount(value, () => {\n          const timeoutId = setTimeout(() => {\n            if (!isMounted) {\n              fn();\n              isMounted = true;\n            }\n          }, 0);\n          return () => {\n            value.off();\n            initAtom.off();\n            clearTimeout(timeoutId);\n          };\n        });\n      }\n    });\n  }\n  return value;\n};\n\nexport { useAuthQuery as u };\n","import { g as getClientConfig, c as createDynamicPathProxy } from '../../shared/better-auth.DLt6eN7D.mjs';\nimport { listenKeys } from 'nanostores';\nimport { useRef, useCallback, useSyncExternalStore } from 'react';\nimport '@better-fetch/fetch';\nimport '../../shared/better-auth.BRFtaovt.mjs';\nimport '../../shared/better-auth.CiuwFiHM.mjs';\nimport '../../shared/better-auth.DdzSJf-n.mjs';\nimport '../../shared/better-auth.BYWGbmZ5.mjs';\nimport '../../shared/better-auth.msGOU0m9.mjs';\n\nfunction useStore(store, options = {}) {\n  let snapshotRef = useRef(store.get());\n  const { keys, deps = [store, keys] } = options;\n  let subscribe = useCallback((onChange) => {\n    const emitChange = (value) => {\n      if (snapshotRef.current === value) return;\n      snapshotRef.current = value;\n      onChange();\n    };\n    emitChange(store.value);\n    if (keys?.length) {\n      return listenKeys(store, keys, emitChange);\n    }\n    return store.listen(emitChange);\n  }, deps);\n  let get = () => snapshotRef.current;\n  return useSyncExternalStore(subscribe, get, get);\n}\n\nfunction getAtomKey(str) {\n  return `use${capitalizeFirstLetter(str)}`;\n}\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction createAuthClient(options) {\n  const {\n    pluginPathMethods,\n    pluginsActions,\n    pluginsAtoms,\n    $fetch,\n    $store,\n    atomListeners\n  } = getClientConfig(options);\n  let resolvedHooks = {};\n  for (const [key, value] of Object.entries(pluginsAtoms)) {\n    resolvedHooks[getAtomKey(key)] = () => useStore(value);\n  }\n  const routes = {\n    ...pluginsActions,\n    ...resolvedHooks,\n    $fetch,\n    $store\n  };\n  const proxy = createDynamicPathProxy(\n    routes,\n    $fetch,\n    pluginPathMethods,\n    pluginsAtoms,\n    atomListeners\n  );\n  return proxy;\n}\n\nexport { capitalizeFirstLetter, createAuthClient, useStore };\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport { paths } from \"@beep/shared-domain\";\nimport * as Equal from \"effect/Equal\";\nimport * as Redacted from \"effect/Redacted\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\nconst ResetPasswordPayloadFields = {\n  newPassword: BS.Password,\n  passwordConfirm: BS.Password,\n};\nexport const ResetPasswordPayload = S.Struct(ResetPasswordPayloadFields).pipe(\n  S.filter(\n    ({ newPassword, passwordConfirm }) =>\n      Equal.equals(Redacted.value(newPassword), Redacted.value(passwordConfirm)) || \"Passwords do not match\"\n  ),\n  S.annotations({\n    identifier: \"ResetPasswordPayload\",\n    description: \"Payload containing the data required to reset a password.\",\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/ResetPasswordPayload\"),\n  })\n);\n\nexport declare namespace ResetPasswordPayload {\n  export type Type = S.Schema.Type<typeof ResetPasswordPayload>;\n  export type Encoded = S.Schema.Encoded<typeof ResetPasswordPayload>;\n}\n\nexport class RequestResetPasswordPayload extends BS.Class<RequestResetPasswordPayload>(\"RequestResetPasswordPayload\")(\n  {\n    email: BS.Email,\n    redirectTo: BS.StringWithDefault(paths.auth.requestResetPassword),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/RequestResetPasswordPayload\"),\n    identifier: \"RequestResetPasswordPayload\",\n    description: \"Payload for requesting a password reset email.\",\n  }\n) {}\n\nexport declare namespace RequestResetPasswordPayload {\n  export type Type = S.Schema.Type<typeof RequestResetPasswordPayload>;\n  export type Encoded = S.Schema.Encoded<typeof RequestResetPasswordPayload>;\n}\n\nexport const ResetPasswordContract = Contract.make(\"ResetPasswordContract\", {\n  description: \"Resets a user's password using the provided token.\",\n  parameters: ResetPasswordPayloadFields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const RequestResetPasswordContract = Contract.make(\"RequestResetPasswordContract\", {\n  description: \"Requests a password reset email for a user.\",\n  parameters: RequestResetPasswordPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const RecoverContractSet = ContractSet.make(ResetPasswordContract, RequestResetPasswordContract);\n","import * as Data from \"effect/Data\";\n\nexport class BetterAuthError extends Data.TaggedError(\"BetterAuthError\")<{\n  readonly message: string;\n}> {\n  constructor(readonly message: string) {\n    super({ message });\n  }\n}\n","import { e as env } from './better-auth.CiuwFiHM.mjs';\nimport { B as BetterAuthError } from './better-auth.DdzSJf-n.mjs';\n\nfunction checkHasPath(url) {\n  try {\n    const parsedUrl = new URL(url);\n    const pathname = parsedUrl.pathname.replace(/\\/+$/, \"\") || \"/\";\n    return pathname !== \"/\";\n  } catch (error) {\n    throw new BetterAuthError(\n      `Invalid base URL: ${url}. Please provide a valid base URL.`\n    );\n  }\n}\nfunction withPath(url, path = \"/api/auth\") {\n  const hasPath = checkHasPath(url);\n  if (hasPath) {\n    return url;\n  }\n  const trimmedUrl = url.replace(/\\/+$/, \"\");\n  if (!path || path === \"/\") {\n    return trimmedUrl;\n  }\n  path = path.startsWith(\"/\") ? path : `/${path}`;\n  return `${trimmedUrl}${path}`;\n}\nfunction getBaseURL(url, path, request, loadEnv) {\n  if (url) {\n    return withPath(url, path);\n  }\n  if (loadEnv !== false) {\n    const fromEnv = env.BETTER_AUTH_URL || env.NEXT_PUBLIC_BETTER_AUTH_URL || env.PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_BETTER_AUTH_URL || env.NUXT_PUBLIC_AUTH_URL || (env.BASE_URL !== \"/\" ? env.BASE_URL : void 0);\n    if (fromEnv) {\n      return withPath(fromEnv, path);\n    }\n  }\n  const fromRequest = request?.headers.get(\"x-forwarded-host\");\n  const fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n  if (fromRequest && fromRequestProto) {\n    return withPath(`${fromRequestProto}://${fromRequest}`, path);\n  }\n  if (request) {\n    const url2 = getOrigin(request.url);\n    if (!url2) {\n      throw new BetterAuthError(\n        \"Could not get origin from request. Please provide a valid base URL.\"\n      );\n    }\n    return withPath(url2, path);\n  }\n  if (typeof window !== \"undefined\" && window.location) {\n    return withPath(window.location.origin, path);\n  }\n  return void 0;\n}\nfunction getOrigin(url) {\n  try {\n    const parsedUrl = new URL(url);\n    return parsedUrl.origin;\n  } catch (error) {\n    return null;\n  }\n}\nfunction getProtocol(url) {\n  try {\n    const parsedUrl = new URL(url);\n    return parsedUrl.protocol;\n  } catch (error) {\n    return null;\n  }\n}\nfunction getHost(url) {\n  try {\n    const parsedUrl = new URL(url);\n    return parsedUrl.host;\n  } catch (error) {\n    return url;\n  }\n}\n\nexport { getBaseURL as a, getHost as b, getProtocol as c, getOrigin as g };\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport { paths } from \"@beep/shared-domain\";\nimport * as SharedEntities from \"@beep/shared-domain/entities\";\nimport * as F from \"effect/Function\";\nimport * as ParseResult from \"effect/ParseResult\";\nimport * as Redacted from \"effect/Redacted\";\nimport * as S from \"effect/Schema\";\nimport * as Str from \"effect/String\";\nimport * as Struct from \"effect/Struct\";\nimport { IamError } from \"../../errors\";\n\nconst SignUpFrom = S.Struct({\n  email: BS.Email,\n  rememberMe: BS.BoolWithDefault(false),\n  redirectTo: BS.StringWithDefault(paths.dashboard.root),\n  gender: SharedEntities.User.Model.insert.fields.gender,\n  password: BS.Password,\n  passwordConfirm: BS.Password,\n  firstName: S.NonEmptyTrimmedString,\n  lastName: S.NonEmptyTrimmedString,\n  captchaResponse: S.Redacted(S.String),\n});\n\nconst SignUpTo = S.Struct({\n  email: S.encodedSchema(BS.Email),\n  rememberMe: BS.BoolWithDefault(false),\n  callbackURL: BS.StringWithDefault(paths.dashboard.root),\n  gender: SharedEntities.User.Model.insert.fields.gender,\n  password: S.encodedSchema(BS.Password),\n  passwordConfirm: S.encodedSchema(BS.Password),\n  firstName: S.NonEmptyTrimmedString,\n  lastName: S.NonEmptyTrimmedString,\n  name: S.NonEmptyTrimmedString,\n  captchaResponse: S.Redacted(S.String),\n});\n\nexport class SignUpValue extends S.transformOrFail(SignUpFrom, SignUpTo, {\n  strict: true,\n  decode: ({ rememberMe = false, ...value }, _, ast) =>\n    ParseResult.try({\n      try: () => {\n        const name = F.pipe(value.firstName, Str.concat(\" \"), Str.concat(value.lastName));\n        return {\n          firstName: value.firstName,\n          lastName: value.lastName,\n          gender: value.gender,\n          email: Redacted.value(value.email),\n          password: Redacted.value(value.password),\n          passwordConfirm: Redacted.value(value.passwordConfirm),\n          redirectTo: value.redirectTo,\n          rememberMe,\n          captchaResponse: Redacted.value(value.captchaResponse),\n          name,\n        } as const;\n      },\n      catch: () => new ParseResult.Type(ast, value, \"could not decode signup\"),\n    }),\n  encode: (value, _, ast) =>\n    ParseResult.try({\n      try: () => {\n        return S.decodeSync(SignUpFrom)(Struct.omit(value, \"name\"));\n      },\n      catch: () => new ParseResult.Type(ast, value, \"could not encode signup\"),\n    }),\n}) {}\n\nexport declare namespace SignUpValue {\n  export type Type = S.Schema.Type<typeof SignUpValue>;\n  export type Encoded = S.Schema.Encoded<typeof SignUpValue>;\n}\n\nexport class SignUpEmailPayload extends BS.Class<SignUpEmailPayload>(\"SignUpEmailPayload\")(\n  {\n    value: SignUpValue,\n    onSuccess: new BS.Fn({\n      input: BS.URLPath,\n      output: S.Void,\n    }).Schema,\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignUpEmailPayload\"),\n    identifier: \"SignUpEmailPayload\",\n    description: \"Payload for signing up a new user via email.\",\n  }\n) {}\n\nexport declare namespace SignUpEmailPayload {\n  export type Type = S.Schema.Type<typeof SignUpEmailPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignUpEmailPayload>;\n}\n\nexport const SignUpEmailContract = Contract.make(\"SignUpEmail\", {\n  description: \"Signs up a new user using email credentials.\",\n  parameters: SignUpEmailPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Union(S.TaggedStruct(\"Success\", {}), S.TaggedStruct(\"Failure\", {})),\n});\n\nexport const SignUpContractSet = ContractSet.make(SignUpEmailContract);\n","import { createAccessControl } from '../../access/index.mjs';\nimport '../../../shared/better-auth.DdzSJf-n.mjs';\n\nconst defaultStatements = {\n  user: [\n    \"create\",\n    \"list\",\n    \"set-role\",\n    \"ban\",\n    \"impersonate\",\n    \"delete\",\n    \"set-password\",\n    \"get\",\n    \"update\"\n  ],\n  session: [\"list\", \"revoke\", \"delete\"]\n};\nconst defaultAc = createAccessControl(defaultStatements);\nconst adminAc = defaultAc.newRole({\n  user: [\n    \"create\",\n    \"list\",\n    \"set-role\",\n    \"ban\",\n    \"impersonate\",\n    \"delete\",\n    \"set-password\",\n    \"get\",\n    \"update\"\n  ],\n  session: [\"list\", \"revoke\", \"delete\"]\n});\nconst userAc = defaultAc.newRole({\n  user: [],\n  session: []\n});\nconst defaultRoles = {\n  admin: adminAc,\n  user: userAc\n};\n\nexport { adminAc, defaultAc, defaultRoles, defaultStatements, userAc };\n","import { createAccessControl } from '../../access/index.mjs';\nimport '../../../shared/better-auth.DdzSJf-n.mjs';\n\nconst defaultStatements = {\n  organization: [\"update\", \"delete\"],\n  member: [\"create\", \"update\", \"delete\"],\n  invitation: [\"create\", \"cancel\"],\n  team: [\"create\", \"update\", \"delete\"],\n  ac: [\"create\", \"read\", \"update\", \"delete\"]\n};\nconst defaultAc = createAccessControl(defaultStatements);\nconst adminAc = defaultAc.newRole({\n  organization: [\"update\"],\n  invitation: [\"create\", \"cancel\"],\n  member: [\"create\", \"update\", \"delete\"],\n  team: [\"create\", \"update\", \"delete\"],\n  ac: [\"create\", \"read\", \"update\", \"delete\"]\n});\nconst ownerAc = defaultAc.newRole({\n  organization: [\"update\", \"delete\"],\n  member: [\"create\", \"update\", \"delete\"],\n  invitation: [\"create\", \"cancel\"],\n  team: [\"create\", \"update\", \"delete\"],\n  ac: [\"create\", \"read\", \"update\", \"delete\"]\n});\nconst memberAc = defaultAc.newRole({\n  organization: [],\n  member: [],\n  invitation: [],\n  team: [],\n  ac: [\"read\"]\n  // Allow members to see all roles for their org.\n});\nconst defaultRoles = {\n  admin: adminAc,\n  owner: ownerAc,\n  member: memberAc\n};\n\nexport { adminAc, defaultAc, defaultRoles, defaultStatements, memberAc, ownerAc };\n","/**\n * Determine if the browser is capable of Webauthn\n */\nexport function browserSupportsWebAuthn() {\n    return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== undefined &&\n        typeof globalThis.PublicKeyCredential === 'function');\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _browserSupportsWebAuthnInternals = {\n    stubThis: (value) => value,\n};\n","import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine if the browser supports conditional UI, so that WebAuthn credentials can\n * be shown to the user in the browser's typical password autofill popup.\n */\nexport function browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    /**\n     * I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in\n     * TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I\n     * want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types\n     * have a chance to catch up.\n     */\n    const globalPublicKeyCredential = globalThis\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential?.isConditionalMediationAvailable === undefined) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n// Make it possible to stub the return value during testing\nexport const _browserSupportsWebAuthnAutofillInternals = {\n    stubThis: (value) => value,\n};\n","import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`\n */\nexport function identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n","import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`\n */\nexport function identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === 'conditional' &&\n            publicKey.authenticatorSelection?.userVerification === 'required') {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: 'User verification was required during automatic registration but it could not be performed',\n                code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\nexport class OAuthRegisterPayload extends BS.Class<OAuthRegisterPayload>(\"OAuthRegisterPayload\")(\n  {\n    client_name: S.NonEmptyTrimmedString,\n    redirect_uris: S.mutable(S.Array(BS.Url)),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/OAuthRegisterPayload\"),\n    identifier: \"OAuthRegisterPayload\",\n    description: \"Payload for registering a new OAuth2 client.\",\n  }\n) {}\n\nexport declare namespace OAuthRegisterPayload {\n  export type Type = S.Schema.Type<typeof OAuthRegisterPayload>;\n  export type Encoded = S.Schema.Encoded<typeof OAuthRegisterPayload>;\n}\n\nexport const OAuthRegisterContract = Contract.make(\"OAuthRegisterContract\", {\n  description: \"Registers a new OAuth2 application.\",\n  parameters: OAuthRegisterPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const OAuthContractSet = ContractSet.make(OAuthRegisterContract);\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\nexport class SignOutPayload extends BS.Class<SignOutPayload>(\"SignOutPayload\")(\n  {\n    onSuccess: new BS.Fn({\n      input: S.Undefined,\n      output: S.Void,\n    }).Schema,\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SignOutPayload\"),\n    identifier: \"SignOutPayload\",\n    description: \"Payload for signing out the current user.\",\n  }\n) {}\n\nexport declare namespace SignOutPayload {\n  export type Type = S.Schema.Type<typeof SignOutPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SignOutPayload>;\n}\n\nexport const SignOutContract = Contract.make(\"SignOutContract\", {\n  description: \"Signs the current user out of their active session.\",\n  parameters: SignOutPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const SignOutContractSet = ContractSet.make(SignOutContract);\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\nexport const SendOtpPayload = S.Struct({}).annotations({\n  schemaId: Symbol.for(\"@beep/iam-sdk/clients/SendOtpPayload\"),\n  identifier: \"SendOtpPayload\",\n  description: \"Payload for sending a one-time password via the two-factor adapter.\",\n});\n\nexport declare namespace SendOtpPayload {\n  export type Type = S.Schema.Type<typeof SendOtpPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SendOtpPayload>;\n}\n\nexport class VerifyOtpPayload extends BS.Class<VerifyOtpPayload>(\"VerifyOtpPayload\")(\n  {\n    code: S.Redacted(S.String),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/VerifyOtpPayload\"),\n    identifier: \"VerifyOtpPayload\",\n    description: \"Payload containing the OTP verification code.\",\n  }\n) {}\n\nexport declare namespace VerifyOtpPayload {\n  export type Type = S.Schema.Type<typeof VerifyOtpPayload>;\n  export type Encoded = S.Schema.Encoded<typeof VerifyOtpPayload>;\n}\n\nexport class VerifyTotpPayload extends BS.Class<VerifyTotpPayload>(\"VerifyTotpPayload\")(\n  {\n    code: S.Redacted(S.String),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/VerifyTotpPayload\"),\n    identifier: \"VerifyTotpPayload\",\n    description: \"Payload containing the TOTP verification code.\",\n  }\n) {}\n\nexport declare namespace VerifyTotpPayload {\n  export type Type = S.Schema.Type<typeof VerifyTotpPayload>;\n  export type Encoded = S.Schema.Encoded<typeof VerifyTotpPayload>;\n}\n\nexport const SendOtpContract = Contract.make(\"SendOtpContract\", {\n  description: \"Sends a one-time password to the user.\",\n  parameters: SendOtpPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const VerifyOtpContract = Contract.make(\"VerifyOtpContract\", {\n  description: \"Verifies an OTP provided by the user.\",\n  parameters: VerifyOtpPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const VerifyTotpContract = Contract.make(\"VerifyTotpContract\", {\n  description: \"Verifies a TOTP provided by the user.\",\n  parameters: VerifyTotpPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const TwoFactorContractSet = ContractSet.make(SendOtpContract, VerifyOtpContract, VerifyTotpContract);\n","import { Contract, ContractSet } from \"@beep/iam-sdk/contractkit\";\nimport { BS } from \"@beep/schema\";\nimport * as S from \"effect/Schema\";\nimport { IamError } from \"../../errors\";\n\nexport class SendVerifyPhonePayload extends BS.Class<SendVerifyPhonePayload>(\"SendVerifyPhonePayload\")(\n  {\n    phoneNumber: BS.Phone,\n    code: S.Redacted(S.NonEmptyTrimmedString),\n    updatePhoneNumber: BS.BoolWithDefault(true),\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SendVerifyPhonePayload\"),\n    identifier: \"SendVerifyPhonePayload\",\n    description: \"Payload for verifying a user's phone number.\",\n  }\n) {}\n\nexport declare namespace SendVerifyPhonePayload {\n  export type Type = S.Schema.Type<typeof SendVerifyPhonePayload>;\n  export type Encoded = S.Schema.Encoded<typeof SendVerifyPhonePayload.Encoded>;\n}\n\nexport class SendEmailVerificationPayload extends S.Class<SendEmailVerificationPayload>(\"SendEmailVerificationPayload\")(\n  {\n    email: BS.Email,\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/SendEmailVerificationPayload\"),\n    identifier: \"SendEmailVerificationPayload\",\n    description: \"Payload for sending an email verification link.\",\n  }\n) {}\n\nexport declare namespace SendEmailVerificationPayload {\n  export type Type = S.Schema.Type<typeof SendEmailVerificationPayload>;\n  export type Encoded = S.Schema.Encoded<typeof SendEmailVerificationPayload>;\n}\n\nexport class VerifyEmailPayload extends S.Class<VerifyEmailPayload>(\"VerifyEmailPayload\")(\n  {\n    token: S.Redacted(S.String),\n    onFailure: new BS.Fn({\n      input: S.Undefined,\n      output: S.Void,\n    }).Schema,\n    onSuccess: new BS.Fn({\n      input: S.Undefined,\n      output: S.Void,\n    }).Schema,\n  },\n  {\n    schemaId: Symbol.for(\"@beep/iam-sdk/clients/VerifyEmailPayload\"),\n    identifier: \"VerifyEmailPayload\",\n    description: \"Payload for verifying an email address via a token.\",\n  }\n) {}\n\nexport declare namespace VerifyEmailPayload {\n  export type Type = S.Schema.Type<typeof VerifyEmailPayload>;\n  export type Encoded = S.Schema.Encoded<typeof VerifyEmailPayload>;\n}\n\nexport const SendVerifyPhoneContract = Contract.make(\"SendVerifyPhoneContract\", {\n  description: \"Sends a phone verification request.\",\n  parameters: SendVerifyPhonePayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const SendEmailVerificationContract = Contract.make(\"SendEmailVerificationContract\", {\n  description: \"Sends an email verification link to the user.\",\n  parameters: SendEmailVerificationPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const VerifyEmailContract = Contract.make(\"VerifyEmailContract\", {\n  description: \"Verifies a user's email via a token.\",\n  parameters: VerifyEmailPayload.fields,\n  failure: S.instanceOf(IamError),\n  success: S.Void,\n});\n\nexport const VerifyContractSet = ContractSet.make(\n  SendVerifyPhoneContract,\n  SendEmailVerificationContract,\n  VerifyEmailContract\n);\n","import { createFetch } from '@better-fetch/fetch';\nimport { a as getBaseURL } from './better-auth.BRFtaovt.mjs';\nimport { atom } from 'nanostores';\nimport { u as useAuthQuery } from './better-auth.BYWGbmZ5.mjs';\nimport { p as parseJSON } from './better-auth.msGOU0m9.mjs';\n\nconst redirectPlugin = {\n  id: \"redirect\",\n  name: \"Redirect\",\n  hooks: {\n    onSuccess(context) {\n      if (context.data?.url && context.data?.redirect) {\n        if (typeof window !== \"undefined\" && window.location) {\n          if (window.location) {\n            try {\n              window.location.href = context.data.url;\n            } catch {\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction getSessionAtom($fetch) {\n  const $signal = atom(false);\n  const session = useAuthQuery($signal, \"/get-session\", $fetch, {\n    method: \"GET\"\n  });\n  return {\n    session,\n    $sessionSignal: $signal\n  };\n}\n\nconst getClientConfig = (options, loadEnv) => {\n  const isCredentialsSupported = \"credentials\" in Request.prototype;\n  const baseURL = getBaseURL(options?.baseURL, options?.basePath, void 0, loadEnv) ?? \"/api/auth\";\n  const pluginsFetchPlugins = options?.plugins?.flatMap((plugin) => plugin.fetchPlugins).filter((pl) => pl !== void 0) || [];\n  const lifeCyclePlugin = {\n    id: \"lifecycle-hooks\",\n    name: \"lifecycle-hooks\",\n    hooks: {\n      onSuccess: options?.fetchOptions?.onSuccess,\n      onError: options?.fetchOptions?.onError,\n      onRequest: options?.fetchOptions?.onRequest,\n      onResponse: options?.fetchOptions?.onResponse\n    }\n  };\n  const { onSuccess, onError, onRequest, onResponse, ...restOfFetchOptions } = options?.fetchOptions || {};\n  const $fetch = createFetch({\n    baseURL,\n    ...isCredentialsSupported ? { credentials: \"include\" } : {},\n    method: \"GET\",\n    jsonParser(text) {\n      if (!text) {\n        return null;\n      }\n      return parseJSON(text, {\n        strict: false\n      });\n    },\n    customFetchImpl: fetch,\n    ...restOfFetchOptions,\n    plugins: [\n      lifeCyclePlugin,\n      ...restOfFetchOptions.plugins || [],\n      ...options?.disableDefaultFetchPlugins ? [] : [redirectPlugin],\n      ...pluginsFetchPlugins\n    ]\n  });\n  const { $sessionSignal, session } = getSessionAtom($fetch);\n  const plugins = options?.plugins || [];\n  let pluginsActions = {};\n  let pluginsAtoms = {\n    $sessionSignal,\n    session\n  };\n  let pluginPathMethods = {\n    \"/sign-out\": \"POST\",\n    \"/revoke-sessions\": \"POST\",\n    \"/revoke-other-sessions\": \"POST\",\n    \"/delete-user\": \"POST\"\n  };\n  const atomListeners = [\n    {\n      signal: \"$sessionSignal\",\n      matcher(path) {\n        return path === \"/sign-out\" || path === \"/update-user\" || path.startsWith(\"/sign-in\") || path.startsWith(\"/sign-up\") || path === \"/delete-user\" || path === \"/verify-email\";\n      }\n    }\n  ];\n  for (const plugin of plugins) {\n    if (plugin.getAtoms) {\n      Object.assign(pluginsAtoms, plugin.getAtoms?.($fetch));\n    }\n    if (plugin.pathMethods) {\n      Object.assign(pluginPathMethods, plugin.pathMethods);\n    }\n    if (plugin.atomListeners) {\n      atomListeners.push(...plugin.atomListeners);\n    }\n  }\n  const $store = {\n    notify: (signal) => {\n      pluginsAtoms[signal].set(\n        !pluginsAtoms[signal].get()\n      );\n    },\n    listen: (signal, listener) => {\n      pluginsAtoms[signal].subscribe(listener);\n    },\n    atoms: pluginsAtoms\n  };\n  for (const plugin of plugins) {\n    if (plugin.getActions) {\n      Object.assign(\n        pluginsActions,\n        plugin.getActions?.($fetch, $store, options)\n      );\n    }\n  }\n  return {\n    get baseURL() {\n      return baseURL;\n    },\n    pluginsActions,\n    pluginsAtoms,\n    pluginPathMethods,\n    atomListeners,\n    $fetch,\n    $store\n  };\n};\n\nfunction isAtom(value) {\n  return typeof value === \"object\" && value !== null && \"get\" in value && typeof value.get === \"function\" && \"lc\" in value && typeof value.lc === \"number\";\n}\n\nfunction getMethod(path, knownPathMethods, args) {\n  const method = knownPathMethods[path];\n  const { fetchOptions, query, ...body } = args || {};\n  if (method) {\n    return method;\n  }\n  if (fetchOptions?.method) {\n    return fetchOptions.method;\n  }\n  if (body && Object.keys(body).length > 0) {\n    return \"POST\";\n  }\n  return \"GET\";\n}\nfunction createDynamicPathProxy(routes, client, knownPathMethods, atoms, atomListeners) {\n  function createProxy(path = []) {\n    return new Proxy(function() {\n    }, {\n      get(_, prop) {\n        if (typeof prop !== \"string\") {\n          return void 0;\n        }\n        if (prop === \"then\" || prop === \"catch\" || prop === \"finally\") {\n          return void 0;\n        }\n        const fullPath = [...path, prop];\n        let current = routes;\n        for (const segment of fullPath) {\n          if (current && typeof current === \"object\" && segment in current) {\n            current = current[segment];\n          } else {\n            current = void 0;\n            break;\n          }\n        }\n        if (typeof current === \"function\") {\n          return current;\n        }\n        if (isAtom(current)) {\n          return current;\n        }\n        return createProxy(fullPath);\n      },\n      apply: async (_, __, args) => {\n        const routePath = \"/\" + path.map(\n          (segment) => segment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`)\n        ).join(\"/\");\n        const arg = args[0] || {};\n        const fetchOptions = args[1] || {};\n        const { query, fetchOptions: argFetchOptions, ...body } = arg;\n        const options = {\n          ...fetchOptions,\n          ...argFetchOptions\n        };\n        const method = getMethod(routePath, knownPathMethods, arg);\n        return await client(routePath, {\n          ...options,\n          body: method === \"GET\" ? void 0 : {\n            ...body,\n            ...options?.body || {}\n          },\n          query: query || options?.query,\n          method,\n          async onSuccess(context) {\n            await options?.onSuccess?.(context);\n            const matches = atomListeners?.find((s) => s.matcher(routePath));\n            if (!matches) return;\n            const signal = atoms[matches.signal];\n            if (!signal) return;\n            const val = signal.get();\n            setTimeout(() => {\n              signal.set(!val);\n            }, 10);\n          }\n        });\n      }\n    });\n  }\n  return createProxy();\n}\n\nexport { createDynamicPathProxy as c, getClientConfig as g };\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { OrganizationContractSet } from \"@beep/iam-sdk/clients/organization/organization.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport * as Effect from \"effect/Effect\";\nimport type { AcceptInvitationPayload } from \"./organization.contracts\";\n\nconst AcceptInvitationHandler = Effect.fn(\"AcceptInvitationHandler\")(function* (payload: AcceptInvitationPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"AcceptInvitationContract\",\n    metadata: () => ({\n      plugin: \"organization\",\n      method: \"acceptInvitation\",\n    }),\n  });\n\n  const result = yield* continuation.run(() => client.organization.acceptInvitation(payload));\n\n  yield* continuation.raiseResult(result);\n});\n\nexport const OrganizationImplementations = OrganizationContractSet.of({\n  AcceptInvitationContract: AcceptInvitationHandler,\n});\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { SignOutContractSet } from \"@beep/iam-sdk/clients/sign-out/sign-out.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport * as Effect from \"effect/Effect\";\nimport type { SignOutPayload } from \"./sign-out.contracts\";\n\nconst SignOutHandler = Effect.fn(\"SignOutHandler\")(function* (payload: SignOutPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"SignOutContract\",\n    metadata: () => ({\n      plugin: \"core\",\n      method: \"signOut\",\n    }),\n  });\n\n  const result = yield* continuation.run((handlers) =>\n    client.signOut({\n      fetchOptions: handlers.signal\n        ? {\n            signal: handlers.signal,\n            onSuccess: () => payload.onSuccess(undefined),\n            onError: handlers.onError,\n          }\n        : {\n            onSuccess: () => payload.onSuccess(undefined),\n            onError: handlers.onError,\n          },\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n\n  if (result.error == null) {\n    client.$store.notify(\"$sessionSignal\");\n  }\n});\n\nexport const SignOutImplementations = SignOutContractSet.of({\n  SignOutContract: SignOutHandler,\n});\n","/**\n * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various\n * credential response ArrayBuffers to string for sending back to the server as JSON.\n *\n * Helper method to compliment `base64URLStringToBuffer`\n */\nexport function bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { OAuthContractSet } from \"@beep/iam-sdk/clients/oauth/oauth.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport * as Effect from \"effect/Effect\";\nimport * as S from \"effect/Schema\";\nimport { OAuthRegisterPayload } from \"./oauth.contracts\";\n\nconst OAuthRegisterHandler = Effect.fn(\"OAuthRegisterHandler\")(function* (payload: OAuthRegisterPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"OAuthRegisterContract\",\n    metadata: () => ({\n      plugin: \"oauth2\",\n      method: \"register\",\n    }),\n  });\n\n  const encoded = yield* S.encode(OAuthRegisterPayload)(payload).pipe(\n    Effect.catchTag(\"ParseError\", (e) => Effect.dieMessage(e.message))\n  );\n\n  const result = yield* continuation.run(() => client.oauth2.register(encoded));\n\n  yield* continuation.raiseResult(result);\n});\n\nexport const OAuthImplementations = OAuthContractSet.of({\n  OAuthRegisterContract: OAuthRegisterHandler,\n});\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { TwoFactorContractSet } from \"@beep/iam-sdk/clients/two-factor/two-factor.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport * as Effect from \"effect/Effect\";\nimport * as Redacted from \"effect/Redacted\";\nimport type { VerifyOtpPayload, VerifyTotpPayload } from \"./two-factor.contracts\";\n\nconst SendOtpHandler = Effect.fn(\"SendOtpContract\")(function* () {\n  const continuation = makeFailureContinuation({\n    contract: \"SendOtpContract\",\n    metadata: () => ({\n      plugin: \"two-factor\",\n      method: \"sendOtp\",\n    }),\n  });\n\n  const result = yield* continuation.run(() => client.twoFactor.sendOtp());\n\n  yield* continuation.raiseResult(result);\n});\n\nconst VerifyOtpHandler = Effect.fn(\"VerifyOtpHandler\")(function* (payload: VerifyOtpPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"VerifyOtpContract\",\n    metadata: () => ({\n      plugin: \"two-factor\",\n      method: \"verifyOtp\",\n    }),\n  });\n\n  const result = yield* continuation.run(() =>\n    client.twoFactor.verifyOtp({\n      code: Redacted.value(payload.code),\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n});\n\nconst VerifyTotpHandler = Effect.fn(\"VerifyTotpHandler\")(function* (payload: VerifyTotpPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"VerifyTotpContract\",\n    metadata: () => ({\n      plugin: \"two-factor\",\n      method: \"verifyTotp\",\n    }),\n  });\n\n  const result = yield* continuation.run(() =>\n    client.twoFactor.verifyTotp({\n      code: Redacted.value(payload.code),\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n});\n\nexport const TwoFactorImplementations = TwoFactorContractSet.of({\n  SendOtpContract: SendOtpHandler,\n  VerifyOtpContract: VerifyOtpHandler,\n  VerifyTotpContract: VerifyTotpHandler,\n});\n","import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine whether the browser can communicate with a built-in authenticator, like\n * Touch ID, Android fingerprint scanner, or Windows Hello.\n *\n * This method will _not_ be able to tell you the name of the platform authenticator.\n */\nexport function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n","/**\n * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a\n * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or\n * excludeCredentials\n *\n * Helper method to compliment `bufferToBase64URLString`\n */\nexport function base64URLStringToBuffer(base64URLString) {\n    // Convert from Base64URL to Base64\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    /**\n     * Pad with '=' until it's a multiple of four\n     * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding\n     * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding\n     * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding\n     * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding\n     */\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    // Convert to a binary string\n    const binary = atob(padded);\n    // Convert binary string to buffer\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { SignUpContractSet } from \"@beep/iam-sdk/clients/sign-up/sign-up.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport { paths } from \"@beep/shared-domain\";\nimport * as Effect from \"effect/Effect\";\nimport * as Redacted from \"effect/Redacted\";\nimport type { SignUpEmailPayload } from \"./sign-up.contracts\";\n\nconst SignUpEmailHandler = Effect.fn(\"SignUpEmailHandler\")(function* (payload: SignUpEmailPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"SignUpEmail\",\n    metadata: () => ({\n      plugin: \"signUp\",\n      method: \"email\",\n    }),\n  });\n\n  const { value, onSuccess } = payload;\n  const { captchaResponse, ...rest } = value;\n\n  const result = yield* continuation.run((handlers) =>\n    client.signUp.email({\n      ...rest,\n      fetchOptions: handlers.signal\n        ? {\n            headers: {\n              \"x-captcha-response\": Redacted.value(captchaResponse),\n            },\n            onSuccess: () => onSuccess(paths.dashboard.root),\n            onError: handlers.onError,\n            signal: handlers.signal,\n          }\n        : {\n            headers: {\n              \"x-captcha-response\": Redacted.value(captchaResponse),\n            },\n            onSuccess: () => onSuccess(paths.dashboard.root),\n            onError: handlers.onError,\n          },\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n\n  if (result.error == null) {\n    client.$store.notify(\"$sessionSignal\");\n  }\n\n  return result.error ? ({ _tag: \"Failure\" } as const) : ({ _tag: \"Success\" } as const);\n});\n\nexport const SignUpImplementations = SignUpContractSet.of({\n  SignUpEmail: SignUpEmailHandler,\n});\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { VerifyContractSet } from \"@beep/iam-sdk/clients/verify/verify.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport * as Effect from \"effect/Effect\";\nimport * as Redacted from \"effect/Redacted\";\n\nimport type { SendEmailVerificationPayload, SendVerifyPhonePayload, VerifyEmailPayload } from \"./verify.contracts\";\n\nconst SendEmailVerificationHandler = Effect.fn(\"SendEmailVerificationHandler\")(function* (\n  payload: SendEmailVerificationPayload.Type\n) {\n  const continuation = makeFailureContinuation({\n    contract: \"SendEmailVerificationContract\",\n    metadata: () => ({\n      plugin: \"verification\",\n      method: \"sendVerificationEmail\",\n    }),\n  });\n\n  const result = yield* continuation.run((handlers) =>\n    client.sendVerificationEmail({\n      email: Redacted.value(payload.email),\n      fetchOptions: handlers.signal\n        ? {\n            onError: handlers.onError,\n            signal: handlers.signal,\n          }\n        : {\n            onError: handlers.onError,\n          },\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n});\n\nconst VerifyEmailHandler = Effect.fn(\"VerifyEmailHandler\")(function* (payload: VerifyEmailPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"VerifyEmailContract\",\n    metadata: () => ({\n      plugin: \"verification\",\n      method: \"verifyEmail\",\n    }),\n  });\n\n  const result = yield* continuation.run((handlers) =>\n    client.verifyEmail(\n      {\n        query: {\n          token: Redacted.value(payload.token),\n        },\n      },\n      handlers.signal\n        ? {\n            signal: handlers.signal,\n            onSuccess: () => {\n              payload.onSuccess(undefined);\n            },\n            onError: (ctx) => {\n              payload.onFailure(undefined);\n              handlers.onError(ctx);\n            },\n          }\n        : {\n            onSuccess: () => {\n              payload.onSuccess(undefined);\n            },\n            onError: (ctx) => {\n              payload.onFailure(undefined);\n              handlers.onError(ctx);\n            },\n          }\n    )\n  );\n\n  yield* continuation.raiseResult(result);\n});\n\nconst SendVerifyPhoneHandler = Effect.fn(\"SendVerifyPhoneHandler\")(function* (payload: SendVerifyPhonePayload.Type) {\n  const { phoneNumber, code, updatePhoneNumber } = payload;\n  const continuation = makeFailureContinuation({\n    contract: \"SendVerifyPhoneContract\",\n    metadata: () => ({\n      plugin: \"verification\",\n      method: \"phone\",\n    }),\n  });\n\n  const result = yield* continuation.run(() =>\n    client.phoneNumber.verify({\n      phoneNumber: Redacted.value(phoneNumber),\n      code: Redacted.value(code),\n      updatePhoneNumber: updatePhoneNumber,\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n});\n\nexport const VerifyImplementations = VerifyContractSet.of({\n  SendVerifyPhoneContract: SendVerifyPhoneHandler,\n  SendEmailVerificationContract: SendEmailVerificationHandler,\n  VerifyEmailContract: VerifyEmailHandler,\n});\n","/**\n * A simple test to determine if a hostname is a properly-formatted domain name\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n */\nexport function isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { RecoverContractSet } from \"@beep/iam-sdk/clients/recover/recover.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport { IamError } from \"@beep/iam-sdk/errors\";\nimport * as Effect from \"effect/Effect\";\nimport * as O from \"effect/Option\";\nimport * as S from \"effect/Schema\";\nimport { RequestResetPasswordPayload, ResetPasswordPayload } from \"./recover.contracts\";\n\nconst ResetPasswordHandler = Effect.fn(\"ResetPasswordHandler\")(function* (payload: ResetPasswordPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"ResetPasswordContract\",\n    metadata: () => ({\n      plugin: \"reset-password\",\n      method: \"submit\",\n    }),\n  });\n\n  const token = new URLSearchParams(window.location.search).get(\"token\");\n  const tokenOption = O.fromNullable(token);\n\n  if (O.isNone(tokenOption)) {\n    return yield* Effect.fail(\n      new IamError(\n        {\n          id: \"reset-password-token\",\n          resource: \"reset-password-token\",\n        },\n        \"No token found\",\n        {\n          plugin: \"reset-password\",\n          method: \"submit\",\n        }\n      )\n    );\n  }\n\n  const encoded = yield* S.encode(ResetPasswordPayload)(payload).pipe(\n    Effect.catchTag(\"ParseError\", (e) => Effect.dieMessage(e.message))\n  );\n\n  const result = yield* continuation.run(() =>\n    client.resetPassword({\n      newPassword: encoded.newPassword,\n      token: tokenOption.value,\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n});\n\nconst RequestPasswordResetHandler = Effect.fn(\"RequestPasswordResetHandler\")(function* (\n  payload: RequestResetPasswordPayload.Type\n) {\n  const continuation = makeFailureContinuation({\n    contract: \"RequestResetPasswordContract\",\n    metadata: () => ({\n      plugin: \"reset-password\",\n      method: \"request\",\n    }),\n  });\n\n  const encoded = yield* S.encode(RequestResetPasswordPayload)(payload).pipe(\n    Effect.catchTag(\"ParseError\", (e) => Effect.dieMessage(e.message))\n  );\n\n  const result = yield* continuation.run(() => client.requestPasswordReset(encoded));\n\n  yield* continuation.raiseResult(result);\n});\n\nexport const RecoverImplementations = RecoverContractSet.of({\n  ResetPasswordContract: ResetPasswordHandler,\n  RequestResetPasswordContract: RequestPasswordResetHandler,\n});\n","import { client } from \"@beep/iam-sdk/adapters\";\nimport { SignInContractSet } from \"@beep/iam-sdk/clients/sign-in/sign-in.contracts\";\nimport { makeFailureContinuation } from \"@beep/iam-sdk/contractkit\";\nimport * as Effect from \"effect/Effect\";\nimport * as Redacted from \"effect/Redacted\";\nimport type {\n  SignInEmailPayload,\n  SignInPhoneNumberPayload,\n  SignInSocialPayload,\n  SignInUsernamePayload,\n} from \"./sign-in.contracts\";\n\nconst SignInSocialHandler = Effect.fn(\"SignInSocialHandler\")(function* (payload: SignInSocialPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"SignInSocial\",\n    metadata: () => ({\n      plugin: \"signIn\",\n      method: \"social\",\n    }),\n  });\n  yield* Effect.flatMap(\n    continuation.run((handlers) =>\n      client.signIn.social(\n        {\n          provider: payload.provider,\n          callbackURL: payload.callbackURL,\n        },\n        handlers.signal\n          ? {\n              onError: handlers.onError,\n              signal: handlers.signal,\n            }\n          : {\n              onError: handlers.onError,\n            }\n      )\n    ),\n    continuation.raiseResult\n  );\n});\n\nconst SignInEmailHandler = Effect.fn(\"SignInEmailHandler\")(function* (payload: SignInEmailPayload.Type) {\n  const continuation = makeFailureContinuation({\n    contract: \"SignInEmail\",\n    metadata: () => ({\n      plugin: \"signIn\",\n      method: \"email\",\n    }),\n  });\n\n  const result = yield* continuation.run((handlers) =>\n    client.signIn.email({\n      email: Redacted.value(payload.email),\n      password: Redacted.value(payload.password),\n      rememberMe: payload.rememberMe,\n      fetchOptions: handlers.signal\n        ? {\n            headers: {\n              \"x-captcha-response\": Redacted.value(payload.captchaResponse),\n            },\n            onError: handlers.onError,\n            signal: handlers.signal,\n          }\n        : {\n            headers: {\n              \"x-captcha-response\": Redacted.value(payload.captchaResponse),\n            },\n            onError: handlers.onError,\n          },\n    })\n  );\n\n  yield* continuation.raiseResult(result);\n\n  if (result.error == null) {\n    client.$store.notify(\"$sessionSignal\");\n  }\n});\n\nconst SignInUsernameHandler = Effect.fn(\"SignInUsernameHandler\")(function* (payload: SignInUsernamePayload.Type) {\n  const { username, password, rememberMe, captchaResponse, callbackURL } = payload;\n\n  const continuation = makeFailureContinuation({\n    contract: \"SignInUsername\",\n    metadata: () => ({\n      plugin: \"signIn\",\n      method: \"username\",\n    }),\n  });\n  yield* Effect.flatMap(\n    continuation.run((handlers) =>\n      client.signIn.username({\n        username: username,\n        password: Redacted.value(password),\n        rememberMe: rememberMe,\n        callbackURL: callbackURL,\n        fetchOptions: handlers.signal\n          ? {\n              headers: {\n                \"x-captcha-response\": Redacted.value(captchaResponse),\n              },\n              onError: handlers.onError,\n              signal: handlers.signal,\n            }\n          : {\n              headers: {\n                \"x-captcha-response\": Redacted.value(captchaResponse),\n              },\n              onError: handlers.onError,\n            },\n      })\n    ),\n    (result) => {\n      if (result.error == null) {\n        client.$store.notify(\"$sessionSignal\");\n      }\n      return continuation.raiseResult(result);\n    }\n  );\n});\n\nconst SignInPhoneNumberHandler = Effect.fn(\"SignInPhoneNumberHandler\")(function* (\n  payload: SignInPhoneNumberPayload.Type\n) {\n  const continuation = makeFailureContinuation({\n    contract: \"SignInUsername\",\n    metadata: () => ({\n      plugin: \"signIn\",\n      method: \"phoneNumber\",\n    }),\n  });\n  yield* Effect.flatMap(\n    continuation.run((handlers) =>\n      client.signIn.phoneNumber({\n        phoneNumber: Redacted.value(payload.phoneNumber),\n        password: Redacted.value(payload.password),\n        rememberMe: payload.rememberMe,\n        fetchOptions: handlers.signal\n          ? {\n              headers: {\n                \"x-captcha-response\": Redacted.value(payload.captchaResponse),\n              },\n              onError: handlers.onError,\n              signal: handlers.signal,\n            }\n          : {\n              headers: {\n                \"x-captcha-response\": Redacted.value(payload.captchaResponse),\n              },\n              onError: handlers.onError,\n            },\n      })\n    ),\n    (result) => {\n      if (result.error == null) {\n        client.$store.notify(\"$sessionSignal\");\n      }\n      return continuation.raiseResult(result);\n    }\n  );\n});\n\nconst SignInOneTapHandler = Effect.fn(\"SignInOneTapHandler\")(function* () {\n  const continuation = makeFailureContinuation({\n    contract: \"SignInOneTap\",\n    metadata: () => ({\n      plugin: \"oneTap\",\n      method: \"signIn\",\n    }),\n  });\n  yield* continuation.run((handlers) =>\n    client.oneTap({\n      fetchOptions: handlers.signal\n        ? {\n            onError: handlers.onError,\n            signal: handlers.signal,\n          }\n        : { onError: handlers.onError },\n    })\n  );\n});\n\nconst SignInPasskeyHandler = Effect.fn(\"SignInPasskey\")(function* () {\n  const continuation = makeFailureContinuation({\n    contract: \"SignInPasskey\",\n    metadata: () => ({\n      plugin: \"signIn\",\n      method: \"passkey\",\n    }),\n  });\n\n  yield* Effect.flatMap(\n    continuation.run((handlers) =>\n      client.signIn.passkey({\n        fetchOptions: handlers.signal\n          ? {\n              onError: handlers.onError,\n              signal: handlers.signal,\n            }\n          : { onError: handlers.onError },\n      })\n    ),\n    (result) => {\n      if (result.error == null) {\n        client.$store.notify(\"$sessionSignal\");\n      }\n      return continuation.raiseResult(result);\n    }\n  );\n});\n\nexport const SignInImplementations = SignInContractSet.of({\n  SignInEmail: SignInEmailHandler,\n  SignInSocial: SignInSocialHandler,\n  SignInPhoneNumber: SignInPhoneNumberHandler,\n  SignInUsername: SignInUsernameHandler,\n  SignInPasskey: SignInPasskeyHandler,\n  SignInOneTap: SignInOneTapHandler,\n});\n","import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyRegistrationError } from '../helpers/identifyRegistrationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"registration\" via WebAuthn attestation\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`\n * @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.\n */\nexport async function startRegistration(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useAutoRegister = false } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    // Prepare options for `.create()`\n    const createOptions = {};\n    /**\n     * Try to use conditional create to register a passkey for the user with the password manager\n     * the user just used to authenticate with. The user won't be shown any prominent UI by the\n     * browser.\n     */\n    if (useAutoRegister) {\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        createOptions.mediation = 'conditional';\n    }\n    // Finalize options\n    createOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    createOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete attestation\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(createOptions));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options: createOptions });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    // Continue to play it safe with `getTransports()` for now, even when L3 types say it's required\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n/**\n * Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API\n * calls\n */\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n","import { atom } from 'nanostores';\nimport '@better-fetch/fetch';\nimport '../../shared/better-auth.CiuwFiHM.mjs';\nimport { u as useAuthQuery } from '../../shared/better-auth.BYWGbmZ5.mjs';\nimport { defaultRoles, ownerAc, memberAc, adminAc } from '../../plugins/organization/access/index.mjs';\nimport { h as hasPermissionFn } from '../../shared/better-auth.DaEBQJp_.mjs';\nimport { startRegistration, WebAuthnError, startAuthentication } from '@simplewebauthn/browser';\nexport { t as twoFactorClient } from '../../shared/better-auth.Ddw8bVyV.mjs';\nimport { userAc, adminAc as adminAc$1 } from '../../plugins/admin/access/index.mjs';\nimport { h as hasPermission } from '../../shared/better-auth.bkwPl2G4.mjs';\nexport { d as deviceAuthorizationClient } from '../../shared/better-auth.BpA03GIs.mjs';\nimport '../../plugins/access/index.mjs';\nimport '../../shared/better-auth.DdzSJf-n.mjs';\n\nconst clientSideHasPermission = (input) => {\n  const acRoles = input.options.roles || defaultRoles;\n  return hasPermissionFn(input, acRoles);\n};\nconst organizationClient = (options) => {\n  const $listOrg = atom(false);\n  const $activeOrgSignal = atom(false);\n  const $activeMemberSignal = atom(false);\n  const $activeMemberRoleSignal = atom(false);\n  const roles = {\n    admin: adminAc,\n    member: memberAc,\n    owner: ownerAc,\n    ...options?.roles\n  };\n  return {\n    id: \"organization\",\n    $InferServerPlugin: {},\n    getActions: ($fetch, _$store, co) => ({\n      $Infer: {\n        ActiveOrganization: {},\n        Organization: {},\n        Invitation: {},\n        Member: {},\n        Team: {}\n      },\n      organization: {\n        checkRolePermission: (data) => {\n          const isAuthorized = clientSideHasPermission({\n            role: data.role,\n            options: {\n              ac: options?.ac,\n              roles\n            },\n            permissions: data.permissions ?? data.permission\n          });\n          return isAuthorized;\n        }\n      }\n    }),\n    getAtoms: ($fetch) => {\n      const listOrganizations = useAuthQuery(\n        $listOrg,\n        \"/organization/list\",\n        $fetch,\n        {\n          method: \"GET\"\n        }\n      );\n      const activeOrganization = useAuthQuery(\n        [$activeOrgSignal],\n        \"/organization/get-full-organization\",\n        $fetch,\n        () => ({\n          method: \"GET\"\n        })\n      );\n      const activeMember = useAuthQuery(\n        [$activeMemberSignal],\n        \"/organization/get-active-member\",\n        $fetch,\n        {\n          method: \"GET\"\n        }\n      );\n      const activeMemberRole = useAuthQuery(\n        [$activeMemberRoleSignal],\n        \"/organization/get-active-member-role\",\n        $fetch,\n        {\n          method: \"GET\"\n        }\n      );\n      return {\n        $listOrg,\n        $activeOrgSignal,\n        $activeMemberSignal,\n        $activeMemberRoleSignal,\n        activeOrganization,\n        listOrganizations,\n        activeMember,\n        activeMemberRole\n      };\n    },\n    pathMethods: {\n      \"/organization/get-full-organization\": \"GET\",\n      \"/organization/list-user-teams\": \"GET\"\n    },\n    atomListeners: [\n      {\n        matcher(path) {\n          return path === \"/organization/create\" || path === \"/organization/delete\" || path === \"/organization/update\";\n        },\n        signal: \"$listOrg\"\n      },\n      {\n        matcher(path) {\n          return path.startsWith(\"/organization\");\n        },\n        signal: \"$activeOrgSignal\"\n      },\n      {\n        matcher(path) {\n          return path.startsWith(\"/organization/set-active\");\n        },\n        signal: \"$sessionSignal\"\n      },\n      {\n        matcher(path) {\n          return path.includes(\"/organization/update-member-role\");\n        },\n        signal: \"$activeMemberSignal\"\n      },\n      {\n        matcher(path) {\n          return path.includes(\"/organization/update-member-role\");\n        },\n        signal: \"$activeMemberRoleSignal\"\n      }\n    ]\n  };\n};\nconst inferOrgAdditionalFields = (schema) => {\n  return {};\n};\n\nconst usernameClient = () => {\n  return {\n    id: \"username\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst getPasskeyActions = ($fetch, {\n  $listPasskeys\n}) => {\n  const signInPasskey = async (opts, options) => {\n    const response = await $fetch(\n      \"/passkey/generate-authenticate-options\",\n      {\n        method: \"POST\"\n      }\n    );\n    if (!response.data) {\n      return response;\n    }\n    try {\n      const res = await startAuthentication({\n        optionsJSON: response.data,\n        useBrowserAutofill: opts?.autoFill\n      });\n      const verified = await $fetch(\"/passkey/verify-authentication\", {\n        body: {\n          response: res\n        },\n        ...opts?.fetchOptions,\n        ...options,\n        method: \"POST\"\n      });\n      return verified;\n    } catch (e) {\n      return {\n        data: null,\n        error: {\n          code: \"AUTH_CANCELLED\",\n          message: \"auth cancelled\",\n          status: 400,\n          statusText: \"BAD_REQUEST\"\n        }\n      };\n    }\n  };\n  const registerPasskey = async (opts, fetchOpts) => {\n    const options = await $fetch(\n      \"/passkey/generate-register-options\",\n      {\n        method: \"GET\",\n        query: {\n          ...opts?.authenticatorAttachment && {\n            authenticatorAttachment: opts.authenticatorAttachment\n          },\n          ...opts?.name && {\n            name: opts.name\n          }\n        }\n      }\n    );\n    if (!options.data) {\n      return options;\n    }\n    try {\n      const res = await startRegistration({\n        optionsJSON: options.data,\n        useAutoRegister: opts?.useAutoRegister\n      });\n      const verified = await $fetch(\"/passkey/verify-registration\", {\n        ...opts?.fetchOptions,\n        ...fetchOpts,\n        body: {\n          response: res,\n          name: opts?.name\n        },\n        method: \"POST\"\n      });\n      if (!verified.data) {\n        return verified;\n      }\n      $listPasskeys.set(Math.random());\n    } catch (e) {\n      if (e instanceof WebAuthnError) {\n        if (e.code === \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\") {\n          return {\n            data: null,\n            error: {\n              code: e.code,\n              message: \"previously registered\",\n              status: 400,\n              statusText: \"BAD_REQUEST\"\n            }\n          };\n        }\n        if (e.code === \"ERROR_CEREMONY_ABORTED\") {\n          return {\n            data: null,\n            error: {\n              code: e.code,\n              message: \"registration cancelled\",\n              status: 400,\n              statusText: \"BAD_REQUEST\"\n            }\n          };\n        }\n        return {\n          data: null,\n          error: {\n            code: e.code,\n            message: e.message,\n            status: 400,\n            statusText: \"BAD_REQUEST\"\n          }\n        };\n      }\n      return {\n        data: null,\n        error: {\n          code: \"UNKNOWN_ERROR\",\n          message: e instanceof Error ? e.message : \"unknown error\",\n          status: 500,\n          statusText: \"INTERNAL_SERVER_ERROR\"\n        }\n      };\n    }\n  };\n  return {\n    signIn: {\n      /**\n       * Sign in with a registered passkey\n       */\n      passkey: signInPasskey\n    },\n    passkey: {\n      /**\n       * Add a passkey to the user account\n       */\n      addPasskey: registerPasskey\n    },\n    /**\n     * Inferred Internal Types\n     */\n    $Infer: {}\n  };\n};\nconst passkeyClient = () => {\n  const $listPasskeys = atom();\n  return {\n    id: \"passkey\",\n    $InferServerPlugin: {},\n    getActions: ($fetch) => getPasskeyActions($fetch, {\n      $listPasskeys\n    }),\n    getAtoms($fetch) {\n      const listPasskeys = useAuthQuery(\n        $listPasskeys,\n        \"/passkey/list-user-passkeys\",\n        $fetch,\n        {\n          method: \"GET\"\n        }\n      );\n      return {\n        listPasskeys,\n        $listPasskeys\n      };\n    },\n    pathMethods: {\n      \"/passkey/register\": \"POST\",\n      \"/passkey/authenticate\": \"POST\"\n    },\n    atomListeners: [\n      {\n        matcher(path) {\n          return path === \"/passkey/verify-registration\" || path === \"/passkey/delete-passkey\" || path === \"/passkey/update-passkey\";\n        },\n        signal: \"_listPasskeys\"\n      }\n    ]\n  };\n};\n\nconst magicLinkClient = () => {\n  return {\n    id: \"magic-link\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst phoneNumberClient = () => {\n  return {\n    id: \"phoneNumber\",\n    $InferServerPlugin: {},\n    atomListeners: [\n      {\n        matcher(path) {\n          return path === \"/phone-number/update\" || path === \"/phone-number/verify\";\n        },\n        signal: \"$sessionSignal\"\n      }\n    ]\n  };\n};\n\nconst anonymousClient = () => {\n  return {\n    id: \"anonymous\",\n    $InferServerPlugin: {},\n    pathMethods: {\n      \"/sign-in/anonymous\": \"POST\"\n    }\n  };\n};\n\nconst inferAdditionalFields = (schema) => {\n  return {\n    id: \"additional-fields-client\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst adminClient = (options) => {\n  const roles = {\n    admin: adminAc$1,\n    user: userAc,\n    ...options?.roles\n  };\n  return {\n    id: \"admin-client\",\n    $InferServerPlugin: {},\n    getActions: () => ({\n      admin: {\n        checkRolePermission: (data) => {\n          const isAuthorized = hasPermission({\n            role: data.role,\n            options: {\n              ac: options?.ac,\n              roles\n            },\n            permissions: data.permissions ?? data.permission\n          });\n          return isAuthorized;\n        }\n      }\n    }),\n    pathMethods: {\n      \"/admin/list-users\": \"GET\",\n      \"/admin/stop-impersonating\": \"POST\"\n    }\n  };\n};\n\nconst genericOAuthClient = () => {\n  return {\n    id: \"generic-oauth-client\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst jwtClient = () => {\n  return {\n    id: \"better-auth-client\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst multiSessionClient = () => {\n  return {\n    id: \"multi-session\",\n    $InferServerPlugin: {},\n    atomListeners: [\n      {\n        matcher(path) {\n          return path === \"/multi-session/set-active\";\n        },\n        signal: \"$sessionSignal\"\n      }\n    ]\n  };\n};\n\nconst emailOTPClient = () => {\n  return {\n    id: \"email-otp\",\n    $InferServerPlugin: {}\n  };\n};\n\nlet isRequestInProgress = false;\nconst oneTapClient = (options) => {\n  return {\n    id: \"one-tap\",\n    getActions: ($fetch, _) => ({\n      oneTap: async (opts, fetchOptions) => {\n        if (isRequestInProgress) {\n          console.warn(\n            \"A Google One Tap request is already in progress. Please wait.\"\n          );\n          return;\n        }\n        isRequestInProgress = true;\n        try {\n          if (typeof window === \"undefined\" || !window.document) {\n            console.warn(\n              \"Google One Tap is only available in browser environments\"\n            );\n            return;\n          }\n          const { autoSelect, cancelOnTapOutside, context } = opts ?? {};\n          const contextValue = context ?? options.context ?? \"signin\";\n          await loadGoogleScript();\n          await new Promise((resolve, reject) => {\n            let isResolved = false;\n            const baseDelay = options.promptOptions?.baseDelay ?? 1e3;\n            const maxAttempts = options.promptOptions?.maxAttempts ?? 5;\n            window.google?.accounts.id.initialize({\n              client_id: options.clientId,\n              callback: async (response) => {\n                isResolved = true;\n                try {\n                  await $fetch(\"/one-tap/callback\", {\n                    method: \"POST\",\n                    body: { idToken: response.credential },\n                    ...opts?.fetchOptions,\n                    ...fetchOptions\n                  });\n                  if (!opts?.fetchOptions && !fetchOptions || opts?.callbackURL) {\n                    window.location.href = opts?.callbackURL ?? \"/\";\n                  }\n                  resolve();\n                } catch (error) {\n                  console.error(\"Error during One Tap callback:\", error);\n                  reject(error);\n                }\n              },\n              auto_select: autoSelect,\n              cancel_on_tap_outside: cancelOnTapOutside,\n              context: contextValue,\n              ...options.additionalOptions\n            });\n            const handlePrompt = (attempt) => {\n              if (isResolved) return;\n              window.google?.accounts.id.prompt((notification) => {\n                if (isResolved) return;\n                if (notification.isDismissedMoment && notification.isDismissedMoment()) {\n                  if (attempt < maxAttempts) {\n                    const delay = Math.pow(2, attempt) * baseDelay;\n                    setTimeout(() => handlePrompt(attempt + 1), delay);\n                  } else {\n                    opts?.onPromptNotification?.(notification);\n                  }\n                } else if (notification.isSkippedMoment && notification.isSkippedMoment()) {\n                  if (attempt < maxAttempts) {\n                    const delay = Math.pow(2, attempt) * baseDelay;\n                    setTimeout(() => handlePrompt(attempt + 1), delay);\n                  } else {\n                    opts?.onPromptNotification?.(notification);\n                  }\n                }\n              });\n            };\n            handlePrompt(0);\n          });\n        } catch (error) {\n          console.error(\"Error during Google One Tap flow:\", error);\n          throw error;\n        } finally {\n          isRequestInProgress = false;\n        }\n      }\n    }),\n    getAtoms($fetch) {\n      return {};\n    }\n  };\n};\nconst loadGoogleScript = () => {\n  return new Promise((resolve) => {\n    if (window.googleScriptInitialized) {\n      resolve();\n      return;\n    }\n    const script = document.createElement(\"script\");\n    script.src = \"https://accounts.google.com/gsi/client\";\n    script.async = true;\n    script.defer = true;\n    script.onload = () => {\n      window.googleScriptInitialized = true;\n      resolve();\n    };\n    document.head.appendChild(script);\n  });\n};\n\nconst customSessionClient = () => {\n  return InferServerPlugin();\n};\n\nconst InferServerPlugin = () => {\n  return {\n    id: \"infer-server-plugin\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst ssoClient = () => {\n  return {\n    id: \"sso-client\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst oidcClient = () => {\n  return {\n    id: \"oidc-client\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst apiKeyClient = () => {\n  return {\n    id: \"api-key\",\n    $InferServerPlugin: {},\n    pathMethods: {\n      \"/api-key/create\": \"POST\",\n      \"/api-key/delete\": \"POST\",\n      \"/api-key/delete-all-expired-api-keys\": \"POST\"\n    }\n  };\n};\n\nconst oneTimeTokenClient = () => {\n  return {\n    id: \"one-time-token\",\n    $InferServerPlugin: {}\n  };\n};\n\nconst siweClient = () => {\n  return {\n    id: \"siwe\",\n    $InferServerPlugin: {}\n  };\n};\n\nfunction getCookieValue(name) {\n  if (typeof document === \"undefined\") {\n    return null;\n  }\n  const cookie = document.cookie.split(\"; \").find((row) => row.startsWith(`${name}=`));\n  return cookie ? cookie.split(\"=\")[1] : null;\n}\nconst lastLoginMethodClient = (config = {}) => {\n  const cookieName = config.cookieName || \"better-auth.last_used_login_method\";\n  return {\n    id: \"last-login-method-client\",\n    getActions() {\n      return {\n        /**\n         * Get the last used login method from cookies\n         * @returns The last used login method or null if not found\n         */\n        getLastUsedLoginMethod: () => {\n          return getCookieValue(cookieName);\n        },\n        /**\n         * Clear the last used login method cookie\n         * This sets the cookie with an expiration date in the past\n         */\n        clearLastUsedLoginMethod: () => {\n          if (typeof document !== \"undefined\") {\n            document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;\n          }\n        },\n        /**\n         * Check if a specific login method was the last used\n         * @param method The method to check\n         * @returns True if the method was the last used, false otherwise\n         */\n        isLastUsedLoginMethod: (method) => {\n          const lastMethod = getCookieValue(cookieName);\n          return lastMethod === method;\n        }\n      };\n    }\n  };\n};\n\nexport { InferServerPlugin, adminClient, anonymousClient, apiKeyClient, clientSideHasPermission, customSessionClient, emailOTPClient, genericOAuthClient, getPasskeyActions, inferAdditionalFields, inferOrgAdditionalFields, jwtClient, lastLoginMethodClient, magicLinkClient, multiSessionClient, oidcClient, oneTapClient, oneTimeTokenClient, organizationClient, passkeyClient, phoneNumberClient, siweClient, ssoClient, usernameClient };\n","import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to avoid passing empty array to avoid blocking retrieval\n    // of public key\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    // Prepare options for `.get()`\n    const getOptions = {};\n    /**\n     * Set up the page to prompt the user to select a credential for authentication via the browser's\n     * input autofill mechanism.\n     */\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        // WebAuthn autofill requires at least one valid input\n        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n        // typescript@4.6.3\n        getOptions.mediation = 'conditional';\n        // Conditional UI requires an empty allow list\n        publicKey.allowCredentials = [];\n    }\n    // Finalize options\n    getOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete assertion\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(getOptions));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options: getOptions });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    // Convert values to base64 to make it easier to send back to the server\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n","/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */\nexport class WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, { cause });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n","import * as Effect from \"effect/Effect\";\nimport { IamError, type IamErrorMetadata } from \"../errors\";\n\nexport interface FailureContinuationContext {\n  readonly contract: string;\n  readonly metadata: () => Readonly<{\n    readonly plugin: string;\n    readonly method: string;\n  }>;\n}\n\nexport interface FailureContinuationOptions {\n  readonly supportsAbort?: boolean;\n}\n\nexport interface FailureContinuationHandlers {\n  readonly signal?: AbortSignal;\n  readonly onError: (ctx: { readonly error: unknown }) => void;\n}\n\nexport interface FailureContinuation {\n  readonly run: <A>(register: (handlers: FailureContinuationHandlers) => Promise<A>) => Effect.Effect<A, FailureError>;\n  readonly raiseResult: (result: { readonly error: unknown | null | undefined }) => Effect.Effect<void, FailureError>;\n}\n\ntype FailureError = InstanceType<typeof IamError>;\n\nexport const makeFailureContinuation = (\n  ctx: FailureContinuationContext,\n  options: FailureContinuationOptions = {}\n): FailureContinuation => {\n  const supportsAbort = options.supportsAbort ?? false;\n\n  const computeMetadata = (): IamErrorMetadata => {\n    const metadata = ctx.metadata();\n    return {\n      plugin: metadata.plugin,\n      method: metadata.method,\n    };\n  };\n\n  const normalize = (error: unknown): FailureError => IamError.match(error, computeMetadata());\n\n  const annotate = <R, E, A>(effect: Effect.Effect<A, E, R>, metadata: IamErrorMetadata) =>\n    effect.pipe(\n      Effect.annotateLogs({\n        contract: ctx.contract,\n        plugin: metadata.plugin,\n        method: metadata.method,\n      })\n    );\n\n  const run: FailureContinuation[\"run\"] = <A>(register: (handlers: FailureContinuationHandlers) => Promise<A>) => {\n    const metadata = computeMetadata();\n    const effect = Effect.async<A, FailureError>((resume) => {\n      const controller = supportsAbort ? new AbortController() : undefined;\n      let settled = false;\n\n      const complete = (result: Effect.Effect<A, FailureError>): void => {\n        if (settled) {\n          return;\n        }\n        settled = true;\n        if (supportsAbort && controller && !controller.signal.aborted) {\n          controller.abort();\n        }\n        resume(result);\n      };\n\n      const handlers: FailureContinuationHandlers = controller\n        ? {\n            signal: controller.signal,\n            onError: ({ error }) => {\n              complete(Effect.fail(normalize(error)));\n            },\n          }\n        : {\n            onError: ({ error }) => {\n              complete(Effect.fail(normalize(error)));\n            },\n          };\n\n      try {\n        const promise = register(handlers);\n        promise.then(\n          (value) => {\n            complete(Effect.succeed(value));\n          },\n          (reason) => {\n            complete(Effect.fail(normalize(reason)));\n          }\n        );\n      } catch (cause) {\n        complete(Effect.fail(normalize(cause)));\n      }\n\n      if (supportsAbort) {\n        return Effect.sync(() => {\n          if (controller && !controller.signal.aborted) {\n            controller.abort();\n          }\n        });\n      }\n    });\n\n    return annotate(effect, metadata);\n  };\n\n  const raiseResult: FailureContinuation[\"raiseResult\"] = (result) => {\n    if (result.error == null) {\n      return Effect.void;\n    }\n    return Effect.fail(normalize(result.error));\n  };\n\n  return {\n    run,\n    raiseResult,\n  };\n};\n","/**\n * The `Contract` module provides a typed way to describe effectful auth contracts\n * that can be shared between clients and identity runtimes.\n *\n * Use it to define public entry points for onboarding, multi-factor\n * verification, password resets, or any other authenticated workflow while\n * keeping validation and dependencies explicit.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * // Define a contract invoked when the user submits a one-time code\n * const VerifyMfaCode = Contract.make(\"VerifyMfaCode\", {\n *   description: \"Validates a one-time code during sign-in\",\n *   parameters: {\n *     userId: S.String,\n *     code: S.String\n *   },\n *   success: S.Struct({\n *     sessionToken: S.String\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n */\nimport type { UnsafeTypes } from \"@beep/types\";\nimport * as Context from \"effect/Context\";\nimport type * as Effect from \"effect/Effect\";\nimport * as F from \"effect/Function\";\nimport * as JsonSchema from \"effect/JSONSchema\";\nimport * as O from \"effect/Option\";\nimport type { Pipeable } from \"effect/Pipeable\";\nimport { pipeArguments } from \"effect/Pipeable\";\nimport * as Predicate from \"effect/Predicate\";\nimport * as S from \"effect/Schema\";\nimport * as AST from \"effect/SchemaAST\";\nimport type { Covariant } from \"effect/Types\";\nimport type * as IamError from \"./IamError\";\n// =============================================================================\n// Type Ids\n// =============================================================================\n\n/**\n * Unique identifier for user-defined contracts.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport const TypeId = \"~@beep/iam-sdk/Contract\";\n\n/**\n * Type-level representation of the user-defined contract identifier.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport type TypeId = typeof TypeId;\n\n/**\n * Unique identifier for provider-defined contracts.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport const ProviderDefinedTypeId = \"~@beep/iam-sdk/Contract/ProviderDefined\";\n\n/**\n * Type-level representation of the provider-defined contract identifier.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport type ProviderDefinedTypeId = typeof ProviderDefinedTypeId;\n\n// =============================================================================\n// Models\n// =============================================================================\n\n/**\n * A user-defined contract that identity clients can call to perform an action.\n *\n * Contracts describe the contract between an auth surface (web, mobile, CLI) and\n * the runtime that fulfills the operation. Each contract declares schemas for\n * parameters, success results, and failure results to keep validation explicit.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const StartPasswordReset = Contract.make(\"StartPasswordReset\", {\n *   description: \"Issues a reset token when a user asks to reset their password\",\n *   parameters: {\n *     email: S.String\n *   },\n *   success: S.Struct({\n *     tokenId: S.String\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n * @category Models\n */\nexport interface Contract<\n  Name extends string,\n  Config extends {\n    readonly parameters: AnyStructSchema;\n    readonly success: S.Schema.Any;\n    readonly failure: S.Schema.All;\n    readonly failureMode: FailureMode;\n  },\n  Requirements = never,\n> extends Contract.Variance<Requirements> {\n  /**\n   * The contract identifier which is used to uniquely identify the contract.\n   */\n  readonly id: string;\n\n  /**\n   * The name of the contract.\n   */\n  readonly name: Name;\n\n  /**\n   * The optional description of the contract.\n   */\n  readonly description?: string | undefined;\n\n  /**\n   * The strategy used for handling errors returned from contract call implementation\n   * execution.\n   *\n   * If set to `\"error\"` (the default), errors that occur during contract call\n   * implementation execution will be returned in the error channel of the calling\n   * effect.\n   *\n   * If set to `\"return\"`, errors that occur during contract call implementation execution\n   * will be captured and returned as part of the contract call result.\n   */\n  readonly failureMode: FailureMode;\n\n  /**\n   * A `Schema` representing the parameters that a contract must be called with.\n   */\n  readonly parametersSchema: Config[\"parameters\"];\n\n  /**\n   * A `Schema` representing the value that a contract must return when called if\n   * the contract call is successful.\n   */\n  readonly successSchema: Config[\"success\"];\n\n  /**\n   * A `Schema` representing the value that a contract must return when called if\n   * it fails.\n   */\n  readonly failureSchema: Config[\"failure\"];\n\n  /**\n   * A `Context` object containing contract annotations which can store metadata\n   * about the contract.\n   */\n  readonly annotations: Context.Context<never>;\n\n  /**\n   * Adds a _request-level_ dependency which must be provided before the contract\n   * call implementation can be executed.\n   *\n   * This can be useful when the auth client must supply per-request data (for\n   * example, tenant context or trace metadata) rather than capturing it when the\n   * contract implementation layer is created.\n   */\n  addDependency<Identifier, Service>(\n    tag: Context.Tag<Identifier, Service>\n  ): Contract<Name, Config, Identifier | Requirements>;\n\n  /**\n   * Set the schema to use to validate the result of a contract call when successful.\n   */\n  setParameters<ParametersSchema extends S.Struct<UnsafeTypes.UnsafeAny> | S.Struct.Fields>(\n    schema: ParametersSchema\n  ): Contract<\n    Name,\n    {\n      readonly parameters: ParametersSchema extends S.Struct<infer _>\n        ? ParametersSchema\n        : ParametersSchema extends S.Struct.Fields\n          ? S.Struct<ParametersSchema>\n          : never;\n      readonly success: Config[\"success\"];\n      readonly failure: Config[\"failure\"];\n      readonly failureMode: Config[\"failureMode\"];\n    },\n    Requirements\n  >;\n\n  /**\n   * Set the schema to use to validate the result of a contract call when successful.\n   */\n  setSuccess<SuccessSchema extends S.Schema.Any>(\n    schema: SuccessSchema\n  ): Contract<\n    Name,\n    {\n      readonly parameters: Config[\"parameters\"];\n      readonly success: SuccessSchema;\n      readonly failure: Config[\"failure\"];\n      readonly failureMode: Config[\"failureMode\"];\n    },\n    Requirements\n  >;\n\n  /**\n   * Set the schema to use to validate the result of a contract call when it fails.\n   */\n  setFailure<FailureSchema extends S.Schema.Any>(\n    schema: FailureSchema\n  ): Contract<\n    Name,\n    {\n      readonly parameters: Config[\"parameters\"];\n      readonly success: Config[\"success\"];\n      readonly failure: FailureSchema;\n      readonly failureMode: Config[\"failureMode\"];\n    },\n    Requirements\n  >;\n\n  /**\n   * Add an annotation to the contract.\n   */\n  annotate<I, S>(tag: Context.Tag<I, S>, value: S): Contract<Name, Config, Requirements>;\n\n  /**\n   * Add many annotations to the contract.\n   */\n  annotateContext<I>(context: Context.Context<I>): Contract<Name, Config, Requirements>;\n}\n\n/**\n * A provider-defined contract wraps functionality that ships with an external\n * auth provider (for example, Better Auth hosted screens or third-party social\n * sign-in callbacks).\n *\n * These contracts are triggered by the provider and optionally require an\n * application-defined implementation to post-process the provider output.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const HostedPasswordReset = Contract.providerDefined({\n *   id: \"betterauth.reset_password\",\n *   contractSetName: \"HostedPasswordReset\",\n *   providerName: \"reset_password\",\n *   args: {\n *     redirectUri: S.String\n *   },\n *   success: S.Struct({\n *     status: S.Literal(\"redirected\")\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n * @category Models\n */\nexport interface ProviderDefined<\n  Name extends string,\n  Config extends {\n    readonly args: AnyStructSchema;\n    readonly parameters: AnyStructSchema;\n    readonly success: S.Schema.Any;\n    readonly failure: S.Schema.All;\n    readonly failureMode: FailureMode;\n  } = {\n    readonly args: S.Struct<{}>;\n    readonly parameters: S.Struct<{}>;\n    readonly success: typeof S.Void;\n    readonly failure: typeof S.Never;\n    readonly failureMode: \"error\";\n  },\n  RequiresImplementation extends boolean = false,\n> extends Contract<\n      Name,\n      {\n        readonly parameters: Config[\"parameters\"];\n        readonly success: Config[\"success\"];\n        readonly failure: Config[\"failure\"];\n        readonly failureMode: Config[\"failureMode\"];\n      }\n    >,\n    Contract.ProviderDefinedProto {\n  /**\n   * The arguments passed to the provider-defined contract.\n   */\n  readonly args: Config[\"args\"][\"Encoded\"];\n\n  /**\n   * A `Schema` representing the arguments provided by the end-user which will\n   * be used to configure the behavior of the provider-defined contract.\n   */\n  readonly argsSchema: Config[\"args\"];\n\n  /**\n   * Name of the contract as recognized by the external auth provider.\n   */\n  readonly providerName: string;\n\n  /**\n   * If set to `true`, this provider-defined contract requires a user-defined\n   * implementation when converting the `ContractSet` containing this contract\n   * into a `Layer`.\n   */\n  readonly requiresImplementation: RequiresImplementation;\n}\n\n/**\n * The strategy used for handling errors returned from contract call implementation\n * execution.\n *\n * If set to `\"error\"` (the default), errors that occur during contract call implementation\n * execution will be returned in the error channel of the calling effect.\n *\n * If set to `\"return\"`, errors that occur during contract call implementation execution\n * will be captured and returned as part of the contract call result.\n *\n * @since 1.0.0\n * @category Models\n */\nexport type FailureMode = \"error\" | \"return\";\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Contract {\n  /**\n   * @since 1.0.0\n   * @category Models\n   */\n  export interface Variance<out Requirements> extends Pipeable {\n    readonly [TypeId]: VarianceStruct<Requirements>;\n  }\n\n  /**\n   * @since 1.0.0\n   * @category Models\n   */\n  export interface VarianceStruct<out Requirements> {\n    readonly _Requirements: Covariant<Requirements>;\n  }\n\n  /**\n   * @since 1.0.0\n   * @category Models\n   */\n  export interface ProviderDefinedProto {\n    readonly [ProviderDefinedTypeId]: ProviderDefinedTypeId;\n  }\n}\n\n// =============================================================================\n// Type Guards\n// =============================================================================\n\n/**\n * Type guard to check if a value is a user-defined contract.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const SignInEmail = Contract.make(\"SignInEmail\", {\n *   description: \"Authenticates a user with email and password\",\n *   parameters: {\n *     email: S.String,\n *     password: S.String\n *   },\n *   success: S.Struct({\n *     sessionToken: S.String\n *   })\n * })\n *\n * const HostedPasswordReset = Contract.providerDefined({\n *   id: \"betterauth.reset_password\",\n *   contractSetName: \"HostedPasswordReset\",\n *   providerName: \"reset_password\",\n *   args: {\n *     redirectUri: S.String\n *   },\n *   success: S.Struct({\n *     status: S.Literal(\"redirected\")\n *   })\n * })\n *\n * console.log(Contract.isUserDefined(SignInEmail))           // true\n * console.log(Contract.isUserDefined(HostedPasswordReset))   // false\n * ```\n *\n * @since 1.0.0\n * @category Guards\n */\nexport const isUserDefined = (u: unknown): u is Contract<string, UnsafeTypes.UnsafeAny, UnsafeTypes.UnsafeAny> =>\n  Predicate.hasProperty(u, TypeId) && !isProviderDefined(u);\n\n/**\n * Type guard to check if a value is a provider-defined contract.\n *\n * @param u - The value to check\n * @returns `true` if the value is a provider-defined `Contract`, `false` otherwise\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const SignInEmail = Contract.make(\"SignInEmail\", {\n *   description: \"Authenticates a user with email and password\",\n *   parameters: {\n *     email: S.String,\n *     password: S.String\n *   },\n *   success: S.Struct({\n *     sessionToken: S.String\n *   })\n * })\n *\n * const HostedPasswordReset = Contract.providerDefined({\n *   id: \"betterauth.reset_password\",\n *   contractSetName: \"HostedPasswordReset\",\n *   providerName: \"reset_password\",\n *   args: {\n *     redirectUri: S.String\n *   },\n *   success: S.Struct({\n *     status: S.Literal(\"redirected\")\n *   })\n * })\n *\n * console.log(Contract.isProviderDefined(SignInEmail))           // false\n * console.log(Contract.isProviderDefined(HostedPasswordReset))   // true\n * ```\n *\n * @since 1.0.0\n * @category Guards\n */\nexport const isProviderDefined = (u: unknown): u is ProviderDefined<string, UnsafeTypes.UnsafeAny> =>\n  Predicate.hasProperty(u, ProviderDefinedTypeId);\n\n// =============================================================================\n// Utility Types\n// =============================================================================\n\n/**\n * A type which represents any `Contract`.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport interface Any extends Pipeable {\n  readonly [TypeId]: {\n    readonly _Requirements: Covariant<UnsafeTypes.UnsafeAny>;\n  };\n  readonly id: string;\n  readonly name: string;\n  readonly description?: string | undefined;\n  readonly parametersSchema: AnyStructSchema;\n  readonly successSchema: S.Schema.Any;\n  readonly failureSchema: S.Schema.All;\n  readonly failureMode: FailureMode;\n  readonly annotations: Context.Context<never>;\n}\n\n/**\n * A type which represents any provider-defined `Contract`.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport interface AnyProviderDefined extends Any {\n  readonly args: UnsafeTypes.UnsafeAny;\n  readonly argsSchema: AnyStructSchema;\n  readonly requiresImplementation: boolean;\n  readonly providerName: string;\n  readonly decodeResult: (result: unknown) => Effect.Effect<UnsafeTypes.UnsafeAny, IamError.IamError>;\n}\n\n/**\n * @since 1.0.0\n * @category Utility Types\n */\nexport interface AnyStructSchema extends Pipeable {\n  readonly [S.TypeId]: UnsafeTypes.UnsafeAny;\n  readonly make: UnsafeTypes.UnsafeAny;\n  readonly Type: UnsafeTypes.UnsafeAny;\n  readonly Encoded: UnsafeTypes.UnsafeAny;\n  readonly Context: UnsafeTypes.UnsafeAny;\n  readonly ast: AST.AST;\n  readonly fields: S.Struct.Fields;\n  readonly annotations: UnsafeTypes.UnsafeAny;\n}\n\n/**\n * @since 1.0.0\n * @category Utility Types\n */\nexport interface AnyTaggedRequestSchema extends AnyStructSchema {\n  readonly _tag: string;\n  readonly success: S.Schema.Any;\n  readonly failure: S.Schema.All;\n}\n\n/**\n * A utility type to convert a `S.TaggedRequest` into an `Contract`.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport interface FromTaggedRequest<S extends AnyTaggedRequestSchema>\n  extends Contract<\n    S[\"_tag\"],\n    {\n      readonly parameters: S;\n      readonly success: S[\"success\"];\n      readonly failure: S[\"failure\"];\n      readonly failureMode: \"error\";\n    }\n  > {}\n\n/**\n * A utility type to extract the `Name` type from an `Contract`.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Name<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements> ? _Name : never;\n\n/**\n * A utility type to extract the type of the contract call parameters.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Parameters<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? S.Struct.Type<_Config[\"parameters\"][\"fields\"]>\n  : never;\n\n/**\n * A utility type to extract the encoded type of the contract call parameters.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ParametersEncoded<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? S.Schema.Encoded<_Config[\"parameters\"]>\n  : never;\n\n/**\n * A utility type to extract the schema for the parameters which an `Contract`\n * must be called with.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ParametersSchema<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? _Config[\"parameters\"]\n  : never;\n\n/**\n * A utility type to extract the type of the contract call result when it succeeds.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Success<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? S.Schema.Type<_Config[\"success\"]>\n  : never;\n\n/**\n * A utility type to extract the encoded type of the contract call result when\n * it succeeds.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type SuccessEncoded<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? S.Schema.Encoded<_Config[\"success\"]>\n  : never;\n\n/**\n * A utility type to extract the schema for the return type of a contract call when\n * the contract call succeeds.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type SuccessSchema<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? _Config[\"success\"]\n  : never;\n\n/**\n * A utility type to extract the type of the contract call result when it fails.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Failure<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? S.Schema.Type<_Config[\"failure\"]>\n  : never;\n\n/**\n * A utility type to extract the encoded type of the contract call result when\n * it fails.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type FailureEncoded<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? S.Schema.Encoded<_Config[\"failure\"]>\n  : never;\n\n/**\n * A utility type to extract the type of the contract call result whether it\n * succeeds or fails.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Result<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? Success<T> | Failure<T>\n  : never;\n\n/**\n * A utility type to extract the encoded type of the contract call result whether\n * it succeeds or fails.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ResultEncoded<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? SuccessEncoded<T> | FailureEncoded<T>\n  : never;\n\n/**\n * A utility type to extract the requirements of an `Contract`.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Requirements<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? _Config[\"parameters\"][\"Context\"] | _Config[\"success\"][\"Context\"] | _Config[\"failure\"][\"Context\"] | _Requirements\n  : never;\n\n/**\n * Represents an `Contract` that has been implemented within the application.\n *\n * @since 1.0.0\n * @category Models\n */\nexport interface Implementation<Name extends string> {\n  readonly _: unique symbol;\n  readonly name: Name;\n  readonly context: Context.Context<never>;\n  readonly implementation: (\n    params: UnsafeTypes.UnsafeAny\n  ) => Effect.Effect<UnsafeTypes.UnsafeAny, UnsafeTypes.UnsafeAny>;\n}\n\n/**\n * Represents the result of calling the implementation for a particular `Contract`.\n *\n * @since 1.0.0\n * @category Models\n */\nexport interface ImplementationResult<Contract extends Any> {\n  /**\n   * Whether the result of executing the contract call implementation was an error or not.\n   */\n  readonly isFailure: boolean;\n  /**\n   * The result of executing the implementation for a particular contract.\n   */\n  readonly result: Result<Contract>;\n  /**\n   * The pre-encoded contract call result of executing the implementation for a particular\n   * contract as a JSON-serializable value. The encoded result can be forwarded to\n   * clients, stored for auditing, or chained into subsequent contract calls.\n   */\n  readonly encodedResult: unknown;\n}\n\n/**\n * A utility type which represents the possible errors that can be raised by\n * a contract call's implementation.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ImplementationError<T> = T extends Contract<infer _Name, infer _Config, infer _Requirements>\n  ? _Config[\"failureMode\"] extends \"error\"\n    ? _Config[\"failure\"][\"Type\"]\n    : never\n  : never;\n\n/**\n * A utility type to create a union of `Implementation` types for all contracts in a\n * record.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ImplementationsFor<Contracts extends Record<string, Any>> = {\n  [Name in keyof Contracts]: RequiresImplementation<Contracts[Name]> extends true\n    ? Implementation<Contracts[Name][\"name\"]>\n    : never;\n}[keyof Contracts];\n\n/**\n * A utility type to determine if the specified contract requires a user-defined\n * implementation to be implemented.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type RequiresImplementation<Contract extends Any> = Contract extends ProviderDefined<\n  infer _Name,\n  infer _Config,\n  infer _RequiresImplementation\n>\n  ? _RequiresImplementation\n  : true;\n\n// =============================================================================\n// Constructors\n// =============================================================================\n\nconst Proto = {\n  [TypeId]: { _Requirements: F.identity },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n  addDependency(this: Any) {\n    return userDefinedProto({ ...this });\n  },\n  setParameters(this: Any, parametersSchema: S.Struct<UnsafeTypes.UnsafeAny> | S.Struct.Fields) {\n    return userDefinedProto({\n      ...this,\n      parametersSchema: S.isSchema(parametersSchema)\n        ? (parametersSchema as UnsafeTypes.UnsafeAny)\n        : S.Struct(parametersSchema as UnsafeTypes.UnsafeAny),\n    });\n  },\n  setSuccess(this: Any, successSchema: S.Schema.Any) {\n    return userDefinedProto({\n      ...this,\n      successSchema,\n    });\n  },\n  setFailure(this: Any, failureSchema: S.Schema.All) {\n    return userDefinedProto({\n      ...this,\n      failureSchema,\n    });\n  },\n  annotate<I, S>(this: Any, tag: Context.Tag<I, S>, value: S) {\n    return userDefinedProto({\n      ...this,\n      annotations: Context.add(this.annotations, tag, value),\n    });\n  },\n  annotateContext<I>(this: Any, context: Context.Context<I>) {\n    return userDefinedProto({\n      ...this,\n      annotations: Context.merge(this.annotations, context),\n    });\n  },\n};\n\nconst ProviderDefinedProto = {\n  ...Proto,\n  [ProviderDefinedTypeId]: ProviderDefinedTypeId,\n};\n\nconst userDefinedProto = <\n  const Name extends string,\n  Parameters extends AnyStructSchema,\n  Success extends S.Schema.Any,\n  Failure extends S.Schema.All,\n  Mode extends FailureMode,\n>(options: {\n  readonly name: Name;\n  readonly description?: string | undefined;\n  readonly parametersSchema: Parameters;\n  readonly successSchema: Success;\n  readonly failureSchema: Failure;\n  readonly annotations: Context.Context<never>;\n  readonly failureMode: Mode;\n}): Contract<\n  Name,\n  {\n    readonly parameters: Parameters;\n    readonly success: Success;\n    readonly failure: Failure;\n    readonly failureMode: Mode;\n  }\n> => {\n  const self = Object.assign(Object.create(Proto), options);\n  self.id = `@beep/iam-sdk/Contract/${options.name}`;\n  return self;\n};\n\nconst providerDefinedProto = <\n  const Name extends string,\n  Args extends AnyStructSchema,\n  Parameters extends AnyStructSchema,\n  Success extends S.Schema.Any,\n  Failure extends S.Schema.All,\n  RequiresImplementation extends boolean,\n  Mode extends FailureMode,\n>(options: {\n  readonly id: string;\n  readonly name: Name;\n  readonly providerName: string;\n  readonly args: Args[\"Encoded\"];\n  readonly argsSchema: Args;\n  readonly requiresImplementation: RequiresImplementation;\n  readonly parametersSchema: Parameters;\n  readonly successSchema: Success;\n  readonly failureSchema: Failure;\n  readonly failureMode: FailureMode;\n}): ProviderDefined<\n  Name,\n  {\n    readonly args: Args;\n    readonly parameters: Parameters;\n    readonly success: Success;\n    readonly failure: Failure;\n    readonly failureMode: Mode;\n  },\n  RequiresImplementation\n> => Object.assign(Object.create(ProviderDefinedProto), options);\n\nconst constEmptyStruct = S.Struct({});\n\n/**\n * Creates a user-defined contract with the specified name and configuration.\n *\n * Use this to expose operations that auth clients call. The contract definition\n * includes parameter validation, success/failure schemas, and optional service\n * dependencies so that the runtime contract stays explicit.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const StartEmailVerification = Contract.make(\"StartEmailVerification\", {\n *   description: \"Sends a verification link to a pending member\",\n *   parameters: {\n *     email: S.String\n *   },\n *   success: S.Struct({\n *     jobId: S.String\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n * @category Constructors\n */\nexport const make = <\n  const Name extends string,\n  Parameters extends S.Struct.Fields = {},\n  Success extends S.Schema.Any = typeof S.Void,\n  Failure extends S.Schema.All = typeof S.Never,\n  Mode extends FailureMode | undefined = undefined,\n  Dependencies extends Array<Context.Tag<UnsafeTypes.UnsafeAny, UnsafeTypes.UnsafeAny>> = [],\n>(\n  /**\n   * The unique name identifier for this contract.\n   */\n  name: Name,\n  options?: {\n    /**\n     * An optional description explaining what the contract does.\n     */\n    readonly description?: string | undefined;\n    /**\n     * Schema defining the parameters this contract accepts.\n     */\n    readonly parameters?: Parameters | undefined;\n    /**\n     * Schema for successful contract execution results.\n     */\n    readonly success?: Success | undefined;\n    /**\n     * Schema for contract execution failures.\n     */\n    readonly failure?: Failure | undefined;\n    /**\n     * The strategy used for handling errors returned from contract call implementation\n     * execution.\n     *\n     * If set to `\"error\"` (the default), errors that occur during contract call implementation\n     * execution will be returned in the error channel of the calling effect.\n     *\n     * If set to `\"return\"`, errors that occur during contract call implementation execution\n     * will be captured and returned as part of the contract call result.\n     */\n    readonly failureMode?: Mode;\n    /**\n     * Service dependencies required by the contract implementation.\n     */\n    readonly dependencies?: Dependencies | undefined;\n  }\n): Contract<\n  Name,\n  {\n    readonly parameters: S.Struct<Parameters>;\n    readonly success: Success;\n    readonly failure: Failure;\n    readonly failureMode: Mode extends undefined ? \"error\" : Mode;\n  },\n  Context.Tag.Identifier<Dependencies[number]>\n> => {\n  const successSchema = options?.success ?? S.Void;\n  const failureSchema = options?.failure ?? S.Never;\n  return userDefinedProto({\n    name,\n    description: options?.description,\n    parametersSchema: options?.parameters ? S.Struct(options?.parameters as UnsafeTypes.UnsafeAny) : constEmptyStruct,\n    successSchema,\n    failureSchema,\n    failureMode: options?.failureMode ?? \"error\",\n    annotations: Context.empty(),\n  }) as UnsafeTypes.UnsafeAny;\n};\n\n/**\n * Creates a provider-defined contract that delegates to functionality supplied\n * by an auth provider.\n *\n * The provider triggers these contracts, but your runtime can still validate the\n * payload, enforce failure handling, and merge in application-specific logic.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const HostedMagicLink = Contract.providerDefined({\n *   id: \"betterauth.magic_link\",\n *   contractSetName: \"HostedMagicLink\",\n *   providerName: \"magic_link\",\n *   args: {\n *     redirectUri: S.String\n *   },\n *   success: S.Struct({\n *     verificationUrl: S.String\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n * @category Constructors\n */\nexport const providerDefined =\n  <\n    const Name extends string,\n    Args extends S.Struct.Fields = {},\n    Parameters extends S.Struct.Fields = {},\n    Success extends S.Schema.Any = typeof S.Void,\n    Failure extends S.Schema.All = typeof S.Never,\n    RequiresImplementation extends boolean = false,\n  >(options: {\n    /**\n     * Unique identifier following format `<provider>.<contract-name>`.\n     */\n    readonly id: `${string}.${string}`;\n    /**\n     * Name used by the ContractSet to identify this contract.\n     */\n    readonly contractSetName: Name;\n    /**\n     * Name of the contract as recognized by the auth provider.\n     */\n    readonly providerName: string;\n    /**\n     * Schema for user-provided configuration arguments.\n     */\n    readonly args: Args;\n    /**\n     * Whether this contract requires a custom implementation implementation.\n     */\n    readonly requiresImplementation?: RequiresImplementation | undefined;\n    /**\n     * Schema for parameters the provider sends when calling the contract.\n     */\n    readonly parameters?: Parameters | undefined;\n    /**\n     * Schema for successful contract execution results.\n     */\n    readonly success?: Success | undefined;\n    /**\n     * Schema for failed contract execution results.\n     */\n    readonly failure?: Failure | undefined;\n  }) =>\n  <Mode extends FailureMode | undefined = undefined>(\n    args: RequiresImplementation extends true\n      ? S.Simplify<\n          S.Struct.Encoded<Args> & {\n            /**\n             * The strategy used for handling errors returned from contract call implementation\n             * execution.\n             *\n             * If set to `\"error\"` (the default), errors that occur during contract call implementation\n             * execution will be returned in the error channel of the calling effect.\n             *\n             * If set to `\"return\"`, errors that occur during contract call implementation execution\n             * will be captured and returned as part of the contract call result.\n             */\n            readonly failureMode?: Mode;\n          }\n        >\n      : S.Simplify<S.Struct.Encoded<Args>>\n  ): ProviderDefined<\n    Name,\n    {\n      readonly args: S.Struct<Args>;\n      readonly parameters: S.Struct<Parameters>;\n      readonly success: Success;\n      readonly failure: Failure;\n      readonly failureMode: Mode extends undefined ? \"error\" : Mode;\n    },\n    RequiresImplementation\n  > => {\n    const failureMode = \"failureMode\" in args ? args.failureMode : undefined;\n    const successSchema = options?.success ?? S.Void;\n    const failureSchema = options?.failure ?? S.Never;\n    return providerDefinedProto({\n      id: options.id,\n      name: options.contractSetName,\n      providerName: options.providerName,\n      args,\n      argsSchema: S.Struct(options.args as UnsafeTypes.UnsafeAny),\n      requiresImplementation: options.requiresImplementation ?? false,\n      parametersSchema: options?.parameters ? S.Struct(options?.parameters as UnsafeTypes.UnsafeAny) : constEmptyStruct,\n      successSchema,\n      failureSchema,\n      failureMode: failureMode ?? \"error\",\n    }) as UnsafeTypes.UnsafeAny;\n  };\n\n/**\n * Creates a Contract from a S.TaggedRequest.\n *\n * This utility function converts Effect's TaggedRequest schemas into Contract\n * definitions, automatically mapping the request parameters, success, and\n * failure schemas.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * // Define a tagged request for verifying a pending invitation\n * class GetInvitation extends S.TaggedRequest<GetInvitation>()(\"GetInvitation\", {\n *   success: S.Struct({\n *     invitationId: S.String,\n *     email: S.String\n *   }),\n *   failure: S.Struct({\n *     reason: S.Literal(\"NotFound\", \"Expired\"),\n *     message: S.String\n *   }),\n *   payload: {\n *     code: S.String\n *   }\n * }) {}\n *\n * // Convert to a Contract\n * const getInvitationContract = Contract.fromTaggedRequest(GetInvitation)\n * ```\n *\n * @since 1.0.0\n * @category Constructors\n */\nexport const fromTaggedRequest = <S extends AnyTaggedRequestSchema>(schema: S): FromTaggedRequest<S> =>\n  userDefinedProto({\n    name: schema._tag,\n    description: O.getOrUndefined(AST.getDescriptionAnnotation((schema.ast as UnsafeTypes.UnsafeAny).to)),\n    parametersSchema: schema,\n    successSchema: schema.success,\n    failureSchema: schema.failure,\n    failureMode: \"error\",\n    annotations: Context.empty(),\n  }) as UnsafeTypes.UnsafeAny;\n\n// =============================================================================\n// Utilities\n// =============================================================================\n\n/**\n * Extracts the description from a contract's metadata.\n *\n * Returns the contract's description if explicitly set, otherwise attempts to\n * extract it from the parameter schema's AST annotations.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n *\n * const myContract = Contract.make(\"example\", {\n *   description: \"This is an example contract\"\n * })\n *\n * const description = Contract.getDescription(myContract)\n * console.log(description) // \"This is an example contract\"\n * ```\n *\n * @since 1.0.0\n * @category Utilities\n */\nexport const getDescription = <\n  Name extends string,\n  Config extends {\n    readonly parameters: AnyStructSchema;\n    readonly success: S.Schema.Any;\n    readonly failure: S.Schema.All;\n    readonly failureMode: FailureMode;\n  },\n>(\n  /**\n   * The contract to get the description from.\n   */\n  contract: Contract<Name, Config>\n): string | undefined => {\n  if (Predicate.isNotUndefined(contract.description)) {\n    return contract.description;\n  }\n  return getDescriptionFromSchemaAst(contract.parametersSchema.ast);\n};\n\n/**\n * @since 1.0.0\n * @category Utilities\n */\nexport const getDescriptionFromSchemaAst = (ast: AST.AST): string | undefined => {\n  const annotations =\n    ast._tag === \"Transformation\"\n      ? {\n          ...ast.to.annotations,\n          ...ast.annotations,\n        }\n      : ast.annotations;\n  return AST.DescriptionAnnotationId in annotations ? (annotations[AST.DescriptionAnnotationId] as string) : undefined;\n};\n\n/**\n * Generates a JSON Schema for a contract.\n *\n * This function creates a JSON Schema representation that can be shared with\n * clients or documentation generators to describe the parameters a contract\n * expects.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as S from \"effect/Schema\"\n *\n * const completeProfile = Contract.make(\"complete_profile\", {\n *   parameters: {\n *     displayName: S.String,\n *     timezone: S.optional(S.String)\n *   }\n * })\n *\n * const jsonSchema = Contract.getJsonSchema(completeProfile)\n * console.log(jsonSchema)\n * // {\n * //   type: \"object\",\n * //   properties: {\n * //     displayName: { type: \"string\" },\n * //     timezone: { type: \"string\" }\n * //   },\n * //   required: [\"displayName\"]\n * // }\n * ```\n *\n * @since 1.0.0\n * @category Utilities\n */\nexport const getJsonSchema = <\n  Name extends string,\n  Config extends {\n    readonly parameters: AnyStructSchema;\n    readonly success: S.Schema.Any;\n    readonly failure: S.Schema.All;\n    readonly failureMode: FailureMode;\n  },\n>(\n  contract: Contract<Name, Config>\n): JsonSchema.JsonSchema7 => getJsonSchemaFromSchemaAst(contract.parametersSchema.ast);\n\n/**\n * @since 1.0.0\n * @category Utilities\n */\nexport const getJsonSchemaFromSchemaAst = (ast: AST.AST): JsonSchema.JsonSchema7 => {\n  const props = AST.getPropertySignatures(ast);\n  if (props.length === 0) {\n    return {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: false,\n    };\n  }\n  const $defs = {};\n  const schema = JsonSchema.fromAST(ast, {\n    definitions: $defs,\n    topLevelReferenceStrategy: \"skip\",\n  });\n  if (Object.keys($defs).length === 0) return schema;\n  (schema as UnsafeTypes.UnsafeAny).$defs = $defs;\n  return schema;\n};\n\n// =============================================================================\n// Annotations\n// =============================================================================\n\n/**\n * Annotation for providing a human-readable title for contracts.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n *\n * const myContract = Contract.make(\"start_password_reset\")\n *   .annotate(Contract.Title, \"Start Password Reset\")\n * ```\n *\n * @since 1.0.0\n * @category Annotations\n */\nexport class Title extends Context.Tag(\"@beep/iam-sdk/Contract/Title\")<Title, string>() {}\n\n/**\n * Annotation indicating whether a contract only reads data without making changes.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n *\n * const readOnlyContract = Contract.make(\"get_user_info\")\n *   .annotate(Contract.Readonly, true)\n * ```\n *\n * @since 1.0.0\n * @category Annotations\n */\nexport class Readonly extends Context.Reference<Readonly>()(\"@beep/iam-sdk/Contract/Readonly\", {\n  defaultValue: F.constFalse,\n}) {}\n\n/**\n * Annotation indicating whether a contract performs destructive operations.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n *\n * const safeContract = Contract.make(\"revoke_all_sessions\")\n *   .annotate(Contract.Destructive, true)\n * ```\n *\n * @since 1.0.0\n * @category Annotations\n */\nexport class Destructive extends Context.Reference<Destructive>()(\"@beep/iam-sdk/Contract/Destructive\", {\n  defaultValue: F.constTrue,\n}) {}\n\n/**\n * Annotation indicating whether a contract can be called multiple times safely.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n *\n * const idempotentContract = Contract.make(\"fetch_active_session\")\n *   .annotate(Contract.Idempotent, true)\n * ```\n *\n * @since 1.0.0\n * @category Annotations\n */\nexport class Idempotent extends Context.Reference<Idempotent>()(\"@beep/iam-sdk/Contract/Idempotent\", {\n  defaultValue: F.constFalse,\n}) {}\n\n/**\n * Annotation indicating whether a contract can handle arbitrary external data.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n *\n * const restrictedContract = Contract.make(\"issue_admin_token\")\n *   .annotate(Contract.OpenWorld, false)\n * ```\n *\n * @since 1.0.0\n * @category Annotations\n */\nexport class OpenWorld extends Context.Reference<OpenWorld>()(\"@beep/iam-sdk/Contract/OpenWorld\", {\n  defaultValue: F.constTrue,\n}) {}\n\nconst suspectProtoRx = /\"__proto__\"\\s*:/;\nconst suspectConstructorRx = /\"constructor\"\\s*:/;\n\nfunction _parse(text: string) {\n  // Parse normally\n  const obj = JSON.parse(text);\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n\n  if (!suspectProtoRx.test(text) && !suspectConstructorRx.test(text)) {\n    return obj;\n  }\n\n  // Scan result for proto keys\n  return filter(obj);\n}\n\nfunction filter(obj: UnsafeTypes.UnsafeAny) {\n  let next = [obj];\n\n  while (next.length) {\n    const nodes = next;\n    next = [];\n\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n\n      if (\n        Object.prototype.hasOwnProperty.call(node, \"constructor\") &&\n        Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")\n      ) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\n\n/**\n * **Unsafe**: This function will throw an error if an insecure property is\n * found in the parsed JSON or if the provided JSON text is not parseable.\n *\n * @since 1.0.0\n * @category Utilities\n */\nexport const unsafeSecureJsonParse = (text: string): unknown => {\n  // Performance optimization, see https://github.com/fastify/secure-json-parse/pull/90\n  const { stackTraceLimit } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n};\n","/**\n * The `ContractSet` module groups related auth contracts into a cohesive bundle\n * that can be implemented once and shared across clients.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as ContractSet from \"@beep/iam-sdk/authkit/ContractSet\"\n * import * as Effect from \"effect/Effect\"\n * import * as S from \"effect/Schema\"\n *\n * const StartPasswordReset = Contract.make(\"StartPasswordReset\", {\n *   description: \"Issues a reset token for a pending user\",\n *   parameters: { email: S.String },\n *   success: S.Struct({ tokenId: S.String })\n * })\n *\n * const VerifyMfaCode = Contract.make(\"VerifyMfaCode\", {\n *   description: \"Validates a one-time passcode\",\n *   parameters: { userId: S.String, code: S.String },\n *   success: S.Struct({ sessionToken: S.String })\n * })\n *\n * const AuthContracts = ContractSet.make(StartPasswordReset, VerifyMfaCode)\n *\n * const layer = AuthContracts.toLayer({\n *   StartPasswordReset: ({ email }) =>\n *     Effect.succeed({ tokenId: `token-${email}` }),\n *   VerifyMfaCode: ({ userId, code }) =>\n *     Effect.succeed({ sessionToken: `${userId}:${code}` })\n * })\n * ```\n *\n * @since 1.0.0\n */\n\nimport type { UnsafeTypes } from \"@beep/types\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport { CommitPrototype } from \"effect/Effectable\";\nimport { identity } from \"effect/Function\";\nimport type { Inspectable } from \"effect/Inspectable\";\nimport { BaseProto as InspectableProto } from \"effect/Inspectable\";\nimport * as Layer from \"effect/Layer\";\nimport type { ParseError } from \"effect/ParseResult\";\nimport * as ParseResult from \"effect/ParseResult\";\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\";\nimport * as P from \"effect/Predicate\";\nimport * as S from \"effect/Schema\";\nimport type * as Scope from \"effect/Scope\";\nimport * as Contract from \"./Contract\";\nimport * as IamError from \"./IamError\";\n\n/**\n * Unique identifier for contractSet instances.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport const TypeId = \"~@beep/iam-sdk/ContractSet\";\n\n/**\n * Type-level representation of the contractSet identifier.\n *\n * @since 1.0.0\n * @category Type Ids\n */\nexport type TypeId = typeof TypeId;\n\n/**\n * Represents a collection of auth contracts that are deployed together.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as ContractSet from \"@beep/iam-sdk/authkit/ContractSet\"\n * import * as Effect from \"effect/Effect\"\n * import * as S from \"effect/Schema\"\n *\n * const SignInEmail = Contract.make(\"SignInEmail\", {\n *   description: \"Authenticates a user with email and password\",\n *   parameters: { email: S.String, password: S.String },\n *   success: S.Struct({ sessionToken: S.String })\n * })\n *\n * const RefreshSession = Contract.make(\"RefreshSession\", {\n *   description: \"Issues a fresh session token\",\n *   parameters: { refreshToken: S.String },\n *   success: S.Struct({ sessionToken: S.String })\n * })\n *\n * const Kit = ContractSet.make(SignInEmail, RefreshSession)\n *\n * const implementations = Kit.toLayer({\n *   SignInEmail: ({ email }) => Effect.succeed({ sessionToken: email }),\n *   RefreshSession: ({ refreshToken }) => Effect.succeed({ sessionToken: refreshToken })\n * })\n * ```\n *\n * @since 1.0.0\n * @category Models\n */\nexport interface ContractSet<in out Contracts extends Record<string, Contract.Any>>\n  extends Effect.Effect<WithImplementation<Contracts>, never, Contract.ImplementationsFor<Contracts>>,\n    Inspectable,\n    Pipeable {\n  readonly [TypeId]: TypeId;\n\n  new (_: never): {};\n\n  /**\n   * A record containing all contracts in this contractSet.\n   */\n  readonly contracts: Contracts;\n\n  /**\n   * A helper method which can be used for type-safe implementation declarations.\n   */\n  of<Implementations extends ImplementationsFrom<Contracts>>(implementations: Implementations): Implementations;\n\n  /**\n   * Converts a contractSet into an Effect Context containing implementations for each contract\n   * in the contractSet.\n   */\n  toContext<Implementations extends ImplementationsFrom<Contracts>, EX = never, RX = never>(\n    build: Implementations | Effect.Effect<Implementations, EX, RX>\n  ): Effect.Effect<Context.Context<Contract.ImplementationsFor<Contracts>>, EX, RX>;\n\n  /**\n   * Converts a contractSet into a Layer containing implementations for each contract in the\n   * contractSet.\n   */\n  toLayer<Implementations extends ImplementationsFrom<Contracts>, EX = never, RX = never>(\n    /**\n     * Implementation functions or Effect that produces implementations.\n     */\n    build: Implementations | Effect.Effect<Implementations, EX, RX>\n  ): Layer.Layer<Contract.ImplementationsFor<Contracts>, EX, Exclude<RX, Scope.Scope>>;\n}\n\n/**\n * A utility type which structurally represents any contractSet instance.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport interface Any {\n  readonly [TypeId]: TypeId;\n  readonly contracts: Record<string, Contract.Any>;\n}\n\n/**\n * A utility type which can be used to extract the contract definitions from a\n * contractSet.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type Contracts<T> = T extends ContractSet<infer Contracts> ? Contracts : never;\n\n/**\n * A utility type which can transforms either a record or an array of contracts into\n * a record where keys are contract names and values are the contract instances.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ContractsByName<Contracts> = Contracts extends Record<string, Contract.Any>\n  ? { readonly [Name in keyof Contracts]: Contracts[Name] }\n  : Contracts extends ReadonlyArray<Contract.Any>\n    ? { readonly [Contract in Contracts[number] as Contract[\"name\"]]: Contract }\n    : never;\n\n/**\n * A utility type that maps contract names to their required implementation functions.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type ImplementationsFrom<Contracts extends Record<string, Contract.Any>> = {\n  readonly [Name in keyof Contracts as Contract.RequiresImplementation<Contracts[Name]> extends true ? Name : never]: (\n    params: Contract.Parameters<Contracts[Name]>\n  ) => Effect.Effect<\n    Contract.Success<Contracts[Name]>,\n    Contract.Failure<Contracts[Name]>,\n    Contract.Requirements<Contracts[Name]>\n  >;\n};\n\n/**\n * A contractSet instance with registered implementations ready for contract execution.\n *\n * @since 1.0.0\n * @category Models\n */\nexport interface WithImplementation<in out Contracts extends Record<string, Contract.Any>> {\n  /**\n   * The contracts available in this contractSet instance.\n   */\n  readonly contracts: Contracts;\n\n  /**\n   * Implementation function for executing contract calls.\n   *\n   * Receives a contract name and parameters, validates the input, executes the\n   * corresponding implementation, and returns both the typed result and encoded result.\n   */\n  readonly handle: <Name extends keyof Contracts>(\n    /**\n     * The name of the contract to execute.\n     */\n    name: Name,\n    /**\n     * Parameters to pass to the contract implementation.\n     */\n    params: Contract.Parameters<Contracts[Name]>\n  ) => Effect.Effect<\n    Contract.ImplementationResult<Contracts[Name]>,\n    Contract.Failure<Contracts[Name]>,\n    Contract.Requirements<Contracts[Name]>\n  >;\n}\n\nconst Proto = {\n  ...CommitPrototype,\n  ...InspectableProto,\n  of: identity,\n  toContext(\n    this: ContractSet<Record<string, Contract.Any>>,\n    build:\n      | Record<string, (params: UnsafeTypes.UnsafeAny) => UnsafeTypes.UnsafeAny>\n      | Effect.Effect<Record<string, (params: UnsafeTypes.UnsafeAny) => UnsafeTypes.UnsafeAny>>\n  ) {\n    return Effect.gen(this, function* () {\n      const context = yield* Effect.context<never>();\n      const implementations = Effect.isEffect(build) ? yield* build : build;\n      const contextMap = new Map<string, unknown>();\n      for (const [name, implementation] of Object.entries(implementations)) {\n        const contract = this.contracts[name]!;\n        contextMap.set(contract.id, { implementation, context });\n      }\n      return Context.unsafeMake(contextMap);\n    });\n  },\n  toLayer(\n    this: ContractSet<Record<string, Contract.Any>>,\n    build:\n      | Record<string, (params: UnsafeTypes.UnsafeAny) => UnsafeTypes.UnsafeAny>\n      | Effect.Effect<Record<string, (params: UnsafeTypes.UnsafeAny) => UnsafeTypes.UnsafeAny>>\n  ) {\n    return Layer.scopedContext(this.toContext(build));\n  },\n  commit(this: ContractSet<Record<string, Contract.Any>>) {\n    return Effect.gen(this, function* () {\n      const contracts = this.contracts;\n      const context = yield* Effect.context<never>();\n      const schemasCache = new WeakMap<\n        UnsafeTypes.UnsafeAny,\n        {\n          readonly context: Context.Context<never>;\n          readonly implementation: (\n            params: UnsafeTypes.UnsafeAny\n          ) => Effect.Effect<UnsafeTypes.UnsafeAny, UnsafeTypes.UnsafeAny>;\n          readonly decodeParameters: (\n            u: unknown\n          ) => Effect.Effect<Contract.Parameters<UnsafeTypes.UnsafeAny>, ParseError>;\n          readonly validateResult: (u: unknown) => Effect.Effect<unknown, ParseError>;\n          readonly encodeResult: (u: unknown) => Effect.Effect<unknown, ParseError>;\n        }\n      >();\n      const getSchemas = (contract: Contract.Any) => {\n        let schemas = schemasCache.get(contract);\n        if (P.isUndefined(schemas)) {\n          const implementation = context.unsafeMap.get(contract.id)! as Contract.Implementation<UnsafeTypes.UnsafeAny>;\n          const decodeParameters = S.decodeUnknown(contract.parametersSchema) as UnsafeTypes.UnsafeAny;\n          const resultSchema = S.Union(contract.successSchema, contract.failureSchema);\n          const validateResult = S.validate(resultSchema) as UnsafeTypes.UnsafeAny;\n          const encodeResult = S.encodeUnknown(resultSchema) as UnsafeTypes.UnsafeAny;\n          schemas = {\n            context: implementation.context,\n            implementation: implementation.implementation,\n            decodeParameters,\n            validateResult,\n            encodeResult,\n          };\n          schemasCache.set(contract, schemas);\n        }\n        return schemas;\n      };\n      const handle = Effect.fn(\"ContractSet.handle\", { captureStackTrace: false })(function* (\n        name: string,\n        params: unknown\n      ) {\n        yield* Effect.annotateCurrentSpan({ contract: name, parameters: params });\n        const contract = contracts[name];\n        if (P.isUndefined(contract)) {\n          const contractNames = Object.keys(contracts).join(\",\");\n          return yield* new IamError.MalformedOutput({\n            module: \"ContractSet\",\n            method: `${name}.handle`,\n            description: `Failed to find contract with name '${name}' in contractSet - available contracts: ${contractNames}`,\n          });\n        }\n        const schemas = getSchemas(contract);\n        const decodedParams = yield* Effect.mapError(\n          schemas.decodeParameters(params),\n          (cause) =>\n            new IamError.MalformedOutput({\n              module: \"ContractSet\",\n              method: `${name}.handle`,\n              description: `Failed to decode contract call parameters for contract '${name}' from:\\n'${JSON.stringify(\n                params,\n                undefined,\n                2\n              )}'`,\n              cause,\n            })\n        );\n        const { isFailure, result } = yield* schemas.implementation(decodedParams).pipe(\n          Effect.map((result) => ({ result, isFailure: false })),\n          Effect.catchAll((error) =>\n            // If the contract implementation failed, check the contract's failure mode to\n            // determine how the result should be returned to the end user\n            contract.failureMode === \"error\" ? Effect.fail(error) : Effect.succeed({ result: error, isFailure: true })\n          ),\n          Effect.tap(({ result }) => schemas.validateResult(result)),\n          Effect.mapInputContext((input) => Context.merge(schemas.context, input)),\n          Effect.mapError((cause) =>\n            ParseResult.isParseError(cause)\n              ? new IamError.MalformedInput({\n                  module: \"ContractSet\",\n                  method: `${name}.handle`,\n                  description: `Failed to validate contract call result for contract '${name}'`,\n                  cause,\n                })\n              : cause\n          )\n        );\n        const encodedResult = yield* Effect.mapError(\n          schemas.encodeResult(result),\n          (cause) =>\n            new IamError.MalformedInput({\n              module: \"ContractSet\",\n              method: `${name}.handle`,\n              description: `Failed to encode contract call result for contract '${name}'`,\n              cause,\n            })\n        );\n        return {\n          isFailure,\n          result,\n          encodedResult,\n        } satisfies Contract.ImplementationResult<UnsafeTypes.UnsafeAny>;\n      });\n      return {\n        contracts,\n        handle,\n      } satisfies WithImplementation<Record<string, UnsafeTypes.UnsafeAny>>;\n    });\n  },\n  toJSON(this: ContractSet<UnsafeTypes.UnsafeAny>): unknown {\n    return {\n      _id: \"@beep/iam-sdk/ContractSet\",\n      contracts: Array.from(Object.values(this.contracts)).map((contract) => (contract as Contract.Any).name),\n    };\n  },\n  pipe() {\n    return pipeArguments(this, arguments);\n  },\n};\n\nconst makeProto = <Contracts extends Record<string, Contract.Any>>(contracts: Contracts): ContractSet<Contracts> =>\n  Object.assign(() => {}, Proto, { contracts }) as UnsafeTypes.UnsafeAny;\n\nconst resolveInput = <Contracts extends ReadonlyArray<Contract.Any>>(\n  ...contracts: Contracts\n): Record<string, Contracts[number]> => {\n  const output = {} as Record<string, Contracts[number]>;\n  for (const contract of contracts) {\n    output[contract.name] = (\n      S.isSchema(contract) ? Contract.fromTaggedRequest(contract as UnsafeTypes.UnsafeAny) : contract\n    ) as UnsafeTypes.UnsafeAny;\n  }\n  return output;\n};\n\n/**\n * An empty contractSet with no contracts.\n *\n * Useful as a starting point for building contractSets or as a default value. Can\n * be extended using the merge function to add contracts.\n *\n * @since 1.0.0\n * @category Constructors\n */\nexport const empty: ContractSet<{}> = makeProto({});\n\n/**\n * Creates a new contractSet from the specified contracts.\n *\n * Use this to compose related auth contracts so they can be provided and\n * implemented together. Contracts can be `Contract.make` definitions or tagged\n * requests converted with `Contract.fromTaggedRequest`.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as ContractSet from \"@beep/iam-sdk/authkit/ContractSet\"\n * import * as S from \"effect/Schema\"\n *\n * const SignInEmail = Contract.make(\"SignInEmail\", {\n *   parameters: { email: S.String, password: S.String },\n *   success: S.Struct({ sessionToken: S.String })\n * })\n *\n * const VerifyInvite = Contract.make(\"VerifyInvite\", {\n *   parameters: { token: S.String },\n *   success: S.Struct({ memberId: S.String })\n * })\n *\n * const contractSet = ContractSet.make(SignInEmail, VerifyInvite)\n * ```\n *\n * @since 1.0.0\n * @category Constructors\n */\nexport const make = <Contracts extends ReadonlyArray<Contract.Any>>(\n  ...contracts: Contracts\n): ContractSet<ContractsByName<Contracts>> => makeProto(resolveInput(...contracts)) as UnsafeTypes.UnsafeAny;\n\n/**\n * A utility type which simplifies a record type.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type SimplifyRecord<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * A utility type which merges two records of contracts together.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type MergeRecords<U> = {\n  readonly [K in Extract<U extends unknown ? keyof U : never, string>]: Extract<\n    U extends Record<K, infer V> ? V : never,\n    Contract.Any\n  >;\n};\n\n/**\n * A utility type which merges the contract calls of two contractSets into a single\n * contractSet.\n *\n * @since 1.0.0\n * @category Utility Types\n */\nexport type MergedContracts<ContractSets extends ReadonlyArray<Any>> = SimplifyRecord<\n  MergeRecords<Contracts<ContractSets[number]>>\n>;\n\n/**\n * Merges multiple contractSets into a single contractSet.\n *\n * Combines all contracts from the provided contractSets into one unified contractSet.\n * If there are naming conflicts, contracts from later contractSets will override\n * contracts from earlier ones.\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as ContractSet from \"@beep/iam-sdk/authkit/ContractSet\"\n *\n * const signInKit = ContractSet.make(\n *   Contract.make(\"SignInEmail\"),\n *   Contract.make(\"SignInMagicLink\")\n * )\n *\n * const recoveryKit = ContractSet.make(\n *   Contract.make(\"StartPasswordReset\"),\n *   Contract.make(\"CompletePasswordReset\")\n * )\n *\n * const combined = ContractSet.merge(signInKit, recoveryKit)\n * // combined now has: SignInEmail, SignInMagicLink, StartPasswordReset, CompletePasswordReset\n * ```\n *\n * @example\n * ```ts\n * import * as Contract from \"@beep/iam-sdk/authkit/Contract\"\n * import * as ContractSet from \"@beep/iam-sdk/authkit/ContractSet\"\n *\n * // Incremental contractSet building\n * const baseKit = ContractSet.make(Contract.make(\"SignOut\"))\n * const extendedKit = ContractSet.merge(\n *   baseKit,\n *   ContractSet.make(Contract.make(\"LinkSocialAccount\")),\n *   ContractSet.make(Contract.make(\"UnlinkSocialAccount\"))\n * )\n * ```\n *\n * @since 1.0.0\n * @category Constructors\n */\nexport const merge = <const ContractSets extends ReadonlyArray<Any>>(\n  /**\n   * The contractSets to merge together.\n   */\n  ...contractSets: ContractSets\n): ContractSet<MergedContracts<ContractSets>> => {\n  const contracts = {} as Record<string, UnsafeTypes.UnsafeAny>;\n  for (const contractSet of contractSets) {\n    for (const [name, contract] of Object.entries(contractSet.contracts)) {\n      contracts[name] = contract;\n    }\n  }\n  return makeProto(contracts) as UnsafeTypes.UnsafeAny;\n};\n","export * from \"./clients\";\nexport * from \"./constants\";\n","import { paths } from \"@beep/shared-domain\";\nimport * as A from \"effect/Array\";\nimport * as F from \"effect/Function\";\nimport * as O from \"effect/Option\";\nimport * as Str from \"effect/String\";\n\nconst privateRoutePrefixes = [\n  paths.dashboard.root,\n  paths.settings.root,\n  paths.admin.root,\n  paths.organizations.root,\n  paths.auth.device.root,\n  \"/account\",\n  paths.fileManager.root,\n] as const;\n\nconst stripFragment = (value: string) =>\n  F.pipe(\n    Str.split(\"#\")(value),\n    A.head,\n    O.getOrElse(() => value)\n  );\n\nconst stripQuery = (value: string) =>\n  F.pipe(\n    Str.split(\"?\")(value),\n    A.head,\n    O.getOrElse(() => value)\n  );\n\nconst normalizePathname = (value: string) => F.pipe(value, stripFragment, stripQuery);\n\nconst startsWithPrefix = (pathname: string) =>\n  A.some(privateRoutePrefixes, (prefix) => Str.startsWith(prefix)(pathname));\n\nconst isAbsolutePath = (value: string) => Str.startsWith(\"/\")(value) && !Str.startsWith(\"//\")(value);\nexport const paramName = \"callbackURL\";\nexport const defaultTarget = `${paths.dashboard.root}`;\n\nexport type SearchParamsLike = Pick<URLSearchParams, \"get\">;\n\nexport const sanitizePath = (raw: string | null | undefined) => {\n  if (!raw) {\n    return defaultTarget;\n  }\n\n  if (!isAbsolutePath(raw)) {\n    return defaultTarget;\n  }\n\n  const normalized = normalizePathname(raw);\n\n  if (!startsWithPrefix(normalized)) {\n    return defaultTarget;\n  }\n\n  return raw;\n};\n\nexport const getURL = (queryParams: SearchParamsLike) => sanitizePath(queryParams.get(paramName));\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,7,8,9,10,11,14,15,17,18,19,20,21,24,26,27,28,29,30,31,36,39,42,43,46,49,50,51,52]}