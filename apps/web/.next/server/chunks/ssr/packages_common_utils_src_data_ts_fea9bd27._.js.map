{"version":3,"sources":["turbopack:///[project]/packages/common/utils/src/assertions/common.ts","turbopack:///[project]/packages/common/utils/src/data/array.utils/array.utils.ts","turbopack:///[project]/packages/common/utils/src/data/array.utils/NonEmptyReadonly/NonEmptyreadonly.ts","turbopack:///[project]/packages/common/utils/src/data/string.utils.ts","turbopack:///[project]/packages/common/utils/src/data/array.utils/order-by.ts","turbopack:///[project]/packages/common/utils/src/guards/isUnsafeProperty.guard.ts","turbopack:///[project]/packages/common/utils/src/data/object.utils/deep-merge.ts","turbopack:///[project]/packages/common/utils/src/data/record.utils.ts","turbopack:///[project]/packages/common/utils/src/data/struct.utils.ts"],"sourcesContent":["import * as F from \"effect/Function\";\nimport * as S from \"effect/Schema\";\n\nexport type AssertsFn<T> = (u: unknown) => asserts u is T;\n\nexport type MakeAssertsFn = <const A, const I, const R>(\n  schema: S.Schema<A, I, R>\n) => AssertsFn<S.Schema.Type<S.Schema<A, I, R>>>;\n\nexport const makeAssertsFn: MakeAssertsFn = <const A, const I, const R>(\n  schema: S.Schema<A, I, R>\n): AssertsFn<S.Schema.Type<S.Schema<A, I, R>>> => S.asserts(schema);\n\nexport type MakeAssertsReturn = <const A, const I, const R>(\n  schema: S.Schema<A, I, R>\n) => (input: unknown) => S.Schema.Type<S.Schema<A, I, R>>;\n\nexport const makeAssertsReturn: MakeAssertsReturn = F.dual<\n  <const A, const I, const R>(schema: S.Schema<A, I, R>) => (input: unknown) => S.Schema.Type<S.Schema<A, I, R>>,\n  <const A, const I, const R>(input: unknown, schema: S.Schema<A, I, R>) => S.Schema.Type<S.Schema<A, I, R>>\n>(2, <const A, const I, const R>(input: unknown, schema: S.Schema<A, I, R>): S.Schema.Type<S.Schema<A, I, R>> => {\n  const assertType: AssertsFn<S.Schema.Type<S.Schema<A, I, R>>> = makeAssertsFn(schema);\n  assertType(input);\n  return input as S.Schema.Type<S.Schema<A, I, R>>;\n});\n","import type { AssertsFn } from \"@beep/utils/assertions\";\nimport { makeAssertsFn, makeAssertsReturn } from \"@beep/utils/assertions\";\nimport type * as A from \"effect/Array\";\nimport * as S from \"effect/Schema\";\n\nexport const isNonEmptyReadonlyArrayOfGuard =\n  <const A, const I, const R>(self: S.Schema<A, I, R>) =>\n  (array: unknown): array is A.NonEmptyReadonlyArray<S.Schema.Type<S.Schema<A, I, R>>> =>\n    S.is(S.NonEmptyArray(self))(array);\n\ntype AssertIsNonEmptyArrayOf = <const A, const I, const R>(\n  elementSchema: S.Schema<A, I, R>\n) => AssertsFn<S.Schema.Type<S.Schema<A, I, R>>>;\n\nexport const assertIsNonEmptyArrayOf: AssertIsNonEmptyArrayOf = <const A, const I, const R>(\n  elementSchema: S.Schema<A, I, R>\n) => makeAssertsFn(S.NonEmptyArray(elementSchema));\n\ntype AssertReturnNonEmpty = <const A, const I, const R>(\n  elementSchema: S.Schema<A, I, R>\n) => AssertsFn<S.Schema.Type<S.Schema<A, I, R>>>;\n\nexport const assertReturnNonEmpty: AssertReturnNonEmpty = <const A, const I, const R>(\n  elementSchema: S.Schema<A, I, R>\n) => makeAssertsReturn(S.NonEmptyArray(elementSchema));\n","import * as A from \"effect/Array\";\nimport * as F from \"effect/Function\";\nimport * as O from \"effect/Option\";\n\nexport function make<const Value>(values: A.NonEmptyReadonlyArray<Value>): A.NonEmptyReadonlyArray<Value>;\nexport function make<const Value>(...values: A.NonEmptyReadonlyArray<Value>): A.NonEmptyReadonlyArray<Value>;\nexport function make<const Value>(...values: A.NonEmptyReadonlyArray<Value>): A.NonEmptyReadonlyArray<Value> {\n  return values;\n}\n\ntype MapWith = ReturnType<\n  typeof F.dual<\n    <const Value, const MappedValue>(\n      f: (value: Value, index: number, array: A.NonEmptyReadonlyArray<Value>) => MappedValue\n    ) => (self: A.NonEmptyReadonlyArray<Value>) => A.NonEmptyReadonlyArray<MappedValue>,\n    <const Value, const MappedValue>(\n      self: A.NonEmptyReadonlyArray<Value>,\n      f: (value: Value, index: number, array: A.NonEmptyReadonlyArray<Value>) => MappedValue\n    ) => A.NonEmptyReadonlyArray<MappedValue>\n  >\n>;\n\nexport const mapWith: MapWith = F.dual<\n  <const Value, const MappedValue>(\n    f: (value: Value, index: number, array: A.NonEmptyReadonlyArray<Value>) => MappedValue\n  ) => (self: A.NonEmptyReadonlyArray<Value>) => A.NonEmptyReadonlyArray<MappedValue>,\n  <const Value, const MappedValue>(\n    self: A.NonEmptyReadonlyArray<Value>,\n    f: (value: Value, index: number, array: A.NonEmptyReadonlyArray<Value>) => MappedValue\n  ) => A.NonEmptyReadonlyArray<MappedValue>\n>(\n  2,\n  <const Value, const MappedValue>(\n    self: A.NonEmptyReadonlyArray<Value>,\n    f: (value: Value, index: number, array: A.NonEmptyReadonlyArray<Value>) => MappedValue\n  ): A.NonEmptyReadonlyArray<MappedValue> => {\n    const headOption = A.head(self);\n    const tailOption = A.tail(self);\n    const head = O.getOrThrow(headOption);\n    const tail = O.getOrThrow(tailOption);\n    const mappedHead = f(head, 0, self);\n\n    if (tail.length === 0) {\n      return [mappedHead] as const;\n    }\n\n    const mappedTail = A.map(tail, (value, index) => f(value, index + 1, self));\n\n    return [mappedHead, ...mappedTail] as const;\n  }\n);\n","import type { StringTypes } from \"@beep/types\";\nimport * as A from \"effect/Array\";\nimport * as F from \"effect/Function\";\nimport * as Match from \"effect/Match\";\nimport * as O from \"effect/Option\";\nimport * as Record from \"effect/Record\";\nimport * as Str from \"effect/String\";\nimport * as ArrayUtils from \"./array.utils\";\n\n/**\n * Generates initials from a given name.\n *\n * @param {string | null | undefined} name - The name to generate initials from.\n * @returns {string} The initials (up to 2 characters) derived from the name, or \"?\" if the input is null, undefined, or empty.\n * @example\n * getNameInitials(\"John Doe\") // Returns \"JD\"\n * getNameInitials(\"Alice\") // Returns \"A\"\n * getNameInitials(null) // Returns \"?\"\n */\nexport const getNameInitials = (name: string | null | undefined): string => {\n  return F.pipe(\n    name === \"\" ? null : name,\n    O.fromNullable,\n    O.map(\n      F.flow(\n        Str.split(\" \"),\n        A.filter((word) => word.length > 0),\n        A.take(2),\n        A.map((word) => word[0]?.toUpperCase() ?? \"\"),\n        A.join(\"\")\n      )\n    ),\n    O.getOrElse(() => \"?\")\n  );\n};\n\n/**\n * Normalizes a string by removing diacritics, converting to lowercase, and performing additional normalization.\n * This function is useful for creating searchable or comparable versions of strings,\n * especially when dealing with text that may contain special characters or accents.\n *\n * @param {string} str - The input string to be normalized.\n * @returns {string} The normalized string.\n *\n * @example\n * normalizeString(\"Año\") // Returns \"ano\"\n * normalizeString(\"Café\") // Returns \"cafe\"\n * normalizeString(\"Größe\") // Returns \"grosse\"\n */\nexport type NormalizeString = (str: string) => string;\nexport const normalizeString: NormalizeString = F.flow(\n  Str.normalize(\"NFKD\"),\n  Str.replace(/[\\u0300-\\u036f]/g, \"\"), // Remove combining diacritical marks\n  Str.toLowerCase,\n  Str.replace(/[æœ]/g, \"ae\"),\n  Str.replace(/ø/g, \"o\"),\n  Str.replace(/ß/g, \"ss\")\n);\n\nexport const kebabCase = (value: string): string =>\n  F.pipe(value, Str.trim, (trimmed) =>\n    Str.isEmpty(trimmed)\n      ? \"\"\n      : F.pipe(\n          trimmed,\n          Str.replace(/([a-z\\d])([A-Z])/g, \"$1-$2\"),\n          Str.replace(/([A-Z]+)([A-Z][a-z])/g, \"$1-$2\"),\n          normalizeString,\n          Str.replace(/[^a-z0-9]+/g, \"-\"),\n          Str.replace(/-+/g, \"-\"),\n          Str.replace(/^-+/, \"\"),\n          Str.replace(/-+$/, \"\")\n        )\n  );\n\n/**\n * Formats the message by replacing double newlines with a space and removing asterisks around words.\n *\n * @param {string} message - The message to format.\n * @returns {string} The formatted message.\n * @example\n * stripMessageFormatting(\"Hello\\\\n\\\\nWorld\") // Returns \"Hello World\"\n * stripMessageFormatting(\"*Hello* World\") // Returns \"Hello World\"\n */\nexport type StripMessageFormatting = (message: string) => string;\nexport const stripMessageFormatting: StripMessageFormatting = F.flow(\n  Str.replace(/\\\\n\\\\n/g, \" \"),\n  Str.replace(/\\*(.*?)\\*/g, \"$1\")\n);\n\n/**\n * Interpolates variables in a template string using handlebars-style syntax.\n * Replaces patterns like {{variable.path}} with actual values from the provided data object.\n * Supports nested object access and array indexing with bracket notation (e.g., {{items.[0].name}}).\n *\n * @param {string} template - The template string containing variable placeholders in {{variable}} format.\n * @param {Record<string, unknown>} data - The data object containing values to interpolate.\n * @returns {string} The template string with variables replaced by their corresponding values.\n *\n * @example\n * const data = {\n *   user: { name: \"John\" },\n *   items: [{ product: { name: \"Widget\" } }],\n *   total: 99.99\n * };\n * interpolateTemplate(\"Hello {{user.name}}, your {{items.[0].product.name}} costs ${{total}}\", data)\n * // Returns \"Hello John, your Widget costs $99.99\"\n *\n * @example\n * interpolateTemplate(\"Welcome {{user.firstName}}!\", { user: { firstName: \"Alice\" } })\n * // Returns \"Welcome Alice!\"\n *\n * @example\n * // Variables not found in data are left unchanged\n * interpolateTemplate(\"Hello {{unknown.var}}\", {})\n * // Returns \"Hello {{unknown.var}}\"\n */\nexport const interpolateTemplate = (template: string, data: Record<string, unknown>): string => {\n  return template.replace(/\\{\\{([^}]+)}}/g, (match, variablePath: string) => {\n    const trimmedPath = variablePath.trim();\n    const value = getNestedValue(data, trimmedPath);\n    return value !== undefined ? String(value) : match;\n  });\n};\n\n/**\n * Safely extracts a nested value from an object using a dot-notation path.\n * Supports array indexing with bracket notation (e.g., \"items.[0].name\").\n *\n * @param {Record<string, unknown>} obj - The object to extract the value from.\n * @param {string} path - The dot-notation path to the desired value (e.g., \"user.profile.name\" or \"items.[0].id\").\n * @returns {unknown} The value at the specified path, or undefined if not found.\n *\n * @example\n * const data = { user: { profile: { name: \"John\" } }, items: [{ id: 1 }] };\n * getNestedValue(data, \"user.profile.name\") // Returns \"John\"\n * getNestedValue(data, \"items.[0].id\") // Returns 1\n * getNestedValue(data, \"nonexistent.path\") // Returns undefined\n */\nexport const getNestedValue = (obj: Record<string, unknown>, path: string): unknown => {\n  const parts = path.split(\".\");\n  let current: unknown = obj;\n\n  for (const part of parts) {\n    // Handle array notation like [0], [1], etc.\n    if (part.startsWith(\"[\") && part.endsWith(\"]\")) {\n      const index = Number.parseInt(part.slice(1, -1), 10);\n      if (A.isArray(current) && index >= 0 && index < current.length) {\n        current = current[index];\n      } else {\n        return undefined;\n      }\n    } else if (current && typeof current === \"object\" && part in current) {\n      current = (current as Record<string, unknown>)[part];\n    } else {\n      return undefined;\n    }\n  }\n\n  return current;\n};\n\nexport type LiteralValue = StringTypes.NonEmptyString;\n\nexport type ApplySuffix = <const Suffix extends LiteralValue, const Prefix extends LiteralValue>(\n  suffix: Suffix\n) => (prefix: Prefix) => `${Prefix}${Suffix}`;\n\nexport const applySuffix: ApplySuffix =\n  <const Suffix extends LiteralValue, const Prefix extends LiteralValue>(suffix: Suffix) =>\n  (prefix: Prefix) =>\n    `${prefix}${suffix}`;\n\nexport type ApplyPrefix = <const Prefix extends LiteralValue, const Suffix extends LiteralValue>(\n  prefix: Prefix\n) => (suffix: Suffix) => `${Prefix}${Suffix}`;\n\nexport const applyPrefix: ApplyPrefix =\n  <const Prefix extends LiteralValue, const Suffix extends LiteralValue>(prefix: Prefix) =>\n  (suffix: Suffix) =>\n    `${prefix}${suffix}`;\n\nexport function mapApplyPrefix<const Prefix extends LiteralValue>(\n  prefix: Prefix\n): {\n  <const Literal extends LiteralValue>(\n    literals: A.NonEmptyReadonlyArray<Literal>\n  ): A.NonEmptyReadonlyArray<`${Prefix}${Literal}`>;\n  <const Literals extends readonly [LiteralValue, ...LiteralValue[]]>(\n    ...literals: Literals\n  ): A.NonEmptyReadonlyArray<`${Prefix}${Literals[number]}`>;\n} {\n  const mapArray = <const Literals extends A.NonEmptyReadonlyArray<StringTypes.NonEmptyString>>(\n    literals: Literals\n  ): A.NonEmptyReadonlyArray<`${Prefix}${Literals[number]}`> => {\n    const applyFn = applyPrefix(prefix);\n    return ArrayUtils.NonEmptyReadonly.mapWith(applyFn)(literals);\n  };\n\n  const mapFn = <const Literal extends StringTypes.NonEmptyString>(\n    first: A.NonEmptyReadonlyArray<Literal> | Literal,\n    ...rest: Literal[]\n  ): A.NonEmptyReadonlyArray<`${Prefix}${Literal}`> => {\n    if (Array.isArray(first)) {\n      if (first.length === 0) {\n        throw new TypeError(\"Expected a non-empty readonly array of literals\");\n      }\n      return mapArray(first as A.NonEmptyReadonlyArray<Literal>);\n    }\n\n    const tuple = [first, ...rest] as readonly [Literal, ...Literal[]];\n    return mapArray(tuple as A.NonEmptyReadonlyArray<Literal>);\n  };\n\n  return mapFn as {\n    <const Literal extends LiteralValue>(\n      literals: A.NonEmptyReadonlyArray<Literal>\n    ): A.NonEmptyReadonlyArray<`${Prefix}${Literal}`>;\n    <const Literals extends readonly [StringTypes.NonEmptyString, ...StringTypes.NonEmptyString[]]>(\n      ...literals: Literals\n    ): A.NonEmptyReadonlyArray<`${Prefix}${Literals[number]}`>;\n  };\n}\n\nexport function mapApplySuffix<const Suffix extends StringTypes.NonEmptyString>(\n  suffix: Suffix\n): {\n  <const Literals extends A.NonEmptyReadonlyArray<StringTypes.NonEmptyString>>(\n    literals: Literals\n  ): A.NonEmptyReadonlyArray<`${Literals[number]}${Suffix}`>;\n  <const Literals extends readonly [StringTypes.NonEmptyString, ...StringTypes.NonEmptyString[]]>(\n    ...literals: Literals\n  ): A.NonEmptyReadonlyArray<`${Literals[number]}${Suffix}`>;\n} {\n  const mapArray = <Literals extends A.NonEmptyReadonlyArray<StringTypes.NonEmptyString>>(\n    literals: Literals\n  ): A.NonEmptyReadonlyArray<`${Literals[number]}${Suffix}`> => {\n    const applyFn = applySuffix(suffix);\n    return ArrayUtils.NonEmptyReadonly.mapWith(applyFn)(literals);\n  };\n\n  const mapFn = <const Literal extends StringTypes.NonEmptyString>(\n    first: A.NonEmptyReadonlyArray<Literal> | Literal,\n    ...rest: Literal[]\n  ): A.NonEmptyReadonlyArray<`${Literal}${Suffix}`> => {\n    if (Array.isArray(first)) {\n      if (first.length === 0) {\n        throw new TypeError(\"Expected a non-empty readonly array of literals\");\n      }\n      return mapArray(first as A.NonEmptyReadonlyArray<Literal>);\n    }\n\n    const tuple = [first, ...rest] as readonly [Literal, ...Literal[]];\n    return mapArray(tuple as A.NonEmptyReadonlyArray<Literal>);\n  };\n\n  return mapFn as {\n    <const Literal extends StringTypes.NonEmptyString>(\n      literals: A.NonEmptyReadonlyArray<Literal>\n    ): A.NonEmptyReadonlyArray<`${Literal}${Suffix}`>;\n    <const Literals extends readonly [StringTypes.NonEmptyString, ...StringTypes.NonEmptyString[]]>(\n      ...literals: Literals\n    ): A.NonEmptyReadonlyArray<`${Literals[number]}${Suffix}`>;\n  };\n}\n\nexport type StrLiteralFromNum = <T extends number>(value: T) => `${T}`;\n\nexport const strLiteralFromNum: StrLiteralFromNum = <T extends number>(value: T) => `${value}` as const;\n\nconst irregularPlurals: Record<string, string> = {\n  address: \"addresses\",\n  campus: \"campuses\",\n  child: \"children\",\n  person: \"people\",\n};\n\nconst irregularSingulars = F.pipe(\n  irregularPlurals,\n  Record.toEntries,\n  A.map(([a, b]) => [b, a] as const),\n  Record.fromEntries\n);\n\nexport function pluralize(word: string): string {\n  // Handle empty strings\n  if (Str.isEmpty(word)) return word;\n\n  const lower = word.toLowerCase();\n\n  // Check for irregular plurals (case-insensitive)\n  if (irregularPlurals[lower]) {\n    return preserveCase(word, irregularPlurals[lower]);\n  }\n\n  // Words ending in 'y' preceded by consonant\n  if (word.length > 1 && word.endsWith(\"y\")) {\n    const beforeY = word[word.length - 2] || \"\";\n    if (!\"aeiou\".includes(beforeY.toLowerCase())) {\n      return `${word.slice(0, -1)}ies`;\n    }\n  }\n\n  // Words ending in s, x, z, ch, sh\n  if (word.match(/[sxz]$|[cs]h$/)) {\n    return `${word}es`;\n  }\n\n  // Words ending in 'f' or 'fe'\n  if (word.endsWith(\"f\")) {\n    return `${word.slice(0, -1)}ves`;\n  }\n  if (word.endsWith(\"fe\")) {\n    return `${word.slice(0, -2)}ves`;\n  }\n\n  // Words ending in 'o' preceded by consonant\n  if (word.length > 1 && word.endsWith(\"o\")) {\n    const beforeO = word[word.length - 2] || \"\";\n    if (!\"aeiou\".includes(beforeO.toLowerCase())) {\n      // Common exceptions that just add 's'\n      const oExceptions = [\"photo\", \"piano\", \"halo\", \"solo\", \"pro\", \"auto\"];\n      if (!oExceptions.includes(lower)) {\n        return `${word}es`;\n      }\n    }\n  }\n\n  // Default: add 's'\n  return `${word}s`;\n}\n\nexport function singularize(word: string): string {\n  // Handle empty strings\n  if (!word) return word;\n\n  const lower = word.toLowerCase();\n\n  // Check for irregular singulars (case-insensitive)\n  if (irregularSingulars[lower]) {\n    return preserveCase(word, irregularSingulars[lower]);\n  }\n\n  // Check if word is already a singular form from our irregular plurals\n  // This prevents singularizing words that are already singular\n  const singularValues = F.pipe(irregularPlurals, Record.values);\n  if (F.pipe(singularValues, A.contains(lower))) {\n    return word;\n  }\n\n  // Words ending in 'us' are typically already singular (Latin origin)\n  // Common examples: campus, status, virus, focus, bonus, genus, etc.\n  if (word.endsWith(\"us\")) {\n    return word;\n  }\n\n  // Words ending in 'ies'\n  if (word.endsWith(\"ies\")) {\n    return `${word.slice(0, -3)}y`;\n  }\n\n  // Words ending in 'ves'\n  if (word.endsWith(\"ves\")) {\n    return `${word.slice(0, -3)}f`;\n  }\n\n  // Words ending in 'es'\n  if (word.endsWith(\"es\")) {\n    const base = word.slice(0, -2);\n    // Check if base ends in s, x, z, ch, sh\n    if (base.match(/[sxz]$|[cs]h$/)) {\n      return base;\n    }\n    // Check if base ends in 'o' preceded by consonant\n    if (base.length > 1 && base.endsWith(\"o\")) {\n      const beforeO = base[base.length - 2] || \"\";\n      if (!\"aeiou\".includes(beforeO.toLowerCase())) {\n        return base;\n      }\n    }\n    // Otherwise, it might be a regular 'e' ending\n    return `${base}e`;\n  }\n\n  // Words ending in 's' (but not 'ss')\n  if (word.endsWith(\"s\") && !word.endsWith(\"ss\")) {\n    return word.slice(0, -1);\n  }\n\n  // If no plural pattern found, return as is\n  return word;\n}\n\n// Helper function to preserve the case pattern of the original word\nfunction preserveCase(original: string, transformed: string): string {\n  if (F.pipe(original, Str.length) === 0) {\n    return transformed;\n  }\n\n  // If original is all uppercase\n  if (original === F.pipe(original, Str.toUpperCase)) {\n    return F.pipe(transformed, Str.toUpperCase);\n  }\n\n  // If original starts with uppercase\n  const firstChar = F.pipe(\n    original,\n    Str.charAt(0),\n    O.getOrElse(() => \"\")\n  );\n  if (firstChar === F.pipe(firstChar, Str.toUpperCase)) {\n    return F.pipe(transformed, Str.capitalize, Str.toLowerCase, Str.capitalize);\n  }\n\n  // Otherwise, return lowercase\n  return F.pipe(transformed, Str.toLowerCase);\n}\n\n/**\n * Converts table name to entity name (people -> Person, addresses -> Address)\n */\nexport type MkEntityName = (tableName: string) => string;\nexport const mkEntityName: MkEntityName = F.flow(Str.snakeToPascal, singularize);\n\n/**\n * Converts entity name to table name (Person -> people, Address -> addresses)\n */\nexport type MkTableName = (entityName: string) => string;\nexport const mkTableName: MkTableName = F.flow(Str.pascalToSnake, pluralize);\n\n/**\n * Converts entity name to Zero schema table name (Person -> people, PhoneNumber -> phoneNumbers)\n */\nexport type MkZeroTableName = (entityName: string) => string;\nexport const mkZeroTableName: MkZeroTableName = F.flow(Str.uncapitalize, pluralize);\n\n/**\n * Converts table name to entity type for IDs (people -> person, phone_numbers -> phonenumber)\n */\nexport type MkEntityType = (tableName: string) => string;\nexport const mkEntityType: MkEntityType = F.flow(Str.snakeToPascal, Str.toLowerCase, singularize);\n\n/**\n * Converts entity name to standardized URL parameter name (Person -> personId, PhoneNumber -> phoneNumberId)\n */\nexport type MkUrlParamName = (entityName: string) => string;\nexport const mkUrlParamName: MkUrlParamName = F.flow(Str.uncapitalize, Str.concat(\"Id\"));\n\n/**\n * Formats a field name into a human-readable label using Effect-TS String utilities\n * Handles snake_case, kebab-case, camelCase, PascalCase, and mixed formats\n * Examples:\n * - \"first_name\" -> \"First Name\"\n * - \"firstName\" -> \"First Name\"\n * - \"FirstName\" -> \"First Name\"\n * - \"first-name\" -> \"First Name\"\n * - \"phoneNumber2\" -> \"Phone Number 2\"\n */\nexport const formatLabel = (fieldName: string): string =>\n  F.pipe(\n    fieldName,\n    Match.value,\n    Match.when(Str.isEmpty, () => \"\"),\n    Match.when(Str.includes(\" \"), (name) => F.pipe(name, Str.split(\" \"), A.map(Str.capitalize), A.join(\" \"))),\n    Match.when(Str.includes(\"_\"), (name) => F.pipe(name, Str.split(\"_\"), A.map(Str.capitalize), A.join(\" \"))),\n    Match.when(Str.includes(\"-\"), (name) => F.pipe(name, Str.split(\"-\"), A.map(Str.capitalize), A.join(\" \"))),\n    Match.orElse((name) =>\n      F.pipe(\n        name,\n        // Convert camelCase/PascalCase to kebab-case with regex for numbers\n        Str.replace(/([a-z])([A-Z])/g, \"$1-$2\"),\n        Str.replace(/([a-z])(\\d)/g, \"$1-$2\"),\n        Str.replace(/(\\d)([A-Z])/g, \"$1-$2\"),\n        Str.toLowerCase,\n        Str.split(\"-\"),\n        A.map(Str.capitalize),\n        A.join(\" \")\n      )\n    )\n  );\n","import { getNestedValue } from \"@beep/utils/data/string.utils\";\nimport * as A from \"effect/Array\";\nimport * as F from \"effect/Function\";\nimport * as O from \"effect/Option\";\nimport * as Order from \"effect/Order\";\nimport * as Str from \"effect/String\";\n\nexport type OrderDirection = \"asc\" | \"desc\";\n\nexport type OrderIteratee<T> = ((item: T) => unknown) | string;\n\nexport const orderBy = <T>(\n  collection: ReadonlyArray<T>,\n  iteratees: ReadonlyArray<OrderIteratee<T>>,\n  directions: ReadonlyArray<OrderDirection | string> = []\n): ReadonlyArray<T> =>\n  F.pipe(\n    iteratees,\n    A.reduce(\n      {\n        index: 0,\n        orders: [] as ReadonlyArray<Order.Order<T>>,\n      },\n      (state, iteratee) => {\n        const direction = F.pipe(\n          directions,\n          A.get(state.index),\n          O.map(normalizeDirection),\n          O.getOrElse<OrderDirection>(() => \"asc\")\n        );\n\n        const accessor = toAccessor(iteratee);\n        const finalOrder = Order.make<T>((left, right) => {\n          const leftValue = accessor(left);\n          const rightValue = accessor(right);\n          const baseResult = compareUnknown(leftValue, rightValue);\n\n          if (baseResult === 0) {\n            return 0;\n          }\n\n          if (isNullish(leftValue) || isNullish(rightValue)) {\n            return baseResult;\n          }\n\n          return direction === \"desc\" ? invertResult(baseResult) : baseResult;\n        });\n\n        return {\n          index: state.index + 1,\n          orders: F.pipe(state.orders, A.append(finalOrder)),\n        };\n      }\n    ),\n    ({ orders }) =>\n      F.pipe(\n        orders,\n        A.match({\n          onEmpty: () => collection,\n          onNonEmpty: (nonEmpty) => F.pipe(collection, A.sort(combineComparators(nonEmpty))),\n        })\n      )\n  );\n\nconst combineComparators = <T>(orders: A.NonEmptyReadonlyArray<Order.Order<T>>): Order.Order<T> =>\n  Order.combineAll(orders);\n\nconst toAccessor =\n  <T>(iteratee: OrderIteratee<T>) =>\n  (item: T): unknown =>\n    typeof iteratee === \"function\" ? iteratee(item) : getNestedValue(item as Record<string, unknown>, iteratee);\n\nconst isNullish = (value: unknown): boolean => value === null || value === undefined;\n\nconst invertResult = (value: -1 | 0 | 1): -1 | 0 | 1 => (value === 0 ? 0 : ((value * -1) as -1 | 0 | 1));\n\nconst normalizeDirection = (input: OrderDirection | string): OrderDirection =>\n  F.pipe(input, Str.trim, Str.toLowerCase, (value) => (value === \"desc\" ? \"desc\" : \"asc\"));\n\nconst compareUnknown = (left: unknown, right: unknown): -1 | 0 | 1 => {\n  if (Object.is(left, right)) {\n    return 0;\n  }\n\n  if (left === undefined || left === null) {\n    return 1;\n  }\n\n  if (right === undefined || right === null) {\n    return -1;\n  }\n\n  if (typeof left === \"number\" && typeof right === \"number\") {\n    if (Number.isNaN(left)) {\n      return Number.isNaN(right) ? 0 : 1;\n    }\n    if (Number.isNaN(right)) {\n      return -1;\n    }\n    return normalizeOrderResult(Order.number(left, right));\n  }\n\n  if (typeof left === \"bigint\" && typeof right === \"bigint\") {\n    return normalizeOrderResult(Order.bigint(left, right));\n  }\n\n  if (typeof left === \"boolean\" && typeof right === \"boolean\") {\n    return normalizeOrderResult(Order.boolean(left, right));\n  }\n\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    return normalizeOrderResult(Order.string(left, right));\n  }\n\n  if (left instanceof Date && right instanceof Date) {\n    return normalizeOrderResult(Order.Date(left, right));\n  }\n\n  if (typeof left === \"symbol\" && typeof right === \"symbol\") {\n    return normalizeOrderResult(Order.string(String(left), String(right)));\n  }\n\n  if (A.isArray(left) && A.isArray(right)) {\n    return normalizeOrderResult(Order.string(JSON.stringify(left), JSON.stringify(right)));\n  }\n\n  if (typeof left === \"object\" && typeof right === \"object\") {\n    return normalizeOrderResult(Order.string(JSON.stringify(left), JSON.stringify(right)));\n  }\n\n  return normalizeOrderResult(Order.string(String(left), String(right)));\n};\n\nconst normalizeOrderResult = (value: number): -1 | 0 | 1 => (value < 0 ? -1 : value > 0 ? 1 : 0);\n","/**\n * Checks if a property key is unsafe to modify directly.\n *\n * This function is used in functions like `merge` to prevent prototype pollution attacks\n * by identifying property keys that could modify the object's prototype chain or constructor.\n *\n * @param key - The property key to check\n * @returns `true` if the property is unsafe to modify directly, `false` otherwise\n * @internal\n */\nexport type IsUnsafeProperty = (key: PropertyKey) => boolean;\n\nexport const isUnsafeProperty: IsUnsafeProperty = (key: PropertyKey) => key === \"__proto__\";\n","import { isUnsafeProperty } from \"@beep/utils/guards\";\nimport * as A from \"effect/Array\";\nimport * as F from \"effect/Function\";\nimport * as O from \"effect/Option\";\nimport * as P from \"effect/Predicate\";\nimport * as Struct from \"effect/Struct\";\n\ntype PlainRecord = Record<PropertyKey, unknown>;\n\ntype Simplify<T> = { [K in keyof T]: T[K] } & {};\n\ntype IsArray<T> = T extends ReadonlyArray<any> ? true : false;\ntype IsFunction<T> = T extends (...args: ReadonlyArray<any>) => unknown ? true : false;\ntype IsPlainObject<T> = T extends object\n  ? IsArray<T> extends true\n    ? false\n    : IsFunction<T> extends true\n      ? false\n      : true\n  : false;\n\ntype DeepMergeValue<TValue, TValueSource> = [TValueSource] extends [undefined]\n  ? TValue\n  : IsArray<TValue> extends true\n    ? TValueSource extends ReadonlyArray<infer TSourceElement>\n      ? TValue extends ReadonlyArray<infer TTargetElement>\n        ? ReadonlyArray<DeepMergeValue<TTargetElement, TSourceElement>>\n        : TValueSource\n      : TValueSource\n    : IsPlainObject<TValue> extends true\n      ? IsPlainObject<TValueSource> extends true\n        ? DeepMergeTwo<TValue & PlainRecord, TValueSource & PlainRecord>\n        : TValueSource\n      : TValueSource;\n\ntype DeepMergeTwo<Target, Source> = Simplify<{\n  [Key in keyof Target | keyof Source]: DeepMergeValue<\n    Key extends keyof Target ? Target[Key] : undefined,\n    Key extends keyof Source ? Source[Key] : undefined\n  >;\n}>;\n\ntype DeepMergeAll<Target, Sources extends ReadonlyArray<object>> = Sources extends readonly [infer Head, ...infer Rest]\n  ? Head extends object\n    ? Rest extends ReadonlyArray<object>\n      ? DeepMergeAll<DeepMergeTwo<Target, Head>, Rest>\n      : DeepMergeTwo<Target, Head>\n    : Target\n  : Target;\n\nexport type DeepMergeResult<Target extends object, Sources extends ReadonlyArray<object>> = Simplify<\n  DeepMergeAll<Target, Sources>\n>;\n\nconst emptyArray: ReadonlyArray<unknown> = [];\nconst emptyObject: PlainRecord = {};\n\nconst isPlainObject = (value: unknown): value is PlainRecord => !A.isArray(value) && P.isRecord(value);\n\nconst assignProperty = (target: PlainRecord, key: PropertyKey, value: unknown): PlainRecord =>\n  Object.is((target as PlainRecord)[key], value) ? target : { ...target, [key]: value };\n\nconst cloneValue = (value: unknown): unknown => {\n  if (A.isArray(value)) {\n    return mergeArrays(emptyArray, value);\n  }\n\n  if (isPlainObject(value)) {\n    return mergeObjects(emptyObject, value);\n  }\n\n  return value;\n};\n\nconst mergeArrayElement = (target: O.Option<unknown>, source: O.Option<unknown>): unknown =>\n  F.pipe(\n    source,\n    O.match({\n      onNone: () =>\n        F.pipe(\n          target,\n          O.getOrElse(() => undefined)\n        ),\n      onSome: (sourceValue) =>\n        sourceValue === undefined\n          ? F.pipe(\n              target,\n              O.getOrElse(() => undefined)\n            )\n          : F.pipe(\n              target,\n              O.match({\n                onNone: () => cloneValue(sourceValue),\n                onSome: (targetValue) => mergeBranch(targetValue, sourceValue),\n              })\n            ),\n    })\n  );\n\nconst mergeArrays = (target: ReadonlyArray<unknown>, source: ReadonlyArray<unknown>): ReadonlyArray<unknown> => {\n  const maxLength = Math.max(A.length(target), A.length(source));\n\n  const loop = (index: number, acc: ReadonlyArray<unknown>): ReadonlyArray<unknown> =>\n    index >= maxLength\n      ? acc\n      : loop(\n          index + 1,\n          F.pipe(acc, A.append(mergeArrayElement(F.pipe(target, A.get(index)), F.pipe(source, A.get(index)))))\n        );\n\n  return loop(0, emptyArray);\n};\n\nconst mergeBranch = (targetValue: unknown, sourceValue: unknown): unknown => {\n  if (A.isArray(sourceValue)) {\n    const normalizedTarget = A.isArray(targetValue) ? targetValue : emptyArray;\n    return mergeArrays(normalizedTarget, sourceValue);\n  }\n\n  if (isPlainObject(sourceValue)) {\n    const normalizedTarget = isPlainObject(targetValue) ? targetValue : emptyObject;\n    return mergeObjects(normalizedTarget, sourceValue);\n  }\n\n  return sourceValue;\n};\n\nconst mergeObjects = (target: PlainRecord, source: PlainRecord): PlainRecord =>\n  F.pipe(\n    Struct.entries(source),\n    A.reduce(target, (acc, [key, sourceValue]) => {\n      if (isUnsafeProperty(key) || sourceValue === undefined) {\n        return acc;\n      }\n\n      const currentValue = (acc as PlainRecord)[key];\n      const nextValue = mergeBranch(currentValue, sourceValue);\n      return assignProperty(acc, key, nextValue);\n    })\n  );\n\nconst cloneTarget = (target: PlainRecord): PlainRecord =>\n  F.pipe(\n    Struct.entries(target),\n    A.reduce(emptyObject, (acc, [key, value]) => assignProperty(acc, key, value))\n  );\n\n/**\n * Deeply merges objects and arrays without mutating the inputs.\n * - `undefined` values in sources do not overwrite defined target values.\n * - Arrays are merged by index, preserving the behavior of the previous external helper.\n * - Plain objects are merged recursively.\n */\nexport function deepMerge<Target extends object, const Sources extends ReadonlyArray<object>>(\n  target: Target,\n  ...sources: Sources\n): DeepMergeResult<Target, Sources> {\n  const normalizedSources = F.pipe(\n    sources,\n    A.filter((source): source is PlainRecord => isPlainObject(source))\n  );\n\n  const baseTarget = isPlainObject(target) ? target : emptyObject;\n\n  return F.pipe(\n    normalizedSources,\n    A.reduce(cloneTarget(baseTarget), (acc, source) => mergeObjects(acc, source))\n  ) as DeepMergeResult<Target, Sources>;\n}\n","import type { RecordTypes, StringTypes, UnsafeTypes } from \"@beep/types\";\nimport { isUnsafeProperty } from \"@beep/utils/guards\";\nimport type * as A from \"effect/Array\";\nimport * as HashSet from \"effect/HashSet\";\nimport * as P from \"effect/Predicate\";\nimport * as R from \"effect/Record\";\nimport * as Struct from \"effect/Struct\";\nexport const recordKeys = <T extends UnsafeTypes.UnsafeReadonlyRecord>(\n  record: RecordTypes.NonEmptyRecordWithStringKeys<T>\n): A.NonEmptyReadonlyArray<keyof T> => {\n  const set = HashSet.make(...Struct.keys(record));\n  return HashSet.values(set) as unknown as A.NonEmptyReadonlyArray<keyof T>;\n};\n\nexport const recordStringValues = <R extends RecordTypes.RecordStringKeyValueString>(\n  r: RecordTypes.NonEmptyRecordStringKeyValues<R>\n) => {\n  return R.values(r) as unknown as RecordTypes.ReadonlyRecordValuesNonEmptyArray<\n    RecordTypes.NonEmptyRecordStringKeyValues<R>\n  >;\n};\n\nexport const reverseRecord = <\n  T extends R.ReadonlyRecord<keyof T & StringTypes.NonEmptyString, StringTypes.NonEmptyString>,\n>(\n  obj: T\n): RecordTypes.ReversedRecord<T> =>\n  Object.fromEntries(Object.entries(obj).map(([key, value]) => [value, key] as const));\n\n/**\n * Merges the properties of the source object into the target object.\n *\n * This function performs a deep merge, meaning nested objects and arrays are merged recursively.\n * If a property in the source object is an array or an object and the corresponding property in the target object is also an array or object, they will be merged.\n * If a property in the source object is undefined, it will not overwrite a defined property in the target object.\n *\n * Note that this function mutates the target object.\n *\n * @param {T} target - The target object into which the source object properties will be merged. This object is modified in place.\n * @param {S} source - The source object whose properties will be merged into the target object.\n * @returns {T & S} The updated target object with properties from the source object merged in.\n *\n * @template T - Type of the target object.\n * @template S - Type of the source object.\n *\n * @example\n * const target = { a: 1, b: { x: 1, y: 2 } };\n * const source = { b: { y: 3, z: 4 }, c: 5 };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: 1, b: { x: 1, y: 3, z: 4 }, c: 5 }\n *\n * @example\n * const target = { a: [1, 2], b: { x: 1 } };\n * const source = { a: [3], b: { y: 2 } };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [3, 2], b: { x: 1, y: 2 } }\n *\n * @example\n * const target = { a: null };\n * const source = { a: [1, 2, 3] };\n *\n * const result = merge(target, source);\n * console.log(result);\n * // Output: { a: [1, 2, 3] }\n */\nexport function merge<\n  T extends Record<PropertyKey, UnsafeTypes.UnsafeAny>,\n  S extends Record<PropertyKey, UnsafeTypes.UnsafeAny>,\n>(target: T, source: S): T & S {\n  const sourceKeys = Struct.keys(source);\n\n  for (let i = 0; i < sourceKeys.length; i++) {\n    const key = sourceKeys[i]!;\n\n    if (isUnsafeProperty(key)) {\n      continue;\n    }\n\n    const sourceValue = source[key];\n    const targetValue = target[key];\n\n    if (Array.isArray(sourceValue)) {\n      if (Array.isArray(targetValue)) {\n        target[key] = merge(targetValue, sourceValue);\n      } else {\n        target[key] = merge([], sourceValue);\n      }\n    } else if (P.isRecord(sourceValue)) {\n      if (P.isRecord(targetValue)) {\n        target[key] = merge(targetValue, sourceValue);\n      } else {\n        target[key] = merge({}, sourceValue);\n      }\n    } else if (targetValue === undefined || sourceValue !== undefined) {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","import type { RecordTypes, StructTypes } from \"@beep/types\";\nimport type * as A from \"effect/Array\";\nimport * as Struct from \"effect/Struct\";\nexport const structEntries = <T extends RecordTypes.RecordStringKeyValueString>(\n  s: RecordTypes.NonEmptyRecordStringKeyValues<T>\n) => {\n  return Struct.entries(s) as unknown as RecordTypes.ReadonlyRecordEntriesNonEmptyArray<T>;\n};\n\nexport const structKeys = <T extends StructTypes.StructFieldsWithStringKeys>(\n  s: StructTypes.NonEmptyStructFields<T>\n) => {\n  return Struct.keys(s) as unknown as A.NonEmptyReadonlyArray<keyof T & string>;\n};\n"],"names":[],"mappings":"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"}