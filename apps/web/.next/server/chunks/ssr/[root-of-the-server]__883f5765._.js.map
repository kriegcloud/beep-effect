{"version":3,"sources":["turbopack:///[project]/node_modules/@mui/material/esm/Button/Button.js","turbopack:///[project]/node_modules/@mui/material/esm/Button/buttonClasses.js","turbopack:///[project]/node_modules/@mui/material/esm/ButtonGroup/ButtonGroupContext.js","turbopack:///[project]/node_modules/@mui/material/esm/ButtonGroup/ButtonGroupButtonContext.js","turbopack:///[project]/node_modules/effect/src/Schedule.ts","turbopack:///[project]/packages/ui-core/src/theme/theme-config.ts","turbopack:///[project]/packages/ui-core/src/theme/create-classes.ts","turbopack:///[project]/node_modules/@mui/utils/esm/usePreviousProps/usePreviousProps.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport resolveProps from '@mui/utils/resolveProps';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { unstable_useId as useId } from \"../utils/index.js\";\nimport rootShouldForwardProp from \"../styles/rootShouldForwardProp.js\";\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport ButtonBase from \"../ButtonBase/index.js\";\nimport CircularProgress from \"../CircularProgress/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport buttonClasses, { getButtonUtilityClass } from \"./buttonClasses.js\";\nimport ButtonGroupContext from \"../ButtonGroup/ButtonGroupContext.js\";\nimport ButtonGroupButtonContext from \"../ButtonGroup/ButtonGroupButtonContext.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    disableElevation,\n    fullWidth,\n    size,\n    variant,\n    loading,\n    loadingPosition,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', loading && 'loading', variant, `${variant}${capitalize(color)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, `color${capitalize(color)}`, disableElevation && 'disableElevation', fullWidth && 'fullWidth', loading && `loadingPosition${capitalize(loadingPosition)}`],\n    startIcon: ['icon', 'startIcon', `iconSize${capitalize(size)}`],\n    endIcon: ['icon', 'endIcon', `iconSize${capitalize(size)}`],\n    loadingIndicator: ['loadingIndicator'],\n    loadingWrapper: ['loadingWrapper']\n  };\n  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);\n  return {\n    ...classes,\n    // forward the focused, disabled, etc. classes to the ButtonBase\n    ...composedClasses\n  };\n};\nconst commonIconStyles = [{\n  props: {\n    size: 'small'\n  },\n  style: {\n    '& > *:nth-of-type(1)': {\n      fontSize: 18\n    }\n  }\n}, {\n  props: {\n    size: 'medium'\n  },\n  style: {\n    '& > *:nth-of-type(1)': {\n      fontSize: 20\n    }\n  }\n}, {\n  props: {\n    size: 'large'\n  },\n  style: {\n    '& > *:nth-of-type(1)': {\n      fontSize: 22\n    }\n  }\n}];\nconst ButtonRoot = styled(ButtonBase, {\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  name: 'MuiButton',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[ownerState.variant], styles[`${ownerState.variant}${capitalize(ownerState.color)}`], styles[`size${capitalize(ownerState.size)}`], styles[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === 'inherit' && styles.colorInherit, ownerState.disableElevation && styles.disableElevation, ownerState.fullWidth && styles.fullWidth, ownerState.loading && styles.loading];\n  }\n})(memoTheme(({\n  theme\n}) => {\n  const inheritContainedBackgroundColor = theme.palette.mode === 'light' ? theme.palette.grey[300] : theme.palette.grey[800];\n  const inheritContainedHoverBackgroundColor = theme.palette.mode === 'light' ? theme.palette.grey.A100 : theme.palette.grey[700];\n  return {\n    ...theme.typography.button,\n    minWidth: 64,\n    padding: '6px 16px',\n    border: 0,\n    borderRadius: (theme.vars || theme).shape.borderRadius,\n    transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color', 'color'], {\n      duration: theme.transitions.duration.short\n    }),\n    '&:hover': {\n      textDecoration: 'none'\n    },\n    [`&.${buttonClasses.disabled}`]: {\n      color: (theme.vars || theme).palette.action.disabled\n    },\n    variants: [{\n      props: {\n        variant: 'contained'\n      },\n      style: {\n        color: `var(--variant-containedColor)`,\n        backgroundColor: `var(--variant-containedBg)`,\n        boxShadow: (theme.vars || theme).shadows[2],\n        '&:hover': {\n          boxShadow: (theme.vars || theme).shadows[4],\n          // Reset on touch devices, it doesn't add specificity\n          '@media (hover: none)': {\n            boxShadow: (theme.vars || theme).shadows[2]\n          }\n        },\n        '&:active': {\n          boxShadow: (theme.vars || theme).shadows[8]\n        },\n        [`&.${buttonClasses.focusVisible}`]: {\n          boxShadow: (theme.vars || theme).shadows[6]\n        },\n        [`&.${buttonClasses.disabled}`]: {\n          color: (theme.vars || theme).palette.action.disabled,\n          boxShadow: (theme.vars || theme).shadows[0],\n          backgroundColor: (theme.vars || theme).palette.action.disabledBackground\n        }\n      }\n    }, {\n      props: {\n        variant: 'outlined'\n      },\n      style: {\n        padding: '5px 15px',\n        border: '1px solid currentColor',\n        borderColor: `var(--variant-outlinedBorder, currentColor)`,\n        backgroundColor: `var(--variant-outlinedBg)`,\n        color: `var(--variant-outlinedColor)`,\n        [`&.${buttonClasses.disabled}`]: {\n          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`\n        }\n      }\n    }, {\n      props: {\n        variant: 'text'\n      },\n      style: {\n        padding: '6px 8px',\n        color: `var(--variant-textColor)`,\n        backgroundColor: `var(--variant-textBg)`\n      }\n    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color]) => ({\n      props: {\n        color\n      },\n      style: {\n        '--variant-textColor': (theme.vars || theme).palette[color].main,\n        '--variant-outlinedColor': (theme.vars || theme).palette[color].main,\n        '--variant-outlinedBorder': theme.alpha((theme.vars || theme).palette[color].main, 0.5),\n        '--variant-containedColor': (theme.vars || theme).palette[color].contrastText,\n        '--variant-containedBg': (theme.vars || theme).palette[color].main,\n        '@media (hover: hover)': {\n          '&:hover': {\n            '--variant-containedBg': (theme.vars || theme).palette[color].dark,\n            '--variant-textBg': theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.hoverOpacity),\n            '--variant-outlinedBorder': (theme.vars || theme).palette[color].main,\n            '--variant-outlinedBg': theme.alpha((theme.vars || theme).palette[color].main, (theme.vars || theme).palette.action.hoverOpacity)\n          }\n        }\n      }\n    })), {\n      props: {\n        color: 'inherit'\n      },\n      style: {\n        color: 'inherit',\n        borderColor: 'currentColor',\n        '--variant-containedBg': theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,\n        '@media (hover: hover)': {\n          '&:hover': {\n            '--variant-containedBg': theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,\n            '--variant-textBg': theme.alpha((theme.vars || theme).palette.text.primary, (theme.vars || theme).palette.action.hoverOpacity),\n            '--variant-outlinedBg': theme.alpha((theme.vars || theme).palette.text.primary, (theme.vars || theme).palette.action.hoverOpacity)\n          }\n        }\n      }\n    }, {\n      props: {\n        size: 'small',\n        variant: 'text'\n      },\n      style: {\n        padding: '4px 5px',\n        fontSize: theme.typography.pxToRem(13)\n      }\n    }, {\n      props: {\n        size: 'large',\n        variant: 'text'\n      },\n      style: {\n        padding: '8px 11px',\n        fontSize: theme.typography.pxToRem(15)\n      }\n    }, {\n      props: {\n        size: 'small',\n        variant: 'outlined'\n      },\n      style: {\n        padding: '3px 9px',\n        fontSize: theme.typography.pxToRem(13)\n      }\n    }, {\n      props: {\n        size: 'large',\n        variant: 'outlined'\n      },\n      style: {\n        padding: '7px 21px',\n        fontSize: theme.typography.pxToRem(15)\n      }\n    }, {\n      props: {\n        size: 'small',\n        variant: 'contained'\n      },\n      style: {\n        padding: '4px 10px',\n        fontSize: theme.typography.pxToRem(13)\n      }\n    }, {\n      props: {\n        size: 'large',\n        variant: 'contained'\n      },\n      style: {\n        padding: '8px 22px',\n        fontSize: theme.typography.pxToRem(15)\n      }\n    }, {\n      props: {\n        disableElevation: true\n      },\n      style: {\n        boxShadow: 'none',\n        '&:hover': {\n          boxShadow: 'none'\n        },\n        [`&.${buttonClasses.focusVisible}`]: {\n          boxShadow: 'none'\n        },\n        '&:active': {\n          boxShadow: 'none'\n        },\n        [`&.${buttonClasses.disabled}`]: {\n          boxShadow: 'none'\n        }\n      }\n    }, {\n      props: {\n        fullWidth: true\n      },\n      style: {\n        width: '100%'\n      }\n    }, {\n      props: {\n        loadingPosition: 'center'\n      },\n      style: {\n        transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color'], {\n          duration: theme.transitions.duration.short\n        }),\n        [`&.${buttonClasses.loading}`]: {\n          color: 'transparent'\n        }\n      }\n    }]\n  };\n}));\nconst ButtonStartIcon = styled('span', {\n  name: 'MuiButton',\n  slot: 'StartIcon',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.startIcon, ownerState.loading && styles.startIconLoadingStart, styles[`iconSize${capitalize(ownerState.size)}`]];\n  }\n})(({\n  theme\n}) => ({\n  display: 'inherit',\n  marginRight: 8,\n  marginLeft: -4,\n  variants: [{\n    props: {\n      size: 'small'\n    },\n    style: {\n      marginLeft: -2\n    }\n  }, {\n    props: {\n      loadingPosition: 'start',\n      loading: true\n    },\n    style: {\n      transition: theme.transitions.create(['opacity'], {\n        duration: theme.transitions.duration.short\n      }),\n      opacity: 0\n    }\n  }, {\n    props: {\n      loadingPosition: 'start',\n      loading: true,\n      fullWidth: true\n    },\n    style: {\n      marginRight: -8\n    }\n  }, ...commonIconStyles]\n}));\nconst ButtonEndIcon = styled('span', {\n  name: 'MuiButton',\n  slot: 'EndIcon',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.endIcon, ownerState.loading && styles.endIconLoadingEnd, styles[`iconSize${capitalize(ownerState.size)}`]];\n  }\n})(({\n  theme\n}) => ({\n  display: 'inherit',\n  marginRight: -4,\n  marginLeft: 8,\n  variants: [{\n    props: {\n      size: 'small'\n    },\n    style: {\n      marginRight: -2\n    }\n  }, {\n    props: {\n      loadingPosition: 'end',\n      loading: true\n    },\n    style: {\n      transition: theme.transitions.create(['opacity'], {\n        duration: theme.transitions.duration.short\n      }),\n      opacity: 0\n    }\n  }, {\n    props: {\n      loadingPosition: 'end',\n      loading: true,\n      fullWidth: true\n    },\n    style: {\n      marginLeft: -8\n    }\n  }, ...commonIconStyles]\n}));\nconst ButtonLoadingIndicator = styled('span', {\n  name: 'MuiButton',\n  slot: 'LoadingIndicator'\n})(({\n  theme\n}) => ({\n  display: 'none',\n  position: 'absolute',\n  visibility: 'visible',\n  variants: [{\n    props: {\n      loading: true\n    },\n    style: {\n      display: 'flex'\n    }\n  }, {\n    props: {\n      loadingPosition: 'start'\n    },\n    style: {\n      left: 14\n    }\n  }, {\n    props: {\n      loadingPosition: 'start',\n      size: 'small'\n    },\n    style: {\n      left: 10\n    }\n  }, {\n    props: {\n      variant: 'text',\n      loadingPosition: 'start'\n    },\n    style: {\n      left: 6\n    }\n  }, {\n    props: {\n      loadingPosition: 'center'\n    },\n    style: {\n      left: '50%',\n      transform: 'translate(-50%)',\n      color: (theme.vars || theme).palette.action.disabled\n    }\n  }, {\n    props: {\n      loadingPosition: 'end'\n    },\n    style: {\n      right: 14\n    }\n  }, {\n    props: {\n      loadingPosition: 'end',\n      size: 'small'\n    },\n    style: {\n      right: 10\n    }\n  }, {\n    props: {\n      variant: 'text',\n      loadingPosition: 'end'\n    },\n    style: {\n      right: 6\n    }\n  }, {\n    props: {\n      loadingPosition: 'start',\n      fullWidth: true\n    },\n    style: {\n      position: 'relative',\n      left: -10\n    }\n  }, {\n    props: {\n      loadingPosition: 'end',\n      fullWidth: true\n    },\n    style: {\n      position: 'relative',\n      right: -10\n    }\n  }]\n}));\nconst ButtonLoadingIconPlaceholder = styled('span', {\n  name: 'MuiButton',\n  slot: 'LoadingIconPlaceholder'\n})({\n  display: 'inline-block',\n  width: '1em',\n  height: '1em'\n});\nconst Button = /*#__PURE__*/React.forwardRef(function Button(inProps, ref) {\n  // props priority: `inProps` > `contextProps` > `themeDefaultProps`\n  const contextProps = React.useContext(ButtonGroupContext);\n  const buttonGroupButtonContextPositionClassName = React.useContext(ButtonGroupButtonContext);\n  const resolvedProps = resolveProps(contextProps, inProps);\n  const props = useDefaultProps({\n    props: resolvedProps,\n    name: 'MuiButton'\n  });\n  const {\n    children,\n    color = 'primary',\n    component = 'button',\n    className,\n    disabled = false,\n    disableElevation = false,\n    disableFocusRipple = false,\n    endIcon: endIconProp,\n    focusVisibleClassName,\n    fullWidth = false,\n    id: idProp,\n    loading = null,\n    loadingIndicator: loadingIndicatorProp,\n    loadingPosition = 'center',\n    size = 'medium',\n    startIcon: startIconProp,\n    type,\n    variant = 'text',\n    ...other\n  } = props;\n  const loadingId = useId(idProp);\n  const loadingIndicator = loadingIndicatorProp ?? /*#__PURE__*/_jsx(CircularProgress, {\n    \"aria-labelledby\": loadingId,\n    color: \"inherit\",\n    size: 16\n  });\n  const ownerState = {\n    ...props,\n    color,\n    component,\n    disabled,\n    disableElevation,\n    disableFocusRipple,\n    fullWidth,\n    loading,\n    loadingIndicator,\n    loadingPosition,\n    size,\n    type,\n    variant\n  };\n  const classes = useUtilityClasses(ownerState);\n  const startIcon = (startIconProp || loading && loadingPosition === 'start') && /*#__PURE__*/_jsx(ButtonStartIcon, {\n    className: classes.startIcon,\n    ownerState: ownerState,\n    children: startIconProp || /*#__PURE__*/_jsx(ButtonLoadingIconPlaceholder, {\n      className: classes.loadingIconPlaceholder,\n      ownerState: ownerState\n    })\n  });\n  const endIcon = (endIconProp || loading && loadingPosition === 'end') && /*#__PURE__*/_jsx(ButtonEndIcon, {\n    className: classes.endIcon,\n    ownerState: ownerState,\n    children: endIconProp || /*#__PURE__*/_jsx(ButtonLoadingIconPlaceholder, {\n      className: classes.loadingIconPlaceholder,\n      ownerState: ownerState\n    })\n  });\n  const positionClassName = buttonGroupButtonContextPositionClassName || '';\n  const loader = typeof loading === 'boolean' ?\n  /*#__PURE__*/\n  // use plain HTML span to minimize the runtime overhead\n  _jsx(\"span\", {\n    className: classes.loadingWrapper,\n    style: {\n      display: 'contents'\n    },\n    children: loading && /*#__PURE__*/_jsx(ButtonLoadingIndicator, {\n      className: classes.loadingIndicator,\n      ownerState: ownerState,\n      children: loadingIndicator\n    })\n  }) : null;\n  return /*#__PURE__*/_jsxs(ButtonRoot, {\n    ownerState: ownerState,\n    className: clsx(contextProps.className, classes.root, className, positionClassName),\n    component: component,\n    disabled: disabled || loading,\n    focusRipple: !disableFocusRipple,\n    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),\n    ref: ref,\n    type: type,\n    id: loading ? loadingId : idProp,\n    ...other,\n    classes: classes,\n    children: [startIcon, loadingPosition !== 'end' && loader, children, loadingPosition === 'end' && loader, endIcon]\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? Button.propTypes /* remove-proptypes */ = {\n  // ┌────────────────────────────── Warning ──────────────────────────────┐\n  // │ These PropTypes are generated from the TypeScript type definitions. │\n  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │\n  // └─────────────────────────────────────────────────────────────────────┘\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['inherit', 'primary', 'secondary', 'success', 'error', 'info', 'warning']), PropTypes.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, no elevation is used.\n   * @default false\n   */\n  disableElevation: PropTypes.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   *\n   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure\n   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.\n   * @default false\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * Element placed after the children.\n   */\n  endIcon: PropTypes.node,\n  /**\n   * @ignore\n   */\n  focusVisibleClassName: PropTypes.string,\n  /**\n   * If `true`, the button will take up the full width of its container.\n   * @default false\n   */\n  fullWidth: PropTypes.bool,\n  /**\n   * The URL to link to when the button is clicked.\n   * If defined, an `a` element will be used as the root node.\n   */\n  href: PropTypes.string,\n  /**\n   * @ignore\n   */\n  id: PropTypes.string,\n  /**\n   * If `true`, the loading indicator is visible and the button is disabled.\n   * If `true | false`, the loading wrapper is always rendered before the children to prevent [Google Translation Crash](https://github.com/mui/material-ui/issues/27853).\n   * @default null\n   */\n  loading: PropTypes.bool,\n  /**\n   * Element placed before the children if the button is in loading state.\n   * The node should contain an element with `role=\"progressbar\"` with an accessible name.\n   * By default, it renders a `CircularProgress` that is labeled by the button itself.\n   * @default <CircularProgress color=\"inherit\" size={16} />\n   */\n  loadingIndicator: PropTypes.node,\n  /**\n   * The loading indicator can be positioned on the start, end, or the center of the button.\n   * @default 'center'\n   */\n  loadingPosition: PropTypes.oneOf(['center', 'end', 'start']),\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense button styling.\n   * @default 'medium'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['small', 'medium', 'large']), PropTypes.string]),\n  /**\n   * Element placed before the children.\n   */\n  startIcon: PropTypes.node,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * @ignore\n   */\n  type: PropTypes.oneOfType([PropTypes.oneOf(['button', 'reset', 'submit']), PropTypes.string]),\n  /**\n   * The variant to use.\n   * @default 'text'\n   */\n  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['contained', 'outlined', 'text']), PropTypes.string])\n} : void 0;\nexport default Button;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getButtonUtilityClass(slot) {\n  return generateUtilityClass('MuiButton', slot);\n}\nconst buttonClasses = generateUtilityClasses('MuiButton', ['root', 'text', 'textInherit', 'textPrimary', 'textSecondary', 'textSuccess', 'textError', 'textInfo', 'textWarning', 'outlined', 'outlinedInherit', 'outlinedPrimary', 'outlinedSecondary', 'outlinedSuccess', 'outlinedError', 'outlinedInfo', 'outlinedWarning', 'contained', 'containedInherit', 'containedPrimary', 'containedSecondary', 'containedSuccess', 'containedError', 'containedInfo', 'containedWarning', 'disableElevation', 'focusVisible', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'colorSuccess', 'colorError', 'colorInfo', 'colorWarning', 'textSizeSmall', 'textSizeMedium', 'textSizeLarge', 'outlinedSizeSmall', 'outlinedSizeMedium', 'outlinedSizeLarge', 'containedSizeSmall', 'containedSizeMedium', 'containedSizeLarge', 'sizeMedium', 'sizeSmall', 'sizeLarge', 'fullWidth', 'startIcon', 'endIcon', 'icon', 'iconSizeSmall', 'iconSizeMedium', 'iconSizeLarge', 'loading', 'loadingWrapper', 'loadingIconPlaceholder', 'loadingIndicator', 'loadingPositionCenter', 'loadingPositionStart', 'loadingPositionEnd']);\nexport default buttonClasses;","'use client';\n\nimport * as React from 'react';\n/**\n * @ignore - internal component.\n */\nconst ButtonGroupContext = /*#__PURE__*/React.createContext({});\nif (process.env.NODE_ENV !== 'production') {\n  ButtonGroupContext.displayName = 'ButtonGroupContext';\n}\nexport default ButtonGroupContext;","'use client';\n\nimport * as React from 'react';\n/**\n * @ignore - internal component.\n */\nconst ButtonGroupButtonContext = /*#__PURE__*/React.createContext(undefined);\nif (process.env.NODE_ENV !== 'production') {\n  ButtonGroupButtonContext.displayName = 'ButtonGroupButtonContext';\n}\nexport default ButtonGroupButtonContext;","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type * as Chunk from \"./Chunk.js\"\nimport type * as Context from \"./Context.js\"\nimport type * as Cron from \"./Cron.js\"\nimport type * as DateTime from \"./DateTime.js\"\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport * as internal from \"./internal/schedule.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate } from \"./Predicate.js\"\nimport type * as Ref from \"./Ref.js\"\nimport type * as ScheduleDecision from \"./ScheduleDecision.js\"\nimport type * as Intervals from \"./ScheduleIntervals.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport const ScheduleTypeId: unique symbol = internal.ScheduleTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type ScheduleTypeId = typeof ScheduleTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport const ScheduleDriverTypeId: unique symbol = internal.ScheduleDriverTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type ScheduleDriverTypeId = typeof ScheduleDriverTypeId\n\n/**\n * A `Schedule<Out, In, R>` defines a recurring schedule, which consumes values\n * of type `In`, and which returns values of type `Out`.\n *\n * The `Schedule` type is structured as follows:\n *\n * ```ts skip-type-checking\n * //        ┌─── The type of output produced by the schedule\n * //        │   ┌─── The type of input consumed by the schedule\n * //        │   │     ┌─── Additional requirements for the schedule\n * //        ▼   ▼     ▼\n * Schedule<Out, In, Requirements>\n * ```\n *\n * A schedule operates by consuming values of type `In` (such as errors in the\n * case of `Effect.retry`, or values in the case of `Effect.repeat`) and\n * producing values of type `Out`. It determines when to halt or continue the\n * execution based on input values and its internal state.\n *\n * The inclusion of a `Requirements` parameter allows the schedule to leverage\n * additional services or resources as needed.\n *\n * Schedules are defined as a possibly infinite set of intervals spread out over\n * time. Each interval defines a window in which recurrence is possible.\n *\n * When schedules are used to repeat or retry effects, the starting boundary of\n * each interval produced by a schedule is used as the moment when the effect\n * will be executed again.\n *\n * Schedules can be composed in different ways:\n *\n * - Union: Combines two schedules and recurs if either schedule wants to\n *   continue, using the shorter delay.\n * - Intersection: Combines two schedules and recurs only if both schedules want\n *   to continue, using the longer delay.\n * - Sequencing: Combines two schedules by running the first one fully, then\n *   switching to the second.\n *\n * In addition, schedule inputs and outputs can be transformed, filtered (to\n * terminate a schedule early in response to some input or output), and so\n * forth.\n *\n * A variety of other operators exist for transforming and combining schedules,\n * and the companion object for `Schedule` contains all common types of\n * schedules, both for performing retrying, as well as performing repetition.\n *\n * @category Model\n * @since 2.0.0\n */\nexport interface Schedule<out Out, in In = unknown, out R = never> extends Schedule.Variance<Out, In, R>, Pipeable {\n  /**\n   * Initial State\n   */\n  readonly initial: any\n  /**\n   * Schedule Step\n   */\n  step(\n    now: number,\n    input: In,\n    state: any\n  ): Effect.Effect<readonly [any, Out, ScheduleDecision.ScheduleDecision], never, R>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Schedule {\n  /**\n   * @since 2.0.0\n   * @category Models\n   */\n  export interface Variance<out Out, in In, out R> {\n    readonly [ScheduleTypeId]: {\n      readonly _Out: Types.Covariant<Out>\n      readonly _In: Types.Contravariant<In>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export interface DriverVariance<out Out, in In, out R> {\n    readonly [ScheduleDriverTypeId]: {\n      readonly _Out: Types.Covariant<Out>\n      readonly _In: Types.Contravariant<In>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport interface ScheduleDriver<out Out, in In = unknown, out R = never> extends Schedule.DriverVariance<Out, In, R> {\n  readonly state: Effect.Effect<unknown>\n  readonly iterationMeta: Ref.Ref<IterationMetadata>\n  readonly last: Effect.Effect<Out, Cause.NoSuchElementException>\n  readonly reset: Effect.Effect<void>\n  next(input: In): Effect.Effect<Out, Option.Option<never>, R>\n}\n\n/**\n * Creates a new schedule with a custom state and step function.\n *\n * **Details**\n *\n * This function constructs a `Schedule` by defining its initial state and a\n * step function, which determines how the schedule progresses over time. The\n * step function is called on each iteration with the current time, an input\n * value, and the schedule's current state. It returns the next state, an output\n * value, and a decision on whether the schedule should continue or stop.\n *\n * This function is useful for creating custom scheduling logic that goes beyond\n * predefined schedules like fixed intervals or exponential backoff. It allows\n * full control over how the schedule behaves at each step.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const makeWithState: <S, In, Out, R = never>(\n  initial: S,\n  step: (\n    now: number,\n    input: In,\n    state: S\n  ) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>\n) => Schedule<Out, In, R> = internal.makeWithState\n\n/**\n * Checks whether a given value is a `Schedule`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isSchedule: (u: unknown) => u is Schedule<unknown, never, unknown> = internal.isSchedule\n\n/**\n * Adds a delay to every interval in a schedule.\n *\n * **Details**\n *\n * This function modifies a given schedule by applying an additional delay to\n * every interval it defines. The delay is determined by the provided function,\n * which takes the schedule's output and returns a delay duration.\n *\n * @see {@link addDelayEffect} If you need to compute the delay using an effectful function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const addDelay: {\n  /**\n   * Adds a delay to every interval in a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule by applying an additional delay to\n   * every interval it defines. The delay is determined by the provided function,\n   * which takes the schedule's output and returns a delay duration.\n   *\n   * @see {@link addDelayEffect} If you need to compute the delay using an effectful function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Adds a delay to every interval in a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule by applying an additional delay to\n   * every interval it defines. The delay is determined by the provided function,\n   * which takes the schedule's output and returns a delay duration.\n   *\n   * @see {@link addDelayEffect} If you need to compute the delay using an effectful function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>\n} = internal.addDelay\n\n/**\n * Adds an effectfully computed delay to every interval in a schedule.\n *\n * **Details**\n *\n * This function modifies a given schedule by applying an additional delay to\n * each interval, where the delay is determined by an effectful function. The\n * function takes the schedule’s output and returns an effect that produces a\n * delay duration.\n *\n * @see {@link addDelay} If you need to compute the delay using a pure function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const addDelayEffect: {\n  /**\n   * Adds an effectfully computed delay to every interval in a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule by applying an additional delay to\n   * each interval, where the delay is determined by an effectful function. The\n   * function takes the schedule’s output and returns an effect that produces a\n   * delay duration.\n   *\n   * @see {@link addDelay} If you need to compute the delay using a pure function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, R2>(f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Adds an effectfully computed delay to every interval in a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule by applying an additional delay to\n   * each interval, where the delay is determined by an effectful function. The\n   * function takes the schedule’s output and returns an effect that produces a\n   * delay duration.\n   *\n   * @see {@link addDelay} If you need to compute the delay using a pure function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.addDelayEffect\n\n/**\n * Runs two schedules sequentially, merging their outputs.\n *\n * **Details**\n *\n * This function executes two schedules one after the other. The first schedule\n * runs to completion, and then the second schedule begins execution. Unlike\n * {@link andThenEither}, this function merges the outputs instead of wrapping\n * them in `Either`, allowing both schedules to contribute their results\n * directly.\n *\n * This is useful when a workflow consists of two phases where the second phase\n * should start only after the first one has fully completed.\n *\n * @see {@link andThenEither} If you need to keep track of which schedule\n * produced each result.\n *\n * @since 2.0.0\n * @category Sequential Composition\n */\nexport const andThen: {\n  /**\n   * Runs two schedules sequentially, merging their outputs.\n   *\n   * **Details**\n   *\n   * This function executes two schedules one after the other. The first schedule\n   * runs to completion, and then the second schedule begins execution. Unlike\n   * {@link andThenEither}, this function merges the outputs instead of wrapping\n   * them in `Either`, allowing both schedules to contribute their results\n   * directly.\n   *\n   * This is useful when a workflow consists of two phases where the second phase\n   * should start only after the first one has fully completed.\n   *\n   * @see {@link andThenEither} If you need to keep track of which schedule\n   * produced each result.\n   *\n   * @since 2.0.0\n   * @category Sequential Composition\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>\n  /**\n   * Runs two schedules sequentially, merging their outputs.\n   *\n   * **Details**\n   *\n   * This function executes two schedules one after the other. The first schedule\n   * runs to completion, and then the second schedule begins execution. Unlike\n   * {@link andThenEither}, this function merges the outputs instead of wrapping\n   * them in `Either`, allowing both schedules to contribute their results\n   * directly.\n   *\n   * This is useful when a workflow consists of two phases where the second phase\n   * should start only after the first one has fully completed.\n   *\n   * @see {@link andThenEither} If you need to keep track of which schedule\n   * produced each result.\n   *\n   * @since 2.0.0\n   * @category Sequential Composition\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>\n} = internal.andThen\n\n/**\n * Runs two schedules sequentially, collecting results in an `Either`.\n *\n * **Details**\n *\n * This function combines two schedules in sequence. The first schedule runs to\n * completion, and then the second schedule starts and runs to completion as\n * well. The outputs of both schedules are collected into an `Either` structure:\n * - `Either.Left` contains the output of the second schedule.\n * - `Either.Right` contains the output of the first schedule.\n *\n * This is useful when you need to switch from one schedule to another after the\n * first one finishes, while still keeping track of which schedule produced each\n * result.\n *\n * @see {@link andThen} If you need to merge the outputs of both schedules.\n *\n * @since 2.0.0\n * @category Sequential Composition\n */\nexport const andThenEither: {\n  /**\n   * Runs two schedules sequentially, collecting results in an `Either`.\n   *\n   * **Details**\n   *\n   * This function combines two schedules in sequence. The first schedule runs to\n   * completion, and then the second schedule starts and runs to completion as\n   * well. The outputs of both schedules are collected into an `Either` structure:\n   * - `Either.Left` contains the output of the second schedule.\n   * - `Either.Right` contains the output of the first schedule.\n   *\n   * This is useful when you need to switch from one schedule to another after the\n   * first one finishes, while still keeping track of which schedule produced each\n   * result.\n   *\n   * @see {@link andThen} If you need to merge the outputs of both schedules.\n   *\n   * @since 2.0.0\n   * @category Sequential Composition\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>\n  /**\n   * Runs two schedules sequentially, collecting results in an `Either`.\n   *\n   * **Details**\n   *\n   * This function combines two schedules in sequence. The first schedule runs to\n   * completion, and then the second schedule starts and runs to completion as\n   * well. The outputs of both schedules are collected into an `Either` structure:\n   * - `Either.Left` contains the output of the second schedule.\n   * - `Either.Right` contains the output of the first schedule.\n   *\n   * This is useful when you need to switch from one schedule to another after the\n   * first one finishes, while still keeping track of which schedule produced each\n   * result.\n   *\n   * @see {@link andThen} If you need to merge the outputs of both schedules.\n   *\n   * @since 2.0.0\n   * @category Sequential Composition\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>\n} = internal.andThenEither\n\n/**\n * Transforms a schedule to always produce a constant output.\n *\n * **Details**\n *\n * This function modifies a given schedule so that instead of returning its\n * computed outputs, it always returns a constant value.\n *\n * This is useful when you need a schedule for timing but don’t care about its\n * actual output, or when you want to standardize results across different\n * scheduling strategies.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const as: {\n  /**\n   * Transforms a schedule to always produce a constant output.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule so that instead of returning its\n   * computed outputs, it always returns a constant value.\n   *\n   * This is useful when you need a schedule for timing but don’t care about its\n   * actual output, or when you want to standardize results across different\n   * scheduling strategies.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>\n  /**\n   * Transforms a schedule to always produce a constant output.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule so that instead of returning its\n   * computed outputs, it always returns a constant value.\n   *\n   * This is useful when you need a schedule for timing but don’t care about its\n   * actual output, or when you want to standardize results across different\n   * scheduling strategies.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>\n} = internal.as\n\n/**\n * Transforms a schedule to always return `void` instead of its output.\n *\n * **Details**\n *\n * This function modifies a given schedule so that it no longer returns\n * meaningful output—each execution produces `void`. This is useful when the\n * schedule is used only for timing purposes and the actual output of the\n * schedule is irrelevant.\n *\n * The schedule still determines when executions should occur, but the results\n * are discarded.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R> = internal.asVoid\n\n// TODO(4.0): rename to `zip`?\n/**\n * Combines two schedules, preserving both their inputs and outputs.\n *\n * **Details**\n *\n * This function merges two schedules so that both their input types and output\n * types are retained. When executed, the resulting schedule will take inputs\n * from both original schedules and produce a tuple containing both outputs.\n *\n * It recurs if either schedule wants to continue, using the shorter delay.\n *\n * This is useful when you want to track multiple schedules simultaneously,\n * ensuring that both receive the same inputs and produce combined results.\n *\n * @since 2.0.0\n * @category Zipping\n */\nexport const bothInOut: {\n  // TODO(4.0): rename to `zip`?\n  /**\n   * Combines two schedules, preserving both their inputs and outputs.\n   *\n   * **Details**\n   *\n   * This function merges two schedules so that both their input types and output\n   * types are retained. When executed, the resulting schedule will take inputs\n   * from both original schedules and produce a tuple containing both outputs.\n   *\n   * It recurs if either schedule wants to continue, using the shorter delay.\n   *\n   * This is useful when you want to track multiple schedules simultaneously,\n   * ensuring that both receive the same inputs and produce combined results.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>\n  // TODO(4.0): rename to `zip`?\n  /**\n   * Combines two schedules, preserving both their inputs and outputs.\n   *\n   * **Details**\n   *\n   * This function merges two schedules so that both their input types and output\n   * types are retained. When executed, the resulting schedule will take inputs\n   * from both original schedules and produce a tuple containing both outputs.\n   *\n   * It recurs if either schedule wants to continue, using the shorter delay.\n   *\n   * This is useful when you want to track multiple schedules simultaneously,\n   * ensuring that both receive the same inputs and produce combined results.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>\n} = internal.bothInOut\n\n/**\n * Filters schedule executions based on a custom condition.\n *\n * **Details**\n *\n * This function modifies a schedule by applying a custom test function to each\n * input-output pair. The test function determines whether the schedule should\n * continue or stop. If the function returns `true`, the schedule proceeds as\n * usual; if it returns `false`, the schedule terminates.\n *\n * This is useful for conditional retries, custom stop conditions, or\n * dynamically controlling execution based on observed inputs and outputs.\n *\n * @see {@link checkEffect} If you need to use an effectful test function.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const check: {\n  /**\n   * Filters schedule executions based on a custom condition.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by applying a custom test function to each\n   * input-output pair. The test function determines whether the schedule should\n   * continue or stop. If the function returns `true`, the schedule proceeds as\n   * usual; if it returns `false`, the schedule terminates.\n   *\n   * This is useful for conditional retries, custom stop conditions, or\n   * dynamically controlling execution based on observed inputs and outputs.\n   *\n   * @see {@link checkEffect} If you need to use an effectful test function.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Filters schedule executions based on a custom condition.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by applying a custom test function to each\n   * input-output pair. The test function determines whether the schedule should\n   * continue or stop. If the function returns `true`, the schedule proceeds as\n   * usual; if it returns `false`, the schedule terminates.\n   *\n   * This is useful for conditional retries, custom stop conditions, or\n   * dynamically controlling execution based on observed inputs and outputs.\n   *\n   * @see {@link checkEffect} If you need to use an effectful test function.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>\n} = internal.check\n\n/**\n * Conditionally filters schedule executions using an effectful function.\n *\n * **Details**\n *\n * This function modifies a schedule by applying a custom effectful test\n * function to each input-output pair. The test function determines whether the\n * schedule should continue (`true`) or stop (`false`).\n *\n * This is useful when the decision to continue depends on external factors such\n * as database lookups, API calls, or other asynchronous computations.\n *\n * @see {@link check} If you need to use a pure test function.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const checkEffect: {\n  /**\n   * Conditionally filters schedule executions using an effectful function.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by applying a custom effectful test\n   * function to each input-output pair. The test function determines whether the\n   * schedule should continue (`true`) or stop (`false`).\n   *\n   * This is useful when the decision to continue depends on external factors such\n   * as database lookups, API calls, or other asynchronous computations.\n   *\n   * @see {@link check} If you need to use a pure test function.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <In, Out, R2>(test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Conditionally filters schedule executions using an effectful function.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by applying a custom effectful test\n   * function to each input-output pair. The test function determines whether the\n   * schedule should continue (`true`) or stop (`false`).\n   *\n   * This is useful when the decision to continue depends on external factors such\n   * as database lookups, API calls, or other asynchronous computations.\n   *\n   * @see {@link check} If you need to use a pure test function.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.checkEffect\n\n/**\n * A schedule that collects all inputs into a `Chunk`.\n *\n * **Details**\n *\n * This function creates a schedule that never terminates and continuously\n * collects every input it receives into a `Chunk`. Each time the schedule runs,\n * it appends the new input to the collected list.\n *\n * This is useful when you need to track all received inputs over time, such as\n * logging user actions, recording retry attempts, or accumulating data for\n * later processing.\n *\n * @see {@link collectAllOutputs} If you need to collect outputs instead of\n * inputs.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A> = internal.collectAllInputs\n\n/**\n * Collects all outputs of a schedule into a `Chunk`.\n *\n * **Details**\n *\n * This function modifies a given schedule so that instead of returning\n * individual outputs, it accumulates them into a `Chunk`. The schedule\n * continues to run, appending each output to the collected list.\n *\n * This is useful when you need to track all results over time, such as logging\n * outputs, aggregating data, or keeping a history of previous values.\n *\n * @see {@link collectAllInputs} If you need to collect inputs instead of\n * outputs.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R> =\n  internal.collectAllOutputs\n\n/**\n * Collects all inputs into a `Chunk` until a condition fails.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` until the given predicate function `f` evaluates to `false`. Once the\n * condition fails, the schedule stops.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A> = internal.collectUntil\n\n/**\n * Collects all inputs into a `Chunk` until an effectful condition fails.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` until the given effectful predicate `f` returns `false`. The\n * predicate runs as an effect, meaning it can involve asynchronous computations\n * like API calls, database lookups, or randomness.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectUntilEffect: <A, R>(\n  f: (a: A) => Effect.Effect<boolean, never, R>\n) => Schedule<Chunk.Chunk<A>, A, R> = internal.collectUntilEffect\n\n/**\n * Collects all inputs into a `Chunk` while a condition holds.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` while the given predicate function `f` evaluates to `true`. As soon\n * as the condition fails, the schedule stops.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A> = internal.collectWhile\n\n/**\n * Collects all inputs into a `Chunk` while an effectful condition holds.\n *\n * **Details**\n *\n * This function creates a schedule that continuously collects inputs into a\n * `Chunk` while the given effectful predicate `f` returns `true`. The predicate\n * returns an effect, meaning it can depend on external state, such as database\n * queries, API responses, or real-time user conditions.\n *\n * As soon as the effectful condition returns `false`, the schedule stops. This\n * is useful for dynamically controlled data collection, where stopping depends\n * on an external or asynchronous factor.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const collectWhileEffect: <A, R>(\n  f: (a: A) => Effect.Effect<boolean, never, R>\n) => Schedule<Chunk.Chunk<A>, A, R> = internal.collectWhileEffect\n\n/**\n * Chains two schedules, passing the output of the first as the input to the\n * second, while selecting the shorter delay between them.\n *\n * **Details**\n *\n * This function composes two schedules so that the output of the first schedule\n * becomes the input of the second schedule. The first schedule executes first,\n * and once it produces a result, the second schedule receives that result and\n * continues execution based on it.\n *\n * This is useful for building complex scheduling workflows where one schedule's\n * behavior determines how the next schedule behaves.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const compose: {\n  /**\n   * Chains two schedules, passing the output of the first as the input to the\n   * second, while selecting the shorter delay between them.\n   *\n   * **Details**\n   *\n   * This function composes two schedules so that the output of the first schedule\n   * becomes the input of the second schedule. The first schedule executes first,\n   * and once it produces a result, the second schedule receives that result and\n   * continues execution based on it.\n   *\n   * This is useful for building complex scheduling workflows where one schedule's\n   * behavior determines how the next schedule behaves.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>\n  /**\n   * Chains two schedules, passing the output of the first as the input to the\n   * second, while selecting the shorter delay between them.\n   *\n   * **Details**\n   *\n   * This function composes two schedules so that the output of the first schedule\n   * becomes the input of the second schedule. The first schedule executes first,\n   * and once it produces a result, the second schedule receives that result and\n   * continues execution based on it.\n   *\n   * This is useful for building complex scheduling workflows where one schedule's\n   * behavior determines how the next schedule behaves.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>\n} = internal.compose\n\n/**\n * Transforms the input type of a schedule.\n *\n * **Details**\n *\n * This function modifies a given schedule by applying a transformation function\n * to its inputs. Instead of directly receiving values of type `In`, the\n * schedule will now accept values of type `In2`, which are converted to `In`\n * using the provided mapping function `f`.\n *\n * This is useful when you have a schedule that expects a specific input type\n * but you need to adapt it to work with a different type.\n *\n * @see {@link mapInputEffect} If you need to use an effectful transformation function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapInput: {\n  /**\n   * Transforms the input type of a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule by applying a transformation function\n   * to its inputs. Instead of directly receiving values of type `In`, the\n   * schedule will now accept values of type `In2`, which are converted to `In`\n   * using the provided mapping function `f`.\n   *\n   * This is useful when you have a schedule that expects a specific input type\n   * but you need to adapt it to work with a different type.\n   *\n   * @see {@link mapInputEffect} If you need to use an effectful transformation function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>\n  /**\n   * Transforms the input type of a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a given schedule by applying a transformation function\n   * to its inputs. Instead of directly receiving values of type `In`, the\n   * schedule will now accept values of type `In2`, which are converted to `In`\n   * using the provided mapping function `f`.\n   *\n   * This is useful when you have a schedule that expects a specific input type\n   * but you need to adapt it to work with a different type.\n   *\n   * @see {@link mapInputEffect} If you need to use an effectful transformation function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>\n} = internal.mapInput\n\n/**\n * Transforms the input type of a schedule using an effectful function.\n *\n * **Details**\n *\n * This function modifies a schedule by applying an effectful transformation to\n * its inputs. Instead of directly receiving values of type `In`, the schedule\n * will now accept values of type `In2`, which are converted to `In` via an\n * effectful function `f`.\n *\n * This is useful when the input transformation involves external dependencies,\n * such as API calls, database lookups, or other asynchronous computations.\n *\n * @see {@link mapInput} If you need to use a pure transformation function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapInputEffect: {\n  /**\n   * Transforms the input type of a schedule using an effectful function.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by applying an effectful transformation to\n   * its inputs. Instead of directly receiving values of type `In`, the schedule\n   * will now accept values of type `In2`, which are converted to `In` via an\n   * effectful function `f`.\n   *\n   * This is useful when the input transformation involves external dependencies,\n   * such as API calls, database lookups, or other asynchronous computations.\n   *\n   * @see {@link mapInput} If you need to use a pure transformation function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <In2, In, R2>(f: (in2: In2) => Effect.Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>\n  /**\n   * Transforms the input type of a schedule using an effectful function.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by applying an effectful transformation to\n   * its inputs. Instead of directly receiving values of type `In`, the schedule\n   * will now accept values of type `In2`, which are converted to `In` via an\n   * effectful function `f`.\n   *\n   * This is useful when the input transformation involves external dependencies,\n   * such as API calls, database lookups, or other asynchronous computations.\n   *\n   * @see {@link mapInput} If you need to use a pure transformation function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect.Effect<In, never, R2>): Schedule<Out, In2, R | R2>\n} = internal.mapInputEffect\n\n/**\n * Transforms the required context of a schedule.\n *\n * **Details**\n *\n * This function modifies a schedule by mapping its required context (`R`) into\n * a new context (`R0`) using the provided function `f`.\n *\n * This is useful when you need to adapt a schedule to work with a different\n * dependency environment without changing its core logic.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapInputContext: {\n  /**\n   * Transforms the required context of a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by mapping its required context (`R`) into\n   * a new context (`R0`) using the provided function `f`.\n   *\n   * This is useful when you need to adapt a schedule to work with a different\n   * dependency environment without changing its core logic.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <R0, R>(f: (env0: Context.Context<R0>) => Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>\n  /**\n   * Transforms the required context of a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule by mapping its required context (`R`) into\n   * a new context (`R0`) using the provided function `f`.\n   *\n   * This is useful when you need to adapt a schedule to work with a different\n   * dependency environment without changing its core logic.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, R0>(\n    self: Schedule<Out, In, R>,\n    f: (env0: Context.Context<R0>) => Context.Context<R>\n  ): Schedule<Out, In, R0>\n} = internal.mapInputContext\n\n/**\n * A schedule that recurs indefinitely, counting the number of recurrences.\n *\n * **Details**\n *\n * This schedule never stops and simply counts how many times it has executed.\n * Each recurrence increases the count, starting from `0`.\n *\n * This is useful when tracking the number of attempts in retry policies,\n * measuring execution loops, or implementing infinite polling scenarios.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const count: Schedule<number> = internal.count\n\n/**\n * Creates a schedule that recurs based on a cron expression.\n *\n * **Details**\n *\n * This schedule automatically executes at intervals defined by a cron\n * expression. It triggers at the beginning of each matched interval and\n * produces timestamps representing the start and end of the cron window.\n *\n * The cron `expression` is validated lazily, meaning errors may only be\n * detected when the schedule is executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const cron: {\n  /**\n   * Creates a schedule that recurs based on a cron expression.\n   *\n   * **Details**\n   *\n   * This schedule automatically executes at intervals defined by a cron\n   * expression. It triggers at the beginning of each matched interval and\n   * produces timestamps representing the start and end of the cron window.\n   *\n   * The cron `expression` is validated lazily, meaning errors may only be\n   * detected when the schedule is executed.\n   *\n   * @since 2.0.0\n   * @category Cron\n   */\n  (cron: Cron.Cron): Schedule<[number, number]>\n  /**\n   * Creates a schedule that recurs based on a cron expression.\n   *\n   * **Details**\n   *\n   * This schedule automatically executes at intervals defined by a cron\n   * expression. It triggers at the beginning of each matched interval and\n   * produces timestamps representing the start and end of the cron window.\n   *\n   * The cron `expression` is validated lazily, meaning errors may only be\n   * detected when the schedule is executed.\n   *\n   * @since 2.0.0\n   * @category Cron\n   */\n  (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>\n} = internal.cron\n\n/**\n * Cron-like schedule that recurs at a specific second of each minute.\n *\n * **Details**\n *\n * This schedule triggers at the specified `second` of each minute,\n * starting at zero nanoseconds. It produces a count of executions\n * (0, 1, 2, ...). The `second` parameter is validated lazily, meaning\n * invalid values will only be caught at runtime.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const secondOfMinute: (second: number) => Schedule<number> = internal.secondOfMinute\n\n/**\n * Creates a schedule that recurs every specified minute of each hour.\n *\n * **Details**\n *\n * This schedule triggers once per hour at the specified `minute`, starting\n * exactly at `minute:00` (zero seconds). The schedule produces a count of\n * executions (`0, 1, 2, ...`), representing how many times it has run.\n *\n * The `minute` parameter must be between `0` and `59`. It is validated lazily,\n * meaning an invalid value will cause errors only when the schedule is\n * executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const minuteOfHour: (minute: number) => Schedule<number> = internal.minuteOfHour\n\n/**\n * Creates a schedule that recurs at a specific hour of each day.\n *\n * **Details**\n *\n * This schedule triggers once per day at the specified `hour`, starting at zero\n * minutes of that hour. The schedule produces a count of executions (`0, 1, 2,\n * ...`), indicating how many times it has been triggered.\n *\n * The `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is\n * validated lazily, meaning an invalid value will cause errors only when the\n * schedule is executed.\n *\n * This is useful for scheduling daily recurring tasks at a fixed time, such as\n * running batch jobs or refreshing data.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const hourOfDay: (hour: number) => Schedule<number> = internal.hourOfDay\n\n/**\n * Creates a schedule that recurs on a specific day of the month.\n *\n * **Details**\n *\n * This schedule triggers at midnight on the specified day of each month. It\n * will not execute in months that have fewer days than the given day. For\n * example, if the schedule is set to run on the 31st, it will not execute in\n * months with only 30 days.\n *\n * The schedule produces a count of executions, starting at 0 and incrementing\n * with each recurrence.\n *\n * The `day` parameter is validated lazily, meaning errors may only be detected\n * when the schedule is executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const dayOfMonth: (day: number) => Schedule<number> = internal.dayOfMonth\n\n/**\n * Creates a schedule that recurs on a specific day of the week.\n *\n * **Details**\n *\n * This schedule triggers at midnight on the specified day of the week. The\n * `day` parameter follows the standard convention where `Monday = 1` and\n * `Sunday = 7`. The schedule produces a count of executions, starting at 0 and\n * incrementing with each recurrence.\n *\n * The `day` parameter is validated lazily, meaning errors may only be detected\n * when the schedule is executed.\n *\n * @since 2.0.0\n * @category Cron\n */\nexport const dayOfWeek: (day: number) => Schedule<number> = internal.dayOfWeek\n\n/**\n * Modifies a schedule by adding a computed delay before each execution.\n *\n * **Details**\n *\n * This function adjusts an existing schedule by applying a transformation to\n * its delays. Instead of using the default interval, each delay is modified\n * using the provided function `f`, which takes the current delay and returns a\n * new delay.\n *\n * This is useful for dynamically adjusting wait times between executions, such\n * as introducing jitter, exponential backoff, or custom delay logic.\n *\n * @see {@link delayedEffect} If you need to compute the delay using an effectful function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const delayed: {\n  /**\n   * Modifies a schedule by adding a computed delay before each execution.\n   *\n   * **Details**\n   *\n   * This function adjusts an existing schedule by applying a transformation to\n   * its delays. Instead of using the default interval, each delay is modified\n   * using the provided function `f`, which takes the current delay and returns a\n   * new delay.\n   *\n   * This is useful for dynamically adjusting wait times between executions, such\n   * as introducing jitter, exponential backoff, or custom delay logic.\n   *\n   * @see {@link delayedEffect} If you need to compute the delay using an effectful function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  (f: (duration: Duration.Duration) => Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Modifies a schedule by adding a computed delay before each execution.\n   *\n   * **Details**\n   *\n   * This function adjusts an existing schedule by applying a transformation to\n   * its delays. Instead of using the default interval, each delay is modified\n   * using the provided function `f`, which takes the current delay and returns a\n   * new delay.\n   *\n   * This is useful for dynamically adjusting wait times between executions, such\n   * as introducing jitter, exponential backoff, or custom delay logic.\n   *\n   * @see {@link delayedEffect} If you need to compute the delay using an effectful function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R>(\n    self: Schedule<Out, In, R>,\n    f: (duration: Duration.Duration) => Duration.DurationInput\n  ): Schedule<Out, In, R>\n} = internal.delayed\n\n/**\n * Modifies a schedule by adding an effectfully computed delay before each\n * execution.\n *\n * **Details**\n *\n * This function adjusts an existing schedule by introducing a delay that is\n * computed via an effect. Instead of using a fixed delay, each interval is\n * dynamically adjusted based on an effectful function `f`, which takes the\n * current delay and returns a new delay wrapped in an `Effect`.\n *\n * This is useful for adaptive scheduling where delays depend on external\n * factors, such as API calls, database queries, or dynamic system conditions.\n *\n * @see {@link delayed} If you need to compute the delay using a pure function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const delayedEffect: {\n  /**\n   * Modifies a schedule by adding an effectfully computed delay before each\n   * execution.\n   *\n   * **Details**\n   *\n   * This function adjusts an existing schedule by introducing a delay that is\n   * computed via an effect. Instead of using a fixed delay, each interval is\n   * dynamically adjusted based on an effectful function `f`, which takes the\n   * current delay and returns a new delay wrapped in an `Effect`.\n   *\n   * This is useful for adaptive scheduling where delays depend on external\n   * factors, such as API calls, database queries, or dynamic system conditions.\n   *\n   * @see {@link delayed} If you need to compute the delay using a pure function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <R2>(\n    f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Modifies a schedule by adding an effectfully computed delay before each\n   * execution.\n   *\n   * **Details**\n   *\n   * This function adjusts an existing schedule by introducing a delay that is\n   * computed via an effect. Instead of using a fixed delay, each interval is\n   * dynamically adjusted based on an effectful function `f`, which takes the\n   * current delay and returns a new delay wrapped in an `Effect`.\n   *\n   * This is useful for adaptive scheduling where delays depend on external\n   * factors, such as API calls, database queries, or dynamic system conditions.\n   *\n   * @see {@link delayed} If you need to compute the delay using a pure function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.delayedEffect\n\n/**\n * Uses the delays produced by a schedule to further delay its intervals.\n *\n * **Details**\n *\n * This function modifies a schedule by using its own output delays to control\n * its execution timing. Instead of executing immediately at each interval, the\n * schedule will be delayed by the duration it produces.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const delayedSchedule: <In, R>(\n  schedule: Schedule<Duration.Duration, In, R>\n) => Schedule<Duration.Duration, In, R> = internal.delayedSchedule\n\n/**\n * Transforms a schedule to output the delay between each occurrence.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that instead of producing its\n * original output, it now returns the delay between each scheduled execution.\n *\n * @since 2.0.0\n * @category Monitoring\n */\nexport const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R> = internal.delays\n\n/**\n * Transforms both the input and output of a schedule.\n *\n * **Details**\n *\n * This function modifies an existing schedule by applying a transformation to\n * both its input values and its output values. The provided transformation\n * functions `onInput` and `onOutput` allow you to map the schedule to work with\n * a different input type while modifying its outputs as well.\n *\n * @see {@link mapBothEffect} If you need to use effectful transformation functions.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapBoth: {\n  /**\n   * Transforms both the input and output of a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule by applying a transformation to\n   * both its input values and its output values. The provided transformation\n   * functions `onInput` and `onOutput` allow you to map the schedule to work with\n   * a different input type while modifying its outputs as well.\n   *\n   * @see {@link mapBothEffect} If you need to use effectful transformation functions.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <In2, In, Out, Out2>(\n    options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2 }\n  ): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>\n  /**\n   * Transforms both the input and output of a schedule.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule by applying a transformation to\n   * both its input values and its output values. The provided transformation\n   * functions `onInput` and `onOutput` allow you to map the schedule to work with\n   * a different input type while modifying its outputs as well.\n   *\n   * @see {@link mapBothEffect} If you need to use effectful transformation functions.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, In2, Out2>(\n    self: Schedule<Out, In, R>,\n    options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2 }\n  ): Schedule<Out2, In2, R>\n} = internal.mapBoth\n\n/**\n * Transforms both the input and output of a schedule using effectful\n * computations.\n *\n * **Details**\n *\n * This function modifies an existing schedule by applying effectful\n * transformations to both its input values and its output values. The provided\n * effectful functions `onInput` and `onOutput` allow you to transform inputs\n * and outputs using computations that may involve additional logic, resource\n * access, or side effects.\n *\n * @see {@link mapBoth} If you need to use pure transformation functions.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapBothEffect: {\n  /**\n   * Transforms both the input and output of a schedule using effectful\n   * computations.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule by applying effectful\n   * transformations to both its input values and its output values. The provided\n   * effectful functions `onInput` and `onOutput` allow you to transform inputs\n   * and outputs using computations that may involve additional logic, resource\n   * access, or side effects.\n   *\n   * @see {@link mapBoth} If you need to use pure transformation functions.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <In2, In, R2, Out, R3, Out2>(\n    options: {\n      readonly onInput: (input: In2) => Effect.Effect<In, never, R2>\n      readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>\n    }\n  ): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>\n  /**\n   * Transforms both the input and output of a schedule using effectful\n   * computations.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule by applying effectful\n   * transformations to both its input values and its output values. The provided\n   * effectful functions `onInput` and `onOutput` allow you to transform inputs\n   * and outputs using computations that may involve additional logic, resource\n   * access, or side effects.\n   *\n   * @see {@link mapBoth} If you need to use pure transformation functions.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, In2, R2, Out2, R3>(\n    self: Schedule<Out, In, R>,\n    options: {\n      readonly onInput: (input: In2) => Effect.Effect<In, never, R2>\n      readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>\n    }\n  ): Schedule<Out2, In2, R | R2 | R3>\n} = internal.mapBothEffect\n\n/**\n * Creates a driver to manually control the execution of a schedule.\n *\n * **Details**\n *\n * This function returns a `ScheduleDriver`, which allows stepping through a\n * schedule manually while handling delays and sleeping appropriately. A driver\n * is useful when you need fine-grained control over how a schedule progresses,\n * rather than relying on automatic execution.\n *\n * The returned driver exposes methods for retrieving the current state,\n * executing the next step, and resetting the schedule when needed.\n *\n * @since 2.0.0\n * @category getter\n */\nexport const driver: <Out, In, R>(\n  self: Schedule<Out, In, R>\n) => Effect.Effect<ScheduleDriver<Out, In, R>> = internal.driver\n\n// TODO(4.0): remove?\n/**\n * Alias of {@link fromDelay}.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration> = internal.duration\n\n// TODO(4.0): remove?\n/**\n * Alias of {@link union}.\n *\n * @since 2.0.0\n * @category Alternatives\n */\nexport const either: {\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link union}.\n   *\n   * @since 2.0.0\n   * @category Alternatives\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link union}.\n   *\n   * @since 2.0.0\n   * @category Alternatives\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>\n} = internal.either\n\n// TODO(4.0): remove?\n/**\n * Alias of {@link unionWith}.\n *\n * @since 2.0.0\n * @category Alternatives\n */\nexport const eitherWith: {\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link unionWith}.\n   *\n   * @since 2.0.0\n   * @category Alternatives\n   */\n  <Out2, In2, R2>(\n    that: Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>\n  // TODO(4.0): remove?\n  /**\n   * Alias of {@link unionWith}.\n   *\n   * @since 2.0.0\n   * @category Alternatives\n   */\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule<Out, In, R>,\n    that: Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ): Schedule<[Out, Out2], In & In2, R | R2>\n} = internal.eitherWith\n\n/**\n * Creates a schedule that tracks the total elapsed duration since it started.\n *\n * **Details**\n *\n * This schedule executes continuously and returns the total time that has\n * passed since the first execution. The duration keeps increasing with each\n * step, providing a way to measure elapsed time.\n *\n * This is useful for tracking execution time, monitoring delays, or\n * implementing logic based on how long a process has been running.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const elapsed: Schedule<Duration.Duration> = internal.elapsed\n\n/**\n * Attaches a finalizer to a schedule that runs when the schedule completes.\n *\n * **Details**\n *\n * This function returns a new schedule that executes a given finalizer when the\n * schedule reaches completion. Unlike `Effect.ensuring`, this method does not\n * guarantee the finalizer will run in all cases. If the schedule never\n * initializes or is not driven to completion, the finalizer may not execute.\n * However, if the schedule decides not to continue, the finalizer will be\n * invoked.\n *\n * This is useful for cleaning up resources, logging, or executing other side\n * effects when a schedule completes.\n *\n * @since 2.0.0\n * @category Finalization\n */\nexport const ensuring: {\n  /**\n   * Attaches a finalizer to a schedule that runs when the schedule completes.\n   *\n   * **Details**\n   *\n   * This function returns a new schedule that executes a given finalizer when the\n   * schedule reaches completion. Unlike `Effect.ensuring`, this method does not\n   * guarantee the finalizer will run in all cases. If the schedule never\n   * initializes or is not driven to completion, the finalizer may not execute.\n   * However, if the schedule decides not to continue, the finalizer will be\n   * invoked.\n   *\n   * This is useful for cleaning up resources, logging, or executing other side\n   * effects when a schedule completes.\n   *\n   * @since 2.0.0\n   * @category Finalization\n   */\n  <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Attaches a finalizer to a schedule that runs when the schedule completes.\n   *\n   * **Details**\n   *\n   * This function returns a new schedule that executes a given finalizer when the\n   * schedule reaches completion. Unlike `Effect.ensuring`, this method does not\n   * guarantee the finalizer will run in all cases. If the schedule never\n   * initializes or is not driven to completion, the finalizer may not execute.\n   * However, if the schedule decides not to continue, the finalizer will be\n   * invoked.\n   *\n   * This is useful for cleaning up resources, logging, or executing other side\n   * effects when a schedule completes.\n   *\n   * @since 2.0.0\n   * @category Finalization\n   */\n  <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>\n} = internal.ensuring\n\n/**\n * Creates a schedule that recurs indefinitely with exponentially increasing\n * delays.\n *\n * **Details**\n *\n * This schedule starts with an initial delay of `base` and increases the delay\n * exponentially on each repetition using the formula `base * factor^n`, where\n * `n` is the number of times the schedule has executed so far. If no `factor`\n * is provided, it defaults to `2`, causing the delay to double after each\n * execution.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const exponential: (\n  base: Duration.DurationInput,\n  factor?: number\n) => Schedule<Duration.Duration> = internal.exponential\n\n/**\n * Creates a schedule that recurs indefinitely with Fibonacci-based increasing\n * delays.\n *\n * **Details**\n *\n * This schedule starts with an initial delay of `one` and increases subsequent\n * delays by summing the two previous delays, following the Fibonacci sequence.\n * The delay pattern follows: `one, one, one + one, (one + one) + one, ...`,\n * resulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.\n *\n * This is useful for progressive backoff strategies, where delays grow\n * naturally over time without increasing as aggressively as an exponential\n * schedule.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration> = internal.fibonacci\n\n/**\n * Creates a schedule that recurs at a fixed interval.\n *\n * **Details**\n *\n * This schedule executes at regular, evenly spaced intervals, returning the\n * number of times it has run so far. If the action being executed takes longer\n * than the interval, the next execution will happen immediately to prevent\n * \"pile-ups,\" ensuring that the schedule remains consistent without overlapping\n * executions.\n *\n * ```text\n * |-----interval-----|-----interval-----|-----interval-----|\n * |---------action--------||action|-----|action|-----------|\n * ```\n *\n * @see {@link spaced} If you need to run from the end of the last execution.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fixed: (interval: Duration.DurationInput) => Schedule<number> = internal.fixed\n\n/**\n * Creates a schedule that recurs indefinitely, producing a count of\n * repetitions.\n *\n * **Details**\n *\n * This schedule runs indefinitely, returning an increasing count of executions\n * (`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking\n * of how many times it has executed.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const forever: Schedule<number> = internal.forever\n\n/**\n * Creates a schedule that recurs once after a specified duration.\n *\n * **Details**\n *\n * This schedule executes a single time after waiting for the given duration.\n * Once it has executed, it does not repeat.\n *\n * @see {@link fromDelays} If you need to create a schedule with multiple delays.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration> = internal.fromDelay\n\n/**\n * Creates a schedule that recurs once for each specified duration, applying the\n * given delays sequentially.\n *\n * **Details**\n *\n * This schedule executes multiple times, each time waiting for the\n * corresponding duration from the provided list of delays. The first execution\n * waits for `delay`, the next for the second value in `delays`, and so on. Once\n * all delays have been used, the schedule stops executing.\n *\n * This is useful for defining a custom delay sequence that does not follow a\n * fixed pattern like exponential or Fibonacci backoff.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fromDelays: (\n  delay: Duration.DurationInput,\n  ...delays: Array<Duration.DurationInput>\n) => Schedule<Duration.Duration> = internal.fromDelays\n\n/**\n * Creates a schedule that always recurs, transforming input values using the\n * specified function.\n *\n * **Details**\n *\n * This schedule continuously executes and applies the given function `f` to\n * each input value, producing a transformed output. The schedule itself does\n * not control delays or stopping conditions; it simply transforms the input\n * values as they are processed.\n *\n * This is useful when defining schedules that map inputs to outputs, allowing\n * dynamic transformations of incoming data.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A> = internal.fromFunction\n\n/**\n * Creates a schedule that always recurs, passing inputs directly as outputs.\n *\n * **Details**\n *\n * This schedule runs indefinitely, returning each input value as its output\n * without modification. It effectively acts as a pass-through that simply\n * echoes its input values at each step.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const identity: <A>() => Schedule<A, A> = internal.identity\n\n/**\n * Transforms a schedule to pass through its inputs as outputs.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it returns its input\n * values instead of its original output values. The schedule's timing remains\n * unchanged, but its outputs are replaced with whatever inputs it receives.\n *\n * @since 2.0.0\n */\nexport const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R> = internal.passthrough\n\n/**\n * Combines two schedules, continuing only if both schedules want to continue,\n * using the longer delay.\n *\n * **Details**\n *\n * This function takes two schedules and creates a new schedule that only\n * continues execution if both schedules allow it. The interval between\n * recurrences is determined by the longer delay between the two schedules.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules. The input type is the intersection of both schedules' input\n * types.\n *\n * This is useful when coordinating multiple scheduling conditions where\n * execution should proceed only when both schedules permit it.\n *\n * @see {@link intersectWith} If you need to use a custom merge function.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const intersect: {\n  /**\n   * Combines two schedules, continuing only if both schedules want to continue,\n   * using the longer delay.\n   *\n   * **Details**\n   *\n   * This function takes two schedules and creates a new schedule that only\n   * continues execution if both schedules allow it. The interval between\n   * recurrences is determined by the longer delay between the two schedules.\n   *\n   * The output of the resulting schedule is a tuple containing the outputs of\n   * both schedules. The input type is the intersection of both schedules' input\n   * types.\n   *\n   * This is useful when coordinating multiple scheduling conditions where\n   * execution should proceed only when both schedules permit it.\n   *\n   * @see {@link intersectWith} If you need to use a custom merge function.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>\n  /**\n   * Combines two schedules, continuing only if both schedules want to continue,\n   * using the longer delay.\n   *\n   * **Details**\n   *\n   * This function takes two schedules and creates a new schedule that only\n   * continues execution if both schedules allow it. The interval between\n   * recurrences is determined by the longer delay between the two schedules.\n   *\n   * The output of the resulting schedule is a tuple containing the outputs of\n   * both schedules. The input type is the intersection of both schedules' input\n   * types.\n   *\n   * This is useful when coordinating multiple scheduling conditions where\n   * execution should proceed only when both schedules permit it.\n   *\n   * @see {@link intersectWith} If you need to use a custom merge function.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>\n} = internal.intersect\n\n/**\n * Combines two schedules, continuing only if both want to continue, merging\n * intervals using a custom function.\n *\n * **Details**\n *\n * This function takes two schedules and creates a new schedule that only\n * continues execution if both schedules allow it. Instead of automatically\n * using the longer delay (like {@link intersect}), this function applies a\n * user-provided merge function `f` to determine the next interval between\n * executions.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules, and the input type is the intersection of both schedules'\n * input types.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const intersectWith: {\n  /**\n   * Combines two schedules, continuing only if both want to continue, merging\n   * intervals using a custom function.\n   *\n   * **Details**\n   *\n   * This function takes two schedules and creates a new schedule that only\n   * continues execution if both schedules allow it. Instead of automatically\n   * using the longer delay (like {@link intersect}), this function applies a\n   * user-provided merge function `f` to determine the next interval between\n   * executions.\n   *\n   * The output of the resulting schedule is a tuple containing the outputs of\n   * both schedules, and the input type is the intersection of both schedules'\n   * input types.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2>(\n    that: Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>\n  /**\n   * Combines two schedules, continuing only if both want to continue, merging\n   * intervals using a custom function.\n   *\n   * **Details**\n   *\n   * This function takes two schedules and creates a new schedule that only\n   * continues execution if both schedules allow it. Instead of automatically\n   * using the longer delay (like {@link intersect}), this function applies a\n   * user-provided merge function `f` to determine the next interval between\n   * executions.\n   *\n   * The output of the resulting schedule is a tuple containing the outputs of\n   * both schedules, and the input type is the intersection of both schedules'\n   * input types.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule<Out, In, R>,\n    that: Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ): Schedule<[Out, Out2], In & In2, R | R2>\n} = internal.intersectWith\n\n/**\n * Returns a new schedule that randomly adjusts the interval size within a\n * range.\n *\n * **Details**\n *\n * This function modifies a schedule so that its delay between executions is\n * randomly varied within a range. By default, the delay is adjusted between\n * `80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original\n * interval size.\n *\n * This is useful for adding randomness to repeated executions, reducing\n * contention in distributed systems, and avoiding synchronized execution\n * patterns that can cause bottlenecks.\n *\n * @see {@link jitteredWith} If you need to specify custom min/max values.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R> = internal.jittered\n\n/**\n * Returns a new schedule that randomly adjusts the interval size within a\n * user-defined range.\n *\n * **Details**\n *\n * This function modifies a schedule so that its delay between executions is\n * randomly varied within a specified range. Instead of using the default `0.8 -\n * 1.2` range like {@link jittered}, this function allows customizing the `min`\n * and `max` multipliers.\n *\n * The delay for each step will be adjusted within `min * original_interval` and\n * `max * original_interval`. If `min` and `max` are not provided, the defaults\n * are `0.8` and `1.2`, respectively.\n *\n * This is useful for introducing randomness into scheduling behavior while\n * having precise control over the jitter range.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const jitteredWith: {\n  /**\n   * Returns a new schedule that randomly adjusts the interval size within a\n   * user-defined range.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule so that its delay between executions is\n   * randomly varied within a specified range. Instead of using the default `0.8 -\n   * 1.2` range like {@link jittered}, this function allows customizing the `min`\n   * and `max` multipliers.\n   *\n   * The delay for each step will be adjusted within `min * original_interval` and\n   * `max * original_interval`. If `min` and `max` are not provided, the defaults\n   * are `0.8` and `1.2`, respectively.\n   *\n   * This is useful for introducing randomness into scheduling behavior while\n   * having precise control over the jitter range.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  (options: { min?: number | undefined; max?: number | undefined }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that randomly adjusts the interval size within a\n   * user-defined range.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule so that its delay between executions is\n   * randomly varied within a specified range. Instead of using the default `0.8 -\n   * 1.2` range like {@link jittered}, this function allows customizing the `min`\n   * and `max` multipliers.\n   *\n   * The delay for each step will be adjusted within `min * original_interval` and\n   * `max * original_interval`. If `min` and `max` are not provided, the defaults\n   * are `0.8` and `1.2`, respectively.\n   *\n   * This is useful for introducing randomness into scheduling behavior while\n   * having precise control over the jitter range.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R>(\n    self: Schedule<Out, In, R>,\n    options: { min?: number | undefined; max?: number | undefined }\n  ): Schedule<Out, In, R>\n} = internal.jitteredWith\n\n/**\n * Creates a schedule that recurs indefinitely, increasing the delay linearly.\n *\n * **Details**\n *\n * This schedule starts with an initial delay of `base` and increases the delay\n * on each recurrence in a linear fashion, following the formula:\n *\n * `delay = base * n`\n *\n * where `n` is the number of times the schedule has executed so far. This\n * results in increasing intervals between executions.\n *\n * This is useful for implementing linear backoff strategies where the wait time\n * between retries increases at a steady rate.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration> = internal.linear\n\n/**\n * Returns a new schedule that transforms its output using the specified\n * function.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that its outputs are\n * transformed by the provided function `f`. The timing and recurrence behavior\n * of the schedule remain unchanged, but the values it produces are mapped to\n * new values.\n *\n * This is useful when composing schedules where you need to adjust the output\n * format or apply additional processing.\n *\n * @see {@link mapEffect} If you need to use an effectful transformation\n * function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const map: {\n  /**\n   * Returns a new schedule that transforms its output using the specified\n   * function.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that its outputs are\n   * transformed by the provided function `f`. The timing and recurrence behavior\n   * of the schedule remain unchanged, but the values it produces are mapped to\n   * new values.\n   *\n   * This is useful when composing schedules where you need to adjust the output\n   * format or apply additional processing.\n   *\n   * @see {@link mapEffect} If you need to use an effectful transformation\n   * function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>\n  /**\n   * Returns a new schedule that transforms its output using the specified\n   * function.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that its outputs are\n   * transformed by the provided function `f`. The timing and recurrence behavior\n   * of the schedule remain unchanged, but the values it produces are mapped to\n   * new values.\n   *\n   * This is useful when composing schedules where you need to adjust the output\n   * format or apply additional processing.\n   *\n   * @see {@link mapEffect} If you need to use an effectful transformation\n   * function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>\n} = internal.map\n\n/**\n * Returns a new schedule that applies an effectful transformation to its\n * output.\n *\n * **Details**\n *\n * This function modifies an existing schedule by applying an effectful function\n * `f` to its output values. The timing and recurrence behavior of the schedule\n * remain unchanged, but each output is mapped to a new value within an\n * `Effect`.\n *\n * This is useful when you need to perform side effects or asynchronous\n * transformations before passing the output forward.\n *\n * @see {@link map} If you need to use a pure transformation function.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapEffect: {\n  /**\n   * Returns a new schedule that applies an effectful transformation to its\n   * output.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule by applying an effectful function\n   * `f` to its output values. The timing and recurrence behavior of the schedule\n   * remain unchanged, but each output is mapped to a new value within an\n   * `Effect`.\n   *\n   * This is useful when you need to perform side effects or asynchronous\n   * transformations before passing the output forward.\n   *\n   * @see {@link map} If you need to use a pure transformation function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, Out2, R2>(f: (out: Out) => Effect.Effect<Out2, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>\n  /**\n   * Returns a new schedule that applies an effectful transformation to its\n   * output.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule by applying an effectful function\n   * `f` to its output values. The timing and recurrence behavior of the schedule\n   * remain unchanged, but each output is mapped to a new value within an\n   * `Effect`.\n   *\n   * This is useful when you need to perform side effects or asynchronous\n   * transformations before passing the output forward.\n   *\n   * @see {@link map} If you need to use a pure transformation function.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <Out, In, R, Out2, R2>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<Out2, never, R2>\n  ): Schedule<Out2, In, R | R2>\n} = internal.mapEffect\n\n/**\n * Returns a new schedule that modifies the delay between executions using a\n * custom function.\n *\n * **Details**\n *\n * This function transforms an existing schedule by applying `f` to modify the\n * delay before each execution. The function receives both the schedule's output\n * (`out`) and the originally computed delay (`duration`), and returns a new\n * adjusted delay.\n *\n * @see {@link modifyDelayEffect} If you need to use an effectful function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const modifyDelay: {\n  /**\n   * Returns a new schedule that modifies the delay between executions using a\n   * custom function.\n   *\n   * **Details**\n   *\n   * This function transforms an existing schedule by applying `f` to modify the\n   * delay before each execution. The function receives both the schedule's output\n   * (`out`) and the originally computed delay (`duration`), and returns a new\n   * adjusted delay.\n   *\n   * @see {@link modifyDelayEffect} If you need to use an effectful function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out>(f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that modifies the delay between executions using a\n   * custom function.\n   *\n   * **Details**\n   *\n   * This function transforms an existing schedule by applying `f` to modify the\n   * delay before each execution. The function receives both the schedule's output\n   * (`out`) and the originally computed delay (`duration`), and returns a new\n   * adjusted delay.\n   *\n   * @see {@link modifyDelayEffect} If you need to use an effectful function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out, duration: Duration.Duration) => Duration.DurationInput\n  ): Schedule<Out, In, R>\n} = internal.modifyDelay\n\n/**\n * Returns a new schedule that modifies the delay before execution using an\n * effectful function.\n *\n * **Details**\n *\n * This function takes an existing schedule and applies an effectful function\n * `f` to dynamically adjust the delay before each execution. The function\n * receives both the schedule's output (`out`) and the originally computed delay\n * (`duration`), returning a new adjusted delay wrapped in an `Effect`.\n *\n * @see {@link modifyDelay} If you need to use a pure function.\n *\n * @since 2.0.0\n * @category Timing & Delay\n */\nexport const modifyDelayEffect: {\n  /**\n   * Returns a new schedule that modifies the delay before execution using an\n   * effectful function.\n   *\n   * **Details**\n   *\n   * This function takes an existing schedule and applies an effectful function\n   * `f` to dynamically adjust the delay before each execution. The function\n   * receives both the schedule's output (`out`) and the originally computed delay\n   * (`duration`), returning a new adjusted delay wrapped in an `Effect`.\n   *\n   * @see {@link modifyDelay} If you need to use a pure function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, R2>(\n    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that modifies the delay before execution using an\n   * effectful function.\n   *\n   * **Details**\n   *\n   * This function takes an existing schedule and applies an effectful function\n   * `f` to dynamically adjust the delay before each execution. The function\n   * receives both the schedule's output (`out`) and the originally computed delay\n   * (`duration`), returning a new adjusted delay wrapped in an `Effect`.\n   *\n   * @see {@link modifyDelay} If you need to use a pure function.\n   *\n   * @since 2.0.0\n   * @category Timing & Delay\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.modifyDelayEffect\n\n/**\n * Returns a new schedule that executes an effect every time the schedule makes\n * a decision.\n *\n * **Details**\n *\n * This function enhances an existing schedule by running an effectful function\n * `f` whenever a scheduling decision is made. The function receives the current\n * schedule output (`out`) and the decision (`ScheduleDecision`), allowing\n * additional logic to be executed, such as logging, monitoring, or side\n * effects.\n *\n * @since 2.0.0\n */\nexport const onDecision: {\n  /**\n   * Returns a new schedule that executes an effect every time the schedule makes\n   * a decision.\n   *\n   * **Details**\n   *\n   * This function enhances an existing schedule by running an effectful function\n   * `f` whenever a scheduling decision is made. The function receives the current\n   * schedule output (`out`) and the decision (`ScheduleDecision`), allowing\n   * additional logic to be executed, such as logging, monitoring, or side\n   * effects.\n   *\n   * @since 2.0.0\n   */\n  <Out, X, R2>(\n    f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>\n  ): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that executes an effect every time the schedule makes\n   * a decision.\n   *\n   * **Details**\n   *\n   * This function enhances an existing schedule by running an effectful function\n   * `f` whenever a scheduling decision is made. The function receives the current\n   * schedule output (`out`) and the decision (`ScheduleDecision`), allowing\n   * additional logic to be executed, such as logging, monitoring, or side\n   * effects.\n   *\n   * @since 2.0.0\n   */\n  <Out, In, R, X, R2>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.onDecision\n\n/**\n * A schedule that executes only once and then stops.\n *\n * **Details**\n *\n * This schedule triggers a single execution and then terminates. It does not\n * repeat or apply any additional logic.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const once: Schedule<void> = internal.once\n\n/**\n * Returns a new schedule with a provided context, eliminating the need for\n * external dependencies.\n *\n * **Details**\n *\n * This function supplies a required `context` to a schedule, allowing it to run\n * without requiring external dependencies. After calling this function, the\n * schedule can be used freely without needing to pass a context at execution\n * time.\n *\n * This is useful when working with schedules that rely on contextual\n * information, such as logging services, database connections, or configuration\n * settings.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provideContext: {\n  /**\n   * Returns a new schedule with a provided context, eliminating the need for\n   * external dependencies.\n   *\n   * **Details**\n   *\n   * This function supplies a required `context` to a schedule, allowing it to run\n   * without requiring external dependencies. After calling this function, the\n   * schedule can be used freely without needing to pass a context at execution\n   * time.\n   *\n   * This is useful when working with schedules that rely on contextual\n   * information, such as logging services, database connections, or configuration\n   * settings.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>\n  /**\n   * Returns a new schedule with a provided context, eliminating the need for\n   * external dependencies.\n   *\n   * **Details**\n   *\n   * This function supplies a required `context` to a schedule, allowing it to run\n   * without requiring external dependencies. After calling this function, the\n   * schedule can be used freely without needing to pass a context at execution\n   * time.\n   *\n   * This is useful when working with schedules that rely on contextual\n   * information, such as logging services, database connections, or configuration\n   * settings.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>\n} = internal.provideContext\n\n/**\n * Returns a new schedule with a single required service provided, eliminating\n * the need for external dependencies.\n *\n * **Details**\n *\n * This function supplies a single service dependency to a schedule, allowing it\n * to run without requiring that service externally. If a schedule depends on\n * multiple services, consider using `provideContext` instead.\n *\n * This is useful when working with schedules that require a specific service,\n * such as logging, metrics, or configuration retrieval.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provideService: {\n  /**\n   * Returns a new schedule with a single required service provided, eliminating\n   * the need for external dependencies.\n   *\n   * **Details**\n   *\n   * This function supplies a single service dependency to a schedule, allowing it\n   * to run without requiring that service externally. If a schedule depends on\n   * multiple services, consider using `provideContext` instead.\n   *\n   * This is useful when working with schedules that require a specific service,\n   * such as logging, metrics, or configuration retrieval.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>\n  /**\n   * Returns a new schedule with a single required service provided, eliminating\n   * the need for external dependencies.\n   *\n   * **Details**\n   *\n   * This function supplies a single service dependency to a schedule, allowing it\n   * to run without requiring that service externally. If a schedule depends on\n   * multiple services, consider using `provideContext` instead.\n   *\n   * This is useful when working with schedules that require a specific service,\n   * such as logging, metrics, or configuration retrieval.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <Out, In, R, I, S>(\n    self: Schedule<Out, In, R>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ): Schedule<Out, In, Exclude<R, I>>\n} = internal.provideService\n\n/**\n * A schedule that recurs until the given predicate evaluates to true.\n *\n * **Details**\n *\n * This schedule will continue executing as long as the provided predicate `f`\n * returns `false` for the input value. Once `f` evaluates to `true`, the\n * schedule stops recurring.\n *\n * This is useful for defining schedules that should stop when a certain\n * condition is met, such as detecting a success state, reaching a threshold, or\n * avoiding unnecessary retries.\n *\n * @see {@link recurUntilEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A> = internal.recurUntil\n\n/**\n * A schedule that recurs until the given effectful predicate evaluates to true.\n *\n * **Details**\n *\n * This schedule continues executing as long as the provided effectful predicate\n * `f` returns `false`. Once `f` evaluates to `true`, the schedule stops\n * recurring. Unlike {@link recurUntil}, this function allows the stopping\n * condition to be computed asynchronously or based on external dependencies.\n *\n * This is useful when the stopping condition depends on an effectful\n * computation, such as checking a database, making an API call, or retrieving\n * system state dynamically.\n *\n * @see {@link recurUntil} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R> =\n  internal.recurUntilEffect\n\n/**\n * A schedule that recurs until the input value matches a partial function, then\n * maps the value.\n *\n * **Details**\n *\n * This schedule continues executing until the provided partial function `pf`\n * returns `Some(value)`. At that point, it stops and maps the resulting value\n * to an `Option<B>`. If `pf` returns `None`, the schedule continues.\n *\n * This is useful when defining schedules that should stop once a certain\n * condition is met and transform the final value before completion.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A> =\n  internal.recurUntilOption\n\n/**\n * A schedule that recurs until the specified duration has elapsed.\n *\n * **Details**\n *\n * This schedule continues executing for the given `duration`, after which it\n * stops. The schedule outputs the elapsed time on each recurrence.\n *\n * This is useful for limiting the duration of retries, enforcing time-based\n * constraints, or ensuring that an operation does not run indefinitely.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration> = internal.recurUpTo\n\n/**\n * A schedule that recurs as long as the given predicate evaluates to true.\n *\n * **Details*\n *\n * This schedule continues executing as long as the provided predicate `f`\n * returns `true` for the input value. Once `f` evaluates to `false`, the\n * schedule stops recurring.\n *\n * @see {@link recurWhileEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A> = internal.recurWhile\n\n/**\n * A schedule that recurs as long as the given effectful predicate evaluates to\n * true.\n *\n * **Details**\n *\n * This schedule continues executing as long as the provided effectful predicate\n * `f` returns `true`. Once `f` evaluates to `false`, the schedule stops\n * recurring. Unlike {@link recurWhile}, this function allows the condition to\n * be computed dynamically using an effectful computation.\n *\n * @see {@link recurWhile} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R> =\n  internal.recurWhileEffect\n\n/**\n * A schedule that recurs a fixed number of times before terminating.\n *\n * **Details**\n *\n * This schedule will continue executing until it has been stepped `n` times,\n * after which it will stop. The output of the schedule is the current count of\n * recurrences.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const recurs: (n: number) => Schedule<number> = internal.recurs\n\n/**\n * Returns a new schedule that folds over the outputs of this one.\n *\n * **Details**\n *\n * This schedule transforms the output by accumulating values over time using a\n * reducer function `f`. It starts with an initial value `zero` and updates it\n * each time the schedule produces an output.\n *\n * This is useful for tracking statistics, aggregating results, or summarizing\n * data across multiple executions.\n *\n * @see {@link reduceEffect} If you need to use an effectful reducer function.\n *\n * @since 2.0.0\n * @category Reducing\n */\nexport const reduce: {\n  /**\n   * Returns a new schedule that folds over the outputs of this one.\n   *\n   * **Details**\n   *\n   * This schedule transforms the output by accumulating values over time using a\n   * reducer function `f`. It starts with an initial value `zero` and updates it\n   * each time the schedule produces an output.\n   *\n   * This is useful for tracking statistics, aggregating results, or summarizing\n   * data across multiple executions.\n   *\n   * @see {@link reduceEffect} If you need to use an effectful reducer function.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>\n  /**\n   * Returns a new schedule that folds over the outputs of this one.\n   *\n   * **Details**\n   *\n   * This schedule transforms the output by accumulating values over time using a\n   * reducer function `f`. It starts with an initial value `zero` and updates it\n   * each time the schedule produces an output.\n   *\n   * This is useful for tracking statistics, aggregating results, or summarizing\n   * data across multiple executions.\n   *\n   * @see {@link reduceEffect} If you need to use an effectful reducer function.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>\n} = internal.reduce\n\n/**\n * Returns a new schedule that effectfully folds over the outputs of this one.\n *\n * **Details**\n *\n * This schedule accumulates outputs over time using an effectful reducer\n * function `f`. It starts with an initial value `zero` and updates it\n * asynchronously or based on external dependencies.\n *\n * This is useful for asynchronous state tracking, logging, external metrics\n * aggregation, or any scenario where accumulation needs to involve an effectful\n * computation.\n *\n * @see {@link reduce} If you need to use a pure reducer function.\n *\n * @since 2.0.0\n * @category Reducing\n */\nexport const reduceEffect: {\n  /**\n   * Returns a new schedule that effectfully folds over the outputs of this one.\n   *\n   * **Details**\n   *\n   * This schedule accumulates outputs over time using an effectful reducer\n   * function `f`. It starts with an initial value `zero` and updates it\n   * asynchronously or based on external dependencies.\n   *\n   * This is useful for asynchronous state tracking, logging, external metrics\n   * aggregation, or any scenario where accumulation needs to involve an effectful\n   * computation.\n   *\n   * @see {@link reduce} If you need to use a pure reducer function.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>\n  /**\n   * Returns a new schedule that effectfully folds over the outputs of this one.\n   *\n   * **Details**\n   *\n   * This schedule accumulates outputs over time using an effectful reducer\n   * function `f`. It starts with an initial value `zero` and updates it\n   * asynchronously or based on external dependencies.\n   *\n   * This is useful for asynchronous state tracking, logging, external metrics\n   * aggregation, or any scenario where accumulation needs to involve an effectful\n   * computation.\n   *\n   * @see {@link reduce} If you need to use a pure reducer function.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <Out, In, R, Z, R2>(\n    self: Schedule<Out, In, R>,\n    zero: Z,\n    f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>\n  ): Schedule<Z, In, R | R2>\n} = internal.reduceEffect\n\n// TODO(4.0): remove?\n/**\n * Alias of {@link forever}.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const repeatForever: Schedule<number> = internal.forever\n\n/**\n * Returns a new schedule that outputs the number of repetitions of this one.\n *\n * **Details**\n *\n * This schedule tracks how many times the given schedule has executed and\n * outputs the count instead of the original values. The first execution starts\n * at `0`, and the count increases with each recurrence.\n *\n * @since 2.0.0\n * @category Monitoring\n */\nexport const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R> = internal.repetitions\n\n/**\n * Returns a new schedule that automatically resets to its initial state after a\n * period of inactivity defined by `duration`.\n *\n * **Details**\n *\n * This function modifies a schedule so that if no inputs are received for the\n * specified `duration`, the schedule resets as if it were new.\n *\n * @see {@link resetWhen} If you need to reset based on output values.\n *\n * @since 2.0.0\n * @category State Management\n */\nexport const resetAfter: {\n  /**\n   * Returns a new schedule that automatically resets to its initial state after a\n   * period of inactivity defined by `duration`.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule so that if no inputs are received for the\n   * specified `duration`, the schedule resets as if it were new.\n   *\n   * @see {@link resetWhen} If you need to reset based on output values.\n   *\n   * @since 2.0.0\n   * @category State Management\n   */\n  (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that automatically resets to its initial state after a\n   * period of inactivity defined by `duration`.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule so that if no inputs are received for the\n   * specified `duration`, the schedule resets as if it were new.\n   *\n   * @see {@link resetWhen} If you need to reset based on output values.\n   *\n   * @since 2.0.0\n   * @category State Management\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>\n} = internal.resetAfter\n\n/**\n * Resets the schedule when the specified predicate on the schedule output\n * evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies a schedule so that it resets to its initial state\n * whenever the provided predicate `f` returns `true` for an output value.\n *\n * @see {@link resetAfter} If you need to reset based on inactivity.\n *\n * @since 2.0.0\n * @category State Management\n */\nexport const resetWhen: {\n  /**\n   * Resets the schedule when the specified predicate on the schedule output\n   * evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule so that it resets to its initial state\n   * whenever the provided predicate `f` returns `true` for an output value.\n   *\n   * @see {@link resetAfter} If you need to reset based on inactivity.\n   *\n   * @since 2.0.0\n   * @category State Management\n   */\n  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Resets the schedule when the specified predicate on the schedule output\n   * evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies a schedule so that it resets to its initial state\n   * whenever the provided predicate `f` returns `true` for an output value.\n   *\n   * @see {@link resetAfter} If you need to reset based on inactivity.\n   *\n   * @since 2.0.0\n   * @category State Management\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>\n} = internal.resetWhen\n\n/**\n * Runs a schedule using the provided inputs and collects all outputs.\n *\n * **Details**\n *\n * This function executes a given schedule with a sequence of input values and\n * accumulates all outputs into a `Chunk`. The schedule starts execution at the\n * specified `now` timestamp and proceeds according to its defined behavior.\n *\n * This is useful for batch processing, simulating execution, or testing\n * schedules with predefined input sequences.\n *\n * @since 2.0.0\n * @category Execution\n */\nexport const run: {\n  /**\n   * Runs a schedule using the provided inputs and collects all outputs.\n   *\n   * **Details**\n   *\n   * This function executes a given schedule with a sequence of input values and\n   * accumulates all outputs into a `Chunk`. The schedule starts execution at the\n   * specified `now` timestamp and proceeds according to its defined behavior.\n   *\n   * This is useful for batch processing, simulating execution, or testing\n   * schedules with predefined input sequences.\n   *\n   * @since 2.0.0\n   * @category Execution\n   */\n  <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>\n  /**\n   * Runs a schedule using the provided inputs and collects all outputs.\n   *\n   * **Details**\n   *\n   * This function executes a given schedule with a sequence of input values and\n   * accumulates all outputs into a `Chunk`. The schedule starts execution at the\n   * specified `now` timestamp and proceeds according to its defined behavior.\n   *\n   * This is useful for batch processing, simulating execution, or testing\n   * schedules with predefined input sequences.\n   *\n   * @since 2.0.0\n   * @category Execution\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>\n} = internal.run\n\n/**\n * Returns a schedule that recurs continuously, with each repetition\n * spaced by the specified `duration` from the last run.\n *\n * **Details**\n *\n * This schedule ensures that executions occur at a fixed interval,\n * maintaining a consistent delay between repetitions. The delay starts\n * from the end of the last execution, not from the schedule start time.\n *\n * @see {@link fixed} If you need to run at a fixed interval from the start.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const spaced: (duration: Duration.DurationInput) => Schedule<number> = internal.spaced\n\n/**\n * A schedule that does not recur and stops immediately.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const stop: Schedule<void> = internal.stop\n\n/**\n * Returns a schedule that recurs indefinitely, always producing the specified\n * constant value.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const succeed: <A>(value: A) => Schedule<A> = internal.succeed\n\n/**\n * Returns a schedule that recurs indefinitely, evaluating the given function to\n * produce a constant value.\n *\n * @category Constructors\n * @since 2.0.0\n */\nexport const sync: <A>(evaluate: LazyArg<A>) => Schedule<A> = internal.sync\n\n/**\n * Returns a new schedule that runs the given effectful function for each input\n * before continuing execution.\n *\n * **Details**\n *\n * This function allows side effects to be performed on each input processed by\n * the schedule. It does not modify the schedule’s behavior but ensures that the\n * provided function `f` runs before each step.\n *\n * @since 2.0.0\n * @category Tapping\n */\nexport const tapInput: {\n  /**\n   * Returns a new schedule that runs the given effectful function for each input\n   * before continuing execution.\n   *\n   * **Details**\n   *\n   * This function allows side effects to be performed on each input processed by\n   * the schedule. It does not modify the schedule’s behavior but ensures that the\n   * provided function `f` runs before each step.\n   *\n   * @since 2.0.0\n   * @category Tapping\n   */\n  <In2, X, R2>(f: (input: In2) => Effect.Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>\n  /**\n   * Returns a new schedule that runs the given effectful function for each input\n   * before continuing execution.\n   *\n   * **Details**\n   *\n   * This function allows side effects to be performed on each input processed by\n   * the schedule. It does not modify the schedule’s behavior but ensures that the\n   * provided function `f` runs before each step.\n   *\n   * @since 2.0.0\n   * @category Tapping\n   */\n  <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect.Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>\n} = internal.tapInput\n\n/**\n * Returns a new schedule that runs the given effectful function for each output\n * before continuing execution.\n *\n * **Details**\n *\n * This function allows side effects to be performed on each output produced by\n * the schedule. It does not modify the schedule’s behavior but ensures that the\n * provided function `f` runs after each step.\n *\n * @since 2.0.0\n * @category Tapping\n */\nexport const tapOutput: {\n  /**\n   * Returns a new schedule that runs the given effectful function for each output\n   * before continuing execution.\n   *\n   * **Details**\n   *\n   * This function allows side effects to be performed on each output produced by\n   * the schedule. It does not modify the schedule’s behavior but ensures that the\n   * provided function `f` runs after each step.\n   *\n   * @since 2.0.0\n   * @category Tapping\n   */\n  <X, R2, Out>(f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that runs the given effectful function for each output\n   * before continuing execution.\n   *\n   * **Details**\n   *\n   * This function allows side effects to be performed on each output produced by\n   * the schedule. It does not modify the schedule’s behavior but ensures that the\n   * provided function `f` runs after each step.\n   *\n   * @since 2.0.0\n   * @category Tapping\n   */\n  <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>\n} = internal.tapOutput\n\n/**\n * Creates a schedule that repeatedly applies a function to transform a state\n * value, producing a sequence of values.\n *\n * **Details**\n *\n * This function starts with an `initial` value and applies `f` recursively to\n * generate the next state at each step. The schedule continues indefinitely,\n * producing a stream of values by unfolding the state over time.\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A> = internal.unfold\n\n/**\n * Combines two schedules, continuing execution as long as at least one of them\n * allows it, using the shorter delay.\n *\n * **Details**\n *\n * This function combines two schedules into a single schedule that executes in\n * parallel. If either schedule allows continuation, the merged schedule\n * continues. When both schedules produce delays, the schedule selects the\n * shorter delay to determine the next step.\n *\n * The output of the new schedule is a tuple containing the outputs of both\n * schedules. The input type is the intersection of both schedules' input types.\n *\n * This is useful for scenarios where multiple scheduling conditions should be\n * considered, ensuring execution proceeds if at least one schedule permits it.\n *\n * @see {@link unionWith} If you need to use a custom merge function.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const union: {\n  /**\n   * Combines two schedules, continuing execution as long as at least one of them\n   * allows it, using the shorter delay.\n   *\n   * **Details**\n   *\n   * This function combines two schedules into a single schedule that executes in\n   * parallel. If either schedule allows continuation, the merged schedule\n   * continues. When both schedules produce delays, the schedule selects the\n   * shorter delay to determine the next step.\n   *\n   * The output of the new schedule is a tuple containing the outputs of both\n   * schedules. The input type is the intersection of both schedules' input types.\n   *\n   * This is useful for scenarios where multiple scheduling conditions should be\n   * considered, ensuring execution proceeds if at least one schedule permits it.\n   *\n   * @see {@link unionWith} If you need to use a custom merge function.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>\n  /**\n   * Combines two schedules, continuing execution as long as at least one of them\n   * allows it, using the shorter delay.\n   *\n   * **Details**\n   *\n   * This function combines two schedules into a single schedule that executes in\n   * parallel. If either schedule allows continuation, the merged schedule\n   * continues. When both schedules produce delays, the schedule selects the\n   * shorter delay to determine the next step.\n   *\n   * The output of the new schedule is a tuple containing the outputs of both\n   * schedules. The input type is the intersection of both schedules' input types.\n   *\n   * This is useful for scenarios where multiple scheduling conditions should be\n   * considered, ensuring execution proceeds if at least one schedule permits it.\n   *\n   * @see {@link unionWith} If you need to use a custom merge function.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>\n} = internal.union\n\n/**\n * Combines two schedules, continuing execution as long as at least one of them\n * wants to continue, merging their intervals using a custom merge function.\n *\n * **Details**\n *\n * This function allows you to combine two schedules while defining how their\n * intervals should be merged. Unlike {@link union}, which simply selects the\n * shorter delay, this function lets you specify a custom merging strategy for\n * the schedules’ intervals.\n *\n * The merged schedule continues execution as long as at least one of the input\n * schedules allows it. The next interval is determined by applying the provided\n * merge function to the intervals of both schedules.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules. The input type is the intersection of both schedules' input\n * types.\n *\n * @see {@link union} If you need to use the shorter delay.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const unionWith: {\n  /**\n   * Combines two schedules, continuing execution as long as at least one of them\n   * wants to continue, merging their intervals using a custom merge function.\n   *\n   * **Details**\n   *\n   * This function allows you to combine two schedules while defining how their\n   * intervals should be merged. Unlike {@link union}, which simply selects the\n   * shorter delay, this function lets you specify a custom merging strategy for\n   * the schedules’ intervals.\n   *\n   * The merged schedule continues execution as long as at least one of the input\n   * schedules allows it. The next interval is determined by applying the provided\n   * merge function to the intervals of both schedules.\n   *\n   * The output of the resulting schedule is a tuple containing the outputs of\n   * both schedules. The input type is the intersection of both schedules' input\n   * types.\n   *\n   * @see {@link union} If you need to use the shorter delay.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2>(\n    that: Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>\n  /**\n   * Combines two schedules, continuing execution as long as at least one of them\n   * wants to continue, merging their intervals using a custom merge function.\n   *\n   * **Details**\n   *\n   * This function allows you to combine two schedules while defining how their\n   * intervals should be merged. Unlike {@link union}, which simply selects the\n   * shorter delay, this function lets you specify a custom merging strategy for\n   * the schedules’ intervals.\n   *\n   * The merged schedule continues execution as long as at least one of the input\n   * schedules allows it. The next interval is determined by applying the provided\n   * merge function to the intervals of both schedules.\n   *\n   * The output of the resulting schedule is a tuple containing the outputs of\n   * both schedules. The input type is the intersection of both schedules' input\n   * types.\n   *\n   * @see {@link union} If you need to use the shorter delay.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule<Out, In, R>,\n    that: Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ): Schedule<[Out, Out2], In & In2, R | R2>\n} = internal.unionWith\n\n/**\n * Returns a new schedule that stops execution when the given predicate on the\n * input evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it continues executing\n * only while the provided predicate returns `false` for incoming inputs. Once\n * an input satisfies the condition, the schedule terminates immediately.\n *\n * @see {@link untilInputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilInput: {\n  /**\n   * Returns a new schedule that stops execution when the given predicate on the\n   * input evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it continues executing\n   * only while the provided predicate returns `false` for incoming inputs. Once\n   * an input satisfies the condition, the schedule terminates immediately.\n   *\n   * @see {@link untilInputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that stops execution when the given predicate on the\n   * input evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it continues executing\n   * only while the provided predicate returns `false` for incoming inputs. Once\n   * an input satisfies the condition, the schedule terminates immediately.\n   *\n   * @see {@link untilInputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>\n} = internal.untilInput\n\n/**\n * Returns a new schedule that stops execution when the given effectful\n * predicate on the input evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it continues executing\n * only while the provided effectful predicate returns `false` for incoming\n * inputs. The predicate is an `Effect`, meaning it can involve asynchronous\n * computations or dependency-based logic.\n *\n * @see {@link untilInput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilInputEffect: {\n  /**\n   * Returns a new schedule that stops execution when the given effectful\n   * predicate on the input evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it continues executing\n   * only while the provided effectful predicate returns `false` for incoming\n   * inputs. The predicate is an `Effect`, meaning it can involve asynchronous\n   * computations or dependency-based logic.\n   *\n   * @see {@link untilInput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that stops execution when the given effectful\n   * predicate on the input evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it continues executing\n   * only while the provided effectful predicate returns `false` for incoming\n   * inputs. The predicate is an `Effect`, meaning it can involve asynchronous\n   * computations or dependency-based logic.\n   *\n   * @see {@link untilInput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (input: In) => Effect.Effect<boolean, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.untilInputEffect\n\n/**\n * Returns a new schedule that stops execution when the given predicate on the\n * output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * executing while the given predicate returns false for its output values. Once\n * the predicate evaluates to `true`, execution stops.\n *\n * The output of the resulting schedule remains the same, but its duration is\n * now constrained by a stopping condition based on its own output.\n *\n * @see {@link untilOutputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilOutput: {\n  /**\n   * Returns a new schedule that stops execution when the given predicate on the\n   * output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * executing while the given predicate returns false for its output values. Once\n   * the predicate evaluates to `true`, execution stops.\n   *\n   * The output of the resulting schedule remains the same, but its duration is\n   * now constrained by a stopping condition based on its own output.\n   *\n   * @see {@link untilOutputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that stops execution when the given predicate on the\n   * output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * executing while the given predicate returns false for its output values. Once\n   * the predicate evaluates to `true`, execution stops.\n   *\n   * The output of the resulting schedule remains the same, but its duration is\n   * now constrained by a stopping condition based on its own output.\n   *\n   * @see {@link untilOutputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>\n} = internal.untilOutput\n\n/**\n * Returns a new schedule that stops execution when the given effectful\n * predicate on the output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * executing while the provided effectful predicate returns `false` for its\n * output values. Once the predicate returns `true`, execution stops.\n *\n * @see {@link untilOutput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const untilOutputEffect: {\n  /**\n   * Returns a new schedule that stops execution when the given effectful\n   * predicate on the output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * executing while the provided effectful predicate returns `false` for its\n   * output values. Once the predicate returns `true`, execution stops.\n   *\n   * @see {@link untilOutput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that stops execution when the given effectful\n   * predicate on the output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * executing while the provided effectful predicate returns `false` for its\n   * output values. Once the predicate returns `true`, execution stops.\n   *\n   * @see {@link untilOutput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<boolean, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.untilOutputEffect\n\n/**\n * Returns a new schedule that limits execution to a fixed duration.\n *\n * **Details**\n *\n * This function modifies an existing schedule to stop execution after a\n * specified duration has passed. The schedule continues as normal until the\n * duration is reached, at which point it stops automatically.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const upTo: {\n  /**\n   * Returns a new schedule that limits execution to a fixed duration.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule to stop execution after a\n   * specified duration has passed. The schedule continues as normal until the\n   * duration is reached, at which point it stops automatically.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that limits execution to a fixed duration.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule to stop execution after a\n   * specified duration has passed. The schedule continues as normal until the\n   * duration is reached, at which point it stops automatically.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>\n} = internal.upTo\n\n/**\n * Returns a new schedule that continues execution as long as the given\n * predicate on the input is true.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while a specified predicate holds true for its input. If the\n * predicate evaluates to `false` at any step, the schedule stops.\n *\n * @see {@link whileInputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileInput: {\n  /**\n   * Returns a new schedule that continues execution as long as the given\n   * predicate on the input is true.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while a specified predicate holds true for its input. If the\n   * predicate evaluates to `false` at any step, the schedule stops.\n   *\n   * @see {@link whileInputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that continues execution as long as the given\n   * predicate on the input is true.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while a specified predicate holds true for its input. If the\n   * predicate evaluates to `false` at any step, the schedule stops.\n   *\n   * @see {@link whileInputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>\n} = internal.whileInput\n\n/**\n * Returns a new schedule that continues execution for as long as the given\n * effectful predicate on the input evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while an effectful predicate holds true for its input. If the\n * predicate evaluates to `false` at any step, the schedule stops.\n *\n * @see {@link whileInput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileInputEffect: {\n  /**\n   * Returns a new schedule that continues execution for as long as the given\n   * effectful predicate on the input evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while an effectful predicate holds true for its input. If the\n   * predicate evaluates to `false` at any step, the schedule stops.\n   *\n   * @see {@link whileInput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that continues execution for as long as the given\n   * effectful predicate on the input evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while an effectful predicate holds true for its input. If the\n   * predicate evaluates to `false` at any step, the schedule stops.\n   *\n   * @see {@link whileInput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (input: In) => Effect.Effect<boolean, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.whileInputEffect\n\n/**\n * Returns a new schedule that continues execution for as long as the given\n * predicate on the output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while a provided condition holds true for its output. If the\n * predicate returns `false`, the schedule stops.\n *\n * @see {@link whileOutputEffect} If you need to use an effectful predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileOutput: {\n  /**\n   * Returns a new schedule that continues execution for as long as the given\n   * predicate on the output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while a provided condition holds true for its output. If the\n   * predicate returns `false`, the schedule stops.\n   *\n   * @see {@link whileOutputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>\n  /**\n   * Returns a new schedule that continues execution for as long as the given\n   * predicate on the output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while a provided condition holds true for its output. If the\n   * predicate returns `false`, the schedule stops.\n   *\n   * @see {@link whileOutputEffect} If you need to use an effectful predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>\n} = internal.whileOutput\n\n/**\n * Returns a new schedule that continues execution for as long as the given\n * effectful predicate on the output evaluates to `true`.\n *\n * **Details**\n *\n * This function modifies an existing schedule so that it only continues\n * execution while an effectful condition holds true for its output. If the\n * effectful predicate returns `false`, the schedule stops.\n *\n * @see {@link whileOutput} If you need to use a pure predicate.\n *\n * @since 2.0.0\n * @category Recurrence Conditions\n */\nexport const whileOutputEffect: {\n  /**\n   * Returns a new schedule that continues execution for as long as the given\n   * effectful predicate on the output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while an effectful condition holds true for its output. If the\n   * effectful predicate returns `false`, the schedule stops.\n   *\n   * @see {@link whileOutput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>\n  /**\n   * Returns a new schedule that continues execution for as long as the given\n   * effectful predicate on the output evaluates to `true`.\n   *\n   * **Details**\n   *\n   * This function modifies an existing schedule so that it only continues\n   * execution while an effectful condition holds true for its output. If the\n   * effectful predicate returns `false`, the schedule stops.\n   *\n   * @see {@link whileOutput} If you need to use a pure predicate.\n   *\n   * @since 2.0.0\n   * @category Recurrence Conditions\n   */\n  <Out, In, R, R2>(\n    self: Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<boolean, never, R2>\n  ): Schedule<Out, In, R | R2>\n} = internal.whileOutputEffect\n\n/**\n * Creates a schedule that divides time into fixed `interval`-long windows,\n * triggering execution at the start of each new window.\n *\n * **Details**\n *\n * This function produces a schedule that waits until the next time window\n * boundary before executing. Each window spans a fixed duration specified by\n * `interval`. If an action completes midway through a window, the schedule\n * waits until the next full window starts before proceeding.\n *\n * For example, `windowed(Duration.seconds(10))` would produce a schedule as\n * follows:\n *\n * ```text\n *      10s        10s        10s       10s\n * |----------|----------|----------|----------|\n * |action------|sleep---|act|-sleep|action----|\n * ```\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const windowed: (interval: Duration.DurationInput) => Schedule<number> = internal.windowed\n\n/**\n * The same as {@link intersect} but ignores the right output.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const zipLeft: {\n  /**\n   * The same as {@link intersect} but ignores the right output.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>\n  /**\n   * The same as {@link intersect} but ignores the right output.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>\n} = internal.zipLeft\n\n/**\n * The same as {@link intersect} but ignores the left output.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const zipRight: {\n  /**\n   * The same as {@link intersect} but ignores the left output.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>\n  /**\n   * The same as {@link intersect} but ignores the left output.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out2, In & In2, R | R2>\n} = internal.zipRight\n\n/**\n * Equivalent to {@link intersect} followed by {@link map}.\n *\n * @since 2.0.0\n * @category Composition\n */\nexport const zipWith: {\n  /**\n   * Equivalent to {@link intersect} followed by {@link map}.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>\n  /**\n   * Equivalent to {@link intersect} followed by {@link map}.\n   *\n   * @since 2.0.0\n   * @category Composition\n   */\n  <Out, In, R, Out2, In2, R2, Out3>(\n    self: Schedule<Out, In, R>,\n    that: Schedule<Out2, In2, R2>,\n    f: (out: Out, out2: Out2) => Out3\n  ): Schedule<Out3, In & In2, R | R2>\n} = internal.zipWith\n\n/**\n * @since 3.15.0\n * @category models\n */\nexport interface CurrentIterationMetadata {\n  readonly _: unique symbol\n}\n\n/**\n * @since 3.15.0\n * @category models\n */\nexport interface IterationMetadata {\n  readonly input: unknown\n  readonly output: unknown\n  readonly recurrence: number\n  readonly start: number\n  readonly now: number\n  readonly elapsed: Duration.Duration\n  readonly elapsedSincePrevious: Duration.Duration\n}\n\n/**\n * @since 3.15.0\n * @category models\n */\nexport const CurrentIterationMetadata: Context.Reference<\n  CurrentIterationMetadata,\n  IterationMetadata\n> = internal.CurrentIterationMetadata\n","import type { CommonColors, Direction, Theme, ThemeProviderProps } from \"@mui/material/styles\";\nimport type { PaletteColorKey, PaletteColorNoChannels } from \"./core/palette\";\nimport type { ThemeCssVariables } from \"./types\";\n\nexport type ThemeConfig = {\n  direction: Direction;\n  classesPrefix: string;\n  cssVariables: ThemeCssVariables;\n  defaultMode: ThemeProviderProps<Theme>[\"defaultMode\"];\n  modeStorageKey: ThemeProviderProps<Theme>[\"modeStorageKey\"];\n  fontFamily: Record<\"primary\" | \"secondary\", string>;\n  palette: Record<PaletteColorKey, PaletteColorNoChannels> & {\n    common: Pick<CommonColors, \"black\" | \"white\">;\n    grey: {\n      [K in 50 | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | 950 as `${K}`]: string;\n    };\n  };\n};\n\nexport const themeConfig: ThemeConfig = {\n  /** **************************************\n   * Base\n   *************************************** */\n  defaultMode: \"dark\",\n  modeStorageKey: \"theme-mode\",\n  direction: \"ltr\",\n  classesPrefix: \"minimal\",\n  /** **************************************\n   * Css variables\n   *************************************** */\n  cssVariables: {\n    cssVarPrefix: \"\",\n    colorSchemeSelector: \"data-color-scheme\",\n  },\n  /** **************************************\n   * Typography\n   *************************************** */\n  fontFamily: {\n    primary: \"Public Sans Variable\",\n    secondary: \"Barlow\",\n  },\n  /** **************************************\n   * Palette\n   *************************************** */\n  palette: {\n    primary: {\n      lighter: \"#C8FAD6\",\n      light: \"#5BE49B\",\n      main: \"#00A76F\",\n      dark: \"#007867\",\n      darker: \"#004B50\",\n      contrastText: \"#FFFFFF\",\n    },\n    secondary: {\n      lighter: \"#EFD6FF\",\n      light: \"#C684FF\",\n      main: \"#8E33FF\",\n      dark: \"#5119B7\",\n      darker: \"#27097A\",\n      contrastText: \"#FFFFFF\",\n    },\n    info: {\n      lighter: \"#CAFDF5\",\n      light: \"#61F3F3\",\n      main: \"#00B8D9\",\n      dark: \"#006C9C\",\n      darker: \"#003768\",\n      contrastText: \"#FFFFFF\",\n    },\n    success: {\n      lighter: \"#D3FCD2\",\n      light: \"#77ED8B\",\n      main: \"#22C55E\",\n      dark: \"#118D57\",\n      darker: \"#065E49\",\n      contrastText: \"#ffffff\",\n    },\n    warning: {\n      lighter: \"#FFF5CC\",\n      light: \"#FFD666\",\n      main: \"#FFAB00\",\n      dark: \"#B76E00\",\n      darker: \"#7A4100\",\n      contrastText: \"#1C252E\",\n    },\n    error: {\n      lighter: \"#FFE9D5\",\n      light: \"#FFAC82\",\n      main: \"#FF5630\",\n      dark: \"#B71D18\",\n      darker: \"#7A0916\",\n      contrastText: \"#FFFFFF\",\n    },\n    grey: {\n      50: \"#FCFDFD\",\n      100: \"#F9FAFB\",\n      200: \"#F4F6F8\",\n      300: \"#DFE3E8\",\n      400: \"#C4CDD5\",\n      500: \"#919EAB\",\n      600: \"#637381\",\n      700: \"#454F5B\",\n      800: \"#1C252E\",\n      900: \"#141A21\",\n      950: \"#06080A\",\n    },\n    common: {\n      black: \"#000000\",\n      white: \"#FFFFFF\",\n    },\n  },\n};\n","import { themeConfig } from \"./theme-config\";\n\nexport function createClasses(className: string): string {\n  return `${themeConfig.classesPrefix}__${className}`;\n}\n","'use client';\n\nimport * as React from 'react';\nfunction usePreviousProps(value) {\n  const ref = React.useRef({});\n  React.useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\nexport default usePreviousProps;"],"names":["internal","ScheduleTypeId","ScheduleDriverTypeId","makeWithState","isSchedule","addDelay","addDelayEffect","andThen","andThenEither","as","asVoid","bothInOut","check","checkEffect","collectAllInputs","collectAllOutputs","collectUntil","collectUntilEffect","collectWhile","collectWhileEffect","compose","mapInput","mapInputEffect","mapInputContext","count","cron","secondOfMinute","minuteOfHour","hourOfDay","dayOfMonth","dayOfWeek","delayed","delayedEffect","delayedSchedule","delays","mapBoth","mapBothEffect","driver","duration","either","eitherWith","elapsed","ensuring","exponential","fibonacci","fixed","forever","fromDelay","fromDelays","fromFunction","identity","passthrough","intersect","intersectWith","jittered","jitteredWith","linear","map","mapEffect","modifyDelay","modifyDelayEffect","onDecision","once","provideContext","provideService","recurUntil","recurUntilEffect","recurUntilOption","recurUpTo","recurWhile","recurWhileEffect","recurs","reduce","reduceEffect","repeatForever","repetitions","resetAfter","resetWhen","run","spaced","stop","succeed","sync","tapInput","tapOutput","unfold","union","unionWith","untilInput","untilInputEffect","untilOutput","untilOutputEffect","upTo","whileInput","whileInputEffect","whileOutput","whileOutputEffect","windowed","zipLeft","zipRight","zipWith","CurrentIterationMetadata"],"mappings":"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","ignoreList":[0,1,2,3,7]}