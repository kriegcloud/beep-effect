{"version":3,"sources":["turbopack:///[project]/node_modules/effect/src/Effectable.ts","turbopack:///[project]/node_modules/effect/src/Chunk.ts","turbopack:///[project]/node_modules/effect/src/internal/context.ts","turbopack:///[project]/node_modules/effect/src/Context.ts","turbopack:///[project]/node_modules/effect/src/Duration.ts","turbopack:///[project]/node_modules/effect/src/internal/stack.ts","turbopack:///[project]/node_modules/effect/src/internal/hashMap/node.ts","turbopack:///[project]/node_modules/effect/src/internal/hashSet.ts","turbopack:///[project]/node_modules/effect/src/internal/hashMap.ts","turbopack:///[project]/node_modules/effect/src/internal/hashMap/bitwise.ts","turbopack:///[project]/node_modules/effect/src/internal/hashMap/config.ts","turbopack:///[project]/node_modules/effect/src/internal/hashMap/array.ts","turbopack:///[project]/node_modules/effect/src/HashSet.ts","turbopack:///[project]/node_modules/effect/src/internal/runtimeFlagsPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/hashMap/keySet.ts","turbopack:///[project]/node_modules/effect/src/internal/data.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberId.ts","turbopack:///[project]/node_modules/effect/src/internal/runtimeFlags.ts","turbopack:///[project]/node_modules/effect/src/internal/differ.ts","turbopack:///[project]/node_modules/effect/src/internal/blockedRequests.ts","turbopack:///[project]/node_modules/effect/src/internal/differ/orPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/differ/chunkPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/differ/contextPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/differ/hashMapPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/differ/readonlyArrayPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/differ/hashSetPatch.ts","turbopack:///[project]/node_modules/effect/src/HashMap.ts","turbopack:///[project]/node_modules/effect/src/RuntimeFlagsPatch.ts","turbopack:///[project]/node_modules/effect/src/MutableRef.ts","turbopack:///[project]/node_modules/effect/src/FiberId.ts","turbopack:///[project]/node_modules/effect/src/List.ts","turbopack:///[project]/node_modules/effect/src/internal/cause.ts","turbopack:///[project]/node_modules/effect/src/internal/opCodes/cause.ts","turbopack:///[project]/node_modules/effect/src/internal/core.ts","turbopack:///[project]/node_modules/effect/src/internal/deferred.ts","turbopack:///[project]/node_modules/effect/src/internal/opCodes/deferred.ts","turbopack:///[project]/node_modules/effect/src/internal/singleShotGen.ts","turbopack:///[project]/node_modules/effect/src/Boolean.ts","turbopack:///[project]/node_modules/effect/src/internal/executionStrategy.ts","turbopack:///[project]/node_modules/effect/src/Readable.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberStatus.ts","turbopack:///[project]/node_modules/effect/src/LogLevel.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberRefs/patch.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberRefs.ts","turbopack:///[project]/node_modules/effect/src/internal/ref.ts","turbopack:///[project]/node_modules/effect/src/Scheduler.ts","turbopack:///[project]/node_modules/effect/src/FiberRefsPatch.ts","turbopack:///[project]/node_modules/effect/src/Ref.ts","turbopack:///[project]/node_modules/effect/src/FiberRefs.ts","turbopack:///[project]/node_modules/effect/src/FiberStatus.ts","turbopack:///[project]/node_modules/effect/src/ExecutionStrategy.ts","turbopack:///[project]/node_modules/effect/src/Micro.ts","turbopack:///[project]/node_modules/effect/src/internal/clock.ts","turbopack:///[project]/node_modules/effect/src/internal/completedRequestMap.ts","turbopack:///[project]/node_modules/effect/src/internal/concurrency.ts","turbopack:///[project]/node_modules/effect/src/RegExp.ts","turbopack:///[project]/node_modules/effect/src/internal/configError.ts","turbopack:///[project]/node_modules/effect/src/internal/opCodes/configError.ts","turbopack:///[project]/node_modules/effect/src/internal/opCodes/config.ts","turbopack:///[project]/node_modules/effect/src/internal/defaultServices/console.ts","turbopack:///[project]/node_modules/effect/src/internal/configProvider/pathPatch.ts","turbopack:///[project]/node_modules/effect/src/internal/random.ts","turbopack:///[project]/node_modules/effect/src/internal/configProvider.ts","turbopack:///[project]/node_modules/effect/src/internal/defaultServices.ts","turbopack:///[project]/node_modules/effect/src/internal/tracer.ts","turbopack:///[project]/node_modules/effect/src/internal/string-utils.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberRuntime.ts","turbopack:///[project]/node_modules/effect/src/Tracer.ts","turbopack:///[project]/node_modules/effect/src/internal/logger.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/boundaries.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/keyType.ts","turbopack:///[project]/node_modules/effect/src/internal/core-effect.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/key.ts","turbopack:///[project]/node_modules/effect/src/MutableHashMap.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/state.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/hook.ts","turbopack:///[project]/node_modules/effect/src/Exit.ts","turbopack:///[project]/node_modules/effect/src/internal/metric.ts","turbopack:///[project]/node_modules/effect/src/internal/redBlackTree/iterator.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/label.ts","turbopack:///[project]/node_modules/effect/src/internal/redBlackTree.ts","turbopack:///[project]/node_modules/effect/src/RedBlackTree.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberScope.ts","turbopack:///[project]/node_modules/effect/src/internal/fiber.ts","turbopack:///[project]/node_modules/effect/src/Clock.ts","turbopack:///[project]/node_modules/effect/src/Differ.ts","turbopack:///[project]/node_modules/effect/src/internal/supervisor/patch.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/pair.ts","turbopack:///[project]/node_modules/effect/src/internal/metric/registry.ts","turbopack:///[project]/node_modules/effect/src/internal/request.ts","turbopack:///[project]/node_modules/effect/src/internal/supervisor.ts","turbopack:///[project]/node_modules/effect/src/internal/redBlackTree/node.ts","turbopack:///[project]/node_modules/effect/src/internal/logSpan.ts","turbopack:///[project]/node_modules/effect/src/internal/fiberMessage.ts","turbopack:///[project]/node_modules/effect/src/SortedSet.ts","turbopack:///[project]/node_modules/effect/src/LogSpan.ts","turbopack:///[project]/node_modules/effect/src/Scope.ts","turbopack:///[project]/node_modules/effect/src/Cause.ts","turbopack:///[project]/node_modules/effect/src/internal/schedule/decision.ts","turbopack:///[project]/node_modules/effect/src/ScheduleInterval.ts","turbopack:///[project]/node_modules/effect/src/internal/schedule/intervals.ts","turbopack:///[project]/node_modules/effect/src/ScheduleIntervals.ts","turbopack:///[project]/node_modules/effect/src/internal/schedule/interval.ts","turbopack:///[project]/node_modules/effect/src/ScheduleDecision.ts","turbopack:///[project]/node_modules/effect/src/internal/layer.ts","turbopack:///[project]/node_modules/effect/src/internal/effect/circular.ts","turbopack:///[project]/node_modules/effect/src/Fiber.ts","turbopack:///[project]/node_modules/effect/src/internal/runtime.ts","turbopack:///[project]/node_modules/effect/src/internal/synchronizedRef.ts","turbopack:///[project]/node_modules/effect/src/internal/opCodes/layer.ts","turbopack:///[project]/node_modules/effect/src/internal/managedRuntime/circular.ts","turbopack:///[project]/node_modules/effect/src/Data.ts","turbopack:///[project]/node_modules/effect/src/internal/console.ts","turbopack:///[project]/node_modules/effect/src/Effect.ts","turbopack:///[project]/node_modules/effect/src/Cron.ts","turbopack:///[project]/node_modules/effect/src/MutableQueue.ts","turbopack:///[project]/node_modules/effect/src/internal/schedule.ts","turbopack:///[project]/node_modules/effect/src/internal/cache.ts","turbopack:///[project]/node_modules/effect/src/internal/executionPlan.ts","turbopack:///[project]/node_modules/effect/src/Request.ts","turbopack:///[project]/node_modules/effect/src/internal/dateTime.ts","turbopack:///[project]/node_modules/effect/src/MutableList.ts","turbopack:///[project]/node_modules/effect/src/internal/query.ts","turbopack:///[project]/node_modules/effect/src/Deferred.ts","turbopack:///[project]/node_modules/effect/src/Random.ts"],"sourcesContent":["/**\n * @since 2.0.0\n */\nimport type * as Channel from \"./Channel.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/effectable.js\"\nimport type * as Sink from \"./Sink.js\"\nimport type * as Stream from \"./Stream.js\"\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const EffectTypeId: Effect.EffectTypeId = internal.EffectTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type EffectTypeId = Effect.EffectTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const StreamTypeId: Stream.StreamTypeId = internal.StreamTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type StreamTypeId = Stream.StreamTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const SinkTypeId: Sink.SinkTypeId = internal.SinkTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type SinkTypeId = Sink.SinkTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const ChannelTypeId: Channel.ChannelTypeId = internal.ChannelTypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type ChannelTypeId = Channel.ChannelTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface CommitPrimitive {\n  new<A, E = never, R = never>(): Effect.Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category prototypes\n */\nexport const EffectPrototype: Effect.Effect<never> = internal.EffectPrototype\n\n/**\n * @since 2.0.0\n * @category prototypes\n */\nexport const CommitPrototype: Effect.Effect<never> = internal.CommitPrototype\n\n/**\n * @since 2.0.0\n * @category prototypes\n */\nexport const StructuralCommitPrototype: Effect.Effect<never> = internal.StructuralCommitPrototype\n\nconst Base: CommitPrimitive = internal.Base\nconst StructuralBase: CommitPrimitive = internal.StructuralBase\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport abstract class Class<A, E = never, R = never> extends Base<A, E, R> {\n  /**\n   * @since 2.0.0\n   */\n  abstract commit(): Effect.Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport abstract class StructuralClass<A, E = never, R = never> extends StructuralBase<A, E, R> {\n  /**\n   * @since 2.0.0\n   */\n  abstract commit(): Effect.Effect<A, E, R>\n}\n","/**\n * @since 2.0.0\n */\nimport * as RA from \"./Array.js\"\nimport type { NonEmptyReadonlyArray } from \"./Array.js\"\nimport type { Either } from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport { dual, identity, pipe } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport type { NonEmptyIterable } from \"./NonEmptyIterable.js\"\nimport type { Option } from \"./Option.js\"\nimport * as O from \"./Option.js\"\nimport * as Order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"./Predicate.js\"\nimport type { Covariant, NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/Chunk\") as TypeId\n\n/**\n * @category symbol\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Chunk<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  readonly length: number\n  /** @internal */\n  right: Chunk<A>\n  /** @internal */\n  left: Chunk<A>\n  /** @internal */\n  backing: Backing<A>\n  /** @internal */\n  depth: number\n}\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport interface NonEmptyChunk<out A> extends Chunk<A>, NonEmptyIterable<A> {}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ChunkTypeLambda extends TypeLambda {\n  readonly type: Chunk<this[\"Target\"]>\n}\n\ntype Backing<A> =\n  | IArray<A>\n  | IConcat<A>\n  | ISingleton<A>\n  | IEmpty\n  | ISlice<A>\n\ninterface IArray<A> {\n  readonly _tag: \"IArray\"\n  readonly array: ReadonlyArray<A>\n}\n\ninterface IConcat<A> {\n  readonly _tag: \"IConcat\"\n  readonly left: Chunk<A>\n  readonly right: Chunk<A>\n}\n\ninterface ISingleton<A> {\n  readonly _tag: \"ISingleton\"\n  readonly a: A\n}\n\ninterface IEmpty {\n  readonly _tag: \"IEmpty\"\n}\n\ninterface ISlice<A> {\n  readonly _tag: \"ISlice\"\n  readonly chunk: Chunk<A>\n  readonly offset: number\n  readonly length: number\n}\n\nfunction copy<A>(\n  src: ReadonlyArray<A>,\n  srcPos: number,\n  dest: Array<A>,\n  destPos: number,\n  len: number\n) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i]!\n  }\n  return dest\n}\n\nconst emptyArray: ReadonlyArray<never> = []\n\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A>(isEquivalent: Equivalence.Equivalence<A>): Equivalence.Equivalence<Chunk<A>> =>\n  Equivalence.make((self, that) =>\n    self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet(that, i)))\n  )\n\nconst _equivalence = getEquivalence(Equal.equals)\n\nconst ChunkProto: Omit<Chunk<unknown>, \"backing\" | \"depth\" | \"left\" | \"length\" | \"right\"> = {\n  [TypeId]: {\n    _A: (_: never) => _\n  },\n  toString<A>(this: Chunk<A>) {\n    return format(this.toJSON())\n  },\n  toJSON<A>(this: Chunk<A>) {\n    return {\n      _id: \"Chunk\",\n      values: toReadonlyArray(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]<A>(this: Chunk<A>) {\n    return this.toJSON()\n  },\n  [Equal.symbol]<A>(this: Chunk<A>, that: unknown): boolean {\n    return isChunk(that) && _equivalence(this, that)\n  },\n  [Hash.symbol]<A>(this: Chunk<A>): number {\n    return Hash.cached(this, Hash.array(toReadonlyArray(this)))\n  },\n  [Symbol.iterator]<A>(this: Chunk<A>): Iterator<A> {\n    switch (this.backing._tag) {\n      case \"IArray\": {\n        return this.backing.array[Symbol.iterator]()\n      }\n      case \"IEmpty\": {\n        return emptyArray[Symbol.iterator]()\n      }\n      default: {\n        return toReadonlyArray(this)[Symbol.iterator]()\n      }\n    }\n  },\n  pipe<A>(this: Chunk<A>) {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeChunk = <A>(backing: Backing<A>): Chunk<A> => {\n  const chunk = Object.create(ChunkProto)\n  chunk.backing = backing\n  switch (backing._tag) {\n    case \"IEmpty\": {\n      chunk.length = 0\n      chunk.depth = 0\n      chunk.left = chunk\n      chunk.right = chunk\n      break\n    }\n    case \"IConcat\": {\n      chunk.length = backing.left.length + backing.right.length\n      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth)\n      chunk.left = backing.left\n      chunk.right = backing.right\n      break\n    }\n    case \"IArray\": {\n      chunk.length = backing.array.length\n      chunk.depth = 0\n      chunk.left = _empty\n      chunk.right = _empty\n      break\n    }\n    case \"ISingleton\": {\n      chunk.length = 1\n      chunk.depth = 0\n      chunk.left = _empty\n      chunk.right = _empty\n      break\n    }\n    case \"ISlice\": {\n      chunk.length = backing.length\n      chunk.depth = backing.chunk.depth + 1\n      chunk.left = _empty\n      chunk.right = _empty\n      break\n    }\n  }\n  return chunk\n}\n\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const isChunk: {\n  /**\n   * Checks if `u` is a `Chunk<unknown>`\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(u: Iterable<A>): u is Chunk<A>\n  /**\n   * Checks if `u` is a `Chunk<unknown>`\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  (u: unknown): u is Chunk<unknown>\n} = (u: unknown): u is Chunk<unknown> => hasProperty(u, TypeId)\n\nconst _empty = makeChunk<never>({ _tag: \"IEmpty\" })\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty: <A = never>() => Chunk<A> = () => _empty\n\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As): NonEmptyChunk<As[number]> =>\n  unsafeFromNonEmptyArray(as)\n\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = <A>(a: A): NonEmptyChunk<A> => makeChunk({ _tag: \"ISingleton\", a }) as any\n\n/**\n * Creates a new `Chunk` from an iterable collection of values.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(self: Iterable<A>): Chunk<A> =>\n  isChunk(self) ? self : unsafeFromArray(RA.fromIterable(self))\n\nconst copyToArray = <A>(self: Chunk<A>, array: Array<any>, initial: number): void => {\n  switch (self.backing._tag) {\n    case \"IArray\": {\n      copy(self.backing.array, 0, array, initial, self.length)\n      break\n    }\n    case \"IConcat\": {\n      copyToArray(self.left, array, initial)\n      copyToArray(self.right, array, initial + self.left.length)\n      break\n    }\n    case \"ISingleton\": {\n      array[initial] = self.backing.a\n      break\n    }\n    case \"ISlice\": {\n      let i = 0\n      let j = initial\n      while (i < self.length) {\n        array[j] = unsafeGet(self, i)\n        i += 1\n        j += 1\n      }\n      break\n    }\n  }\n}\n\nconst toArray_ = <A>(self: Chunk<A>): Array<A> => toReadonlyArray(self).slice()\n\n/**\n * Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n * (`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\n * non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray: <S extends Chunk<any>>(\n  self: S\n) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>> = toArray_ as any\n\nconst toReadonlyArray_ = <A>(self: Chunk<A>): ReadonlyArray<A> => {\n  switch (self.backing._tag) {\n    case \"IEmpty\": {\n      return emptyArray\n    }\n    case \"IArray\": {\n      return self.backing.array\n    }\n    default: {\n      const arr = new Array<A>(self.length)\n      copyToArray(self, arr, 0)\n      self.backing = {\n        _tag: \"IArray\",\n        array: arr\n      }\n      self.left = _empty\n      self.right = _empty\n      self.depth = 0\n      return arr\n    }\n  }\n}\n\n/**\n * Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\n * non-empty (`NonEmptyChunk`), the function will return a\n * `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toReadonlyArray: <S extends Chunk<any>>(\n  self: S\n) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>> =\n  toReadonlyArray_ as any\n\nconst reverseChunk = <A>(self: Chunk<A>): Chunk<A> => {\n  switch (self.backing._tag) {\n    case \"IEmpty\":\n    case \"ISingleton\":\n      return self\n    case \"IArray\": {\n      return makeChunk({ _tag: \"IArray\", array: RA.reverse(self.backing.array) })\n    }\n    case \"IConcat\": {\n      return makeChunk({ _tag: \"IConcat\", left: reverse(self.backing.right), right: reverse(self.backing.left) })\n    }\n    case \"ISlice\":\n      return unsafeFromArray(RA.reverse(toReadonlyArray(self)))\n  }\n}\n\n/**\n * Reverses the order of elements in a `Chunk`.\n * Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const chunk = Chunk.make(1, 2, 3)\n * const result = Chunk.reverse(chunk)\n *\n * console.log(result)\n * // { _id: 'Chunk', values: [ 3, 2, 1 ] }\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>> = reverseChunk as any\n\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const get: {\n  /**\n   * This function provides a safe way to read a value at a particular index from a `Chunk`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  (index: number): <A>(self: Chunk<A>) => Option<A>\n  /**\n   * This function provides a safe way to read a value at a particular index from a `Chunk`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, index: number): Option<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, index: number): Option<A> =>\n    index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index))\n)\n\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromArray = <A>(self: ReadonlyArray<A>): Chunk<A> =>\n  self.length === 0 ? empty() : self.length === 1 ? of(self[0]) : makeChunk({ _tag: \"IArray\", array: self })\n\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeFromNonEmptyArray = <A>(self: NonEmptyReadonlyArray<A>): NonEmptyChunk<A> =>\n  unsafeFromArray(self) as any\n\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Gets an element unsafely, will throw on out of bounds\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  (index: number): <A>(self: Chunk<A>) => A\n  /**\n   * Gets an element unsafely, will throw on out of bounds\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <A>(self: Chunk<A>, index: number): A\n} = dual(2, <A>(self: Chunk<A>, index: number): A => {\n  switch (self.backing._tag) {\n    case \"IEmpty\": {\n      throw new Error(`Index out of bounds`)\n    }\n    case \"ISingleton\": {\n      if (index !== 0) {\n        throw new Error(`Index out of bounds`)\n      }\n      return self.backing.a\n    }\n    case \"IArray\": {\n      if (index >= self.length || index < 0) {\n        throw new Error(`Index out of bounds`)\n      }\n      return self.backing.array[index]!\n    }\n    case \"IConcat\": {\n      return index < self.left.length\n        ? unsafeGet(self.left, index)\n        : unsafeGet(self.right, index - self.left.length)\n    }\n    case \"ISlice\": {\n      return unsafeGet(self.backing.chunk, index + self.backing.offset)\n    }\n  }\n})\n\n/**\n * Appends the specified element to the end of the `Chunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  /**\n   * Appends the specified element to the end of the `Chunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>\n  /**\n   * Appends the specified element to the end of the `Chunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>\n} = dual(2, <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2> => appendAll(self, of(a)))\n\n/**\n * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  /**\n   * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>\n  /**\n   * Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>\n} = dual(2, <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B> => appendAll(of(elem), self))\n\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const take: {\n  /**\n   * Takes the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Takes the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => {\n  if (n <= 0) {\n    return _empty\n  } else if (n >= self.length) {\n    return self\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\": {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self.backing.chunk,\n          length: n,\n          offset: self.backing.offset\n        })\n      }\n      case \"IConcat\": {\n        if (n > self.left.length) {\n          return makeChunk({\n            _tag: \"IConcat\",\n            left: self.left,\n            right: take(self.right, n - self.left.length)\n          })\n        }\n\n        return take(self.left, n)\n      }\n      default: {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self,\n          offset: 0,\n          length: n\n        })\n      }\n    }\n  }\n})\n\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 2.0.0\n */\nexport const drop: {\n  /**\n   * Drops the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Drops the first up to `n` elements from the chunk\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => {\n  if (n <= 0) {\n    return self\n  } else if (n >= self.length) {\n    return _empty\n  } else {\n    switch (self.backing._tag) {\n      case \"ISlice\": {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self.backing.chunk,\n          offset: self.backing.offset + n,\n          length: self.backing.length - n\n        })\n      }\n      case \"IConcat\": {\n        if (n > self.left.length) {\n          return drop(self.right, n - self.left.length)\n        }\n        return makeChunk({\n          _tag: \"IConcat\",\n          left: drop(self.left, n),\n          right: self.right\n        })\n      }\n      default: {\n        return makeChunk({\n          _tag: \"ISlice\",\n          chunk: self,\n          offset: n,\n          length: self.length - n\n        })\n      }\n    }\n  }\n})\n\n/**\n * Drops the last `n` elements.\n *\n * @since 2.0.0\n */\nexport const dropRight: {\n  /**\n   * Drops the last `n` elements.\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Drops the last `n` elements.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => take(self, Math.max(0, self.length - n)))\n\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n */\nexport const dropWhile: {\n  /**\n   * Drops all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Drops all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A> => {\n  const arr = toReadonlyArray(self)\n  const len = arr.length\n  let i = 0\n  while (i < len && predicate(arr[i]!)) {\n    i++\n  }\n  return drop(self, i)\n})\n\n/**\n * Prepends the specified prefix chunk to the beginning of the specified chunk.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n *\n * console.log(result)\n * // [ \"a\", \"b\", 1, 2 ]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Prepends the specified prefix chunk to the beginning of the specified chunk.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ \"a\", \"b\", 1, 2 ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>\n} = dual(2, <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): Chunk<A | B> => appendAll(that, self))\n\n/**\n * Concatenates two chunks, combining their elements.\n * If either chunk is non-empty, the result is also a non-empty chunk.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n *\n * console.log(result)\n * // [ 1, 2, \"a\", \"b\" ]\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>\n  /**\n   * Concatenates two chunks, combining their elements.\n   * If either chunk is non-empty, the result is also a non-empty chunk.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n   *\n   * console.log(result)\n   * // [ 1, 2, \"a\", \"b\" ]\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>\n} = dual(2, <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B> => {\n  if (self.backing._tag === \"IEmpty\") {\n    return that\n  }\n  if (that.backing._tag === \"IEmpty\") {\n    return self\n  }\n  const diff = that.depth - self.depth\n  if (Math.abs(diff) <= 1) {\n    return makeChunk</**\n     * Concatenates two chunks, combining their elements.\n     * If either chunk is non-empty, the result is also a non-empty chunk.\n     *\n     * **Example**\n     *\n     * ```ts\n     * import { Chunk } from \"effect\"\n     *\n     * const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make(\"a\", \"b\")), Chunk.toArray)\n     *\n     * console.log(result)\n     * // [ 1, 2, \"a\", \"b\" ]\n     * ```\n     *\n     * @category concatenating\n     * @since 2.0.0\n     */\n    A | B>({ _tag: \"IConcat\", left: self, right: that });\n  } else if (diff < -1) {\n    if (self.left.depth >= self.right.depth) {\n      const nr = appendAll(self.right, that)\n      return makeChunk({ _tag: \"IConcat\", left: self.left, right: nr })\n    } else {\n      const nrr = appendAll(self.right.right, that)\n      if (nrr.depth === self.depth - 3) {\n        const nr = makeChunk({ _tag: \"IConcat\", left: self.right.left, right: nrr })\n        return makeChunk({ _tag: \"IConcat\", left: self.left, right: nr })\n      } else {\n        const nl = makeChunk({ _tag: \"IConcat\", left: self.left, right: self.right.left })\n        return makeChunk({ _tag: \"IConcat\", left: nl, right: nrr })\n      }\n    }\n  } else {\n    if (that.right.depth >= that.left.depth) {\n      const nl = appendAll(self, that.left)\n      return makeChunk({ _tag: \"IConcat\", left: nl, right: that.right })\n    } else {\n      const nll = appendAll(self, that.left.left)\n      if (nll.depth === that.depth - 3) {\n        const nl = makeChunk({ _tag: \"IConcat\", left: nll, right: that.left.right })\n        return makeChunk({ _tag: \"IConcat\", left: nl, right: that.right })\n      } else {\n        const nr = makeChunk({ _tag: \"IConcat\", left: that.left.right, right: that.right })\n        return makeChunk({ _tag: \"IConcat\", left: nll, right: nr })\n      }\n    }\n  }\n})\n\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap: {\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B> => unsafeFromArray(RA.filterMap(self, f))\n)\n\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter: {\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>\n  /**\n   * Returns a filtered and mapped subset of the elements.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A> => unsafeFromArray(RA.filter(self, predicate))\n)\n\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMapWhile: {\n  /**\n   * Transforms all elements of the chunk for as long as the specified function returns some value\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Transforms all elements of the chunk for as long as the specified function returns some value\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A) => Option<B>) => unsafeFromArray(RA.filterMapWhile(self, f)))\n\n/**\n * Filter out optional values\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact = <A>(self: Chunk<Option<A>>): Chunk<A> => filterMap(self, identity)\n\n/**\n * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>\n  /**\n   * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>\n  /**\n   * Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a, 0)\n  }\n  let out: Chunk<B> = _empty\n  let i = 0\n  for (const k of self) {\n    out = appendAll(out, f(k, i++))\n  }\n  return out\n})\n\n/**\n * Iterates over each element of a `Chunk` and applies a function to it.\n *\n * **Details**\n *\n * This function processes every element of the given `Chunk`, calling the\n * provided function `f` on each element. It does not return a new value;\n * instead, it is primarily used for side effects, such as logging or\n * accumulating data in an external variable.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach: {\n  /**\n   * Iterates over each element of a `Chunk` and applies a function to it.\n   *\n   * **Details**\n   *\n   * This function processes every element of the given `Chunk`, calling the\n   * provided function `f` on each element. It does not return a new value;\n   * instead, it is primarily used for side effects, such as logging or\n   * accumulating data in an external variable.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void\n  /**\n   * Iterates over each element of a `Chunk` and applies a function to it.\n   *\n   * **Details**\n   *\n   * This function processes every element of the given `Chunk`, calling the\n   * provided function `f` on each element. It does not return a new value;\n   * instead, it is primarily used for side effects, such as logging or\n   * accumulating data in an external variable.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A) => B): void => toReadonlyArray(self).forEach(f))\n\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S> = flatMap(identity) as any\n\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const chunksOf: {\n  /**\n   * Groups elements in chunks of up to `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>\n  /**\n   * Groups elements in chunks of up to `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>\n} = dual(2, <A>(self: Chunk<A>, n: number) => {\n  const gr: Array<Chunk<A>> = []\n  let current: Array<A> = []\n  toReadonlyArray(self).forEach((a) => {\n    current.push(a)\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current))\n      current = []\n    }\n  })\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current))\n  }\n  return unsafeFromArray(gr)\n})\n\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const intersection: {\n  /**\n   * Creates a Chunk of unique values that are included in all given Chunks.\n   *\n   * The order and references of result values are determined by the Chunk.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>\n  /**\n   * Creates a Chunk of unique values that are included in all given Chunks.\n   *\n   * The order and references of result values are determined by the Chunk.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B> =>\n    unsafeFromArray(RA.intersection(toReadonlyArray(self), toReadonlyArray(that)))\n)\n\n/**\n * Determines if the chunk is empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty = <A>(self: Chunk<A>): boolean => self.length === 0\n\n/**\n * Determines if the chunk is not empty.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isNonEmpty = <A>(self: Chunk<A>): self is NonEmptyChunk<A> => self.length > 0\n\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const head: <A>(self: Chunk<A>) => Option<A> = get(0)\n\n/**\n * Returns the first element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = <A>(self: Chunk<A>): A => unsafeGet(self, 0)\n\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A = unsafeHead\n\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const last = <A>(self: Chunk<A>): Option<A> => get(self, self.length - 1)\n\n/**\n * Returns the last element of this chunk.\n *\n * It will throw an error if the chunk is empty.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = <A>(self: Chunk<A>): A => unsafeGet(self, self.length - 1)\n\n/**\n * Returns the last element of this non empty chunk.\n *\n * @since 3.4.0\n * @category elements\n */\nexport const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A = unsafeLast\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Chunk {\n  /**\n   * @since 2.0.0\n   */\n  export type Infer<S extends Chunk<any>> = S extends Chunk<infer A> ? A : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type With<S extends Chunk<any>, A> = S extends NonEmptyChunk<any> ? NonEmptyChunk<A> : Chunk<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type OrNonEmpty<S extends Chunk<any>, T extends Chunk<any>, A> = S extends NonEmptyChunk<any> ?\n    NonEmptyChunk<A>\n    : T extends NonEmptyChunk<any> ? NonEmptyChunk<A>\n    : Chunk<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type AndNonEmpty<S extends Chunk<any>, T extends Chunk<any>, A> = S extends NonEmptyChunk<any> ?\n    T extends NonEmptyChunk<any> ? NonEmptyChunk<A>\n    : Chunk<A> :\n    Chunk<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type Flatten<T extends Chunk<Chunk<any>>> = T extends NonEmptyChunk<NonEmptyChunk<infer A>> ? NonEmptyChunk<A>\n    : T extends Chunk<Chunk<infer A>> ? Chunk<A>\n    : never\n}\n\n/**\n * Transforms the elements of a chunk using the specified mapping function.\n * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n *\n * **Example**\n *\n * ```ts\n * import { Chunk } from \"effect\"\n *\n * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n *\n * console.log(result)\n * // { _id: 'Chunk', values: [ 2, 3 ] }\n * ```\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Transforms the elements of a chunk using the specified mapping function.\n   * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n   *\n   * console.log(result)\n   * // { _id: 'Chunk', values: [ 2, 3 ] }\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>\n  /**\n   * Transforms the elements of a chunk using the specified mapping function.\n   * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n   *\n   * console.log(result)\n   * // { _id: 'Chunk', values: [ 2, 3 ] }\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>\n  /**\n   * Transforms the elements of a chunk using the specified mapping function.\n   * If the input chunk is non-empty, the resulting chunk will also be non-empty.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Chunk } from \"effect\"\n   *\n   * const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n   *\n   * console.log(result)\n   * // { _id: 'Chunk', values: [ 2, 3 ] }\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>\n} = dual(2, <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B> =>\n  self.backing._tag === \"ISingleton\" ?\n    of(f(self.backing.a, 0)) :\n    unsafeFromArray(pipe(toReadonlyArray(self), RA.map((a, i) => f(a, i)))))\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum: {\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]\n  /**\n   * Statefully maps over the chunk, producing new elements of type `B`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]\n} = dual(3, <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>] => {\n  const [s1, as] = RA.mapAccum(self, s, f)\n  return [s1, unsafeFromArray(as)]\n})\n\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]\n  /**\n   * Separate elements based on a predicate that also exposes the index of the element.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]\n} = dual(\n  2,\n  <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>] =>\n    pipe(\n      RA.partition(toReadonlyArray(self), predicate),\n      ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]\n    )\n)\n\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  /**\n   * Partitions the elements of this chunk into two chunks using f.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]\n  /**\n   * Partitions the elements of this chunk into two chunks using f.\n   *\n   * @category filtering\n   * @since 2.0.0\n   */\n  <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]\n} = dual(2, <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>] =>\n  pipe(\n    RA.partitionMap(toReadonlyArray(self), f),\n    ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]\n  ))\n\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate = <A, B>(self: Chunk<Either<B, A>>): [Chunk<A>, Chunk<B>] =>\n  pipe(\n    RA.separate(toReadonlyArray(self)),\n    ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]\n  )\n\n/**\n * Retireves the size of the chunk\n *\n * @since 2.0.0\n * @category elements\n */\nexport const size = <A>(self: Chunk<A>): number => self.length\n\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 2.0.0\n * @category sorting\n */\nexport const sort: {\n  /**\n   * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n   *\n   * @since 2.0.0\n   * @category sorting\n   */\n  <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n   *\n   * @since 2.0.0\n   * @category sorting\n   */\n  <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>\n} = dual(\n  2,\n  <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A> => unsafeFromArray(RA.sort(toReadonlyArray(self), O))\n)\n\n/**\n * @since 2.0.0\n * @category sorting\n */\nexport const sortWith: {\n  /**\n   * @since 2.0.0\n   * @category sorting\n   */\n  <A, B>(f: (a: A) => B, order: Order.Order<B>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * @since 2.0.0\n   * @category sorting\n   */\n  <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order.Order<B>): Chunk<A>\n} = dual(\n  3,\n  <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order.Order<B>): Chunk<A> => sort(self, Order.mapInput(order, f))\n)\n\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const splitAt: {\n  /**\n   *  Returns two splits of this chunk at the specified index.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]\n  /**\n   *  Returns two splits of this chunk at the specified index.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]\n} = dual(2, <A>(self: Chunk<A>, n: number): [Chunk<A>, Chunk<A>] => [take(self, n), drop(self, n)])\n\n/**\n * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt: {\n  /**\n   * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]\n  /**\n   * Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\n   * The value of `n` must be `>= 1`.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]\n} = dual(2, <A>(self: NonEmptyChunk<A>, n: number): [Chunk<A>, Chunk<A>] => {\n  const _n = Math.max(1, Math.floor(n))\n  return _n >= self.length ?\n    [self, empty()] :\n    [take(self, _n), drop(self, _n)]\n})\n\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split: {\n  /**\n   * Splits this chunk into `n` equally sized chunks.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>\n  /**\n   * Splits this chunk into `n` equally sized chunks.\n   *\n   * @since 2.0.0\n   * @category splitting\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>\n} = dual(2, <A>(self: Chunk<A>, n: number) => chunksOf(self, Math.ceil(self.length / Math.floor(n))))\n\n/**\n * Splits this chunk on the first element that matches this predicate.\n * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere: {\n  /**\n   * Splits this chunk on the first element that matches this predicate.\n   * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]\n  /**\n   * Splits this chunk on the first element that matches this predicate.\n   * Returns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.\n   *\n   * @category splitting\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]\n} = dual(2, <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>] => {\n  let i = 0\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      break\n    } else {\n      i++\n    }\n  }\n  return splitAt(self, i)\n})\n\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tail = <A>(self: Chunk<A>): Option<Chunk<A>> => self.length > 0 ? O.some(drop(self, 1)) : O.none()\n\n/**\n * Returns every elements after the first.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const tailNonEmpty = <A>(self: NonEmptyChunk<A>): Chunk<A> => drop(self, 1)\n\n/**\n * Takes the last `n` elements.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeRight: {\n  /**\n   * Takes the last `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (n: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Takes the last `n` elements.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: Chunk<A>, n: number): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, n: number): Chunk<A> => drop(self, self.length - n))\n\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const takeWhile: {\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>\n  /**\n   * Takes all elements so long as the predicate returns true.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>\n} = dual(2, <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A> => {\n  const out: Array<A> = []\n  for (const a of toReadonlyArray(self)) {\n    if (predicate(a)) {\n      out.push(a)\n    } else {\n      break\n    }\n  }\n  return unsafeFromArray(out)\n})\n\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const union: {\n  /**\n   * Creates a Chunks of unique values, in order, from all given Chunks.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>\n  /**\n   * Creates a Chunks of unique values, in order, from all given Chunks.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, that: Chunk<B>) => unsafeFromArray(RA.union(toReadonlyArray(self), toReadonlyArray(that)))\n)\n\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const dedupe = <A>(self: Chunk<A>): Chunk<A> => unsafeFromArray(RA.dedupe(toReadonlyArray(self)))\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const dedupeAdjacent = <A>(self: Chunk<A>): Chunk<A> => unsafeFromArray(RA.dedupeAdjacent(self))\n\n/**\n * Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const unzip = <A, B>(self: Chunk<readonly [A, B]>): [Chunk<A>, Chunk<B>] => {\n  const [left, right] = RA.unzip(self)\n  return [unsafeFromArray(left), unsafeFromArray(right)]\n}\n\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith: {\n  /**\n   * Zips this chunk pointwise with the specified chunk using the specified combiner.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>\n  /**\n   * Zips this chunk pointwise with the specified chunk using the specified combiner.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>\n} = dual(\n  3,\n  <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C> =>\n    unsafeFromArray(RA.zipWith(self, that, f))\n)\n\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Zips this chunk pointwise with the specified chunk.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>\n  /**\n   * Zips this chunk pointwise with the specified chunk.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]> => zipWith(self, that, (a, b) => [a, b])\n)\n\n/**\n * Delete the element at the specified index, creating a new `Chunk`.\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * Delete the element at the specified index, creating a new `Chunk`.\n   *\n   * @since 2.0.0\n   */\n  (i: number): <A>(self: Chunk<A>) => Chunk<A>\n  /**\n   * Delete the element at the specified index, creating a new `Chunk`.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, i: number): Chunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, i: number): Chunk<A> => {\n    if (i < 0 || i >= self.length) return self\n    return unsafeFromArray(RA.remove(toReadonlyArray(self), i))\n  }\n)\n\n/**\n * @since 3.16.0\n */\nexport const removeOption: {\n  /**\n   * @since 3.16.0\n   */\n  (i: number): <A>(self: Chunk<A>) => Option<Chunk<A>>\n  /**\n   * @since 3.16.0\n   */\n  <A>(self: Chunk<A>, i: number): Option<Chunk<A>>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, i: number): Option<Chunk<A>> => {\n    if (i < 0 || i >= self.length) return O.none()\n    return O.some(unsafeFromArray(RA.remove(toReadonlyArray(self), i)))\n  }\n)\n\n/**\n * @since 2.0.0\n */\nexport const modifyOption: {\n  /**\n   * @since 2.0.0\n   */\n  <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Option<Chunk<A | B>>\n  /**\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>>\n} = dual(\n  3,\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>> => {\n    if (i < 0 || i >= self.length) return O.none()\n    return O.some(unsafeFromArray(RA.modify(toReadonlyArray(self), i, f)))\n  }\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Apply a function to the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>\n  /**\n   * Apply a function to the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>\n} = dual(\n  3,\n  <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B> => O.getOrElse(modifyOption(self, i, f), () => self)\n)\n\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const replace: {\n  /**\n   * Change the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>\n  /**\n   * Change the element at the specified index, creating a new `Chunk`,\n   * or returning the input if the index is out of bounds.\n   *\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>\n} = dual(3, <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A> => modify(self, i, () => b))\n\n/**\n * @since 2.0.0\n */\nexport const replaceOption: {\n  /**\n   * @since 2.0.0\n   */\n  <B>(i: number, b: B): <A>(self: Chunk<A>) => Option<Chunk<B | A>>\n  /**\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>>\n} = dual(3, <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>> => modifyOption(self, i, () => b))\n\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy: {\n  /**\n   * Return a Chunk of length n with element i initialized with f(i).\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>\n  /**\n   * Return a Chunk of length n with element i initialized with f(i).\n   *\n   * **Note**. `n` is normalized to an integer >= 1.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>\n} = dual(2, (n, f) => fromIterable(RA.makeBy(n, f)))\n\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start: number, end: number): NonEmptyChunk<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : of(start)\n\n// -------------------------------------------------------------------------------------\n// re-exports from ReadonlyArray\n// -------------------------------------------------------------------------------------\n\n/**\n * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  // -------------------------------------------------------------------------------------\n  // re-exports from ReadonlyArray\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(a: A): (self: Chunk<A>) => boolean\n  // -------------------------------------------------------------------------------------\n  // re-exports from ReadonlyArray\n  // -------------------------------------------------------------------------------------\n\n  /**\n   * Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, a: A): boolean\n} = RA.contains\n\n/**\n * Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith: <A>(\n  isEquivalent: (self: A, that: A) => boolean\n) => {\n  (a: A): (self: Chunk<A>) => boolean\n  (self: Chunk<A>, a: A): boolean\n} = RA.containsWith\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>\n} = RA.findFirst\n\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex: {\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>\n  /**\n   * Return the first index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>\n} = RA.findFirstIndex\n\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast: {\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>\n  /**\n   * Find the last element for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>\n} = RA.findLast\n\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex: {\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>\n  /**\n   * Return the last index for which a predicate holds.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>\n} = RA.findLastIndex\n\n/**\n * Check if a predicate holds true for every `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every: {\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>\n  /**\n   * Check if a predicate holds true for every `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B> =>\n    RA.fromIterable(self).every(refinement)\n)\n\n/**\n * Check if a predicate holds true for some `Chunk` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some: {\n  /**\n   * Check if a predicate holds true for some `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>\n  /**\n   * Check if a predicate holds true for some `Chunk` element.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A> => RA.fromIterable(self).some(predicate)\n)\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const join: {\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  (sep: string): (self: Chunk<string>) => string\n  /**\n   * Joins the elements together with \"sep\" in the middle.\n   *\n   * @category folding\n   * @since 2.0.0\n   */\n  (self: Chunk<string>, sep: string): string\n} = RA.join\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = RA.reduce\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight: {\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B\n  /**\n   * @category folding\n   * @since 2.0.0\n   */\n  <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = RA.reduceRight\n\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const differenceWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>\n  (self: Chunk<A>, that: Chunk<A>): Chunk<A>\n} => {\n  return dual(\n    2,\n    (self: Chunk<A>, that: Chunk<A>): Chunk<A> => unsafeFromArray(RA.differenceWith(isEquivalent)(that, self))\n  )\n}\n\n/**\n * Creates a `Chunk` of values not included in the other given `Chunk`.\n * The order and references of result values are determined by the first `Chunk`.\n *\n * @since 3.2.0\n */\nexport const difference: {\n  /**\n   * Creates a `Chunk` of values not included in the other given `Chunk`.\n   * The order and references of result values are determined by the first `Chunk`.\n   *\n   * @since 3.2.0\n   */\n  <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>\n  /**\n   * Creates a `Chunk` of values not included in the other given `Chunk`.\n   * The order and references of result values are determined by the first `Chunk`.\n   *\n   * @since 3.2.0\n   */\n  <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>\n} = dual(\n  2,\n  <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A> => unsafeFromArray(RA.difference(that, self))\n)\n","import type * as C from \"../Context.js\"\nimport * as Equal from \"../Equal.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport type * as O from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as STM from \"../STM.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport { EffectPrototype, effectVariance } from \"./effectable.js\"\nimport * as option from \"./option.js\"\n\n/** @internal */\nexport const TagTypeId: C.TagTypeId = Symbol.for(\"effect/Context/Tag\") as C.TagTypeId\n\n/** @internal */\nexport const ReferenceTypeId: C.ReferenceTypeId = Symbol.for(\"effect/Context/Reference\") as C.ReferenceTypeId\n\n/** @internal */\nconst STMSymbolKey = \"effect/STM\"\n\n/** @internal */\nexport const STMTypeId: STM.STMTypeId = Symbol.for(\n  STMSymbolKey\n) as STM.STMTypeId\n\n/** @internal */\nexport const TagProto: any = {\n  ...EffectPrototype,\n  _op: \"Tag\",\n  [STMTypeId]: effectVariance,\n  [TagTypeId]: {\n    _Service: (_: unknown) => _,\n    _Identifier: (_: unknown) => _\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON<I, A>(this: C.Tag<I, A>) {\n    return {\n      _id: \"Tag\",\n      key: this.key,\n      stack: this.stack\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  of<Service>(self: Service): Service {\n    return self\n  },\n  context<Identifier, Service>(\n    this: C.Tag<Identifier, Service>,\n    self: Service\n  ): C.Context<Identifier> {\n    return make(this, self)\n  }\n}\n\nexport const ReferenceProto: any = {\n  ...TagProto,\n  [ReferenceTypeId]: ReferenceTypeId\n}\n\n/** @internal */\nexport const makeGenericTag = <Identifier, Service = Identifier>(key: string): C.Tag<Identifier, Service> => {\n  const limit = Error.stackTraceLimit\n  Error.stackTraceLimit = 2\n  const creationError = new Error()\n  Error.stackTraceLimit = limit\n  const tag = Object.create(TagProto)\n  Object.defineProperty(tag, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n  tag.key = key\n  return tag\n}\n\n/** @internal */\nexport const Tag = <const Id extends string>(id: Id) => <Self, Shape>(): C.TagClass<Self, Id, Shape> => {\n  const limit = Error.stackTraceLimit\n  Error.stackTraceLimit = 2\n  const creationError = new Error()\n  Error.stackTraceLimit = limit\n\n  function TagClass() {}\n  Object.setPrototypeOf(TagClass, TagProto)\n  TagClass.key = id\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n  return TagClass as any\n}\n\n/** @internal */\nexport const Reference = <Self>() =>\n<const Id extends string, Service>(id: Id, options: {\n  readonly defaultValue: () => Service\n}): C.ReferenceClass<Self, Id, Service> => {\n  const limit = Error.stackTraceLimit\n  Error.stackTraceLimit = 2\n  const creationError = new Error()\n  Error.stackTraceLimit = limit\n\n  function ReferenceClass() {}\n  Object.setPrototypeOf(ReferenceClass, ReferenceProto)\n  ReferenceClass.key = id\n  ReferenceClass.defaultValue = options.defaultValue\n  Object.defineProperty(ReferenceClass, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n  return ReferenceClass as any\n}\n\n/** @internal */\nexport const TypeId: C.TypeId = Symbol.for(\"effect/Context\") as C.TypeId\n\n/** @internal */\nexport const ContextProto: Omit<C.Context<unknown>, \"unsafeMap\"> = {\n  [TypeId]: {\n    _Services: (_: unknown) => _\n  },\n  [Equal.symbol]<A>(this: C.Context<A>, that: unknown): boolean {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n    return false\n  },\n  [Hash.symbol]<A>(this: C.Context<A>): number {\n    return Hash.cached(this, Hash.number(this.unsafeMap.size))\n  },\n  pipe<A>(this: C.Context<A>) {\n    return pipeArguments(this, arguments)\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON<A>(this: C.Context<A>) {\n    return {\n      _id: \"Context\",\n      services: Array.from(this.unsafeMap).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return (this as any).toJSON()\n  }\n}\n\n/** @internal */\nexport const makeContext = <Services>(unsafeMap: Map<string, any>): C.Context<Services> => {\n  const context = Object.create(ContextProto)\n  context.unsafeMap = unsafeMap\n  return context\n}\n\nconst serviceNotFoundError = (tag: C.Tag<any, any>) => {\n  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : \"\"}`)\n  if (tag.stack) {\n    const lines = tag.stack.split(\"\\n\")\n    if (lines.length > 2) {\n      const afterAt = lines[2].match(/at (.*)/)\n      if (afterAt) {\n        error.message = error.message + ` (defined at ${afterAt[1]})`\n      }\n    }\n  }\n  if (error.stack) {\n    const lines = error.stack.split(\"\\n\")\n    lines.splice(1, 3)\n    error.stack = lines.join(\"\\n\")\n  }\n  return error\n}\n\n/** @internal */\nexport const isContext = (u: unknown): u is C.Context<never> => hasProperty(u, TypeId)\n\n/** @internal */\nexport const isTag = (u: unknown): u is C.Tag<any, any> => hasProperty(u, TagTypeId)\n\n/** @internal */\nexport const isReference = (u: unknown): u is C.Reference<any, any> => hasProperty(u, ReferenceTypeId)\n\nconst _empty = makeContext(new Map())\n\n/** @internal */\nexport const empty = (): C.Context<never> => _empty\n\n/** @internal */\nexport const make = <I, S>(tag: C.Tag<I, S>, service: NoInfer<S>): C.Context<I> =>\n  makeContext(new Map([[tag.key, service]]))\n\n/** @internal */\nexport const add = dual<\n  <I, S>(\n    tag: C.Tag<I, S>,\n    service: NoInfer<S>\n  ) => <Services>(\n    self: C.Context<Services>\n  ) => C.Context<Services | I>,\n  <Services, I, S>(\n    self: C.Context<Services>,\n    tag: C.Tag<I, S>,\n    service: NoInfer<S>\n  ) => C.Context<Services | I>\n>(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap)\n  map.set(tag.key, service)\n  return makeContext(map)\n})\n\nconst defaultValueCache = globalValue(\"effect/Context/defaultValueCache\", () => new Map<string, any>())\nconst getDefaultValue = (tag: C.Reference<any, any>) => {\n  if (defaultValueCache.has(tag.key)) {\n    return defaultValueCache.get(tag.key)\n  }\n  const value = tag.defaultValue()\n  defaultValueCache.set(tag.key, value)\n  return value\n}\n\n/** @internal */\nexport const unsafeGetReference = <Services, I, S>(self: C.Context<Services>, tag: C.Reference<I, S>): S => {\n  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag)\n}\n\n/** @internal */\nexport const unsafeGet = dual<\n  <S, I>(tag: C.Tag<I, S>) => <Services>(self: C.Context<Services>) => S,\n  <Services, S, I>(self: C.Context<Services>, tag: C.Tag<I, S>) => S\n>(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    if (ReferenceTypeId in tag) return getDefaultValue(tag as any)\n    throw serviceNotFoundError(tag)\n  }\n  return self.unsafeMap.get(tag.key)! as any\n})\n\n/** @internal */\nexport const get: {\n  <I, S>(tag: C.Reference<I, S>): <Services>(self: C.Context<Services>) => S\n  <Services, I extends Services, S>(tag: C.Tag<I, S>): (self: C.Context<Services>) => S\n  <Services, I, S>(self: C.Context<Services>, tag: C.Reference<I, S>): S\n  <Services, I extends Services, S>(self: C.Context<Services>, tag: C.Tag<I, S>): S\n} = unsafeGet as any\n\n/** @internal */\nexport const getOrElse = dual<\n  <S, I, B>(tag: C.Tag<I, S>, orElse: LazyArg<B>) => <Services>(self: C.Context<Services>) => S | B,\n  <Services, S, I, B>(self: C.Context<Services>, tag: C.Tag<I, S>, orElse: LazyArg<B>) => S | B\n>(3, (self, tag, orElse) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return isReference(tag) ? getDefaultValue(tag) : orElse()\n  }\n  return self.unsafeMap.get(tag.key)! as any\n})\n\n/** @internal */\nexport const getOption = dual<\n  <S, I>(tag: C.Tag<I, S>) => <Services>(self: C.Context<Services>) => O.Option<S>,\n  <Services, S, I>(self: C.Context<Services>, tag: C.Tag<I, S>) => O.Option<S>\n>(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag.key)) {\n    return isReference(tag) ? option.some(getDefaultValue(tag)) : option.none\n  }\n  return option.some(self.unsafeMap.get(tag.key)! as any)\n})\n\n/** @internal */\nexport const merge = dual<\n  <R1>(that: C.Context<R1>) => <Services>(self: C.Context<Services>) => C.Context<Services | R1>,\n  <Services, R1>(self: C.Context<Services>, that: C.Context<R1>) => C.Context<Services | R1>\n>(2, (self, that) => {\n  const map = new Map(self.unsafeMap)\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s)\n  }\n  return makeContext(map)\n})\n\n/** @internal */\nexport const mergeAll = <T extends Array<unknown>>(\n  ...ctxs: [...{ [K in keyof T]: C.Context<T[K]> }]\n): C.Context<T[number]> => {\n  const map = new Map()\n  for (const ctx of ctxs) {\n    for (const [tag, s] of ctx.unsafeMap) {\n      map.set(tag, s)\n    }\n  }\n  return makeContext(map)\n}\n\n/** @internal */\nexport const pick =\n  <Tags extends ReadonlyArray<C.Tag<any, any>>>(...tags: Tags) =>\n  <Services>(self: C.Context<Services>): C.Context<\n    Services & C.Tag.Identifier<Tags[number]>\n  > => {\n    const tagSet = new Set<string>(tags.map((_) => _.key))\n    const newEnv = new Map()\n    for (const [tag, s] of self.unsafeMap.entries()) {\n      if (tagSet.has(tag)) {\n        newEnv.set(tag, s)\n      }\n    }\n    return makeContext(newEnv)\n  }\n\n/** @internal */\nexport const omit =\n  <Tags extends ReadonlyArray<C.Tag<any, any>>>(...tags: Tags) =>\n  <Services>(self: C.Context<Services>): C.Context<\n    Exclude<Services, C.Tag.Identifier<Tags[number]>>\n  > => {\n    const newEnv = new Map(self.unsafeMap)\n    for (const tag of tags) {\n      newEnv.delete(tag.key)\n    }\n    return makeContext(newEnv)\n  }\n","/**\n * This module provides a data structure called `Context` that can be used for dependency injection in effectful\n * programs. It is essentially a table mapping `Tag`s to their implementations (called `Service`s), and can be used to\n * manage dependencies in a type-safe way. The `Context` data structure is essentially a way of providing access to a set\n * of related services that can be passed around as a single unit. This module provides functions to create, modify, and\n * query the contents of a `Context`, as well as a number of utility types for working with tags and services.\n *\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport type { Equal } from \"./Equal.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as internal from \"./internal/context.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const TagTypeId: unique symbol = internal.TagTypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TagTypeId = typeof TagTypeId\n\n/**\n * @since 3.5.9\n * @category models\n */\nexport interface Tag<in out Id, in out Value> extends Pipeable, Inspectable, ReadonlyTag<Id, Value> {\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Invariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  of(self: Value): Value\n  context(self: Value): Context<Id>\n  readonly stack?: string | undefined\n  readonly key: string\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: TagUnify<this>\n  [Unify.ignoreSymbol]?: TagUnifyIgnore\n}\n\n/**\n * @since 3.5.9\n * @category models\n */\nexport interface ReadonlyTag<in out Id, out Value> extends Pipeable, Inspectable, Effect.Effect<Value, never, Id> {\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Covariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  readonly stack?: string | undefined\n  readonly key: string\n}\n\n/**\n * @since 3.11.0\n * @category symbol\n */\nexport const ReferenceTypeId: unique symbol = internal.ReferenceTypeId\n\n/**\n * @since 3.11.0\n * @category symbol\n */\nexport type ReferenceTypeId = typeof ReferenceTypeId\n\n/**\n * @since 3.11.0\n * @category models\n */\nexport interface Reference<in out Id, in out Value> extends Pipeable, Inspectable {\n  readonly [ReferenceTypeId]: ReferenceTypeId\n  readonly defaultValue: () => Value\n\n  readonly _op: \"Tag\"\n  readonly Service: Value\n  readonly Identifier: Id\n  readonly [TagTypeId]: {\n    readonly _Service: Types.Invariant<Value>\n    readonly _Identifier: Types.Invariant<Id>\n  }\n  of(self: Value): Value\n  context(self: Value): Context<Id>\n  readonly stack?: string | undefined\n  readonly key: string\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: TagUnify<this>\n  [Unify.ignoreSymbol]?: TagUnifyIgnore\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface TagClassShape<Id, Shape> {\n  readonly [TagTypeId]: TagTypeId\n  readonly Type: Shape\n  readonly Id: Id\n}\n\n// TODO(4.0): move key narrowing to the Tag interface\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface TagClass<Self, Id extends string, Type> extends Tag<Self, Type> {\n  new(_: never): TagClassShape<Id, Type>\n  readonly key: Id\n}\n\n// TODO(4.0): move key narrowing to the Reference interface\n/**\n * @since 3.11.0\n * @category models\n */\nexport interface ReferenceClass<Self, Id extends string, Type> extends Reference<Self, Type> {\n  new(_: never): TagClassShape<Id, Type>\n  readonly key: Id\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface TagUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Tag?: () => Extract<A[Unify.typeSymbol], Tag<any, any>>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface TagUnifyIgnore {}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Tag {\n  /**\n   * @since 2.0.0\n   */\n  export type Service<T extends Tag<any, any> | TagClassShape<any, any>> = T extends Tag<any, any> ? T[\"Service\"]\n    : T extends TagClassShape<any, infer A> ? A\n    : never\n  /**\n   * @since 2.0.0\n   */\n  export type Identifier<T extends Tag<any, any> | TagClassShape<any, any>> = T extends Tag<any, any> ? T[\"Identifier\"]\n    : T extends TagClassShape<any, any> ? T\n    : never\n}\n\n/**\n * Creates a new `Tag` instance with an optional key parameter.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.GenericTag(\"PORT\").key === Context.GenericTag(\"PORT\").key, true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service> =\n  internal.makeGenericTag\n\nconst TypeId: unique symbol = internal.TypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type ValidTagsById<R> = R extends infer S ? Tag<S, any> : never\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Context<in Services> extends Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Services: Types.Contravariant<Services>\n  }\n  readonly unsafeMap: Map<string, any>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeMake: <Services>(unsafeMap: Map<string, any>) => Context<Services> = internal.makeContext\n\n/**\n * Checks if the provided argument is a `Context`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n * ```\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isContext: (input: unknown) => input is Context<never> = internal.isContext\n\n/**\n * Checks if the provided argument is a `Tag`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isTag(Context.GenericTag(\"Tag\")), true)\n * ```\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isTag: (input: unknown) => input is Tag<any, any> = internal.isTag\n\n/**\n * Checks if the provided argument is a `Reference`.\n *\n * @since 3.11.0\n * @category guards\n * @experimental\n */\nexport const isReference: (u: unknown) => u is Reference<any, any> = internal.isReference\n\n/**\n * Returns an empty `Context`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * assert.strictEqual(Context.isContext(Context.empty()), true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: () => Context<never> = internal.empty\n\n/**\n * Creates a new `Context` with a single service associated to the tag.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <I, S>(tag: Tag<I, S>, service: Types.NoInfer<S>) => Context<I> = internal.make\n\n/**\n * Adds a service to a given `Context`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, pipe } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = Context.make(Port, { PORT: 8080 })\n *\n * const Services = pipe(\n *   someContext,\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n */\nexport const add: {\n  /**\n   * Adds a service to a given `Context`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context, pipe } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const someContext = Context.make(Port, { PORT: 8080 })\n   *\n   * const Services = pipe(\n   *   someContext,\n   *   Context.add(Timeout, { TIMEOUT: 5000 })\n   * )\n   *\n   * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <I, S>(tag: Tag<I, S>, service: Types.NoInfer<S>): <Services>(self: Context<Services>) => Context<Services | I>\n  /**\n   * Adds a service to a given `Context`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context, pipe } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const someContext = Context.make(Port, { PORT: 8080 })\n   *\n   * const Services = pipe(\n   *   someContext,\n   *   Context.add(Timeout, { TIMEOUT: 5000 })\n   * )\n   *\n   * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <Services, I, S>(self: Context<Services>, tag: Tag<I, S>, service: Types.NoInfer<S>): Context<Services | I>\n} = internal.add\n\n/**\n * Get a service from the context that corresponds to the given tag.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get: {\n  /**\n   * Get a service from the context that corresponds to the given tag.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = pipe(\n   *   Context.make(Port, { PORT: 8080 }),\n   *   Context.add(Timeout, { TIMEOUT: 5000 })\n   * )\n   *\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S\n  /**\n   * Get a service from the context that corresponds to the given tag.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = pipe(\n   *   Context.make(Port, { PORT: 8080 }),\n   *   Context.add(Timeout, { TIMEOUT: 5000 })\n   * )\n   *\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <Services, I extends Services, S>(tag: Tag<I, S>): (self: Context<Services>) => S\n  /**\n   * Get a service from the context that corresponds to the given tag.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = pipe(\n   *   Context.make(Port, { PORT: 8080 }),\n   *   Context.add(Timeout, { TIMEOUT: 5000 })\n   * )\n   *\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S\n  /**\n   * Get a service from the context that corresponds to the given tag.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { pipe, Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = pipe(\n   *   Context.make(Port, { PORT: 8080 }),\n   *   Context.add(Timeout, { TIMEOUT: 5000 })\n   * )\n   *\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <Services, I extends Services, S>(self: Context<Services>, tag: Tag<I, S>): S\n} = internal.get\n\n/**\n * Get a service from the context that corresponds to the given tag, or\n * use the fallback value.\n *\n * @since 3.7.0\n * @category getters\n */\nexport const getOrElse: {\n  /**\n   * Get a service from the context that corresponds to the given tag, or\n   * use the fallback value.\n   *\n   * @since 3.7.0\n   * @category getters\n   */\n  <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B\n  /**\n   * Get a service from the context that corresponds to the given tag, or\n   * use the fallback value.\n   *\n   * @since 3.7.0\n   * @category getters\n   */\n  <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B\n} = internal.getOrElse\n\n/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n * assert.throws(() => Context.unsafeGet(Services, Timeout))\n * ```\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Get a service from the context that corresponds to the given tag.\n   * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n   *\n   * For a safer version see {@link getOption}.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = Context.make(Port, { PORT: 8080 })\n   *\n   * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n   * assert.throws(() => Context.unsafeGet(Services, Timeout))\n   * ```\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S\n  /**\n   * Get a service from the context that corresponds to the given tag.\n   * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n   *\n   * For a safer version see {@link getOption}.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = Context.make(Port, { PORT: 8080 })\n   *\n   * assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\n   * assert.throws(() => Context.unsafeGet(Services, Timeout))\n   * ```\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S\n} = internal.unsafeGet\n\n/**\n * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n * found, the `Option` object will be `None`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const Services = Context.make(Port, { PORT: 8080 })\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOption: {\n  /**\n   * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n   * found, the `Option` object will be `None`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context, Option } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = Context.make(Port, { PORT: 8080 })\n   *\n   * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n   * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>\n  /**\n   * Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\n   * found, the `Option` object will be `None`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context, Option } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const Services = Context.make(Port, { PORT: 8080 })\n   *\n   * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n   * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>\n} = internal.getOption\n\n/**\n * Merges two `Context`s, returning a new `Context` containing the services of both.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n *\n * const Services = Context.merge(firstContext, secondContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * ```\n *\n * @since 2.0.0\n */\nexport const merge: {\n  /**\n   * Merges two `Context`s, returning a new `Context` containing the services of both.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const firstContext = Context.make(Port, { PORT: 8080 })\n   * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n   *\n   * const Services = Context.merge(firstContext, secondContext)\n   *\n   * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>\n  /**\n   * Merges two `Context`s, returning a new `Context` containing the services of both.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Context } from \"effect\"\n   *\n   * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n   * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n   *\n   * const firstContext = Context.make(Port, { PORT: 8080 })\n   * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n   *\n   * const Services = Context.merge(firstContext, secondContext)\n   *\n   * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n   * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>\n} = internal.merge\n\n/**\n * Merges any number of `Context`s, returning a new `Context` containing the services of all.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n * const Host = Context.GenericTag<{ HOST: string }>(\"Host\")\n *\n * const firstContext = Context.make(Port, { PORT: 8080 })\n * const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n * const thirdContext = Context.make(Host, { HOST: \"localhost\" })\n *\n * const Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n *\n * assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\n * assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\n * assert.deepStrictEqual(Context.get(Services, Host), { HOST: \"localhost\" })\n * ```\n *\n * @since 3.12.0\n */\nexport const mergeAll: <T extends Array<unknown>>(\n  ...ctxs: [...{ [K in keyof T]: Context<T[K]> }]\n) => Context<T[number]> = internal.mergeAll\n\n/**\n * Returns a new `Context` that contains only the specified services.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { pipe, Context, Option } from \"effect\"\n *\n * const Port = Context.GenericTag<{ PORT: number }>(\"Port\")\n * const Timeout = Context.GenericTag<{ TIMEOUT: number }>(\"Timeout\")\n *\n * const someContext = pipe(\n *   Context.make(Port, { PORT: 8080 }),\n *   Context.add(Timeout, { TIMEOUT: 5000 })\n * )\n *\n * const Services = pipe(someContext, Context.pick(Port))\n *\n * assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\n * assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())\n * ```\n *\n * @since 2.0.0\n */\nexport const pick: <Tags extends ReadonlyArray<Tag<any, any>>>(\n  ...tags: Tags\n) => <Services>(self: Context<Services>) => Context<Services & Tag.Identifier<Tags[number]>> = internal.pick\n\n/**\n * @since 2.0.0\n */\nexport const omit: <Tags extends ReadonlyArray<Tag<any, any>>>(\n  ...tags: Tags\n) => <Services>(self: Context<Services>) => Context<Exclude<Services, Tag.Identifier<Tags[number]>>> = internal.omit\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, Layer } from \"effect\"\n *\n * class MyTag extends Context.Tag(\"MyTag\")<\n *  MyTag,\n *  { readonly myNum: number }\n * >() {\n *  static Live = Layer.succeed(this, { myNum: 108 })\n * }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Tag: <const Id extends string>(id: Id) => <Self, Shape>() => TagClass<Self, Id, Shape> = internal.Tag\n\n/**\n * Creates a context tag with a default value.\n *\n * **Details**\n *\n * `Context.Reference` allows you to create a tag that can hold a value. You can\n * provide a default value for the service, which will automatically be used\n * when the context is accessed, or override it with a custom implementation\n * when needed.\n *\n * **Example** (Declaring a Tag with a default value)\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Context, Effect } from \"effect\"\n *\n * class SpecialNumber extends Context.Reference<SpecialNumber>()(\n *   \"SpecialNumber\",\n *   { defaultValue: () => 2048 }\n * ) {}\n *\n * //       Effect<void, never, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const specialNumber = yield* SpecialNumber\n *   console.log(`The special number is ${specialNumber}`)\n * })\n *\n * // No need to provide the SpecialNumber implementation\n * Effect.runPromise(program)\n * // Output: The special number is 2048\n * ```\n *\n * **Example** (Overriding the default value)\n *\n * ```ts\n * import { Context, Effect } from \"effect\"\n *\n * class SpecialNumber extends Context.Reference<SpecialNumber>()(\n *   \"SpecialNumber\",\n *   { defaultValue: () => 2048 }\n * ) {}\n *\n * const program = Effect.gen(function* () {\n *   const specialNumber = yield* SpecialNumber\n *   console.log(`The special number is ${specialNumber}`)\n * })\n *\n * Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n * // Output: The special number is -1\n * ```\n *\n * @since 3.11.0\n * @category constructors\n * @experimental\n */\nexport const Reference: <Self>() => <const Id extends string, Service>(\n  id: Id,\n  options: { readonly defaultValue: () => Service }\n) => ReferenceClass<Self, Id, Service> = internal.Reference\n","/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\"\nimport type * as equivalence from \"./Equivalence.js\"\nimport { dual } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport { NodeInspectSymbol } from \"./Inspectable.js\"\nimport * as Option from \"./Option.js\"\nimport * as order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty, isBigInt, isNumber, isString } from \"./Predicate.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/Duration\")\n\nconst bigint0 = BigInt(0)\nconst bigint24 = BigInt(24)\nconst bigint60 = BigInt(60)\nconst bigint1e3 = BigInt(1_000)\nconst bigint1e6 = BigInt(1_000_000)\nconst bigint1e9 = BigInt(1_000_000_000)\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Duration extends Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly value: DurationValue\n}\n/**\n * @since 2.0.0\n * @category models\n */\nexport type DurationValue =\n  | {\n    readonly _tag: \"Millis\"\n    readonly millis: number\n  }\n  | {\n    readonly _tag: \"Nanos\"\n    readonly nanos: bigint\n  }\n  | {\n    readonly _tag: \"Infinity\"\n  }\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type Unit =\n  | \"nano\"\n  | \"nanos\"\n  | \"micro\"\n  | \"micros\"\n  | \"milli\"\n  | \"millis\"\n  | \"second\"\n  | \"seconds\"\n  | \"minute\"\n  | \"minutes\"\n  | \"hour\"\n  | \"hours\"\n  | \"day\"\n  | \"days\"\n  | \"week\"\n  | \"weeks\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type DurationInput =\n  | Duration\n  | number // millis\n  | bigint // nanos\n  | readonly [seconds: number, nanos: number]\n  | `${number} ${Unit}`\n\nconst DURATION_REGEX = /^(-?\\d+(?:\\.\\d+)?)\\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/\n\n/**\n * @since 2.0.0\n */\nexport const decode = (input: DurationInput): Duration => {\n  if (isDuration(input)) {\n    return input\n  } else if (isNumber(input)) {\n    return millis(input)\n  } else if (isBigInt(input)) {\n    return nanos(input)\n  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {\n    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {\n      return zero\n    }\n\n    if (input[0] === Infinity || input[1] === Infinity) {\n      return infinity\n    }\n\n    return nanos(BigInt(Math.round(input[0] * 1_000_000_000)) + BigInt(Math.round(input[1])))\n  } else if (isString(input)) {\n    const match = DURATION_REGEX.exec(input)\n    if (match) {\n      const [_, valueStr, unit] = match\n      const value = Number(valueStr)\n      switch (unit) {\n        case \"nano\":\n        case \"nanos\":\n          return nanos(BigInt(valueStr))\n        case \"micro\":\n        case \"micros\":\n          return micros(BigInt(valueStr))\n        case \"milli\":\n        case \"millis\":\n          return millis(value)\n        case \"second\":\n        case \"seconds\":\n          return seconds(value)\n        case \"minute\":\n        case \"minutes\":\n          return minutes(value)\n        case \"hour\":\n        case \"hours\":\n          return hours(value)\n        case \"day\":\n        case \"days\":\n          return days(value)\n        case \"week\":\n        case \"weeks\":\n          return weeks(value)\n      }\n    }\n  }\n  throw new Error(\"Invalid DurationInput\")\n}\n\n/**\n * @since 2.5.0\n */\nexport const decodeUnknown: (u: unknown) => Option.Option<Duration> = Option.liftThrowable(decode) as any\n\nconst zeroValue: DurationValue = { _tag: \"Millis\", millis: 0 }\nconst infinityValue: DurationValue = { _tag: \"Infinity\" }\n\nconst DurationProto: Omit<Duration, \"value\"> = {\n  [TypeId]: TypeId,\n  [Hash.symbol](this: Duration) {\n    return Hash.cached(this, Hash.structure(this.value))\n  },\n  [Equal.symbol](this: Duration, that: unknown): boolean {\n    return isDuration(that) && equals(this, that)\n  },\n  toString(this: Duration) {\n    return `Duration(${format(this)})`\n  },\n  toJSON(this: Duration) {\n    switch (this.value._tag) {\n      case \"Millis\":\n        return { _id: \"Duration\", _tag: \"Millis\", millis: this.value.millis }\n      case \"Nanos\":\n        return { _id: \"Duration\", _tag: \"Nanos\", hrtime: toHrTime(this) }\n      case \"Infinity\":\n        return { _id: \"Duration\", _tag: \"Infinity\" }\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n} as const\n\nconst make = (input: number | bigint): Duration => {\n  const duration = Object.create(DurationProto)\n  if (isNumber(input)) {\n    if (isNaN(input) || input <= 0) {\n      duration.value = zeroValue\n    } else if (!Number.isFinite(input)) {\n      duration.value = infinityValue\n    } else if (!Number.isInteger(input)) {\n      duration.value = { _tag: \"Nanos\", nanos: BigInt(Math.round(input * 1_000_000)) }\n    } else {\n      duration.value = { _tag: \"Millis\", millis: input }\n    }\n  } else if (input <= bigint0) {\n    duration.value = zeroValue\n  } else {\n    duration.value = { _tag: \"Nanos\", nanos: input }\n  }\n  return duration\n}\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isDuration = (u: unknown): u is Duration => hasProperty(u, TypeId)\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isFinite = (self: Duration): boolean => self.value._tag !== \"Infinity\"\n\n/**\n * @since 3.5.0\n * @category guards\n */\nexport const isZero = (self: Duration): boolean => {\n  switch (self.value._tag) {\n    case \"Millis\": {\n      return self.value.millis === 0\n    }\n    case \"Nanos\": {\n      return self.value.nanos === bigint0\n    }\n    case \"Infinity\": {\n      return false\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const zero: Duration = make(0)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const infinity: Duration = make(Infinity)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const nanos = (nanos: bigint): Duration => make(nanos)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const micros = (micros: bigint): Duration => make(micros * bigint1e3)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const millis = (millis: number): Duration => make(millis)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const seconds = (seconds: number): Duration => make(seconds * 1000)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const minutes = (minutes: number): Duration => make(minutes * 60_000)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const hours = (hours: number): Duration => make(hours * 3_600_000)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const days = (days: number): Duration => make(days * 86_400_000)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const weeks = (weeks: number): Duration => make(weeks * 604_800_000)\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const toMillis = (self: DurationInput): number =>\n  match(self, {\n    onMillis: (millis) => millis,\n    onNanos: (nanos) => Number(nanos) / 1_000_000\n  })\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const toSeconds = (self: DurationInput): number =>\n  match(self, {\n    onMillis: (millis) => millis / 1_000,\n    onNanos: (nanos) => Number(nanos) / 1_000_000_000\n  })\n\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toMinutes = (self: DurationInput): number =>\n  match(self, {\n    onMillis: (millis) => millis / 60_000,\n    onNanos: (nanos) => Number(nanos) / 60_000_000_000\n  })\n\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toHours = (self: DurationInput): number =>\n  match(self, {\n    onMillis: (millis) => millis / 3_600_000,\n    onNanos: (nanos) => Number(nanos) / 3_600_000_000_000\n  })\n\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toDays = (self: DurationInput): number =>\n  match(self, {\n    onMillis: (millis) => millis / 86_400_000,\n    onNanos: (nanos) => Number(nanos) / 86_400_000_000_000\n  })\n\n/**\n * @since 3.8.0\n * @category getters\n */\nexport const toWeeks = (self: DurationInput): number =>\n  match(self, {\n    onMillis: (millis) => millis / 604_800_000,\n    onNanos: (nanos) => Number(nanos) / 604_800_000_000_000\n  })\n\n/**\n * Get the duration in nanoseconds as a bigint.\n *\n * If the duration is infinite, returns `Option.none()`\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toNanos = (self: DurationInput): Option.Option<bigint> => {\n  const _self = decode(self)\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return Option.none()\n    case \"Nanos\":\n      return Option.some(_self.value.nanos)\n    case \"Millis\":\n      return Option.some(BigInt(Math.round(_self.value.millis * 1_000_000)))\n  }\n}\n\n/**\n * Get the duration in nanoseconds as a bigint.\n *\n * If the duration is infinite, it throws an error.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const unsafeToNanos = (self: DurationInput): bigint => {\n  const _self = decode(self)\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      throw new Error(\"Cannot convert infinite duration to nanos\")\n    case \"Nanos\":\n      return _self.value.nanos\n    case \"Millis\":\n      return BigInt(Math.round(_self.value.millis * 1_000_000))\n  }\n}\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const toHrTime = (self: DurationInput): [seconds: number, nanos: number] => {\n  const _self = decode(self)\n  switch (_self.value._tag) {\n    case \"Infinity\":\n      return [Infinity, 0]\n    case \"Nanos\":\n      return [\n        Number(_self.value.nanos / bigint1e9),\n        Number(_self.value.nanos % bigint1e9)\n      ]\n    case \"Millis\":\n      return [\n        Math.floor(_self.value.millis / 1000),\n        Math.round((_self.value.millis % 1000) * 1_000_000)\n      ]\n  }\n}\n\n/**\n * @since 2.0.0\n * @category pattern matching\n */\nexport const match: {\n  /**\n   * @since 2.0.0\n   * @category pattern matching\n   */\n  <A, B>(\n    options: {\n      readonly onMillis: (millis: number) => A\n      readonly onNanos: (nanos: bigint) => B\n    }\n  ): (self: DurationInput) => A | B\n  /**\n   * @since 2.0.0\n   * @category pattern matching\n   */\n  <A, B>(\n    self: DurationInput,\n    options: {\n      readonly onMillis: (millis: number) => A\n      readonly onNanos: (nanos: bigint) => B\n    }\n  ): A | B\n} = dual(2, <A, B>(\n  self: DurationInput,\n  options: {\n    readonly onMillis: (millis: number) => A\n    readonly onNanos: (nanos: bigint) => B\n  }\n): A | B => {\n  const _self = decode(self)\n  switch (_self.value._tag) {\n    case \"Nanos\":\n      return options.onNanos(_self.value.nanos)\n    case \"Infinity\":\n      return options.onMillis(Infinity)\n    case \"Millis\":\n      return options.onMillis(_self.value.millis)\n  }\n})\n\n/**\n * @since 2.0.0\n * @category pattern matching\n */\nexport const matchWith: {\n  /**\n   * @since 2.0.0\n   * @category pattern matching\n   */\n  <A, B>(\n    that: DurationInput,\n    options: {\n      readonly onMillis: (self: number, that: number) => A\n      readonly onNanos: (self: bigint, that: bigint) => B\n    }\n  ): (self: DurationInput) => A | B\n  /**\n   * @since 2.0.0\n   * @category pattern matching\n   */\n  <A, B>(\n    self: DurationInput,\n    that: DurationInput,\n    options: {\n      readonly onMillis: (self: number, that: number) => A\n      readonly onNanos: (self: bigint, that: bigint) => B\n    }\n  ): A | B\n} = dual(3, <A, B>(\n  self: DurationInput,\n  that: DurationInput,\n  options: {\n    readonly onMillis: (self: number, that: number) => A\n    readonly onNanos: (self: bigint, that: bigint) => B\n  }\n): A | B => {\n  const _self = decode(self)\n  const _that = decode(that)\n  if (_self.value._tag === \"Infinity\" || _that.value._tag === \"Infinity\") {\n    return options.onMillis(\n      toMillis(_self),\n      toMillis(_that)\n    )\n  } else if (_self.value._tag === \"Nanos\" || _that.value._tag === \"Nanos\") {\n    const selfNanos = _self.value._tag === \"Nanos\" ?\n      _self.value.nanos :\n      BigInt(Math.round(_self.value.millis * 1_000_000))\n    const thatNanos = _that.value._tag === \"Nanos\" ?\n      _that.value.nanos :\n      BigInt(Math.round(_that.value.millis * 1_000_000))\n    return options.onNanos(selfNanos, thatNanos)\n  }\n\n  return options.onMillis(\n    _self.value.millis,\n    _that.value.millis\n  )\n})\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order: order.Order<Duration> = order.make((self, that) =>\n  matchWith(self, that, {\n    onMillis: (self, that) => (self < that ? -1 : self > that ? 1 : 0),\n    onNanos: (self, that) => (self < that ? -1 : self > that ? 1 : 0)\n  })\n)\n\n/**\n * Checks if a `Duration` is between a `minimum` and `maximum` value.\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const between: {\n  /**\n   * Checks if a `Duration` is between a `minimum` and `maximum` value.\n   *\n   * @category predicates\n   * @since 2.0.0\n   */\n  (\n    options: {\n      minimum: DurationInput\n      maximum: DurationInput\n    }\n  ): (self: DurationInput) => boolean\n  /**\n   * Checks if a `Duration` is between a `minimum` and `maximum` value.\n   *\n   * @category predicates\n   * @since 2.0.0\n   */\n  (\n    self: DurationInput,\n    options: {\n      minimum: DurationInput\n      maximum: DurationInput\n    }\n  ): boolean\n} = order.between(order.mapInput(Order, decode))\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence: equivalence.Equivalence<Duration> = (self, that) =>\n  matchWith(self, that, {\n    onMillis: (self, that) => self === that,\n    onNanos: (self, that) => self === that\n  })\n\nconst _min = order.min(Order)\n\n/**\n * @since 2.0.0\n */\nexport const min: {\n  /**\n   * @since 2.0.0\n   */\n  (that: DurationInput): (self: DurationInput) => Duration\n  /**\n   * @since 2.0.0\n   */\n  (self: DurationInput, that: DurationInput): Duration\n} = dual(2, (self: DurationInput, that: DurationInput): Duration => _min(decode(self), decode(that)))\n\nconst _max = order.max(Order)\n\n/**\n * @since 2.0.0\n * @category order\n */\nexport const max: {\n  /**\n   * @since 2.0.0\n   * @category order\n   */\n  (that: DurationInput): (self: DurationInput) => Duration\n  /**\n   * @since 2.0.0\n   * @category order\n   */\n  (self: DurationInput, that: DurationInput): Duration\n} = dual(2, (self: DurationInput, that: DurationInput): Duration => _max(decode(self), decode(that)))\n\nconst _clamp = order.clamp(Order)\n\n/**\n * @since 2.0.0\n * @category order\n */\nexport const clamp: {\n  /**\n   * @since 2.0.0\n   * @category order\n   */\n  (\n    options: {\n      minimum: DurationInput\n      maximum: DurationInput\n    }\n  ): (self: DurationInput) => Duration\n  /**\n   * @since 2.0.0\n   * @category order\n   */\n  (\n    self: DurationInput,\n    options: {\n      minimum: DurationInput\n      maximum: DurationInput\n    }\n  ): Duration\n} = dual(\n  2,\n  (self: DurationInput, options: {\n    minimum: DurationInput\n    maximum: DurationInput\n  }): Duration =>\n    _clamp(decode(self), {\n      minimum: decode(options.minimum),\n      maximum: decode(options.maximum)\n    })\n)\n\n/**\n * @since 2.4.19\n * @category math\n */\nexport const divide: {\n  /**\n   * @since 2.4.19\n   * @category math\n   */\n  (by: number): (self: DurationInput) => Option.Option<Duration>\n  /**\n   * @since 2.4.19\n   * @category math\n   */\n  (self: DurationInput, by: number): Option.Option<Duration>\n} = dual(\n  2,\n  (self: DurationInput, by: number): Option.Option<Duration> =>\n    match(self, {\n      onMillis: (millis) => {\n        if (by === 0 || isNaN(by) || !Number.isFinite(by)) {\n          return Option.none()\n        }\n        return Option.some(make(millis / by))\n      },\n      onNanos: (nanos) => {\n        if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {\n          return Option.none()\n        }\n        try {\n          return Option.some(make(nanos / BigInt(by)))\n        } catch {\n          return Option.none()\n        }\n      }\n    })\n)\n\n/**\n * @since 2.4.19\n * @category math\n */\nexport const unsafeDivide: {\n  /**\n   * @since 2.4.19\n   * @category math\n   */\n  (by: number): (self: DurationInput) => Duration\n  /**\n   * @since 2.4.19\n   * @category math\n   */\n  (self: DurationInput, by: number): Duration\n} = dual(\n  2,\n  (self: DurationInput, by: number): Duration =>\n    match(self, {\n      onMillis: (millis) => make(millis / by),\n      onNanos: (nanos) => {\n        if (isNaN(by) || by < 0 || Object.is(by, -0)) {\n          return zero\n        } else if (Object.is(by, 0) || !Number.isFinite(by)) {\n          return infinity\n        }\n        return make(nanos / BigInt(by))\n      }\n    })\n)\n\n/**\n * @since 2.0.0\n * @category math\n */\nexport const times: {\n  /**\n   * @since 2.0.0\n   * @category math\n   */\n  (times: number): (self: DurationInput) => Duration\n  /**\n   * @since 2.0.0\n   * @category math\n   */\n  (self: DurationInput, times: number): Duration\n} = dual(\n  2,\n  (self: DurationInput, times: number): Duration =>\n    match(self, {\n      onMillis: (millis) => make(millis * times),\n      onNanos: (nanos) => make(nanos * BigInt(times))\n    })\n)\n\n/**\n * @since 2.0.0\n * @category math\n */\nexport const subtract: {\n  /**\n   * @since 2.0.0\n   * @category math\n   */\n  (that: DurationInput): (self: DurationInput) => Duration\n  /**\n   * @since 2.0.0\n   * @category math\n   */\n  (self: DurationInput, that: DurationInput): Duration\n} = dual(\n  2,\n  (self: DurationInput, that: DurationInput): Duration =>\n    matchWith(self, that, {\n      onMillis: (self, that) => make(self - that),\n      onNanos: (self, that) => make(self - that)\n    })\n)\n\n/**\n * @since 2.0.0\n * @category math\n */\nexport const sum: {\n  /**\n   * @since 2.0.0\n   * @category math\n   */\n  (that: DurationInput): (self: DurationInput) => Duration\n  /**\n   * @since 2.0.0\n   * @category math\n   */\n  (self: DurationInput, that: DurationInput): Duration\n} = dual(\n  2,\n  (self: DurationInput, that: DurationInput): Duration =>\n    matchWith(self, that, {\n      onMillis: (self, that) => make(self + that),\n      onNanos: (self, that) => make(self + that)\n    })\n)\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const lessThan: {\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (that: DurationInput): (self: DurationInput) => boolean\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (self: DurationInput, that: DurationInput): boolean\n} = dual(\n  2,\n  (self: DurationInput, that: DurationInput): boolean =>\n    matchWith(self, that, {\n      onMillis: (self, that) => self < that,\n      onNanos: (self, that) => self < that\n    })\n)\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const lessThanOrEqualTo: {\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (that: DurationInput): (self: DurationInput) => boolean\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (self: DurationInput, that: DurationInput): boolean\n} = dual(\n  2,\n  (self: DurationInput, that: DurationInput): boolean =>\n    matchWith(self, that, {\n      onMillis: (self, that) => self <= that,\n      onNanos: (self, that) => self <= that\n    })\n)\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const greaterThan: {\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (that: DurationInput): (self: DurationInput) => boolean\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (self: DurationInput, that: DurationInput): boolean\n} = dual(\n  2,\n  (self: DurationInput, that: DurationInput): boolean =>\n    matchWith(self, that, {\n      onMillis: (self, that) => self > that,\n      onNanos: (self, that) => self > that\n    })\n)\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const greaterThanOrEqualTo: {\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (that: DurationInput): (self: DurationInput) => boolean\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (self: DurationInput, that: DurationInput): boolean\n} = dual(\n  2,\n  (self: DurationInput, that: DurationInput): boolean =>\n    matchWith(self, that, {\n      onMillis: (self, that) => self >= that,\n      onNanos: (self, that) => self >= that\n    })\n)\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const equals: {\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (that: DurationInput): (self: DurationInput) => boolean\n  /**\n   * @since 2.0.0\n   * @category predicates\n   */\n  (self: DurationInput, that: DurationInput): boolean\n} = dual(2, (self: DurationInput, that: DurationInput): boolean => Equivalence(decode(self), decode(that)))\n\n/**\n * Converts a `Duration` to its parts.\n *\n * @since 3.8.0\n * @category conversions\n */\nexport const parts = (self: DurationInput): {\n  days: number\n  hours: number\n  minutes: number\n  seconds: number\n  millis: number\n  nanos: number\n} => {\n  const duration = decode(self)\n  if (duration.value._tag === \"Infinity\") {\n    return {\n      days: Infinity,\n      hours: Infinity,\n      minutes: Infinity,\n      seconds: Infinity,\n      millis: Infinity,\n      nanos: Infinity\n    }\n  }\n\n  const nanos = unsafeToNanos(duration)\n  const ms = nanos / bigint1e6\n  const sec = ms / bigint1e3\n  const min = sec / bigint60\n  const hr = min / bigint60\n  const days = hr / bigint24\n\n  return {\n    days: Number(days),\n    hours: Number(hr % bigint24),\n    minutes: Number(min % bigint60),\n    seconds: Number(sec % bigint60),\n    millis: Number(ms % bigint1e3),\n    nanos: Number(nanos % bigint1e6)\n  }\n}\n\n/**\n * Converts a `Duration` to a human readable string.\n *\n * @since 2.0.0\n * @category conversions\n * @example\n * ```ts\n * import { Duration } from \"effect\"\n *\n * Duration.format(Duration.millis(1000)) // \"1s\"\n * Duration.format(Duration.millis(1001)) // \"1s 1ms\"\n * ```\n */\nexport const format = (self: DurationInput): string => {\n  const duration = decode(self)\n  if (duration.value._tag === \"Infinity\") {\n    return \"Infinity\"\n  }\n  if (isZero(duration)) {\n    return \"0\"\n  }\n\n  const fragments = parts(duration)\n  const pieces = []\n  if (fragments.days !== 0) {\n    pieces.push(`${fragments.days}d`)\n  }\n\n  if (fragments.hours !== 0) {\n    pieces.push(`${fragments.hours}h`)\n  }\n\n  if (fragments.minutes !== 0) {\n    pieces.push(`${fragments.minutes}m`)\n  }\n\n  if (fragments.seconds !== 0) {\n    pieces.push(`${fragments.seconds}s`)\n  }\n\n  if (fragments.millis !== 0) {\n    pieces.push(`${fragments.millis}ms`)\n  }\n\n  if (fragments.nanos !== 0) {\n    pieces.push(`${fragments.nanos}ns`)\n  }\n\n  return pieces.join(\" \")\n}\n\n/**\n * Formats a Duration into an ISO8601 duration string.\n *\n * Months are assumed to be 30 days and years are assumed to be 365 days.\n *\n * Milliseconds and nanoseconds are expressed as fractional seconds.\n *\n * @example\n * ```ts\n * import { Duration } from \"effect\"\n *\n * Duration.unsafeFormatIso(Duration.days(1)) // => \"P1D\"\n * Duration.unsafeFormatIso(Duration.minutes(90)) // => \"PT1H30M\"\n * Duration.unsafeFormatIso(Duration.millis(1500)) // => \"PT1.5S\"\n * ```\n *\n * @throws `RangeError` If the duration is not finite.\n *\n * @since 3.13.0\n * @category conversions\n */\nexport const unsafeFormatIso = (self: DurationInput): string => {\n  const duration = decode(self)\n  if (!isFinite(duration)) {\n    throw new RangeError(\"Cannot format infinite duration\")\n  }\n\n  const fragments = []\n  const {\n    days,\n    hours,\n    millis,\n    minutes,\n    nanos,\n    seconds\n  } = parts(duration)\n\n  let rest = days\n  if (rest >= 365) {\n    const years = Math.floor(rest / 365)\n    rest %= 365\n    fragments.push(`${years}Y`)\n  }\n\n  if (rest >= 30) {\n    const months = Math.floor(rest / 30)\n    rest %= 30\n    fragments.push(`${months}M`)\n  }\n\n  if (rest >= 7) {\n    const weeks = Math.floor(rest / 7)\n    rest %= 7\n    fragments.push(`${weeks}W`)\n  }\n\n  if (rest > 0) {\n    fragments.push(`${rest}D`)\n  }\n\n  if (hours !== 0 || minutes !== 0 || seconds !== 0 || millis !== 0 || nanos !== 0) {\n    fragments.push(\"T\")\n\n    if (hours !== 0) {\n      fragments.push(`${hours}H`)\n    }\n\n    if (minutes !== 0) {\n      fragments.push(`${minutes}M`)\n    }\n\n    if (seconds !== 0 || millis !== 0 || nanos !== 0) {\n      const total = BigInt(seconds) * bigint1e9 + BigInt(millis) * bigint1e6 + BigInt(nanos)\n      const str = (Number(total) / 1e9).toFixed(9).replace(/\\.?0+$/, \"\")\n      fragments.push(`${str}S`)\n    }\n  }\n\n  return `P${fragments.join(\"\") || \"T0S\"}`\n}\n\n/**\n * Formats a Duration into an ISO8601 duration string.\n *\n * Months are assumed to be 30 days and years are assumed to be 365 days.\n *\n * Returns `Option.none()` if the duration is infinite.\n *\n * @example\n * ```ts\n * import { Duration, Option } from \"effect\"\n *\n * Duration.formatIso(Duration.days(1)) // => Option.some(\"P1D\")\n * Duration.formatIso(Duration.minutes(90)) // => Option.some(\"PT1H30M\")\n * Duration.formatIso(Duration.millis(1500)) // => Option.some(\"PT1.5S\")\n * Duration.formatIso(Duration.infinity) // => Option.none()\n * ```\n *\n * @since 3.13.0\n * @category conversions\n */\nexport const formatIso = (self: DurationInput): Option.Option<string> => {\n  const duration = decode(self)\n  return isFinite(duration) ? Option.some(unsafeFormatIso(duration)) : Option.none()\n}\n\n/**\n * Parses an ISO8601 duration string into a `Duration`.\n *\n * Months are assumed to be 30 days and years are assumed to be 365 days.\n *\n * @example\n * ```ts\n * import { Duration, Option } from \"effect\"\n *\n * Duration.fromIso(\"P1D\") // => Option.some(Duration.days(1))\n * Duration.fromIso(\"PT1H\") // => Option.some(Duration.hours(1))\n * Duration.fromIso(\"PT1M\") // => Option.some(Duration.minutes(1))\n * Duration.fromIso(\"PT1.5S\") // => Option.some(Duration.seconds(1.5))\n * ```\n *\n * @since 3.13.0\n * @category conversions\n */\nexport const fromIso = (iso: string): Option.Option<Duration> => {\n  const result = DURATION_ISO_REGEX.exec(iso)\n  if (result == null) {\n    return Option.none()\n  }\n\n  const [years, months, weeks, days, hours, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0)\n  const value = years * 365 * 24 * 60 * 60 +\n    months * 30 * 24 * 60 * 60 +\n    weeks * 7 * 24 * 60 * 60 +\n    days * 24 * 60 * 60 +\n    hours * 60 * 60 +\n    mins * 60 +\n    secs\n\n  return Option.some(seconds(value))\n}\n\nconst DURATION_ISO_REGEX =\n  /^P(?!$)(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?(?:T(?!$)(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$/\n","/** @internal */\nexport interface Stack<out A> {\n  readonly value: A\n  readonly previous: Stack<A> | undefined\n}\n\nexport const make = <A>(value: A, previous?: Stack<A>): Stack<A> => ({\n  value,\n  previous\n})\n","import { equals } from \"../../Equal.js\"\nimport type { HashMap } from \"../../HashMap.js\"\nimport * as O from \"../../Option.js\"\nimport { isTagged } from \"../../Predicate.js\"\nimport * as Stack from \"../stack.js\"\nimport { arraySpliceIn, arraySpliceOut, arrayUpdate } from \"./array.js\"\nimport { fromBitmap, hashFragment, toBitmap } from \"./bitwise.js\"\nimport { MAX_INDEX_NODE, MIN_ARRAY_NODE, SIZE } from \"./config.js\"\n\n/** @internal */\nexport type Node<K, V> =\n  | EmptyNode<K, V>\n  | LeafNode<K, V>\n  | CollisionNode<K, V>\n  | IndexedNode<K, V>\n  | ArrayNode<K, V>\n\n/** @internal */\nexport interface SizeRef {\n  value: number // mutable by design\n}\n\n/** @internal */\nexport class EmptyNode<out K, out V> {\n  readonly _tag = \"EmptyNode\"\n\n  modify(\n    edit: number,\n    _shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    const v = f(O.none())\n    if (O.isNone(v)) return new EmptyNode()\n    ++size.value\n    return new LeafNode(edit, hash, key, v)\n  }\n}\n\n/** @internal */\nexport function isEmptyNode(a: unknown): a is EmptyNode<unknown, unknown> {\n  return isTagged(a, \"EmptyNode\")\n}\n\n/** @internal */\nexport function isLeafNode<K, V>(\n  node: Node<K, V>\n): node is EmptyNode<K, V> | LeafNode<K, V> | CollisionNode<K, V> {\n  return isEmptyNode(node) || node._tag === \"LeafNode\" || node._tag === \"CollisionNode\"\n}\n\n/** @internal */\nexport function canEditNode<K, V>(node: Node<K, V>, edit: number): boolean {\n  return isEmptyNode(node) ? false : edit === node.edit\n}\n\n/** @internal */\nexport class LeafNode<out K, out V> {\n  readonly _tag = \"LeafNode\"\n\n  constructor(\n    readonly edit: number,\n    readonly hash: number,\n    readonly key: K,\n    public value: O.Option<V>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    if (equals(key, this.key)) {\n      const v = f(this.value)\n      if (v === this.value) return this\n      else if (O.isNone(v)) {\n        --size.value\n        return new EmptyNode()\n      }\n      if (canEditNode(this, edit)) {\n        this.value = v\n        return this\n      }\n      return new LeafNode(edit, hash, key, v)\n    }\n    const v = f(O.none())\n    if (O.isNone(v)) return this\n    ++size.value\n    return mergeLeaves(\n      edit,\n      shift,\n      this.hash,\n      this,\n      hash,\n      new LeafNode(edit, hash, key, v)\n    )\n  }\n}\n\n/** @internal */\nexport class CollisionNode<out K, out V> {\n  readonly _tag = \"CollisionNode\"\n\n  constructor(\n    readonly edit: number,\n    readonly hash: number,\n    readonly children: Array<Node<K, V>>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    if (hash === this.hash) {\n      const canEdit = canEditNode(this, edit)\n      const list = this.updateCollisionList(\n        canEdit,\n        edit,\n        this.hash,\n        this.children,\n        f,\n        key,\n        size\n      )\n      if (list === this.children) return this\n\n      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]! // collapse single element collision list\n    }\n    const v = f(O.none())\n    if (O.isNone(v)) return this\n    ++size.value\n    return mergeLeaves(\n      edit,\n      shift,\n      this.hash,\n      this,\n      hash,\n      new LeafNode(edit, hash, key, v)\n    )\n  }\n\n  updateCollisionList(\n    mutate: boolean,\n    edit: number,\n    hash: number,\n    list: Array<Node<K, V>>,\n    f: HashMap.UpdateFn<V>,\n    key: K,\n    size: SizeRef\n  ) {\n    const len = list.length\n    for (let i = 0; i < len; ++i) {\n      const child = list[i]!\n      if (\"key\" in child && equals(key, child.key)) {\n        const value = child.value\n        const newValue = f(value)\n        if (newValue === value) return list\n        if (O.isNone(newValue)) {\n          --size.value\n          return arraySpliceOut(mutate, i, list)\n        }\n        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list)\n      }\n    }\n\n    const newValue = f(O.none())\n    if (O.isNone(newValue)) return list\n    ++size.value\n    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list)\n  }\n}\n\n/** @internal */\nexport class IndexedNode<out K, out V> {\n  readonly _tag = \"IndexedNode\"\n\n  constructor(\n    readonly edit: number,\n    public mask: number,\n    public children: Array<Node<K, V>>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    const mask = this.mask\n    const children = this.children\n    const frag = hashFragment(shift, hash)\n    const bit = toBitmap(frag)\n    const indx = fromBitmap(mask, bit)\n    const exists = mask & bit\n    const canEdit = canEditNode(this, edit)\n\n    if (!exists) {\n      const _newChild = new EmptyNode<K, V>().modify(edit, shift + SIZE, f, hash, key, size)\n      if (!_newChild) return this\n      return children.length >= MAX_INDEX_NODE ?\n        expand(edit, frag, _newChild, mask, children) :\n        new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children))\n    }\n\n    const current = children[indx]!\n    const child = current.modify(edit, shift + SIZE, f, hash, key, size)\n\n    if (current === child) return this\n    let bitmap = mask\n    let newChildren\n    if (isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit\n      if (!bitmap) return new EmptyNode()\n      if (children.length <= 2 && isLeafNode(children[indx ^ 1]!)) {\n        return children[indx ^ 1]! // collapse\n      }\n\n      newChildren = arraySpliceOut(canEdit, indx, children)\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children)\n    }\n\n    if (canEdit) {\n      this.mask = bitmap\n      this.children = newChildren\n      return this\n    }\n\n    return new IndexedNode(edit, bitmap, newChildren)\n  }\n}\n\n/** @internal */\nexport class ArrayNode<out K, out V> {\n  readonly _tag = \"ArrayNode\"\n\n  constructor(\n    readonly edit: number,\n    public size: number,\n    public children: Array<Node<K, V>>\n  ) {}\n\n  modify(\n    edit: number,\n    shift: number,\n    f: HashMap.UpdateFn<V>,\n    hash: number,\n    key: K,\n    size: SizeRef\n  ): Node<K, V> {\n    let count = this.size\n    const children = this.children\n    const frag = hashFragment(shift, hash)\n    const child = children[frag]\n    const newChild = (child || new EmptyNode<K, V>()).modify(\n      edit,\n      shift + SIZE,\n      f,\n      hash,\n      key,\n      size\n    )\n\n    if (child === newChild) return this\n\n    const canEdit = canEditNode(this, edit)\n    let newChildren\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ++count\n      newChildren = arrayUpdate(canEdit, frag, newChild, children)\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      --count\n      if (count <= MIN_ARRAY_NODE) {\n        return pack(edit, count, frag, children)\n      }\n      newChildren = arrayUpdate(canEdit, frag, new EmptyNode<K, V>(), children)\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children)\n    }\n\n    if (canEdit) {\n      this.size = count\n      this.children = newChildren\n      return this\n    }\n    return new ArrayNode(edit, count, newChildren)\n  }\n}\n\nfunction pack<K, V>(\n  edit: number,\n  count: number,\n  removed: number,\n  elements: Array<Node<K, V>>\n) {\n  const children = new Array<Node<K, V>>(count - 1)\n  let g = 0\n  let bitmap = 0\n  for (let i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      const elem = elements[i]\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem\n        bitmap |= 1 << i\n      }\n    }\n  }\n  return new IndexedNode(edit, bitmap, children)\n}\n\nfunction expand<K, V>(\n  edit: number,\n  frag: number,\n  child: Node<K, V>,\n  bitmap: number,\n  subNodes: Array<Node<K, V>>\n) {\n  const arr = []\n  let bit = bitmap\n  let count = 0\n  for (let i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++]!\n    bit >>>= 1\n  }\n  arr[frag] = child\n  return new ArrayNode(edit, count + 1, arr)\n}\n\nfunction mergeLeavesInner<K, V>(\n  edit: number,\n  shift: number,\n  h1: number,\n  n1: Node<K, V>,\n  h2: number,\n  n2: Node<K, V>\n): Node<K, V> | ((child: Node<K, V>) => Node<K, V>) {\n  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1])\n  const subH1 = hashFragment(shift, h1)\n  const subH2 = hashFragment(shift, h2)\n\n  if (subH1 === subH2) {\n    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child])\n  } else {\n    const children = subH1 < subH2 ? [n1, n2] : [n2, n1]\n    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children)\n  }\n}\n\nfunction mergeLeaves<K, V>(\n  edit: number,\n  shift: number,\n  h1: number,\n  n1: Node<K, V>,\n  h2: number,\n  n2: Node<K, V>\n): Node<K, V> {\n  let stack: Stack.Stack<(node: Node<K, V>) => Node<K, V>> | undefined = undefined\n  let currentShift = shift\n\n  while (true) {\n    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2)\n\n    if (typeof res === \"function\") {\n      stack = Stack.make(res, stack)\n      currentShift = currentShift + SIZE\n    } else {\n      let final = res\n      while (stack != null) {\n        final = stack.value(final)\n        stack = stack.previous\n      }\n      return final\n    }\n  }\n}\n","import * as Equal from \"../Equal.js\"\nimport { dual } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport type { HashMap } from \"../HashMap.js\"\nimport type * as HS from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type { Predicate, Refinement } from \"../Predicate.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport * as HM from \"./hashMap.js\"\n\nconst HashSetSymbolKey = \"effect/HashSet\"\n\n/** @internal */\nexport const HashSetTypeId: HS.TypeId = Symbol.for(HashSetSymbolKey) as HS.TypeId\n\n/** @internal */\nexport interface HashSetImpl<out A> extends HS.HashSet<A> {\n  readonly _keyMap: HashMap<A, unknown>\n}\n\nconst HashSetProto: Omit<HashSetImpl<unknown>, \"_keyMap\"> = {\n  [HashSetTypeId]: HashSetTypeId,\n  [Symbol.iterator]<A>(this: HashSetImpl<A>): Iterator<A> {\n    return HM.keys(this._keyMap)\n  },\n  [Hash.symbol]<A>(this: HashSetImpl<A>): number {\n    return Hash.cached(\n      this,\n      Hash.combine(Hash.hash(this._keyMap))(Hash.hash(HashSetSymbolKey))\n    )\n  },\n  [Equal.symbol]<A>(this: HashSetImpl<A>, that: unknown): boolean {\n    if (isHashSet(that)) {\n      return (\n        HM.size(this._keyMap) === HM.size((that as HashSetImpl<A>)._keyMap) &&\n        Equal.equals(this._keyMap, (that as HashSetImpl<A>)._keyMap)\n      )\n    }\n    return false\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"HashSet\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const makeImpl = <A>(keyMap: HashMap<A, unknown>): HashSetImpl<A> => {\n  const set = Object.create(HashSetProto)\n  set._keyMap = keyMap\n  return set\n}\n\n/** @internal */\nexport const isHashSet: {\n  <A>(u: Iterable<A>): u is HS.HashSet<A>\n  (u: unknown): u is HS.HashSet<unknown>\n} = (u: unknown): u is HS.HashSet<unknown> => hasProperty(u, HashSetTypeId)\n\nconst _empty = makeImpl<never>(HM.empty())\n\n/** @internal */\nexport const empty = <A = never>(): HS.HashSet<A> => _empty\n\n/** @internal */\nexport const fromIterable = <A>(elements: Iterable<A>): HS.HashSet<A> => {\n  const set = beginMutation(empty<A>())\n  for (const value of elements) {\n    add(set, value)\n  }\n  return endMutation(set)\n}\n\n/** @internal */\nexport const make = <As extends ReadonlyArray<any>>(...elements: As): HS.HashSet<As[number]> => {\n  const set = beginMutation(empty<As[number]>())\n  for (const value of elements) {\n    add(set, value)\n  }\n  return endMutation(set)\n}\n\n/** @internal */\nexport const has = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => boolean,\n  <A>(self: HS.HashSet<A>, value: A) => boolean\n>(2, <A>(self: HS.HashSet<A>, value: A) => HM.has((self as HashSetImpl<A>)._keyMap, value))\n\n/** @internal */\nexport const some = dual<\n  <A>(f: Predicate<A>) => (self: HS.HashSet<A>) => boolean,\n  <A>(self: HS.HashSet<A>, f: Predicate<A>) => boolean\n>(2, (self, f) => {\n  let found = false\n  for (const value of self) {\n    found = f(value)\n    if (found) {\n      break\n    }\n  }\n  return found\n})\n\n/** @internal */\nexport const every: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HS.HashSet<A>) => self is HS.HashSet<B>\n  <A>(predicate: Predicate<A>): (self: HS.HashSet<A>) => boolean\n  <A, B extends A>(self: HS.HashSet<A>, refinement: Refinement<A, B>): self is HS.HashSet<B>\n  <A>(self: HS.HashSet<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: HS.HashSet<A>, refinement: Refinement<A, B>): self is HS.HashSet<B> =>\n    !some(self, (a) => !refinement(a))\n)\n\n/** @internal */\nexport const isSubset = dual<\n  <A>(that: HS.HashSet<A>) => (self: HS.HashSet<A>) => boolean,\n  <A>(self: HS.HashSet<A>, that: HS.HashSet<A>) => boolean\n>(2, (self, that) => every(self, (value) => has(that, value)))\n\n/** @internal */\nexport const values = <A>(self: HS.HashSet<A>): IterableIterator<A> => HM.keys((self as HashSetImpl<A>)._keyMap)\n\n/** @internal */\nexport const size = <A>(self: HS.HashSet<A>): number => HM.size((self as HashSetImpl<A>)._keyMap)\n\n/** @internal */\nexport const beginMutation = <A>(self: HS.HashSet<A>): HS.HashSet<A> =>\n  makeImpl(HM.beginMutation((self as HashSetImpl<A>)._keyMap))\n\n/** @internal */\nexport const endMutation = <A>(self: HS.HashSet<A>): HS.HashSet<A> => {\n  ;((self as HashSetImpl<A>)._keyMap as HM.HashMapImpl<A, unknown>)._editable = false\n  return self\n}\n\n/** @internal */\nexport const mutate = dual<\n  <A>(f: (set: HS.HashSet<A>) => void) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, f: (set: HS.HashSet<A>) => void) => HS.HashSet<A>\n>(2, (self, f) => {\n  const transient = beginMutation(self)\n  f(transient)\n  return endMutation(transient)\n})\n\n/** @internal */\nexport const add = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, value: A) => HS.HashSet<A>\n>(\n  2,\n  <A>(self: HS.HashSet<A>, value: A) =>\n    ((self as HashSetImpl<A>)._keyMap as HM.HashMapImpl<A, unknown>)._editable\n      ? (HM.set(value as A, true as unknown)((self as HashSetImpl<A>)._keyMap), self)\n      : makeImpl(HM.set(value as A, true as unknown)((self as HashSetImpl<A>)._keyMap))\n)\n\n/** @internal */\nexport const remove = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, value: A) => HS.HashSet<A>\n>(\n  2,\n  <A>(self: HS.HashSet<A>, value: A) =>\n    (((self as HashSetImpl<A>)._keyMap) as HM.HashMapImpl<A, unknown>)._editable\n      ? (HM.remove(value)((self as HashSetImpl<A>)._keyMap), self)\n      : makeImpl(HM.remove(value)((self as HashSetImpl<A>)._keyMap))\n)\n\n/** @internal */\nexport const difference = dual<\n  <A>(that: Iterable<A>) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, that: Iterable<A>) => HS.HashSet<A>\n>(2, (self, that) =>\n  mutate(self, (set) => {\n    for (const value of that) {\n      remove(set, value)\n    }\n  }))\n\n/** @internal */\nexport const intersection = dual<\n  <A>(that: Iterable<A>) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, that: Iterable<A>) => HS.HashSet<A>\n>(2, (self, that) =>\n  mutate(empty(), (set) => {\n    for (const value of that) {\n      if (has(value)(self)) {\n        add(value)(set)\n      }\n    }\n  }))\n\n/** @internal */\nexport const union = dual<\n  <A>(that: Iterable<A>) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, that: Iterable<A>) => HS.HashSet<A>\n>(2, (self, that) =>\n  mutate(empty(), (set) => {\n    forEach(self, (value) => add(set, value))\n    for (const value of that) {\n      add(set, value)\n    }\n  }))\n\n/** @internal */\nexport const toggle = dual<\n  <A>(value: A) => (self: HS.HashSet<A>) => HS.HashSet<A>,\n  <A>(self: HS.HashSet<A>, value: A) => HS.HashSet<A>\n>(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value))\n\n/** @internal */\nexport const map = dual<\n  <A, B>(f: (a: A) => B) => (self: HS.HashSet<A>) => HS.HashSet<B>,\n  <A, B>(self: HS.HashSet<A>, f: (a: A) => B) => HS.HashSet<B>\n>(2, (self, f) =>\n  mutate(empty(), (set) => {\n    forEach(self, (a) => {\n      const b = f(a)\n      if (!has(set, b)) {\n        add(set, b)\n      }\n    })\n  }))\n\n/** @internal */\nexport const flatMap = dual<\n  <A, B>(f: (a: A) => Iterable<B>) => (self: HS.HashSet<A>) => HS.HashSet<B>,\n  <A, B>(self: HS.HashSet<A>, f: (a: A) => Iterable<B>) => HS.HashSet<B>\n>(2, (self, f) =>\n  mutate(empty(), (set) => {\n    forEach(self, (a) => {\n      for (const b of f(a)) {\n        if (!has(set, b)) {\n          add(set, b)\n        }\n      }\n    })\n  }))\n\n/** @internal */\nexport const forEach = dual<\n  <A>(f: (value: A) => void) => (self: HS.HashSet<A>) => void,\n  <A>(self: HS.HashSet<A>, f: (value: A) => void) => void\n>(2, <A>(self: HS.HashSet<A>, f: (value: A) => void) =>\n  HM.forEach(\n    (self as HashSetImpl<A>)._keyMap,\n    (_, k) => f(k)\n  ))\n\n/** @internal */\nexport const reduce = dual<\n  <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z) => (self: HS.HashSet<A>) => Z,\n  <A, Z>(self: HS.HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z) => Z\n>(3, <A, Z>(self: HS.HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z) =>\n  HM.reduce(\n    (self as HashSetImpl<A>)._keyMap,\n    zero,\n    (z, _, a) => f(z, a)\n  ))\n\n/** @internal */\nexport const filter: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HS.HashSet<A>) => HS.HashSet<B>\n  <A>(predicate: Predicate<NoInfer<A>>): (self: HS.HashSet<A>) => HS.HashSet<A>\n  <A, B extends A>(self: HS.HashSet<A>, refinement: Refinement<A, B>): HS.HashSet<B>\n  <A>(self: HS.HashSet<A>, predicate: Predicate<A>): HS.HashSet<A>\n} = dual(2, <A>(self: HS.HashSet<A>, f: Predicate<A>) => {\n  return mutate(empty(), (set) => {\n    const iterator = values(self)\n    let next: IteratorResult<A, any>\n    while (!(next = iterator.next()).done) {\n      const value = next.value\n      if (f(value)) {\n        add(set, value)\n      }\n    }\n  })\n})\n\n/** @internal */\nexport const partition: {\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (self: HS.HashSet<A>) => [excluded: HS.HashSet<Exclude<A, B>>, satisfying: HS.HashSet<B>]\n  <A>(\n    predicate: Predicate<NoInfer<A>>\n  ): (self: HS.HashSet<A>) => [excluded: HS.HashSet<A>, satisfying: HS.HashSet<A>]\n  <A, B extends A>(\n    self: HS.HashSet<A>,\n    refinement: Refinement<A, B>\n  ): [excluded: HS.HashSet<Exclude<A, B>>, satisfying: HS.HashSet<B>]\n  <A>(self: HS.HashSet<A>, predicate: Predicate<A>): [excluded: HS.HashSet<A>, satisfying: HS.HashSet<A>]\n} = dual(2, <A>(self: HS.HashSet<A>, predicate: Predicate<A>): [excluded: HS.HashSet<A>, satisfying: HS.HashSet<A>] => {\n  const iterator = values(self)\n  let next: IteratorResult<A, any>\n  const right = beginMutation(empty<A>())\n  const left = beginMutation(empty<A>())\n  while (!(next = iterator.next()).done) {\n    const value = next.value\n    if (predicate(value)) {\n      add(right, value)\n    } else {\n      add(left, value)\n    }\n  }\n  return [endMutation(left), endMutation(right)]\n})\n","import * as Equal from \"../Equal.js\"\nimport * as Dual from \"../Function.js\"\nimport { identity, pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport type * as HM from \"../HashMap.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport { fromBitmap, hashFragment, toBitmap } from \"./hashMap/bitwise.js\"\nimport { SIZE } from \"./hashMap/config.js\"\nimport * as Node from \"./hashMap/node.js\"\n\nconst HashMapSymbolKey = \"effect/HashMap\"\n\n/** @internal */\nexport const HashMapTypeId: HM.TypeId = Symbol.for(HashMapSymbolKey) as HM.TypeId\n\ntype TraversalFn<K, V, A> = (k: K, v: V) => A\n\ntype Cont<K, V, A> =\n  | [\n    len: number,\n    children: Array<Node.Node<K, V>>,\n    i: number,\n    f: TraversalFn<K, V, A>,\n    cont: Cont<K, V, A>\n  ]\n  | undefined\n\ninterface VisitResult<K, V, A> {\n  value: A\n  cont: Cont<K, V, A>\n}\n\n/** @internal */\nexport interface HashMapImpl<out K, out V> extends HM.HashMap<K, V> {\n  _editable: boolean // mutable by design\n  _edit: number // mutable by design\n  _root: Node.Node<K, V> // mutable by design\n  _size: number // mutable by design\n}\n\nconst HashMapProto: HM.HashMap<unknown, unknown> = {\n  [HashMapTypeId]: HashMapTypeId,\n  [Symbol.iterator]<K, V>(this: HashMapImpl<K, V>): Iterator<[K, V]> {\n    return new HashMapIterator(this, (k, v) => [k, v])\n  },\n  [Hash.symbol](this: HM.HashMap<unknown, unknown>): number {\n    let hash = Hash.hash(HashMapSymbolKey)\n    for (const item of this) {\n      hash ^= pipe(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])))\n    }\n    return Hash.cached(this, hash)\n  },\n  [Equal.symbol]<K, V>(this: HashMapImpl<K, V>, that: unknown): boolean {\n    if (isHashMap(that)) {\n      if ((that as HashMapImpl<K, V>)._size !== this._size) {\n        return false\n      }\n      for (const item of this) {\n        const elem = pipe(\n          that as HM.HashMap<K, V>,\n          getHash(item[0], Hash.hash(item[0]))\n        )\n        if (Option.isNone(elem)) {\n          return false\n        } else {\n          if (!Equal.equals(item[1], elem.value)) {\n            return false\n          }\n        }\n      }\n      return true\n    }\n    return false\n  },\n  toString<K, V>(this: HashMapImpl<K, V>) {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"HashMap\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeImpl = <K, V>(\n  editable: boolean,\n  edit: number,\n  root: Node.Node<K, V>,\n  size: number\n): HashMapImpl<K, V> => {\n  const map = Object.create(HashMapProto)\n  map._editable = editable\n  map._edit = edit\n  map._root = root\n  map._size = size\n  return map\n}\n\nclass HashMapIterator<in out K, in out V, out T> implements IterableIterator<T> {\n  v: Option.Option<VisitResult<K, V, T>>\n\n  constructor(readonly map: HashMapImpl<K, V>, readonly f: TraversalFn<K, V, T>) {\n    this.v = visitLazy(this.map._root, this.f, undefined)\n  }\n\n  next(): IteratorResult<T> {\n    if (Option.isNone(this.v)) {\n      return { done: true, value: undefined }\n    }\n    const v0 = this.v.value\n    this.v = applyCont(v0.cont)\n    return { done: false, value: v0.value }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return new HashMapIterator(this.map, this.f)\n  }\n}\n\nconst applyCont = <K, V, A>(cont: Cont<K, V, A>): Option.Option<VisitResult<K, V, A>> =>\n  cont\n    ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4])\n    : Option.none()\n\nconst visitLazy = <K, V, A>(\n  node: Node.Node<K, V>,\n  f: TraversalFn<K, V, A>,\n  cont: Cont<K, V, A> = undefined\n): Option.Option<VisitResult<K, V, A>> => {\n  switch (node._tag) {\n    case \"LeafNode\": {\n      if (Option.isSome(node.value)) {\n        return Option.some({\n          value: f(node.key, node.value.value),\n          cont\n        })\n      }\n      return applyCont(cont)\n    }\n    case \"CollisionNode\":\n    case \"ArrayNode\":\n    case \"IndexedNode\": {\n      const children = node.children\n      return visitLazyChildren(children.length, children, 0, f, cont)\n    }\n    default: {\n      return applyCont(cont)\n    }\n  }\n}\n\nconst visitLazyChildren = <K, V, A>(\n  len: number,\n  children: Array<Node.Node<K, V>>,\n  i: number,\n  f: TraversalFn<K, V, A>,\n  cont: Cont<K, V, A>\n): Option.Option<VisitResult<K, V, A>> => {\n  while (i < len) {\n    const child = children[i++]\n    if (child && !Node.isEmptyNode(child)) {\n      return visitLazy(child, f, [len, children, i, f, cont])\n    }\n  }\n  return applyCont(cont)\n}\n\nconst _empty = makeImpl<never, never>(false, 0, new Node.EmptyNode(), 0)\n\n/** @internal */\nexport const empty = <K = never, V = never>(): HM.HashMap<K, V> => _empty\n\n/** @internal */\nexport const make = <Entries extends ReadonlyArray<readonly [any, any]>>(\n  ...entries: Entries\n): HM.HashMap<\n  Entries[number] extends readonly [infer K, any] ? K : never,\n  Entries[number] extends readonly [any, infer V] ? V : never\n> => fromIterable(entries)\n\n/** @internal */\nexport const fromIterable = <K, V>(entries: Iterable<readonly [K, V]>): HM.HashMap<K, V> => {\n  const map = beginMutation(empty<K, V>())\n  for (const entry of entries) {\n    set(map, entry[0], entry[1])\n  }\n  return endMutation(map)\n}\n\n/** @internal */\nexport const isHashMap: {\n  <K, V>(u: Iterable<readonly [K, V]>): u is HM.HashMap<K, V>\n  (u: unknown): u is HM.HashMap<unknown, unknown>\n} = (u: unknown): u is HM.HashMap<unknown, unknown> => hasProperty(u, HashMapTypeId)\n\n/** @internal */\nexport const isEmpty = <K, V>(self: HM.HashMap<K, V>): boolean =>\n  self && Node.isEmptyNode((self as HashMapImpl<K, V>)._root)\n\n/** @internal */\nexport const get = Dual.dual<\n  <K1 extends K, K>(key: K1) => <V>(self: HM.HashMap<K, V>) => Option.Option<V>,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1) => Option.Option<V>\n>(2, (self, key) => getHash(self, key, Hash.hash(key)))\n\n/** @internal */\nexport const getHash = Dual.dual<\n  <K1 extends K, K>(key: K1, hash: number) => <V>(self: HM.HashMap<K, V>) => Option.Option<V>,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1, hash: number) => Option.Option<V>\n>(3, <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1, hash: number) => {\n  let node = (self as HashMapImpl<K, V>)._root\n  let shift = 0\n\n  while (true) {\n    switch (node._tag) {\n      case \"LeafNode\": {\n        return Equal.equals(key, node.key) ? node.value : Option.none()\n      }\n      case \"CollisionNode\": {\n        if (hash === node.hash) {\n          const children = node.children\n          for (let i = 0, len = children.length; i < len; ++i) {\n            const child = children[i]!\n            if (\"key\" in child && Equal.equals(key, child.key)) {\n              return child.value\n            }\n          }\n        }\n        return Option.none()\n      }\n      case \"IndexedNode\": {\n        const frag = hashFragment(shift, hash)\n        const bit = toBitmap(frag)\n        if (node.mask & bit) {\n          node = node.children[fromBitmap(node.mask, bit)]!\n          shift += SIZE\n          break\n        }\n        return Option.none()\n      }\n      case \"ArrayNode\": {\n        node = node.children[hashFragment(shift, hash)]!\n        if (node) {\n          shift += SIZE\n          break\n        }\n        return Option.none()\n      }\n      default:\n        return Option.none()\n    }\n  }\n})\n\n/** @internal */\nexport const unsafeGet = Dual.dual<\n  <K1 extends K, K>(key: K1) => <V>(self: HM.HashMap<K, V>) => V,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1) => V\n>(2, (self, key) => {\n  const element = getHash(self, key, Hash.hash(key))\n  if (Option.isNone(element)) {\n    throw new Error(\"Expected map to contain key\")\n  }\n  return element.value\n})\n\n/** @internal */\nexport const has = Dual.dual<\n  <K1 extends K, K>(key: K1) => <V>(self: HM.HashMap<K, V>) => boolean,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1) => boolean\n>(2, (self, key) => Option.isSome(getHash(self, key, Hash.hash(key))))\n\n/** @internal */\nexport const hasHash = Dual.dual<\n  <K1 extends K, K>(key: K1, hash: number) => <V>(self: HM.HashMap<K, V>) => boolean,\n  <K, V, K1 extends K>(self: HM.HashMap<K, V>, key: K1, hash: number) => boolean\n>(3, (self, key, hash) => Option.isSome(getHash(self, key, hash)))\n\n/** @internal */\nexport const hasBy = Dual.dual<\n  <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => (self: HM.HashMap<K, V>) => boolean,\n  <K, V>(self: HM.HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => boolean\n>(2, (self, predicate) => Option.isSome(findFirst(self, predicate)))\n\n/** @internal */\nexport const set = Dual.dual<\n  <K, V>(key: K, value: V) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, value: V) => HM.HashMap<K, V>\n>(3, (self, key, value) => modifyAt(self, key, () => Option.some(value)))\n\n/** @internal */\nexport const setTree = Dual.dual<\n  <K, V>(newRoot: Node.Node<K, V>, newSize: number) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, newRoot: Node.Node<K, V>, newSize: number) => HM.HashMap<K, V>\n>(3, <K, V>(self: HM.HashMap<K, V>, newRoot: Node.Node<K, V>, newSize: number) => {\n  if ((self as HashMapImpl<K, V>)._editable) {\n    ;(self as HashMapImpl<K, V>)._root = newRoot\n    ;(self as HashMapImpl<K, V>)._size = newSize\n    return self\n  }\n  return newRoot === (self as HashMapImpl<K, V>)._root\n    ? self\n    : makeImpl(\n      (self as HashMapImpl<K, V>)._editable,\n      (self as HashMapImpl<K, V>)._edit,\n      newRoot,\n      newSize\n    )\n})\n\n/** @internal */\nexport const keys = <K, V>(self: HM.HashMap<K, V>): IterableIterator<K> =>\n  new HashMapIterator(self as HashMapImpl<K, V>, (key) => key)\n\n/** @internal */\nexport const values = <K, V>(self: HM.HashMap<K, V>): IterableIterator<V> =>\n  new HashMapIterator(self as HashMapImpl<K, V>, (_, value) => value)\n\n/** @internal */\nexport const entries = <K, V>(self: HM.HashMap<K, V>): IterableIterator<[K, V]> =>\n  new HashMapIterator(self as HashMapImpl<K, V>, (key, value) => [key, value])\n\n/** @internal */\nexport const size = <K, V>(self: HM.HashMap<K, V>): number => (self as HashMapImpl<K, V>)._size\n\n/** @internal */\nexport const countBy = Dual.dual<\n  <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => (self: HM.HashMap<K, V>) => number,\n  <K, V>(self: HM.HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean) => number\n>(2, (self, f) => {\n  let count = 0\n  for (const [k, a] of self) {\n    if (f(a, k)) {\n      count++\n    }\n  }\n  return count\n})\n\n/** @internal */\nexport const beginMutation = <K, V>(self: HM.HashMap<K, V>): HM.HashMap<K, V> =>\n  makeImpl(\n    true,\n    (self as HashMapImpl<K, V>)._edit + 1,\n    (self as HashMapImpl<K, V>)._root,\n    (self as HashMapImpl<K, V>)._size\n  )\n\n/** @internal */\nexport const endMutation = <K, V>(self: HM.HashMap<K, V>): HM.HashMap<K, V> => {\n  ;(self as HashMapImpl<K, V>)._editable = false\n  return self\n}\n\n/** @internal */\nexport const mutate = Dual.dual<\n  <K, V>(f: (self: HM.HashMap<K, V>) => void) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, f: (self: HM.HashMap<K, V>) => void) => HM.HashMap<K, V>\n>(2, (self, f) => {\n  const transient = beginMutation(self)\n  f(transient)\n  return endMutation(transient)\n})\n\n/** @internal */\nexport const modifyAt = Dual.dual<\n  <K, V>(key: K, f: HM.HashMap.UpdateFn<V>) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, f: HM.HashMap.UpdateFn<V>) => HM.HashMap<K, V>\n>(3, (self, key, f) => modifyHash(self, key, Hash.hash(key), f))\n\n/** @internal */\nexport const modifyHash = Dual.dual<\n  <K, V>(key: K, hash: number, f: HM.HashMap.UpdateFn<V>) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, hash: number, f: HM.HashMap.UpdateFn<V>) => HM.HashMap<K, V>\n>(4, <K, V>(self: HM.HashMap<K, V>, key: K, hash: number, f: HM.HashMap.UpdateFn<V>) => {\n  const size = { value: (self as HashMapImpl<K, V>)._size }\n  const newRoot = (self as HashMapImpl<K, V>)._root.modify(\n    (self as HashMapImpl<K, V>)._editable ?\n      (self as HashMapImpl<K, V>)._edit :\n      NaN,\n    0,\n    f,\n    hash,\n    key,\n    size\n  )\n  return pipe(self, setTree(newRoot, size.value))\n})\n\n/** @internal */\nexport const modify = Dual.dual<\n  <K, V>(key: K, f: (v: V) => V) => (self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K, f: (v: V) => V) => HM.HashMap<K, V>\n>(3, (self, key, f) => modifyAt(self, key, Option.map(f)))\n\n/** @internal */\nexport const union = Dual.dual<\n  <K1, V1>(\n    that: HM.HashMap<K1, V1>\n  ) => <K0, V0>(self: HM.HashMap<K0, V0>) => HM.HashMap<K0 | K1, V0 | V1>,\n  <K0, V0, K1, V1>(\n    self: HM.HashMap<K0, V0>,\n    that: HM.HashMap<K1, V1>\n  ) => HM.HashMap<K0 | K1, V0 | V1>\n>(2, <K0, V0, K1, V1>(self: HM.HashMap<K0, V0>, that: HM.HashMap<K1, V1>) => {\n  const result: HM.HashMap<K0 | K1, V0 | V1> = beginMutation(self)\n  forEach(that, (v, k) => set(result, k, v))\n  return endMutation(result)\n})\n\n/** @internal */\nexport const remove = Dual.dual<\n  <K>(key: K) => <V>(self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, key: K) => HM.HashMap<K, V>\n>(2, (self, key) => modifyAt(self, key, Option.none))\n\n/** @internal */\nexport const removeMany = Dual.dual<\n  <K>(keys: Iterable<K>) => <V>(self: HM.HashMap<K, V>) => HM.HashMap<K, V>,\n  <K, V>(self: HM.HashMap<K, V>, keys: Iterable<K>) => HM.HashMap<K, V>\n>(2, (self, keys) =>\n  mutate(self, (map) => {\n    for (const key of keys) {\n      remove(key)(map)\n    }\n  }))\n\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map = Dual.dual<\n  <A, V, K>(f: (value: V, key: K) => A) => (self: HM.HashMap<K, V>) => HM.HashMap<K, A>,\n  <K, V, A>(self: HM.HashMap<K, V>, f: (value: V, key: K) => A) => HM.HashMap<K, A>\n>(2, (self, f) =>\n  reduce(\n    self,\n    empty(),\n    (map, value, key) => set(map, key, f(value, key))\n  ))\n\n/** @internal */\nexport const flatMap = Dual.dual<\n  <A, K, B>(\n    f: (value: A, key: K) => HM.HashMap<K, B>\n  ) => (self: HM.HashMap<K, A>) => HM.HashMap<K, B>,\n  <K, A, B>(self: HM.HashMap<K, A>, f: (value: A, key: K) => HM.HashMap<K, B>) => HM.HashMap<K, B>\n>(\n  2,\n  (self, f) =>\n    reduce(self, empty(), (zero, value, key) =>\n      mutate(\n        zero,\n        (map) => forEach(f(value, key), (value, key) => set(map, key, value))\n      ))\n)\n\n/** @internal */\nexport const forEach = Dual.dual<\n  <V, K>(f: (value: V, key: K) => void) => (self: HM.HashMap<K, V>) => void,\n  <V, K>(self: HM.HashMap<K, V>, f: (value: V, key: K) => void) => void\n>(2, (self, f) => reduce(self, void 0 as void, (_, value, key) => f(value, key)))\n\n/** @internal */\nexport const reduce = Dual.dual<\n  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => (self: HM.HashMap<K, V>) => Z,\n  <Z, V, K>(self: HM.HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => Z\n>(3, <Z, V, K>(self: HM.HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => {\n  const root = (self as HashMapImpl<K, V>)._root\n  if (root._tag === \"LeafNode\") {\n    return Option.isSome(root.value) ? f(zero, root.value.value, root.key) : zero\n  }\n  if (root._tag === \"EmptyNode\") {\n    return zero\n  }\n  const toVisit = [root.children]\n  let children\n  while ((children = toVisit.pop())) {\n    for (let i = 0, len = children.length; i < len;) {\n      const child = children[i++]\n      if (child && !Node.isEmptyNode(child)) {\n        if (child._tag === \"LeafNode\") {\n          if (Option.isSome(child.value)) {\n            zero = f(zero, child.value.value, child.key)\n          }\n        } else {\n          toVisit.push(child.children)\n        }\n      }\n    }\n  }\n  return zero\n})\n\n/** @internal */\nexport const filter: {\n  <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HM.HashMap<K, A>) => HM.HashMap<K, B>\n  <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => HM.HashMap<K, A>\n  <K, A, B extends A>(self: HM.HashMap<K, A>, f: (a: A, k: K) => a is B): HM.HashMap<K, B>\n  <K, A>(self: HM.HashMap<K, A>, f: (a: A, k: K) => boolean): HM.HashMap<K, A>\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, f: (a: A, k: K) => boolean): HM.HashMap<K, A> =>\n    mutate(empty(), (map) => {\n      for (const [k, a] of self) {\n        if (f(a, k)) {\n          set(map, k, a)\n        }\n      }\n    })\n)\n\n/** @internal */\nexport const compact = <K, A>(self: HM.HashMap<K, Option.Option<A>>) => filterMap(self, identity)\n\n/** @internal */\nexport const filterMap = Dual.dual<\n  <A, K, B>(\n    f: (value: A, key: K) => Option.Option<B>\n  ) => (self: HM.HashMap<K, A>) => HM.HashMap<K, B>,\n  <K, A, B>(self: HM.HashMap<K, A>, f: (value: A, key: K) => Option.Option<B>) => HM.HashMap<K, B>\n>(2, (self, f) =>\n  mutate(empty(), (map) => {\n    for (const [k, a] of self) {\n      const option = f(a, k)\n      if (Option.isSome(option)) {\n        set(map, k, option.value)\n      }\n    }\n  }))\n\n/** @internal */\nexport const findFirst: {\n  <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HM.HashMap<K, A>) => Option.Option<[K, B]>\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => Option.Option<[K, A]>\n  <K, A, B extends A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option.Option<[K, B]>\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option.Option<[K, A]>\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option.Option<[K, A]> => {\n    for (const ka of self) {\n      if (predicate(ka[1], ka[0])) {\n        return Option.some(ka)\n      }\n    }\n    return Option.none()\n  }\n)\n\n/** @internal */\nexport const some: {\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => boolean\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean => {\n    for (const ka of self) {\n      if (predicate(ka[1], ka[0])) {\n        return true\n      }\n    }\n    return false\n  }\n)\n\n/** @internal */\nexport const every: {\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HM.HashMap<K, A>) => boolean\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean\n} = Dual.dual(\n  2,\n  <K, A>(self: HM.HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean => !some(self, (a, k) => !predicate(a, k))\n)\n","import { MASK } from \"./config.js\"\n\n/**\n * Hamming weight.\n *\n * Taken from: http://jsperf.com/hamming-weight\n *\n * @internal\n */\nexport function popcount(x: number) {\n  x -= (x >> 1) & 0x55555555\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n  x = (x + (x >> 4)) & 0x0f0f0f0f\n  x += x >> 8\n  x += x >> 16\n  return x & 0x7f\n}\n\n/** @internal */\nexport function hashFragment(shift: number, h: number) {\n  return (h >>> shift) & MASK\n}\n\n/** @internal */\nexport function toBitmap(x: number) {\n  return 1 << x\n}\n\n/** @internal */\nexport function fromBitmap(bitmap: number, bit: number) {\n  return popcount(bitmap & (bit - 1))\n}\n","/** @internal */\nexport const SIZE = 5\n\n/** @internal */\nexport const BUCKET_SIZE = Math.pow(2, SIZE)\n\n/** @internal */\nexport const MASK = BUCKET_SIZE - 1\n\n/** @internal */\nexport const MAX_INDEX_NODE = BUCKET_SIZE / 2\n\n/** @internal */\nexport const MIN_ARRAY_NODE = BUCKET_SIZE / 4\n","/** @internal */\nexport function arrayUpdate<A>(mutate: boolean, at: number, v: A, arr: Array<A>) {\n  let out = arr\n  if (!mutate) {\n    const len = arr.length\n    out = new Array(len)\n    for (let i = 0; i < len; ++i) out[i] = arr[i]!\n  }\n  out[at] = v\n  return out\n}\n\n/** @internal */\nexport function arraySpliceOut<A>(mutate: boolean, at: number, arr: Array<A>) {\n  const newLen = arr.length - 1\n  let i = 0\n  let g = 0\n  let out = arr\n  if (mutate) {\n    i = g = at\n  } else {\n    out = new Array(newLen)\n    while (i < at) out[g++] = arr[i++]!\n  }\n  ++i\n  while (i <= newLen) out[g++] = arr[i++]!\n  if (mutate) {\n    out.length = newLen\n  }\n  return out\n}\n\n/** @internal */\nexport function arraySpliceIn<A>(mutate: boolean, at: number, v: A, arr: Array<A>) {\n  const len = arr.length\n  if (mutate) {\n    let i = len\n    while (i >= at) arr[i--] = arr[i]!\n    arr[at] = v\n    return arr\n  }\n  let i = 0,\n    g = 0\n  const out = new Array<A>(len + 1)\n  while (i < at) out[g++] = arr[i++]!\n  out[at] = v\n  while (i < len) out[++g] = arr[i++]!\n  return out\n}\n","/**\n * # HashSet\n *\n * An immutable `HashSet` provides a collection of unique values with efficient\n * lookup, insertion and removal. Once created, a `HashSet` cannot be modified;\n * any operation that would alter the set instead returns a new `HashSet` with\n * the changes. This immutability offers benefits like predictable state\n * management and easier reasoning about your code.\n *\n * ## What Problem Does It Solve?\n *\n * `HashSet` solves the problem of maintaining an unsorted collection where each\n * value appears exactly once, with fast operations for checking membership and\n * adding/removing values.\n *\n * ## When to Use\n *\n * Use `HashSet` when you need:\n *\n * - A collection with no duplicate values\n * - Efficient membership testing (**`O(1)`** average complexity)\n * - Set operations like union, intersection, and difference\n * - An immutable data structure that preserves functional programming patterns\n *\n * ## Advanced Features\n *\n * HashSet provides operations for:\n *\n * - Transforming sets with map and flatMap\n * - Filtering elements with filter\n * - Combining sets with union, intersection and difference\n * - Performance optimizations via mutable operations in controlled contexts\n *\n * ## Performance Characteristics\n *\n * - **Lookup** operations ({@link module:HashSet.has}): **`O(1)`** average time\n *   complexity\n * - **Insertion** operations ({@link module:HashSet.add}): **`O(1)`** average time\n *   complexity\n * - **Removal** operations ({@link module:HashSet.remove}): **`O(1)`** average\n *   time complexity\n * - **Set** operations ({@link module:HashSet.union},\n *   {@link module:HashSet.intersection}): **`O(n)`** where n is the size of the\n *   smaller set\n * - **Iteration**: **`O(n)`** where n is the size of the set\n *\n * The HashSet data structure implements the following traits:\n *\n * - {@link Iterable}: allows iterating over the values in the set\n * - {@link Equal}: allows comparing two sets for value-based equality\n * - {@link Pipeable}: allows chaining operations with the pipe operator\n * - {@link Inspectable}: allows inspecting the contents of the set\n *\n * ## Operations Reference\n *\n * | Category     | Operation                           | Description                                 | Complexity |\n * | ------------ | ----------------------------------- | ------------------------------------------- | ---------- |\n * | constructors | {@link module:HashSet.empty}        | Creates an empty HashSet                    | O(1)       |\n * | constructors | {@link module:HashSet.fromIterable} | Creates a HashSet from an iterable          | O(n)       |\n * | constructors | {@link module:HashSet.make}         | Creates a HashSet from multiple values      | O(n)       |\n * |              |                                     |                                             |            |\n * | elements     | {@link module:HashSet.has}          | Checks if a value exists in the set         | O(1) avg   |\n * | elements     | {@link module:HashSet.some}         | Checks if any element satisfies a predicate | O(n)       |\n * | elements     | {@link module:HashSet.every}        | Checks if all elements satisfy a predicate  | O(n)       |\n * | elements     | {@link module:HashSet.isSubset}     | Checks if a set is a subset of another      | O(n)       |\n * |              |                                     |                                             |            |\n * | getters      | {@link module:HashSet.values}       | Gets an iterator of all values              | O(1)       |\n * | getters      | {@link module:HashSet.toValues}     | Gets an array of all values                 | O(n)       |\n * | getters      | {@link module:HashSet.size}         | Gets the number of elements                 | O(1)       |\n * |              |                                     |                                             |            |\n * | mutations    | {@link module:HashSet.add}          | Adds a value to the set                     | O(1) avg   |\n * | mutations    | {@link module:HashSet.remove}       | Removes a value from the set                | O(1) avg   |\n * | mutations    | {@link module:HashSet.toggle}       | Toggles a value's presence                  | O(1) avg   |\n * |              |                                     |                                             |            |\n * | operations   | {@link module:HashSet.difference}   | Computes set difference (A - B)             | O(n)       |\n * | operations   | {@link module:HashSet.intersection} | Computes set intersection (A  B)           | O(n)       |\n * | operations   | {@link module:HashSet.union}        | Computes set union (A  B)                  | O(n)       |\n * |              |                                     |                                             |            |\n * | mapping      | {@link module:HashSet.map}          | Transforms each element                     | O(n)       |\n * |              |                                     |                                             |            |\n * | sequencing   | {@link module:HashSet.flatMap}      | Transforms and flattens elements            | O(n)       |\n * |              |                                     |                                             |            |\n * | traversing   | {@link module:HashSet.forEach}      | Applies a function to each element          | O(n)       |\n * |              |                                     |                                             |            |\n * | folding      | {@link module:HashSet.reduce}       | Reduces the set to a single value           | O(n)       |\n * |              |                                     |                                             |            |\n * | filtering    | {@link module:HashSet.filter}       | Keeps elements that satisfy a predicate     | O(n)       |\n * |              |                                     |                                             |            |\n * | partitioning | {@link module:HashSet.partition}    | Splits into two sets by a predicate         | O(n)       |\n *\n * ## Notes\n *\n * ### Composability with the Effect Ecosystem:\n *\n * This `HashSet` is designed to work seamlessly within the Effect ecosystem. It\n * implements the {@link Iterable}, {@link Equal}, {@link Pipeable}, and\n * {@link Inspectable} traits from Effect. This ensures compatibility with other\n * Effect data structures and functionalities. For example, you can easily use\n * Effect's `pipe` method to chain operations on the `HashSet`.\n *\n * **Equality of Elements with Effect's {@link Equal `Equal`} Trait:**\n *\n * This `HashSet` relies on Effect's {@link Equal} trait to determine the\n * uniqueness of elements within the set. The way equality is checked depends on\n * the type of the elements:\n *\n * - **Primitive Values:** For primitive JavaScript values like strings, numbers,\n *   booleans, `null`, and `undefined`, equality is determined by their value\n *   (similar to the `===` operator).\n * - **Objects and Custom Types:** For objects and other custom types, equality is\n *   determined by whether those types implement the {@link Equal} interface\n *   themselves. If an element type implements `Equal`, the `HashSet` will\n *   delegate to that implementation to perform the equality check. This allows\n *   you to define custom logic for determining when two instances of your\n *   objects should be considered equal based on their properties, rather than\n *   just their object identity.\n *\n * ```ts\n * import { Equal, Hash, HashSet } from \"effect\"\n *\n * class Person implements Equal.Equal {\n *   constructor(\n *     readonly id: number, // Unique identifier\n *     readonly name: string,\n *     readonly age: number\n *   ) {}\n *\n *   // Define equality based on id, name, and age\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Person) {\n *       return (\n *         Equal.equals(this.id, that.id) &&\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.age, that.age)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the unique id\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.id)\n *   }\n * }\n *\n * // Creating a HashSet with objects that implement the Equal interface\n * const set = HashSet.empty().pipe(\n *   HashSet.add(new Person(1, \"Alice\", 30)),\n *   HashSet.add(new Person(1, \"Alice\", 30))\n * )\n *\n * // HashSet recognizes them as equal, so only one element is stored\n * console.log(HashSet.size(set))\n * // Output: 1\n * ```\n *\n * **Simplifying Equality and Hashing with `Data` and `Schema`:**\n *\n * Effect's {@link Data} and {@link Schema `Schema.Data`} modules offer powerful\n * ways to automatically handle the implementation of both the {@link Equal} and\n * {@link Hash} traits for your custom data structures.\n *\n * - **`Data` Module:** By using constructors like `Data.struct`, `Data.tuple`,\n *   `Data.array`, or `Data.case` to define your data types, Effect\n *   automatically generates the necessary implementations for value-based\n *   equality and consistent hashing. This significantly reduces boilerplate and\n *   ensures correctness.\n *\n * ```ts\n * import { HashSet, Data, Equal } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Data.* implements the `Equal` traits for us\n * const person1 = Data.struct({ id: 1, name: \"Alice\", age: 30 })\n * const person2 = Data.struct({ id: 1, name: \"Alice\", age: 30 })\n *\n * assert(Equal.equals(person1, person2))\n *\n * const set = HashSet.empty().pipe(\n *   HashSet.add(person1),\n *   HashSet.add(person2)\n * )\n *\n * // HashSet recognizes them as equal, so only one element is stored\n * console.log(HashSet.size(set)) // Output: 1\n * ```\n *\n * - **`Schema` Module:** When defining data schemas using the {@link Schema}\n *   module, you can use `Schema.Data` to automatically include the `Equal` and\n *   `Hash` traits in the decoded objects. This is particularly important when\n *   working with `HashSet`. **For decoded objects to be correctly recognized as\n *   equal within a `HashSet`, ensure that the schema for those objects is\n *   defined using `Schema.Data`.**\n *\n * ```ts\n * import { Equal, HashSet, Schema } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Schema.Data implements the `Equal` traits for us\n * const PersonSchema = Schema.Data(\n *   Schema.Struct({\n *     id: Schema.Number,\n *     name: Schema.String,\n *     age: Schema.Number\n *   })\n * )\n *\n * const Person = Schema.decode(PersonSchema)\n *\n * const person1 = Person({ id: 1, name: \"Alice\", age: 30 })\n * const person2 = Person({ id: 1, name: \"Alice\", age: 30 })\n *\n * assert(Equal.equals(person1, person2)) // Output: true\n *\n * const set = HashSet.empty().pipe(\n *   HashSet.add(person1),\n *   HashSet.add(person2)\n * )\n *\n * // HashSet thanks to Schema.Data implementation of the `Equal` trait, recognizes the two Person as equal, so only one element is stored\n * console.log(HashSet.size(set)) // Output: 1\n * ```\n *\n * ### Interoperability with the JavaScript Runtime:\n *\n * To interoperate with the regular JavaScript runtime, Effect's `HashSet`\n * provides methods to access its elements in formats readily usable by\n * JavaScript APIs: {@link values `HashSet.values`},\n * {@link toValues `HashSet.toValues`}\n *\n * ```ts\n * import { HashSet } from \"effect\"\n *\n * const hashSet: HashSet.HashSet<number> = HashSet.make(1, 2, 3)\n *\n * // Using HashSet.values to convert HashSet.HashSet<A> to IterableIterator<A>\n * const iterable: IterableIterator<number> = HashSet.values(hashSet)\n *\n * console.log(...iterable) // Logs:  1 2 3\n *\n * // Using HashSet.toValues to convert HashSet.HashSet<A> to Array<A>\n * const array: Array<number> = HashSet.toValues(hashSet)\n *\n * console.log(array) // Logs: [ 1, 2, 3 ]\n * ```\n *\n * Be mindful of performance implications (both time and space complexity) when\n * frequently converting between Effect's immutable HashSet and mutable\n * JavaScript data structures, especially for large collections.\n *\n * @module HashSet\n * @since 2.0.0\n */\n\nimport type { Equal } from \"./Equal.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as HS from \"./internal/hashSet.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = HS.HashSetTypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @memberof HashSet\n * @since 2.0.0\n * @category models\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet } from \"effect\"\n *\n * let numberSet: HashSet.HashSet<number>\n * ```\n *\n * @interface\n */\nexport interface HashSet<out A> extends Iterable<A>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}\n\n/**\n * @memberof HashSet\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashSet: {\n  /**\n   * Type guard function to determine if a given iterable is a `HashSet`.\n   *\n   * This overload preserves the type of the iterable's elements.\n   *\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   *\n   * const numberIterable: Iterable<1 | 2 | 3> = [1, 2, 3]\n   *\n   * if (\n   *   // if passed an Iterable<A> the type guard that preserves the type parameter <A>\n   *   HashSet.isHashSet(numberIterable)\n   * ) {\n   *   const HashSet: HashSet.HashSet<1 | 2 | 3> = numberIterable\n   * }\n   * ```\n   *\n   * @param u - The iterable input to be checked.\n   * @returns A boolean indicating whether the provided iterable is a `HashSet`.\n   */\n  <A>(u: Iterable<A>): u is HashSet<A>\n\n  /**\n   * Type guard function that checks if the provided value is a `HashSet` of\n   * unknown type.\n   *\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // Check if a value is a HashSet\n   * const set = HashSet.make(1, 2, 3)\n   *\n   * assert.equal(HashSet.isHashSet(set), true) // true\n   * assert.equal(HashSet.isHashSet(HashSet.empty()), true)\n   *\n   * // Works with any type\n   * assert.equal(HashSet.isHashSet(null), false) // false\n   * assert.equal(HashSet.isHashSet({}), false) // false\n   * assert.equal(HashSet.isHashSet([1, 2, 3]), false) // false\n   * ```\n   *\n   * @param u - The value to check.\n   * @returns A boolean indicating whether the value is a `HashSet<unknown>`.\n   */\n  (u: unknown): u is HashSet<unknown>\n} = HS.isHashSet\n\n/**\n * Creates an empty `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // Provide a type argument to create a HashSet of a specific type\n *     HashSet.empty<number>(),\n *     HashSet.add(1),\n *     HashSet.add(1), // Notice the duplicate\n *     HashSet.add(2),\n *     HashSet.toValues\n *   )\n * ) // Output: [1, 2]\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.make} {@link module:HashSet.fromIterable}\n */\nexport const empty: <A = never>() => HashSet<A> = HS.empty\n\n/**\n * Creates a new `HashSet` from an iterable collection of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the iterable\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * // Creating a HashSet from an Array\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.\n *     HashSet.fromIterable,\n *     HashSet.toValues\n *   )\n * ) // Output: [1, 2, 3, 4, 5]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from a Set\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     new Set([\"apple\", \"banana\", \"orange\", \"apple\"]), // Set<string> is an Iterable<string>\n *     HashSet.fromIterable,\n *     HashSet.toValues\n *   )\n * ) // Output: [\"apple\", \"banana\", \"orange\"]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from a Generator\n * import { HashSet } from \"effect\"\n *\n * // Generator functions return iterables\n * function* fibonacci(n: number): Generator<number, void, unknown> {\n *   let [a, b] = [0, 1]\n *   for (let i = 0; i < n; i++) {\n *     yield a\n *     ;[a, b] = [b, a + b]\n *   }\n * }\n *\n * // Create a HashSet from the first 10 Fibonacci numbers\n * const fibonacciSet = HashSet.fromIterable(fibonacci(10))\n *\n * console.log(HashSet.toValues(fibonacciSet))\n * // Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n * ```\n *\n * @example\n *\n * ```ts\n * //  Creating a HashSet from another HashSet\n * import { HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // since HashSet implements the Iterable interface, we can use it to create a new HashSet\n *     HashSet.make(1, 2, 3, 4),\n *     HashSet.fromIterable,\n *     HashSet.toValues // turns the HashSet back into an array\n *   )\n * ) // Output: [1, 2, 3, 4]\n * ```\n *\n * @example\n *\n * ```ts\n * // Creating a HashSet from other Effect's data structures like Chunk\n * import { Chunk, HashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     Chunk.make(1, 2, 3, 4), // Iterable<number>\n *     HashSet.fromIterable,\n *     HashSet.toValues // turns the HashSet back into an array\n *   )\n * ) // Outputs: [1, 2, 3, 4]\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.empty} {@link module:HashSet.make}\n */\nexport const fromIterable: <A>(elements: Iterable<A>) => HashSet<A> = HS.fromIterable\n\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { Equal, Hash, HashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * class Character implements Equal.Equal {\n *   readonly name: string\n *   readonly trait: string\n *\n *   constructor(name: string, trait: string) {\n *     this.name = name\n *     this.trait = trait\n *   }\n *\n *   // Define equality based on name, and trait\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Character) {\n *       return (\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.trait, that.trait)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the sum of the character's name and trait\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.name + this.trait)\n *   }\n *\n *   static readonly of = (name: string, trait: string): Character => {\n *     return new Character(name, trait)\n *   }\n * }\n *\n * assert.strictEqual(\n *   Equal.equals(\n *     HashSet.make(\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ),\n *     // Is the same as adding each character to an empty set\n *     pipe(\n *       HashSet.empty(),\n *       HashSet.add(Character.of(\"Alice\", \"Curious\")),\n *       HashSet.add(Character.of(\"Alice\", \"Curious\")), // Alice tried to attend twice!\n *       HashSet.add(Character.of(\"White Rabbit\", \"Always late\")),\n *       HashSet.add(Character.of(\"Mad Hatter\", \"Tea enthusiast\"))\n *     )\n *   ),\n *   true,\n *   \"`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal\"\n * )\n *\n * assert.strictEqual(\n *   Equal.equals(\n *     HashSet.make(\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ),\n *     HashSet.fromIterable([\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"Alice\", \"Curious\"),\n *       Character.of(\"White Rabbit\", \"Always late\"),\n *       Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n *     ])\n *   ),\n *   true,\n *   \"`HashSet.make` and `HashSet.fromIterable` should be equal\"\n * )\n * ```\n *\n * @see Other `HashSet` constructors are {@link module:HashSet.fromIterable} {@link module:HashSet.empty}\n */\nexport const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]> = HS.make\n\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false\n *\n * // or with `data-first` API\n * HashSet.has(HashSet.make(0, 1, 2), 3) // false\n * ```\n *\n * @returns A `boolean` signaling the presence of the value in the HashSet\n * @see Other `HashSet` elements are {@link module:HashSet.some} {@link module:HashSet.every} {@link module:HashSet.isSubset}\n */\nexport const has: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(pipe(set, HashSet.has(0)), true)\n   * assert.equal(pipe(set, HashSet.has(1)), true)\n   * assert.equal(pipe(set, HashSet.has(2)), true)\n   * assert.equal(pipe(set, HashSet.has(3)), false)\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(HashSet.has(set, 0), true)\n   * assert.equal(HashSet.has(set, 1), true)\n   * assert.equal(HashSet.has(set, 2), true)\n   * assert.equal(HashSet.has(set, 3), false)\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): boolean\n} = HS.has\n\n/**\n * Check if a predicate holds true for some `HashSet` element.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   set,\n *   HashSet.some((n) => n > 0)\n * ) // true\n *\n * // or piped with the pipe function\n * set.pipe(HashSet.some((n) => n > 0)) // true\n *\n * // or with `data-first` API\n * HashSet.some(set, (n) => n > 0) // true\n * ```\n *\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.every} {@link module:HashSet.isSubset}\n */\nexport const some: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   pipe(\n   *     set,\n   *     HashSet.some((n) => n > 0)\n   *   ),\n   *   true\n   * )\n   *\n   * assert.equal(\n   *   pipe(\n   *     set,\n   *     HashSet.some((n) => n > 2)\n   *   ),\n   *   false\n   * )\n   * ```\n   */\n  <A>(f: Predicate<A>): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   HashSet.some(set, (n) => n > 0),\n   *   true\n   * )\n   *\n   * assert.equal(\n   *   HashSet.some(set, (n) => n > 2),\n   *   false\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, f: Predicate<A>): boolean\n} = HS.some\n\n/**\n * Check if a predicate holds true for every `HashSet` element.\n *\n * Time complexity is **`O(n)`** as it needs to traverse the whole HashSet\n * collection\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax with Refinement\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * const numberOrString = HashSet.make(1, \"1\", \"one\", \"uno\")\n *\n * // with `data-last`, a.k.a. `pipeable` API and `Refinement`\n * pipe(\n *   numberOrString, // HashSet.HashSet<number | string>\n *   HashSet.every(Predicate.isString)\n * ) // HashSet.HashSet<string>\n *\n * // or piped with the pipe function and  `Refinement`\n * numberOrString // HashSet.HashSet<number | string>\n *   .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>\n *\n * // or with `data-first` API and `Refinement`\n * HashSet.every(\n *   numberOrString, // HashSet.HashSet<number | string>\n *   Predicate.isString\n * ) // HashSet.HashSet<string>\n * ```\n *\n * @example\n *\n * ```ts\n * // Syntax with Predicate\n * import { HashSet, pipe } from \"effect\"\n *\n * const set = HashSet.make(1, 2, 3)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   set,\n *   HashSet.every((n) => n >= 0)\n * ) // true\n *\n * // or piped with the pipe function\n * set.pipe(HashSet.every((n) => n >= 0)) // true\n *\n * // or with `data-first` API\n * HashSet.every(set, (n) => n >= 0) // true\n * ```\n *\n * @returns A boolean once it has evaluated that whole collection fulfill the\n *   Predicate function\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.isSubset}\n */\nexport const every: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { Effect, HashSet, pipe, Predicate } from \"effect\"\n   *\n   * const numberOrString: HashSet.HashSet<number | string> = HashSet.make(\n   *   1,\n   *   \"1\",\n   *   \"one\",\n   *   \"uno\"\n   * )\n   *\n   * assert.equal(\n   *   pipe(\n   *     numberOrString, // HashSet.HashSet<number | string>\n   *     HashSet.every(Predicate.isString)\n   *   ), // HashSet.HashSet<string>\n   *   false\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (self: HashSet<A>) => self is HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet, pipe } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   pipe(\n   *     set,\n   *     HashSet.every((n) => n >= 0)\n   *   ),\n   *   true\n   * )\n   * ```\n   */\n  <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { Effect, HashSet, pipe, Predicate } from \"effect\"\n   *\n   * const numberOrString: HashSet.HashSet<number | string> = HashSet.make(\n   *   1,\n   *   \"1\",\n   *   \"one\",\n   *   \"uno\"\n   * )\n   *\n   * assert.equal(\n   *   HashSet.every(\n   *     numberOrString, // HashSet.HashSet<number | string>\n   *     Predicate.isString\n   *   ), // HashSet.HashSet<string>\n   *   false\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    self: HashSet<A>,\n    refinement: Refinement<A, B>\n  ): self is HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { HashSet } from \"effect\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   *\n   * assert.equal(\n   *   HashSet.every(set, (n) => n >= 0),\n   *   true\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, predicate: Predicate<A>): boolean\n} = HS.every\n\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * Time complexity analysis is of **`O(n)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const set1 = HashSet.make(0, 1)\n * const set2 = HashSet.make(1, 2)\n * const set3 = HashSet.make(0, 1, 2)\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(set1, HashSet.isSubset(set2)) // false\n * pipe(set1, HashSet.isSubset(set3)) // true\n *\n * // or piped with the pipe function\n * set1.pipe(HashSet.isSubset(set2)) // false\n * set1.pipe(HashSet.isSubset(set3)) // true\n *\n * // or with `data-first` API\n * HashSet.isSubset(set1, set2) // false\n * HashSet.isSubset(set1, set3) // true)\n * ```\n *\n * @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.every}\n */\nexport const isSubset: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(\n   *   pipe(\n   *     HashSet.make(0, 1), //\n   *     HashSet.isSubset(HashSet.make(1, 2))\n   *   ),\n   *   false\n   * )\n   *\n   * assert.equal(\n   *   pipe(\n   *     HashSet.make(0, 1), //\n   *     HashSet.isSubset(HashSet.make(0, 1, 2))\n   *   ),\n   *   true\n   * )\n   * ```\n   */\n  <A>(that: HashSet<A>): (self: HashSet<A>) => boolean\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(HashSet.isSubset(set1, set2), false)\n   *\n   * assert.equal(HashSet.isSubset(set1, set3), true)\n   * ```\n   */\n  <A>(self: HashSet<A>, that: HashSet<A>): boolean\n} = HS.isSubset\n\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n *\n * const numberIterable = pipe(\n *   HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>\n *   HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>\n * )\n *\n * for (const number of numberIterable) {\n *   console.log(number) // it will logs: 0, 1, 2\n * }\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.toValues} {@link module:HashSet.size}\n */\nexport const values: <A>(self: HashSet<A>) => IterableIterator<A> = HS.values\n\n/**\n * Returns an `Array` of the values within the `HashSet`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * @memberof HashSet\n * @since 3.13.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n * import { deepStrictEqual } from \"node:assert/strict\"\n *\n * deepStrictEqual(\n *   pipe(\n *     HashSet.make(0, 1, 1, 2), // HashSet<number>\n *     HashSet.toValues // takes an HashSet<A> and returns an Array<A>\n *   ),\n *   Array.of(0, 1, 2)\n * )\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.size}\n */\nexport const toValues = <A>(self: HashSet<A>): Array<A> => Array.from(values(self))\n\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category getters\n * @example\n *\n * ```ts\n * import { HashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)\n *\n * assert.deepStrictEqual(\n *   pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),\n *   4\n * )\n * ```\n *\n * @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.toValues}\n */\nexport const size: <A>(self: HashSet<A>) => number = HS.size\n\n/**\n * Creates a new mutable version of the `HashSet`\n *\n * When a `HashSet` is mutable, operations like {@link add} and {@link remove}\n * modify the data structure in place instead of creating a new one, which is\n * more efficient when performing multiple operations.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * import { HashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * const UPPER_BOUND = 10_000\n *\n * const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))\n *\n * // Create a mutable version of the immutableSet\n * const mutableSet = HashSet.beginMutation(immutableSet)\n *\n * for (let i = 1; i < UPPER_BOUND; i++) {\n *   // Operations now modify the set in place instead of creating new instances\n *   // This is more efficient when making multiple changes\n *   const pointerToMutableSet = HashSet.add(mutableSet, i)\n *\n *   // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance\n *   assert(Object.is(mutableSet, pointerToMutableSet))\n *   assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet\n *   assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet\n * }\n *\n * const next = UPPER_BOUND + 1\n * // When done, mark the set as immutable again\n * HashSet.endMutation(mutableSet).pipe(\n *   HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet\n * )\n * assert.equal(HashSet.has(mutableSet, next), false)\n *\n * console.log(HashSet.toValues(immutableSet)) // [0]\n * console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const beginMutation: <A>(self: HashSet<A>) => HashSet<A> = HS.beginMutation\n\n/**\n * Makes the `HashSet` immutable again.\n *\n * After calling `endMutation`, operations like {@link add} and {@link remove}\n * will create new instances of the `HashSet` instead of modifying the existing\n * one.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * import { HashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * // Create a mutable set\n * const mutableSet = HashSet.beginMutation(HashSet.empty<number>())\n *\n * // Add some elements to the mutable set\n * HashSet.add(mutableSet, 1)\n * HashSet.add(mutableSet, 2)\n *\n * // Before endMutation, operations modify the set in place\n * const sameSet = HashSet.add(mutableSet, 3)\n * assert(Object.is(mutableSet, sameSet)) // true - same object reference\n * assert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])\n *\n * // Make the set immutable again\n * const immutableSet = HashSet.endMutation(mutableSet)\n *\n * // endMutation returns the same set instance, now made immutable\n * assert(Object.is(mutableSet, immutableSet)) // true - same object reference\n *\n * // After endMutation, operations create new instances\n * const newSet = HashSet.add(immutableSet, 4)\n * assert(!Object.is(immutableSet, newSet)) // false - different object references\n *\n * // The original set remains unchanged\n * assert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])\n *\n * // The new set contains the added element\n * assert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.mutate}\n */\nexport const endMutation: <A>(self: HashSet<A>) => HashSet<A> = HS.endMutation\n\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * You can consider it a functional abstraction on top of the lower-level\n * mutation primitives of {@link module:HashSet.beginMutation} `->` `mutable\n * context` `->` {@link HashSet.endMutation}.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(\n *   HashSet.make(1, 2, 3),\n *   HashSet.mutate((set) => {\n *     HashSet.add(set, 4)\n *     HashSet.remove(set, 1)\n *   })\n * )\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(\n *   HashSet.mutate((set) => {\n *     HashSet.add(set, 4)\n *     HashSet.remove(set, 1)\n *   })\n * )\n *\n * // or with data-first API\n * HashSet.mutate(HashSet.make(1, 2, 3), (set) => {\n *   HashSet.add(set, 4)\n *   HashSet.remove(set, 1)\n * })\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation}\n */\nexport const mutate: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // Create a set with initial values\n   * const immutableSet = HashSet.make(1, 2, 3)\n   *\n   * // Use mutate to perform multiple operations efficiently\n   * const result = pipe(\n   *   immutableSet,\n   *   HashSet.mutate((set) => {\n   *     assert.equal(Object.is(immutableSet, set), false)\n   *\n   *     // The set is temporarily mutable inside this function\n   *     const mod1 = HashSet.add(set, 4)\n   *     const mod2 = HashSet.remove(set, 1)\n   *     assert.equal(Object.is(mod1, mod2), true) // they are the same object by reference\n   *   })\n   * )\n   *\n   * // The original set is unchanged\n   * assert.equal(Object.is(immutableSet, result), false)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(immutableSet).sort(),\n   *   [1, 2, 3]\n   * )\n   *\n   * // The result contains the mutations\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3, 4])\n   * ```\n   */\n  <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // Create a set with initial values\n   * const immutableSet = HashSet.make(1, 2, 3)\n   *\n   * // Use mutate with data-first API\n   * const result = HashSet.mutate(immutableSet, (set) => {\n   *   // The set is temporarily mutable inside this function\n   *   HashSet.add(set, 4)\n   *   HashSet.remove(set, 1)\n   * })\n   *\n   * // The original set is unchanged\n   * assert.equal(Object.is(immutableSet, result), false)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(immutableSet).sort(),\n   *   [1, 2, 3]\n   * )\n   *\n   * // The result contains the mutations\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3, 4])\n   * ```\n   */\n  <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>\n} = HS.mutate\n\n/**\n * Adds a value to the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @remarks\n * Remember that a `HashSet` is a collection of unique values, so adding a value\n * that already exists in the `HashSet` will not add a duplicate.\n *\n * Remember that HashSet is an immutable data structure, so the `add` function,\n * like all other functions that modify the HashSet, will return a new HashSet\n * with the added value.\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))\n *\n * // or piped with the pipe function\n * HashSet.empty().pipe(HashSet.add(0))\n *\n * // or with data-first API\n * HashSet.add(HashSet.empty(), 0)\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const add: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.empty<number>(), // HashSet.HashSet<number>\n   *     HashSet.add(0),\n   *     HashSet.add(1),\n   *     HashSet.add(1),\n   *     HashSet.add(2),\n   *     HashSet.toValues\n   *   ),\n   *   Array.of(0, 1, 2)\n   * )\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * const empty = HashSet.empty<number>()\n   * const withZero = HashSet.add(empty, 0)\n   * const withOne = HashSet.add(withZero, 1)\n   * const withTwo = HashSet.add(withOne, 2)\n   * const withTwoTwo = HashSet.add(withTwo, 2)\n   *\n   * assert.deepStrictEqual(HashSet.toValues(withTwoTwo), Array.of(0, 1, 2))\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): HashSet<A>\n} = HS.add\n\n/**\n * Removes a value from the `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.remove(0))\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.remove(0))\n *\n * // or with `data-first` API\n * HashSet.remove(HashSet.make(0, 1, 2), 0)\n * ```\n *\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const remove: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   * const result = pipe(set, HashSet.remove(0))\n   *\n   * assert.equal(pipe(result, HashSet.has(0)), false) // it has correctly removed 0\n   * assert.equal(pipe(set, HashSet.has(0)), true) // it does not mutate the original set\n   * assert.equal(pipe(result, HashSet.has(1)), true)\n   * assert.equal(pipe(result, HashSet.has(2)), true)\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const set = HashSet.make(0, 1, 2)\n   * const result = HashSet.remove(set, 0)\n   *\n   * assert.equal(HashSet.has(result, 0), false) // it has correctly removed 0\n   * assert.equal(HashSet.has(set, 0), true) // it does not mutate the original set\n   * assert.equal(HashSet.has(result, 1), true)\n   * assert.equal(HashSet.has(result, 2), true)\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): HashSet<A>\n} = HS.remove\n\n/**\n * Computes the set difference `(A - B)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same; meaning we cannot compute a difference between a `HashSet\n * of bananas` and a `HashSet of elephants` as they are not the same type and\n * won't implement the Equal trait in the same way.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))\n *\n * // or with data-first API\n * HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.intersection} {@link module:HashSet.union}\n */\nexport const difference: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const thisSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the difference (elements in thisSet that are not in thatIterable)\n   * const result = pipe(thisSet, HashSet.difference(thatIterable))\n   *\n   * // The result contains only elements from thisSet that are not in thatIterable\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [1, 2])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(thisSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also use arrays or other iterables\n   * const diffWithArray = pipe(thisSet, HashSet.difference([3, 4]))\n   * assert.deepStrictEqual(HashSet.toValues(diffWithArray).sort(), [1, 2])\n   * ```\n   */\n  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const thisSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the difference using data-first API\n   * const result = HashSet.difference(thisSet, thatIterable)\n   *\n   * // The result contains only elements from thisSet that are not in thatIterable\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [1, 2])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(thisSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also compute the difference in the other direction\n   * const reverseResult = HashSet.difference(thatIterable, thisSet)\n   * assert.deepStrictEqual(HashSet.toValues(reverseResult).sort(), [4, 5])\n   * ```\n   */\n  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>\n} = HS.difference\n\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`. Computes set intersection (A  B)\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the smaller\n * set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))\n *\n * // or with data-first API\n * HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.union}\n */\nexport const intersection: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const set1 = HashSet.make(1, 2, 3)\n   * const set2 = HashSet.make(2, 3, 4)\n   *\n   * // Compute the intersection (elements that are in both sets)\n   * const result = pipe(set1, HashSet.intersection(set2))\n   *\n   * // The result contains only elements that are in both sets\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(set1).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(HashSet.toValues(set2).sort(), [2, 3, 4])\n   *\n   * // You can also use arrays or other iterables\n   * const intersectWithArray = pipe(set1, HashSet.intersection([2, 3, 5]))\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(intersectWithArray).sort(),\n   *   [2, 3]\n   * )\n   * ```\n   */\n  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const set1 = HashSet.make(1, 2, 3)\n   * const set2 = HashSet.make(2, 3, 4)\n   *\n   * // Compute the intersection using data-first API\n   * const result = HashSet.intersection(set1, set2)\n   *\n   * // The result contains only elements that are in both sets\n   * assert.deepStrictEqual(HashSet.toValues(result).sort(), [2, 3])\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(set1).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(HashSet.toValues(set2).sort(), [2, 3, 4])\n   *\n   * // You can also use arrays or other iterables\n   * const intersectWithArray = HashSet.intersection(set1, [2, 3, 5])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(intersectWithArray).sort(),\n   *   [2, 3]\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>\n} = HS.intersection\n\n/**\n * Computes the set union `( self  that )` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the set\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))\n *\n * // or piped with the pipe function\n * HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))\n *\n * // or with data-first API\n * HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))\n * ```\n *\n * @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.intersection}\n */\nexport const union: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const selfSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the union (all elements from both sets)\n   * const result = pipe(selfSet, HashSet.union(thatIterable))\n   *\n   * // The result contains all elements from both sets (without duplicates)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(result).sort(),\n   *   [1, 2, 3, 4, 5]\n   * )\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(selfSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also use arrays or other iterables\n   * const unionWithArray = pipe(selfSet, HashSet.union([4, 5, 6]))\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(unionWithArray).sort(),\n   *   [1, 2, 3, 4, 5, 6]\n   * )\n   * ```\n   */\n  <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * // Create two sets with some overlapping elements\n   * const selfSet = HashSet.make(1, 2, 3)\n   * const thatIterable = HashSet.make(3, 4, 5)\n   *\n   * // Compute the union using data-first API\n   * const result = HashSet.union(selfSet, thatIterable)\n   *\n   * // The result contains all elements from both sets (without duplicates)\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(result).sort(),\n   *   [1, 2, 3, 4, 5]\n   * )\n   *\n   * // The original sets are unchanged\n   * assert.deepStrictEqual(HashSet.toValues(selfSet).sort(), [1, 2, 3])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(thatIterable).sort(),\n   *   [3, 4, 5]\n   * )\n   *\n   * // You can also use arrays or other iterables\n   * const unionWithArray = HashSet.union(selfSet, [4, 5, 6])\n   * assert.deepStrictEqual(\n   *   HashSet.toValues(unionWithArray).sort(),\n   *   [1, 2, 3, 4, 5, 6]\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>\n} = HS.union\n\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * @memberof HashSet\n * @since 2.0.0\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))\n *\n * // or piped with the pipe function\n * HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))\n *\n * // or with `data-first` API\n * HashSet.toggle(HashSet.make(0, 1, 2), 0)\n * ```\n *\n * @returns A new `HashSet` where the toggled value is being either added or\n *   removed based on the initial `HashSet` state.\n * @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}\n */\nexport const toggle: {\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-last` a.k.a. `pipeable` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // arrange\n   * let set = HashSet.make(0, 1, 2)\n   *\n   * // assert 1: 0 is in the set\n   * assert.equal(pipe(set, HashSet.has(0)), true)\n   *\n   * // act 2: toggle 0 once on the set\n   * set = pipe(set, HashSet.toggle(0))\n   *\n   * // assert 2: 0 is not in the set any longer\n   * assert.equal(pipe(set, HashSet.has(0)), false)\n   *\n   * // act 3: toggle 0 once again on the set\n   * set = pipe(set, HashSet.toggle(0))\n   *\n   * // assert 3: 0 in now back in the set\n   * assert.equal(pipe(set, HashSet.has(0)), true)\n   * ```\n   */\n  <A>(value: A): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * // `data-first` API\n   * import { HashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * // arrange\n   * let set = HashSet.make(0, 1, 2)\n   *\n   * // assert 1: 0 is in the set\n   * assert.equal(HashSet.has(set, 0), true)\n   *\n   * // act 2: toggle 0 once on the set\n   * set = HashSet.toggle(set, 0)\n   *\n   * // assert 2: 0 is not in the set any longer\n   * assert.equal(HashSet.has(set, 0), false)\n   *\n   * // act 3: toggle 0 once again on the set\n   * set = HashSet.toggle(set, 0)\n   *\n   * // assert 3: 0 in now back in the set\n   * assert.equal(HashSet.has(set, 0), true)\n   * ```\n   */\n  <A>(self: HashSet<A>, value: A): HashSet<A>\n} = HS.toggle\n\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category mapping\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n *   HashSet.map(String) // HashSet.HashSet<string>\n * )\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.map(String))\n *\n * // or with `data-first` API\n * HashSet.map(HashSet.make(0, 1, 2), String)\n * ```\n */\nexport const map: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.make(0, 1, 2), //    HashSet.HashSet<number>\n   *     HashSet.map((n) => String(n + 1)) // HashSet.HashSet<String>\n   *   ),\n   *   HashSet.make(\"1\", \"2\", \"3\")\n   * )\n   * ```\n   */\n  <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   HashSet.map(\n   *     HashSet.make(0, 1, 2), //    HashSet.HashSet<number>\n   *     (n) => String(n + 1)\n   *   ), // HashSet.HashSet<String>\n   *   HashSet.make(\"1\", \"2\", \"3\")\n   * )\n   * ```\n   */\n  <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>\n} = HS.map\n\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category sequencing\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n *   HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n * )\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2) // HashSet.HashSet<number>\n *   .pipe(\n *     HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n *   )\n *\n * // or with `data-first` API\n * HashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))\n * ```\n */\nexport const flatMap: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, List } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.make(0, 1, 2),\n   *     HashSet.flatMap((n) => List.of(String(n * n))) // needs to return an Iterable\n   *   ),\n   *   HashSet.make(\"0\", \"1\", \"4\")\n   * )\n   * ```\n   */\n  <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, List } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.deepStrictEqual(\n   *   HashSet.flatMap(HashSet.make(0, 1, 2), (n) =>\n   *     List.of(String(n * n * n))\n   *   ), // needs to return an Iterable\n   *   HashSet.make(\"0\", \"1\", \"8\")\n   * )\n   * ```\n   */\n  <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>\n} = HS.flatMap\n\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category traversing\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2\n *\n * // or piped with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2\n *\n * // or with `data-first` API\n * HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2\n * ```\n */\nexport const forEach: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const result: Array<number> = []\n   *\n   * pipe(\n   *   HashSet.make(0, 1, 2),\n   *   HashSet.forEach((n): void => {\n   *     result.push(n)\n   *   })\n   * )\n   *\n   * assert.deepStrictEqual(result, [0, 1, 2])\n   * ```\n   */\n  <A>(f: (value: A) => void): (self: HashSet<A>) => void\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const result: Array<number> = []\n   *\n   * HashSet.forEach(HashSet.make(0, 1, 2), (n): void => {\n   *   result.push(n)\n   * })\n   *\n   * assert.deepStrictEqual(result, [0, 1, 2])\n   * ```\n   */\n  <A>(self: HashSet<A>, f: (value: A) => void): void\n} = HS.forEach\n\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category folding\n * @example\n *\n * ```ts\n * // Syntax\n * import { HashSet, pipe } from \"effect\"\n *\n * const sum = (a: number, b: number): number => a + b\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))\n *\n * // or with the pipe method\n * HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))\n *\n * // or with `data-first` API\n * HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)\n * ```\n */\nexport const reduce: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(\n   *   pipe(\n   *     HashSet.make(0, 1, 2),\n   *     HashSet.reduce(10, (accumulator, value) => accumulator + value)\n   *   ),\n   *   13\n   * )\n   * ```\n   */\n  <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * assert.equal(\n   *   HashSet.reduce(\n   *     HashSet.make(0, 1, 2),\n   *     -3,\n   *     (accumulator, value) => accumulator + value\n   *   ),\n   *   0\n   * )\n   * ```\n   */\n  <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z\n} = HS.reduce\n\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * The time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category filtering\n * @example\n *\n * ```ts\n * // Syntax with  Predicate\n * import { HashSet, type Predicate, pipe } from \"effect\"\n *\n * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(-2, -1, 0, 1, 2),\n *   HashSet.filter(filterPositiveNumbers)\n * )\n *\n * // or with the pipe method\n * HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))\n *\n * // or with `data-first` API\n * HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)\n * ```\n *\n * @example\n *\n * ```ts\n * /// Syntax with Refinement\n * import { HashSet, pipe } from \"effect\"\n *\n * const stringRefinement = (value: unknown): value is string =>\n *   typeof value === \"string\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // // HashSet.HashSet<number | string>\n *   HashSet.filter(stringRefinement)\n * ) // HashSet.HashSet<string>\n *\n * // or with the pipe method\n * HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\") // HashSet.HashSet<number | string>\n *   .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>\n *\n * // or with `data-first` API\n * HashSet.filter(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"), // HashSet.HashSet<number | string>\n *   stringRefinement\n * ) // HashSet.HashSet<string>\n * ```\n */\nexport const filter: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const stringHashSet: HashSet.HashSet<string> = pipe(\n   *   numbersAndStringsHashSet,\n   *   HashSet.filter(stringRefinement)\n   * )\n   *\n   * assert.equal(\n   *   pipe(stringHashSet, HashSet.every(Predicate.isString)),\n   *   true\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (self: HashSet<A>) => HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, type Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   pipe(\n   *     HashSet.make(-2, -1, 0, 1, 2),\n   *     HashSet.filter(filterPositiveNumbers)\n   *   ),\n   *   HashSet.make(1, 2)\n   * )\n   * ```\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const stringHashSet: HashSet.HashSet<string> = HashSet.filter(\n   *   numbersAndStringsHashSet,\n   *   stringRefinement\n   * )\n   *\n   * assert.equal(HashSet.every(stringHashSet, Predicate.isString), true)\n   * ```\n   */\n  <A, B extends A>(\n    self: HashSet<A>,\n    refinement: Refinement<A, B>\n  ): HashSet<B>\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, type Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n   *\n   * assert.deepStrictEqual(\n   *   HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers),\n   *   HashSet.make(1, 2)\n   * )\n   * ```\n   */\n  <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>\n} = HS.filter\n\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * Time complexity is of **`O(n)`**.\n *\n * @memberof HashSet\n * @since 2.0.0\n * @category partitioning\n * @example\n *\n * ```ts\n * // Syntax with Predicate\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(0, 1, 2, 3, 4, 5),\n *   HashSet.partition((n) => n % 2 === 0)\n * )\n *\n * // or with the pipe method\n * HashSet.make(0, 1, 2, 3, 4, 5).pipe(\n *   HashSet.partition((n) => n % 2 === 0)\n * )\n *\n * // or with `data-first` API\n * HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)\n * ```\n *\n * @example\n *\n * ```ts\n * // Syntax with Refinement\n * import { HashSet, pipe, Predicate } from \"effect\"\n *\n * const stringRefinement: Predicate.Refinement<string | number, string> = (\n *   value\n * ) => typeof value === \"string\"\n *\n * // with `data-last`, a.k.a. `pipeable` API\n * pipe(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n *   HashSet.partition(stringRefinement)\n * )\n *\n * // or with the pipe method\n * HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\").pipe(\n *   HashSet.partition(stringRefinement)\n * )\n *\n * // or with `data-first` API\n * HashSet.partition(\n *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\"),\n *   stringRefinement\n * )\n * ```\n */\nexport const partition: {\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const [\n   *   excluded, // HashSet.HashSet<number>\n   *   satisfying // HashSet.HashSet<string>\n   * ] = pipe(numbersAndStringsHashSet, HashSet.partition(stringRefinement))\n   *\n   * assert.equal(pipe(satisfying, HashSet.every(Predicate.isString)), true)\n   * assert.equal(pipe(excluded, HashSet.every(Predicate.isNumber)), true)\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 2, 3, 4))\n   * assert.deepStrictEqual(\n   *   satisfying,\n   *   HashSet.make(\"unos\", \"two\", \"trois\", \"vier\")\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>\n  ): (\n    self: HashSet<A>\n  ) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const [excluded, satisfying] = pipe(\n   *   HashSet.make(0, 1, 2, 3, 4, 5),\n   *   HashSet.partition((n) => n % 2 === 0)\n   * )\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 3, 5))\n   * assert.deepStrictEqual(satisfying, HashSet.make(0, 2, 4))\n   * ```\n   */\n  <A>(\n    predicate: Predicate<NoInfer<A>>\n  ): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet, pipe, Predicate } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const numbersAndStringsHashSet: HashSet.HashSet<number | string> =\n   *   HashSet.make(1, \"unos\", 2, \"two\", 3, \"trois\", 4, \"vier\")\n   *\n   * const stringRefinement: Predicate.Refinement<\n   *   string | number,\n   *   string\n   * > = (value) => typeof value === \"string\"\n   *\n   * const [\n   *   excluded, // HashSet.HashSet<number>\n   *   satisfying // HashSet.HashSet<string>\n   * ] = HashSet.partition(numbersAndStringsHashSet, stringRefinement)\n   *\n   * assert.equal(HashSet.every(satisfying, Predicate.isString), true)\n   * assert.equal(HashSet.every(excluded, Predicate.isNumber), true)\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 2, 3, 4))\n   * assert.deepStrictEqual(\n   *   satisfying,\n   *   HashSet.make(\"unos\", \"two\", \"trois\", \"vier\")\n   * )\n   * ```\n   */\n  <A, B extends A>(\n    self: HashSet<A>,\n    refinement: Refinement<A, B>\n  ): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]\n\n  /**\n   * @example\n   *\n   * ```ts\n   * import { HashSet } from \"effect\"\n   * import * as assert from \"node:assert/strict\"\n   *\n   * const [excluded, satisfying] = HashSet.partition(\n   *   HashSet.make(0, 1, 2, 3, 4, 5),\n   *   (n) => n % 2 === 0\n   * )\n   *\n   * assert.deepStrictEqual(excluded, HashSet.make(1, 3, 5))\n   * assert.deepStrictEqual(satisfying, HashSet.make(0, 2, 4))\n   * ```\n   */\n  <A>(\n    self: HashSet<A>,\n    predicate: Predicate<A>\n  ): [excluded: HashSet<A>, satisfying: HashSet<A>]\n} = HS.partition\n","import { dual } from \"../Function.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport type * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\n\n/** @internal */\nconst BIT_MASK = 0xff\n\n/** @internal */\nconst BIT_SHIFT = 0x08\n\n/** @internal */\nexport const active = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): number => patch & BIT_MASK\n\n/** @internal */\nexport const enabled = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): number => (patch >> BIT_SHIFT) & BIT_MASK\n\n/** @internal */\nexport const make = (active: number, enabled: number): RuntimeFlagsPatch.RuntimeFlagsPatch =>\n  ((active & BIT_MASK) + (((enabled & active) & BIT_MASK) << BIT_SHIFT)) as RuntimeFlagsPatch.RuntimeFlagsPatch\n\n/** @internal */\nexport const empty = make(0, 0)\n\n/** @internal */\nexport const enable = (flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch.RuntimeFlagsPatch => make(flag, flag)\n\n/** @internal */\nexport const disable = (flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch.RuntimeFlagsPatch => make(flag, 0)\n\n/** @internal */\nexport const isEmpty = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): boolean => patch === 0\n\n/** @internal */\nexport const isActive = dual<\n  (flag: RuntimeFlagsPatch.RuntimeFlagsPatch) => (self: RuntimeFlagsPatch.RuntimeFlagsPatch) => boolean,\n  (self: RuntimeFlagsPatch.RuntimeFlagsPatch, flag: RuntimeFlagsPatch.RuntimeFlagsPatch) => boolean\n>(2, (self, flag) => (active(self) & flag) !== 0)\n\n/** @internal */\nexport const isEnabled = dual<\n  (flag: RuntimeFlags.RuntimeFlag) => (self: RuntimeFlagsPatch.RuntimeFlagsPatch) => boolean,\n  (self: RuntimeFlagsPatch.RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag) => boolean\n>(2, (self, flag) => (enabled(self) & flag) !== 0)\n\n/** @internal */\nexport const isDisabled = dual<\n  (flag: RuntimeFlags.RuntimeFlag) => (self: RuntimeFlagsPatch.RuntimeFlagsPatch) => boolean,\n  (self: RuntimeFlagsPatch.RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag) => boolean\n>(2, (self, flag) => ((active(self) & flag) !== 0) && ((enabled(self) & flag) === 0))\n\n/** @internal */\nexport const exclude = dual<\n  (\n    flag: RuntimeFlags.RuntimeFlag\n  ) => (self: RuntimeFlagsPatch.RuntimeFlagsPatch) => RuntimeFlagsPatch.RuntimeFlagsPatch,\n  (self: RuntimeFlagsPatch.RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch.RuntimeFlagsPatch\n>(2, (self, flag) => make(active(self) & ~flag, enabled(self)))\n\n/** @internal */\nexport const both = dual<\n  (\n    that: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => (\n    self: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => RuntimeFlagsPatch.RuntimeFlagsPatch,\n  (\n    self: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    that: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => RuntimeFlagsPatch.RuntimeFlagsPatch\n>(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)))\n\n/** @internal */\nexport const either = dual<\n  (\n    that: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => (\n    self: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => RuntimeFlagsPatch.RuntimeFlagsPatch,\n  (\n    self: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    that: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => RuntimeFlagsPatch.RuntimeFlagsPatch\n>(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)))\n\n/** @internal */\nexport const andThen = dual<\n  (\n    that: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => (\n    self: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => RuntimeFlagsPatch.RuntimeFlagsPatch,\n  (\n    self: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    that: RuntimeFlagsPatch.RuntimeFlagsPatch\n  ) => RuntimeFlagsPatch.RuntimeFlagsPatch\n>(2, (self, that) => (self | that) as RuntimeFlagsPatch.RuntimeFlagsPatch)\n\n/** @internal */\nexport const inverse = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlagsPatch.RuntimeFlagsPatch =>\n  make(enabled(patch), invert(active(patch)))\n\n/** @internal */\nexport const invert = (n: number): number => (~n >>> 0) & BIT_MASK\n","import type { HashMap } from \"../../HashMap.js\"\nimport type { HashSet } from \"../../HashSet.js\"\nimport { makeImpl } from \"../hashSet.js\"\n\n/** @internal */\nexport function keySet<K, V>(self: HashMap<K, V>): HashSet<K> {\n  return makeImpl(self)\n}\n","import * as Equal from \"../Equal.js\"\nimport * as Hash from \"../Hash.js\"\nimport type * as Types from \"../Types.js\"\nimport { StructuralPrototype } from \"./effectable.js\"\n\n/** @internal */\nexport const ArrayProto: Equal.Equal = Object.assign(Object.create(Array.prototype), {\n  [Hash.symbol](this: Array<any>) {\n    return Hash.cached(this, Hash.array(this))\n  },\n  [Equal.symbol](this: Array<any>, that: Equal.Equal) {\n    if (Array.isArray(that) && this.length === that.length) {\n      return this.every((v, i) => Equal.equals(v, (that as Array<any>)[i]))\n    } else {\n      return false\n    }\n  }\n})\n\n/** @internal */\nexport const Structural: new<A>(\n  args: Types.Equals<Omit<A, keyof Equal.Equal>, {}> extends true ? void\n    : { readonly [P in keyof A as P extends keyof Equal.Equal ? never : P]: A[P] }\n) => {} = (function() {\n  function Structural(this: any, args: any) {\n    if (args) {\n      Object.assign(this, args)\n    }\n  }\n  Structural.prototype = StructuralPrototype\n  return Structural as any\n})()\n\n/** @internal */\nexport const struct = <As extends Readonly<Record<string, any>>>(as: As): As =>\n  Object.assign(Object.create(StructuralPrototype), as)\n","import * as Equal from \"../Equal.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\n\n/** @internal */\nconst FiberIdSymbolKey = \"effect/FiberId\"\n\n/** @internal */\nexport const FiberIdTypeId: FiberId.FiberIdTypeId = Symbol.for(\n  FiberIdSymbolKey\n) as FiberId.FiberIdTypeId\n\n/** @internal */\nconst OP_NONE = \"None\" as const\n\n/** @internal */\nexport type OP_NONE = typeof OP_NONE\n\n/** @internal */\nconst OP_RUNTIME = \"Runtime\" as const\n\n/** @internal */\nexport type OP_RUNTIME = typeof OP_RUNTIME\n\n/** @internal */\nconst OP_COMPOSITE = \"Composite\" as const\n\n/** @internal */\nexport type OP_COMPOSITE = typeof OP_COMPOSITE\n\nconst emptyHash = Hash.string(`${FiberIdSymbolKey}-${OP_NONE}`)\n\n/** @internal */\nclass None implements FiberId.None {\n  readonly [FiberIdTypeId]: FiberId.FiberIdTypeId = FiberIdTypeId\n  readonly _tag = OP_NONE\n  readonly id = -1\n  readonly startTimeMillis = -1;\n  [Hash.symbol](): number {\n    return emptyHash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isFiberId(that) && that._tag === OP_NONE\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag\n    }\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n}\n\n/** @internal */\nclass Runtime implements FiberId.Runtime {\n  readonly [FiberIdTypeId]: FiberId.FiberIdTypeId = FiberIdTypeId\n  readonly _tag = OP_RUNTIME\n  constructor(\n    readonly id: number,\n    readonly startTimeMillis: number\n  ) {}\n  [Hash.symbol](): number {\n    return Hash.cached(this, Hash.string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`))\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isFiberId(that) &&\n      that._tag === OP_RUNTIME &&\n      this.id === that.id &&\n      this.startTimeMillis === that.startTimeMillis\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      id: this.id,\n      startTimeMillis: this.startTimeMillis\n    }\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n}\n\n/** @internal */\nclass Composite implements FiberId.Composite {\n  readonly [FiberIdTypeId]: FiberId.FiberIdTypeId = FiberIdTypeId\n  readonly _tag = OP_COMPOSITE\n  constructor(\n    readonly left: FiberId.FiberId,\n    readonly right: FiberId.FiberId\n  ) {\n  }\n  _hash: number | undefined;\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.string(`${FiberIdSymbolKey}-${this._tag}`),\n      Hash.combine(Hash.hash(this.left)),\n      Hash.combine(Hash.hash(this.right)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isFiberId(that) &&\n      that._tag === OP_COMPOSITE &&\n      Equal.equals(this.left, that.left) &&\n      Equal.equals(this.right, that.right)\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  toJSON() {\n    return {\n      _id: \"FiberId\",\n      _tag: this._tag,\n      left: toJSON(this.left),\n      right: toJSON(this.right)\n    }\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n}\n\n/** @internal */\nexport const none: FiberId.None = new None()\n\n/** @internal */\nexport const runtime = (id: number, startTimeMillis: number): FiberId.Runtime => {\n  return new Runtime(id, startTimeMillis)\n}\n\n/** @internal */\nexport const composite = (left: FiberId.FiberId, right: FiberId.FiberId): FiberId.Composite => {\n  return new Composite(left, right)\n}\n\n/** @internal */\nexport const isFiberId = (self: unknown): self is FiberId.FiberId => hasProperty(self, FiberIdTypeId)\n\n/** @internal */\nexport const isNone = (self: FiberId.FiberId): self is FiberId.None => {\n  return self._tag === OP_NONE || pipe(toSet(self), HashSet.every((id) => isNone(id)))\n}\n\n/** @internal */\nexport const isRuntime = (self: FiberId.FiberId): self is FiberId.Runtime => {\n  return self._tag === OP_RUNTIME\n}\n\n/** @internal */\nexport const isComposite = (self: FiberId.FiberId): self is FiberId.Composite => {\n  return self._tag === OP_COMPOSITE\n}\n\n/** @internal */\nexport const combine = dual<\n  (that: FiberId.FiberId) => (self: FiberId.FiberId) => FiberId.FiberId,\n  (self: FiberId.FiberId, that: FiberId.FiberId) => FiberId.FiberId\n>(2, (self, that) => {\n  if (self._tag === OP_NONE) {\n    return that\n  }\n  if (that._tag === OP_NONE) {\n    return self\n  }\n  return new Composite(self, that)\n})\n\n/** @internal */\nexport const combineAll = (fiberIds: HashSet.HashSet<FiberId.FiberId>): FiberId.FiberId => {\n  return pipe(fiberIds, HashSet.reduce(none as FiberId.FiberId, (a, b) => combine(b)(a)))\n}\n\n/** @internal */\nexport const getOrElse = dual<\n  (that: FiberId.FiberId) => (self: FiberId.FiberId) => FiberId.FiberId,\n  (self: FiberId.FiberId, that: FiberId.FiberId) => FiberId.FiberId\n>(2, (self, that) => isNone(self) ? that : self)\n\n/** @internal */\nexport const ids = (self: FiberId.FiberId): HashSet.HashSet<number> => {\n  switch (self._tag) {\n    case OP_NONE: {\n      return HashSet.empty()\n    }\n    case OP_RUNTIME: {\n      return HashSet.make(self.id)\n    }\n    case OP_COMPOSITE: {\n      return pipe(ids(self.left), HashSet.union(ids(self.right)))\n    }\n  }\n}\n\nconst _fiberCounter = globalValue(\n  Symbol.for(\"effect/Fiber/Id/_fiberCounter\"),\n  () => MutableRef.make(0)\n)\n\n/** @internal */\nexport const make = (id: number, startTimeSeconds: number): FiberId.FiberId => {\n  return new Runtime(id, startTimeSeconds)\n}\n\n/** @internal */\nexport const threadName = (self: FiberId.FiberId): string => {\n  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(\",\")\n  return identifiers\n}\n\n/** @internal */\nexport const toOption = (self: FiberId.FiberId): Option.Option<FiberId.FiberId> => {\n  const fiberIds = toSet(self)\n  if (HashSet.size(fiberIds) === 0) {\n    return Option.none()\n  }\n  let first = true\n  let acc: FiberId.FiberId\n  for (const fiberId of fiberIds) {\n    if (first) {\n      acc = fiberId\n      first = false\n    } else {\n      // @ts-expect-error\n      acc = pipe(acc, combine(fiberId))\n    }\n  }\n  // @ts-expect-error\n  return Option.some(acc)\n}\n\n/** @internal */\nexport const toSet = (self: FiberId.FiberId): HashSet.HashSet<FiberId.Runtime> => {\n  switch (self._tag) {\n    case OP_NONE: {\n      return HashSet.empty()\n    }\n    case OP_RUNTIME: {\n      return HashSet.make(self)\n    }\n    case OP_COMPOSITE: {\n      return pipe(toSet(self.left), HashSet.union(toSet(self.right)))\n    }\n  }\n}\n\n/** @internal */\nexport const unsafeMake = (): FiberId.Runtime => {\n  const id = MutableRef.get(_fiberCounter)\n  pipe(_fiberCounter, MutableRef.set(id + 1))\n  return new Runtime(id, Date.now())\n}\n","import type * as Differ from \"../Differ.js\"\nimport { dual } from \"../Function.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport type * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport * as internalDiffer from \"./differ.js\"\nimport * as runtimeFlagsPatch from \"./runtimeFlagsPatch.js\"\n\n/** @internal */\nexport const None: RuntimeFlags.RuntimeFlag = 0 as RuntimeFlags.RuntimeFlag\n\n/** @internal */\nexport const Interruption: RuntimeFlags.RuntimeFlag = 1 << 0 as RuntimeFlags.RuntimeFlag\n\n/** @internal */\nexport const OpSupervision: RuntimeFlags.RuntimeFlag = 1 << 1 as RuntimeFlags.RuntimeFlag\n\n/** @internal */\nexport const RuntimeMetrics: RuntimeFlags.RuntimeFlag = 1 << 2 as RuntimeFlags.RuntimeFlag\n\n/** @internal */\nexport const WindDown: RuntimeFlags.RuntimeFlag = 1 << 4 as RuntimeFlags.RuntimeFlag\n\n/** @internal */\nexport const CooperativeYielding: RuntimeFlags.RuntimeFlag = 1 << 5 as RuntimeFlags.RuntimeFlag\n\n/** @internal */\nexport const allFlags: ReadonlyArray<RuntimeFlags.RuntimeFlag> = [\n  None,\n  Interruption,\n  OpSupervision,\n  RuntimeMetrics,\n  WindDown,\n  CooperativeYielding\n]\n\nconst print = (flag: RuntimeFlags.RuntimeFlag) => {\n  switch (flag) {\n    case CooperativeYielding: {\n      return \"CooperativeYielding\"\n    }\n    case WindDown: {\n      return \"WindDown\"\n    }\n    case RuntimeMetrics: {\n      return \"RuntimeMetrics\"\n    }\n    case OpSupervision: {\n      return \"OpSupervision\"\n    }\n    case Interruption: {\n      return \"Interruption\"\n    }\n    case None: {\n      return \"None\"\n    }\n  }\n}\n\n/** @internal */\nexport const cooperativeYielding = (self: RuntimeFlags.RuntimeFlags): boolean => isEnabled(self, CooperativeYielding)\n\n/** @internal */\nexport const disable = dual<\n  (flag: RuntimeFlags.RuntimeFlag) => (self: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags,\n  (self: RuntimeFlags.RuntimeFlags, flag: RuntimeFlags.RuntimeFlag) => RuntimeFlags.RuntimeFlags\n>(2, (self, flag) => (self & ~flag) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const disableAll = dual<\n  (flags: RuntimeFlags.RuntimeFlags) => (self: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags,\n  (self: RuntimeFlags.RuntimeFlags, flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags\n>(2, (self, flags) => (self & ~flags) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const enable = dual<\n  (flag: RuntimeFlags.RuntimeFlag) => (self: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags,\n  (self: RuntimeFlags.RuntimeFlags, flag: RuntimeFlags.RuntimeFlag) => RuntimeFlags.RuntimeFlags\n>(2, (self, flag) => (self | flag) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const enableAll = dual<\n  (flags: RuntimeFlags.RuntimeFlags) => (self: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags,\n  (self: RuntimeFlags.RuntimeFlags, flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags\n>(2, (self, flags) => (self | flags) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const interruptible = (self: RuntimeFlags.RuntimeFlags): boolean => interruption(self) && !windDown(self)\n\n/** @internal */\nexport const interruption = (self: RuntimeFlags.RuntimeFlags): boolean => isEnabled(self, Interruption)\n\n/** @internal */\nexport const isDisabled = dual<\n  (flag: RuntimeFlags.RuntimeFlag) => (self: RuntimeFlags.RuntimeFlags) => boolean,\n  (self: RuntimeFlags.RuntimeFlags, flag: RuntimeFlags.RuntimeFlag) => boolean\n>(2, (self, flag) => !isEnabled(self, flag))\n\n/** @internal */\nexport const isEnabled = dual<\n  (flag: RuntimeFlags.RuntimeFlag) => (self: RuntimeFlags.RuntimeFlags) => boolean,\n  (self: RuntimeFlags.RuntimeFlags, flag: RuntimeFlags.RuntimeFlag) => boolean\n>(2, (self, flag) => (self & flag) !== 0)\n\n/** @internal */\nexport const make = (...flags: ReadonlyArray<RuntimeFlags.RuntimeFlag>): RuntimeFlags.RuntimeFlags =>\n  flags.reduce((a, b) => a | b, 0) as RuntimeFlags.RuntimeFlags\n\n/** @internal */\nexport const none: RuntimeFlags.RuntimeFlags = make(None)\n\n/** @internal */\nexport const opSupervision = (self: RuntimeFlags.RuntimeFlags): boolean => isEnabled(self, OpSupervision)\n\n/** @internal */\nexport const render = (self: RuntimeFlags.RuntimeFlags): string => {\n  const active: Array<string> = []\n  allFlags.forEach((flag) => {\n    if (isEnabled(self, flag)) {\n      active.push(`${print(flag)}`)\n    }\n  })\n  return `RuntimeFlags(${active.join(\", \")})`\n}\n\n/** @internal */\nexport const runtimeMetrics = (self: RuntimeFlags.RuntimeFlags): boolean => isEnabled(self, RuntimeMetrics)\n\n/** @internal */\nexport const toSet = (self: RuntimeFlags.RuntimeFlags): ReadonlySet<RuntimeFlags.RuntimeFlag> =>\n  new Set(allFlags.filter((flag) => isEnabled(self, flag)))\n\nexport const windDown = (self: RuntimeFlags.RuntimeFlags): boolean => isEnabled(self, WindDown)\n\n// circular with RuntimeFlagsPatch\n\n/** @internal */\nexport const enabledSet = (self: RuntimeFlagsPatch.RuntimeFlagsPatch): ReadonlySet<RuntimeFlags.RuntimeFlag> =>\n  toSet((runtimeFlagsPatch.active(self) & runtimeFlagsPatch.enabled(self)) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const disabledSet = (self: RuntimeFlagsPatch.RuntimeFlagsPatch): ReadonlySet<RuntimeFlags.RuntimeFlag> =>\n  toSet((runtimeFlagsPatch.active(self) & ~runtimeFlagsPatch.enabled(self)) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const diff = dual<\n  (that: RuntimeFlags.RuntimeFlags) => (self: RuntimeFlags.RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch,\n  (self: RuntimeFlags.RuntimeFlags, that: RuntimeFlags.RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch\n>(2, (self, that) => runtimeFlagsPatch.make(self ^ that, that))\n\n/** @internal */\nexport const patch = dual<\n  (patch: RuntimeFlagsPatch.RuntimeFlagsPatch) => (self: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags,\n  (self: RuntimeFlags.RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch) => RuntimeFlags.RuntimeFlags\n>(2, (self, patch) =>\n  (\n    (self & (runtimeFlagsPatch.invert(runtimeFlagsPatch.active(patch)) | runtimeFlagsPatch.enabled(patch))) |\n    (runtimeFlagsPatch.active(patch) & runtimeFlagsPatch.enabled(patch))\n  ) as RuntimeFlags.RuntimeFlags)\n\n/** @internal */\nexport const renderPatch = (self: RuntimeFlagsPatch.RuntimeFlagsPatch): string => {\n  const enabled = Array.from(enabledSet(self))\n    .map((flag) => print(flag))\n    .join(\", \")\n  const disabled = Array.from(disabledSet(self))\n    .map((flag) => print(flag))\n    .join(\", \")\n  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`\n}\n\n/** @internal */\nexport const differ: Differ.Differ<RuntimeFlags.RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch> = internalDiffer\n  .make({\n    empty: runtimeFlagsPatch.empty,\n    diff: (oldValue, newValue) => diff(oldValue, newValue),\n    combine: (first, second) => runtimeFlagsPatch.andThen(second)(first),\n    patch: (_patch, oldValue) => patch(oldValue, _patch)\n  })\n","import type { Chunk } from \"../Chunk.js\"\nimport type { Context } from \"../Context.js\"\nimport type * as Differ from \"../Differ.js\"\nimport type { Either } from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Dual from \"../Function.js\"\nimport { constant, identity } from \"../Function.js\"\nimport type { HashMap } from \"../HashMap.js\"\nimport type { HashSet } from \"../HashSet.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as ChunkPatch from \"./differ/chunkPatch.js\"\nimport * as ContextPatch from \"./differ/contextPatch.js\"\nimport * as HashMapPatch from \"./differ/hashMapPatch.js\"\nimport * as HashSetPatch from \"./differ/hashSetPatch.js\"\nimport * as OrPatch from \"./differ/orPatch.js\"\nimport * as ReadonlyArrayPatch from \"./differ/readonlyArrayPatch.js\"\n\n/** @internal */\nexport const DifferTypeId: Differ.TypeId = Symbol.for(\"effect/Differ\") as Differ.TypeId\n\n/** @internal */\nexport const DifferProto = {\n  [DifferTypeId]: {\n    _P: identity,\n    _V: identity\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const make = <Value, Patch>(\n  params: {\n    readonly empty: Patch\n    readonly diff: (oldValue: Value, newValue: Value) => Patch\n    readonly combine: (first: Patch, second: Patch) => Patch\n    readonly patch: (patch: Patch, oldValue: Value) => Value\n  }\n): Differ.Differ<Value, Patch> => {\n  const differ = Object.create(DifferProto)\n  differ.empty = params.empty\n  differ.diff = params.diff\n  differ.combine = params.combine\n  differ.patch = params.patch\n  return differ\n}\n\n/** @internal */\nexport const environment = <A>(): Differ.Differ<Context<A>, Differ.Differ.Context.Patch<A, A>> =>\n  make({\n    empty: ContextPatch.empty(),\n    combine: (first, second) => ContextPatch.combine(second)(first),\n    diff: (oldValue, newValue) => ContextPatch.diff(oldValue, newValue),\n    patch: (patch, oldValue) => ContextPatch.patch(oldValue)(patch)\n  })\n\n/** @internal */\nexport const chunk = <Value, Patch>(\n  differ: Differ.Differ<Value, Patch>\n): Differ.Differ<Chunk<Value>, Differ.Differ.Chunk.Patch<Value, Patch>> =>\n  make({\n    empty: ChunkPatch.empty(),\n    combine: (first, second) => ChunkPatch.combine(second)(first),\n    diff: (oldValue, newValue) => ChunkPatch.diff({ oldValue, newValue, differ }),\n    patch: (patch, oldValue) => ChunkPatch.patch(oldValue, differ)(patch)\n  })\n\n/** @internal */\nexport const hashMap = <Key, Value, Patch>(\n  differ: Differ.Differ<Value, Patch>\n): Differ.Differ<HashMap<Key, Value>, Differ.Differ.HashMap.Patch<Key, Value, Patch>> =>\n  make({\n    empty: HashMapPatch.empty(),\n    combine: (first, second) => HashMapPatch.combine(second)(first),\n    diff: (oldValue, newValue) => HashMapPatch.diff({ oldValue, newValue, differ }),\n    patch: (patch, oldValue) => HashMapPatch.patch(oldValue, differ)(patch)\n  })\n\n/** @internal */\nexport const hashSet = <Value>(): Differ.Differ<HashSet<Value>, Differ.Differ.HashSet.Patch<Value>> =>\n  make({\n    empty: HashSetPatch.empty(),\n    combine: (first, second) => HashSetPatch.combine(second)(first),\n    diff: (oldValue, newValue) => HashSetPatch.diff(oldValue, newValue),\n    patch: (patch, oldValue) => HashSetPatch.patch(oldValue)(patch)\n  })\n\n/** @internal */\nexport const orElseEither = Dual.dual<\n  <Value2, Patch2>(that: Differ.Differ<Value2, Patch2>) => <Value, Patch>(\n    self: Differ.Differ<Value, Patch>\n  ) => Differ.Differ<Either<Value2, Value>, Differ.Differ.Or.Patch<Value, Value2, Patch, Patch2>>,\n  <Value, Patch, Value2, Patch2>(\n    self: Differ.Differ<Value, Patch>,\n    that: Differ.Differ<Value2, Patch2>\n  ) => Differ.Differ<Either<Value2, Value>, Differ.Differ.Or.Patch<Value, Value2, Patch, Patch2>>\n>(2, (self, that) =>\n  make({\n    empty: OrPatch.empty(),\n    combine: (first, second) => OrPatch.combine(first, second),\n    diff: (oldValue, newValue) =>\n      OrPatch.diff({\n        oldValue,\n        newValue,\n        left: self,\n        right: that\n      }),\n    patch: (patch, oldValue) =>\n      OrPatch.patch(patch, {\n        oldValue,\n        left: self,\n        right: that\n      })\n  }))\n\n/** @internal */\nexport const readonlyArray = <Value, Patch>(\n  differ: Differ.Differ<Value, Patch>\n): Differ.Differ<ReadonlyArray<Value>, Differ.Differ.ReadonlyArray.Patch<Value, Patch>> =>\n  make({\n    empty: ReadonlyArrayPatch.empty(),\n    combine: (first, second) => ReadonlyArrayPatch.combine(first, second),\n    diff: (oldValue, newValue) => ReadonlyArrayPatch.diff({ oldValue, newValue, differ }),\n    patch: (patch, oldValue) => ReadonlyArrayPatch.patch(patch, oldValue, differ)\n  })\n\n/** @internal */\nexport const transform = Dual.dual<\n  <Value, Value2>(\n    options: {\n      readonly toNew: (value: Value) => Value2\n      readonly toOld: (value: Value2) => Value\n    }\n  ) => <Patch>(self: Differ.Differ<Value, Patch>) => Differ.Differ<Value2, Patch>,\n  <Value, Patch, Value2>(\n    self: Differ.Differ<Value, Patch>,\n    options: {\n      readonly toNew: (value: Value) => Value2\n      readonly toOld: (value: Value2) => Value\n    }\n  ) => Differ.Differ<Value2, Patch>\n>(2, (self, { toNew, toOld }) =>\n  make({\n    empty: self.empty,\n    combine: (first, second) => self.combine(first, second),\n    diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),\n    patch: (patch, oldValue) => toNew(self.patch(patch, toOld(oldValue)))\n  }))\n\n/** @internal */\nexport const update = <A>(): Differ.Differ<A, (a: A) => A> => updateWith((_, a) => a)\n\n/** @internal */\nexport const updateWith = <A>(f: (x: A, y: A) => A): Differ.Differ<A, (a: A) => A> =>\n  make({\n    empty: identity,\n    combine: (first, second) => {\n      if (first === identity) {\n        return second\n      }\n      if (second === identity) {\n        return first\n      }\n      return (a) => second(first(a))\n    },\n    diff: (oldValue, newValue) => {\n      if (Equal.equals(oldValue, newValue)) {\n        return identity\n      }\n      return constant(newValue)\n    },\n    patch: (patch, oldValue) => f(oldValue, patch(oldValue))\n  })\n\n/** @internal */\nexport const zip = Dual.dual<\n  <Value2, Patch2>(that: Differ.Differ<Value2, Patch2>) => <Value, Patch>(\n    self: Differ.Differ<Value, Patch>\n  ) => Differ.Differ<readonly [Value, Value2], readonly [Patch, Patch2]>,\n  <Value, Patch, Value2, Patch2>(\n    self: Differ.Differ<Value, Patch>,\n    that: Differ.Differ<Value2, Patch2>\n  ) => Differ.Differ<readonly [Value, Value2], readonly [Patch, Patch2]>\n>(2, (self, that) =>\n  make({\n    empty: [self.empty, that.empty] as const,\n    combine: (first, second) => [\n      self.combine(first[0], second[0]),\n      that.combine(first[1], second[1])\n    ],\n    diff: (oldValue, newValue) => [\n      self.diff(oldValue[0], newValue[0]),\n      that.diff(oldValue[1], newValue[1])\n    ],\n    patch: (patch, oldValue) => [\n      self.patch(patch[0], oldValue[0]),\n      that.patch(patch[1], oldValue[1])\n    ]\n  }))\n","import * as Chunk from \"../Chunk.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type { FiberId } from \"../FiberId.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as List from \"../List.js\"\nimport * as Option from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as RequestBlock from \"../RequestBlock.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\n\n/** @internal */\nexport const empty: RequestBlock.RequestBlock = {\n  _tag: \"Empty\"\n}\n\n/**\n * Combines this collection of blocked requests with the specified collection\n * of blocked requests, in parallel.\n *\n * @internal\n */\nexport const par = (\n  self: RequestBlock.RequestBlock,\n  that: RequestBlock.RequestBlock\n): RequestBlock.RequestBlock => ({\n  _tag: \"Par\",\n  left: self,\n  right: that\n})\n\n/**\n * Combines this collection of blocked requests with the specified collection\n * of blocked requests, in sequence.\n *\n * @internal\n */\nexport const seq = (\n  self: RequestBlock.RequestBlock,\n  that: RequestBlock.RequestBlock\n): RequestBlock.RequestBlock => ({\n  _tag: \"Seq\",\n  left: self,\n  right: that\n})\n\n/**\n * Constructs a collection of blocked requests from the specified blocked\n * request and data source.\n *\n * @internal\n */\nexport const single = <A>(\n  dataSource: RequestResolver.RequestResolver<A>,\n  blockedRequest: Request.Entry<A>\n): RequestBlock.RequestBlock => ({\n  _tag: \"Single\",\n  dataSource: dataSource as any,\n  blockedRequest\n})\n\n/** @internal */\nexport const MapRequestResolversReducer = <A>(\n  f: (dataSource: RequestResolver.RequestResolver<A>) => RequestResolver.RequestResolver<A>\n): RequestBlock.RequestBlock.Reducer<RequestBlock.RequestBlock> => ({\n  emptyCase: () => empty,\n  parCase: (left, right) => par(left, right),\n  seqCase: (left, right) => seq(left, right),\n  singleCase: (dataSource, blockedRequest) => single(f(dataSource), blockedRequest as any)\n})\n\ntype BlockedRequestsCase = ParCase | SeqCase\n\ninterface ParCase {\n  readonly _tag: \"ParCase\"\n}\n\ninterface SeqCase {\n  readonly _tag: \"SeqCase\"\n}\n\n/**\n * Transforms all data sources with the specified data source aspect, which\n * can change the environment type of data sources but must preserve the\n * request type of each data source.\n *\n * @internal\n */\nexport const mapRequestResolvers = <A>(\n  self: RequestBlock.RequestBlock,\n  f: (dataSource: RequestResolver.RequestResolver<A>) => RequestResolver.RequestResolver<A>\n): RequestBlock.RequestBlock => reduce(self, MapRequestResolversReducer(f))\n\n/**\n * Folds over the cases of this collection of blocked requests with the\n * specified functions.\n *\n * @internal\n */\nexport const reduce = <Z>(\n  self: RequestBlock.RequestBlock,\n  reducer: RequestBlock.RequestBlock.Reducer<Z>\n): Z => {\n  let input: List.List<RequestBlock.RequestBlock> = List.of(self)\n  let output = List.empty<Either.Either<Z, BlockedRequestsCase>>()\n  while (List.isCons(input)) {\n    const current: RequestBlock.RequestBlock = input.head\n    switch (current._tag) {\n      case \"Empty\": {\n        output = List.cons(Either.right(reducer.emptyCase()), output)\n        input = input.tail\n        break\n      }\n      case \"Par\": {\n        output = List.cons(Either.left({ _tag: \"ParCase\" }), output)\n        input = List.cons(current.left, List.cons(current.right, input.tail))\n        break\n      }\n      case \"Seq\": {\n        output = List.cons(Either.left({ _tag: \"SeqCase\" }), output)\n        input = List.cons(current.left, List.cons(current.right, input.tail))\n        break\n      }\n      case \"Single\": {\n        const result = reducer.singleCase(current.dataSource, current.blockedRequest)\n        output = List.cons(Either.right(result), output)\n        input = input.tail\n        break\n      }\n    }\n  }\n  const result = List.reduce(output, List.empty<Z>(), (acc, current) => {\n    switch (current._tag) {\n      case \"Left\": {\n        const left = List.unsafeHead(acc)\n        const right = List.unsafeHead(List.unsafeTail(acc))\n        const tail = List.unsafeTail(List.unsafeTail(acc))\n        switch (current.left._tag) {\n          case \"ParCase\": {\n            return List.cons(reducer.parCase(left, right), tail)\n          }\n          case \"SeqCase\": {\n            return List.cons(reducer.seqCase(left, right), tail)\n          }\n        }\n      }\n      case \"Right\": {\n        return List.cons(current.right, acc)\n      }\n    }\n  })\n  if (List.isNil(result)) {\n    throw new Error(\n      \"BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues\"\n    )\n  }\n  return result.head\n}\n\n/**\n * Flattens a collection of blocked requests into a collection of pipelined\n * and batched requests that can be submitted for execution.\n *\n * @internal\n */\nexport const flatten = (\n  self: RequestBlock.RequestBlock\n): List.List<SequentialCollection> => {\n  let current = List.of(self)\n  let updated = List.empty<SequentialCollection>()\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = List.reduce(\n      current,\n      [parallelCollectionEmpty(), List.empty<RequestBlock.RequestBlock>()] as const,\n      ([parallel, sequential], blockedRequest) => {\n        const [par, seq] = step(blockedRequest)\n        return [\n          parallelCollectionCombine(parallel, par),\n          List.appendAll(sequential, seq)\n        ]\n      }\n    )\n    updated = merge(updated, parallel)\n    if (List.isNil(sequential)) {\n      return List.reverse(updated)\n    }\n    current = sequential\n  }\n  throw new Error(\n    \"BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues\"\n  )\n}\n\n/**\n * Takes one step in evaluating a collection of blocked requests, returning a\n * collection of blocked requests that can be performed in parallel and a list\n * of blocked requests that must be performed sequentially after those\n * requests.\n */\nconst step = (\n  requests: RequestBlock.RequestBlock\n): [ParallelCollection, List.List<RequestBlock.RequestBlock>] => {\n  let current: RequestBlock.RequestBlock = requests\n  let parallel = parallelCollectionEmpty()\n  let stack = List.empty<RequestBlock.RequestBlock>()\n  let sequential = List.empty<RequestBlock.RequestBlock>()\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    switch (current._tag) {\n      case \"Empty\": {\n        if (List.isNil(stack)) {\n          return [parallel, sequential]\n        }\n        current = stack.head\n        stack = stack.tail\n        break\n      }\n      case \"Par\": {\n        stack = List.cons(current.right, stack)\n        current = current.left\n        break\n      }\n      case \"Seq\": {\n        const left = current.left\n        const right = current.right\n        switch (left._tag) {\n          case \"Empty\": {\n            current = right\n            break\n          }\n          case \"Par\": {\n            const l = left.left\n            const r = left.right\n            current = par(seq(l, right), seq(r, right))\n            break\n          }\n          case \"Seq\": {\n            const l = left.left\n            const r = left.right\n            current = seq(l, seq(r, right))\n            break\n          }\n          case \"Single\": {\n            current = left\n            sequential = List.cons(right, sequential)\n            break\n          }\n        }\n        break\n      }\n      case \"Single\": {\n        parallel = parallelCollectionAdd(\n          parallel,\n          current\n        )\n        if (List.isNil(stack)) {\n          return [parallel, sequential]\n        }\n        current = stack.head\n        stack = stack.tail\n        break\n      }\n    }\n  }\n  throw new Error(\n    \"BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues\"\n  )\n}\n\n/**\n * Merges a collection of requests that must be executed sequentially with a\n * collection of requests that can be executed in parallel. If the collections\n * are both from the same single data source then the requests can be\n * pipelined while preserving ordering guarantees.\n */\nconst merge = (\n  sequential: List.List<SequentialCollection>,\n  parallel: ParallelCollection\n): List.List<SequentialCollection> => {\n  if (List.isNil(sequential)) {\n    return List.of(parallelCollectionToSequentialCollection(parallel))\n  }\n  if (parallelCollectionIsEmpty(parallel)) {\n    return sequential\n  }\n  const seqHeadKeys = sequentialCollectionKeys(sequential.head)\n  const parKeys = parallelCollectionKeys(parallel)\n  if (\n    seqHeadKeys.length === 1 &&\n    parKeys.length === 1 &&\n    Equal.equals(seqHeadKeys[0], parKeys[0])\n  ) {\n    return List.cons(\n      sequentialCollectionCombine(\n        sequential.head,\n        parallelCollectionToSequentialCollection(parallel)\n      ),\n      sequential.tail\n    )\n  }\n  return List.cons(parallelCollectionToSequentialCollection(parallel), sequential)\n}\n\n//\n// circular\n//\n\n/** @internal */\nexport const EntryTypeId: Request.EntryTypeId = Symbol.for(\n  \"effect/RequestBlock/Entry\"\n) as Request.EntryTypeId\n\n/** @internal */\nclass EntryImpl<A extends Request.Request<any, any>> implements Request.Entry<A> {\n  readonly [EntryTypeId] = blockedRequestVariance\n  constructor(\n    readonly request: A,\n    readonly result: Deferred.Deferred<Request.Request.Success<A>, Request.Request.Error<A>>,\n    readonly listeners: Request.Listeners,\n    readonly ownerId: FiberId,\n    readonly state: {\n      completed: boolean\n    }\n  ) {}\n}\n\nconst blockedRequestVariance = {\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport const isEntry = (u: unknown): u is Request.Entry<unknown> => hasProperty(u, EntryTypeId)\n\n/** @internal */\nexport const makeEntry = <A extends Request.Request<any, any>>(\n  options: {\n    readonly request: A\n    readonly result: Deferred.Deferred<Request.Request.Success<A>, Request.Request.Error<A>>\n    readonly listeners: Request.Listeners\n    readonly ownerId: FiberId\n    readonly state: { completed: boolean }\n  }\n): Request.Entry<A> => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state)\n\n/** @internal */\nexport const RequestBlockParallelTypeId = Symbol.for(\n  \"effect/RequestBlock/RequestBlockParallel\"\n)\n\nconst parallelVariance = {\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nclass ParallelImpl implements ParallelCollection {\n  readonly [RequestBlockParallelTypeId] = parallelVariance\n  constructor(\n    readonly map: HashMap.HashMap<\n      RequestResolver.RequestResolver<unknown, unknown>,\n      Chunk.Chunk<Request.Entry<unknown>>\n    >\n  ) {}\n}\n\n/** @internal */\nexport const parallelCollectionEmpty = (): ParallelCollection => new ParallelImpl(HashMap.empty())\n\n/** @internal */\nexport const parallelCollectionMake = <A>(\n  dataSource: RequestResolver.RequestResolver<A>,\n  blockedRequest: Request.Entry<A>\n): ParallelCollection => new ParallelImpl(HashMap.make([dataSource, Chunk.of(blockedRequest)]) as any)\n\n/** @internal */\nexport const parallelCollectionAdd = (\n  self: ParallelCollection,\n  blockedRequest: RequestBlock.Single\n): ParallelCollection =>\n  new ParallelImpl(HashMap.modifyAt(\n    self.map,\n    blockedRequest.dataSource,\n    (_) =>\n      Option.orElseSome(\n        Option.map(_, Chunk.append(blockedRequest.blockedRequest)),\n        () => Chunk.of(blockedRequest.blockedRequest)\n      )\n  ))\n\n/** @internal */\nexport const parallelCollectionCombine = (\n  self: ParallelCollection,\n  that: ParallelCollection\n): ParallelCollection =>\n  new ParallelImpl(HashMap.reduce(self.map, that.map, (map, value, key) =>\n    HashMap.set(\n      map,\n      key,\n      Option.match(HashMap.get(map, key), {\n        onNone: () => value,\n        onSome: (other) => Chunk.appendAll(value, other)\n      })\n    )))\n\n/** @internal */\nexport const parallelCollectionIsEmpty = (self: ParallelCollection): boolean => HashMap.isEmpty(self.map)\n\n/** @internal */\nexport const parallelCollectionKeys = (\n  self: ParallelCollection\n): Array<RequestResolver.RequestResolver<unknown>> => Array.from(HashMap.keys(self.map)) as any\n\n/** @internal */\nexport const parallelCollectionToSequentialCollection = (\n  self: ParallelCollection\n): SequentialCollection => sequentialCollectionMake(HashMap.map(self.map, (x) => Chunk.of(x)) as any)\n\n// TODO\n// /** @internal */\n// export const parallelCollectionToChunk = <R>(\n//   self: ParallelCollection<R>\n// ): Array<[RequestResolver.RequestResolver<unknown, R>, Array<Request.Entry<unknown>>]> => Array.from(self.map) as any\n\n/** @internal */\nexport const SequentialCollectionTypeId = Symbol.for(\n  \"effect/RequestBlock/RequestBlockSequential\"\n)\n\nconst sequentialVariance = {\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nclass SequentialImpl implements SequentialCollection {\n  readonly [SequentialCollectionTypeId] = sequentialVariance\n  constructor(\n    readonly map: HashMap.HashMap<\n      RequestResolver.RequestResolver<unknown, unknown>,\n      Chunk.Chunk<Chunk.Chunk<Request.Entry<unknown>>>\n    >\n  ) {}\n}\n\n/** @internal */\nexport const sequentialCollectionMake = <A, R>(\n  map: HashMap.HashMap<\n    RequestResolver.RequestResolver<A, R>,\n    Chunk.Chunk<Chunk.Chunk<Request.Entry<A>>>\n  >\n): SequentialCollection => new SequentialImpl(map as any)\n\n/** @internal */\nexport const sequentialCollectionCombine = (\n  self: SequentialCollection,\n  that: SequentialCollection\n): SequentialCollection =>\n  new SequentialImpl(HashMap.reduce(that.map, self.map, (map, value, key) =>\n    HashMap.set(\n      map,\n      key,\n      Option.match(HashMap.get(map, key), {\n        onNone: () => Chunk.empty(),\n        onSome: (a) => Chunk.appendAll(a, value)\n      })\n    )))\n\n/** @internal */\nexport const sequentialCollectionIsEmpty = (self: SequentialCollection): boolean => HashMap.isEmpty(self.map)\n\n/** @internal */\nexport const sequentialCollectionKeys = (\n  self: SequentialCollection\n): Array<RequestResolver.RequestResolver<unknown>> => Array.from(HashMap.keys(self.map)) as any\n\n/** @internal */\nexport const sequentialCollectionToChunk = (\n  self: SequentialCollection\n): Array<[RequestResolver.RequestResolver<unknown>, Chunk.Chunk<Chunk.Chunk<Request.Entry<unknown>>>]> =>\n  Array.from(self.map) as any\n\n/** @internal */\nexport type RequestBlockParallelTypeId = typeof RequestBlockParallelTypeId\n\n/** @internal */\nexport interface ParallelCollection extends ParallelCollection.Variance {\n  readonly map: HashMap.HashMap<\n    RequestResolver.RequestResolver<unknown, unknown>,\n    Chunk.Chunk<Request.Entry<unknown>>\n  >\n}\n\n/** @internal */\nexport declare namespace ParallelCollection {\n  /** @internal */\n  export interface Variance {\n    readonly [RequestBlockParallelTypeId]: {}\n  }\n}\n\n/** @internal */\nexport type SequentialCollectionTypeId = typeof SequentialCollectionTypeId\n\n/** @internal */\nexport interface SequentialCollection extends SequentialCollection.Variance {\n  readonly map: HashMap.HashMap<\n    RequestResolver.RequestResolver<unknown, unknown>,\n    Chunk.Chunk<Chunk.Chunk<Request.Entry<unknown>>>\n  >\n}\n\n/** @internal */\nexport declare namespace SequentialCollection {\n  /** @internal */\n  export interface Variance {\n    readonly [SequentialCollectionTypeId]: {}\n  }\n}\n","import * as Chunk from \"../../Chunk.js\"\nimport type { Differ } from \"../../Differ.js\"\nimport type { Either } from \"../../Either.js\"\nimport * as E from \"../../Either.js\"\nimport * as Equal from \"../../Equal.js\"\nimport * as Dual from \"../../Function.js\"\nimport { Structural } from \"../data.js\"\n\n/** @internal */\nexport const OrPatchTypeId: Differ.Or.TypeId = Symbol.for(\"effect/DifferOrPatch\") as Differ.Or.TypeId\n\nfunction variance<A, B>(a: A): B {\n  return a as unknown as B\n}\n\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [OrPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n}\n\n/** @internal */\nexport interface Empty<in out Value, in out Value2, in out Patch, in out Patch2>\n  extends Differ.Or.Patch<Value, Value2, Patch, Patch2>\n{\n  readonly _tag: \"Empty\"\n}\n\nconst EmptyProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Empty\"\n})\n\nconst _empty = Object.create(EmptyProto)\n\n/** @internal */\nexport const empty = <Value, Value2, Patch, Patch2>(): Differ.Or.Patch<\n  Value,\n  Value2,\n  Patch,\n  Patch2\n> => _empty\n\n/** @internal */\nexport interface AndThen<in out Value, in out Value2, in out Patch, Patch2>\n  extends Differ.Or.Patch<Value, Value2, Patch, Patch2>\n{\n  readonly _tag: \"AndThen\"\n  readonly first: Differ.Or.Patch<Value, Value2, Patch, Patch2>\n  readonly second: Differ.Or.Patch<Value, Value2, Patch, Patch2>\n}\n\nconst AndThenProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AndThen\"\n})\n\n/** @internal */\nexport const makeAndThen = <Value, Value2, Patch, Patch2>(\n  first: Differ.Or.Patch<Value, Value2, Patch, Patch2>,\n  second: Differ.Or.Patch<Value, Value2, Patch, Patch2>\n): Differ.Or.Patch<\n  Value,\n  Value2,\n  Patch,\n  Patch2\n> => {\n  const o = Object.create(AndThenProto)\n  o.first = first\n  o.second = second\n  return o\n}\n\n/** @internal */\nexport interface SetLeft<in out Value, in out Value2, in out Patch, Patch2>\n  extends Differ.Or.Patch<Value, Value2, Patch, Patch2>\n{\n  readonly _tag: \"SetLeft\"\n  readonly value: Value\n}\n\nconst SetLeftProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"SetLeft\"\n})\n\n/** @internal */\nexport const makeSetLeft = <Value, Value2, Patch, Patch2>(\n  value: Value\n): Differ.Or.Patch<\n  Value,\n  Value2,\n  Patch,\n  Patch2\n> => {\n  const o = Object.create(SetLeftProto)\n  o.value = value\n  return o\n}\n\n/** @internal */\nexport interface SetRight<in out Value, in out Value2, in out Patch, in out Patch2>\n  extends Differ.Or.Patch<Value, Value2, Patch, Patch2>\n{\n  readonly _tag: \"SetRight\"\n  readonly value: Value2\n}\n\nconst SetRightProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"SetRight\"\n})\n\n/** @internal */\nexport const makeSetRight = <Value, Value2, Patch, Patch2>(\n  value: Value2\n): Differ.Or.Patch<\n  Value,\n  Value2,\n  Patch,\n  Patch2\n> => {\n  const o = Object.create(SetRightProto)\n  o.value = value\n  return o\n}\n\n/** @internal */\nexport interface UpdateLeft<in out Value, in out Value2, in out Patch, in out Patch2>\n  extends Differ.Or.Patch<Value, Value2, Patch, Patch2>\n{\n  readonly _tag: \"UpdateLeft\"\n  readonly patch: Patch\n}\n\nconst UpdateLeftProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"UpdateLeft\"\n})\n\n/** @internal */\nexport const makeUpdateLeft = <Value, Value2, Patch, Patch2>(\n  patch: Patch\n): Differ.Or.Patch<\n  Value,\n  Value2,\n  Patch,\n  Patch2\n> => {\n  const o = Object.create(UpdateLeftProto)\n  o.patch = patch\n  return o\n}\n\n/** @internal */\nexport interface UpdateRight<in out Value, in out Value2, in out Patch, in out Patch2>\n  extends Differ.Or.Patch<Value, Value2, Patch, Patch2>\n{\n  readonly _tag: \"UpdateRight\"\n  readonly patch: Patch2\n}\n\nconst UpdateRightProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"UpdateRight\"\n})\n\n/** @internal */\nexport const makeUpdateRight = <Value, Value2, Patch, Patch2>(\n  patch: Patch2\n): Differ.Or.Patch<\n  Value,\n  Value2,\n  Patch,\n  Patch2\n> => {\n  const o = Object.create(UpdateRightProto)\n  o.patch = patch\n  return o\n}\n\ntype Instruction =\n  | AndThen<any, any, any, any>\n  | Empty<any, any, any, any>\n  | SetLeft<any, any, any, any>\n  | SetRight<any, any, any, any>\n  | UpdateLeft<any, any, any, any>\n  | UpdateRight<any, any, any, any>\n\n/** @internal */\nexport const diff = <Value, Value2, Patch, Patch2>(\n  options: {\n    readonly oldValue: Either<Value2, Value>\n    readonly newValue: Either<Value2, Value>\n    readonly left: Differ<Value, Patch>\n    readonly right: Differ<Value2, Patch2>\n  }\n): Differ.Or.Patch<Value, Value2, Patch, Patch2> => {\n  switch (options.oldValue._tag) {\n    case \"Left\": {\n      switch (options.newValue._tag) {\n        case \"Left\": {\n          const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left)\n          if (Equal.equals(valuePatch, options.left.empty)) {\n            return empty()\n          }\n          return makeUpdateLeft(valuePatch)\n        }\n        case \"Right\": {\n          return makeSetRight(options.newValue.right)\n        }\n      }\n    }\n    case \"Right\": {\n      switch (options.newValue._tag) {\n        case \"Left\": {\n          return makeSetLeft(options.newValue.left)\n        }\n        case \"Right\": {\n          const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right)\n          if (Equal.equals(valuePatch, options.right.empty)) {\n            return empty()\n          }\n          return makeUpdateRight(valuePatch)\n        }\n      }\n    }\n  }\n}\n\n/** @internal */\nexport const combine = Dual.dual<\n  <Value, Value2, Patch, Patch2>(\n    that: Differ.Or.Patch<Value, Value2, Patch, Patch2>\n  ) => (\n    self: Differ.Or.Patch<Value, Value2, Patch, Patch2>\n  ) => Differ.Or.Patch<Value, Value2, Patch, Patch2>,\n  <Value, Value2, Patch, Patch2>(\n    self: Differ.Or.Patch<Value, Value2, Patch, Patch2>,\n    that: Differ.Or.Patch<Value, Value2, Patch, Patch2>\n  ) => Differ.Or.Patch<Value, Value2, Patch, Patch2>\n>(2, (self, that) => makeAndThen(self, that))\n\n/** @internal */\nexport const patch = Dual.dual<\n  <Value, Value2, Patch, Patch2>(\n    options: {\n      readonly oldValue: Either<Value2, Value>\n      readonly left: Differ<Value, Patch>\n      readonly right: Differ<Value2, Patch2>\n    }\n  ) => (self: Differ.Or.Patch<Value, Value2, Patch, Patch2>) => Either<Value2, Value>,\n  <Value, Value2, Patch, Patch2>(\n    self: Differ.Or.Patch<Value, Value2, Patch, Patch2>,\n    options: {\n      readonly oldValue: Either<Value2, Value>\n      readonly left: Differ<Value, Patch>\n      readonly right: Differ<Value2, Patch2>\n    }\n  ) => Either<Value2, Value>\n>(2, <Value, Value2, Patch, Patch2>(\n  self: Differ.Or.Patch<Value, Value2, Patch, Patch2>,\n  { left, oldValue, right }: {\n    oldValue: Either<Value2, Value>\n    left: Differ<Value, Patch>\n    right: Differ<Value2, Patch2>\n  }\n) => {\n  if ((self as Instruction)._tag === \"Empty\") {\n    return oldValue\n  }\n  let patches: Chunk.Chunk<Differ.Or.Patch<Value, Value2, Patch, Patch2>> = Chunk.of(self)\n  let result = oldValue\n  while (Chunk.isNonEmpty(patches)) {\n    const head: Instruction = Chunk.headNonEmpty(patches) as Instruction\n    const tail = Chunk.tailNonEmpty(patches)\n    switch (head._tag) {\n      case \"Empty\": {\n        patches = tail\n        break\n      }\n      case \"AndThen\": {\n        patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail))\n        break\n      }\n      case \"UpdateLeft\": {\n        if (result._tag === \"Left\") {\n          result = E.left(left.patch(head.patch, result.left))\n        }\n        patches = tail\n        break\n      }\n      case \"UpdateRight\": {\n        if (result._tag === \"Right\") {\n          result = E.right(right.patch(head.patch, result.right))\n        }\n        patches = tail\n        break\n      }\n      case \"SetLeft\": {\n        result = E.left(head.value)\n        patches = tail\n        break\n      }\n      case \"SetRight\": {\n        result = E.right(head.value)\n        patches = tail\n        break\n      }\n    }\n  }\n  return result\n})\n","import * as Chunk from \"../../Chunk.js\"\nimport type * as Differ from \"../../Differ.js\"\nimport * as Equal from \"../../Equal.js\"\nimport * as Dual from \"../../Function.js\"\nimport { pipe } from \"../../Function.js\"\nimport * as Data from \"../data.js\"\n\n/** @internal */\nexport const ChunkPatchTypeId: Differ.Differ.Chunk.TypeId = Symbol.for(\n  \"effect/DifferChunkPatch\"\n) as Differ.Differ.Chunk.TypeId\n\nfunction variance<A, B>(a: A): B {\n  return a as unknown as B\n}\n\nconst PatchProto = {\n  ...Data.Structural.prototype,\n  [ChunkPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n}\n\ninterface Empty<Value, Patch> extends Differ.Differ.Chunk.Patch<Value, Patch> {\n  readonly _tag: \"Empty\"\n}\n\nconst EmptyProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Empty\"\n})\n\nconst _empty = Object.create(EmptyProto)\n\n/**\n * @internal\n */\nexport const empty = <Value, Patch>(): Differ.Differ.Chunk.Patch<Value, Patch> => _empty\n\ninterface AndThen<Value, Patch> extends Differ.Differ.Chunk.Patch<Value, Patch> {\n  readonly _tag: \"AndThen\"\n  readonly first: Differ.Differ.Chunk.Patch<Value, Patch>\n  readonly second: Differ.Differ.Chunk.Patch<Value, Patch>\n}\n\nconst AndThenProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AndThen\"\n})\n\nconst makeAndThen = <Value, Patch>(\n  first: Differ.Differ.Chunk.Patch<Value, Patch>,\n  second: Differ.Differ.Chunk.Patch<Value, Patch>\n): Differ.Differ.Chunk.Patch<Value, Patch> => {\n  const o = Object.create(AndThenProto)\n  o.first = first\n  o.second = second\n  return o\n}\n\ninterface Append<Value, Patch> extends Differ.Differ.Chunk.Patch<Value, Patch> {\n  readonly _tag: \"Append\"\n  readonly values: Chunk.Chunk<Value>\n}\n\nconst AppendProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Append\"\n})\n\nconst makeAppend = <Value, Patch>(values: Chunk.Chunk<Value>): Differ.Differ.Chunk.Patch<Value, Patch> => {\n  const o = Object.create(AppendProto)\n  o.values = values\n  return o\n}\n\ninterface Slice<Value, Patch> extends Differ.Differ.Chunk.Patch<Value, Patch> {\n  readonly _tag: \"Slice\"\n  readonly from: number\n  readonly until: number\n}\n\nconst SliceProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Slice\"\n})\n\nconst makeSlice = <Value, Patch>(from: number, until: number): Differ.Differ.Chunk.Patch<Value, Patch> => {\n  const o = Object.create(SliceProto)\n  o.from = from\n  o.until = until\n  return o\n}\n\ninterface Update<Value, Patch> extends Differ.Differ.Chunk.Patch<Value, Patch> {\n  readonly _tag: \"Update\"\n  readonly index: number\n  readonly patch: Patch\n}\n\nconst UpdateProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Update\"\n})\n\nconst makeUpdate = <Value, Patch>(index: number, patch: Patch): Differ.Differ.Chunk.Patch<Value, Patch> => {\n  const o = Object.create(UpdateProto)\n  o.index = index\n  o.patch = patch\n  return o\n}\n\ntype Instruction =\n  | Empty<any, any>\n  | AndThen<any, any>\n  | Append<any, any>\n  | Slice<any, any>\n  | Update<any, any>\n\n/** @internal */\nexport const diff = <Value, Patch>(\n  options: {\n    readonly oldValue: Chunk.Chunk<Value>\n    readonly newValue: Chunk.Chunk<Value>\n    readonly differ: Differ.Differ<Value, Patch>\n  }\n): Differ.Differ.Chunk.Patch<Value, Patch> => {\n  let i = 0\n  let patch = empty<Value, Patch>()\n  while (i < options.oldValue.length && i < options.newValue.length) {\n    const oldElement = Chunk.unsafeGet(i)(options.oldValue)\n    const newElement = Chunk.unsafeGet(i)(options.newValue)\n    const valuePatch = options.differ.diff(oldElement, newElement)\n    if (!Equal.equals(valuePatch, options.differ.empty)) {\n      patch = pipe(patch, combine(makeUpdate(i, valuePatch)))\n    }\n    i = i + 1\n  }\n  if (i < options.oldValue.length) {\n    patch = pipe(patch, combine(makeSlice(0, i)))\n  }\n  if (i < options.newValue.length) {\n    patch = pipe(patch, combine(makeAppend(Chunk.drop(i)(options.newValue))))\n  }\n  return patch\n}\n\n/** @internal */\nexport const combine = Dual.dual<\n  <Value, Patch>(\n    that: Differ.Differ.Chunk.Patch<Value, Patch>\n  ) => (\n    self: Differ.Differ.Chunk.Patch<Value, Patch>\n  ) => Differ.Differ.Chunk.Patch<Value, Patch>,\n  <Value, Patch>(\n    self: Differ.Differ.Chunk.Patch<Value, Patch>,\n    that: Differ.Differ.Chunk.Patch<Value, Patch>\n  ) => Differ.Differ.Chunk.Patch<Value, Patch>\n>(2, (self, that) => makeAndThen(self, that))\n\n/** @internal */\nexport const patch = Dual.dual<\n  <Value, Patch>(\n    oldValue: Chunk.Chunk<Value>,\n    differ: Differ.Differ<Value, Patch>\n  ) => (self: Differ.Differ.Chunk.Patch<Value, Patch>) => Chunk.Chunk<Value>,\n  <Value, Patch>(\n    self: Differ.Differ.Chunk.Patch<Value, Patch>,\n    oldValue: Chunk.Chunk<Value>,\n    differ: Differ.Differ<Value, Patch>\n  ) => Chunk.Chunk<Value>\n>(3, <Value, Patch>(\n  self: Differ.Differ.Chunk.Patch<Value, Patch>,\n  oldValue: Chunk.Chunk<Value>,\n  differ: Differ.Differ<Value, Patch>\n) => {\n  if ((self as Instruction)._tag === \"Empty\") {\n    return oldValue\n  }\n  let chunk = oldValue\n  let patches: Chunk.Chunk<Differ.Differ.Chunk.Patch<Value, Patch>> = Chunk.of(self)\n  while (Chunk.isNonEmpty(patches)) {\n    const head: Instruction = Chunk.headNonEmpty(patches) as Instruction\n    const tail = Chunk.tailNonEmpty(patches)\n    switch (head._tag) {\n      case \"Empty\": {\n        patches = tail\n        break\n      }\n      case \"AndThen\": {\n        patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail))\n        break\n      }\n      case \"Append\": {\n        chunk = Chunk.appendAll(head.values)(chunk)\n        patches = tail\n        break\n      }\n      case \"Slice\": {\n        const array = Chunk.toReadonlyArray(chunk)\n        chunk = Chunk.unsafeFromArray(array.slice(head.from, head.until))\n        patches = tail\n        break\n      }\n      case \"Update\": {\n        const array = Chunk.toReadonlyArray(chunk) as Array<Value>\n        array[head.index] = differ.patch(head.patch, array[head.index]!)\n        chunk = Chunk.unsafeFromArray(array)\n        patches = tail\n        break\n      }\n    }\n  }\n  return chunk\n})\n","import * as Chunk from \"../../Chunk.js\"\nimport type { Context } from \"../../Context.js\"\nimport type { Differ } from \"../../Differ.js\"\nimport * as Equal from \"../../Equal.js\"\nimport * as Dual from \"../../Function.js\"\nimport { makeContext } from \"../context.js\"\nimport { Structural } from \"../data.js\"\n\n/** @internal */\nexport const ContextPatchTypeId: Differ.Context.TypeId = Symbol.for(\n  \"effect/DifferContextPatch\"\n) as Differ.Context.TypeId\n\nfunction variance<A, B>(a: A): B {\n  return a as unknown as B\n}\n\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [ContextPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n}\n\ninterface Empty<Input, Output> extends Differ.Context.Patch<Input, Output> {\n  readonly _tag: \"Empty\"\n}\n\nconst EmptyProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Empty\"\n})\n\nconst _empty = Object.create(EmptyProto)\n\n/**\n * @internal\n */\nexport const empty = <Input, Output>(): Differ.Context.Patch<Input, Output> => _empty\n\n/** @internal */\nexport interface AndThen<in out Input, in out Output, in out Output2> extends Differ.Context.Patch<Input, Output2> {\n  readonly _tag: \"AndThen\"\n  readonly first: Differ.Context.Patch<Input, Output>\n  readonly second: Differ.Context.Patch<Output, Output2>\n}\n\nconst AndThenProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AndThen\"\n})\n\nconst makeAndThen = <Input, Output, Output2>(\n  first: Differ.Context.Patch<Input, Output>,\n  second: Differ.Context.Patch<Output, Output2>\n): Differ.Context.Patch<Input, Output2> => {\n  const o = Object.create(AndThenProto)\n  o.first = first\n  o.second = second\n  return o\n}\n\n/** @internal */\nexport interface AddService<in out Env, in out T, in out I> extends Differ.Context.Patch<Env, Env | I> {\n  readonly _tag: \"AddService\"\n  readonly key: string\n  readonly service: T\n}\n\nconst AddServiceProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AddService\"\n})\n\nconst makeAddService = <Env, I, T>(\n  key: string,\n  service: T\n): Differ.Context.Patch<Env, Env | I> => {\n  const o = Object.create(AddServiceProto)\n  o.key = key\n  o.service = service\n  return o\n}\n\n/** @internal */\nexport interface RemoveService<in out Env, in out I> extends Differ.Context.Patch<Env, Exclude<Env, I>> {\n  readonly _tag: \"RemoveService\"\n  readonly key: string\n}\n\nconst RemoveServiceProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"RemoveService\"\n})\n\nconst makeRemoveService = <Env, I>(\n  key: string\n): Differ.Context.Patch<Env, Exclude<Env, I>> => {\n  const o = Object.create(RemoveServiceProto)\n  o.key = key\n  return o\n}\n\n/** @internal */\nexport interface UpdateService<in out Env, in out T, in out I> extends Differ.Context.Patch<Env | I, Env | I> {\n  readonly _tag: \"UpdateService\"\n  readonly key: string\n  update(service: T): T\n}\n\nconst UpdateServiceProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"UpdateService\"\n})\n\nconst makeUpdateService = <Env, I, T>(\n  key: string,\n  update: (service: T) => T\n): Differ.Context.Patch<Env | I, Env | I> => {\n  const o = Object.create(UpdateServiceProto)\n  o.key = key\n  o.update = update\n  return o\n}\n\ntype Instruction =\n  | Empty<any, any>\n  | AndThen<any, any, any>\n  | AddService<any, any, any>\n  | RemoveService<any, any>\n  | UpdateService<any, any, any>\n\n/** @internal */\nexport const diff = <Input, Output>(\n  oldValue: Context<Input>,\n  newValue: Context<Output>\n): Differ.Context.Patch<Input, Output> => {\n  const missingServices = new Map(oldValue.unsafeMap)\n  let patch = empty<any, any>()\n  for (const [tag, newService] of newValue.unsafeMap.entries()) {\n    if (missingServices.has(tag)) {\n      const old = missingServices.get(tag)!\n      missingServices.delete(tag)\n      if (!Equal.equals(old, newService)) {\n        patch = combine(makeUpdateService(tag, () => newService))(patch)\n      }\n    } else {\n      missingServices.delete(tag)\n      patch = combine(makeAddService(tag, newService))(patch)\n    }\n  }\n  for (const [tag] of missingServices.entries()) {\n    patch = combine(makeRemoveService(tag))(patch)\n  }\n  return patch\n}\n\n/** @internal */\nexport const combine = Dual.dual<\n  <Output, Output2>(\n    that: Differ.Context.Patch<Output, Output2>\n  ) => <Input>(\n    self: Differ.Context.Patch<Input, Output>\n  ) => Differ.Context.Patch<Input, Output2>,\n  <Input, Output, Output2>(\n    self: Differ.Context.Patch<Input, Output>,\n    that: Differ.Context.Patch<Output, Output2>\n  ) => Differ.Context.Patch<Input, Output2>\n>(2, (self, that) => makeAndThen(self, that))\n\n/** @internal */\nexport const patch = Dual.dual<\n  <Input>(\n    context: Context<Input>\n  ) => <Output>(\n    self: Differ.Context.Patch<Input, Output>\n  ) => Context<Output>,\n  <Input, Output>(\n    self: Differ.Context.Patch<Input, Output>,\n    context: Context<Input>\n  ) => Context<Output>\n>(2, <Input, Output>(self: Differ.Context.Patch<Input, Output>, context: Context<Input>) => {\n  if ((self as Instruction)._tag === \"Empty\") {\n    return context as any\n  }\n  let wasServiceUpdated = false\n  let patches: Chunk.Chunk<Differ.Context.Patch<unknown, unknown>> = Chunk.of(\n    self as Differ.Context.Patch<unknown, unknown>\n  )\n  const updatedContext: Map<string, unknown> = new Map(context.unsafeMap)\n  while (Chunk.isNonEmpty(patches)) {\n    const head: Instruction = Chunk.headNonEmpty(patches) as Instruction\n    const tail = Chunk.tailNonEmpty(patches)\n    switch (head._tag) {\n      case \"Empty\": {\n        patches = tail\n        break\n      }\n      case \"AddService\": {\n        updatedContext.set(head.key, head.service)\n        patches = tail\n        break\n      }\n      case \"AndThen\": {\n        patches = Chunk.prepend(Chunk.prepend(tail, head.second), head.first)\n        break\n      }\n      case \"RemoveService\": {\n        updatedContext.delete(head.key)\n        patches = tail\n        break\n      }\n      case \"UpdateService\": {\n        updatedContext.set(head.key, head.update(updatedContext.get(head.key)))\n        wasServiceUpdated = true\n        patches = tail\n        break\n      }\n    }\n  }\n  if (!wasServiceUpdated) {\n    return makeContext(updatedContext) as Context<Output>\n  }\n  const map = new Map()\n  for (const [tag] of context.unsafeMap) {\n    if (updatedContext.has(tag)) {\n      map.set(tag, updatedContext.get(tag))\n      updatedContext.delete(tag)\n    }\n  }\n  for (const [tag, s] of updatedContext) {\n    map.set(tag, s)\n  }\n  return makeContext(map) as Context<Output>\n})\n","import * as Chunk from \"../../Chunk.js\"\nimport type * as Differ from \"../../Differ.js\"\nimport * as Equal from \"../../Equal.js\"\nimport * as Dual from \"../../Function.js\"\nimport * as HashMap from \"../../HashMap.js\"\nimport { Structural } from \"../data.js\"\n\n/** @internal */\nexport const HashMapPatchTypeId: Differ.Differ.HashMap.TypeId = Symbol.for(\n  \"effect/DifferHashMapPatch\"\n) as Differ.Differ.HashMap.TypeId\n\nfunction variance<A, B>(a: A): B {\n  return a as unknown as B\n}\n\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [HashMapPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n}\n\ninterface Empty<Key, Value, Patch> extends Differ.Differ.HashMap.Patch<Key, Value, Patch> {\n  readonly _tag: \"Empty\"\n}\n\nconst EmptyProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Empty\"\n})\n\nconst _empty = Object.create(EmptyProto)\n\n/** @internal */\nexport const empty = <Key, Value, Patch>(): Differ.Differ.HashMap.Patch<Key, Value, Patch> => _empty\n\ninterface AndThen<Key, Value, Patch> extends Differ.Differ.HashMap.Patch<Key, Value, Patch> {\n  readonly _tag: \"AndThen\"\n  readonly first: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n  readonly second: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n}\n\nconst AndThenProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AndThen\"\n})\n\nconst makeAndThen = <Key, Value, Patch>(\n  first: Differ.Differ.HashMap.Patch<Key, Value, Patch>,\n  second: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n): Differ.Differ.HashMap.Patch<Key, Value, Patch> => {\n  const o = Object.create(AndThenProto)\n  o.first = first\n  o.second = second\n  return o\n}\n\ninterface Add<Key, Value, Patch> extends Differ.Differ.HashMap.Patch<Key, Value, Patch> {\n  readonly _tag: \"Add\"\n  readonly key: Key\n  readonly value: Value\n}\n\nconst AddProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Add\"\n})\n\nconst makeAdd = <Key, Value, Patch>(key: Key, value: Value): Differ.Differ.HashMap.Patch<Key, Value, Patch> => {\n  const o = Object.create(AddProto)\n  o.key = key\n  o.value = value\n  return o\n}\n\ninterface Remove<Key, Value, Patch> extends Differ.Differ.HashMap.Patch<Key, Value, Patch> {\n  readonly _tag: \"Remove\"\n  readonly key: Key\n}\n\nconst RemoveProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Remove\"\n})\n\nconst makeRemove = <Key, Value, Patch>(key: Key): Differ.Differ.HashMap.Patch<Key, Value, Patch> => {\n  const o = Object.create(RemoveProto)\n  o.key = key\n  return o\n}\n\ninterface Update<Key, Value, Patch> extends Differ.Differ.HashMap.Patch<Key, Value, Patch> {\n  readonly _tag: \"Update\"\n  readonly key: Key\n  readonly patch: Patch\n}\n\nconst UpdateProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Update\"\n})\n\nconst makeUpdate = <Key, Value, Patch>(key: Key, patch: Patch): Differ.Differ.HashMap.Patch<Key, Value, Patch> => {\n  const o = Object.create(UpdateProto)\n  o.key = key\n  o.patch = patch\n  return o\n}\n\ntype Instruction =\n  | Add<any, any, any>\n  | Remove<any, any, any>\n  | Update<any, any, any>\n  | Empty<any, any, any>\n  | AndThen<any, any, any>\n\n/** @internal */\nexport const diff = <Key, Value, Patch>(\n  options: {\n    readonly oldValue: HashMap.HashMap<Key, Value>\n    readonly newValue: HashMap.HashMap<Key, Value>\n    readonly differ: Differ.Differ<Value, Patch>\n  }\n): Differ.Differ.HashMap.Patch<Key, Value, Patch> => {\n  const [removed, patch] = HashMap.reduce(\n    [options.oldValue, empty<Key, Value, Patch>()] as const,\n    ([map, patch], newValue: Value, key: Key) => {\n      const option = HashMap.get(key)(map)\n      switch (option._tag) {\n        case \"Some\": {\n          const valuePatch = options.differ.diff(option.value, newValue)\n          if (Equal.equals(valuePatch, options.differ.empty)) {\n            return [HashMap.remove(key)(map), patch] as const\n          }\n          return [\n            HashMap.remove(key)(map),\n            combine<Key, Value, Patch>(makeUpdate(key, valuePatch))(patch)\n          ] as const\n        }\n        case \"None\": {\n          return [map, combine<Key, Value, Patch>(makeAdd(key, newValue))(patch)] as const\n        }\n      }\n    }\n  )(options.newValue)\n  return HashMap.reduce(\n    patch,\n    (patch, _, key: Key) => combine<Key, Value, Patch>(makeRemove(key))(patch)\n  )(removed)\n}\n\n/** @internal */\nexport const combine = Dual.dual<\n  <Key, Value, Patch>(\n    that: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n  ) => (\n    self: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n  ) => Differ.Differ.HashMap.Patch<Key, Value, Patch>,\n  <Key, Value, Patch>(\n    self: Differ.Differ.HashMap.Patch<Key, Value, Patch>,\n    that: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n  ) => Differ.Differ.HashMap.Patch<Key, Value, Patch>\n>(2, (self, that) => makeAndThen(self, that))\n\n/** @internal */\nexport const patch = Dual.dual<\n  <Key, Value, Patch>(\n    oldValue: HashMap.HashMap<Key, Value>,\n    differ: Differ.Differ<Value, Patch>\n  ) => (\n    self: Differ.Differ.HashMap.Patch<Key, Value, Patch>\n  ) => HashMap.HashMap<Key, Value>,\n  <Key, Value, Patch>(\n    self: Differ.Differ.HashMap.Patch<Key, Value, Patch>,\n    oldValue: HashMap.HashMap<Key, Value>,\n    differ: Differ.Differ<Value, Patch>\n  ) => HashMap.HashMap<Key, Value>\n>(3, <Key, Value, Patch>(\n  self: Differ.Differ.HashMap.Patch<Key, Value, Patch>,\n  oldValue: HashMap.HashMap<Key, Value>,\n  differ: Differ.Differ<Value, Patch>\n) => {\n  if ((self as Instruction)._tag === \"Empty\") {\n    return oldValue\n  }\n  let map = oldValue\n  let patches: Chunk.Chunk<Differ.Differ.HashMap.Patch<Key, Value, Patch>> = Chunk.of(self)\n  while (Chunk.isNonEmpty(patches)) {\n    const head: Instruction = Chunk.headNonEmpty(patches) as Instruction\n    const tail = Chunk.tailNonEmpty(patches)\n    switch (head._tag) {\n      case \"Empty\": {\n        patches = tail\n        break\n      }\n      case \"AndThen\": {\n        patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail))\n        break\n      }\n      case \"Add\": {\n        map = HashMap.set(head.key, head.value)(map)\n        patches = tail\n        break\n      }\n      case \"Remove\": {\n        map = HashMap.remove(head.key)(map)\n        patches = tail\n        break\n      }\n      case \"Update\": {\n        const option = HashMap.get(head.key)(map)\n        if (option._tag === \"Some\") {\n          map = HashMap.set(head.key, differ.patch(head.patch, option.value))(map)\n        }\n        patches = tail\n        break\n      }\n    }\n  }\n  return map\n})\n","import * as Arr from \"../../Array.js\"\nimport type * as Differ from \"../../Differ.js\"\nimport * as Equal from \"../../Equal.js\"\nimport * as Dual from \"../../Function.js\"\nimport * as Data from \"../data.js\"\n\n/** @internal */\nexport const ReadonlyArrayPatchTypeId: Differ.Differ.ReadonlyArray.TypeId = Symbol.for(\n  \"effect/DifferReadonlyArrayPatch\"\n) as Differ.Differ.ReadonlyArray.TypeId\n\nfunction variance<A, B>(a: A): B {\n  return a as unknown as B\n}\n\nconst PatchProto = {\n  ...Data.Structural.prototype,\n  [ReadonlyArrayPatchTypeId]: {\n    _Value: variance,\n    _Patch: variance\n  }\n}\n\ninterface Empty<Value, Patch> extends Differ.Differ.ReadonlyArray.Patch<Value, Patch> {\n  readonly _tag: \"Empty\"\n}\n\nconst EmptyProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Empty\"\n})\n\nconst _empty = Object.create(EmptyProto)\n\n/**\n * @internal\n */\nexport const empty = <Value, Patch>(): Differ.Differ.ReadonlyArray.Patch<Value, Patch> => _empty\n\ninterface AndThen<Value, Patch> extends Differ.Differ.ReadonlyArray.Patch<Value, Patch> {\n  readonly _tag: \"AndThen\"\n  readonly first: Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n  readonly second: Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n}\n\nconst AndThenProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AndThen\"\n})\n\nconst makeAndThen = <Value, Patch>(\n  first: Differ.Differ.ReadonlyArray.Patch<Value, Patch>,\n  second: Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n): Differ.Differ.ReadonlyArray.Patch<Value, Patch> => {\n  const o = Object.create(AndThenProto)\n  o.first = first\n  o.second = second\n  return o\n}\n\ninterface Append<Value, Patch> extends Differ.Differ.ReadonlyArray.Patch<Value, Patch> {\n  readonly _tag: \"Append\"\n  readonly values: ReadonlyArray<Value>\n}\n\nconst AppendProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Append\"\n})\n\nconst makeAppend = <Value, Patch>(values: ReadonlyArray<Value>): Differ.Differ.ReadonlyArray.Patch<Value, Patch> => {\n  const o = Object.create(AppendProto)\n  o.values = values\n  return o\n}\n\ninterface Slice<Value, Patch> extends Differ.Differ.ReadonlyArray.Patch<Value, Patch> {\n  readonly _tag: \"Slice\"\n  readonly from: number\n  readonly until: number\n}\n\nconst SliceProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Slice\"\n})\n\nconst makeSlice = <Value, Patch>(from: number, until: number): Differ.Differ.ReadonlyArray.Patch<Value, Patch> => {\n  const o = Object.create(SliceProto)\n  o.from = from\n  o.until = until\n  return o\n}\n\ninterface Update<Value, Patch> extends Differ.Differ.ReadonlyArray.Patch<Value, Patch> {\n  readonly _tag: \"Update\"\n  readonly index: number\n  readonly patch: Patch\n}\n\nconst UpdateProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Update\"\n})\n\nconst makeUpdate = <Value, Patch>(index: number, patch: Patch): Differ.Differ.ReadonlyArray.Patch<Value, Patch> => {\n  const o = Object.create(UpdateProto)\n  o.index = index\n  o.patch = patch\n  return o\n}\n\ntype Instruction =\n  | Empty<any, any>\n  | AndThen<any, any>\n  | Append<any, any>\n  | Slice<any, any>\n  | Update<any, any>\n\n/** @internal */\nexport const diff = <Value, Patch>(\n  options: {\n    readonly oldValue: ReadonlyArray<Value>\n    readonly newValue: ReadonlyArray<Value>\n    readonly differ: Differ.Differ<Value, Patch>\n  }\n): Differ.Differ.ReadonlyArray.Patch<Value, Patch> => {\n  let i = 0\n  let patch = empty<Value, Patch>()\n  while (i < options.oldValue.length && i < options.newValue.length) {\n    const oldElement = options.oldValue[i]!\n    const newElement = options.newValue[i]!\n    const valuePatch = options.differ.diff(oldElement, newElement)\n    if (!Equal.equals(valuePatch, options.differ.empty)) {\n      patch = combine(patch, makeUpdate(i, valuePatch))\n    }\n    i = i + 1\n  }\n  if (i < options.oldValue.length) {\n    patch = combine(patch, makeSlice(0, i))\n  }\n  if (i < options.newValue.length) {\n    patch = combine(patch, makeAppend(Arr.drop(i)(options.newValue)))\n  }\n  return patch\n}\n\n/** @internal */\nexport const combine = Dual.dual<\n  <Value, Patch>(\n    that: Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n  ) => (\n    self: Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n  ) => Differ.Differ.ReadonlyArray.Patch<Value, Patch>,\n  <Value, Patch>(\n    self: Differ.Differ.ReadonlyArray.Patch<Value, Patch>,\n    that: Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n  ) => Differ.Differ.ReadonlyArray.Patch<Value, Patch>\n>(2, (self, that) => makeAndThen(self, that))\n\n/** @internal */\nexport const patch = Dual.dual<\n  <Value, Patch>(\n    oldValue: ReadonlyArray<Value>,\n    differ: Differ.Differ<Value, Patch>\n  ) => (self: Differ.Differ.ReadonlyArray.Patch<Value, Patch>) => ReadonlyArray<Value>,\n  <Value, Patch>(\n    self: Differ.Differ.ReadonlyArray.Patch<Value, Patch>,\n    oldValue: ReadonlyArray<Value>,\n    differ: Differ.Differ<Value, Patch>\n  ) => ReadonlyArray<Value>\n>(3, <Value, Patch>(\n  self: Differ.Differ.ReadonlyArray.Patch<Value, Patch>,\n  oldValue: ReadonlyArray<Value>,\n  differ: Differ.Differ<Value, Patch>\n) => {\n  if ((self as Instruction)._tag === \"Empty\") {\n    return oldValue\n  }\n  let readonlyArray = oldValue.slice()\n  let patches: Array<Differ.Differ.ReadonlyArray.Patch<Value, Patch>> = Arr.of(self)\n  while (Arr.isNonEmptyArray(patches)) {\n    const head: Instruction = Arr.headNonEmpty(patches) as Instruction\n    const tail = Arr.tailNonEmpty(patches)\n    switch (head._tag) {\n      case \"Empty\": {\n        patches = tail\n        break\n      }\n      case \"AndThen\": {\n        tail.unshift(head.first, head.second)\n        patches = tail\n        break\n      }\n      case \"Append\": {\n        for (const value of head.values) {\n          readonlyArray.push(value)\n        }\n        patches = tail\n        break\n      }\n      case \"Slice\": {\n        readonlyArray = readonlyArray.slice(head.from, head.until)\n        patches = tail\n        break\n      }\n      case \"Update\": {\n        readonlyArray[head.index] = differ.patch(head.patch, readonlyArray[head.index]!)\n        patches = tail\n        break\n      }\n    }\n  }\n  return readonlyArray\n})\n","import * as Chunk from \"../../Chunk.js\"\nimport type { Differ } from \"../../Differ.js\"\nimport * as Dual from \"../../Function.js\"\nimport * as HashSet from \"../../HashSet.js\"\nimport { Structural } from \"../data.js\"\n\n/** @internal */\nexport const HashSetPatchTypeId: Differ.HashSet.TypeId = Symbol.for(\n  \"effect/DifferHashSetPatch\"\n) as Differ.HashSet.TypeId\n\nfunction variance<A, B>(a: A): B {\n  return a as unknown as B\n}\n\n/** @internal */\nconst PatchProto = {\n  ...Structural.prototype,\n  [HashSetPatchTypeId]: {\n    _Value: variance,\n    _Key: variance,\n    _Patch: variance\n  }\n}\n\ninterface Empty<Value> extends Differ.HashSet.Patch<Value> {\n  readonly _tag: \"Empty\"\n}\n\nconst EmptyProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Empty\"\n})\n\nconst _empty = Object.create(EmptyProto)\n\n/** @internal */\nexport const empty = <Value>(): Differ.HashSet.Patch<Value> => _empty\n\ninterface AndThen<Value> extends Differ.HashSet.Patch<Value> {\n  readonly _tag: \"AndThen\"\n  readonly first: Differ.HashSet.Patch<Value>\n  readonly second: Differ.HashSet.Patch<Value>\n}\n\nconst AndThenProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"AndThen\"\n})\n\n/** @internal */\nexport const makeAndThen = <Value>(\n  first: Differ.HashSet.Patch<Value>,\n  second: Differ.HashSet.Patch<Value>\n): Differ.HashSet.Patch<Value> => {\n  const o = Object.create(AndThenProto)\n  o.first = first\n  o.second = second\n  return o\n}\n\ninterface Add<Value> extends Differ.HashSet.Patch<Value> {\n  readonly _tag: \"Add\"\n  readonly value: Value\n}\n\nconst AddProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Add\"\n})\n\n/** @internal */\nexport const makeAdd = <Value>(\n  value: Value\n): Differ.HashSet.Patch<Value> => {\n  const o = Object.create(AddProto)\n  o.value = value\n  return o\n}\n\ninterface Remove<Value> extends Differ.HashSet.Patch<Value> {\n  readonly _tag: \"Remove\"\n  readonly value: Value\n}\n\nconst RemoveProto = Object.assign(Object.create(PatchProto), {\n  _tag: \"Remove\"\n})\n\n/** @internal */\nexport const makeRemove = <Value>(\n  value: Value\n): Differ.HashSet.Patch<Value> => {\n  const o = Object.create(RemoveProto)\n  o.value = value\n  return o\n}\n\ntype Instruction =\n  | Add<any>\n  | AndThen<any>\n  | Empty<any>\n  | Remove<any>\n\n/** @internal */\nexport const diff = <Value>(\n  oldValue: HashSet.HashSet<Value>,\n  newValue: HashSet.HashSet<Value>\n): Differ.HashSet.Patch<Value> => {\n  const [removed, patch] = HashSet.reduce(\n    [oldValue, empty<Value>()] as const,\n    ([set, patch], value: Value) => {\n      if (HashSet.has(value)(set)) {\n        return [HashSet.remove(value)(set), patch] as const\n      }\n      return [set, combine(makeAdd(value))(patch)] as const\n    }\n  )(newValue)\n  return HashSet.reduce(patch, (patch, value: Value) => combine(makeRemove(value))(patch))(removed)\n}\n\n/** @internal */\nexport const combine = Dual.dual<\n  <Value>(\n    that: Differ.HashSet.Patch<Value>\n  ) => (\n    self: Differ.HashSet.Patch<Value>\n  ) => Differ.HashSet.Patch<Value>,\n  <Value>(\n    self: Differ.HashSet.Patch<Value>,\n    that: Differ.HashSet.Patch<Value>\n  ) => Differ.HashSet.Patch<Value>\n>(2, (self, that) => makeAndThen(self, that))\n\n/** @internal */\nexport const patch = Dual.dual<\n  <Value>(\n    oldValue: HashSet.HashSet<Value>\n  ) => (\n    self: Differ.HashSet.Patch<Value>\n  ) => HashSet.HashSet<Value>,\n  <Value>(\n    self: Differ.HashSet.Patch<Value>,\n    oldValue: HashSet.HashSet<Value>\n  ) => HashSet.HashSet<Value>\n>(2, <Value>(\n  self: Differ.HashSet.Patch<Value>,\n  oldValue: HashSet.HashSet<Value>\n) => {\n  if ((self as Instruction)._tag === \"Empty\") {\n    return oldValue\n  }\n  let set = oldValue\n  let patches: Chunk.Chunk<Differ.HashSet.Patch<Value>> = Chunk.of(self)\n  while (Chunk.isNonEmpty(patches)) {\n    const head: Instruction = Chunk.headNonEmpty(patches) as Instruction\n    const tail = Chunk.tailNonEmpty(patches)\n    switch (head._tag) {\n      case \"Empty\": {\n        patches = tail\n        break\n      }\n      case \"AndThen\": {\n        patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail))\n        break\n      }\n      case \"Add\": {\n        set = HashSet.add(head.value)(set)\n        patches = tail\n        break\n      }\n      case \"Remove\": {\n        set = HashSet.remove(head.value)(set)\n        patches = tail\n      }\n    }\n  }\n  return set\n})\n","/**\n * @since 2.0.0\n */\n\nimport type { Equal } from \"./Equal.js\"\nimport type { HashSet } from \"./HashSet.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as HM from \"./internal/hashMap.js\"\nimport * as keySet_ from \"./internal/hashMap/keySet.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = HM.HashMapTypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface HashMap<out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace HashMap {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type UpdateFn<V> = (option: Option<V>) => Option<V>\n  /**\n   * This type-level utility extracts the key type `K` from a `HashMap<K, V>` type.\n   *\n   * @example\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * declare const hm: HashMap.HashMap<string, number>\n   *\n   * // $ExpectType string\n   * type K = HashMap.HashMap.Key<typeof hm>\n   *\n   * ```\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Key<T extends HashMap<any, any>> = [T] extends [HashMap<infer _K, infer _V>] ? _K : never\n  /**\n   * This type-level utility extracts the value type `V` from a `HashMap<K, V>` type.\n   *\n   * @example\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * declare const hm: HashMap.HashMap<string, number>\n   *\n   * // $ExpectType number\n   * type V = HashMap.HashMap.Value<typeof hm>\n   *\n   * ```\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Value<T extends HashMap<any, any>> = [T] extends [HashMap<infer _K, infer _V>] ? _V : never\n\n  /**\n   * This type-level utility extracts the entry type `[K, V]` from a `HashMap<K, V>` type.\n   *\n   * @example\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * declare const hm: HashMap.HashMap<string, number>\n   *\n   * // $ExpectType [string, number]\n   * type V = HashMap.HashMap.Entry<typeof hm>\n   *\n   * ```\n   * @since 3.9.0\n   * @category type-level\n   */\n  export type Entry<T extends HashMap<any, any>> = [Key<T>, Value<T>]\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHashMap: {\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  <K, V>(u: Iterable<readonly [K, V]>): u is HashMap<K, V>\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  (u: unknown): u is HashMap<unknown, unknown>\n} = HM.isHashMap\n\n/**\n * Creates a new `HashMap`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <K = never, V = never>() => HashMap<K, V> = HM.empty\n\n/**\n * Constructs a new `HashMap` from an array of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Entries extends ReadonlyArray<readonly [any, any]>>(\n  ...entries: Entries\n) => HashMap<\n  Entries[number] extends readonly [infer K, any] ? K : never,\n  Entries[number] extends readonly [any, infer V] ? V : never\n> = HM.make\n\n/**\n * Creates a new `HashMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V> = HM.fromIterable\n\n/**\n * Checks if the `HashMap` contains any entries.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty: <K, V>(self: HashMap<K, V>) => boolean = HM.isEmpty\n\n/**\n * Safely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const get: {\n  /**\n   * Safely lookup the value for the specified key in the `HashMap` using the\n   * internal hashing function.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K>(key: K1): <V>(self: HashMap<K, V>) => Option<V>\n  /**\n   * Safely lookup the value for the specified key in the `HashMap` using the\n   * internal hashing function.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): Option<V>\n} = HM.get\n\n/**\n * Lookup the value for the specified key in the `HashMap` using a custom hash.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const getHash: {\n  /**\n   * Lookup the value for the specified key in the `HashMap` using a custom hash.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K>(key: K1, hash: number): <V>(self: HashMap<K, V>) => Option<V>\n  /**\n   * Lookup the value for the specified key in the `HashMap` using a custom hash.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K, V>(self: HashMap<K, V>, key: K1, hash: number): Option<V>\n} = HM.getHash\n\n/**\n * Unsafely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Unsafely lookup the value for the specified key in the `HashMap` using the\n   * internal hashing function.\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <K1 extends K, K>(key: K1): <V>(self: HashMap<K, V>) => V\n  /**\n   * Unsafely lookup the value for the specified key in the `HashMap` using the\n   * internal hashing function.\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): V\n} = HM.unsafeGet\n\n/**\n * Checks if the specified key has an entry in the `HashMap`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * Checks if the specified key has an entry in the `HashMap`.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K>(key: K1): <K, V>(self: HashMap<K, V>) => boolean\n  /**\n   * Checks if the specified key has an entry in the `HashMap`.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): boolean\n} = HM.has\n\n/**\n * Checks if the specified key has an entry in the `HashMap` using a custom\n * hash.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const hasHash: {\n  /**\n   * Checks if the specified key has an entry in the `HashMap` using a custom\n   * hash.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K>(key: K1, hash: number): <V>(self: HashMap<K, V>) => boolean\n  /**\n   * Checks if the specified key has an entry in the `HashMap` using a custom\n   * hash.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K1 extends K, K, V>(self: HashMap<K, V>, key: K1, hash: number): boolean\n} = HM.hasHash\n\n/**\n * Checks if an element matching the given predicate exists in the given `HashMap`.\n *\n * @example\n * ```ts\n * import { HashMap } from \"effect\"\n *\n * const hm = HashMap.make([1, 'a'])\n * HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true\n * HashMap.hasBy(hm, (value) => value === 'b'); // -> false\n *\n * ```\n *\n * @since 3.16.0\n * @category elements\n */\nexport const hasBy: {\n  /**\n   * Checks if an element matching the given predicate exists in the given `HashMap`.\n   *\n   * @example\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * const hm = HashMap.make([1, 'a'])\n   * HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true\n   * HashMap.hasBy(hm, (value) => value === 'b'); // -> false\n   *\n   * ```\n   *\n   * @since 3.16.0\n   * @category elements\n   */\n  <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: HashMap<K, V>) => boolean\n  /**\n   * Checks if an element matching the given predicate exists in the given `HashMap`.\n   *\n   * @example\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * const hm = HashMap.make([1, 'a'])\n   * HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true\n   * HashMap.hasBy(hm, (value) => value === 'b'); // -> false\n   *\n   * ```\n   *\n   * @since 3.16.0\n   * @category elements\n   */\n  <K, V>(\n   self: HashMap<K, V>,\n   predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean\n  ): boolean\n} = HM.hasBy\n\n/**\n * Sets the specified key to the specified value using the internal hashing\n * function.\n *\n * @since 2.0.0\n */\nexport const set: {\n  /**\n   * Sets the specified key to the specified value using the internal hashing\n   * function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Sets the specified key to the specified value using the internal hashing\n   * function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>\n} = HM.set\n\n/**\n * Returns an `IterableIterator` of the keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K> = HM.keys\n\n/**\n * Returns a `HashSet` of keys within the `HashMap`.\n *\n * @since 2.0.0\n * @category getter\n */\nexport const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K> = keySet_.keySet\n\n/**\n * Returns an `IterableIterator` of the values within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V> = HM.values\n\n/**\n * Returns an `Array` of the values within the `HashMap`.\n *\n * @since 3.13.0\n * @category getters\n */\nexport const toValues = <K, V>(self: HashMap<K, V>): Array<V> => Array.from(values(self))\n\n/**\n * Returns an `IterableIterator` of the entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]> = HM.entries\n\n/**\n * Returns an `Array<[K, V]>` of the entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toEntries = <K, V>(self: HashMap<K, V>): Array<[K, V]> => Array.from(entries(self))\n\n/**\n * Returns the number of entries within the `HashMap`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <K, V>(self: HashMap<K, V>) => number = HM.size\n\n/**\n * Counts all the element of the given HashMap that pass the given predicate\n *\n * **Example**\n *\n * ```ts\n * import { HashMap } from \"effect\"\n *\n * const map = HashMap.make([1, \"a\"], [2, \"b\"], [3, \"c\"])\n * const result = HashMap.countBy(map, (_v, key) => key % 2 === 1)\n * console.log(result) // 2\n * ```\n *\n * @since 3.17.0\n * @category folding\n */\nexport const countBy: {\n  /**\n   * Counts all the element of the given HashMap that pass the given predicate\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * const map = HashMap.make([1, \"a\"], [2, \"b\"], [3, \"c\"])\n   * const result = HashMap.countBy(map, (_v, key) => key % 2 === 1)\n   * console.log(result) // 2\n   * ```\n   *\n   * @since 3.17.0\n   * @category folding\n   */\n  <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: HashMap<K, V>) => number\n  /**\n   * Counts all the element of the given HashMap that pass the given predicate\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { HashMap } from \"effect\"\n   *\n   * const map = HashMap.make([1, \"a\"], [2, \"b\"], [3, \"c\"])\n   * const result = HashMap.countBy(map, (_v, key) => key % 2 === 1)\n   * console.log(result) // 2\n   * ```\n   *\n   * @since 3.17.0\n   * @category folding\n   */\n  <K, V>(\n   self: HashMap<K, V>,\n   predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean\n  ): number\n} = HM.countBy\n\n/**\n * Marks the `HashMap` as mutable.\n *\n * @since 2.0.0\n */\nexport const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V> = HM.beginMutation\n\n/**\n * Marks the `HashMap` as immutable.\n *\n * @since 2.0.0\n */\nexport const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V> = HM.endMutation\n\n/**\n * Mutates the `HashMap` within the context of the provided function.\n *\n * @since 2.0.0\n */\nexport const mutate: {\n  /**\n   * Mutates the `HashMap` within the context of the provided function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Mutates the `HashMap` within the context of the provided function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>\n} = HM.mutate\n\n/**\n * Set or remove the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * @since 2.0.0\n */\nexport const modifyAt: {\n  /**\n   * Set or remove the specified key in the `HashMap` using the specified\n   * update function. The value of the specified key will be computed using the\n   * provided hash.\n   *\n   * The update function will be invoked with the current value of the key if it\n   * exists, or `None` if no such value exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Set or remove the specified key in the `HashMap` using the specified\n   * update function. The value of the specified key will be computed using the\n   * provided hash.\n   *\n   * The update function will be invoked with the current value of the key if it\n   * exists, or `None` if no such value exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>\n} = HM.modifyAt\n\n/**\n * Alter the value of the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * This function will always either update or insert a value into the `HashMap`.\n *\n * @since 2.0.0\n */\nexport const modifyHash: {\n  /**\n   * Alter the value of the specified key in the `HashMap` using the specified\n   * update function. The value of the specified key will be computed using the\n   * provided hash.\n   *\n   * The update function will be invoked with the current value of the key if it\n   * exists, or `None` if no such value exists.\n   *\n   * This function will always either update or insert a value into the `HashMap`.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Alter the value of the specified key in the `HashMap` using the specified\n   * update function. The value of the specified key will be computed using the\n   * provided hash.\n   *\n   * The update function will be invoked with the current value of the key if it\n   * exists, or `None` if no such value exists.\n   *\n   * This function will always either update or insert a value into the `HashMap`.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>\n} = HM.modifyHash\n\n/**\n * Updates the value of the specified key within the `HashMap` if it exists.\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Updates the value of the specified key within the `HashMap` if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Updates the value of the specified key within the `HashMap` if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>\n} = HM.modify\n\n/**\n * Performs a union of this `HashMap` and that `HashMap`.\n *\n * @since 2.0.0\n */\nexport const union: {\n  /**\n   * Performs a union of this `HashMap` and that `HashMap`.\n   *\n   * @since 2.0.0\n   */\n  <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>\n  /**\n   * Performs a union of this `HashMap` and that `HashMap`.\n   *\n   * @since 2.0.0\n   */\n  <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>\n} = HM.union\n\n/**\n * Remove the entry for the specified key in the `HashMap` using the internal\n * hashing function.\n *\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * Remove the entry for the specified key in the `HashMap` using the internal\n   * hashing function.\n   *\n   * @since 2.0.0\n   */\n  <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Remove the entry for the specified key in the `HashMap` using the internal\n   * hashing function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>\n} = HM.remove\n\n/**\n * Removes all entries in the `HashMap` which have the specified keys.\n *\n * @since 2.0.0\n */\nexport const removeMany: {\n  /**\n   * Removes all entries in the `HashMap` which have the specified keys.\n   *\n   * @since 2.0.0\n   */\n  <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>\n  /**\n   * Removes all entries in the `HashMap` which have the specified keys.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>\n} = HM.removeMany\n\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Maps over the entries of the `HashMap` using the specified function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>\n  /**\n   * Maps over the entries of the `HashMap` using the specified function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>\n} = HM.map\n\n/**\n * Chains over the entries of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * Chains over the entries of the `HashMap` using the specified function.\n   *\n   * **NOTE**: the hash and equal of both maps have to be the same.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>\n  /**\n   * Chains over the entries of the `HashMap` using the specified function.\n   *\n   * **NOTE**: the hash and equal of both maps have to be the same.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>\n} = HM.flatMap\n\n/**\n * Applies the specified function to the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach: {\n  /**\n   * Applies the specified function to the entries of the `HashMap`.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void\n  /**\n   * Applies the specified function to the entries of the `HashMap`.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void\n} = HM.forEach\n\n/**\n * Reduces the specified state over the entries of the `HashMap`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Reduces the specified state over the entries of the `HashMap`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z\n  /**\n   * Reduces the specified state over the entries of the `HashMap`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z\n} = HM.reduce\n\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter: {\n  /**\n   * Filters entries out of a `HashMap` using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>\n  /**\n   * Filters entries out of a `HashMap` using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>\n  /**\n   * Filters entries out of a `HashMap` using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>\n  /**\n   * Filters entries out of a `HashMap` using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>\n} = HM.filter\n\n/**\n * Filters out `None` values from a `HashMap` of `Options`s.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A> = HM.compact\n\n/**\n * Maps over the entries of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap: {\n  /**\n   * Maps over the entries of the `HashMap` using the specified partial function\n   * and filters out `None` values.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>\n  /**\n   * Maps over the entries of the `HashMap` using the specified partial function\n   * and filters out `None` values.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>\n} = HM.filterMap\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>\n} = HM.findFirst\n\n/**\n * Checks if any entry in a hashmap meets a specific condition.\n *\n * @since 3.13.0\n * @category elements\n */\nexport const some: {\n  /**\n   * Checks if any entry in a hashmap meets a specific condition.\n   *\n   * @since 3.13.0\n   * @category elements\n   */\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean\n  /**\n   * Checks if any entry in a hashmap meets a specific condition.\n   *\n   * @since 3.13.0\n   * @category elements\n   */\n  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean\n} = HM.some\n\n/**\n * Checks if all entries in a hashmap meets a specific condition.\n *\n * @param self - The hashmap to check.\n * @param predicate - The condition to test entries (value, key).\n *\n * @since 3.14.0\n * @category elements\n */\nexport const every: {\n  /**\n   * Checks if all entries in a hashmap meets a specific condition.\n   *\n   * @param self - The hashmap to check.\n   * @param predicate - The condition to test entries (value, key).\n   *\n   * @since 3.14.0\n   * @category elements\n   */\n  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean\n  /**\n   * Checks if all entries in a hashmap meets a specific condition.\n   *\n   * @param self - The hashmap to check.\n   * @param predicate - The condition to test entries (value, key).\n   *\n   * @since 3.14.0\n   * @category elements\n   */\n  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean\n} = HM.every\n","/**\n * @since 2.0.0\n */\nimport * as runtimeFlags from \"./internal/runtimeFlags.js\"\nimport * as internal from \"./internal/runtimeFlagsPatch.js\"\nimport type * as RuntimeFlags from \"./RuntimeFlags.js\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type RuntimeFlagsPatch = number & {\n  readonly RuntimeFlagsPatch: unique symbol\n}\n\n/**\n * The empty `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: RuntimeFlagsPatch = internal.empty\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (active: number, enabled: number) => RuntimeFlagsPatch = internal.make\n\n/**\n * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch = internal.enable\n\n/**\n * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const disable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch = internal.disable\n\n/**\n * Returns `true` if the specified `RuntimeFlagsPatch` is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty: (patch: RuntimeFlagsPatch) => boolean = internal.isEmpty\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as active.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isActive: {\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n   * `RuntimeFlag` as active.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n   * `RuntimeFlag` as active.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean\n} = internal.isActive\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as enabled.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEnabled: {\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n   * `RuntimeFlag` as enabled.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n   * `RuntimeFlag` as enabled.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean\n} = internal.isEnabled\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as disabled.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isDisabled: {\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n   * `RuntimeFlag` as disabled.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n   * `RuntimeFlag` as disabled.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean\n} = internal.isDisabled\n\n/**\n * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n * `RuntimeFlag`, `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const includes: {\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n   * `RuntimeFlag`, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean\n  /**\n   * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n   * `RuntimeFlag`, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean\n} = internal.isActive\n\n/**\n * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n * followed by `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const andThen: {\n  /**\n   * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n   * followed by `that` patch.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch\n  /**\n   * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n   * followed by `that` patch.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch\n} = internal.andThen\n\n/**\n * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n * and `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const both: {\n  /**\n   * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n   * and `that` patch.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch\n  /**\n   * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n   * and `that` patch.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch\n} = internal.both\n\n/**\n * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n * patch or `that` patch.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const either: {\n  /**\n   * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n   * patch or `that` patch.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch\n  /**\n   * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n   * patch or `that` patch.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch\n} = internal.either\n\n/**\n * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n * `RuntimeFlag` from the set of `RuntimeFlags`.\n *\n * @category utils\n * @since 2.0.0\n */\nexport const exclude: {\n  /**\n   * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n   * `RuntimeFlag` from the set of `RuntimeFlags`.\n   *\n   * @category utils\n   * @since 2.0.0\n   */\n  (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch\n  /**\n   * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n   * `RuntimeFlag` from the set of `RuntimeFlags`.\n   *\n   * @category utils\n   * @since 2.0.0\n   */\n  (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch\n} = internal.exclude\n\n/**\n * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\n * specified by the provided `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch = internal.inverse\n\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * enabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag> = runtimeFlags.enabledSet\n\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * disabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag> = runtimeFlags.disabledSet\n\n/**\n * Renders the provided `RuntimeFlagsPatch` to a string.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const render: (self: RuntimeFlagsPatch) => string = runtimeFlags.renderPatch\n","/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\"\nimport * as Dual from \"./Function.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/MutableRef\") as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MutableRef<out T> extends Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  current: T\n}\n\nconst MutableRefProto: Omit<MutableRef<unknown>, \"current\"> = {\n  [TypeId]: TypeId,\n  toString<A>(this: MutableRef<A>): string {\n    return format(this.toJSON())\n  },\n  toJSON<A>(this: MutableRef<A>) {\n    return {\n      _id: \"MutableRef\",\n      current: toJSON(this.current)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = <T>(value: T): MutableRef<T> => {\n  const ref = Object.create(MutableRefProto)\n  ref.current = value\n  return ref\n}\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const compareAndSet: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(oldValue: T, newValue: T): (self: MutableRef<T>) => boolean\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, oldValue: T, newValue: T): boolean\n} = Dual.dual<\n  <T>(oldValue: T, newValue: T) => (self: MutableRef<T>) => boolean,\n  <T>(self: MutableRef<T>, oldValue: T, newValue: T) => boolean\n>(3, (self, oldValue, newValue) => {\n  if (Equal.equals(oldValue, self.current)) {\n    self.current = newValue\n    return true\n  }\n  return false\n})\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const decrement = (self: MutableRef<number>): MutableRef<number> => update(self, (n) => n - 1)\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const decrementAndGet = (self: MutableRef<number>): number => updateAndGet(self, (n) => n - 1)\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const get = <T>(self: MutableRef<T>): T => self.current\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const getAndDecrement = (self: MutableRef<number>): number => getAndUpdate(self, (n) => n - 1)\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const getAndIncrement = (self: MutableRef<number>): number => getAndUpdate(self, (n) => n + 1)\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(value: T): (self: MutableRef<T>) => T\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, value: T): T\n} = Dual.dual<\n  <T>(value: T) => (self: MutableRef<T>) => T,\n  <T>(self: MutableRef<T>, value: T) => T\n>(2, (self, value) => {\n  const ret = self.current\n  self.current = value\n  return ret\n})\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(f: (value: T) => T): (self: MutableRef<T>) => T\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, f: (value: T) => T): T\n} = Dual.dual<\n  <T>(f: (value: T) => T) => (self: MutableRef<T>) => T,\n  <T>(self: MutableRef<T>, f: (value: T) => T) => T\n>(2, (self, f) => getAndSet(self, f(get(self))))\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const increment = (self: MutableRef<number>): MutableRef<number> => update(self, (n) => n + 1)\n\n/**\n * @since 2.0.0\n * @category numeric\n */\nexport const incrementAndGet = (self: MutableRef<number>): number => updateAndGet(self, (n) => n + 1)\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(value: T): (self: MutableRef<T>) => MutableRef<T>\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, value: T): MutableRef<T>\n} = Dual.dual<\n  <T>(value: T) => (self: MutableRef<T>) => MutableRef<T>,\n  <T>(self: MutableRef<T>, value: T) => MutableRef<T>\n>(2, (self, value) => {\n  self.current = value\n  return self\n})\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(value: T): (self: MutableRef<T>) => T\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, value: T): T\n} = Dual.dual<\n  <T>(value: T) => (self: MutableRef<T>) => T,\n  <T>(self: MutableRef<T>, value: T) => T\n>(2, (self, value) => {\n  self.current = value\n  return self.current\n})\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(f: (value: T) => T): (self: MutableRef<T>) => MutableRef<T>\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, f: (value: T) => T): MutableRef<T>\n} = Dual.dual<\n  <T>(f: (value: T) => T) => (self: MutableRef<T>) => MutableRef<T>,\n  <T>(self: MutableRef<T>, f: (value: T) => T) => MutableRef<T>\n>(2, (self, f) => set(self, f(get(self))))\n\n/**\n * @since 2.0.0\n * @category general\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(f: (value: T) => T): (self: MutableRef<T>) => T\n  /**\n   * @since 2.0.0\n   * @category general\n   */\n  <T>(self: MutableRef<T>, f: (value: T) => T): T\n} = Dual.dual<\n  <T>(f: (value: T) => T) => (self: MutableRef<T>) => T,\n  <T>(self: MutableRef<T>, f: (value: T) => T) => T\n>(2, (self, f) => setAndGet(self, f(get(self))))\n\n/**\n * @since 2.0.0\n * @category boolean\n */\nexport const toggle = (self: MutableRef<boolean>): MutableRef<boolean> => update(self, (_) => !_)\n","/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as internal from \"./internal/fiberId.js\"\nimport type * as Option from \"./Option.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FiberIdTypeId: unique symbol = internal.FiberIdTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FiberIdTypeId = typeof FiberIdTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type Single = None | Runtime\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type FiberId = Single | Composite\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface None extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"None\"\n  readonly id: -1\n  readonly startTimeMillis: -1\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Runtime extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"Runtime\"\n  readonly id: number\n  readonly startTimeMillis: number\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Composite extends Equal.Equal, Inspectable {\n  readonly [FiberIdTypeId]: FiberIdTypeId\n  readonly _tag: \"Composite\"\n  readonly left: FiberId\n  readonly right: FiberId\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const none: None = internal.none\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const runtime: (id: number, startTimeMillis: number) => Runtime = internal.runtime\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const composite: (left: FiberId, right: FiberId) => Composite = internal.composite\n\n/**\n * Returns `true` if the specified unknown value is a `FiberId`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isFiberId: (self: unknown) => self is FiberId = internal.isFiberId\n\n/**\n * Returns `true` if the `FiberId` is a `None`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNone: (self: FiberId) => self is None = internal.isNone\n\n/**\n * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRuntime: (self: FiberId) => self is Runtime = internal.isRuntime\n\n/**\n * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isComposite: (self: FiberId) => self is Composite = internal.isComposite\n\n/**\n * Combine two `FiberId`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combine: {\n  /**\n   * Combine two `FiberId`s.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (that: FiberId): (self: FiberId) => FiberId\n  /**\n   * Combine two `FiberId`s.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (self: FiberId, that: FiberId): FiberId\n} = internal.combine\n\n/**\n * Combines a set of `FiberId`s into a single `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId = internal.combineAll\n\n/**\n * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const getOrElse: {\n  /**\n   * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: FiberId): (self: FiberId) => FiberId\n  /**\n   * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: FiberId, that: FiberId): FiberId\n} = internal.getOrElse\n\n/**\n * Get the set of identifiers for this `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const ids: (self: FiberId) => HashSet.HashSet<number> = internal.ids\n\n/**\n * Creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (id: number, startTimeSeconds: number) => FiberId = internal.make\n\n/**\n * Creates a string representing the name of the current thread of execution\n * represented by the specified `FiberId`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const threadName: (self: FiberId) => string = internal.threadName\n\n/**\n * Convert a `FiberId` into an `Option<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toOption: (self: FiberId) => Option.Option<FiberId> = internal.toOption\n\n/**\n * Convert a `FiberId` into a `HashSet<FiberId>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toSet: (self: FiberId) => HashSet.HashSet<Runtime> = internal.toSet\n\n/**\n * Unsafely creates a new `FiberId`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: (_: void) => Runtime = internal.unsafeMake\n","/**\n * A data type for immutable linked lists representing ordered collections of elements of type `A`.\n *\n * This data type is optimal for last-in-first-out (LIFO), stack-like access patterns. If you need another access pattern, for example, random access or FIFO, consider using a collection more suited to this than `List`.\n *\n * **Performance**\n *\n * - Time: `List` has `O(1)` prepend and head/tail access. Most other operations are `O(n)` on the number of elements in the list. This includes the index-based lookup of elements, `length`, `append` and `reverse`.\n * - Space: `List` implements structural sharing of the tail list. This means that many operations are either zero- or constant-memory cost.\n *\n * @since 2.0.0\n */\n\n/**\n * This file is ported from\n *\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n */\nimport * as Arr from \"./Array.js\"\nimport * as Chunk from \"./Chunk.js\"\nimport * as Either from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport { dual, identity, unsafeCoerce } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport type { nonEmpty, NonEmptyIterable } from \"./NonEmptyIterable.js\"\nimport * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"./Predicate.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * Represents an immutable linked list of elements of type `A`.\n *\n * A `List` is optimal for last-in-first-out (LIFO), stack-like access patterns.\n * If you need another access pattern, for example, random access or FIFO,\n * consider using a collection more suited for that other than `List`.\n *\n * @since 2.0.0\n * @category models\n */\nexport type List<A> = Cons<A> | Nil<A>\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/List\")\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Nil<out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly _tag: \"Nil\"\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Cons<out A> extends NonEmptyIterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly _tag: \"Cons\"\n  readonly head: A\n  readonly tail: List<A>\n}\n\n/**\n * Converts the specified `List` to an `Array`.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = <A>(self: List<A>): Array<A> => Arr.fromIterable(self)\n\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A>(isEquivalent: Equivalence.Equivalence<A>): Equivalence.Equivalence<List<A>> =>\n  Equivalence.mapInput(Arr.getEquivalence(isEquivalent), toArray<A>)\n\nconst _equivalence = getEquivalence(Equal.equals)\n\nconst ConsProto: Omit<Cons<unknown>, \"head\" | \"tail\" | typeof nonEmpty> = {\n  [TypeId]: TypeId,\n  _tag: \"Cons\",\n  toString(this: Cons<unknown>) {\n    return format(this.toJSON())\n  },\n  toJSON(this: Cons<unknown>) {\n    return {\n      _id: \"List\",\n      _tag: \"Cons\",\n      values: toArray(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  [Equal.symbol](this: Cons<unknown>, that: unknown): boolean {\n    return isList(that) &&\n      this._tag === that._tag &&\n      _equivalence(this, that)\n  },\n  [Hash.symbol](this: Cons<unknown>): number {\n    return Hash.cached(this, Hash.array(toArray(this)))\n  },\n  [Symbol.iterator](this: Cons<unknown>): Iterator<unknown> {\n    let done = false\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self: List<unknown> = this\n    return {\n      next() {\n        if (done) {\n          return this.return!()\n        }\n        if (self._tag === \"Nil\") {\n          done = true\n          return this.return!()\n        }\n        const value: unknown = self.head\n        self = self.tail\n        return { done, value }\n      },\n      return(value?: unknown) {\n        if (!done) {\n          done = true\n        }\n        return { done: true, value }\n      }\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\ninterface MutableCons<A> extends Cons<A> {\n  head: A\n  tail: List<A>\n}\n\nconst makeCons = <A>(head: A, tail: List<A>): MutableCons<A> => {\n  const cons = Object.create(ConsProto)\n  cons.head = head\n  cons.tail = tail\n  return cons\n}\n\nconst NilHash = Hash.string(\"Nil\")\nconst NilProto: Nil<unknown> = {\n  [TypeId]: TypeId,\n  _tag: \"Nil\",\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"List\",\n      _tag: \"Nil\"\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  [Hash.symbol](): number {\n    return NilHash\n  },\n  [Equal.symbol](that: unknown): boolean {\n    return isList(that) && this._tag === that._tag\n  },\n  [Symbol.iterator](): Iterator<unknown> {\n    return {\n      next() {\n        return { done: true, value: undefined }\n      }\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n} as const\n\nconst _Nil = Object.create(NilProto) as Nil<never>\n\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isList: {\n  /**\n   * Returns `true` if the specified value is a `List`, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category refinements\n   */\n  <A>(u: Iterable<A>): u is List<A>\n  /**\n   * Returns `true` if the specified value is a `List`, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category refinements\n   */\n  (u: unknown): u is List<unknown>\n} = (u: unknown): u is List<unknown> => hasProperty(u, TypeId)\n\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNil = <A>(self: List<A>): self is Nil<A> => self._tag === \"Nil\"\n\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isCons = <A>(self: List<A>): self is Cons<A> => self._tag === \"Cons\"\n\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size = <A>(self: List<A>): number => {\n  let these = self\n  let len = 0\n  while (!isNil(these)) {\n    len += 1\n    these = these.tail\n  }\n  return len\n}\n\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nil = <A = never>(): List<A> => _Nil\n\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const cons = <A>(head: A, tail: List<A>): Cons<A> => makeCons(head, tail)\n\n/**\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = nil\n\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const of = <A>(value: A): Cons<A> => makeCons(value, _Nil)\n\n/**\n * Creates a new `List` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = <A>(prefix: Iterable<A>): List<A> => {\n  const iterator = prefix[Symbol.iterator]()\n  let next: IteratorResult<A>\n  if ((next = iterator.next()) && !next.done) {\n    const result = makeCons(next.value, _Nil)\n    let curr = result\n    while ((next = iterator.next()) && !next.done) {\n      const temp = makeCons(next.value, _Nil)\n      curr.tail = temp\n      curr = temp\n    }\n    return result\n  } else {\n    return _Nil\n  }\n}\n\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = <Elements extends readonly [any, ...Array<any>]>(\n  ...elements: Elements\n): Cons<Elements[number]> => fromIterable(elements) as any\n\n/**\n * Appends the specified element to the end of the `List`, creating a new `Cons`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  /**\n   * Appends the specified element to the end of the `List`, creating a new `Cons`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(element: B): <A>(self: List<A>) => Cons<A | B>\n  /**\n   * Appends the specified element to the end of the `List`, creating a new `Cons`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, element: B): Cons<A | B>\n} = dual(2, <A, B>(self: List<A>, element: B): Cons<A | B> => appendAll(self, of(element)))\n\n/**\n * Concatenates two lists, combining their elements.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n *   [1, 2, \"a\", \"b\"]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  /**\n   * Concatenates two lists, combining their elements.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [1, 2, \"a\", \"b\"]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>\n  /**\n   * Concatenates two lists, combining their elements.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [1, 2, \"a\", \"b\"]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>\n  /**\n   * Concatenates two lists, combining their elements.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [1, 2, \"a\", \"b\"]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>\n  /**\n   * Concatenates two lists, combining their elements.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.appendAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [1, 2, \"a\", \"b\"]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, that: List<B>): List<A | B>\n} = dual(2, <A, B>(self: List<A>, that: List<B>): List<A | B> => prependAll(that, self))\n\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  /**\n   * Prepends the specified element to the beginning of the list.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(element: B): <A>(self: List<A>) => Cons<A | B>\n  /**\n   * Prepends the specified element to the beginning of the list.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, element: B): Cons<A | B>\n} = dual(2, <A, B>(self: List<A>, element: B): Cons<A | B> => cons</**\n * Prepends the specified element to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nA | B>(element, self))\n\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n * If either list is non-empty, the result is also a non-empty list.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { List } from \"effect\"\n *\n * assert.deepStrictEqual(\n *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n *   [\"a\", \"b\", 1, 2]\n * )\n * ```\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  /**\n   * Prepends the specified prefix list to the beginning of the specified list.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [\"a\", \"b\", 1, 2]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>\n  /**\n   * Prepends the specified prefix list to the beginning of the specified list.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [\"a\", \"b\", 1, 2]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>\n  /**\n   * Prepends the specified prefix list to the beginning of the specified list.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [\"a\", \"b\", 1, 2]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>\n  /**\n   * Prepends the specified prefix list to the beginning of the specified list.\n   * If either list is non-empty, the result is also a non-empty list.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { List } from \"effect\"\n   *\n   * assert.deepStrictEqual(\n   *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n   *   [\"a\", \"b\", 1, 2]\n   * )\n   * ```\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, that: List<B>): List<A | B>\n} = dual(2, <A, B>(self: List<A>, prefix: List<B>): List<A | B> => {\n  if (isNil(self)) {\n    return prefix\n  } else if (isNil(prefix)) {\n    return self\n  } else {\n    const result = makeCons</**\n     * Prepends the specified prefix list to the beginning of the specified list.\n     * If either list is non-empty, the result is also a non-empty list.\n     *\n     * @example\n     * ```ts\n     * import * as assert from \"node:assert\"\n     * import { List } from \"effect\"\n     *\n     * assert.deepStrictEqual(\n     *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n     *   [\"a\", \"b\", 1, 2]\n     * )\n     * ```\n     *\n     * @category concatenating\n     * @since 2.0.0\n     */\n    A | B>(prefix.head, self)\n    let curr = result\n    let that = prefix.tail\n    while (!isNil(that)) {\n      const temp = makeCons</**\n       * Prepends the specified prefix list to the beginning of the specified list.\n       * If either list is non-empty, the result is also a non-empty list.\n       *\n       * @example\n       * ```ts\n       * import * as assert from \"node:assert\"\n       * import { List } from \"effect\"\n       *\n       * assert.deepStrictEqual(\n       *   List.make(1, 2).pipe(List.prependAll(List.make(\"a\", \"b\")), List.toArray),\n       *   [\"a\", \"b\", 1, 2]\n       * )\n       * ```\n       *\n       * @category concatenating\n       * @since 2.0.0\n       */\n      A | B>(that.head, self)\n      curr.tail = temp\n      curr = temp\n      that = that.tail\n    }\n    return result\n  }\n})\n\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAllReversed: {\n  /**\n   * Prepends the specified prefix list (in reverse order) to the beginning of the\n   * specified list.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>\n  /**\n   * Prepends the specified prefix list (in reverse order) to the beginning of the\n   * specified list.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A, B>(self: List<A>, prefix: List<B>): List<A | B>\n} = dual(2, <A, B>(self: List<A>, prefix: List<B>): List<A | B> => {\n  let out: List<A | B> = self\n  let pres = prefix\n  while (isCons(pres)) {\n    out = makeCons(pres.head, out)\n    pres = pres.tail\n  }\n  return out\n})\n\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const drop: {\n  /**\n   * Drops the first `n` elements from the specified list.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  (n: number): <A>(self: List<A>) => List<A>\n  /**\n   * Drops the first `n` elements from the specified list.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(self: List<A>, n: number): List<A>\n} = dual(2, <A>(self: List<A>, n: number): List<A> => {\n  if (n <= 0) {\n    return self\n  }\n  if (n >= size(self)) {\n    return _Nil\n  }\n  let these = self\n  let i = 0\n  while (!isNil(these) && i < n) {\n    these = these.tail\n    i += 1\n  }\n  return these\n})\n\n/**\n * Check if a predicate holds true for every `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every: {\n  /**\n   * Check if a predicate holds true for every `List` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>\n  /**\n   * Check if a predicate holds true for every `List` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: List<A>) => boolean\n  /**\n   * Check if a predicate holds true for every `List` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>\n  /**\n   * Check if a predicate holds true for every `List` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: List<A>, predicate: Predicate<A>): boolean\n} = dual(2, <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B> => {\n  for (const a of self) {\n    if (!refinement(a)) {\n      return false\n    }\n  }\n  return true\n})\n\n/**\n * Check if a predicate holds true for some `List` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some: {\n  /**\n   * Check if a predicate holds true for some `List` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>\n  /**\n   * Check if a predicate holds true for some `List` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>\n} = dual(2, <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A> => {\n  let these = self\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true\n    }\n    these = these.tail\n  }\n  return false\n})\n\n/**\n * Filters a list using the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filter: {\n  /**\n   * Filters a list using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>\n  /**\n   * Filters a list using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>\n  /**\n   * Filters a list using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>\n  /**\n   * Filters a list using the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(self: List<A>, predicate: Predicate<A>): List<A>\n} = dual(2, <A>(self: List<A>, predicate: Predicate<A>): List<A> => noneIn(self, predicate, false))\n\n// everything seen so far is not included\nconst noneIn = <A>(\n  self: List<A>,\n  predicate: Predicate<A>,\n  isFlipped: boolean\n): List<A> => {\n  while (true) {\n    if (isNil(self)) {\n      return _Nil\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped)\n      } else {\n        self = self.tail\n      }\n    }\n  }\n}\n\n// everything from 'start' is included, if everything from this point is in we can return the origin\n// start otherwise if we discover an element that is out we must create a new partial list.\nconst allIn = <A>(\n  start: List<A>,\n  remaining: List<A>,\n  predicate: Predicate<A>,\n  isFlipped: boolean\n): List<A> => {\n  while (true) {\n    if (isNil(remaining)) {\n      return start\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail\n      } else {\n        return partialFill(start, remaining, predicate, isFlipped)\n      }\n    }\n  }\n}\n\n// we have seen elements that should be included then one that should be excluded, start building\nconst partialFill = <A>(\n  origStart: List<A>,\n  firstMiss: List<A>,\n  predicate: Predicate<A>,\n  isFlipped: boolean\n): List<A> => {\n  const newHead = makeCons<A>(unsafeHead(origStart)!, _Nil)\n  let toProcess = unsafeTail(origStart)! as Cons<A>\n  let currentLast = newHead\n\n  // we know that all elements are :: until at least firstMiss.tail\n  while (!(toProcess === firstMiss)) {\n    const newElem = makeCons(unsafeHead(toProcess)!, _Nil)\n    currentLast.tail = newElem\n    currentLast = unsafeCoerce(newElem)\n    toProcess = unsafeCoerce(toProcess.tail)\n  }\n\n  // at this point newHead points to a list which is a duplicate of all the 'in' elements up to the first miss.\n  // currentLast is the last element in that list.\n\n  // now we are going to try and share as much of the tail as we can, only moving elements across when we have to.\n  let next = firstMiss.tail\n  let nextToCopy: Cons<A> = unsafeCoerce(next) // the next element we would need to copy to our list if we cant share.\n  while (!isNil(next)) {\n    // generally recommended is next.isNonEmpty but this incurs an extra method call.\n    const head = unsafeHead(next)!\n    if (predicate(head) !== isFlipped) {\n      next = next.tail\n    } else {\n      // its not a match - do we have outstanding elements?\n      while (!(nextToCopy === next)) {\n        const newElem = makeCons(unsafeHead(nextToCopy)!, _Nil)\n        currentLast.tail = newElem\n        currentLast = newElem\n        nextToCopy = unsafeCoerce(nextToCopy.tail)\n      }\n      nextToCopy = unsafeCoerce(next.tail)\n      next = next.tail\n    }\n  }\n\n  // we have remaining elements - they are unchanged attach them to the end\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy\n  }\n  return newHead\n}\n\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const filterMap: {\n  /**\n   * Filters and maps a list using the specified partial function. The resulting\n   * list may be smaller than the input list due to the possibility of the partial\n   * function not being defined for some elements.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>\n  /**\n   * Filters and maps a list using the specified partial function. The resulting\n   * list may be smaller than the input list due to the possibility of the partial\n   * function not being defined for some elements.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>\n} = dual(2, <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B> => {\n  const bs: Array<B> = []\n  for (const a of self) {\n    const oa = f(a)\n    if (Option.isSome(oa)) {\n      bs.push(oa.value)\n    }\n  }\n  return fromIterable(bs)\n})\n\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const compact = <A>(self: List<Option.Option<A>>): List<A> => filterMap(self, identity)\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>\n  /**\n   * Returns the first element that satisfies the specified\n   * predicate, or `None` if no such element exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>\n} = dual(2, <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A> => {\n  let these = self\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return Option.some(these.head)\n    }\n    these = these.tail\n  }\n  return Option.none()\n})\n\n/**\n * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>\n  /**\n   * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>\n  /**\n   * Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>\n} = dual(2, <A, B>(self: List<A>, f: (a: A) => List<B>): List<B> => {\n  let rest = self\n  let head: MutableCons<B> | undefined = undefined\n  let tail: MutableCons<B> | undefined = undefined\n  while (!isNil(rest)) {\n    let bs = f(rest.head)\n    while (!isNil(bs)) {\n      const next = makeCons(bs.head, _Nil)\n      if (tail === undefined) {\n        head = next\n      } else {\n        tail.tail = next\n      }\n      tail = next\n      bs = bs.tail\n    }\n    rest = rest.tail\n  }\n  if (head === undefined) {\n    return _Nil\n  }\n  return head\n})\n\n/**\n * Applies the specified function to each element of the `List`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const forEach: {\n  /**\n   * Applies the specified function to each element of the `List`.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: A) => B): (self: List<A>) => void\n  /**\n   * Applies the specified function to each element of the `List`.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(self: List<A>, f: (a: A) => B): void\n} = dual(2, <A, B>(self: List<A>, f: (a: A) => B): void => {\n  let these = self\n  while (!isNil(these)) {\n    f(these.head)\n    these = these.tail\n  }\n})\n\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head = <A>(self: List<A>): Option.Option<A> => isNil(self) ? Option.none() : Option.some(self.head)\n\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const last = <A>(self: List<A>): Option.Option<A> => isNil(self) ? Option.none() : Option.some(unsafeLast(self)!)\n\n/**\n * @since 2.0.0\n */\nexport declare namespace List {\n  /**\n   * @since 2.0.0\n   */\n  export type Infer<S extends List<any>> = S extends List<infer A> ? A : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type With<S extends List<any>, A> = S extends Cons<any> ? Cons<A> : List<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type OrNonEmpty<S extends List<any>, T extends List<any>, A> = S extends Cons<any> ? Cons<A>\n    : T extends Cons<any> ? Cons<A>\n    : List<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type AndNonEmpty<S extends List<any>, T extends List<any>, A> = S extends Cons<any> ?\n    T extends Cons<any> ? Cons<A>\n    : List<A> :\n    List<A>\n}\n\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Applies the specified mapping function to each element of the list.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>\n  /**\n   * Applies the specified mapping function to each element of the list.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>\n} = dual(2, <A, B>(self: List<A>, f: (a: A, i: number) => B): List<B> => {\n  if (isNil(self)) {\n    return self as unknown as List<B>\n  } else {\n    let i = 0\n    const head = makeCons(f(self.head, i++), _Nil)\n    let nextHead = head\n    let rest = self.tail\n    while (!isNil(rest)) {\n      const next = makeCons(f(rest.head, i++), _Nil)\n      nextHead.tail = next\n      nextHead = next\n      rest = rest.tail\n    }\n    return head\n  }\n})\n\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partition: {\n  /**\n   * Partition a list into two lists, where the first list contains all elements\n   * that did not satisfy the specified predicate, and the second list contains\n   * all elements that did satisfy the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]\n  /**\n   * Partition a list into two lists, where the first list contains all elements\n   * that did not satisfy the specified predicate, and the second list contains\n   * all elements that did satisfy the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]\n  /**\n   * Partition a list into two lists, where the first list contains all elements\n   * that did not satisfy the specified predicate, and the second list contains\n   * all elements that did satisfy the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]\n  /**\n   * Partition a list into two lists, where the first list contains all elements\n   * that did not satisfy the specified predicate, and the second list contains\n   * all elements that did satisfy the specified predicate.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]\n} = dual(2, <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>] => {\n  const left: Array<A> = []\n  const right: Array<A> = []\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a)\n    } else {\n      left.push(a)\n    }\n  }\n  return [fromIterable(left), fromIterable(right)]\n})\n\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const partitionMap: {\n  /**\n   * Partition a list into two lists, where the first list contains all elements\n   * for which the specified function returned a `Left`, and the second list\n   * contains all elements for which the specified function returned a `Right`.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]\n  /**\n   * Partition a list into two lists, where the first list contains all elements\n   * for which the specified function returned a `Left`, and the second list\n   * contains all elements for which the specified function returned a `Right`.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]\n} = dual(2, <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>] => {\n  const left: Array<B> = []\n  const right: Array<C> = []\n  for (const a of self) {\n    const e = f(a)\n    if (Either.isLeft(e)) {\n      left.push(e.left)\n    } else {\n      right.push(e.right)\n    }\n  }\n  return [fromIterable(left), fromIterable(right)]\n})\n\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Folds over the elements of the list using the specified function, using the\n   * specified initial value.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z\n  /**\n   * Folds over the elements of the list using the specified function, using the\n   * specified initial value.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z\n} = dual(3, <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z => {\n  let acc = zero\n  let these = self\n  while (!isNil(these)) {\n    acc = f(acc, these.head)\n    these = these.tail\n  }\n  return acc\n})\n\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduceRight: {\n  /**\n   * Folds over the elements of the list using the specified function, beginning\n   * with the last element of the list, using the specified initial value.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z\n  /**\n   * Folds over the elements of the list using the specified function, beginning\n   * with the last element of the list, using the specified initial value.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z\n} = dual(3, <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z => {\n  let acc = zero\n  let these = reverse(self)\n  while (!isNil(these)) {\n    acc = f(acc, these.head)\n    these = these.tail\n  }\n  return acc\n})\n\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reverse = <A>(self: List<A>): List<A> => {\n  let result = empty<A>()\n  let these = self\n  while (!isNil(these)) {\n    result = prepend(result, these.head)\n    these = these.tail\n  }\n  return result\n}\n\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const splitAt: {\n  /**\n   * Splits the specified list into two lists at the specified index.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]\n  /**\n   * Splits the specified list into two lists at the specified index.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]\n} = dual(2, <A>(self: List<A>, n: number): [List<A>, List<A>] => [take(self, n), drop(self, n)])\n\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const tail = <A>(self: List<A>): Option.Option<List<A>> => isNil(self) ? Option.none() : Option.some(self.tail)\n\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const take: {\n  /**\n   * Takes the specified number of elements from the beginning of the specified\n   * list.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  (n: number): <A>(self: List<A>) => List<A>\n  /**\n   * Takes the specified number of elements from the beginning of the specified\n   * list.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(self: List<A>, n: number): List<A>\n} = dual(2, <A>(self: List<A>, n: number): List<A> => {\n  if (n <= 0) {\n    return _Nil\n  }\n  if (n >= size(self)) {\n    return self\n  }\n  let these = make(unsafeHead(self))\n  let current = unsafeTail(self)!\n  for (let i = 1; i < n; i++) {\n    these = makeCons(unsafeHead(current), these)\n    current = unsafeTail(current!)\n  }\n  return reverse(these)\n})\n\n/**\n * Converts the specified `List` to a `Chunk`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const toChunk = <A>(self: List<A>): Chunk.Chunk<A> => Chunk.fromIterable(self)\n\nconst getExpectedListToBeNonEmptyErrorMessage = \"Expected List to be non-empty\"\n\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeHead = <A>(self: List<A>): A => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage)\n  }\n  return self.head\n}\n\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeLast = <A>(self: List<A>): A => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage)\n  }\n  let these = self\n  let scout = self.tail\n  while (!isNil(scout)) {\n    these = scout\n    scout = scout.tail\n  }\n  return these.head\n}\n\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeTail = <A>(self: List<A>): List<A> => {\n  if (isNil(self)) {\n    throw new Error(getExpectedListToBeNonEmptyErrorMessage)\n  }\n  return self.tail\n}\n","import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport { constFalse, constTrue, dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport { NodeInspectSymbol, stringifyCircular, toJSON } from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type { Predicate, Refinement } from \"../Predicate.js\"\nimport { hasProperty, isFunction } from \"../Predicate.js\"\nimport type { AnySpan, Span } from \"../Tracer.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport * as OpCodes from \"./opCodes/cause.js\"\n\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst CauseSymbolKey = \"effect/Cause\"\n\n/** @internal */\nexport const CauseTypeId: Cause.CauseTypeId = Symbol.for(\n  CauseSymbolKey\n) as Cause.CauseTypeId\n\nconst variance = {\n  /* c8 ignore next */\n  _E: (_: never) => _\n}\n\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol](this: Cause.Cause<any>): number {\n    return pipe(\n      Hash.hash(CauseSymbolKey),\n      Hash.combine(Hash.hash(flattenCause(this))),\n      Hash.cached(this)\n    )\n  },\n  [Equal.symbol](this: Cause.Cause<any>, that: unknown): boolean {\n    return isCause(that) && causeEquals(this, that)\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  toJSON<E>(this: Cause.Cause<E>) {\n    switch (this._tag) {\n      case \"Empty\":\n        return { _id: \"Cause\", _tag: this._tag }\n      case \"Die\":\n        return { _id: \"Cause\", _tag: this._tag, defect: toJSON(this.defect) }\n      case \"Interrupt\":\n        return { _id: \"Cause\", _tag: this._tag, fiberId: this.fiberId.toJSON() }\n      case \"Fail\":\n        return { _id: \"Cause\", _tag: this._tag, failure: toJSON(this.error) }\n      case \"Sequential\":\n      case \"Parallel\":\n        return { _id: \"Cause\", _tag: this._tag, left: toJSON(this.left), right: toJSON(this.right) }\n    }\n  },\n  toString<E>(this: Cause.Cause<E>) {\n    return pretty(this)\n  },\n  [NodeInspectSymbol]<E>(this: Cause.Cause<E>) {\n    return this.toJSON()\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const empty: Cause.Cause<never> = (() => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_EMPTY\n  return o\n})()\n\n/** @internal */\nexport const fail = <E>(error: E): Cause.Cause<E> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_FAIL\n  o.error = error\n  return o\n}\n\n/** @internal */\nexport const die = (defect: unknown): Cause.Cause<never> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_DIE\n  o.defect = defect\n  return o\n}\n\n/** @internal */\nexport const interrupt = (fiberId: FiberId.FiberId): Cause.Cause<never> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_INTERRUPT\n  o.fiberId = fiberId\n  return o\n}\n\n/** @internal */\nexport const parallel = <E, E2>(left: Cause.Cause<E>, right: Cause.Cause<E2>): Cause.Cause<E | E2> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_PARALLEL\n  o.left = left\n  o.right = right\n  return o\n}\n\n/** @internal */\nexport const sequential = <E, E2>(left: Cause.Cause<E>, right: Cause.Cause<E2>): Cause.Cause<E | E2> => {\n  const o = Object.create(proto)\n  o._tag = OpCodes.OP_SEQUENTIAL\n  o.left = left\n  o.right = right\n  return o\n}\n\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const isCause = (u: unknown): u is Cause.Cause<unknown> => hasProperty(u, CauseTypeId)\n\n/** @internal */\nexport const isEmptyType = <E>(self: Cause.Cause<E>): self is Cause.Empty => self._tag === OpCodes.OP_EMPTY\n\n/** @internal */\nexport const isFailType = <E>(self: Cause.Cause<E>): self is Cause.Fail<E> => self._tag === OpCodes.OP_FAIL\n\n/** @internal */\nexport const isDieType = <E>(self: Cause.Cause<E>): self is Cause.Die => self._tag === OpCodes.OP_DIE\n\n/** @internal */\nexport const isInterruptType = <E>(self: Cause.Cause<E>): self is Cause.Interrupt => self._tag === OpCodes.OP_INTERRUPT\n\n/** @internal */\nexport const isSequentialType = <E>(self: Cause.Cause<E>): self is Cause.Sequential<E> =>\n  self._tag === OpCodes.OP_SEQUENTIAL\n\n/** @internal */\nexport const isParallelType = <E>(self: Cause.Cause<E>): self is Cause.Parallel<E> => self._tag === OpCodes.OP_PARALLEL\n\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const size = <E>(self: Cause.Cause<E>): number => reduceWithContext(self, void 0, SizeCauseReducer)\n\n/** @internal */\nexport const isEmpty = <E>(self: Cause.Cause<E>): boolean => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY: {\n        return Option.some(acc)\n      }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT: {\n        return Option.some(false)\n      }\n      default: {\n        return Option.none()\n      }\n    }\n  })\n}\n\n/** @internal */\nexport const isFailure = <E>(self: Cause.Cause<E>): boolean => Option.isSome(failureOption(self))\n\n/** @internal */\nexport const isDie = <E>(self: Cause.Cause<E>): boolean => Option.isSome(dieOption(self))\n\n/** @internal */\nexport const isInterrupted = <E>(self: Cause.Cause<E>): boolean => Option.isSome(interruptOption(self))\n\n/** @internal */\nexport const isInterruptedOnly = <E>(self: Cause.Cause<E>): boolean =>\n  reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self)\n\n/** @internal */\nexport const failures = <E>(self: Cause.Cause<E>): Chunk.Chunk<E> =>\n  Chunk.reverse(\n    reduce<Chunk.Chunk<E>, E>(\n      self,\n      Chunk.empty<E>(),\n      (list, cause) =>\n        cause._tag === OpCodes.OP_FAIL ?\n          Option.some(pipe(list, Chunk.prepend(cause.error))) :\n          Option.none()\n    )\n  )\n\n/** @internal */\nexport const defects = <E>(self: Cause.Cause<E>): Chunk.Chunk<unknown> =>\n  Chunk.reverse(\n    reduce<Chunk.Chunk<unknown>, E>(\n      self,\n      Chunk.empty<unknown>(),\n      (list, cause) =>\n        cause._tag === OpCodes.OP_DIE ?\n          Option.some(pipe(list, Chunk.prepend(cause.defect))) :\n          Option.none()\n    )\n  )\n\n/** @internal */\nexport const interruptors = <E>(self: Cause.Cause<E>): HashSet.HashSet<FiberId.FiberId> =>\n  reduce(self, HashSet.empty<FiberId.FiberId>(), (set, cause) =>\n    cause._tag === OpCodes.OP_INTERRUPT ?\n      Option.some(pipe(set, HashSet.add(cause.fiberId))) :\n      Option.none())\n\n/** @internal */\nexport const failureOption = <E>(self: Cause.Cause<E>): Option.Option<E> =>\n  find<E, E>(self, (cause) =>\n    cause._tag === OpCodes.OP_FAIL ?\n      Option.some(cause.error) :\n      Option.none())\n\n/** @internal */\nexport const failureOrCause = <E>(self: Cause.Cause<E>): Either.Either<Cause.Cause<never>, E> => {\n  const option = failureOption(self)\n  switch (option._tag) {\n    case \"None\": {\n      // no `E` inside this `Cause`, so it can be safely cast to `never`\n      return Either.right(self as Cause.Cause<never>)\n    }\n    case \"Some\": {\n      return Either.left(option.value)\n    }\n  }\n}\n\n/** @internal */\nexport const dieOption = <E>(self: Cause.Cause<E>): Option.Option<unknown> =>\n  find(self, (cause) =>\n    cause._tag === OpCodes.OP_DIE ?\n      Option.some(cause.defect) :\n      Option.none())\n\n/** @internal */\nexport const flipCauseOption = <E>(self: Cause.Cause<Option.Option<E>>): Option.Option<Cause.Cause<E>> =>\n  match(self, {\n    onEmpty: Option.some<Cause.Cause<E>>(empty),\n    onFail: Option.map(fail),\n    onDie: (defect) => Option.some(die(defect)),\n    onInterrupt: (fiberId) => Option.some(interrupt(fiberId)),\n    onSequential: Option.mergeWith(sequential),\n    onParallel: Option.mergeWith(parallel)\n  })\n\n/** @internal */\nexport const interruptOption = <E>(self: Cause.Cause<E>): Option.Option<FiberId.FiberId> =>\n  find(self, (cause) =>\n    cause._tag === OpCodes.OP_INTERRUPT ?\n      Option.some(cause.fiberId) :\n      Option.none())\n\n/** @internal */\nexport const keepDefects = <E>(self: Cause.Cause<E>): Option.Option<Cause.Cause<never>> =>\n  match(self, {\n    onEmpty: Option.none(),\n    onFail: () => Option.none(),\n    onDie: (defect) => Option.some(die(defect)),\n    onInterrupt: () => Option.none(),\n    onSequential: Option.mergeWith(sequential),\n    onParallel: Option.mergeWith(parallel)\n  })\n\n/** @internal */\nexport const keepDefectsAndElectFailures = <E>(self: Cause.Cause<E>): Option.Option<Cause.Cause<never>> =>\n  match(self, {\n    onEmpty: Option.none(),\n    onFail: (failure) => Option.some(die(failure)),\n    onDie: (defect) => Option.some(die(defect)),\n    onInterrupt: () => Option.none(),\n    onSequential: Option.mergeWith(sequential),\n    onParallel: Option.mergeWith(parallel)\n  })\n\n/** @internal */\nexport const linearize = <E>(self: Cause.Cause<E>): HashSet.HashSet<Cause.Cause<E>> =>\n  match(self, {\n    onEmpty: HashSet.empty(),\n    onFail: (error) => HashSet.make(fail(error)),\n    onDie: (defect) => HashSet.make(die(defect)),\n    onInterrupt: (fiberId) => HashSet.make(interrupt(fiberId)),\n    onSequential: (leftSet, rightSet) =>\n      HashSet.flatMap(leftSet, (leftCause) => HashSet.map(rightSet, (rightCause) => sequential(leftCause, rightCause))),\n    onParallel: (leftSet, rightSet) =>\n      HashSet.flatMap(leftSet, (leftCause) => HashSet.map(rightSet, (rightCause) => parallel(leftCause, rightCause)))\n  })\n\n/** @internal */\nexport const stripFailures = <E>(self: Cause.Cause<E>): Cause.Cause<never> =>\n  match(self, {\n    onEmpty: empty,\n    onFail: () => empty,\n    onDie: die,\n    onInterrupt: interrupt,\n    onSequential: sequential,\n    onParallel: parallel\n  })\n\n/** @internal */\nexport const electFailures = <E>(self: Cause.Cause<E>): Cause.Cause<never> =>\n  match(self, {\n    onEmpty: empty,\n    onFail: die,\n    onDie: die,\n    onInterrupt: interrupt,\n    onSequential: sequential,\n    onParallel: parallel\n  })\n\n/** @internal */\nexport const stripSomeDefects = dual<\n  (pf: (defect: unknown) => Option.Option<unknown>) => <E>(self: Cause.Cause<E>) => Option.Option<Cause.Cause<E>>,\n  <E>(self: Cause.Cause<E>, pf: (defect: unknown) => Option.Option<unknown>) => Option.Option<Cause.Cause<E>>\n>(\n  2,\n  <E>(self: Cause.Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause.Cause<E>> =>\n    match(self, {\n      onEmpty: Option.some<Cause.Cause<E>>(empty),\n      onFail: (error) => Option.some(fail(error)),\n      onDie: (defect) => {\n        const option = pf(defect)\n        return Option.isSome(option) ? Option.none() : Option.some(die(defect))\n      },\n      onInterrupt: (fiberId) => Option.some(interrupt(fiberId)),\n      onSequential: Option.mergeWith(sequential),\n      onParallel: Option.mergeWith(parallel)\n    })\n)\n\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const as = dual<\n  <E2>(error: E2) => <E>(self: Cause.Cause<E>) => Cause.Cause<E2>,\n  <E, E2>(self: Cause.Cause<E>, error: E2) => Cause.Cause<E2>\n>(2, (self, error) => map(self, () => error))\n\n/** @internal */\nexport const map = dual<\n  <E, E2>(f: (e: E) => E2) => (self: Cause.Cause<E>) => Cause.Cause<E2>,\n  <E, E2>(self: Cause.Cause<E>, f: (e: E) => E2) => Cause.Cause<E2>\n>(2, (self, f) => flatMap(self, (e) => fail(f(e))))\n\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const flatMap = dual<\n  <E, E2>(f: (e: E) => Cause.Cause<E2>) => (self: Cause.Cause<E>) => Cause.Cause<E2>,\n  <E, E2>(self: Cause.Cause<E>, f: (e: E) => Cause.Cause<E2>) => Cause.Cause<E2>\n>(2, (self, f) =>\n  match(self, {\n    onEmpty: empty,\n    onFail: (error) => f(error),\n    onDie: (defect) => die(defect),\n    onInterrupt: (fiberId) => interrupt(fiberId),\n    onSequential: (left, right) => sequential(left, right),\n    onParallel: (left, right) => parallel(left, right)\n  }))\n\n/** @internal */\nexport const flatten = <E>(self: Cause.Cause<Cause.Cause<E>>): Cause.Cause<E> => flatMap(self, identity)\n\n/** @internal */\nexport const andThen: {\n  <E, E2>(f: (e: E) => Cause.Cause<E2>): (self: Cause.Cause<E>) => Cause.Cause<E2>\n  <E2>(f: Cause.Cause<E2>): <E>(self: Cause.Cause<E>) => Cause.Cause<E2>\n  <E, E2>(self: Cause.Cause<E>, f: (e: E) => Cause.Cause<E2>): Cause.Cause<E2>\n  <E, E2>(self: Cause.Cause<E>, f: Cause.Cause<E2>): Cause.Cause<E2>\n} = dual(\n  2,\n  <E, E2>(self: Cause.Cause<E>, f: ((e: E) => Cause.Cause<E2>) | Cause.Cause<E2>): Cause.Cause<E2> =>\n    isFunction(f) ? flatMap(self, f) : flatMap(self, () => f)\n)\n\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const contains = dual<\n  <E2>(that: Cause.Cause<E2>) => <E>(self: Cause.Cause<E>) => boolean,\n  <E, E2>(self: Cause.Cause<E>, that: Cause.Cause<E2>) => boolean\n>(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that))\n  })\n})\n\n/** @internal */\nconst causeEquals = (left: Cause.Cause<unknown>, right: Cause.Cause<unknown>): boolean => {\n  let leftStack: Chunk.Chunk<Cause.Cause<unknown>> = Chunk.of(left)\n  let rightStack: Chunk.Chunk<Cause.Cause<unknown>> = Chunk.of(right)\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = pipe(\n      Chunk.headNonEmpty(leftStack),\n      reduce(\n        [HashSet.empty<unknown>(), Chunk.empty<Cause.Cause<unknown>>()] as const,\n        ([parallel, sequential], cause) => {\n          const [par, seq] = evaluateCause(cause)\n          return Option.some(\n            [\n              pipe(parallel, HashSet.union(par)),\n              pipe(sequential, Chunk.appendAll(seq))\n            ] as const\n          )\n        }\n      )\n    )\n    const [rightParallel, rightSequential] = pipe(\n      Chunk.headNonEmpty(rightStack),\n      reduce(\n        [HashSet.empty<unknown>(), Chunk.empty<Cause.Cause<unknown>>()] as const,\n        ([parallel, sequential], cause) => {\n          const [par, seq] = evaluateCause(cause)\n          return Option.some(\n            [\n              pipe(parallel, HashSet.union(par)),\n              pipe(sequential, Chunk.appendAll(seq))\n            ] as const\n          )\n        }\n      )\n    )\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false\n    }\n    leftStack = leftSequential\n    rightStack = rightSequential\n  }\n  return true\n}\n\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = (cause: Cause.Cause<unknown>): Chunk.Chunk<HashSet.HashSet<unknown>> => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty())\n}\n\n/** @internal */\nconst flattenCauseLoop = (\n  causes: Chunk.Chunk<Cause.Cause<unknown>>,\n  flattened: Chunk.Chunk<HashSet.HashSet<unknown>>\n): Chunk.Chunk<HashSet.HashSet<unknown>> => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = pipe(\n      causes,\n      Arr.reduce(\n        [HashSet.empty<unknown>(), Chunk.empty<Cause.Cause<unknown>>()] as const,\n        ([parallel, sequential], cause) => {\n          const [par, seq] = evaluateCause(cause)\n          return [\n            pipe(parallel, HashSet.union(par)),\n            pipe(sequential, Chunk.appendAll(seq))\n          ]\n        }\n      )\n    )\n    const updated = HashSet.size(parallel) > 0 ?\n      pipe(flattened, Chunk.prepend(parallel)) :\n      flattened\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated)\n    }\n    causes = sequential\n    flattened = updated\n  }\n  throw new Error(getBugErrorMessage(\"Cause.flattenCauseLoop\"))\n}\n\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const find = dual<\n  <E, Z>(pf: (cause: Cause.Cause<E>) => Option.Option<Z>) => (self: Cause.Cause<E>) => Option.Option<Z>,\n  <E, Z>(self: Cause.Cause<E>, pf: (cause: Cause.Cause<E>) => Option.Option<Z>) => Option.Option<Z>\n>(2, <E, Z>(self: Cause.Cause<E>, pf: (cause: Cause.Cause<E>) => Option.Option<Z>) => {\n  const stack: Array<Cause.Cause<E>> = [self]\n  while (stack.length > 0) {\n    const item = stack.pop()!\n    const option = pf(item)\n    switch (option._tag) {\n      case \"None\": {\n        switch (item._tag) {\n          case OpCodes.OP_SEQUENTIAL:\n          case OpCodes.OP_PARALLEL: {\n            stack.push(item.right)\n            stack.push(item.left)\n            break\n          }\n        }\n        break\n      }\n      case \"Some\": {\n        return option\n      }\n    }\n  }\n  return Option.none()\n})\n\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const filter: {\n  <E, EB extends E>(\n    refinement: Refinement<Cause.Cause<NoInfer<E>>, Cause.Cause<EB>>\n  ): (self: Cause.Cause<E>) => Cause.Cause<EB>\n  <E>(predicate: Predicate<Cause.Cause<NoInfer<E>>>): (self: Cause.Cause<E>) => Cause.Cause<E>\n  <E, EB extends E>(self: Cause.Cause<E>, refinement: Refinement<Cause.Cause<E>, Cause.Cause<EB>>): Cause.Cause<EB>\n  <E>(self: Cause.Cause<E>, predicate: Predicate<Cause.Cause<E>>): Cause.Cause<E>\n} = dual(\n  2,\n  <E>(self: Cause.Cause<E>, predicate: Predicate<Cause.Cause<E>>): Cause.Cause<E> =>\n    reduceWithContext(self, void 0, FilterCauseReducer(predicate))\n)\n\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = (\n  self: Cause.Cause<unknown>\n): [HashSet.HashSet<unknown>, Chunk.Chunk<Cause.Cause<unknown>>] => {\n  let cause: Cause.Cause<unknown> | undefined = self\n  const stack: Array<Cause.Cause<unknown>> = []\n  let _parallel = HashSet.empty<unknown>()\n  let _sequential = Chunk.empty<Cause.Cause<unknown>>()\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY: {\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_FAIL: {\n        _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.error))\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_DIE: {\n        _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.defect))\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_INTERRUPT: {\n        _parallel = HashSet.add(_parallel, Chunk.make(cause._tag, cause.fiberId as unknown))\n        if (stack.length === 0) {\n          return [_parallel, _sequential]\n        }\n        cause = stack.pop()\n        break\n      }\n      case OpCodes.OP_SEQUENTIAL: {\n        switch (cause.left._tag) {\n          case OpCodes.OP_EMPTY: {\n            cause = cause.right\n            break\n          }\n          case OpCodes.OP_SEQUENTIAL: {\n            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right))\n            break\n          }\n          case OpCodes.OP_PARALLEL: {\n            cause = parallel(\n              sequential(cause.left.left, cause.right),\n              sequential(cause.left.right, cause.right)\n            )\n            break\n          }\n          default: {\n            _sequential = Chunk.prepend(_sequential, cause.right)\n            cause = cause.left\n            break\n          }\n        }\n        break\n      }\n      case OpCodes.OP_PARALLEL: {\n        stack.push(cause.right)\n        cause = cause.left\n        break\n      }\n    }\n  }\n  throw new Error(getBugErrorMessage(\"Cause.evaluateCauseLoop\"))\n}\n\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst SizeCauseReducer: Cause.CauseReducer<unknown, unknown, number> = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n}\n\n/** @internal */\nconst IsInterruptedOnlyCauseReducer: Cause.CauseReducer<unknown, unknown, boolean> = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n}\n\n/** @internal */\nconst FilterCauseReducer = <E>(\n  predicate: Predicate<Cause.Cause<E>>\n): Cause.CauseReducer<unknown, E, Cause.Cause<E>> => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right)\n      }\n      return left\n    }\n    if (predicate(right)) {\n      return right\n    }\n    return empty\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right)\n      }\n      return left\n    }\n    if (predicate(right)) {\n      return right\n    }\n    return empty\n  }\n})\n\n/** @internal */\ntype CauseCase = SequentialCase | ParallelCase\n\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\"\n\nconst OP_PARALLEL_CASE = \"ParallelCase\"\n\n/** @internal */\ninterface SequentialCase {\n  readonly _tag: typeof OP_SEQUENTIAL_CASE\n}\n\n/** @internal */\ninterface ParallelCase {\n  readonly _tag: typeof OP_PARALLEL_CASE\n}\n\n/** @internal */\nexport const match = dual<\n  <Z, E>(\n    options: {\n      readonly onEmpty: Z\n      readonly onFail: (error: E) => Z\n      readonly onDie: (defect: unknown) => Z\n      readonly onInterrupt: (fiberId: FiberId.FiberId) => Z\n      readonly onSequential: (left: Z, right: Z) => Z\n      readonly onParallel: (left: Z, right: Z) => Z\n    }\n  ) => (self: Cause.Cause<E>) => Z,\n  <Z, E>(\n    self: Cause.Cause<E>,\n    options: {\n      readonly onEmpty: Z\n      readonly onFail: (error: E) => Z\n      readonly onDie: (defect: unknown) => Z\n      readonly onInterrupt: (fiberId: FiberId.FiberId) => Z\n      readonly onSequential: (left: Z, right: Z) => Z\n      readonly onParallel: (left: Z, right: Z) => Z\n    }\n  ) => Z\n>(2, (self, { onDie, onEmpty, onFail, onInterrupt, onParallel, onSequential }) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => onEmpty,\n    failCase: (_, error) => onFail(error),\n    dieCase: (_, defect) => onDie(defect),\n    interruptCase: (_, fiberId) => onInterrupt(fiberId),\n    sequentialCase: (_, left, right) => onSequential(left, right),\n    parallelCase: (_, left, right) => onParallel(left, right)\n  })\n})\n\n/** @internal */\nexport const reduce = dual<\n  <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause.Cause<E>) => Option.Option<Z>) => (self: Cause.Cause<E>) => Z,\n  <Z, E>(self: Cause.Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause.Cause<E>) => Option.Option<Z>) => Z\n>(3, <Z, E>(self: Cause.Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause.Cause<E>) => Option.Option<Z>) => {\n  let accumulator: Z = zero\n  let cause: Cause.Cause<E> | undefined = self\n  const causes: Array<Cause.Cause<E>> = []\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause)\n    accumulator = Option.isSome(option) ? option.value : accumulator\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL: {\n        causes.push(cause.right)\n        cause = cause.left\n        break\n      }\n      case OpCodes.OP_PARALLEL: {\n        causes.push(cause.right)\n        cause = cause.left\n        break\n      }\n      default: {\n        cause = undefined\n        break\n      }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop()!\n    }\n  }\n  return accumulator\n})\n\n/** @internal */\nexport const reduceWithContext = dual<\n  <C, E, Z>(context: C, reducer: Cause.CauseReducer<C, E, Z>) => (self: Cause.Cause<E>) => Z,\n  <C, E, Z>(self: Cause.Cause<E>, context: C, reducer: Cause.CauseReducer<C, E, Z>) => Z\n>(3, <C, E, Z>(self: Cause.Cause<E>, context: C, reducer: Cause.CauseReducer<C, E, Z>) => {\n  const input: Array<Cause.Cause<E>> = [self]\n  const output: Array<Either.Either<Z, CauseCase>> = []\n  while (input.length > 0) {\n    const cause = input.pop()!\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY: {\n        output.push(Either.right(reducer.emptyCase(context)))\n        break\n      }\n      case OpCodes.OP_FAIL: {\n        output.push(Either.right(reducer.failCase(context, cause.error)))\n        break\n      }\n      case OpCodes.OP_DIE: {\n        output.push(Either.right(reducer.dieCase(context, cause.defect)))\n        break\n      }\n      case OpCodes.OP_INTERRUPT: {\n        output.push(Either.right(reducer.interruptCase(context, cause.fiberId)))\n        break\n      }\n      case OpCodes.OP_SEQUENTIAL: {\n        input.push(cause.right)\n        input.push(cause.left)\n        output.push(Either.left({ _tag: OP_SEQUENTIAL_CASE }))\n        break\n      }\n      case OpCodes.OP_PARALLEL: {\n        input.push(cause.right)\n        input.push(cause.left)\n        output.push(Either.left({ _tag: OP_PARALLEL_CASE }))\n        break\n      }\n    }\n  }\n  const accumulator: Array<Z> = []\n  while (output.length > 0) {\n    const either = output.pop()!\n    switch (either._tag) {\n      case \"Left\": {\n        switch (either.left._tag) {\n          case OP_SEQUENTIAL_CASE: {\n            const left = accumulator.pop()!\n            const right = accumulator.pop()!\n            const value = reducer.sequentialCase(context, left, right)\n            accumulator.push(value)\n            break\n          }\n          case OP_PARALLEL_CASE: {\n            const left = accumulator.pop()!\n            const right = accumulator.pop()!\n            const value = reducer.parallelCase(context, left, right)\n            accumulator.push(value)\n            break\n          }\n        }\n        break\n      }\n      case \"Right\": {\n        accumulator.push(either.right)\n        break\n      }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\n      \"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\"\n    )\n  }\n  return accumulator.pop()!\n})\n\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const pretty = <E>(cause: Cause.Cause<E>, options?: {\n  readonly renderErrorCause?: boolean | undefined\n}): string => {\n  if (isInterruptedOnly(cause)) {\n    return \"All fibers interrupted without errors.\"\n  }\n  return prettyErrors<E>(cause).map(function(e) {\n    if (options?.renderErrorCause !== true || e.cause === undefined) {\n      return e.stack\n    }\n    return `${e.stack} {\\n${renderErrorCause(e.cause as PrettyError, \"  \")}\\n}`\n  }).join(\"\\n\")\n}\n\nconst renderErrorCause = (cause: PrettyError, prefix: string) => {\n  const lines = cause.stack!.split(\"\\n\")\n  let stack = `${prefix}[cause]: ${lines[0]}`\n  for (let i = 1, len = lines.length; i < len; i++) {\n    stack += `\\n${prefix}${lines[i]}`\n  }\n  if (cause.cause) {\n    stack += ` {\\n${renderErrorCause(cause.cause as PrettyError, `${prefix}  `)}\\n${prefix}}`\n  }\n  return stack\n}\n\n/** @internal */\nexport class PrettyError extends globalThis.Error implements Cause.PrettyError {\n  span: undefined | Span = undefined\n  constructor(originalError: unknown) {\n    const originalErrorIsObject = typeof originalError === \"object\" && originalError !== null\n    const prevLimit = Error.stackTraceLimit\n    Error.stackTraceLimit = 1\n    super(\n      prettyErrorMessage(originalError),\n      originalErrorIsObject && \"cause\" in originalError && typeof originalError.cause !== \"undefined\"\n        ? { cause: new PrettyError(originalError.cause) }\n        : undefined\n    )\n    if (this.message === \"\") {\n      this.message = \"An error has occurred\"\n    }\n    Error.stackTraceLimit = prevLimit\n    this.name = originalError instanceof Error ? originalError.name : \"Error\"\n    if (originalErrorIsObject) {\n      if (spanSymbol in originalError) {\n        this.span = originalError[spanSymbol] as Span\n      }\n      Object.keys(originalError).forEach((key) => {\n        if (!(key in this)) {\n          // @ts-expect-error\n          this[key] = originalError[key]\n        }\n      })\n    }\n    this.stack = prettyErrorStack(\n      `${this.name}: ${this.message}`,\n      originalError instanceof Error && originalError.stack\n        ? originalError.stack\n        : \"\",\n      this.span\n    )\n  }\n}\n\n/**\n * A utility function for generating human-readable error messages from a generic error of type `unknown`.\n *\n * Rules:\n *\n * 1) If the input `u` is already a string, it's considered a message.\n * 2) If `u` is an Error instance with a message defined, it uses the message.\n * 3) If `u` has a user-defined `toString()` method, it uses that method.\n * 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,\n *   with \"Error\" added as a prefix.\n *\n * @internal\n */\nexport const prettyErrorMessage = (u: unknown): string => {\n  // 1)\n  if (typeof u === \"string\") {\n    return u\n  }\n  // 2)\n  if (typeof u === \"object\" && u !== null && u instanceof Error) {\n    return u.message\n  }\n  // 3)\n  try {\n    if (\n      hasProperty(u, \"toString\") &&\n      isFunction(u[\"toString\"]) &&\n      u[\"toString\"] !== Object.prototype.toString &&\n      u[\"toString\"] !== globalThis.Array.prototype.toString\n    ) {\n      return u[\"toString\"]()\n    }\n  } catch {\n    // something's off, rollback to json\n  }\n  // 4)\n  return stringifyCircular(u)\n}\n\nconst locationRegex = /\\((.*)\\)/g\n\n/** @internal */\nexport const spanToTrace = globalValue(\"effect/Tracer/spanToTrace\", () => new WeakMap())\n\nconst prettyErrorStack = (message: string, stack: string, span?: Span | undefined): string => {\n  const out: Array<string> = [message]\n  const lines = stack.startsWith(message) ? stack.slice(message.length).split(\"\\n\") : stack.split(\"\\n\")\n\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i].includes(\" at new BaseEffectError\") || lines[i].includes(\" at new YieldableError\")) {\n      i++\n      continue\n    }\n    if (lines[i].includes(\"Generator.next\")) {\n      break\n    }\n    if (lines[i].includes(\"effect_internal_function\")) {\n      break\n    }\n    out.push(\n      lines[i]\n        .replace(/at .*effect_instruction_i.*\\((.*)\\)/, \"at $1\")\n        .replace(/EffectPrimitive\\.\\w+/, \"<anonymous>\")\n    )\n  }\n\n  if (span) {\n    let current: Span | AnySpan | undefined = span\n    let i = 0\n    while (current && current._tag === \"Span\" && i < 10) {\n      const stackFn = spanToTrace.get(current)\n      if (typeof stackFn === \"function\") {\n        const stack = stackFn()\n        if (typeof stack === \"string\") {\n          const locationMatchAll = stack.matchAll(locationRegex)\n          let match = false\n          for (const [, location] of locationMatchAll) {\n            match = true\n            out.push(`    at ${current.name} (${location})`)\n          }\n          if (!match) {\n            out.push(`    at ${current.name} (${stack.replace(/^at /, \"\")})`)\n          }\n        } else {\n          out.push(`    at ${current.name}`)\n        }\n      } else {\n        out.push(`    at ${current.name}`)\n      }\n      current = Option.getOrUndefined(current.parent)\n      i++\n    }\n  }\n\n  return out.join(\"\\n\")\n}\n\n/** @internal */\nexport const spanSymbol = Symbol.for(\"effect/SpanAnnotation\")\n\n/** @internal */\nexport const prettyErrors = <E>(cause: Cause.Cause<E>): Array<PrettyError> =>\n  reduceWithContext(cause, void 0, {\n    emptyCase: (): Array<PrettyError> => [],\n    dieCase: (_, unknownError) => {\n      return [new PrettyError(unknownError)]\n    },\n    failCase: (_, error) => {\n      return [new PrettyError(error)]\n    },\n    interruptCase: () => [],\n    parallelCase: (_, l, r) => [...l, ...r],\n    sequentialCase: (_, l, r) => [...l, ...r]\n  })\n","/** @internal */\nexport const OP_DIE = \"Die\" as const\n\n/** @internal */\nexport type OP_DIE = typeof OP_DIE\n\n/** @internal */\nexport const OP_EMPTY = \"Empty\" as const\n\n/** @internal */\nexport type OP_EMPTY = typeof OP_EMPTY\n\n/** @internal */\nexport const OP_FAIL = \"Fail\" as const\n\n/** @internal */\nexport type OP_FAIL = typeof OP_FAIL\n\n/** @internal */\nexport const OP_INTERRUPT = \"Interrupt\" as const\n\n/** @internal */\nexport type OP_INTERRUPT = typeof OP_INTERRUPT\n\n/** @internal */\nexport const OP_PARALLEL = \"Parallel\" as const\n\n/** @internal */\nexport type OP_PARALLEL = typeof OP_PARALLEL\n\n/** @internal */\nexport const OP_SEQUENTIAL = \"Sequential\" as const\n\n/** @internal */\nexport type OP_SEQUENTIAL = typeof OP_SEQUENTIAL\n","import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport type * as Differ from \"../Differ.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as HashSet from \"../HashSet.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as List from \"../List.js\"\nimport type * as LogLevel from \"../LogLevel.js\"\nimport type * as LogSpan from \"../LogSpan.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, isObject, isPromiseLike, type Predicate, type Refinement } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as BlockedRequests from \"../RequestBlock.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type { NoInfer, NotFunction } from \"../Types.js\"\nimport { internalCall, YieldWrap } from \"../Utils.js\"\nimport * as blockedRequests_ from \"./blockedRequests.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as deferred from \"./deferred.js\"\nimport * as internalDiffer from \"./differ.js\"\nimport { CommitPrototype, effectVariance, StructuralCommitPrototype } from \"./effectable.js\"\nimport { getBugErrorMessage } from \"./errors.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\nimport type * as fiberScope from \"./fiberScope.js\"\nimport * as DeferredOpCodes from \"./opCodes/deferred.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as runtimeFlags_ from \"./runtimeFlags.js\"\nimport { SingleShotGen } from \"./singleShotGen.js\"\n\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n\n/**\n * @internal\n */\nexport const blocked = <A, E>(\n  blockedRequests: BlockedRequests.RequestBlock,\n  _continue: Effect.Effect<A, E>\n): Effect.Blocked<A, E> => {\n  const effect = new EffectPrimitive(\"Blocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  effect.effect_instruction_i1 = _continue\n  return effect\n}\n\n/**\n * @internal\n */\nexport const runRequestBlock = (\n  blockedRequests: BlockedRequests.RequestBlock\n): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(\"RunBlocked\") as any\n  effect.effect_instruction_i0 = blockedRequests\n  return effect\n}\n\n/** @internal */\nexport const EffectTypeId: Effect.EffectTypeId = Symbol.for(\"effect/Effect\") as Effect.EffectTypeId\n\n/** @internal */\nexport type Primitive =\n  | Async\n  | Commit\n  | Failure\n  | OnFailure\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | Success\n  | Sync\n  | UpdateRuntimeFlags\n  | While\n  | FromIterator\n  | WithRuntime\n  | Yield\n  | OpTag\n  | Blocked\n  | RunBlocked\n  | Either.Either<any, any>\n  | Option.Option<any>\n\n/** @internal */\nexport type Continuation =\n  | OnSuccess\n  | OnStep\n  | OnSuccessAndFailure\n  | OnFailure\n  | While\n  | FromIterator\n  | RevertFlags\n\n/** @internal */\nexport class RevertFlags {\n  readonly _op = OpCodes.OP_REVERT_FLAGS\n  constructor(\n    readonly patch: RuntimeFlagsPatch.RuntimeFlagsPatch,\n    readonly op: Primitive & { _op: OpCodes.OP_UPDATE_RUNTIME_FLAGS }\n  ) {\n  }\n}\n\nclass EffectPrimitive {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {}\n  [Equal.symbol](this: {}, that: unknown) {\n    return this === that\n  }\n  [Hash.symbol](this: {}) {\n    return Hash.cached(this, Hash.random(this))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Effect\",\n      _op: this._op,\n      effect_instruction_i0: toJSON(this.effect_instruction_i0),\n      effect_instruction_i1: toJSON(this.effect_instruction_i1),\n      effect_instruction_i2: toJSON(this.effect_instruction_i2)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveFailure {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Failure\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get cause() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      cause: (this.cause as any).toJSON()\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nclass EffectPrimitiveSuccess {\n  public effect_instruction_i0 = undefined\n  public effect_instruction_i1 = undefined\n  public effect_instruction_i2 = undefined\n  public trace = undefined;\n  [EffectTypeId] = effectVariance\n  constructor(readonly _op: Primitive[\"_op\"]) {\n    // @ts-expect-error\n    this._tag = _op\n  }\n  [Equal.symbol](this: {}, that: unknown) {\n    return exitIsExit(that) && that._op === \"Success\" &&\n      // @ts-expect-error\n      Equal.equals(this.effect_instruction_i0, that.effect_instruction_i0)\n  }\n  [Hash.symbol](this: {}) {\n    return pipe(\n      // @ts-expect-error\n      Hash.string(this._tag),\n      // @ts-expect-error\n      Hash.combine(Hash.hash(this.effect_instruction_i0)),\n      Hash.cached(this)\n    )\n  }\n  get value() {\n    return this.effect_instruction_i0\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toJSON() {\n    return {\n      _id: \"Exit\",\n      _tag: this._op,\n      value: toJSON(this.value)\n    }\n  }\n  toString() {\n    return format(this.toJSON())\n  }\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this))\n  }\n}\n\n/** @internal */\nexport type Op<Tag extends string, Body = {}> = Effect.Effect<never> & Body & {\n  readonly _op: Tag\n}\n\n/** @internal */\nexport interface Async extends\n  Op<OpCodes.OP_ASYNC, {\n    effect_instruction_i0(resume: (effect: Primitive) => void): void\n    readonly effect_instruction_i1: FiberId.FiberId\n  }>\n{}\n\n/** @internal */\nexport interface Blocked<out E = any, out A = any> extends\n  Op<\"Blocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n    readonly effect_instruction_i1: Effect.Effect<A, E>\n  }>\n{}\n\n/** @internal */\nexport interface RunBlocked extends\n  Op<\"RunBlocked\", {\n    readonly effect_instruction_i0: BlockedRequests.RequestBlock\n  }>\n{}\n\n/** @internal */\nexport interface Failure extends\n  Op<OpCodes.OP_FAILURE, {\n    readonly effect_instruction_i0: Cause.Cause<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OpTag extends Op<OpCodes.OP_TAG, {}> {}\n\n/** @internal */\nexport interface Commit extends\n  Op<OpCodes.OP_COMMIT, {\n    commit(): Effect.Effect<unknown, unknown, unknown>\n  }>\n{}\n\n/** @internal */\nexport interface OnFailure extends\n  Op<OpCodes.OP_ON_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnSuccess extends\n  Op<OpCodes.OP_ON_SUCCESS, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface OnStep extends Op<\"OnStep\", { readonly effect_instruction_i0: Primitive }> {}\n\n/** @internal */\nexport interface OnSuccessAndFailure extends\n  Op<OpCodes.OP_ON_SUCCESS_AND_FAILURE, {\n    readonly effect_instruction_i0: Primitive\n    effect_instruction_i1(a: Cause.Cause<unknown>): Primitive\n    effect_instruction_i2(a: unknown): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Success extends\n  Op<OpCodes.OP_SUCCESS, {\n    readonly effect_instruction_i0: unknown\n  }>\n{}\n\n/** @internal */\nexport interface Sync extends\n  Op<OpCodes.OP_SYNC, {\n    effect_instruction_i0(): unknown\n  }>\n{}\n\n/** @internal */\nexport interface UpdateRuntimeFlags extends\n  Op<OpCodes.OP_UPDATE_RUNTIME_FLAGS, {\n    readonly effect_instruction_i0: RuntimeFlagsPatch.RuntimeFlagsPatch\n    readonly effect_instruction_i1?: (oldRuntimeFlags: RuntimeFlags.RuntimeFlags) => Primitive\n  }>\n{}\n\n/** @internal */\nexport interface While extends\n  Op<OpCodes.OP_WHILE, {\n    effect_instruction_i0(): boolean\n    effect_instruction_i1(): Primitive\n    effect_instruction_i2(a: unknown): void\n  }>\n{}\n\n/** @internal */\nexport interface FromIterator extends\n  Op<OpCodes.OP_ITERATOR, {\n    effect_instruction_i0: Iterator<YieldWrap<Primitive>, any>\n  }>\n{}\n\n/** @internal */\nexport interface WithRuntime extends\n  Op<OpCodes.OP_WITH_RUNTIME, {\n    effect_instruction_i0(fiber: FiberRuntime.FiberRuntime<unknown, unknown>, status: FiberStatus.Running): Primitive\n  }>\n{}\n\n/** @internal */\nexport interface Yield extends Op<OpCodes.OP_YIELD> {}\n\n/** @internal */\nexport const isEffect = (u: unknown): u is Effect.Effect<unknown, unknown, unknown> => hasProperty(u, EffectTypeId)\n\n/* @internal */\nexport const withFiberRuntime = <A, E = never, R = never>(\n  withRuntime: (fiber: FiberRuntime.FiberRuntime<A, E>, status: FiberStatus.Running) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WITH_RUNTIME) as any\n  effect.effect_instruction_i0 = withRuntime\n  return effect\n}\n\n/* @internal */\nexport const acquireUseRelease: {\n  <A2, E2, R2, A, X, R3>(\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): <E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2 | E, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, X, R3>(\n    acquire: Effect.Effect<A, E, R>,\n    use: (a: A) => Effect.Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n  ): Effect.Effect<A2, E | E2, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, X, R3>(\n  acquire: Effect.Effect<A, E, R>,\n  use: (a: A) => Effect.Effect<A2, E2, R2>,\n  release: (a: A, exit: Exit.Exit<A2, E2>) => Effect.Effect<X, never, R3>\n): Effect.Effect<A2, E | E2, R | R2 | R3> =>\n  uninterruptibleMask((restore) =>\n    flatMap(\n      acquire,\n      (a) =>\n        flatMap(exit(suspend(() => restore(use(a)))), (exit): Effect.Effect<A2, E | E2, R | R2 | R3> => {\n          return suspend(() => release(a, exit)).pipe(\n            matchCauseEffect({\n              onFailure: (cause) => {\n                switch (exit._tag) {\n                  case OpCodes.OP_FAILURE:\n                    return failCause(internalCause.sequential(exit.effect_instruction_i0, cause))\n                  case OpCodes.OP_SUCCESS:\n                    return failCause(cause)\n                }\n              },\n              onSuccess: () => exit\n            })\n          )\n        })\n    )\n  ))\n\n/* @internal */\nexport const as: {\n  <B>(value: B): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, value: B): Effect.Effect<B, E, R> => flatMap(self, () => succeed(value))\n)\n\n/* @internal */\nexport const asVoid = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, E, R> => as(self, void 0)\n\n/* @internal */\nexport const custom: {\n  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <X, Y, A, E, R>(\n    i0: X,\n    i1: Y,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n  <X, Y, Z, A, E, R>(\n    i0: X,\n    i1: Y,\n    i2: Z,\n    body: (\n      this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }\n    ) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = function() {\n  const wrapper = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  switch (arguments.length) {\n    case 2: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.commit = arguments[1]\n      break\n    }\n    case 3: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.commit = arguments[2]\n      break\n    }\n    case 4: {\n      wrapper.effect_instruction_i0 = arguments[0]\n      wrapper.effect_instruction_i1 = arguments[1]\n      wrapper.effect_instruction_i2 = arguments[2]\n      wrapper.commit = arguments[3]\n      break\n    }\n    default: {\n      throw new Error(getBugErrorMessage(\"you're not supposed to end up here\"))\n    }\n  }\n  return wrapper\n}\n\n/* @internal */\nexport const unsafeAsync = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n  let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n  effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n    cancelerRef = register(resume)\n  }\n  effect.effect_instruction_i1 = blockingOn\n  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_)\n}\n\n/* @internal */\nexport const asyncInterrupt = <A, E = never, R = never>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => suspend(() => unsafeAsync(register, blockingOn))\n\nconst async_ = <A, E = never, R = never>(\n  resume: (\n    callback: (_: Effect.Effect<A, E, R>) => void,\n    signal: AbortSignal\n  ) => void | Effect.Effect<void, never, R>,\n  blockingOn: FiberId.FiberId = FiberId.none\n): Effect.Effect<A, E, R> => {\n  return custom(resume, function() {\n    let backingResume: ((_: Effect.Effect<A, E, R>) => void) | undefined = undefined\n    let pendingEffect: Effect.Effect<A, E, R> | undefined = undefined\n    function proxyResume(effect: Effect.Effect<A, E, R>) {\n      if (backingResume) {\n        backingResume(effect)\n      } else if (pendingEffect === undefined) {\n        pendingEffect = effect\n      }\n    }\n    const effect = new EffectPrimitive(OpCodes.OP_ASYNC) as any\n    effect.effect_instruction_i0 = (resume: (_: Effect.Effect<A, E, R>) => void) => {\n      backingResume = resume\n      if (pendingEffect) {\n        resume(pendingEffect)\n      }\n    }\n    effect.effect_instruction_i1 = blockingOn\n    let cancelerRef: Effect.Effect<void, never, R> | void = undefined\n    let controllerRef: AbortController | void = undefined\n    if (this.effect_instruction_i0.length !== 1) {\n      controllerRef = new AbortController()\n      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef!.signal))\n    } else {\n      cancelerRef = internalCall(() => (this.effect_instruction_i0 as any)(proxyResume))\n    }\n    return (cancelerRef || controllerRef) ?\n      onInterrupt(effect, (_) => {\n        if (controllerRef) {\n          controllerRef.abort()\n        }\n        return cancelerRef ?? void_\n      }) :\n      effect\n  })\n}\nexport {\n  /** @internal */\n  async_ as async\n}\n\n/* @internal */\nexport const catchAllCause = dual<\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2 | A, E2, R2 | R>\n>(2, (self, f) => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = f\n  return effect\n})\n\n/* @internal */\nexport const catchAll: {\n  <E, A2, E2, R2>(\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => matchEffect(self, { onFailure: f, onSuccess: succeed })\n)\n\n/* @internal */\nexport const catchIf: {\n  <E, EB extends E, A2, E2, R2>(\n    refinement: Refinement<NoInfer<E>, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <E, A2, E2, R2>(\n    predicate: Predicate<NoInfer<E>>,\n    f: (e: NoInfer<E>) => Effect.Effect<A2, E2, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A | A2, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate<E>,\n  f: (e: E) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  catchAllCause(self, (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return predicate(either.left) ? f(either.left) : failCause(cause)\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const catchSome = dual<\n  <E, A2, E2, R2>(\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A2 | A, E | E2, R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  pf: (e: NoInfer<E>) => Option.Option<Effect.Effect<A2, E2, R2>>\n) =>\n  catchAllCause(self, (cause): Effect.Effect<A2 | A, E | E2, R2 | R> => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return pipe(pf(either.left), Option.getOrElse(() => failCause(cause)))\n      case \"Right\":\n        return failCause(either.right)\n    }\n  }))\n\n/* @internal */\nexport const checkInterruptible = <A, E, R>(\n  f: (isInterruptible: boolean) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((_, status) => f(runtimeFlags_.interruption(status.runtimeFlags)))\n\nconst originalSymbol = Symbol.for(\"effect/OriginalAnnotation\")\n\n/* @internal */\nexport const originalInstance = <E>(obj: E): E => {\n  if (hasProperty(obj, originalSymbol)) {\n    // @ts-expect-error\n    return obj[originalSymbol]\n  }\n  return obj\n}\n\n/* @internal */\nexport const capture = <E>(obj: E & object, span: Option.Option<Tracer.Span>): E => {\n  if (Option.isSome(span)) {\n    return new Proxy(obj, {\n      has(target, p) {\n        return p === internalCause.spanSymbol || p === originalSymbol || p in target\n      },\n      get(target, p) {\n        if (p === internalCause.spanSymbol) {\n          return span.value\n        }\n        if (p === originalSymbol) {\n          return obj\n        }\n        // @ts-expect-error\n        return target[p]\n      }\n    })\n  }\n  return obj\n}\n\n/* @internal */\nexport const die = (defect: unknown): Effect.Effect<never> =>\n  isObject(defect) && !(internalCause.spanSymbol in defect) ?\n    withFiberRuntime((fiber) => failCause(internalCause.die(capture(defect, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.die(defect))\n\n/* @internal */\nexport const dieMessage = (message: string): Effect.Effect<never> =>\n  failCauseSync(() => internalCause.die(new RuntimeException(message)))\n\n/* @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Effect.Effect<never> => flatMap(sync(evaluate), die)\n\n/* @internal */\nexport const either = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Either.Either<A, E>, never, R> =>\n  matchEffect(self, {\n    onFailure: (e) => succeed(Either.left(e)),\n    onSuccess: (a) => succeed(Either.right(a))\n  })\n\n/* @internal */\nexport const exit = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Exit.Exit<A, E>, never, R> =>\n  matchCause(self, {\n    onFailure: exitFailCause,\n    onSuccess: exitSucceed\n  })\n\n/* @internal */\nexport const fail = <E>(error: E): Effect.Effect<never, E> =>\n  isObject(error) && !(internalCause.spanSymbol in error) ?\n    withFiberRuntime((fiber) => failCause(internalCause.fail(capture(error, currentSpanFromFiber(fiber)))))\n    : failCause(internalCause.fail(error))\n\n/* @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Effect.Effect<never, E> => flatMap(sync(evaluate), fail)\n\n/* @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Effect.Effect<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/* @internal */\nexport const failCauseSync = <E>(\n  evaluate: LazyArg<Cause.Cause<E>>\n): Effect.Effect<never, E> => flatMap(sync(evaluate), failCause)\n\n/* @internal */\nexport const fiberId: Effect.Effect<FiberId.FiberId> = withFiberRuntime((state) => succeed(state.id()))\n\n/* @internal */\nexport const fiberIdWith = <A, E, R>(\n  f: (descriptor: FiberId.Runtime) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => withFiberRuntime((state) => f(state.id()))\n\n/* @internal */\nexport const flatMap = dual<\n  <A, B, E1, R1>(\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E1 | E, R1 | R>,\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: A) => Effect.Effect<B, E1, R1>\n  ) => Effect.Effect<B, E | E1, R | R1>\n>(\n  2,\n  (self, f) => {\n    const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS) as any\n    effect.effect_instruction_i0 = self\n    effect.effect_instruction_i1 = f\n    return effect\n  }\n)\n\n/* @internal */\nexport const andThen: {\n  <A, X>(\n    f: (a: NoInfer<A>) => X\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <X>(\n    f: NotFunction<X>\n  ): <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: (a: NoInfer<A>) => X\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    f: NotFunction<X>\n  ): [X] extends [Effect.Effect<infer A1, infer E1, infer R1>] ? Effect.Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect.Effect<A1, E | Cause.UnknownException, R>\n    : Effect.Effect<X, E, R>\n} = dual(2, (self, f) =>\n  flatMap(self, (a) => {\n    const b = typeof f === \"function\" ? (f as any)(a) : f\n    if (isEffect(b)) {\n      return b\n    } else if (isPromiseLike(b)) {\n      return unsafeAsync<any, Cause.UnknownException>((resume) => {\n        b.then((a) => resume(succeed(a)), (e) =>\n          resume(fail(new UnknownException(e, \"An unknown error occurred in Effect.andThen\"))))\n      })\n    }\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const step = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Exit.Exit<A, E> | Effect.Blocked<A, E>, never, R> => {\n  const effect = new EffectPrimitive(\"OnStep\") as any\n  effect.effect_instruction_i0 = self\n  return effect\n}\n\n/* @internal */\nexport const flatten = <A, E1, R1, E, R>(\n  self: Effect.Effect<Effect.Effect<A, E1, R1>, E, R>\n): Effect.Effect<A, E | E1, R | R1> => flatMap(self, identity)\n\n/* @internal */\nexport const flip = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E, A, R> =>\n  matchEffect(self, { onFailure: succeed, onSuccess: fail })\n\n/* @internal */\nexport const matchCause: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => A2\n    readonly onSuccess: (a: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => succeed(options.onFailure(cause)),\n    onSuccess: (a) => succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const matchCauseEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_ON_SUCCESS_AND_FAILURE) as any\n  effect.effect_instruction_i0 = self\n  effect.effect_instruction_i1 = options.onFailure\n  effect.effect_instruction_i2 = options.onSuccess\n  return effect\n})\n\n/* @internal */\nexport const matchEffect: {\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n    }\n  ): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(2, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (e: E) => Effect.Effect<A2, E2, R2>\n    readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  }\n): Effect.Effect<A2 | A3, E2 | E3, R2 | R3 | R> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(internalCause.electFailures(cause))\n      }\n      const failures = internalCause.failures(cause)\n      if (failures.length > 0) {\n        return options.onFailure(Chunk.unsafeHead(failures))\n      }\n      return failCause(cause as Cause.Cause<never>)\n    },\n    onSuccess: options.onSuccess\n  }))\n\n/* @internal */\nexport const forEachSequential: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<Array<B>, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<Array<B>, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      const ret = Arr.allocate<B>(arr.length)\n      let i = 0\n      return as(\n        whileLoop({\n          while: () => i < arr.length,\n          body: () => f(arr[i], i),\n          step: (b) => {\n            ret[i++] = b\n          }\n        }),\n        ret as Array<B>\n      )\n    })\n)\n\n/* @internal */\nexport const forEachSequentialDiscard: {\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>): (self: Iterable<A>) => Effect.Effect<void, E, R>\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R>\n} = dual(\n  2,\n  <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>): Effect.Effect<void, E, R> =>\n    suspend(() => {\n      const arr = Arr.fromIterable(self)\n      let i = 0\n      return whileLoop({\n        while: () => i < arr.length,\n        body: () => f(arr[i], i),\n        step: () => {\n          i++\n        }\n      })\n    })\n)\n\n/* @internal */\nexport const if_ = dual<\n  <A1, E1, R1, A2, E2, R2>(\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => <E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean\n  ) => Effect.Effect<A1 | A2, E | E1 | E2, R | R1 | R2>,\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ) => Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n>(\n  (args) => typeof args[0] === \"boolean\" || isEffect(args[0]),\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: Effect.Effect<boolean, E, R> | boolean,\n    options: {\n      readonly onTrue: LazyArg<Effect.Effect<A1, E1, R1>>\n      readonly onFalse: LazyArg<Effect.Effect<A2, E2, R2>>\n    }\n  ): Effect.Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R> =>\n    isEffect(self)\n      ? flatMap(self, (b): Effect.Effect<A1 | A2, E1 | E2, R1 | R2> => (b ? options.onTrue() : options.onFalse()))\n      : self\n      ? options.onTrue()\n      : options.onFalse()\n)\n\n/* @internal */\nexport const interrupt: Effect.Effect<never> = flatMap(fiberId, (fiberId) => interruptWith(fiberId))\n\n/* @internal */\nexport const interruptWith = (fiberId: FiberId.FiberId): Effect.Effect<never> =>\n  failCause(internalCause.interrupt(fiberId))\n\n/* @internal */\nexport const interruptible = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(runtimeFlags_.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const interruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.enable(runtimeFlags_.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      runtimeFlags_.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\n/* @internal */\nexport const intoDeferred: {\n  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<boolean, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect.Effect<boolean, never, R> =>\n    uninterruptibleMask((restore) =>\n      flatMap(\n        exit(restore(self)),\n        (exit) => deferredDone(deferred, exit)\n      )\n    )\n)\n\n/* @internal */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Effect.Effect<A, E, R>, f: (a: A) => B): Effect.Effect<B, E, R> =>\n    flatMap(self, (a) => sync(() => f(a)))\n)\n\n/* @internal */\nexport const mapBoth: {\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R>\n  <A, E, R, E2, A2>(\n    self: Effect.Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect.Effect<A2, E2, R>\n} = dual(2, <A, E, R, E2, A2>(\n  self: Effect.Effect<A, E, R>,\n  options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n): Effect.Effect<A2, E2, R> =>\n  matchEffect(self, {\n    onFailure: (e) => failSync(() => options.onFailure(e)),\n    onSuccess: (a) => sync(() => options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const mapError: {\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (e: E) => E2): Effect.Effect<A, E2, R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => {\n        const either = internalCause.failureOrCause(cause)\n        switch (either._tag) {\n          case \"Left\": {\n            return failSync(() => f(either.left))\n          }\n          case \"Right\": {\n            return failCause(either.right)\n          }\n        }\n      },\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const onError: {\n  <E, X, R2>(\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(self, (exit) => exitIsSuccess(exit) ? void_ : cleanup(exit.effect_instruction_i0)))\n\n/* @internal */\nexport const onExit: {\n  <A, E, X, R2>(\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  uninterruptibleMask((restore) =>\n    matchCauseEffect(restore(self), {\n      onFailure: (cause1) => {\n        const result = exitFailCause(cause1)\n        return matchCauseEffect(cleanup(result), {\n          onFailure: (cause2) => exitFailCause(internalCause.sequential(cause1, cause2)),\n          onSuccess: () => result\n        })\n      },\n      onSuccess: (success) => {\n        const result = exitSucceed(success)\n        return zipRight(cleanup(result), result)\n      }\n    })\n  ))\n\n/* @internal */\nexport const onInterrupt: {\n  <X, R2>(\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R>\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R>\n} = dual(2, <A, E, R, X, R2>(\n  self: Effect.Effect<A, E, R>,\n  cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect.Effect<X, never, R2>\n): Effect.Effect<A, E, R2 | R> =>\n  onExit(\n    self,\n    exitMatch({\n      onFailure: (cause) =>\n        internalCause.isInterruptedOnly(cause)\n          ? asVoid(cleanup(internalCause.interruptors(cause)))\n          : void_,\n      onSuccess: () => void_\n    })\n  ))\n\n/* @internal */\nexport const orElse: {\n  <A2, E2, R2>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E2, R2 | R> => attemptOrElse(self, that, succeed)\n)\n\n/* @internal */\nexport const orDie = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> => orDieWith(self, identity)\n\n/* @internal */\nexport const orDieWith: {\n  <E>(f: (error: E) => unknown): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, never, R>\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Effect.Effect<A, E, R>, f: (error: E) => unknown): Effect.Effect<A, never, R> =>\n    matchEffect(self, {\n      onFailure: (e) => die(f(e)),\n      onSuccess: succeed\n    })\n)\n\n/* @internal */\nexport const partitionMap: <A, A1, A2>(\n  elements: Iterable<A>,\n  f: (a: A) => Either.Either<A2, A1>\n) => [left: Array<A1>, right: Array<A2>] = Arr.partitionMap\n/* @internal */\nexport const runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags> = withFiberRuntime((_, status) =>\n  succeed(status.runtimeFlags)\n)\n\n/* @internal */\nexport const succeed = <A>(value: A): Effect.Effect<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/* @internal */\nexport const suspend = <A, E, R>(evaluate: LazyArg<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_COMMIT) as any\n  effect.commit = evaluate\n  return effect\n}\n\n/* @internal */\nexport const sync = <A>(thunk: LazyArg<A>): Effect.Effect<A> => {\n  const effect = new EffectPrimitive(OpCodes.OP_SYNC) as any\n  effect.effect_instruction_i0 = thunk\n  return effect\n}\n\n/* @internal */\nexport const tap = dual<\n  {\n    <A, X>(\n      f: (a: NoInfer<A>) => X\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, X, E1, R1>(\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n    <X>(\n      f: NotFunction<X>\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <X, E1, R1>(\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<A, E | E1, R | R1>\n  },\n  {\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => X\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: (a: NoInfer<A>) => Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n    <A, E, R, X>(\n      self: Effect.Effect<A, E, R>,\n      f: NotFunction<X>\n    ): [X] extends [Effect.Effect<infer _A1, infer E1, infer R1>] ? Effect.Effect<A, E | E1, R | R1>\n      : [X] extends [PromiseLike<infer _A1>] ? Effect.Effect<A, E | Cause.UnknownException, R>\n      : Effect.Effect<A, E, R>\n    <A, E, R, X, E1, R1>(\n      self: Effect.Effect<A, E, R>,\n      f: Effect.Effect<X, E1, R1>,\n      options: { onlyEffect: true }\n    ): Effect.Effect<A, E | E1, R | R1>\n  }\n>(\n  (args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && \"onlyEffect\" in args[1]),\n  <A, E, R, X>(self: Effect.Effect<A, E, R>, f: X) =>\n    flatMap(self, (a) => {\n      const b = typeof f === \"function\" ? (f as any)(a) : f\n      if (isEffect(b)) {\n        return as(b, a)\n      } else if (isPromiseLike(b)) {\n        return unsafeAsync<any, Cause.UnknownException>((resume) => {\n          b.then((_) => resume(succeed(a)), (e) =>\n            resume(fail(new UnknownException(e, \"An unknown error occurred in Effect.tap\"))))\n        })\n      }\n      return succeed(a)\n    })\n)\n\n/* @internal */\nexport const transplant = <A, E, R>(\n  f: (grafter: <A2, E2, R2>(effect: Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  withFiberRuntime<A, E, R>((state) => {\n    const scopeOverride = state.getFiberRef(currentForkScopeOverride)\n    const scope = pipe(scopeOverride, Option.getOrElse(() => state.scope()))\n    return f(fiberRefLocally(currentForkScopeOverride, Option.some(scope)))\n  })\n\n/* @internal */\nexport const attemptOrElse: {\n  <A2, E2, R2, A, A3, E3, R3>(\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    that: LazyArg<Effect.Effect<A2, E2, R2>>,\n    onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n  ): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3>\n} = dual(3, <A, E, R, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  that: LazyArg<Effect.Effect<A2, E2, R2>>,\n  onSuccess: (a: A) => Effect.Effect<A3, E3, R3>\n): Effect.Effect<A2 | A3, E2 | E3, R | R2 | R3> =>\n  matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const defects = internalCause.defects(cause)\n      if (defects.length > 0) {\n        return failCause(Option.getOrThrow(internalCause.keepDefectsAndElectFailures(cause)))\n      }\n      return that()\n    },\n    onSuccess\n  }))\n\n/* @internal */\nexport const uninterruptible: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(runtimeFlags_.Interruption)\n  effect.effect_instruction_i1 = () => self\n  return effect\n}\n\n/* @internal */\nexport const uninterruptibleMask = <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect.Effect<AX, EX, RX>) => Effect.Effect<AX, EX, RX>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  custom(f, function() {\n    const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n    effect.effect_instruction_i0 = RuntimeFlagsPatch.disable(runtimeFlags_.Interruption)\n    effect.effect_instruction_i1 = (oldFlags: RuntimeFlags.RuntimeFlags) =>\n      runtimeFlags_.interruption(oldFlags)\n        ? internalCall(() => this.effect_instruction_i0(interruptible))\n        : internalCall(() => this.effect_instruction_i0(uninterruptible))\n    return effect\n  })\n\nconst void_: Effect.Effect<void> = succeed(void 0)\nexport {\n  /* @internal */\n  void_ as void\n}\n\n/* @internal */\nexport const updateRuntimeFlags = (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = patch\n  effect.effect_instruction_i1 = void 0\n  return effect\n}\n\n/* @internal */\nexport const whenEffect: {\n  <E, R>(\n    condition: Effect.Effect<boolean, E, R>\n  ): <A, E2, R2>(\n    effect: Effect.Effect<A, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n  <A, E2, R2, E, R>(\n    self: Effect.Effect<A, E2, R2>,\n    condition: Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E | E2, R | R2>\n} = dual(2, <A, E2, R2, E, R>(\n  self: Effect.Effect<A, E2, R2>,\n  condition: Effect.Effect<boolean, E, R>\n): Effect.Effect<Option.Option<A>, E | E2, R | R2> =>\n  flatMap(condition, (b) => {\n    if (b) {\n      return pipe(self, map(Option.some))\n    }\n    return succeed(Option.none())\n  }))\n\n/* @internal */\nexport const whileLoop = <A, E, R>(\n  options: {\n    readonly while: LazyArg<boolean>\n    readonly body: LazyArg<Effect.Effect<A, E, R>>\n    readonly step: (a: A) => void\n  }\n): Effect.Effect<void, E, R> => {\n  const effect = new EffectPrimitive(OpCodes.OP_WHILE) as any\n  effect.effect_instruction_i0 = options.while\n  effect.effect_instruction_i1 = options.body\n  effect.effect_instruction_i2 = options.step\n  return effect\n}\n\n/* @internal */\nexport const fromIterator = <Eff extends YieldWrap<Effect.Effect<any, any, any>>, AEff>(\n  iterator: LazyArg<Iterator<Eff, AEff, never>>\n): Effect.Effect<\n  AEff,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect.Effect<infer _A, infer E, infer _R>>] ? E : never,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect.Effect<infer _A, infer _E, infer R>>] ? R : never\n> =>\n  suspend(() => {\n    const effect = new EffectPrimitive(OpCodes.OP_ITERATOR) as any\n    effect.effect_instruction_i0 = iterator()\n    return effect\n  })\n\n/* @internal */\nexport const gen: typeof Effect.gen = function() {\n  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0])\n  return fromIterator(() => f(pipe))\n}\n\n/** @internal */\nexport const fnUntraced: Effect.fn.Untraced = (body: Function, ...pipeables: Array<any>) =>\n  Object.defineProperty(\n    pipeables.length === 0\n      ? function(this: any, ...args: Array<any>) {\n        return fromIterator(() => body.apply(this, args))\n      }\n      : function(this: any, ...args: Array<any>) {\n        let effect = fromIterator(() => body.apply(this, args))\n        for (const x of pipeables) {\n          effect = x(effect, ...args)\n        }\n        return effect\n      },\n    \"length\",\n    { value: body.length, configurable: true }\n  )\n\n/* @internal */\nexport const withConcurrency = dual<\n  (concurrency: number | \"unbounded\") => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, concurrency: number | \"unbounded\") => Effect.Effect<A, E, R>\n>(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency))\n\n/* @internal */\nexport const withRequestBatching = dual<\n  (requestBatching: boolean) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, requestBatching: boolean) => Effect.Effect<A, E, R>\n>(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching))\n\n/* @internal */\nexport const withRuntimeFlags = dual<\n  (update: RuntimeFlagsPatch.RuntimeFlagsPatch) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect.Effect<A, E, R>\n>(2, (self, update) => {\n  const effect = new EffectPrimitive(OpCodes.OP_UPDATE_RUNTIME_FLAGS) as any\n  effect.effect_instruction_i0 = update\n  effect.effect_instruction_i1 = () => self\n  return effect\n})\n\n/** @internal */\nexport const withTracerEnabled = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerEnabled,\n    enabled\n  ))\n\n/** @internal */\nexport const withTracerTiming = dual<\n  (enabled: boolean) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean) => Effect.Effect<A, E, R>\n>(2, (effect, enabled) =>\n  fiberRefLocally(\n    effect,\n    currentTracerTimingEnabled,\n    enabled\n  ))\n\n/* @internal */\nexport const yieldNow = (options?: {\n  readonly priority?: number | undefined\n}): Effect.Effect<void> => {\n  const effect = new EffectPrimitive(OpCodes.OP_YIELD) as any\n  return typeof options?.priority !== \"undefined\" ?\n    withSchedulingPriority(effect, options.priority) :\n    effect\n}\n\n/* @internal */\nexport const zip = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [a, b])))\n\n/* @internal */\nexport const zipFlatten: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A extends ReadonlyArray<any>, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[...A, A2], E | E2, R | R2>\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<[...A, A2], E | E2, R | R2>\n} = dual(2, <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<[...A, A2], E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => [...a, b])))\n\n/* @internal */\nexport const zipLeft: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A, E | E2, R | R2> => flatMap(self, (a) => as(that, a)))\n\n/* @internal */\nexport const zipRight: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ): Effect.Effect<A2, E | E2, R | R2>\n} = dual(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n): Effect.Effect<A2, E | E2, R | R2> => flatMap(self, () => that))\n\n/* @internal */\nexport const zipWith: {\n  <A2, E2, R2, A, B>(\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E2, R | R2>\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B\n  ): Effect.Effect<B, E | E2, R | R2>\n} = dual(3, <A, E, R, A2, E2, R2, B>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  f: (a: A, b: A2) => B\n): Effect.Effect<B, E | E2, R | R2> => flatMap(self, (a) => map(that, (b) => f(a, b))))\n\n/* @internal */\nexport const never: Effect.Effect<never> = asyncInterrupt<never>(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1)\n  return sync(() => clearInterval(interval))\n})\n\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const interruptFiber = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Exit.Exit<A, E>> =>\n  flatMap(fiberId, (fiberId) => pipe(self, interruptAsFiber(fiberId)))\n\n/* @internal */\nexport const interruptAsFiber = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Fiber.Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>,\n  <A, E>(self: Fiber.Fiber<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<Exit.Exit<A, E>>\n>(2, (self, fiberId) => flatMap(self.interruptAsFork(fiberId), () => self.await))\n\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const logLevelAll: LogLevel.LogLevel = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelFatal: LogLevel.LogLevel = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelError: LogLevel.LogLevel = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelWarning: LogLevel.LogLevel = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelInfo: LogLevel.LogLevel = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelDebug: LogLevel.LogLevel = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelTrace: LogLevel.LogLevel = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const logLevelNone: LogLevel.LogLevel = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const allLogLevels: ReadonlyArray<LogLevel.LogLevel> = [\n  logLevelAll,\n  logLevelTrace,\n  logLevelDebug,\n  logLevelInfo,\n  logLevelWarning,\n  logLevelError,\n  logLevelFatal,\n  logLevelNone\n]\n\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst FiberRefSymbolKey = \"effect/FiberRef\"\n\n/** @internal */\nexport const FiberRefTypeId: FiberRef.FiberRefTypeId = Symbol.for(\n  FiberRefSymbolKey\n) as FiberRef.FiberRefTypeId\n\nconst fiberRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/* @internal */\nexport const fiberRefGet = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<A> =>\n  withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)))\n\n/* @internal */\nexport const fiberRefGetAndSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<A>\n>(2, (self, value) => fiberRefModify(self, (v) => [v, value] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)] as const))\n\n/* @internal */\nexport const fiberRefGetAndUpdateSome = dual<\n  <A>(\n    pf: (a: A) => Option.Option<A>\n  ) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    pf: (a: A) => Option.Option<A>\n  ) => Effect.Effect<A>\n>(2, (self, pf) => fiberRefModify(self, (v) => [v, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefGetWith = dual<\n  <B, E, R, A>(f: (a: A) => Effect.Effect<B, E, R>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(self: FiberRef.FiberRef<A>, f: (a: A) => Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n>(2, (self, f) => flatMap(fiberRefGet(self), f))\n\n/* @internal */\nexport const fiberRefSet = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<void>\n>(2, (self, value) => fiberRefModify(self, () => [void 0, value] as const))\n\n/* @internal */\nexport const fiberRefDelete = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> =>\n  withFiberRuntime((state) => {\n    state.unsafeDeleteFiberRef(self)\n    return void_\n  })\n\n/* @internal */\nexport const fiberRefReset = <A>(self: FiberRef.FiberRef<A>): Effect.Effect<void> => fiberRefSet(self, self.initial)\n\n/* @internal */\nexport const fiberRefModify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: FiberRef.FiberRef<A>) => Effect.Effect<B>,\n  <A, B>(self: FiberRef.FiberRef<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, <A, B>(\n  self: FiberRef.FiberRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> =>\n  withFiberRuntime((state) => {\n    const [b, a] = f(state.getFiberRef(self) as A)\n    state.setFiberRef(self, a)\n    return succeed(b)\n  }))\n\n/* @internal */\nexport const fiberRefModifySome = <A, B>(\n  self: FiberRef.FiberRef<A>,\n  def: B,\n  f: (a: A) => Option.Option<readonly [B, A]>\n): Effect.Effect<B> => fiberRefModify(self, (v) => Option.getOrElse(f(v), () => [def, v] as const))\n\n/* @internal */\nexport const fiberRefUpdate = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<void>\n>(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateSome = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<void>\n>(2, (self, pf) => fiberRefModify(self, (v) => [void 0, Option.getOrElse(pf(v), () => v)] as const))\n\n/* @internal */\nexport const fiberRefUpdateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, (self, f) =>\n  fiberRefModify(self, (v) => {\n    const result = f(v)\n    return [result, result] as const\n  }))\n\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: FiberRef.FiberRef<A>) => Effect.Effect<A>,\n  <A>(self: FiberRef.FiberRef<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, (self, pf) =>\n  fiberRefModify(self, (v) => {\n    const result = Option.getOrElse(pf(v), () => v)\n    return [result, result] as const\n  }))\n\n// circular\n/** @internal */\nconst RequestResolverSymbolKey = \"effect/RequestResolver\"\n\n/** @internal */\nexport const RequestResolverTypeId: RequestResolver.RequestResolverTypeId = Symbol.for(\n  RequestResolverSymbolKey\n) as RequestResolver.RequestResolverTypeId\n\nconst requestResolverVariance = {\n  /* c8 ignore next */\n  _A: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class RequestResolverImpl<in A, out R> implements RequestResolver.RequestResolver<A, R> {\n  readonly [RequestResolverTypeId] = requestResolverVariance\n  constructor(\n    readonly runAll: (\n      requests: Array<Array<Request.Entry<A>>>\n    ) => Effect.Effect<void, never, R>,\n    readonly target?: unknown\n  ) {\n  }\n  [Hash.symbol](): number {\n    return Hash.cached(this, this.target ? Hash.hash(this.target) : Hash.random(this))\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return this.target ?\n      isRequestResolver(that) && Equal.equals(this.target, (that as RequestResolverImpl<any, any>).target) :\n      this === that\n  }\n  identified(...ids: Array<unknown>): RequestResolver.RequestResolver<A, R> {\n    return new RequestResolverImpl(this.runAll, Chunk.fromIterable(ids))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isRequestResolver = (u: unknown): u is RequestResolver.RequestResolver<unknown, unknown> =>\n  hasProperty(u, RequestResolverTypeId)\n\n// end\n\n/** @internal */\nexport const resolverLocally = dual<\n  <A>(\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => <R, B extends Request.Request<any, any>>(\n    use: RequestResolver.RequestResolver<B, R>\n  ) => RequestResolver.RequestResolver<B, R>,\n  <R, B extends Request.Request<any, any>, A>(\n    use: RequestResolver.RequestResolver<B, R>,\n    self: FiberRef.FiberRef<A>,\n    value: A\n  ) => RequestResolver.RequestResolver<B, R>\n>(3, <R, B extends Request.Request<any, any>, A>(\n  use: RequestResolver.RequestResolver<B, R>,\n  self: FiberRef.FiberRef<A>,\n  value: A\n): RequestResolver.RequestResolver<B, R> =>\n  new RequestResolverImpl<B, R>(\n    (requests) =>\n      fiberRefLocally(\n        use.runAll(requests),\n        self,\n        value\n      ),\n    Chunk.make(\"Locally\", use, self, value)\n  ))\n\n/** @internal */\nexport const requestBlockLocally = <A>(\n  self: BlockedRequests.RequestBlock,\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock => blockedRequests_.reduce(self, LocallyReducer(ref, value))\n\nconst LocallyReducer = <A>(\n  ref: FiberRef.FiberRef<A>,\n  value: A\n): BlockedRequests.RequestBlock.Reducer<BlockedRequests.RequestBlock> => ({\n  emptyCase: () => blockedRequests_.empty,\n  parCase: (left, right) => blockedRequests_.par(left, right),\n  seqCase: (left, right) => blockedRequests_.seq(left, right),\n  singleCase: (dataSource, blockedRequest) =>\n    blockedRequests_.single(\n      resolverLocally(dataSource, ref, value),\n      blockedRequest as any\n    )\n})\n\n/* @internal */\nexport const fiberRefLocally: {\n  <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R>\n} = dual(\n  3,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect.Effect<B, E, R> =>\n    acquireUseRelease(\n      zipLeft(fiberRefGet(self), fiberRefSet(self, value)),\n      () => use,\n      (oldValue) => fiberRefSet(self, oldValue)\n    )\n)\n\n/* @internal */\nexport const fiberRefLocallyWith = dual<\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => <B, E, R>(use: Effect.Effect<B, E, R>) => Effect.Effect<B, E, R>,\n  <B, E, R, A>(use: Effect.Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<B, E, R>\n>(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))))\n\n/** @internal */\nexport const fiberRefUnsafeMake = <Value>(\n  initial: Value,\n  options?: {\n    readonly fork?: ((a: Value) => Value) | undefined\n    readonly join?: ((left: Value, right: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: internalDiffer.update(),\n    fork: options?.fork ?? identity,\n    join: options?.join\n  })\n\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = <A>(\n  initial: HashSet.HashSet<A>\n): FiberRef.FiberRef<HashSet.HashSet<A>> => {\n  const differ = internalDiffer.hashSet<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeReadonlyArray = <A>(\n  initial: ReadonlyArray<A>\n): FiberRef.FiberRef<ReadonlyArray<A>> => {\n  const differ = internalDiffer.readonlyArray(internalDiffer.update<A>())\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeContext = <A>(\n  initial: Context.Context<A>\n): FiberRef.FiberRef<Context.Context<A>> => {\n  const differ = internalDiffer.environment<A>()\n  return fiberRefUnsafeMakePatch(initial, {\n    differ,\n    fork: differ.empty\n  })\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakePatch = <Value, Patch>(\n  initial: Value,\n  options: {\n    readonly differ: Differ.Differ<Value, Patch>\n    readonly fork: Patch\n    readonly join?: ((oldV: Value, newV: Value) => Value) | undefined\n  }\n): FiberRef.FiberRef<Value> => {\n  const _fiberRef = {\n    ...CommitPrototype,\n    [FiberRefTypeId]: fiberRefVariance,\n    initial,\n    commit() {\n      return fiberRefGet(this)\n    },\n    diff: (oldValue: Value, newValue: Value) => options.differ.diff(oldValue, newValue),\n    combine: (first: Patch, second: Patch) => options.differ.combine(first, second),\n    patch: (patch: Patch) => (oldValue: Value) => options.differ.patch(patch, oldValue),\n    fork: options.fork,\n    join: options.join ?? ((_, n) => n)\n  }\n  return _fiberRef\n}\n\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = (\n  initial: RuntimeFlags.RuntimeFlags\n): FiberRef.FiberRef<RuntimeFlags.RuntimeFlags> =>\n  fiberRefUnsafeMakePatch(initial, {\n    differ: runtimeFlags_.differ,\n    fork: runtimeFlags_.differ.empty\n  })\n\n/** @internal */\nexport const currentContext: FiberRef.FiberRef<Context.Context<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentContext\"),\n  () => fiberRefUnsafeMakeContext(Context.empty())\n)\n\n/** @internal */\nexport const currentSchedulingPriority: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentSchedulingPriority\"),\n  () => fiberRefUnsafeMake(0)\n)\n\n/** @internal */\nexport const currentMaxOpsBeforeYield: FiberRef.FiberRef<number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMaxOpsBeforeYield\"),\n  () => fiberRefUnsafeMake(2048)\n)\n\n/** @internal */\nexport const currentLogAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogAnnotation\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentLogLevel: FiberRef.FiberRef<LogLevel.LogLevel> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogLevel\"),\n  () => fiberRefUnsafeMake<LogLevel.LogLevel>(logLevelInfo)\n)\n\n/** @internal */\nexport const currentLogSpan: FiberRef.FiberRef<List.List<LogSpan.LogSpan>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLogSpan\"),\n  () => fiberRefUnsafeMake(List.empty<LogSpan.LogSpan>())\n)\n\n/** @internal */\nexport const withSchedulingPriority = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler))\n\n/** @internal */\nexport const withMaxOpsBeforeYield = dual<\n  (priority: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, priority: number) => Effect.Effect<A, E, R>\n>(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler))\n\n/** @internal */\nexport const currentConcurrency: FiberRef.FiberRef<\"unbounded\" | number> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentConcurrency\"),\n  () => fiberRefUnsafeMake<\"unbounded\" | number>(\"unbounded\")\n)\n\n/**\n * @internal\n */\nexport const currentRequestBatching = globalValue(\n  Symbol.for(\"effect/FiberRef/currentRequestBatching\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentUnhandledErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentUnhandledErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelDebug))\n)\n\n/** @internal */\nexport const currentVersionMismatchErrorLogLevel: FiberRef.FiberRef<Option.Option<LogLevel.LogLevel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/versionMismatchErrorLogLevel\"),\n  () => fiberRefUnsafeMake(Option.some<LogLevel.LogLevel>(logLevelWarning))\n)\n\n/** @internal */\nexport const withUnhandledErrorLogLevel = dual<\n  (level: Option.Option<LogLevel.LogLevel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>) => Effect.Effect<A, E, R>\n>(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level))\n\n/** @internal */\nexport const currentMetricLabels: FiberRef.FiberRef<ReadonlyArray<MetricLabel.MetricLabel>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentMetricLabels\"),\n  () => fiberRefUnsafeMakeReadonlyArray(Arr.empty())\n)\n\n/* @internal */\nexport const metricLabels: Effect.Effect<ReadonlyArray<MetricLabel.MetricLabel>> = fiberRefGet(\n  currentMetricLabels\n)\n\n/** @internal */\nexport const currentForkScopeOverride: FiberRef.FiberRef<Option.Option<fiberScope.FiberScope>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentForkScopeOverride\"),\n  () =>\n    fiberRefUnsafeMake(Option.none(), {\n      fork: () => Option.none() as Option.Option<fiberScope.FiberScope>,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentInterruptedCause: FiberRef.FiberRef<Cause.Cause<never>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentInterruptedCause\"),\n  () =>\n    fiberRefUnsafeMake(internalCause.empty, {\n      fork: () => internalCause.empty,\n      join: (parent, _) => parent\n    })\n)\n\n/** @internal */\nexport const currentTracerEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerEnabled\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerTimingEnabled: FiberRef.FiberRef<boolean> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerTiming\"),\n  () => fiberRefUnsafeMake(true)\n)\n\n/** @internal */\nexport const currentTracerSpanAnnotations: FiberRef.FiberRef<HashMap.HashMap<string, unknown>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanAnnotations\"),\n  () => fiberRefUnsafeMake(HashMap.empty())\n)\n\n/** @internal */\nexport const currentTracerSpanLinks: FiberRef.FiberRef<Chunk.Chunk<Tracer.SpanLink>> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentTracerSpanLinks\"),\n  () => fiberRefUnsafeMake(Chunk.empty())\n)\n\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const ScopeTypeId: Scope.ScopeTypeId = Symbol.for(\"effect/Scope\") as Scope.ScopeTypeId\n\n/** @internal */\nexport const CloseableScopeTypeId: Scope.CloseableScopeTypeId = Symbol.for(\n  \"effect/CloseableScope\"\n) as Scope.CloseableScopeTypeId\n\n/* @internal */\nexport const scopeAddFinalizer = (\n  self: Scope.Scope,\n  finalizer: Effect.Effect<unknown>\n): Effect.Effect<void> => self.addFinalizer(() => asVoid(finalizer))\n\n/* @internal */\nexport const scopeAddFinalizerExit = (\n  self: Scope.Scope,\n  finalizer: Scope.Scope.Finalizer\n): Effect.Effect<void> => self.addFinalizer(finalizer)\n\n/* @internal */\nexport const scopeClose = (\n  self: Scope.Scope.Closeable,\n  exit: Exit.Exit<unknown, unknown>\n): Effect.Effect<void> => self.close(exit)\n\n/* @internal */\nexport const scopeFork = (\n  self: Scope.Scope,\n  strategy: ExecutionStrategy.ExecutionStrategy\n): Effect.Effect<Scope.Scope.Closeable> => self.fork(strategy)\n\n// -----------------------------------------------------------------------------\n// Cause\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const causeSquash = <E>(self: Cause.Cause<E>): unknown => {\n  return causeSquashWith(identity)(self)\n}\n\n/** @internal */\nexport const causeSquashWith = dual<\n  <E>(f: (error: E) => unknown) => (self: Cause.Cause<E>) => unknown,\n  <E>(self: Cause.Cause<E>, f: (error: E) => unknown) => unknown\n>(2, (self, f) => {\n  const option = pipe(self, internalCause.failureOption, Option.map(f))\n  switch (option._tag) {\n    case \"None\": {\n      return pipe(\n        internalCause.defects(self),\n        Chunk.head,\n        Option.match({\n          onNone: () => {\n            const interrupts = Arr.fromIterable(internalCause.interruptors(self)).flatMap((fiberId) =>\n              Arr.fromIterable(FiberId.ids(fiberId)).map((id) => `#${id}`)\n            )\n            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0)\n          },\n          onSome: identity\n        })\n      )\n    }\n    case \"Some\": {\n      return option.value\n    }\n  }\n})\n\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const YieldableError: new(message?: string, options?: ErrorOptions) => Cause.YieldableError = (function() {\n  class YieldableError extends globalThis.Error {\n    commit() {\n      return fail(this)\n    }\n    toJSON() {\n      const obj = { ...this }\n      if (this.message) obj.message = this.message\n      if (this.cause) obj.cause = this.cause\n      return obj\n    }\n    [NodeInspectSymbol]() {\n      if (this.toString !== globalThis.Error.prototype.toString) {\n        return this.stack ? `${this.toString()}\\n${this.stack.split(\"\\n\").slice(1).join(\"\\n\")}` : this.toString()\n      } else if (\"Bun\" in globalThis) {\n        return internalCause.pretty(internalCause.fail(this), { renderErrorCause: true })\n      }\n      return this\n    }\n  }\n  // @effect-diagnostics-next-line floatingEffect:off\n  Object.assign(YieldableError.prototype, StructuralCommitPrototype)\n  return YieldableError as any\n})()\n\nconst makeException = <T extends { _tag: string; message?: string }>(\n  proto: Omit<T, keyof Cause.YieldableError | \"_tag\">,\n  tag: T[\"_tag\"]\n): new(message?: string | undefined) => T => {\n  class Base extends YieldableError {\n    readonly _tag = tag\n  }\n  Object.assign(Base.prototype, proto)\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/** @internal */\nexport const RuntimeExceptionTypeId: Cause.RuntimeExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/RuntimeException\"\n) as Cause.RuntimeExceptionTypeId\n\n/** @internal */\nexport const RuntimeException = makeException<Cause.RuntimeException>({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\")\n\n/** @internal */\nexport const isRuntimeException = (u: unknown): u is Cause.RuntimeException => hasProperty(u, RuntimeExceptionTypeId)\n\n/** @internal */\nexport const InterruptedExceptionTypeId: Cause.InterruptedExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InterruptedException\"\n) as Cause.InterruptedExceptionTypeId\n\n/** @internal */\nexport const InterruptedException = makeException<Cause.InterruptedException>({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\")\n\n/** @internal */\nexport const isInterruptedException = (u: unknown): u is Cause.InterruptedException =>\n  hasProperty(u, InterruptedExceptionTypeId)\n\n/** @internal */\nexport const IllegalArgumentExceptionTypeId: Cause.IllegalArgumentExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/IllegalArgument\"\n) as Cause.IllegalArgumentExceptionTypeId\n\n/** @internal */\nexport const IllegalArgumentException = makeException<Cause.IllegalArgumentException>({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\")\n\n/** @internal */\nexport const isIllegalArgumentException = (u: unknown): u is Cause.IllegalArgumentException =>\n  hasProperty(u, IllegalArgumentExceptionTypeId)\n\n/** @internal */\nexport const NoSuchElementExceptionTypeId: Cause.NoSuchElementExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/NoSuchElement\"\n) as Cause.NoSuchElementExceptionTypeId\n\n/** @internal */\nexport const NoSuchElementException = makeException<Cause.NoSuchElementException>({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\")\n\n/** @internal */\nexport const isNoSuchElementException = (u: unknown): u is Cause.NoSuchElementException =>\n  hasProperty(u, NoSuchElementExceptionTypeId)\n\n/** @internal */\nexport const InvalidPubSubCapacityExceptionTypeId: Cause.InvalidPubSubCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/InvalidPubSubCapacityException\"\n) as Cause.InvalidPubSubCapacityExceptionTypeId\n\n/** @internal */\nexport const InvalidPubSubCapacityException = makeException<Cause.InvalidPubSubCapacityException>({\n  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}, \"InvalidPubSubCapacityException\")\n\n/** @internal */\nexport const ExceededCapacityExceptionTypeId: Cause.ExceededCapacityExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/ExceededCapacityException\"\n) as Cause.ExceededCapacityExceptionTypeId\n\n/** @internal */\nexport const ExceededCapacityException = makeException<Cause.ExceededCapacityException>({\n  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}, \"ExceededCapacityException\")\n\n/** @internal */\nexport const isExceededCapacityException = (u: unknown): u is Cause.ExceededCapacityException =>\n  hasProperty(u, ExceededCapacityExceptionTypeId)\n\n/** @internal */\nexport const isInvalidCapacityError = (u: unknown): u is Cause.InvalidPubSubCapacityException =>\n  hasProperty(u, InvalidPubSubCapacityExceptionTypeId)\n\n/** @internal */\nexport const TimeoutExceptionTypeId: Cause.TimeoutExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/Timeout\"\n) as Cause.TimeoutExceptionTypeId\n\n/** @internal */\nexport const TimeoutException = makeException<Cause.TimeoutException>({\n  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}, \"TimeoutException\")\n\n/** @internal */\nexport const timeoutExceptionFromDuration = (duration: Duration.DurationInput): Cause.TimeoutException =>\n  new TimeoutException(`Operation timed out after '${Duration.format(duration)}'`)\n\n/** @internal */\nexport const isTimeoutException = (u: unknown): u is Cause.TimeoutException => hasProperty(u, TimeoutExceptionTypeId)\n\n/** @internal */\nexport const UnknownExceptionTypeId: Cause.UnknownExceptionTypeId = Symbol.for(\n  \"effect/Cause/errors/UnknownException\"\n) as Cause.UnknownExceptionTypeId\n\n/** @internal */\nexport const UnknownException: new(cause: unknown, message?: string | undefined) => Cause.UnknownException =\n  (function() {\n    class UnknownException extends YieldableError {\n      readonly _tag = \"UnknownException\"\n      readonly error: unknown\n      constructor(cause: unknown, message?: string) {\n        super(message ?? \"An unknown error occurred\", { cause })\n        this.error = cause\n      }\n    }\n    Object.assign(UnknownException.prototype, {\n      [UnknownExceptionTypeId]: UnknownExceptionTypeId,\n      name: \"UnknownException\"\n    })\n    return UnknownException as any\n  })()\n\n/** @internal */\nexport const isUnknownException = (u: unknown): u is Cause.UnknownException => hasProperty(u, UnknownExceptionTypeId)\n\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const exitIsExit = (u: unknown): u is Exit.Exit<unknown, unknown> =>\n  isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\")\n\n/** @internal */\nexport const exitIsFailure = <A, E>(self: Exit.Exit<A, E>): self is Exit.Failure<A, E> => self._tag === \"Failure\"\n\n/** @internal */\nexport const exitIsSuccess = <A, E>(self: Exit.Exit<A, E>): self is Exit.Success<A, E> => self._tag === \"Success\"\n\n/** @internal */\nexport const exitIsInterrupted = <A, E>(self: Exit.Exit<A, E>): boolean => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return internalCause.isInterrupted(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return false\n  }\n}\n\n/** @internal */\nexport const exitAs = dual<\n  <A2>(value: A2) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E>,\n  <A, E, A2>(self: Exit.Exit<A, E>, value: A2) => Exit.Exit<A2, E>\n>(2, <A, E, A2>(self: Exit.Exit<A, E>, value: A2): Exit.Exit<A2, E> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exitSucceed(value) as Exit.Exit<A2, E>\n    }\n  }\n})\n\n/** @internal */\nexport const exitAsVoid = <A, E>(self: Exit.Exit<A, E>): Exit.Exit<void, E> => exitAs(self, void 0)\n\n/** @internal */\nexport const exitCauseOption = <A, E>(self: Exit.Exit<A, E>): Option.Option<Cause.Cause<E>> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return Option.some(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return Option.none()\n  }\n}\n\n/** @internal */\nexport const exitCollectAll = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  options?: {\n    readonly parallel?: boolean | undefined\n  }\n): Option.Option<Exit.Exit<Array<A>, E>> =>\n  exitCollectAllInternal(exits, options?.parallel ? internalCause.parallel : internalCause.sequential)\n\n/** @internal */\nexport const exitDie = (defect: unknown): Exit.Exit<never> =>\n  exitFailCause(internalCause.die(defect)) as Exit.Exit<never>\n\n/** @internal */\nexport const exitExists: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit.Exit<A, E>) => self is Exit.Exit<B>\n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit.Exit<A, E>) => boolean\n  <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B>\n  <A, E>(self: Exit.Exit<A, E>, predicate: Predicate<A>): boolean\n} = dual(2, <A, E, B extends A>(self: Exit.Exit<A, E>, refinement: Refinement<A, B>): self is Exit.Exit<B> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return false\n    case OpCodes.OP_SUCCESS:\n      return refinement(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitFail = <E>(error: E): Exit.Exit<never, E> =>\n  exitFailCause(internalCause.fail(error)) as Exit.Exit<never, E>\n\n/** @internal */\nexport const exitFailCause = <E>(cause: Cause.Cause<E>): Exit.Exit<never, E> => {\n  const effect = new EffectPrimitiveFailure(OpCodes.OP_FAILURE) as any\n  effect.effect_instruction_i0 = cause\n  return effect\n}\n\n/** @internal */\nexport const exitFlatMap = dual<\n  <A, A2, E2>(f: (a: A) => Exit.Exit<A2, E2>) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, <A, E, E2, A2>(self: Exit.Exit<A, E>, f: (a: A) => Exit.Exit<A2, E2>): Exit.Exit<A2, E | E2> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return exitFailCause(self.effect_instruction_i0)\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatMapEffect: {\n  <A, E, A2, E2, R>(\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): (self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  <A, E, A2, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n  ): Effect.Effect<Exit.Exit<A2, E>, E2, R>\n} = dual(2, <A, E, A2, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<Exit.Exit<A2, E>, E2, R>\n): Effect.Effect<Exit.Exit<A2, E>, E2, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return f(self.effect_instruction_i0)\n    }\n  }\n})\n\n/** @internal */\nexport const exitFlatten = <A, E, E2>(\n  self: Exit.Exit<Exit.Exit<A, E>, E2>\n): Exit.Exit<A, E | E2> => pipe(self, exitFlatMap(identity))\n\n/** @internal */\nexport const exitForEachEffect: {\n  <A, B, E2, R>(\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): <E>(self: Exit.Exit<A, E>) => Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n  <A, E, B, E2, R>(\n    self: Exit.Exit<A, E>,\n    f: (a: A) => Effect.Effect<B, E2, R>\n  ): Effect.Effect<Exit.Exit<B, E | E2>, never, R>\n} = dual(2, <A, E, B, E2, R>(\n  self: Exit.Exit<A, E>,\n  f: (a: A) => Effect.Effect<B, E2, R>\n): Effect.Effect<Exit.Exit<B, E | E2>, never, R> => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      return succeed(exitFailCause(self.effect_instruction_i0))\n    }\n    case OpCodes.OP_SUCCESS: {\n      return exit(f(self.effect_instruction_i0))\n    }\n  }\n})\n\n/** @internal */\nexport const exitFromEither = <R, L>(either: Either.Either<R, L>): Exit.Exit<R, L> => {\n  switch (either._tag) {\n    case \"Left\":\n      return exitFail(either.left)\n    case \"Right\":\n      return exitSucceed(either.right)\n  }\n}\n\n/** @internal */\nexport const exitFromOption = <A>(option: Option.Option<A>): Exit.Exit<A, void> => {\n  switch (option._tag) {\n    case \"None\":\n      return exitFail(void 0)\n    case \"Some\":\n      return exitSucceed(option.value)\n  }\n}\n\n/** @internal */\nexport const exitGetOrElse = dual<\n  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2) => <A>(self: Exit.Exit<A, E>) => A | A2,\n  <A, E, A2>(self: Exit.Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2) => A | A2\n>(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return orElse(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return self.effect_instruction_i0\n  }\n})\n\n/** @internal */\nexport const exitInterrupt = (fiberId: FiberId.FiberId): Exit.Exit<never> =>\n  exitFailCause(internalCause.interrupt(fiberId))\n\n/** @internal */\nexport const exitMap = dual<\n  <A, B>(f: (a: A) => B) => <E>(self: Exit.Exit<A, E>) => Exit.Exit<B, E>,\n  <A, E, B>(self: Exit.Exit<A, E>, f: (a: A) => B) => Exit.Exit<B, E>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(f(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapBoth = dual<\n  <E, A, E2, A2>(\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<A2, E2>,\n  <A, E, E2, A2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => Exit.Exit<A2, E2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(onFailure)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(onSuccess(self.effect_instruction_i0))\n  }\n})\n\n/** @internal */\nexport const exitMapError = dual<\n  <E, E2>(f: (e: E) => E2) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <A, E, E2>(self: Exit.Exit<A, E>, f: (e: E) => E2) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(pipe(self.effect_instruction_i0, internalCause.map(f)))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMapErrorCause = dual<\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => <A>(self: Exit.Exit<A, E>) => Exit.Exit<A, E2>,\n  <E, A, E2>(self: Exit.Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => Exit.Exit<A, E2>\n>(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return exitFailCause(f(self.effect_instruction_i0))\n    case OpCodes.OP_SUCCESS:\n      return exitSucceed(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatch = dual<\n  <E, A, Z1, Z2>(options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => (self: Exit.Exit<A, E>) => Z1 | Z2,\n  <A, E, Z1, Z2>(self: Exit.Exit<A, E>, options: {\n    readonly onFailure: (cause: Cause.Cause<E>) => Z1\n    readonly onSuccess: (a: A) => Z2\n  }) => Z1 | Z2\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitMatchEffect = dual<\n  <E, A2, E2, R, A, A3, E3, R2>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>,\n  <A, E, A2, E2, R, A3, E3, R2>(\n    self: Exit.Exit<A, E>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n      readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R2>\n>(2, (self, { onFailure, onSuccess }) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      return onFailure(self.effect_instruction_i0)\n    case OpCodes.OP_SUCCESS:\n      return onSuccess(self.effect_instruction_i0)\n  }\n})\n\n/** @internal */\nexport const exitSucceed = <A>(value: A): Exit.Exit<A> => {\n  const effect = new EffectPrimitiveSuccess(OpCodes.OP_SUCCESS) as any\n  effect.effect_instruction_i0 = value\n  return effect\n}\n\n/** @internal */\nexport const exitVoid: Exit.Exit<void> = exitSucceed(void 0)\n\n/** @internal */\nexport const exitZip = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.sequential\n  }))\n\n/** @internal */\nexport const exitZipPar = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<[A, A2], E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, a2) => [a, a2],\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParLeft = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (a, _) => a,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipParRight = dual<\n  <A2, E2>(that: Exit.Exit<A2, E2>) => <A, E>(self: Exit.Exit<A, E>) => Exit.Exit<A2, E | E2>,\n  <A, E, A2, E2>(self: Exit.Exit<A, E>, that: Exit.Exit<A2, E2>) => Exit.Exit<A2, E | E2>\n>(2, (self, that) =>\n  exitZipWith(self, that, {\n    onSuccess: (_, a2) => a2,\n    onFailure: internalCause.parallel\n  }))\n\n/** @internal */\nexport const exitZipWith = dual<\n  <B, E2, A, C, E>(\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => (self: Exit.Exit<A, E>) => Exit.Exit<C, E | E2>,\n  <A, E, B, E2, C>(\n    self: Exit.Exit<A, E>,\n    that: Exit.Exit<B, E2>,\n    options: {\n      readonly onSuccess: (a: A, b: B) => C\n      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n    }\n  ) => Exit.Exit<C, E | E2>\n>(3, (\n  self,\n  that,\n  { onFailure, onSuccess }\n) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitFailCause(self.effect_instruction_i0)\n        case OpCodes.OP_FAILURE: {\n          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0))\n        }\n      }\n    }\n    case OpCodes.OP_SUCCESS: {\n      switch (that._tag) {\n        case OpCodes.OP_SUCCESS:\n          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0))\n        case OpCodes.OP_FAILURE:\n          return exitFailCause(that.effect_instruction_i0)\n      }\n    }\n  }\n})\n\nconst exitCollectAllInternal = <A, E>(\n  exits: Iterable<Exit.Exit<A, E>>,\n  combineCauses: (causeA: Cause.Cause<E>, causeB: Cause.Cause<E>) => Cause.Cause<E>\n): Option.Option<Exit.Exit<Array<A>, E>> => {\n  const list = Chunk.fromIterable(exits)\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none()\n  }\n  return pipe(\n    Chunk.tailNonEmpty(list),\n    Arr.reduce(\n      pipe(Chunk.headNonEmpty(list), exitMap<A, Chunk.Chunk<A>>(Chunk.of)),\n      (accumulator, current) =>\n        pipe(\n          accumulator,\n          exitZipWith(current, {\n            onSuccess: (list, value) => pipe(list, Chunk.prepend(value)),\n            onFailure: combineCauses\n          })\n        )\n    ),\n    exitMap(Chunk.reverse),\n    exitMap((chunk) => Chunk.toReadonlyArray(chunk) as Array<A>),\n    Option.some\n  )\n}\n\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const deferredUnsafeMake = <A, E = never>(fiberId: FiberId.FiberId): Deferred.Deferred<A, E> => {\n  const _deferred = {\n    ...CommitPrototype,\n    [deferred.DeferredTypeId]: deferred.deferredVariance,\n    state: MutableRef.make(deferred.pending<A, E>([])),\n    commit() {\n      return deferredAwait(this)\n    },\n    blockingOn: fiberId\n  }\n  return _deferred\n}\n\n/* @internal */\nexport const deferredMake = <A, E = never>(): Effect.Effect<Deferred.Deferred<A, E>> =>\n  flatMap(fiberId, (id) => deferredMakeAs<A, E>(id))\n\n/* @internal */\nexport const deferredMakeAs = <A, E = never>(fiberId: FiberId.FiberId): Effect.Effect<Deferred.Deferred<A, E>> =>\n  sync(() => deferredUnsafeMake<A, E>(fiberId))\n\n/* @internal */\nexport const deferredAwait = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<A, E> =>\n  asyncInterrupt<A, E>((resume) => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return resume(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        // we can push here as the internal state is mutable\n        state.joiners.push(resume)\n        return deferredInterruptJoiner(self, resume)\n      }\n    }\n  }, self.blockingOn)\n\n/* @internal */\nexport const deferredComplete: {\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = dual(\n  2,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean> =>\n    intoDeferred(effect, self)\n)\n\n/* @internal */\nexport const deferredCompleteWith = dual<\n  <A, E>(effect: Effect.Effect<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>) => Effect.Effect<boolean>\n>(2, (self, effect) =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return false\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        MutableRef.set(self.state, deferred.done(effect))\n        for (let i = 0, len = state.joiners.length; i < len; i++) {\n          state.joiners[i](effect)\n        }\n        return true\n      }\n    }\n  }))\n\n/* @internal */\nexport const deferredDone = dual<\n  <A, E>(exit: Exit.Exit<A, E>) => (self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, exit: Exit.Exit<A, E>) => Effect.Effect<boolean>\n>(2, (self, exit) => deferredCompleteWith(self, exit))\n\n/* @internal */\nexport const deferredFail = dual<\n  <E>(error: E) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, error: E) => Effect.Effect<boolean>\n>(2, (self, error) => deferredCompleteWith(self, fail(error)))\n\n/* @internal */\nexport const deferredFailSync = dual<\n  <E>(evaluate: LazyArg<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<E>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)))\n\n/* @internal */\nexport const deferredFailCause = dual<\n  <E>(cause: Cause.Cause<E>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, cause: Cause.Cause<E>) => Effect.Effect<boolean>\n>(2, (self, cause) => deferredCompleteWith(self, failCause(cause)))\n\n/* @internal */\nexport const deferredFailCauseSync = dual<\n  <E>(evaluate: LazyArg<Cause.Cause<E>>) => <A>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)))\n\n/* @internal */\nexport const deferredDie = dual<\n  (defect: unknown) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, defect: unknown) => Effect.Effect<boolean>\n>(2, (self, defect) => deferredCompleteWith(self, die(defect)))\n\n/* @internal */\nexport const deferredDieSync = dual<\n  (evaluate: LazyArg<unknown>) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<unknown>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)))\n\n/* @internal */\nexport const deferredInterrupt = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  flatMap(fiberId, (fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredInterruptWith = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<boolean>\n>(2, (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)))\n\n/* @internal */\nexport const deferredIsDone = <A, E>(self: Deferred.Deferred<A, E>): Effect.Effect<boolean> =>\n  sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE)\n\n/* @internal */\nexport const deferredPoll = <A, E>(\n  self: Deferred.Deferred<A, E>\n): Effect.Effect<Option.Option<Effect.Effect<A, E>>> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    switch (state._tag) {\n      case DeferredOpCodes.OP_STATE_DONE: {\n        return Option.some(state.effect)\n      }\n      case DeferredOpCodes.OP_STATE_PENDING: {\n        return Option.none()\n      }\n    }\n  })\n\n/* @internal */\nexport const deferredSucceed = dual<\n  <A>(value: A) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, value: A) => Effect.Effect<boolean>\n>(2, (self, value) => deferredCompleteWith(self, succeed(value)))\n\n/* @internal */\nexport const deferredSync = dual<\n  <A>(evaluate: LazyArg<A>) => <E>(self: Deferred.Deferred<A, E>) => Effect.Effect<boolean>,\n  <A, E>(self: Deferred.Deferred<A, E>, evaluate: LazyArg<A>) => Effect.Effect<boolean>\n>(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)))\n\n/** @internal */\nexport const deferredUnsafeDone = <A, E>(self: Deferred.Deferred<A, E>, effect: Effect.Effect<A, E>): void => {\n  const state = MutableRef.get(self.state)\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(self.state, deferred.done(effect))\n    for (let i = 0, len = state.joiners.length; i < len; i++) {\n      state.joiners[i](effect)\n    }\n  }\n}\n\nconst deferredInterruptJoiner = <A, E>(\n  self: Deferred.Deferred<A, E>,\n  joiner: (effect: Effect.Effect<A, E>) => void\n): Effect.Effect<void> =>\n  sync(() => {\n    const state = MutableRef.get(self.state)\n    if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n      const index = state.joiners.indexOf(joiner)\n      if (index >= 0) {\n        // we can splice here as the internal state is mutable\n        state.joiners.splice(index, 1)\n      }\n    }\n  })\n\n// -----------------------------------------------------------------------------\n// Context\n// -----------------------------------------------------------------------------\n\nconst constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext))\n\n/* @internal */\nexport const context = <R>(): Effect.Effect<Context.Context<R>, never, R> => constContext as any\n\n/* @internal */\nexport const contextWith = <R0, A>(\n  f: (context: Context.Context<R0>) => A\n): Effect.Effect<A, never, R0> => map(context<R0>(), f)\n\n/* @internal */\nexport const contextWithEffect = <R2, A, E, R>(\n  f: (context: Context.Context<R2>) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R | R2> => flatMap(context<R2>(), f)\n\n/* @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) => Effect.Effect<A, E>\n>(2, <A, E, R>(self: Effect.Effect<A, E, R>, context: Context.Context<R>) =>\n  fiberRefLocally(\n    currentContext,\n    context\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const provideSomeContext = dual<\n  <R>(context: Context.Context<R>) => <A, E, R1>(self: Effect.Effect<A, E, R1>) => Effect.Effect<A, E, Exclude<R1, R>>,\n  <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) => Effect.Effect<A, E, Exclude<R1, R>>\n>(2, <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Context.Context<R>) =>\n  fiberRefLocallyWith(\n    currentContext,\n    (parent) => Context.merge(parent, context)\n  )(self as Effect.Effect<A, E>))\n\n/* @internal */\nexport const mapInputContext = dual<\n  <R2, R>(\n    f: (context: Context.Context<R2>) => Context.Context<R>\n  ) => <A, E>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2>,\n  <A, E, R, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (context: Context.Context<R2>) => Context.Context<R>\n  ) => Effect.Effect<A, E, R2>\n>(2, <A, E, R, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (context: Context.Context<R2>) => Context.Context<R>\n) => contextWithEffect((context: Context.Context<R2>) => provideContext(self, f(context))))\n\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const filterEffectOrElse: {\n  <A, E2, R2, A2, E3, R3>(\n    options: {\n      readonly predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n      readonly orElse: (a: NoInfer<A>) => Effect.Effect<A2, E3, R3>\n    }\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2 | E3, R | R2 | R3>\n  <A, E, R, E2, R2, A2, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n      readonly orElse: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ): Effect.Effect<A | A2, E | E2 | E3, R | R2 | R3>\n} = dual(2, <A, E, R, E2, R2, A2, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n    readonly orElse: (a: A) => Effect.Effect<A2, E3, R3>\n  }\n): Effect.Effect<A | A2, E | E2 | E3, R | R2 | R3> =>\n  flatMap(\n    self,\n    (a) =>\n      flatMap(\n        options.predicate(a),\n        (pass): Effect.Effect<A | A2, E3, R3> => pass ? succeed(a) : options.orElse(a)\n      )\n  ))\n\n/** @internal */\nexport const filterEffectOrFail: {\n  <A, E2, R2, E3>(\n    options: {\n      readonly predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n      readonly orFailWith: (a: NoInfer<A>) => E3\n    }\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2 | E3, R | R2>\n  <A, E, R, E2, R2, E3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n      readonly orFailWith: (a: A) => E3\n    }\n  ): Effect.Effect<A, E | E2 | E3, R | R2>\n} = dual(2, <A, E, R, E2, R2, E3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n    readonly orFailWith: (a: A) => E3\n  }\n): Effect.Effect<A, E | E2 | E3, R | R2> =>\n  filterEffectOrElse(self, {\n    predicate: options.predicate,\n    orElse: (a) => fail(options.orFailWith(a))\n  }))\n\n// -----------------------------------------------------------------------------\n// Tracing\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const currentSpanFromFiber = <A, E>(fiber: Fiber.RuntimeFiber<A, E>): Option.Option<Tracer.Span> => {\n  const span = fiber.currentSpan\n  return span !== undefined && span._tag === \"Span\" ? Option.some(span) : Option.none()\n}\n\nconst NoopSpanProto: Omit<Tracer.Span, \"parent\" | \"name\" | \"context\"> = {\n  _tag: \"Span\",\n  spanId: \"noop\",\n  traceId: \"noop\",\n  sampled: false,\n  status: {\n    _tag: \"Ended\",\n    startTime: BigInt(0),\n    endTime: BigInt(0),\n    exit: exitVoid\n  },\n  attributes: new Map(),\n  links: [],\n  kind: \"internal\",\n  attribute() {},\n  event() {},\n  end() {},\n  addLinks() {}\n}\n\n/** @internal */\nexport const noopSpan = (options: {\n  readonly name: string\n  readonly parent: Option.Option<Tracer.AnySpan>\n  readonly context: Context.Context<never>\n}): Tracer.Span => Object.assign(Object.create(NoopSpanProto), options)\n","import type * as Deferred from \"../Deferred.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as OpCodes from \"./opCodes/deferred.js\"\n\n/** @internal */\nconst DeferredSymbolKey = \"effect/Deferred\"\n\n/** @internal */\nexport const DeferredTypeId: Deferred.DeferredTypeId = Symbol.for(\n  DeferredSymbolKey\n) as Deferred.DeferredTypeId\n\n/** @internal */\nexport const deferredVariance = {\n  /* c8 ignore next */\n  _E: (_: any) => _,\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nexport type State</* in out */ A, /* in out */ E> = Pending<A, E> | Done<A, E>\n\n/** @internal */\nexport interface Pending<in A, in E> {\n  readonly _tag: \"Pending\"\n  readonly joiners: Array<(effect: Effect.Effect<A, E>) => void>\n}\n\n/** @internal */\nexport interface Done<out A, out E> {\n  readonly _tag: \"Done\"\n  readonly effect: Effect.Effect<A, E>\n}\n\n/** @internal */\nexport const pending = <A, E>(\n  joiners: Array<(effect: Effect.Effect<A, E>) => void>\n): State<A, E> => {\n  return { _tag: OpCodes.OP_STATE_PENDING, joiners }\n}\n\n/** @internal */\nexport const done = <A, E>(effect: Effect.Effect<A, E>): State<A, E> => {\n  return { _tag: OpCodes.OP_STATE_DONE, effect }\n}\n","/** @internal */\nexport const OP_STATE_PENDING = \"Pending\" as const\n\n/** @internal */\nexport type OP_STATE_PENDING = typeof OP_STATE_PENDING\n\n/** @internal */\nexport const OP_STATE_DONE = \"Done\" as const\n\n/** @internal */\nexport type OP_STATE_DONE = typeof OP_STATE_DONE\n","/** @internal */\nexport class SingleShotGen<T, A> implements Generator<T, A> {\n  called = false\n\n  constructor(readonly self: T) {\n  }\n\n  next(a: A): IteratorResult<T, A> {\n    return this.called ?\n      ({\n        value: a,\n        done: true\n      }) :\n      (this.called = true,\n        ({\n          value: this.self,\n          done: false\n        }))\n  }\n\n  return(a: A): IteratorResult<T, A> {\n    return ({\n      value: a,\n      done: true\n    })\n  }\n\n  throw(e: unknown): IteratorResult<T, A> {\n    throw e\n  }\n\n  [Symbol.iterator](): Generator<T, A> {\n    return new SingleShotGen<T, A>(this.self)\n  }\n}\n","/**\n * This module provides utility functions and type class instances for working with the `boolean` type in TypeScript.\n * It includes functions for basic boolean operations, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @since 2.0.0\n */\nimport * as equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual } from \"./Function.js\"\nimport * as order from \"./Order.js\"\nimport * as predicate from \"./Predicate.js\"\n\n/**\n * Tests if a value is a `boolean`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { isBoolean } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBoolean: (input: unknown) => input is boolean = predicate.isBoolean\n\n/**\n * This function returns the result of either of the given functions depending on the value of the boolean parameter.\n * It is useful when you have to run one of two functions depending on the boolean value.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Boolean } from \"effect\"\n *\n * assert.deepStrictEqual(Boolean.match(true, { onFalse: () => \"It's false!\", onTrue: () => \"It's true!\" }), \"It's true!\")\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * This function returns the result of either of the given functions depending on the value of the boolean parameter.\n   * It is useful when you have to run one of two functions depending on the boolean value.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Boolean } from \"effect\"\n   *\n   * assert.deepStrictEqual(Boolean.match(true, { onFalse: () => \"It's false!\", onTrue: () => \"It's true!\" }), \"It's true!\")\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B = A>(\n    options: {\n      readonly onFalse: LazyArg<A>\n      readonly onTrue: LazyArg<B>\n    }\n  ): (value: boolean) => A | B\n  /**\n   * This function returns the result of either of the given functions depending on the value of the boolean parameter.\n   * It is useful when you have to run one of two functions depending on the boolean value.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Boolean } from \"effect\"\n   *\n   * assert.deepStrictEqual(Boolean.match(true, { onFalse: () => \"It's false!\", onTrue: () => \"It's true!\" }), \"It's true!\")\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B>(\n    value: boolean,\n    options: {\n      readonly onFalse: LazyArg<A>\n      readonly onTrue: LazyArg<B>\n    }\n  ): A | B\n} = dual(2, <A, B>(value: boolean, options: {\n  readonly onFalse: LazyArg<A>\n  readonly onTrue: LazyArg<B>\n}): A | B => value ? options.onTrue() : options.onFalse())\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence: equivalence.Equivalence<boolean> = equivalence.boolean\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order: order.Order<boolean> = order.boolean\n\n/**\n * Negates the given boolean: `!self`\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { not } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(not(true), false)\n * assert.deepStrictEqual(not(false), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const not = (self: boolean): boolean => !self\n\n/**\n * Combines two boolean using AND: `self && that`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { and } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(and(true, true), true)\n * assert.deepStrictEqual(and(true, false), false)\n * assert.deepStrictEqual(and(false, true), false)\n * assert.deepStrictEqual(and(false, false), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const and: {\n  /**\n   * Combines two boolean using AND: `self && that`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { and } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(and(true, true), true)\n   * assert.deepStrictEqual(and(true, false), false)\n   * assert.deepStrictEqual(and(false, true), false)\n   * assert.deepStrictEqual(and(false, false), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two boolean using AND: `self && that`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { and } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(and(true, true), true)\n   * assert.deepStrictEqual(and(true, false), false)\n   * assert.deepStrictEqual(and(false, true), false)\n   * assert.deepStrictEqual(and(false, false), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self: boolean, that: boolean): boolean => self && that)\n\n/**\n * Combines two boolean using NAND: `!(self && that)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { nand } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(nand(true, true), false)\n * assert.deepStrictEqual(nand(true, false), true)\n * assert.deepStrictEqual(nand(false, true), true)\n * assert.deepStrictEqual(nand(false, false), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const nand: {\n  /**\n   * Combines two boolean using NAND: `!(self && that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { nand } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(nand(true, true), false)\n   * assert.deepStrictEqual(nand(true, false), true)\n   * assert.deepStrictEqual(nand(false, true), true)\n   * assert.deepStrictEqual(nand(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two boolean using NAND: `!(self && that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { nand } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(nand(true, true), false)\n   * assert.deepStrictEqual(nand(true, false), true)\n   * assert.deepStrictEqual(nand(false, true), true)\n   * assert.deepStrictEqual(nand(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self: boolean, that: boolean): boolean => !(self && that))\n\n/**\n * Combines two boolean using OR: `self || that`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { or } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(or(true, true), true)\n * assert.deepStrictEqual(or(true, false), true)\n * assert.deepStrictEqual(or(false, true), true)\n * assert.deepStrictEqual(or(false, false), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const or: {\n  /**\n   * Combines two boolean using OR: `self || that`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { or } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(or(true, true), true)\n   * assert.deepStrictEqual(or(true, false), true)\n   * assert.deepStrictEqual(or(false, true), true)\n   * assert.deepStrictEqual(or(false, false), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two boolean using OR: `self || that`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { or } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(or(true, true), true)\n   * assert.deepStrictEqual(or(true, false), true)\n   * assert.deepStrictEqual(or(false, true), true)\n   * assert.deepStrictEqual(or(false, false), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self: boolean, that: boolean): boolean => self || that)\n\n/**\n * Combines two booleans using NOR: `!(self || that)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { nor } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(nor(true, true), false)\n * assert.deepStrictEqual(nor(true, false), false)\n * assert.deepStrictEqual(nor(false, true), false)\n * assert.deepStrictEqual(nor(false, false), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const nor: {\n  /**\n   * Combines two booleans using NOR: `!(self || that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { nor } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(nor(true, true), false)\n   * assert.deepStrictEqual(nor(true, false), false)\n   * assert.deepStrictEqual(nor(false, true), false)\n   * assert.deepStrictEqual(nor(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two booleans using NOR: `!(self || that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { nor } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(nor(true, true), false)\n   * assert.deepStrictEqual(nor(true, false), false)\n   * assert.deepStrictEqual(nor(false, true), false)\n   * assert.deepStrictEqual(nor(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self: boolean, that: boolean): boolean => !(self || that))\n\n/**\n * Combines two booleans using XOR: `(!self && that) || (self && !that)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { xor } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(xor(true, true), false)\n * assert.deepStrictEqual(xor(true, false), true)\n * assert.deepStrictEqual(xor(false, true), true)\n * assert.deepStrictEqual(xor(false, false), false)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const xor: {\n  /**\n   * Combines two booleans using XOR: `(!self && that) || (self && !that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { xor } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(xor(true, true), false)\n   * assert.deepStrictEqual(xor(true, false), true)\n   * assert.deepStrictEqual(xor(false, true), true)\n   * assert.deepStrictEqual(xor(false, false), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two booleans using XOR: `(!self && that) || (self && !that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { xor } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(xor(true, true), false)\n   * assert.deepStrictEqual(xor(true, false), true)\n   * assert.deepStrictEqual(xor(false, true), true)\n   * assert.deepStrictEqual(xor(false, false), false)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self: boolean, that: boolean): boolean => (!self && that) || (self && !that))\n\n/**\n * Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { eqv } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(eqv(true, true), true)\n * assert.deepStrictEqual(eqv(true, false), false)\n * assert.deepStrictEqual(eqv(false, true), false)\n * assert.deepStrictEqual(eqv(false, false), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const eqv: {\n  /**\n   * Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { eqv } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(eqv(true, true), true)\n   * assert.deepStrictEqual(eqv(true, false), false)\n   * assert.deepStrictEqual(eqv(false, true), false)\n   * assert.deepStrictEqual(eqv(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two booleans using EQV (aka XNOR): `!xor(self, that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { eqv } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(eqv(true, true), true)\n   * assert.deepStrictEqual(eqv(true, false), false)\n   * assert.deepStrictEqual(eqv(false, true), false)\n   * assert.deepStrictEqual(eqv(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self: boolean, that: boolean): boolean => !xor(self, that))\n\n/**\n * Combines two booleans using an implication: `(!self || that)`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { implies } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(implies(true, true), true)\n * assert.deepStrictEqual(implies(true, false), false)\n * assert.deepStrictEqual(implies(false, true), true)\n * assert.deepStrictEqual(implies(false, false), true)\n * ```\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const implies: {\n  /**\n   * Combines two booleans using an implication: `(!self || that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { implies } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(implies(true, true), true)\n   * assert.deepStrictEqual(implies(true, false), false)\n   * assert.deepStrictEqual(implies(false, true), true)\n   * assert.deepStrictEqual(implies(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (that: boolean): (self: boolean) => boolean\n  /**\n   * Combines two booleans using an implication: `(!self || that)`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { implies } from \"effect/Boolean\"\n   *\n   * assert.deepStrictEqual(implies(true, true), true)\n   * assert.deepStrictEqual(implies(true, false), false)\n   * assert.deepStrictEqual(implies(false, true), true)\n   * assert.deepStrictEqual(implies(false, false), true)\n   * ```\n   *\n   * @category combinators\n   * @since 2.0.0\n   */\n  (self: boolean, that: boolean): boolean\n} = dual(2, (self, that) => self ? that : true)\n\n/**\n * This utility function is used to check if all the elements in a collection of boolean values are `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { every } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(every([true, true, true]), true)\n * assert.deepStrictEqual(every([true, false, true]), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const every = (collection: Iterable<boolean>): boolean => {\n  for (const b of collection) {\n    if (!b) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * This utility function is used to check if at least one of the elements in a collection of boolean values is `true`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { some } from \"effect/Boolean\"\n *\n * assert.deepStrictEqual(some([true, false, true]), true)\n * assert.deepStrictEqual(some([false, false, false]), false)\n * ```\n *\n * @since 2.0.0\n */\nexport const some = (collection: Iterable<boolean>): boolean => {\n  for (const b of collection) {\n    if (b) {\n      return true\n    }\n  }\n  return false\n}\n","import type * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport { dual } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\n\n/** @internal */\nexport const OP_SEQUENTIAL = \"Sequential\" as const\n\n/** @internal */\nexport type OP_SEQUENTIAL = typeof OP_SEQUENTIAL\n\n/** @internal */\nexport const OP_PARALLEL = \"Parallel\" as const\n\n/** @internal */\nexport type OP_PARALLEL = typeof OP_PARALLEL\n\n/** @internal */\nexport const OP_PARALLEL_N = \"ParallelN\" as const\n\n/** @internal */\nexport type OP_PARALLEL_N = typeof OP_PARALLEL_N\n\n/** @internal */\nexport const sequential: ExecutionStrategy.ExecutionStrategy = { _tag: OP_SEQUENTIAL }\n\n/** @internal */\nexport const parallel: ExecutionStrategy.ExecutionStrategy = { _tag: OP_PARALLEL }\n\n/** @internal */\nexport const parallelN = (parallelism: number): ExecutionStrategy.ExecutionStrategy => ({\n  _tag: OP_PARALLEL_N,\n  parallelism\n})\n\n/** @internal */\nexport const isSequential = (self: ExecutionStrategy.ExecutionStrategy): self is ExecutionStrategy.Sequential =>\n  self._tag === OP_SEQUENTIAL\n\n/** @internal */\nexport const isParallel = (self: ExecutionStrategy.ExecutionStrategy): self is ExecutionStrategy.Parallel =>\n  self._tag === OP_PARALLEL\n\n/** @internal */\nexport const isParallelN = (self: ExecutionStrategy.ExecutionStrategy): self is ExecutionStrategy.ParallelN =>\n  self._tag === OP_PARALLEL_N\n\n/** @internal */\nexport const match = dual<\n  <A>(options: {\n    readonly onSequential: LazyArg<A>\n    readonly onParallel: LazyArg<A>\n    readonly onParallelN: (n: number) => A\n  }) => (self: ExecutionStrategy.ExecutionStrategy) => A,\n  <A>(\n    self: ExecutionStrategy.ExecutionStrategy,\n    options: {\n      readonly onSequential: LazyArg<A>\n      readonly onParallel: LazyArg<A>\n      readonly onParallelN: (n: number) => A\n    }\n  ) => A\n>(2, (self, options) => {\n  switch (self._tag) {\n    case OP_SEQUENTIAL: {\n      return options.onSequential()\n    }\n    case OP_PARALLEL: {\n      return options.onParallel()\n    }\n    case OP_PARALLEL_N: {\n      return options.onParallelN(self.parallelism)\n    }\n  }\n})\n","/**\n * @since 2.0.0\n */\nimport type { Effect } from \"./Effect.js\"\nimport { dual } from \"./Function.js\"\nimport * as core from \"./internal/core.js\"\nimport { type Pipeable, pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Readable\")\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Readable<A, E = never, R = never> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly get: Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isReadable = (u: unknown): u is Readable<unknown, unknown, unknown> => hasProperty(u, TypeId)\n\nconst Proto: Omit<Readable<any>, \"get\"> = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = <A, E, R>(get: Effect<A, E, R>): Readable<A, E, R> => {\n  const self = Object.create(Proto)\n  self.get = get\n  return self\n}\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Readable<A, E, R>) => Readable<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E, R, B>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => B): Readable<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => B): Readable<B, E, R> => make(core.map(self.get, f))\n)\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const mapEffect: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(fa: Readable<A, E, R>) => Readable<B, E | E2, R | R2>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E, R, B, E2, R2>(self: Readable<A, E, R>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Readable<B, E | E2, R | R2>\n} = dual(2, <A, E, R, B, E2, R2>(\n  self: Readable<A, E, R>,\n  f: (a: NoInfer<A>) => Effect<B, E2, R2>\n): Readable<B, E | E2, R | R2> => make(core.flatMap(self.get, f)))\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unwrap = <A, E, R, E1, R1>(\n  effect: Effect<Readable<A, E, R>, E1, R1>\n): Readable<A, E | E1, R | R1> =>\n  make(\n    core.flatMap(effect, (s) => s.get)\n  )\n","import * as Equal from \"../Equal.js\"\nimport type { FiberId } from \"../FiberId.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport { pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type { RuntimeFlags } from \"../RuntimeFlags.js\"\n\nconst FiberStatusSymbolKey = \"effect/FiberStatus\"\n\n/** @internal */\nexport const FiberStatusTypeId: FiberStatus.FiberStatusTypeId = Symbol.for(\n  FiberStatusSymbolKey\n) as FiberStatus.FiberStatusTypeId\n\n/** @internal */\nexport const OP_DONE = \"Done\" as const\n\n/** @internal */\nexport type OP_DONE = typeof OP_DONE\n\n/** @internal */\nexport const OP_RUNNING = \"Running\" as const\n\n/** @internal */\nexport type OP_RUNNING = typeof OP_RUNNING\n\n/** @internal */\nexport const OP_SUSPENDED = \"Suspended\" as const\n\n/** @internal */\nexport type OP_SUSPENDED = typeof OP_SUSPENDED\n\nconst DoneHash = Hash.string(`${FiberStatusSymbolKey}-${OP_DONE}`)\n\n/** @internal */\nclass Done implements FiberStatus.Done {\n  readonly [FiberStatusTypeId]: FiberStatus.FiberStatusTypeId = FiberStatusTypeId\n  readonly _tag = OP_DONE;\n  [Hash.symbol](): number {\n    return DoneHash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isFiberStatus(that) && that._tag === OP_DONE\n  }\n}\n\n/** @internal */\nclass Running implements FiberStatus.Running {\n  readonly [FiberStatusTypeId]: FiberStatus.FiberStatusTypeId = FiberStatusTypeId\n  readonly _tag = OP_RUNNING\n  constructor(readonly runtimeFlags: RuntimeFlags) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(FiberStatusSymbolKey),\n      Hash.combine(Hash.hash(this._tag)),\n      Hash.combine(Hash.hash(this.runtimeFlags)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return (\n      isFiberStatus(that) &&\n      that._tag === OP_RUNNING &&\n      this.runtimeFlags === that.runtimeFlags\n    )\n  }\n}\n\n/** @internal */\nclass Suspended implements FiberStatus.Suspended {\n  readonly [FiberStatusTypeId]: FiberStatus.FiberStatusTypeId = FiberStatusTypeId\n  readonly _tag = OP_SUSPENDED\n  constructor(\n    readonly runtimeFlags: RuntimeFlags,\n    readonly blockingOn: FiberId\n  ) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(FiberStatusSymbolKey),\n      Hash.combine(Hash.hash(this._tag)),\n      Hash.combine(Hash.hash(this.runtimeFlags)),\n      Hash.combine(Hash.hash(this.blockingOn)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return (\n      isFiberStatus(that) &&\n      that._tag === OP_SUSPENDED &&\n      this.runtimeFlags === that.runtimeFlags &&\n      Equal.equals(this.blockingOn, that.blockingOn)\n    )\n  }\n}\n\n/** @internal */\nexport const done: FiberStatus.FiberStatus = new Done()\n\n/** @internal */\nexport const running = (runtimeFlags: RuntimeFlags): FiberStatus.FiberStatus => new Running(runtimeFlags)\n\n/** @internal */\nexport const suspended = (\n  runtimeFlags: RuntimeFlags,\n  blockingOn: FiberId\n): FiberStatus.FiberStatus => new Suspended(runtimeFlags, blockingOn)\n\n/** @internal */\nexport const isFiberStatus = (u: unknown): u is FiberStatus.FiberStatus => hasProperty(u, FiberStatusTypeId)\n\n/** @internal */\nexport const isDone = (self: FiberStatus.FiberStatus): self is FiberStatus.Done => self._tag === OP_DONE\n\n/** @internal */\nexport const isRunning = (self: FiberStatus.FiberStatus): self is FiberStatus.Running => self._tag === OP_RUNNING\n\n/** @internal */\nexport const isSuspended = (self: FiberStatus.FiberStatus): self is FiberStatus.Suspended => self._tag === OP_SUSPENDED\n","/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport { dual, pipe } from \"./Function.js\"\nimport * as core from \"./internal/core.js\"\nimport * as number from \"./Number.js\"\nimport * as order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * A `LogLevel` represents the log level associated with an individual logging\n * operation. Log levels are used both to describe the granularity (or\n * importance) of individual log statements, as well as to enable tuning\n * verbosity of log output.\n *\n * @since 2.0.0\n * @category model\n * @property ordinal - The priority of the log message. Larger values indicate higher priority.\n * @property label - A label associated with the log level.\n * @property syslog -The syslog severity level of the log level.\n */\nexport type LogLevel = All | Fatal | Error | Warning | Info | Debug | Trace | None\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport type Literal = LogLevel[\"_tag\"]\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface All extends Pipeable {\n  readonly _tag: \"All\"\n  readonly label: \"ALL\"\n  readonly syslog: 0\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Fatal extends Pipeable {\n  readonly _tag: \"Fatal\"\n  readonly label: \"FATAL\"\n  readonly syslog: 2\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Error extends Pipeable {\n  readonly _tag: \"Error\"\n  readonly label: \"ERROR\"\n  readonly syslog: 3\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Warning extends Pipeable {\n  readonly _tag: \"Warning\"\n  readonly label: \"WARN\"\n  readonly syslog: 4\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Info extends Pipeable {\n  readonly _tag: \"Info\"\n  readonly label: \"INFO\"\n  readonly syslog: 6\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Debug extends Pipeable {\n  readonly _tag: \"Debug\"\n  readonly label: \"DEBUG\"\n  readonly syslog: 7\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Trace extends Pipeable {\n  readonly _tag: \"Trace\"\n  readonly label: \"TRACE\"\n  readonly syslog: 7\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface None extends Pipeable {\n  readonly _tag: \"None\"\n  readonly label: \"OFF\"\n  readonly syslog: 7\n  readonly ordinal: number\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const All: LogLevel = core.logLevelAll\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Fatal: LogLevel = core.logLevelFatal\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Error: LogLevel = core.logLevelError\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Warning: LogLevel = core.logLevelWarning\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Info: LogLevel = core.logLevelInfo\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Debug: LogLevel = core.logLevelDebug\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Trace: LogLevel = core.logLevelTrace\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const None: LogLevel = core.logLevelNone\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const allLevels = core.allLogLevels\n\n/**\n * Temporarily sets a `LogLevel` for an `Effect` workflow.\n *\n * **Details**\n *\n * This function allows you to apply a specific `LogLevel` locally to an\n * `Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its\n * previous state.\n *\n * **When to Use**\n *\n * This is particularly useful when you want to adjust the verbosity of logging\n * for specific parts of your program without affecting the global log level.\n *\n * @example\n * ```ts\n * import { Effect, LogLevel } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"message1\")\n *   yield* Effect.gen(function*() {\n *     yield* Effect.log(\"message2\")\n *     yield* Effect.log(\"message3\")\n *   }).pipe(LogLevel.locally(LogLevel.Warning))\n * })\n *\n * Effect.runFork(program)\n * // timestamp=... level=INFO fiber=#0 message=message1\n * // timestamp=... level=WARN fiber=#0 message=message2\n * // timestamp=... level=WARN fiber=#0 message=message3\n * ```\n *\n * @since 2.0.0\n * @category utils\n */\nexport const locally: {\n  /**\n   * Temporarily sets a `LogLevel` for an `Effect` workflow.\n   *\n   * **Details**\n   *\n   * This function allows you to apply a specific `LogLevel` locally to an\n   * `Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its\n   * previous state.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful when you want to adjust the verbosity of logging\n   * for specific parts of your program without affecting the global log level.\n   *\n   * @example\n   * ```ts\n   * import { Effect, LogLevel } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"message1\")\n   *   yield* Effect.gen(function*() {\n   *     yield* Effect.log(\"message2\")\n   *     yield* Effect.log(\"message3\")\n   *   }).pipe(LogLevel.locally(LogLevel.Warning))\n   * })\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=message1\n   * // timestamp=... level=WARN fiber=#0 message=message2\n   * // timestamp=... level=WARN fiber=#0 message=message3\n   * ```\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Temporarily sets a `LogLevel` for an `Effect` workflow.\n   *\n   * **Details**\n   *\n   * This function allows you to apply a specific `LogLevel` locally to an\n   * `Effect` workflow. Once the workflow completes, the `LogLevel` reverts to its\n   * previous state.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful when you want to adjust the verbosity of logging\n   * for specific parts of your program without affecting the global log level.\n   *\n   * @example\n   * ```ts\n   * import { Effect, LogLevel } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"message1\")\n   *   yield* Effect.gen(function*() {\n   *     yield* Effect.log(\"message2\")\n   *     yield* Effect.log(\"message3\")\n   *   }).pipe(LogLevel.locally(LogLevel.Warning))\n   * })\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=message1\n   * // timestamp=... level=WARN fiber=#0 message=message2\n   * // timestamp=... level=WARN fiber=#0 message=message3\n   * ```\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R> =>\n    core.fiberRefLocally(use, core.currentLogLevel, self)\n)\n\n/**\n * @since 2.0.0\n * @category instances\n */\nexport const Order: order.Order<LogLevel> = pipe(\n  number.Order,\n  order.mapInput((level: LogLevel) => level.ordinal)\n)\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nexport const lessThan: {\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: LogLevel): (self: LogLevel) => boolean\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: LogLevel, that: LogLevel): boolean\n} = order.lessThan(Order)\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nexport const lessThanEqual: {\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: LogLevel): (self: LogLevel) => boolean\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: LogLevel, that: LogLevel): boolean\n} = order.lessThanOrEqualTo(Order)\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nexport const greaterThan: {\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: LogLevel): (self: LogLevel) => boolean\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: LogLevel, that: LogLevel): boolean\n} = order.greaterThan(Order)\n\n/**\n * @since 2.0.0\n * @category ordering\n */\nexport const greaterThanEqual: {\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: LogLevel): (self: LogLevel) => boolean\n  /**\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: LogLevel, that: LogLevel): boolean\n} = order.greaterThanOrEqualTo(Order)\n\n/**\n * @since 2.0.0\n * @category conversions\n */\nexport const fromLiteral = (literal: Literal): LogLevel => {\n  switch (literal) {\n    case \"All\":\n      return All\n    case \"Debug\":\n      return Debug\n    case \"Error\":\n      return Error\n    case \"Fatal\":\n      return Fatal\n    case \"Info\":\n      return Info\n    case \"Trace\":\n      return Trace\n    case \"None\":\n      return None\n    case \"Warning\":\n      return Warning\n  }\n}\n","import * as Arr from \"../../Array.js\"\nimport { equals } from \"../../Equal.js\"\nimport type * as FiberId from \"../../FiberId.js\"\nimport type * as FiberRefs from \"../../FiberRefs.js\"\nimport type * as FiberRefsPatch from \"../../FiberRefsPatch.js\"\nimport { dual } from \"../../Function.js\"\nimport * as fiberRefs_ from \"../fiberRefs.js\"\n\n/** @internal */\nexport const OP_EMPTY = \"Empty\" as const\n\n/** @internal */\nexport type OP_EMPTY = typeof OP_EMPTY\n\n/** @internal */\nexport const OP_ADD = \"Add\" as const\n\n/** @internal */\nexport type OP_ADD = typeof OP_ADD\n\n/** @internal */\nexport const OP_REMOVE = \"Remove\" as const\n\n/** @internal */\nexport type OP_REMOVE = typeof OP_REMOVE\n\n/** @internal */\nexport const OP_UPDATE = \"Update\" as const\n\n/** @internal */\nexport type OP_UPDATE = typeof OP_UPDATE\n\n/** @internal */\nexport const OP_AND_THEN = \"AndThen\" as const\n\n/** @internal */\nexport type OP_AND_THEN = typeof OP_AND_THEN\n\n/** @internal */\nexport const empty: FiberRefsPatch.FiberRefsPatch = ({\n  _tag: OP_EMPTY\n}) as FiberRefsPatch.FiberRefsPatch\n\n/** @internal */\nexport const diff = (\n  oldValue: FiberRefs.FiberRefs,\n  newValue: FiberRefs.FiberRefs\n): FiberRefsPatch.FiberRefsPatch => {\n  const missingLocals = new Map(oldValue.locals)\n  let patch = empty\n  for (const [fiberRef, pairs] of newValue.locals.entries()) {\n    const newValue = Arr.headNonEmpty(pairs)[1]\n    const old = missingLocals.get(fiberRef)\n    if (old !== undefined) {\n      const oldValue = Arr.headNonEmpty(old)[1]\n      if (!equals(oldValue, newValue)) {\n        patch = combine({\n          _tag: OP_UPDATE,\n          fiberRef,\n          patch: fiberRef.diff(oldValue, newValue)\n        })(patch)\n      }\n    } else {\n      patch = combine({\n        _tag: OP_ADD,\n        fiberRef,\n        value: newValue\n      })(patch)\n    }\n    missingLocals.delete(fiberRef)\n  }\n  for (const [fiberRef] of missingLocals.entries()) {\n    patch = combine({\n      _tag: OP_REMOVE,\n      fiberRef\n    })(patch)\n  }\n  return patch\n}\n\n/** @internal */\nexport const combine = dual<\n  (that: FiberRefsPatch.FiberRefsPatch) => (self: FiberRefsPatch.FiberRefsPatch) => FiberRefsPatch.FiberRefsPatch,\n  (self: FiberRefsPatch.FiberRefsPatch, that: FiberRefsPatch.FiberRefsPatch) => FiberRefsPatch.FiberRefsPatch\n>(2, (self, that) => ({\n  _tag: OP_AND_THEN,\n  first: self,\n  second: that\n}))\n\n/** @internal */\nexport const patch = dual<\n  (\n    fiberId: FiberId.Runtime,\n    oldValue: FiberRefs.FiberRefs\n  ) => (self: FiberRefsPatch.FiberRefsPatch) => FiberRefs.FiberRefs,\n  (\n    self: FiberRefsPatch.FiberRefsPatch,\n    fiberId: FiberId.Runtime,\n    oldValue: FiberRefs.FiberRefs\n  ) => FiberRefs.FiberRefs\n>(3, (self, fiberId, oldValue) => {\n  let fiberRefs: FiberRefs.FiberRefs = oldValue\n  let patches: ReadonlyArray<FiberRefsPatch.FiberRefsPatch> = Arr.of(self)\n  while (Arr.isNonEmptyReadonlyArray(patches)) {\n    const head = Arr.headNonEmpty(patches)\n    const tail = Arr.tailNonEmpty(patches)\n    switch (head._tag) {\n      case OP_EMPTY: {\n        patches = tail\n        break\n      }\n      case OP_ADD: {\n        fiberRefs = fiberRefs_.updateAs(fiberRefs, {\n          fiberId,\n          fiberRef: head.fiberRef,\n          value: head.value\n        })\n        patches = tail\n        break\n      }\n      case OP_REMOVE: {\n        fiberRefs = fiberRefs_.delete_(fiberRefs, head.fiberRef)\n        patches = tail\n        break\n      }\n      case OP_UPDATE: {\n        const value = fiberRefs_.getOrDefault(fiberRefs, head.fiberRef)\n        fiberRefs = fiberRefs_.updateAs(fiberRefs, {\n          fiberId,\n          fiberRef: head.fiberRef,\n          value: head.fiberRef.patch(head.patch)(value)\n        })\n        patches = tail\n        break\n      }\n      case OP_AND_THEN: {\n        patches = Arr.prepend(head.first)(Arr.prepend(head.second)(tail))\n        break\n      }\n    }\n  }\n  return fiberRefs\n})\n","import * as Arr from \"../Array.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport type * as FiberRefs from \"../FiberRefs.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nexport function unsafeMake(\n  fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>\n): FiberRefs.FiberRefs {\n  return new FiberRefsImpl(fiberRefLocals)\n}\n\n/** @internal */\nexport function empty(): FiberRefs.FiberRefs {\n  return unsafeMake(new Map())\n}\n\n/** @internal */\nexport const FiberRefsSym: FiberRefs.FiberRefsSym = Symbol.for(\"effect/FiberRefs\") as FiberRefs.FiberRefsSym\n\n/** @internal */\nexport class FiberRefsImpl implements FiberRefs.FiberRefs {\n  readonly [FiberRefsSym]: FiberRefs.FiberRefsSym = FiberRefsSym\n  constructor(\n    readonly locals: Map<\n      FiberRef.FiberRef<any>,\n      Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>\n    >\n  ) {}\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nconst findAncestor = (\n  _ref: FiberRef.FiberRef<any>,\n  _parentStack: ReadonlyArray<readonly [FiberId.Single, unknown]>,\n  _childStack: ReadonlyArray<readonly [FiberId.Single, unknown]>,\n  _childModified = false\n): readonly [unknown, boolean] => {\n  const ref = _ref\n  let parentStack = _parentStack\n  let childStack = _childStack\n  let childModified = _childModified\n  let ret: readonly [unknown, boolean] | undefined = undefined\n  while (ret === undefined) {\n    if (Arr.isNonEmptyReadonlyArray(parentStack) && Arr.isNonEmptyReadonlyArray(childStack)) {\n      const parentFiberId = Arr.headNonEmpty(parentStack)[0]\n      const parentAncestors = Arr.tailNonEmpty(parentStack)\n      const childFiberId = Arr.headNonEmpty(childStack)[0]\n      const childRefValue = Arr.headNonEmpty(childStack)[1]\n      const childAncestors = Arr.tailNonEmpty(childStack)\n      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {\n        childStack = childAncestors\n        childModified = true\n      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {\n        parentStack = parentAncestors\n      } else {\n        if (parentFiberId.id < childFiberId.id) {\n          childStack = childAncestors\n          childModified = true\n        } else if (parentFiberId.id > childFiberId.id) {\n          parentStack = parentAncestors\n        } else {\n          ret = [childRefValue, childModified] as const\n        }\n      }\n    } else {\n      ret = [ref.initial, true] as const\n    }\n  }\n  return ret\n}\n\n/** @internal */\nexport const joinAs = dual<\n  (fiberId: FiberId.Single, that: FiberRefs.FiberRefs) => (self: FiberRefs.FiberRefs) => FiberRefs.FiberRefs,\n  (self: FiberRefs.FiberRefs, fiberId: FiberId.Single, that: FiberRefs.FiberRefs) => FiberRefs.FiberRefs\n>(3, (self, fiberId, that) => {\n  const parentFiberRefs = new Map(self.locals)\n  that.locals.forEach((childStack, fiberRef) => {\n    const childValue = childStack[0][1]\n    if (!childStack[0][0][Equal.symbol](fiberId)) {\n      if (!parentFiberRefs.has(fiberRef)) {\n        if (Equal.equals(childValue, fiberRef.initial)) {\n          return\n        }\n        parentFiberRefs.set(\n          fiberRef,\n          [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]\n        )\n        return\n      }\n      const parentStack = parentFiberRefs.get(fiberRef)!\n      const [ancestor, wasModified] = findAncestor(\n        fiberRef,\n        parentStack,\n        childStack\n      )\n      if (wasModified) {\n        const patch = fiberRef.diff(ancestor, childValue)\n        const oldValue = parentStack[0][1]\n        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue))\n        if (!Equal.equals(oldValue, newValue)) {\n          let newStack: Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, unknown]>\n          const parentFiberId = parentStack[0][0]\n          if (parentFiberId[Equal.symbol](fiberId)) {\n            newStack = [[parentFiberId, newValue] as const, ...parentStack.slice(1)]\n          } else {\n            newStack = [[fiberId, newValue] as const, ...parentStack]\n          }\n          parentFiberRefs.set(fiberRef, newStack)\n        }\n      }\n    }\n  })\n  return new FiberRefsImpl(parentFiberRefs)\n})\n\n/** @internal */\nexport const forkAs = dual<\n  (childId: FiberId.Single) => (self: FiberRefs.FiberRefs) => FiberRefs.FiberRefs,\n  (self: FiberRefs.FiberRefs, childId: FiberId.Single) => FiberRefs.FiberRefs\n>(2, (self, childId) => {\n  const map = new Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, unknown]>>()\n  unsafeForkAs(self, map, childId)\n  return new FiberRefsImpl(map)\n})\n\nconst unsafeForkAs = (\n  self: FiberRefs.FiberRefs,\n  map: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>,\n  fiberId: FiberId.Single\n) => {\n  self.locals.forEach((stack, fiberRef) => {\n    const oldValue = stack[0][1]\n    const newValue = fiberRef.patch(fiberRef.fork)(oldValue)\n    if (Equal.equals(oldValue, newValue)) {\n      map.set(fiberRef, stack)\n    } else {\n      map.set(fiberRef, [[fiberId, newValue] as const, ...stack])\n    }\n  })\n}\n\n/** @internal */\nexport const fiberRefs = (self: FiberRefs.FiberRefs) => HashSet.fromIterable(self.locals.keys())\n\n/** @internal */\nexport const setAll = (self: FiberRefs.FiberRefs): Effect.Effect<void> =>\n  core.forEachSequentialDiscard(\n    fiberRefs(self),\n    (fiberRef) => core.fiberRefSet(fiberRef, getOrDefault(self, fiberRef))\n  )\n\n/** @internal */\nexport const delete_ = dual<\n  <A>(fiberRef: FiberRef.FiberRef<A>) => (self: FiberRefs.FiberRefs) => FiberRefs.FiberRefs,\n  <A>(self: FiberRefs.FiberRefs, fiberRef: FiberRef.FiberRef<A>) => FiberRefs.FiberRefs\n>(2, (self, fiberRef) => {\n  const locals = new Map(self.locals)\n  locals.delete(fiberRef)\n  return new FiberRefsImpl(locals)\n})\n\n/** @internal */\nexport const get = dual<\n  <A>(fiberRef: FiberRef.FiberRef<A>) => (self: FiberRefs.FiberRefs) => Option.Option<A>,\n  <A>(self: FiberRefs.FiberRefs, fiberRef: FiberRef.FiberRef<A>) => Option.Option<A>\n>(2, (self, fiberRef) => {\n  if (!self.locals.has(fiberRef)) {\n    return Option.none()\n  }\n  return Option.some(Arr.headNonEmpty(self.locals.get(fiberRef)!)[1])\n})\n\n/** @internal */\nexport const getOrDefault = dual<\n  <A>(fiberRef: FiberRef.FiberRef<A>) => (self: FiberRefs.FiberRefs) => A,\n  <A>(self: FiberRefs.FiberRefs, fiberRef: FiberRef.FiberRef<A>) => A\n>(2, (self, fiberRef) => pipe(get(self, fiberRef), Option.getOrElse(() => fiberRef.initial)))\n\n/** @internal */\nexport const updateAs = dual<\n  <A>(\n    options: {\n      readonly fiberId: FiberId.Single\n      readonly fiberRef: FiberRef.FiberRef<A>\n      readonly value: A\n    }\n  ) => (self: FiberRefs.FiberRefs) => FiberRefs.FiberRefs,\n  <A>(\n    self: FiberRefs.FiberRefs,\n    options: {\n      readonly fiberId: FiberId.Single\n      readonly fiberRef: FiberRef.FiberRef<A>\n      readonly value: A\n    }\n  ) => FiberRefs.FiberRefs\n>(2, <A>(self: FiberRefs.FiberRefs, { fiberId, fiberRef, value }: {\n  readonly fiberId: FiberId.Single\n  readonly fiberRef: FiberRef.FiberRef<A>\n  readonly value: A\n}) => {\n  if (self.locals.size === 0) {\n    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId, value] as const]]]))\n  }\n  const locals = new Map(self.locals)\n  unsafeUpdateAs(locals, fiberId, fiberRef, value)\n  return new FiberRefsImpl(locals)\n})\n\nconst unsafeUpdateAs = (\n  locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>,\n  fiberId: FiberId.Single,\n  fiberRef: FiberRef.FiberRef<any>,\n  value: any\n) => {\n  const oldStack: ReadonlyArray<readonly [FiberId.Single, any]> = locals.get(fiberRef) ?? []\n  let newStack: Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]> | undefined\n\n  if (Arr.isNonEmptyReadonlyArray(oldStack)) {\n    const [currentId, currentValue] = Arr.headNonEmpty(oldStack)\n    if (currentId[Equal.symbol](fiberId)) {\n      if (Equal.equals(currentValue, value)) {\n        return\n      } else {\n        newStack = [\n          [fiberId, value] as const,\n          ...oldStack.slice(1)\n        ]\n      }\n    } else {\n      newStack = [\n        [fiberId, value] as const,\n        ...oldStack\n      ]\n    }\n  } else {\n    newStack = [[fiberId, value] as const]\n  }\n\n  locals.set(fiberRef, newStack)\n}\n\n/** @internal */\nexport const updateManyAs = dual<\n  (\n    options: {\n      readonly forkAs?: FiberId.Single | undefined\n      readonly entries: Arr.NonEmptyReadonlyArray<\n        readonly [FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>]\n      >\n    }\n  ) => (self: FiberRefs.FiberRefs) => FiberRefs.FiberRefs,\n  (\n    self: FiberRefs.FiberRefs,\n    options: {\n      readonly forkAs?: FiberId.Single | undefined\n      readonly entries: Arr.NonEmptyReadonlyArray<\n        readonly [FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>]\n      >\n    }\n  ) => FiberRefs.FiberRefs\n>(2, (self: FiberRefs.FiberRefs, { entries, forkAs }: {\n  readonly forkAs?: FiberId.Single | undefined\n  readonly entries: Arr.NonEmptyReadonlyArray<\n    readonly [FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>]\n  >\n}) => {\n  if (self.locals.size === 0) {\n    return new FiberRefsImpl(new Map(entries))\n  }\n\n  const locals = new Map(self.locals)\n  if (forkAs !== undefined) {\n    unsafeForkAs(self, locals, forkAs)\n  }\n  entries.forEach(([fiberRef, values]) => {\n    if (values.length === 1) {\n      unsafeUpdateAs(locals, values[0][0], fiberRef, values[0][1])\n    } else {\n      values.forEach(([fiberId, value]) => {\n        unsafeUpdateAs(locals, fiberId, fiberRef, value)\n      })\n    }\n  })\n  return new FiberRefsImpl(locals)\n})\n","import type * as Effect from \"../Effect.js\"\nimport * as Effectable from \"../Effectable.js\"\nimport { dual } from \"../Function.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport * as Readable from \"../Readable.js\"\nimport type * as Ref from \"../Ref.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nexport const RefTypeId: Ref.RefTypeId = Symbol.for(\"effect/Ref\") as Ref.RefTypeId\n\n/** @internal */\nexport const refVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\nclass RefImpl<in out A> extends Effectable.Class<A> implements Ref.Ref<A> {\n  commit() {\n    return this.get\n  }\n  readonly [RefTypeId] = refVariance\n  readonly [Readable.TypeId]: Readable.TypeId = Readable.TypeId\n  constructor(readonly ref: MutableRef.MutableRef<A>) {\n    super()\n    this.get = core.sync(() => MutableRef.get(this.ref))\n  }\n  readonly get: Effect.Effect<A>\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B> {\n    return core.sync(() => {\n      const current = MutableRef.get(this.ref)\n      const [b, a] = f(current)\n      if ((current as unknown) !== (a as unknown)) {\n        MutableRef.set(a)(this.ref)\n      }\n      return b\n    })\n  }\n}\n\n/** @internal */\nexport const unsafeMake = <A>(value: A): Ref.Ref<A> => new RefImpl(MutableRef.make(value))\n\n/** @internal */\nexport const make = <A>(value: A): Effect.Effect<Ref.Ref<A>> => core.sync(() => unsafeMake(value))\n\n/** @internal */\nexport const get = <A>(self: Ref.Ref<A>) => self.get\n\n/** @internal */\nexport const set = dual<\n  <A>(value: A) => (self: Ref.Ref<A>) => Effect.Effect<void>,\n  <A>(self: Ref.Ref<A>, value: A) => Effect.Effect<void>\n>(2, <A>(self: Ref.Ref<A>, value: A) => self.modify((): [void, A] => [void 0, value]))\n\n/** @internal */\nexport const getAndSet = dual<\n  <A>(value: A) => (self: Ref.Ref<A>) => Effect.Effect<A>,\n  <A>(self: Ref.Ref<A>, value: A) => Effect.Effect<A>\n>(2, <A>(self: Ref.Ref<A>, value: A) => self.modify((a): [A, A] => [a, value]))\n\n/** @internal */\nexport const getAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: Ref.Ref<A>) => Effect.Effect<A>,\n  <A>(self: Ref.Ref<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, <A>(self: Ref.Ref<A>, f: (a: A) => A) => self.modify((a): [A, A] => [a, f(a)]))\n\n/** @internal */\nexport const getAndUpdateSome = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: Ref.Ref<A>) => Effect.Effect<A>,\n  <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>) =>\n  self.modify((value): [A, A] => {\n    const option = pf(value)\n    switch (option._tag) {\n      case \"None\": {\n        return [value, value]\n      }\n      case \"Some\": {\n        return [value, option.value]\n      }\n    }\n  }))\n\n/** @internal */\nexport const setAndGet = dual<\n  <A>(value: A) => (self: Ref.Ref<A>) => Effect.Effect<A>,\n  <A>(self: Ref.Ref<A>, value: A) => Effect.Effect<A>\n>(2, <A>(self: Ref.Ref<A>, value: A) => self.modify((): [A, A] => [value, value]))\n\n/** @internal */\nexport const modify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: Ref.Ref<A>) => Effect.Effect<B>,\n  <A, B>(self: Ref.Ref<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, (self, f) => self.modify(f))\n\n/** @internal */\nexport const modifySome = dual<\n  <B, A>(\n    fallback: B,\n    pf: (a: A) => Option.Option<readonly [B, A]>\n  ) => (self: Ref.Ref<A>) => Effect.Effect<B>,\n  <A, B>(\n    self: Ref.Ref<A>,\n    fallback: B,\n    pf: (a: A) => Option.Option<readonly [B, A]>\n  ) => Effect.Effect<B>\n>(3, (self, fallback, pf) =>\n  self.modify((value) => {\n    const option = pf(value)\n    switch (option._tag) {\n      case \"None\": {\n        return [fallback, value]\n      }\n      case \"Some\": {\n        return option.value\n      }\n    }\n  }))\n\n/** @internal */\nexport const update = dual<\n  <A>(f: (a: A) => A) => (self: Ref.Ref<A>) => Effect.Effect<void>,\n  <A>(self: Ref.Ref<A>, f: (a: A) => A) => Effect.Effect<void>\n>(2, <A>(self: Ref.Ref<A>, f: (a: A) => A) => self.modify((a): [void, A] => [void 0, f(a)]))\n\n/** @internal */\nexport const updateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: Ref.Ref<A>) => Effect.Effect<A>,\n  <A>(self: Ref.Ref<A>, f: (a: A) => A) => Effect.Effect<A>\n>(2, <A>(self: Ref.Ref<A>, f: (a: A) => A) =>\n  self.modify((a): [A, A] => {\n    const result = f(a)\n    return [result, result]\n  }))\n\n/** @internal */\nexport const updateSome = dual<\n  <A>(f: (a: A) => Option.Option<A>) => (self: Ref.Ref<A>) => Effect.Effect<void>,\n  <A>(self: Ref.Ref<A>, f: (a: A) => Option.Option<A>) => Effect.Effect<void>\n>(2, <A>(self: Ref.Ref<A>, f: (a: A) => Option.Option<A>) =>\n  self.modify(\n    (a): [void, A] => [\n      void 0,\n      Option.match(f(a), {\n        onNone: () => a,\n        onSome: (b) => b\n      })\n    ]\n  ))\n\n/** @internal */\nexport const updateSomeAndGet = dual<\n  <A>(pf: (a: A) => Option.Option<A>) => (self: Ref.Ref<A>) => Effect.Effect<A>,\n  <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>) => Effect.Effect<A>\n>(2, <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>) =>\n  self.modify((value): [A, A] => {\n    const option = pf(value)\n    switch (option._tag) {\n      case \"None\": {\n        return [value, value]\n      }\n      case \"Some\": {\n        return [option.value, option.value]\n      }\n    }\n  }))\n\n/** @internal */\nexport const unsafeGet = <A>(self: Ref.Ref<A>): A => MutableRef.get((self as RefImpl<A>).ref)\n","/**\n * @since 2.0.0\n */\n\nimport type { Effect } from \"./Effect.js\"\nimport type { RuntimeFiber } from \"./Fiber.js\"\nimport type { FiberRef } from \"./FiberRef.js\"\nimport { dual } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as core from \"./internal/core.js\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type Task = () => void\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Scheduler {\n  shouldYield(fiber: RuntimeFiber<unknown, unknown>): number | false\n  scheduleTask(task: Task, priority: number): void\n}\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport class PriorityBuckets<in out T = Task> {\n  /**\n   * @since 2.0.0\n   */\n  public buckets: Array<[number, Array<T>]> = []\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task: T, priority: number) {\n    const length = this.buckets.length\n    let bucket: [number, Array<T>] | undefined = undefined\n    let index = 0\n    for (; index < length; index++) {\n      if (this.buckets[index][0] <= priority) {\n        bucket = this.buckets[index]\n      } else {\n        break\n      }\n    }\n    if (bucket && bucket[0] === priority) {\n      bucket[1].push(task)\n    } else if (index === length) {\n      this.buckets.push([priority, [task]])\n    } else {\n      this.buckets.splice(index, 0, [priority, [task]])\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport class MixedScheduler implements Scheduler {\n  /**\n   * @since 2.0.0\n   */\n  running = false\n  /**\n   * @since 2.0.0\n   */\n  tasks = new PriorityBuckets()\n\n  constructor(\n    /**\n     * @since 2.0.0\n     */\n    readonly maxNextTickBeforeTimer: number\n  ) {}\n\n  /**\n   * @since 2.0.0\n   */\n  private starveInternal(depth: number) {\n    const tasks = this.tasks.buckets\n    this.tasks.buckets = []\n    for (const [_, toRun] of tasks) {\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]()\n      }\n    }\n    if (this.tasks.buckets.length === 0) {\n      this.running = false\n    } else {\n      this.starve(depth)\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  private starve(depth = 0) {\n    if (depth >= this.maxNextTickBeforeTimer) {\n      setTimeout(() => this.starveInternal(0), 0)\n    } else {\n      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1))\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  shouldYield(fiber: RuntimeFiber<unknown, unknown>): number | false {\n    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield)\n      ? fiber.getFiberRef(core.currentSchedulingPriority)\n      : false\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task: Task, priority: number) {\n    this.tasks.scheduleTask(task, priority)\n    if (!this.running) {\n      this.running = true\n      this.starve()\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category schedulers\n */\nexport const defaultScheduler: Scheduler = globalValue(\n  Symbol.for(\"effect/Scheduler/defaultScheduler\"),\n  () => new MixedScheduler(2048)\n)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport class SyncScheduler implements Scheduler {\n  /**\n   * @since 2.0.0\n   */\n  tasks = new PriorityBuckets()\n\n  /**\n   * @since 2.0.0\n   */\n  deferred = false\n\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task: Task, priority: number) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task, priority)\n    } else {\n      this.tasks.scheduleTask(task, priority)\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  shouldYield(fiber: RuntimeFiber<unknown, unknown>): number | false {\n    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield)\n      ? fiber.getFiberRef(core.currentSchedulingPriority)\n      : false\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  flush() {\n    while (this.tasks.buckets.length > 0) {\n      const tasks = this.tasks.buckets\n      this.tasks.buckets = []\n      for (const [_, toRun] of tasks) {\n        for (let i = 0; i < toRun.length; i++) {\n          toRun[i]()\n        }\n      }\n    }\n    this.deferred = true\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport class ControlledScheduler implements Scheduler {\n  /**\n   * @since 2.0.0\n   */\n  tasks = new PriorityBuckets()\n\n  /**\n   * @since 2.0.0\n   */\n  deferred = false\n\n  /**\n   * @since 2.0.0\n   */\n  scheduleTask(task: Task, priority: number) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task, priority)\n    } else {\n      this.tasks.scheduleTask(task, priority)\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  shouldYield(fiber: RuntimeFiber<unknown, unknown>): number | false {\n    return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield)\n      ? fiber.getFiberRef(core.currentSchedulingPriority)\n      : false\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  step() {\n    const tasks = this.tasks.buckets\n    this.tasks.buckets = []\n    for (const [_, toRun] of tasks) {\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]()\n      }\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const makeMatrix = (...record: Array<[number, Scheduler]>): Scheduler => {\n  const index = record.sort(([p0], [p1]) => p0 < p1 ? -1 : p0 > p1 ? 1 : 0)\n  return {\n    shouldYield(fiber) {\n      for (const scheduler of record) {\n        const priority = scheduler[1].shouldYield(fiber)\n        if (priority !== false) {\n          return priority\n        }\n      }\n      return false\n    },\n    scheduleTask(task, priority) {\n      let scheduler: Scheduler | undefined = undefined\n      for (const i of index) {\n        if (priority >= i[0]) {\n          scheduler = i[1]\n        } else {\n          return (scheduler ?? defaultScheduler).scheduleTask(task, priority)\n        }\n      }\n      return (scheduler ?? defaultScheduler).scheduleTask(task, priority)\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category utilities\n */\nexport const defaultShouldYield: Scheduler[\"shouldYield\"] = (fiber) => {\n  return fiber.currentOpCount > fiber.getFiberRef(core.currentMaxOpsBeforeYield)\n    ? fiber.getFiberRef(core.currentSchedulingPriority)\n    : false\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (\n  scheduleTask: Scheduler[\"scheduleTask\"],\n  shouldYield: Scheduler[\"shouldYield\"] = defaultShouldYield\n): Scheduler => ({\n  scheduleTask,\n  shouldYield\n})\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const makeBatched = (\n  callback: (runBatch: () => void) => void,\n  shouldYield: Scheduler[\"shouldYield\"] = defaultShouldYield\n) => {\n  let running = false\n  const tasks = new PriorityBuckets()\n  const starveInternal = () => {\n    const tasksToRun = tasks.buckets\n    tasks.buckets = []\n    for (const [_, toRun] of tasksToRun) {\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]()\n      }\n    }\n    if (tasks.buckets.length === 0) {\n      running = false\n    } else {\n      starve()\n    }\n  }\n\n  const starve = () => callback(starveInternal)\n\n  return make((task, priority) => {\n    tasks.scheduleTask(task, priority)\n    if (!running) {\n      running = true\n      starve()\n    }\n  }, shouldYield)\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const timer = (ms: number, shouldYield: Scheduler[\"shouldYield\"] = defaultShouldYield) =>\n  make((task) => setTimeout(task, ms), shouldYield)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const timerBatched = (ms: number, shouldYield: Scheduler[\"shouldYield\"] = defaultShouldYield) =>\n  makeBatched((task) => setTimeout(task, ms), shouldYield)\n\n/** @internal */\nexport const currentScheduler: FiberRef<Scheduler> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentScheduler\"),\n  () => core.fiberRefUnsafeMake(defaultScheduler)\n)\n\n/** @internal */\nexport const withScheduler = dual<\n  /** @internal */\n  (scheduler: Scheduler) => <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>,\n  /** @internal */\n  <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler) => Effect<A, E, R>\n>(2, (self, scheduler) => core.fiberRefLocally(self, currentScheduler, scheduler))\n","/**\n * @since 2.0.0\n */\nimport type * as FiberId from \"./FiberId.js\"\nimport type * as FiberRef from \"./FiberRef.js\"\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport * as internal from \"./internal/fiberRefs/patch.js\"\n\n/**\n * A `FiberRefsPatch` captures the changes in `FiberRef` values made by a single\n * fiber as a value. This allows fibers to apply the changes made by a workflow\n * without inheriting all the `FiberRef` values of the fiber that executed the\n * workflow.\n *\n * @since 2.0.0\n * @category models\n */\nexport type FiberRefsPatch = Empty | Add | Remove | Update | AndThen\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Empty {\n  readonly _tag: \"Empty\"\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Add {\n  readonly _tag: \"Add\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n  readonly value: unknown\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Remove {\n  readonly _tag: \"Remove\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Update {\n  readonly _tag: \"Update\"\n  readonly fiberRef: FiberRef.FiberRef<unknown>\n  readonly patch: unknown\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface AndThen {\n  readonly _tag: \"AndThen\"\n  readonly first: FiberRefsPatch\n  readonly second: FiberRefsPatch\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: FiberRefsPatch = internal.empty\n\n/**\n * Constructs a patch that describes the changes between the specified\n * collections of `FiberRef`\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch = internal.diff\n\n/**\n * Combines this patch and the specified patch to create a new patch that\n * describes applying the changes from this patch and the specified patch\n * sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const combine: {\n  /**\n   * Combines this patch and the specified patch to create a new patch that\n   * describes applying the changes from this patch and the specified patch\n   * sequentially.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch\n  /**\n   * Combines this patch and the specified patch to create a new patch that\n   * describes applying the changes from this patch and the specified patch\n   * sequentially.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch\n} = internal.combine\n\n/**\n * Applies the changes described by this patch to the specified collection\n * of `FiberRef` values.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const patch: {\n  /**\n   * Applies the changes described by this patch to the specified collection\n   * of `FiberRef` values.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs\n  /**\n   * Applies the changes described by this patch to the specified collection\n   * of `FiberRef` values.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  (\n   self: FiberRefsPatch,\n   fiberId: FiberId.Runtime,\n   oldValue: FiberRefs.FiberRefs\n  ): FiberRefs.FiberRefs\n} = internal.patch\n","/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/ref.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Readable from \"./Readable.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const RefTypeId: unique symbol = internal.RefTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type RefTypeId = typeof RefTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Ref<in out A> extends Ref.Variance<A>, Effect.Effect<A>, Readable.Readable<A> {\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RefUnify<this>\n  readonly [Unify.ignoreSymbol]?: RefUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface RefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Ref?: () => Extract<A[Unify.typeSymbol], Ref<any>>\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface RefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport declare namespace Ref {\n  /**\n   * @since 2.0.0\n   */\n  export interface Variance<in out A> {\n    readonly [RefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(value: A) => Effect.Effect<Ref<A>> = internal.make\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A>(self: Ref<A>) => Effect.Effect<A> = internal.get\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, value: A): Effect.Effect<A>\n} = internal.getAndSet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<A>\n} = internal.getAndUpdate\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = internal.getAndUpdateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modify: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: Ref<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(self: Ref<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(self: Ref<A>, fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): Effect.Effect<B>\n} = internal.modifySome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, value: A): Effect.Effect<void>\n} = internal.set\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, value: A): Effect.Effect<A>\n} = internal.setAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<void>\n} = internal.update\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, f: (a: A) => A): Effect.Effect<A>\n} = internal.updateAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>\n} = internal.updateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = internal.updateSomeAndGet\n\n/**\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: <A>(value: A) => Ref<A> = internal.unsafeMake\n","/**\n * @since 2.0.0\n */\nimport type * as Arr from \"./Array.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type * as FiberRef from \"./FiberRef.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport * as internal from \"./internal/fiberRefs.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FiberRefsSym: unique symbol = internal.FiberRefsSym\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FiberRefsSym = typeof FiberRefsSym\n\n/**\n * `FiberRefs` is a data type that represents a collection of `FiberRef` values.\n *\n * This allows safely propagating `FiberRef` values across fiber boundaries, for\n * example between an asynchronous producer and consumer.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface FiberRefs extends Pipeable {\n  readonly [FiberRefsSym]: FiberRefsSym\n  readonly locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>\n}\n\nconst delete_: {\n  <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => FiberRefs\n  <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): FiberRefs\n} = internal.delete_\n\nexport {\n  /**\n   * Deletes the specified `FiberRef` from the `FibterRefs`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  delete_ as delete\n}\n\n/**\n * Returns a set of each `FiberRef` in this collection.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>> = internal.fiberRefs\n\n/**\n * Forks this collection of fiber refs as the specified child fiber id. This\n * will potentially modify the value of the fiber refs, as determined by the\n * individual fiber refs that make up the collection.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const forkAs: {\n  /**\n   * Forks this collection of fiber refs as the specified child fiber id. This\n   * will potentially modify the value of the fiber refs, as determined by the\n   * individual fiber refs that make up the collection.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (childId: FiberId.Single): (self: FiberRefs) => FiberRefs\n  /**\n   * Forks this collection of fiber refs as the specified child fiber id. This\n   * will potentially modify the value of the fiber refs, as determined by the\n   * individual fiber refs that make up the collection.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: FiberRefs, childId: FiberId.Single): FiberRefs\n} = internal.forkAs\n\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or `None` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get: {\n  /**\n   * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n   * values if it exists or `None` otherwise.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>\n  /**\n   * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n   * values if it exists or `None` otherwise.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>\n} = internal.get\n\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or the `initial` value of the `FiberRef` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOrDefault: {\n  /**\n   * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n   * values if it exists or the `initial` value of the `FiberRef` otherwise.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A\n  /**\n   * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n   * values if it exists or the `initial` value of the `FiberRef` otherwise.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A\n} = internal.getOrDefault\n\n/**\n * Joins this collection of fiber refs to the specified collection, as the\n * specified fiber id. This will perform diffing and merging to ensure\n * preservation of maximum information from both child and parent refs.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const joinAs: {\n  /**\n   * Joins this collection of fiber refs to the specified collection, as the\n   * specified fiber id. This will perform diffing and merging to ensure\n   * preservation of maximum information from both child and parent refs.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs\n  /**\n   * Joins this collection of fiber refs to the specified collection, as the\n   * specified fiber id. This will perform diffing and merging to ensure\n   * preservation of maximum information from both child and parent refs.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs\n} = internal.joinAs\n\n/**\n * Set each ref to either its value or its default.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const setAll: (self: FiberRefs) => Effect.Effect<void> = internal.setAll\n\n/**\n * Updates the value of the specified `FiberRef` using the provided `FiberId`\n *\n * @since 2.0.0\n * @category utils\n */\nexport const updateAs: {\n  /**\n   * Updates the value of the specified `FiberRef` using the provided `FiberId`\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(\n    options: {\n      readonly fiberId: FiberId.Single\n      readonly fiberRef: FiberRef.FiberRef<A>\n      readonly value: A\n    }\n  ): (self: FiberRefs) => FiberRefs\n  /**\n   * Updates the value of the specified `FiberRef` using the provided `FiberId`\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(\n    self: FiberRefs,\n    options: {\n      readonly fiberId: FiberId.Single\n      readonly fiberRef: FiberRef.FiberRef<A>\n      readonly value: A\n    }\n  ): FiberRefs\n} = internal.updateAs\n\n/**\n * Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`\n *\n * @since 2.0.0\n * @category utils\n */\nexport const updateManyAs: {\n  /**\n   * Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (\n    options: {\n      readonly forkAs?: FiberId.Single | undefined\n      readonly entries: readonly [\n        readonly [\n          FiberRef.FiberRef<any>,\n          readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]\n        ],\n        ...Array<\n          readonly [\n            FiberRef.FiberRef<any>,\n            readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]\n          ]\n        >\n      ]\n    }\n  ): (self: FiberRefs) => FiberRefs\n  /**\n   * Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (\n    self: FiberRefs,\n    options: {\n      readonly forkAs?: FiberId.Single | undefined\n      readonly entries: readonly [\n        readonly [\n          FiberRef.FiberRef<any>,\n          readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]\n        ],\n        ...Array<\n          readonly [\n            FiberRef.FiberRef<any>,\n            readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]\n          ]\n        >\n      ]\n    }\n  ): FiberRefs\n} = internal.updateManyAs\n\n/**\n * Note: it will not copy the provided Map, make sure to provide a fresh one.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: (\n  fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>\n) => FiberRefs = internal.unsafeMake\n\n/**\n * The empty collection of `FiberRef` values.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const empty: () => FiberRefs = internal.empty\n","/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport * as internal from \"./internal/fiberStatus.js\"\nimport type * as RuntimeFlags from \"./RuntimeFlags.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FiberStatusTypeId: unique symbol = internal.FiberStatusTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FiberStatusTypeId = typeof FiberStatusTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type FiberStatus = Done | Running | Suspended\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Done extends Equal.Equal {\n  readonly _tag: \"Done\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Running extends Equal.Equal {\n  readonly _tag: \"Running\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Suspended extends Equal.Equal {\n  readonly _tag: \"Suspended\"\n  readonly [FiberStatusTypeId]: FiberStatusTypeId\n  readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n  readonly blockingOn: FiberId.FiberId\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const done: FiberStatus = internal.done\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const running: (runtimeFlags: RuntimeFlags.RuntimeFlags) => FiberStatus = internal.running\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const suspended: (runtimeFlags: RuntimeFlags.RuntimeFlags, blockingOn: FiberId.FiberId) => FiberStatus =\n  internal.suspended\n\n/**\n * Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isFiberStatus: (u: unknown) => u is FiberStatus = internal.isFiberStatus\n\n/**\n * Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isDone: (self: FiberStatus) => self is Done = internal.isDone\n\n/**\n * Returns `true` if the specified `FiberStatus` is `Running`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRunning: (self: FiberStatus) => self is Running = internal.isRunning\n\n/**\n * Returns `true` if the specified `FiberStatus` is `Suspended`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isSuspended: (self: FiberStatus) => self is Suspended = internal.isSuspended\n","/**\n * @since 2.0.0\n */\nimport type { LazyArg } from \"./Function.js\"\nimport * as internal from \"./internal/executionStrategy.js\"\n\n/**\n * Describes a strategy for evaluating multiple effects, potentially in\n * parallel.\n *\n * There are 3 possible execution strategies: `Sequential`, `Parallel`,\n * `ParallelN`.\n *\n * @since 2.0.0\n * @category models\n */\nexport type ExecutionStrategy = Sequential | Parallel | ParallelN\n\n/**\n * Execute effects sequentially.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Sequential {\n  readonly _tag: \"Sequential\"\n}\n\n/**\n * Execute effects in parallel.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Parallel {\n  readonly _tag: \"Parallel\"\n}\n\n/**\n * Execute effects in parallel, up to the specified number of concurrent fibers.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface ParallelN {\n  readonly _tag: \"ParallelN\"\n  readonly parallelism: number\n}\n\n/**\n * Execute effects sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sequential: ExecutionStrategy = internal.sequential\n\n/**\n * Execute effects in parallel.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const parallel: ExecutionStrategy = internal.parallel\n\n/**\n * Execute effects in parallel, up to the specified number of concurrent fibers.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const parallelN: (parallelism: number) => ExecutionStrategy = internal.parallelN\n\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isSequential: (self: ExecutionStrategy) => self is Sequential = internal.isSequential\n\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isParallel: (self: ExecutionStrategy) => self is Parallel = internal.isParallel\n\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isParallelN: (self: ExecutionStrategy) => self is ParallelN = internal.isParallelN\n\n/**\n * Folds over the specified `ExecutionStrategy` using the provided case\n * functions.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds over the specified `ExecutionStrategy` using the provided case\n   * functions.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(\n   options: {\n     readonly onSequential: LazyArg<A>\n     readonly onParallel: LazyArg<A>\n     readonly onParallelN: (n: number) => A\n   }\n  ): (self: ExecutionStrategy) => A\n  /**\n   * Folds over the specified `ExecutionStrategy` using the provided case\n   * functions.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(\n   self: ExecutionStrategy,\n   options: {\n     readonly onSequential: LazyArg<A>\n     readonly onParallel: LazyArg<A>\n     readonly onParallelN: (n: number) => A\n   }\n  ): A\n} = internal.match\n","/**\n * A lightweight alternative to the `Effect` data type, with a subset of the functionality.\n *\n * @since 3.4.0\n * @experimental\n */\nimport * as Arr from \"./Array.js\"\nimport type { Channel } from \"./Channel.js\"\nimport * as Context from \"./Context.js\"\nimport type { Effect, EffectUnify, EffectUnifyIgnore } from \"./Effect.js\"\nimport * as Effectable from \"./Effectable.js\"\nimport * as Either from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constTrue, constVoid, dual, identity } from \"./Function.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as Hash from \"./Hash.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport { format, NodeInspectSymbol, toStringUnknown } from \"./Inspectable.js\"\nimport * as InternalContext from \"./internal/context.js\"\nimport * as doNotation from \"./internal/doNotation.js\"\nimport { StructuralPrototype } from \"./internal/effectable.js\"\nimport * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport { hasProperty, isIterable, isTagged } from \"./Predicate.js\"\nimport type { Sink } from \"./Sink.js\"\nimport type { Stream } from \"./Stream.js\"\nimport type { Concurrency, Covariant, Equals, NoExcessProperties, NotFunction, Simplify } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport { SingleShotGen, YieldWrap, yieldWrapGet } from \"./Utils.js\"\n\n/**\n * @since 3.4.0\n * @experimental\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Micro\")\n\n/**\n * @since 3.4.0\n * @experimental\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 3.4.0\n * @experimental\n * @category MicroExit\n */\nexport const MicroExitTypeId: unique symbol = Symbol.for(\n  \"effect/Micro/MicroExit\"\n)\n\n/**\n * @since 3.4.0\n * @experimental\n * @category MicroExit\n */\nexport type MicroExitTypeId = typeof TypeId\n\n/**\n * A lightweight alternative to the `Effect` data type, with a subset of the functionality.\n *\n * @since 3.4.0\n * @experimental\n * @category models\n */\nexport interface Micro<out A, out E = never, out R = never> extends Effect<A, E, R> {\n  readonly [TypeId]: Micro.Variance<A, E, R>\n  [Symbol.iterator](): MicroIterator<Micro<A, E, R>>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: MicroUnify<this>\n  [Unify.ignoreSymbol]?: MicroUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.4.3\n */\nexport interface MicroUnify<A extends { [Unify.typeSymbol]?: any }> extends EffectUnify<A> {\n  Micro?: () => A[Unify.typeSymbol] extends Micro<infer A0, infer E0, infer R0> | infer _ ? Micro<A0, E0, R0> : never\n}\n\n/**\n * @category models\n * @since 3.4.3\n */\nexport interface MicroUnifyIgnore extends EffectUnifyIgnore {\n  Effect?: true\n}\n/**\n * @category type lambdas\n * @since 3.4.1\n */\nexport interface MicroTypeLambda extends TypeLambda {\n  readonly type: Micro<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}\n\n/**\n * @since 3.4.0\n * @experimental\n */\nexport declare namespace Micro {\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export interface Variance<A, E, R> {\n    _A: Covariant<A>\n    _E: Covariant<E>\n    _R: Covariant<R>\n  }\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type Success<T> = T extends Micro<infer _A, infer _E, infer _R> ? _A : never\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type Error<T> = T extends Micro<infer _A, infer _E, infer _R> ? _E : never\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type Context<T> = T extends Micro<infer _A, infer _E, infer _R> ? _R : never\n}\n\n/**\n * @since 3.4.0\n * @experimental\n * @category guards\n */\nexport const isMicro = (u: unknown): u is Micro<any, any, any> => typeof u === \"object\" && u !== null && TypeId in u\n\n/**\n * @since 3.4.0\n * @experimental\n * @category models\n */\nexport interface MicroIterator<T extends Micro<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<YieldWrap<T>, Micro.Success<T>>\n}\n\n// ----------------------------------------------------------------------------\n// MicroCause\n// ----------------------------------------------------------------------------\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const MicroCauseTypeId = Symbol.for(\"effect/Micro/MicroCause\")\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport type MicroCauseTypeId = typeof MicroCauseTypeId\n\n/**\n * A `MicroCause` is a data type that represents the different ways a `Micro` can fail.\n *\n * **Details**\n *\n * `MicroCause` comes in three forms:\n *\n * - `Die`: Indicates an unforeseen defect that wasn't planned for in the system's logic.\n * - `Fail`: Covers anticipated errors that are recognized and typically handled within the application.\n * - `Interrupt`: Signifies an operation that has been purposefully stopped.\n *\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport type MicroCause<E> =\n  | MicroCause.Die\n  | MicroCause.Fail<E>\n  | MicroCause.Interrupt\n\n/**\n * @since 3.6.6\n * @experimental\n * @category guards\n */\nexport const isMicroCause = (self: unknown): self is MicroCause<unknown> => hasProperty(self, MicroCauseTypeId)\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport declare namespace MicroCause {\n  /**\n   * @since 3.4.6\n   * @experimental\n   */\n  export type Error<T> = T extends MicroCause.Fail<infer E> ? E : never\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export interface Proto<Tag extends string, E> extends Pipeable, globalThis.Error {\n    readonly [MicroCauseTypeId]: {\n      _E: Covariant<E>\n    }\n    readonly _tag: Tag\n    readonly traces: ReadonlyArray<string>\n  }\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroCause\n   */\n  export interface Die extends Proto<\"Die\", never> {\n    readonly defect: unknown\n  }\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroCause\n   */\n  export interface Fail<E> extends Proto<\"Fail\", E> {\n    readonly error: E\n  }\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroCause\n   */\n  export interface Interrupt extends Proto<\"Interrupt\", never> {}\n}\n\nconst microCauseVariance = {\n  _E: identity\n}\n\nabstract class MicroCauseImpl<Tag extends string, E> extends globalThis.Error implements MicroCause.Proto<Tag, E> {\n  readonly [MicroCauseTypeId]: {\n    _E: Covariant<E>\n  }\n  constructor(\n    readonly _tag: Tag,\n    originalError: unknown,\n    readonly traces: ReadonlyArray<string>\n  ) {\n    const causeName = `MicroCause.${_tag}`\n    let name: string\n    let message: string\n    let stack: string\n    if (originalError instanceof globalThis.Error) {\n      name = `(${causeName}) ${originalError.name}`\n      message = originalError.message as string\n      const messageLines = message.split(\"\\n\").length\n      stack = originalError.stack\n        ? `(${causeName}) ${\n          originalError.stack\n            .split(\"\\n\")\n            .slice(0, messageLines + 3)\n            .join(\"\\n\")\n        }`\n        : `${name}: ${message}`\n    } else {\n      name = causeName\n      message = toStringUnknown(originalError, 0)\n      stack = `${name}: ${message}`\n    }\n    if (traces.length > 0) {\n      stack += `\\n    ${traces.join(\"\\n    \")}`\n    }\n    super(message)\n    this[MicroCauseTypeId] = microCauseVariance\n    this.name = name\n    this.stack = stack\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n  toString() {\n    return this.stack\n  }\n  [NodeInspectSymbol]() {\n    return this.stack\n  }\n}\n\nclass Fail<E> extends MicroCauseImpl<\"Fail\", E> implements MicroCause.Fail<E> {\n  constructor(\n    readonly error: E,\n    traces: ReadonlyArray<string> = []\n  ) {\n    super(\"Fail\", error, traces)\n  }\n}\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeFail = <E>(\n  error: E,\n  traces: ReadonlyArray<string> = []\n): MicroCause<E> => new Fail(error, traces)\n\nclass Die extends MicroCauseImpl<\"Die\", never> implements MicroCause.Die {\n  constructor(\n    readonly defect: unknown,\n    traces: ReadonlyArray<string> = []\n  ) {\n    super(\"Die\", defect, traces)\n  }\n}\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeDie = (\n  defect: unknown,\n  traces: ReadonlyArray<string> = []\n): MicroCause<never> => new Die(defect, traces)\n\nclass Interrupt extends MicroCauseImpl<\"Interrupt\", never> implements MicroCause.Interrupt {\n  constructor(traces: ReadonlyArray<string> = []) {\n    super(\"Interrupt\", \"interrupted\", traces)\n  }\n}\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeInterrupt = (\n  traces: ReadonlyArray<string> = []\n): MicroCause<never> => new Interrupt(traces)\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeIsFail = <E>(\n  self: MicroCause<E>\n): self is MicroCause.Fail<E> => self._tag === \"Fail\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeIsDie = <E>(self: MicroCause<E>): self is MicroCause.Die => self._tag === \"Die\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeIsInterrupt = <E>(\n  self: MicroCause<E>\n): self is MicroCause.Interrupt => self._tag === \"Interrupt\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeSquash = <E>(self: MicroCause<E>): unknown =>\n  self._tag === \"Fail\" ? self.error : self._tag === \"Die\" ? self.defect : self\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroCause\n */\nexport const causeWithTrace: {\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroCause\n   */\n  (trace: string): <E>(self: MicroCause<E>) => MicroCause<E>\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroCause\n   */\n  <E>(self: MicroCause<E>, trace: string): MicroCause<E>\n} = dual(2, <E>(self: MicroCause<E>, trace: string): MicroCause<E> => {\n  const traces = [...self.traces, trace]\n  switch (self._tag) {\n    case \"Die\":\n      return causeDie(self.defect, traces)\n    case \"Interrupt\":\n      return causeInterrupt(traces)\n    case \"Fail\":\n      return causeFail(self.error, traces)\n  }\n})\n\n// ----------------------------------------------------------------------------\n// MicroFiber\n// ----------------------------------------------------------------------------\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport const MicroFiberTypeId = Symbol.for(\"effect/Micro/MicroFiber\")\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport type MicroFiberTypeId = typeof MicroFiberTypeId\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport interface MicroFiber<out A, out E = never> {\n  readonly [MicroFiberTypeId]: MicroFiber.Variance<A, E>\n\n  readonly currentOpCount: number\n  readonly getRef: <I, A>(ref: Context.Reference<I, A>) => A\n  readonly context: Context.Context<never>\n  readonly addObserver: (cb: (exit: MicroExit<A, E>) => void) => () => void\n  readonly unsafeInterrupt: () => void\n  readonly unsafePoll: () => MicroExit<A, E> | undefined\n}\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport declare namespace MicroFiber {\n  /**\n   * @since 3.11.0\n   * @experimental\n   * @category MicroFiber\n   */\n  export interface Variance<out A, out E = never> {\n    readonly _A: Covariant<A>\n    readonly _E: Covariant<E>\n  }\n}\n\nconst fiberVariance = {\n  _A: identity,\n  _E: identity\n}\n\nclass MicroFiberImpl<in out A = any, in out E = any> implements MicroFiber<A, E> {\n  readonly [MicroFiberTypeId]: MicroFiber.Variance<A, E>\n\n  readonly _stack: Array<Primitive> = []\n  readonly _observers: Array<(exit: MicroExit<A, E>) => void> = []\n  _exit: MicroExit<A, E> | undefined\n  public _children: Set<MicroFiberImpl<any, any>> | undefined\n\n  public currentOpCount = 0\n\n  constructor(\n    public context: Context.Context<never>,\n    public interruptible = true\n  ) {\n    this[MicroFiberTypeId] = fiberVariance\n  }\n\n  getRef<I, A>(ref: Context.Reference<I, A>): A {\n    return InternalContext.unsafeGetReference(this.context, ref)\n  }\n\n  addObserver(cb: (exit: MicroExit<A, E>) => void): () => void {\n    if (this._exit) {\n      cb(this._exit)\n      return constVoid\n    }\n    this._observers.push(cb)\n    return () => {\n      const index = this._observers.indexOf(cb)\n      if (index >= 0) {\n        this._observers.splice(index, 1)\n      }\n    }\n  }\n\n  _interrupted = false\n  unsafeInterrupt(): void {\n    if (this._exit) {\n      return\n    }\n    this._interrupted = true\n    if (this.interruptible) {\n      this.evaluate(exitInterrupt as any)\n    }\n  }\n\n  unsafePoll(): MicroExit<A, E> | undefined {\n    return this._exit\n  }\n\n  evaluate(effect: Primitive): void {\n    if (this._exit) {\n      return\n    } else if (this._yielded !== undefined) {\n      const yielded = this._yielded as () => void\n      this._yielded = undefined\n      yielded()\n    }\n    const exit = this.runLoop(effect)\n    if (exit === Yield) {\n      return\n    }\n\n    // the interruptChildren middlware is added in Micro.fork, so it can be\n    // tree-shaken if not used\n    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this)\n    if (interruptChildren !== undefined) {\n      return this.evaluate(flatMap(interruptChildren, () => exit) as any)\n    }\n\n    this._exit = exit\n    for (let i = 0; i < this._observers.length; i++) {\n      this._observers[i](exit)\n    }\n    this._observers.length = 0\n  }\n\n  runLoop(effect: Primitive): MicroExit<A, E> | Yield {\n    let yielding = false\n    let current: Primitive | Yield = effect\n    this.currentOpCount = 0\n    try {\n      while (true) {\n        this.currentOpCount++\n        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this as any)) {\n          yielding = true\n          const prev = current\n          current = flatMap(yieldNow, () => prev as any) as any\n        }\n        current = (current as any)[evaluate](this)\n        if (current === Yield) {\n          const yielded = this._yielded!\n          if (MicroExitTypeId in yielded) {\n            this._yielded = undefined\n            return yielded\n          }\n          return Yield\n        }\n      }\n    } catch (error) {\n      if (!hasProperty(current, evaluate)) {\n        return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`)\n      }\n      return exitDie(error)\n    }\n  }\n\n  getCont<S extends successCont | failureCont>(\n    symbol: S\n  ): Primitive & Record<S, (value: any, fiber: MicroFiberImpl) => Primitive> | undefined {\n    while (true) {\n      const op = this._stack.pop()\n      if (!op) return undefined\n      const cont = op[ensureCont] && op[ensureCont](this)\n      if (cont) return { [symbol]: cont } as any\n      if (op[symbol]) return op as any\n    }\n  }\n\n  // cancel the yielded operation, or for the yielded exit value\n  _yielded: MicroExit<any, any> | (() => void) | undefined = undefined\n  yieldWith(value: MicroExit<any, any> | (() => void)): Yield {\n    this._yielded = value\n    return Yield\n  }\n\n  children(): Set<MicroFiber<any, any>> {\n    return this._children ??= new Set()\n  }\n}\n\nconst fiberMiddleware = globalValue(\"effect/Micro/fiberMiddleware\", () => ({\n  interruptChildren: undefined as ((fiber: MicroFiberImpl) => Micro<void> | undefined) | undefined\n}))\n\nconst fiberInterruptChildren = (fiber: MicroFiberImpl) => {\n  if (fiber._children === undefined || fiber._children.size === 0) {\n    return undefined\n  }\n  return fiberInterruptAll(fiber._children)\n}\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport const fiberAwait = <A, E>(self: MicroFiber<A, E>): Micro<MicroExit<A, E>> =>\n  async((resume) => sync(self.addObserver((exit) => resume(succeed(exit)))))\n\n/**\n * @since 3.11.2\n * @experimental\n * @category MicroFiber\n */\nexport const fiberJoin = <A, E>(self: MicroFiber<A, E>): Micro<A, E> => flatten(fiberAwait(self))\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport const fiberInterrupt = <A, E>(self: MicroFiber<A, E>): Micro<void> =>\n  suspend(() => {\n    self.unsafeInterrupt()\n    return asVoid(fiberAwait(self))\n  })\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroFiber\n */\nexport const fiberInterruptAll = <A extends Iterable<MicroFiber<any, any>>>(fibers: A): Micro<void> =>\n  suspend(() => {\n    for (const fiber of fibers) fiber.unsafeInterrupt()\n    const iter = fibers[Symbol.iterator]()\n    const wait: Micro<void> = suspend(() => {\n      let result = iter.next()\n      while (!result.done) {\n        if (result.value.unsafePoll()) {\n          result = iter.next()\n          continue\n        }\n        const fiber = result.value\n        return async((resume) => {\n          fiber.addObserver((_) => {\n            resume(wait)\n          })\n        })\n      }\n      return exitVoid\n    })\n    return wait\n  })\n\nconst identifier = Symbol.for(\"effect/Micro/identifier\")\ntype identifier = typeof identifier\n\nconst args = Symbol.for(\"effect/Micro/args\")\ntype args = typeof args\n\nconst evaluate = Symbol.for(\"effect/Micro/evaluate\")\ntype evaluate = typeof evaluate\n\nconst successCont = Symbol.for(\"effect/Micro/successCont\")\ntype successCont = typeof successCont\n\nconst failureCont = Symbol.for(\"effect/Micro/failureCont\")\ntype failureCont = typeof failureCont\n\nconst ensureCont = Symbol.for(\"effect/Micro/ensureCont\")\ntype ensureCont = typeof ensureCont\n\nconst Yield = Symbol.for(\"effect/Micro/Yield\")\ntype Yield = typeof Yield\n\ninterface Primitive {\n  readonly [identifier]: string\n  readonly [successCont]: ((value: unknown, fiber: MicroFiberImpl) => Primitive | Yield) | undefined\n  readonly [failureCont]:\n    | ((cause: MicroCause<unknown>, fiber: MicroFiberImpl) => Primitive | Yield)\n    | undefined\n  readonly [ensureCont]:\n    | ((fiber: MicroFiberImpl) =>\n      | ((value: unknown, fiber: MicroFiberImpl) => Primitive | Yield)\n      | undefined)\n    | undefined\n  [evaluate](fiber: MicroFiberImpl): Primitive | Yield\n}\n\nconst microVariance = {\n  _A: identity,\n  _E: identity,\n  _R: identity\n}\n\nconst MicroProto = {\n  ...Effectable.EffectPrototype,\n  _op: \"Micro\",\n  [TypeId]: microVariance,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  [Symbol.iterator]() {\n    return new SingleShotGen(new YieldWrap(this)) as any\n  },\n  toJSON(this: Primitive) {\n    return {\n      _id: \"Micro\",\n      op: this[identifier],\n      ...(args in this ? { args: this[args] } : undefined)\n    }\n  },\n  toString() {\n    return format(this)\n  },\n  [NodeInspectSymbol]() {\n    return format(this)\n  }\n}\n\nfunction defaultEvaluate(_fiber: MicroFiberImpl): Primitive | Yield {\n  return exitDie(`Micro.evaluate: Not implemented`) as any\n}\n\nconst makePrimitiveProto = <Op extends string>(options: {\n  readonly op: Op\n  readonly eval?: (fiber: MicroFiberImpl) => Primitive | Micro<any, any, any> | Yield\n  readonly contA?: (this: Primitive, value: any, fiber: MicroFiberImpl) => Primitive | Micro<any, any, any> | Yield\n  readonly contE?: (\n    this: Primitive,\n    cause: MicroCause<any>,\n    fiber: MicroFiberImpl\n  ) => Primitive | Micro<any, any, any> | Yield\n  readonly ensure?: (this: Primitive, fiber: MicroFiberImpl) => void | ((value: any, fiber: MicroFiberImpl) => void)\n}): Primitive => ({\n  ...MicroProto,\n  [identifier]: options.op,\n  [evaluate]: options.eval ?? defaultEvaluate,\n  [successCont]: options.contA,\n  [failureCont]: options.contE,\n  [ensureCont]: options.ensure\n} as any)\n\nconst makePrimitive = <Fn extends (...args: Array<any>) => any, Single extends boolean = true>(options: {\n  readonly op: string\n  readonly single?: Single\n  readonly eval?: (\n    this: Primitive & { readonly [args]: Single extends true ? Parameters<Fn>[0] : Parameters<Fn> },\n    fiber: MicroFiberImpl\n  ) => Primitive | Micro<any, any, any> | Yield\n  readonly contA?: (\n    this: Primitive & { readonly [args]: Single extends true ? Parameters<Fn>[0] : Parameters<Fn> },\n    value: any,\n    fiber: MicroFiberImpl\n  ) => Primitive | Micro<any, any, any> | Yield\n  readonly contE?: (\n    this: Primitive & { readonly [args]: Single extends true ? Parameters<Fn>[0] : Parameters<Fn> },\n    cause: MicroCause<any>,\n    fiber: MicroFiberImpl\n  ) => Primitive | Micro<any, any, any> | Yield\n  readonly ensure?: (\n    this: Primitive & { readonly [args]: Single extends true ? Parameters<Fn>[0] : Parameters<Fn> },\n    fiber: MicroFiberImpl\n  ) => void | ((value: any, fiber: MicroFiberImpl) => void)\n}): Fn => {\n  const Proto = makePrimitiveProto(options as any)\n  return function() {\n    const self = Object.create(Proto)\n    self[args] = options.single === false ? arguments : arguments[0]\n    return self\n  } as Fn\n}\n\nconst makeExit = <Fn extends (...args: Array<any>) => any, Prop extends string>(options: {\n  readonly op: \"Success\" | \"Failure\"\n  readonly prop: Prop\n  readonly eval: (\n    this:\n      & MicroExit<unknown, unknown>\n      & { [args]: Parameters<Fn>[0] },\n    fiber: MicroFiberImpl<unknown, unknown>\n  ) => Primitive | Yield\n}): Fn => {\n  const Proto = {\n    ...makePrimitiveProto(options),\n    [MicroExitTypeId]: MicroExitTypeId,\n    _tag: options.op,\n    get [options.prop](): any {\n      return (this as any)[args]\n    },\n    toJSON(this: any) {\n      return {\n        _id: \"MicroExit\",\n        _tag: options.op,\n        [options.prop]: this[args]\n      }\n    },\n    [Equal.symbol](this: any, that: any): boolean {\n      return isMicroExit(that) && that._tag === options.op &&\n        Equal.equals(this[args], (that as any)[args])\n    },\n    [Hash.symbol](this: any): number {\n      return Hash.cached(this, Hash.combine(Hash.string(options.op))(Hash.hash(this[args])))\n    }\n  }\n  return function(value: unknown) {\n    const self = Object.create(Proto)\n    self[args] = value\n    self[successCont] = undefined\n    self[failureCont] = undefined\n    self[ensureCont] = undefined\n    return self\n  } as Fn\n}\n\n/**\n * Creates a `Micro` effect that will succeed with the specified constant value.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const succeed: <A>(value: A) => Micro<A> = makeExit({\n  op: \"Success\",\n  prop: \"value\",\n  eval(fiber) {\n    const cont = fiber.getCont(successCont)\n    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this)\n  }\n})\n\n/**\n * Creates a `Micro` effect that will fail with the specified `MicroCause`.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */\nexport const failCause: <E>(cause: MicroCause<E>) => Micro<never, E> = makeExit({\n  op: \"Failure\",\n  prop: \"cause\",\n  eval(fiber) {\n    let cont = fiber.getCont(failureCont)\n    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {\n      cont = fiber.getCont(failureCont)\n    }\n    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this)\n  }\n})\n\n/**\n * Creates a `Micro` effect that fails with the given error.\n *\n * This results in a `Fail` variant of the `MicroCause` type, where the error is\n * tracked at the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const fail = <E>(error: E): Micro<never, E> => failCause(causeFail(error))\n\n/**\n * Creates a `Micro` effect that succeeds with a lazily evaluated value.\n *\n * If the evaluation of the value throws an error, the effect will fail with a\n * `Die` variant of the `MicroCause` type.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const sync: <A>(evaluate: LazyArg<A>) => Micro<A> = makePrimitive({\n  op: \"Sync\",\n  eval(fiber): Primitive | Yield {\n    const value = this[args]()\n    const cont = fiber.getCont(successCont)\n    return cont ? cont[successCont](value, fiber) : fiber.yieldWith(exitSucceed(value))\n  }\n})\n\n/**\n * Lazily creates a `Micro` effect from the given side-effect.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R> = makePrimitive({\n  op: \"Suspend\",\n  eval(_fiber) {\n    return this[args]()\n  }\n})\n\n/**\n * Pause the execution of the current `Micro` effect, and resume it on the next\n * scheduler tick.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const yieldNowWith: (priority?: number) => Micro<void> = makePrimitive({\n  op: \"Yield\",\n  eval(fiber) {\n    let resumed = false\n    fiber.getRef(CurrentScheduler).scheduleTask(() => {\n      if (resumed) return\n      fiber.evaluate(exitVoid as any)\n    }, this[args] ?? 0)\n    return fiber.yieldWith(() => {\n      resumed = true\n    })\n  }\n})\n\n/**\n * Pause the execution of the current `Micro` effect, and resume it on the next\n * scheduler tick.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const yieldNow: Micro<void> = yieldNowWith(0)\n\n/**\n * Creates a `Micro` effect that will succeed with the value wrapped in `Some`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const succeedSome = <A>(a: A): Micro<Option.Option<A>> => succeed(Option.some(a))\n\n/**\n * Creates a `Micro` effect that succeeds with `None`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const succeedNone: Micro<Option.Option<never>> = succeed(Option.none())\n\n/**\n * Creates a `Micro` effect that will fail with the lazily evaluated `MicroCause`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const failCauseSync = <E>(evaluate: LazyArg<MicroCause<E>>): Micro<never, E> =>\n  suspend(() => failCause(evaluate()))\n\n/**\n * Creates a `Micro` effect that will die with the specified error.\n *\n * This results in a `Die` variant of the `MicroCause` type, where the error is\n * not tracked at the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const die = (defect: unknown): Micro<never> => exitDie(defect)\n\n/**\n * Creates a `Micro` effect that will fail with the lazily evaluated error.\n *\n * This results in a `Fail` variant of the `MicroCause` type, where the error is\n * tracked at the type level.\n *\n * @since 3.4.6\n * @experimental\n * @category constructors\n */\nexport const failSync = <E>(error: LazyArg<E>): Micro<never, E> => suspend(() => fail(error()))\n\n/**\n * Converts an `Option` into a `Micro` effect, that will fail with\n * `NoSuchElementException` if the option is `None`. Otherwise, it will succeed with the\n * value of the option.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const fromOption = <A>(option: Option.Option<A>): Micro<A, NoSuchElementException> =>\n  option._tag === \"Some\" ? succeed(option.value) : fail(new NoSuchElementException({}))\n\n/**\n * Converts an `Either` into a `Micro` effect, that will fail with the left side\n * of the either if it is a `Left`. Otherwise, it will succeed with the right\n * side of the either.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const fromEither = <R, L>(either: Either.Either<R, L>): Micro<R, L> =>\n  either._tag === \"Right\" ? succeed(either.right) : fail(either.left)\n\nconst void_: Micro<void> = succeed(void 0)\nexport {\n  /**\n   * A `Micro` effect that will succeed with `void` (`undefined`).\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category constructors\n   */\n  void_ as void\n}\n\nconst try_ = <A, E>(options: {\n  try: LazyArg<A>\n  catch: (error: unknown) => E\n}): Micro<A, E> =>\n  suspend(() => {\n    try {\n      return succeed(options.try())\n    } catch (err) {\n      return fail(options.catch(err))\n    }\n  })\nexport {\n  /**\n   * The `Micro` equivalent of a try / catch block, which allows you to map\n   * thrown errors to a specific error type.\n   *\n   * @example\n   * ```ts\n   * import { Micro } from \"effect\"\n   *\n   * Micro.try({\n   *   try: () => { throw new Error(\"boom\") },\n   *   catch: (cause) => new Error(\"caught\", { cause })\n   * })\n   * ```\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category constructors\n   */\n  try_ as try\n}\n\n/**\n * Wrap a `Promise` into a `Micro` effect.\n *\n * Any errors will result in a `Die` variant of the `MicroCause` type, where the\n * error is not tracked at the type level.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const promise = <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Micro<A> =>\n  asyncOptions<A>(function(resume, signal) {\n    evaluate(signal!).then(\n      (a) => resume(succeed(a)),\n      (e) => resume(die(e))\n    )\n  }, evaluate.length !== 0)\n\n/**\n * Wrap a `Promise` into a `Micro` effect. Any errors will be caught and\n * converted into a specific error type.\n *\n * @example\n * ```ts\n * import { Micro } from \"effect\"\n *\n * Micro.tryPromise({\n *   try: () => Promise.resolve(\"success\"),\n *   catch: (cause) => new Error(\"caught\", { cause })\n * })\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const tryPromise = <A, E>(options: {\n  readonly try: (signal: AbortSignal) => PromiseLike<A>\n  readonly catch: (error: unknown) => E\n}): Micro<A, E> =>\n  asyncOptions<A, E>(function(resume, signal) {\n    try {\n      options.try(signal!).then(\n        (a) => resume(succeed(a)),\n        (e) => resume(fail(options.catch(e)))\n      )\n    } catch (err) {\n      resume(fail(options.catch(err)))\n    }\n  }, options.try.length !== 0)\n\n/**\n * Create a `Micro` effect using the current `MicroFiber`.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const withMicroFiber: <A, E = never, R = never>(\n  evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>\n) => Micro<A, E, R> = makePrimitive({\n  op: \"WithMicroFiber\",\n  eval(fiber) {\n    return this[args](fiber)\n  }\n})\n\n/**\n * Flush any yielded effects that are waiting to be executed.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const yieldFlush: Micro<void> = withMicroFiber((fiber) => {\n  fiber.getRef(CurrentScheduler).flush()\n  return exitVoid\n})\n\nconst asyncOptions: <A, E = never, R = never>(\n  register: (\n    resume: (effect: Micro<A, E, R>) => void,\n    signal?: AbortSignal\n  ) => void | Micro<void, never, R>,\n  withSignal: boolean\n) => Micro<A, E, R> = makePrimitive({\n  op: \"Async\",\n  single: false,\n  eval(fiber) {\n    const register = this[args][0]\n    let resumed = false\n    let yielded: boolean | Primitive = false\n    const controller = this[args][1] ? new AbortController() : undefined\n    const onCancel = register((effect) => {\n      if (resumed) return\n      resumed = true\n      if (yielded) {\n        fiber.evaluate(effect as any)\n      } else {\n        yielded = effect as any\n      }\n    }, controller?.signal)\n    if (yielded !== false) return yielded\n    yielded = true\n    fiber._yielded = () => {\n      resumed = true\n    }\n    if (controller === undefined && onCancel === undefined) {\n      return Yield\n    }\n    fiber._stack.push(asyncFinalizer(() => {\n      resumed = true\n      controller?.abort()\n      return onCancel ?? exitVoid\n    }))\n    return Yield\n  }\n})\nconst asyncFinalizer: (onInterrupt: () => Micro<void, any, any>) => Primitive = makePrimitive({\n  op: \"AsyncFinalizer\",\n  ensure(fiber) {\n    if (fiber.interruptible) {\n      fiber.interruptible = false\n      fiber._stack.push(setInterruptible(true))\n    }\n  },\n  contE(cause, _fiber) {\n    return causeIsInterrupt(cause)\n      ? flatMap(this[args](), () => failCause(cause))\n      : failCause(cause)\n  }\n})\n\n/**\n * Create a `Micro` effect from an asynchronous computation.\n *\n * You can return a cleanup effect that will be run when the effect is aborted.\n * It is also passed an `AbortSignal` that is triggered when the effect is\n * aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const async = <A, E = never, R = never>(\n  register: (\n    resume: (effect: Micro<A, E, R>) => void,\n    signal: AbortSignal\n  ) => void | Micro<void, never, R>\n): Micro<A, E, R> => asyncOptions(register as any, register.length >= 2)\n\n/**\n * A `Micro` that will never succeed or fail. It wraps `setInterval` to prevent\n * the Javascript runtime from exiting.\n *\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const never: Micro<never> = async<never>(function() {\n  const interval = setInterval(constVoid, 2147483646)\n  return sync(() => clearInterval(interval))\n})\n\n/**\n * @since 3.4.0\n * @experimental\n * @category constructors\n */\nexport const gen = <Self, Eff extends YieldWrap<Micro<any, any, any>>, AEff>(\n  ...args:\n    | [self: Self, body: (this: Self) => Generator<Eff, AEff, never>]\n    | [body: () => Generator<Eff, AEff, never>]\n): Micro<\n  AEff,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Micro<infer _A, infer E, infer _R>>] ? E : never,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Micro<infer _A, infer _E, infer R>>] ? R : never\n> => suspend(() => fromIterator(args.length === 1 ? args[0]() : args[1].call(args[0]) as any))\n\nconst fromIterator: (\n  iterator: Iterator<any, YieldWrap<Micro<any, any, any>>>\n) => Micro<any, any, any> = makePrimitive({\n  op: \"Iterator\",\n  contA(value, fiber) {\n    const state = this[args].next(value)\n    if (state.done) return succeed(state.value)\n    fiber._stack.push(this)\n    return yieldWrapGet(state.value)\n  },\n  eval(this: any, fiber: MicroFiberImpl) {\n    return this[successCont](undefined, fiber)\n  }\n})\n\n// ----------------------------------------------------------------------------\n// mapping & sequencing\n// ----------------------------------------------------------------------------\n\n/**\n * Create a `Micro` effect that will replace the success value of the given\n * effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const as: {\n  // ----------------------------------------------------------------------------\n  // mapping & sequencing\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Create a `Micro` effect that will replace the success value of the given\n   * effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>\n  // ----------------------------------------------------------------------------\n  // mapping & sequencing\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Create a `Micro` effect that will replace the success value of the given\n   * effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>\n} = dual(2, <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R> => map(self, (_) => value))\n\n/**\n * Wrap the success value of this `Micro` effect in a `Some`.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const asSome = <A, E, R>(self: Micro<A, E, R>): Micro<Option.Option<A>, E, R> => map(self, Option.some)\n\n/**\n * Swap the error and success types of the `Micro` effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const flip = <A, E, R>(self: Micro<A, E, R>): Micro<E, A, R> =>\n  matchEffect(self, {\n    onFailure: succeed,\n    onSuccess: fail\n  })\n\n/**\n * A more flexible version of `flatMap` that combines `map` and `flatMap` into a\n * single API.\n *\n * It also lets you directly pass a `Micro` effect, which will be executed after\n * the current effect.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const andThen: {\n  /**\n   * A more flexible version of `flatMap` that combines `map` and `flatMap` into a\n   * single API.\n   *\n   * It also lets you directly pass a `Micro` effect, which will be executed after\n   * the current effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, X>(f: (a: A) => X): <E, R>(\n    self: Micro<A, E, R>\n  ) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1>\n    : Micro<X, E, R>\n  /**\n   * A more flexible version of `flatMap` that combines `map` and `flatMap` into a\n   * single API.\n   *\n   * It also lets you directly pass a `Micro` effect, which will be executed after\n   * the current effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <X>(f: NotFunction<X>): <A, E, R>(\n    self: Micro<A, E, R>\n  ) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1>\n    : Micro<X, E, R>\n  /**\n   * A more flexible version of `flatMap` that combines `map` and `flatMap` into a\n   * single API.\n   *\n   * It also lets you directly pass a `Micro` effect, which will be executed after\n   * the current effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, X>(self: Micro<A, E, R>, f: (a: A) => X): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1>\n    : Micro<X, E, R>\n  /**\n   * A more flexible version of `flatMap` that combines `map` and `flatMap` into a\n   * single API.\n   *\n   * It also lets you directly pass a `Micro` effect, which will be executed after\n   * the current effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1>\n    : Micro<X, E, R>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: any): Micro<B, E | E2, R | R2> =>\n    flatMap(self, (a) => {\n      const value = isMicro(f) ? f : typeof f === \"function\" ? f(a) : f\n      return isMicro(value) ? value : succeed(value)\n    })\n)\n\n/**\n * Execute a side effect from the success value of the `Micro` effect.\n *\n * It is similar to the `andThen` api, but the success value is ignored.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const tap: {\n  /**\n   * Execute a side effect from the success value of the `Micro` effect.\n   *\n   * It is similar to the `andThen` api, but the success value is ignored.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, X>(f: (a: NoInfer<A>) => X): <E, R>(\n    self: Micro<A, E, R>\n  ) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1>\n    : Micro<A, E, R>\n  /**\n   * Execute a side effect from the success value of the `Micro` effect.\n   *\n   * It is similar to the `andThen` api, but the success value is ignored.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <X>(f: NotFunction<X>): <A, E, R>(\n    self: Micro<A, E, R>\n  ) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1>\n    : Micro<A, E, R>\n  /**\n   * Execute a side effect from the success value of the `Micro` effect.\n   *\n   * It is similar to the `andThen` api, but the success value is ignored.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, X>(self: Micro<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1>\n    : Micro<A, E, R>\n  /**\n   * Execute a side effect from the success value of the `Micro` effect.\n   *\n   * It is similar to the `andThen` api, but the success value is ignored.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1>\n    : Micro<A, E, R>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2> =>\n    flatMap(self, (a) => {\n      const value = isMicro(f) ? f : typeof f === \"function\" ? f(a) : f\n      return isMicro(value) ? as(value, a) : succeed(a)\n    })\n)\n\n/**\n * Replace the success value of the `Micro` effect with `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const asVoid = <A, E, R>(self: Micro<A, E, R>): Micro<void, E, R> => flatMap(self, (_) => exitVoid)\n\n/**\n * Access the `MicroExit` of the given `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category mapping & sequencing\n */\nexport const exit = <A, E, R>(self: Micro<A, E, R>): Micro<MicroExit<A, E>, never, R> =>\n  matchCause(self, {\n    onFailure: exitFailCause,\n    onSuccess: exitSucceed\n  })\n\n/**\n * Replace the error type of the given `Micro` with the full `MicroCause` object.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const sandbox = <A, E, R>(self: Micro<A, E, R>): Micro<A, MicroCause<E>, R> => catchAllCause(self, fail)\n\n/**\n * Returns an effect that races all the specified effects,\n * yielding the value of the first effect to succeed with a value. Losers of\n * the race will be interrupted immediately\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nexport const raceAll = <Eff extends Micro<any, any, any>>(\n  all: Iterable<Eff>\n): Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>> =>\n  withMicroFiber((parent) =>\n    async((resume) => {\n      const effects = Arr.fromIterable(all)\n      const len = effects.length\n      let doneCount = 0\n      let done = false\n      const fibers = new Set<MicroFiber<any, any>>()\n      const causes: Array<MicroCause<any>> = []\n      const onExit = (exit: MicroExit<any, any>) => {\n        doneCount++\n        if (exit._tag === \"Failure\") {\n          causes.push(exit.cause)\n          if (doneCount >= len) {\n            resume(failCause(causes[0]))\n          }\n          return\n        }\n        done = true\n        resume(fibers.size === 0 ? exit : flatMap(uninterruptible(fiberInterruptAll(fibers)), () => exit))\n      }\n\n      for (let i = 0; i < len; i++) {\n        if (done) break\n        const fiber = unsafeFork(parent, interruptible(effects[i]), true, true)\n        fibers.add(fiber)\n        fiber.addObserver((exit) => {\n          fibers.delete(fiber)\n          onExit(exit)\n        })\n      }\n\n      return fiberInterruptAll(fibers)\n    })\n  )\n\n/**\n * Returns an effect that races all the specified effects,\n * yielding the value of the first effect to succeed or fail. Losers of\n * the race will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nexport const raceAllFirst = <Eff extends Micro<any, any, any>>(\n  all: Iterable<Eff>\n): Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>> =>\n  withMicroFiber((parent) =>\n    async((resume) => {\n      let done = false\n      const fibers = new Set<MicroFiber<any, any>>()\n      const onExit = (exit: MicroExit<any, any>) => {\n        done = true\n        resume(fibers.size === 0 ? exit : flatMap(fiberInterruptAll(fibers), () => exit))\n      }\n\n      for (const effect of all) {\n        if (done) break\n        const fiber = unsafeFork(parent, interruptible(effect), true, true)\n        fibers.add(fiber)\n        fiber.addObserver((exit) => {\n          fibers.delete(fiber)\n          onExit(exit)\n        })\n      }\n\n      return fiberInterruptAll(fibers)\n    })\n  )\n\n/**\n * Returns an effect that races two effects, yielding the value of the first\n * effect to succeed. Losers of the race will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nexport const race: {\n  /**\n   * Returns an effect that races two effects, yielding the value of the first\n   * effect to succeed. Losers of the race will be interrupted immediately.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category sequencing\n   */\n  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>\n  /**\n   * Returns an effect that races two effects, yielding the value of the first\n   * effect to succeed. Losers of the race will be interrupted immediately.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category sequencing\n   */\n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2> =>\n    raceAll([self, that])\n)\n\n/**\n * Returns an effect that races two effects, yielding the value of the first\n * effect to succeed *or* fail. Losers of the race will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category sequencing\n */\nexport const raceFirst: {\n  /**\n   * Returns an effect that races two effects, yielding the value of the first\n   * effect to succeed *or* fail. Losers of the race will be interrupted immediately.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category sequencing\n   */\n  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>\n  /**\n   * Returns an effect that races two effects, yielding the value of the first\n   * effect to succeed *or* fail. Losers of the race will be interrupted immediately.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category sequencing\n   */\n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2> =>\n    raceAllFirst([self, that])\n)\n\n/**\n * Map the success value of this `Micro` effect to another `Micro` effect, then\n * flatten the result.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const flatMap: {\n  /**\n   * Map the success value of this `Micro` effect to another `Micro` effect, then\n   * flatten the result.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>\n  /**\n   * Map the success value of this `Micro` effect to another `Micro` effect, then\n   * flatten the result.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    f: (a: A) => Micro<B, E2, R2>\n  ): Micro<B, E | E2, R | R2> => {\n    const onSuccess = Object.create(OnSuccessProto)\n    onSuccess[args] = self\n    onSuccess[successCont] = f\n    return onSuccess\n  }\n)\nconst OnSuccessProto = makePrimitiveProto({\n  op: \"OnSuccess\",\n  eval(this: any, fiber: MicroFiberImpl): Primitive {\n    fiber._stack.push(this)\n    return this[args]\n  }\n})\n\n// ----------------------------------------------------------------------------\n// mapping & sequencing\n// ----------------------------------------------------------------------------\n\n/**\n * Flattens any nested `Micro` effects, merging the error and requirement types.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const flatten = <A, E, R, E2, R2>(\n  self: Micro<Micro<A, E, R>, E2, R2>\n): Micro<A, E | E2, R | R2> => flatMap(self, identity)\n\n/**\n * Transforms the success value of the `Micro` effect with the specified\n * function.\n *\n * @since 3.4.0\n * @experimental\n * @category mapping & sequencing\n */\nexport const map: {\n  /**\n   * Transforms the success value of the `Micro` effect with the specified\n   * function.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>\n  /**\n   * Transforms the success value of the `Micro` effect with the specified\n   * function.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category mapping & sequencing\n   */\n  <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R> => flatMap(self, (a) => succeed(f(a)))\n)\n\n// ----------------------------------------------------------------------------\n// MicroExit\n// ----------------------------------------------------------------------------\n\n/**\n * The `MicroExit` type is used to represent the result of a `Micro` computation. It\n * can either be successful, containing a value of type `A`, or it can fail,\n * containing an error of type `E` wrapped in a `MicroCause`.\n *\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport type MicroExit<A, E = never> =\n  | MicroExit.Success<A, E>\n  | MicroExit.Failure<A, E>\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport declare namespace MicroExit {\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroExit\n   */\n  export interface Proto<out A, out E = never> extends Micro<A, E> {\n    readonly [MicroExitTypeId]: MicroExitTypeId\n  }\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroExit\n   */\n  export interface Success<out A, out E> extends Proto<A, E> {\n    readonly _tag: \"Success\"\n    readonly value: A\n  }\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category MicroExit\n   */\n  export interface Failure<out A, out E> extends Proto<A, E> {\n    readonly _tag: \"Failure\"\n    readonly cause: MicroCause<E>\n  }\n}\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const isMicroExit = (u: unknown): u is MicroExit<unknown, unknown> => hasProperty(u, MicroExitTypeId)\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitSucceed: <A>(a: A) => MicroExit<A, never> = succeed as any\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitFailCause: <E>(cause: MicroCause<E>) => MicroExit<never, E> = failCause as any\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitInterrupt: MicroExit<never> = exitFailCause(causeInterrupt())\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitFail = <E>(e: E): MicroExit<never, E> => exitFailCause(causeFail(e))\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitDie = (defect: unknown): MicroExit<never> => exitFailCause(causeDie(defect))\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitIsSuccess = <A, E>(\n  self: MicroExit<A, E>\n): self is MicroExit.Success<A, E> => self._tag === \"Success\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitIsFailure = <A, E>(\n  self: MicroExit<A, E>\n): self is MicroExit.Failure<A, E> => self._tag === \"Failure\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitIsInterrupt = <A, E>(\n  self: MicroExit<A, E>\n): self is MicroExit.Failure<A, E> & {\n  readonly cause: MicroCause.Interrupt\n} => exitIsFailure(self) && self.cause._tag === \"Interrupt\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitIsFail = <A, E>(\n  self: MicroExit<A, E>\n): self is MicroExit.Failure<A, E> & {\n  readonly cause: MicroCause.Fail<E>\n} => exitIsFailure(self) && self.cause._tag === \"Fail\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitIsDie = <A, E>(\n  self: MicroExit<A, E>\n): self is MicroExit.Failure<A, E> & {\n  readonly cause: MicroCause.Die\n} => exitIsFailure(self) && self.cause._tag === \"Die\"\n\n/**\n * @since 3.4.6\n * @experimental\n * @category MicroExit\n */\nexport const exitVoid: MicroExit<void> = exitSucceed(void 0)\n\n/**\n * @since 3.11.0\n * @experimental\n * @category MicroExit\n */\nexport const exitVoidAll = <I extends Iterable<MicroExit<any, any>>>(\n  exits: I\n): MicroExit<void, I extends Iterable<MicroExit<infer _A, infer _E>> ? _E : never> => {\n  for (const exit of exits) {\n    if (exit._tag === \"Failure\") {\n      return exit\n    }\n  }\n  return exitVoid\n}\n\n// ----------------------------------------------------------------------------\n// scheduler\n// ----------------------------------------------------------------------------\n\n/**\n * @since 3.5.9\n * @experimental\n * @category scheduler\n */\nexport interface MicroScheduler {\n  readonly scheduleTask: (task: () => void, priority: number) => void\n  readonly shouldYield: (fiber: MicroFiber<unknown, unknown>) => boolean\n  readonly flush: () => void\n}\n\nconst setImmediate = \"setImmediate\" in globalThis\n  ? globalThis.setImmediate\n  : (f: () => void) => setTimeout(f, 0)\n\n/**\n * @since 3.5.9\n * @experimental\n * @category scheduler\n */\nexport class MicroSchedulerDefault implements MicroScheduler {\n  private tasks: Array<() => void> = []\n  private running = false\n\n  /**\n   * @since 3.5.9\n   */\n  scheduleTask(task: () => void, _priority: number) {\n    this.tasks.push(task)\n    if (!this.running) {\n      this.running = true\n      setImmediate(this.afterScheduled)\n    }\n  }\n\n  /**\n   * @since 3.5.9\n   */\n  afterScheduled = () => {\n    this.running = false\n    this.runTasks()\n  }\n\n  /**\n   * @since 3.5.9\n   */\n  runTasks() {\n    const tasks = this.tasks\n    this.tasks = []\n    for (let i = 0, len = tasks.length; i < len; i++) {\n      tasks[i]()\n    }\n  }\n\n  /**\n   * @since 3.5.9\n   */\n  shouldYield(fiber: MicroFiber<unknown, unknown>) {\n    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield)\n  }\n\n  /**\n   * @since 3.5.9\n   */\n  flush() {\n    while (this.tasks.length > 0) {\n      this.runTasks()\n    }\n  }\n}\n\n/**\n * Access the given `Context.Tag` from the environment.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nexport const service: {\n  /**\n   * Access the given `Context.Tag` from the environment.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment\n   */\n  <I, S>(tag: Context.Reference<I, S>): Micro<S>\n  /**\n   * Access the given `Context.Tag` from the environment.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment\n   */\n  <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>\n} =\n  (<I, S>(tag: Context.Tag<I, S>): Micro<S, never, I> =>\n    withMicroFiber((fiber) => succeed(Context.unsafeGet(fiber.context, tag)))) as any\n\n/**\n * Access the given `Context.Tag` from the environment, without tracking the\n * dependency at the type level.\n *\n * It will return an `Option` of the service, depending on whether it is\n * available in the environment or not.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nexport const serviceOption = <I, S>(\n  tag: Context.Tag<I, S>\n): Micro<Option.Option<S>> => withMicroFiber((fiber) => succeed(Context.getOption(fiber.context, tag)))\n\n/**\n * Update the Context with the given mapping function.\n *\n * @since 3.11.0\n * @experimental\n * @category environment\n */\nexport const updateContext: {\n  /**\n   * Update the Context with the given mapping function.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category environment\n   */\n  <R2, R>(f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>\n  /**\n   * Update the Context with the given mapping function.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category environment\n   */\n  <A, E, R, R2>(\n    self: Micro<A, E, R>,\n    f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>\n  ): Micro<A, E, R2>\n} = dual(\n  2,\n  <A, E, R, R2>(\n    self: Micro<A, E, R>,\n    f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>\n  ): Micro<A, E, R2> =>\n    withMicroFiber</**\n     * Update the Context with the given mapping function.\n     *\n     * @since 3.11.0\n     * @experimental\n     * @category environment\n     */\n    A, /**\n     * Update the Context with the given mapping function.\n     *\n     * @since 3.11.0\n     * @experimental\n     * @category environment\n     */\n    E, /**\n     * Update the Context with the given mapping function.\n     *\n     * @since 3.11.0\n     * @experimental\n     * @category environment\n     */\n    R2>((fiber) => {\n      const prev = fiber.context as Context.Context<R2>\n      fiber.context = f(prev)\n      return onExit(\n        self as any,\n        () => {\n          fiber.context = prev\n          return void_\n        }\n      )\n    })\n)\n\n/**\n * Update the service for the given `Context.Tag` in the environment.\n *\n * @since 3.11.0\n * @experimental\n * @category environment\n */\nexport const updateService: {\n  /**\n   * Update the service for the given `Context.Tag` in the environment.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category environment\n   */\n  <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>\n  /**\n   * Update the service for the given `Context.Tag` in the environment.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category environment\n   */\n  <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>\n  /**\n   * Update the service for the given `Context.Tag` in the environment.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category environment\n   */\n  <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>\n  /**\n   * Update the service for the given `Context.Tag` in the environment.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category environment\n   */\n  <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>\n} = dual(\n  3,\n  <XA, E, R, I, A>(\n    self: Micro<XA, E, R>,\n    tag: Context.Reference<I, A>,\n    f: (value: A) => A\n  ): Micro<XA, E, R> =>\n    withMicroFiber((fiber) => {\n      const prev = Context.unsafeGet(fiber.context, tag)\n      fiber.context = Context.add(fiber.context, tag, f(prev))\n      return onExit(\n        self,\n        () => {\n          fiber.context = Context.add(fiber.context, tag, prev)\n          return void_\n        }\n      )\n    })\n)\n\n/**\n * Access the current `Context` from the environment.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nexport const context = <R>(): Micro<Context.Context<R>> => getContext as any\nconst getContext = withMicroFiber((fiber) => succeed(fiber.context))\n\n/**\n * Merge the given `Context` with the current context.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nexport const provideContext: {\n  /**\n   * Merge the given `Context` with the current context.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment\n   */\n  <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>\n  /**\n   * Merge the given `Context` with the current context.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment\n   */\n  <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>\n} = dual(\n  2,\n  <A, E, R, XR>(\n    self: Micro<A, E, R>,\n    provided: Context.Context<XR>\n  ): Micro<A, E, Exclude<R, XR>> => updateContext(self, Context.merge(provided)) as any\n)\n\n/**\n * Add the provided service to the current context.\n *\n * @since 3.4.0\n * @experimental\n * @category environment\n */\nexport const provideService: {\n  /**\n   * Add the provided service to the current context.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment\n   */\n  <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>\n  /**\n   * Add the provided service to the current context.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment\n   */\n  <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>\n} = dual(\n  3,\n  <A, E, R, I, S>(\n    self: Micro<A, E, R>,\n    tag: Context.Tag<I, S>,\n    service: S\n  ): Micro<A, E, Exclude<R, I>> => updateContext(self, Context.add(tag, service)) as any\n)\n\n/**\n * Create a service using the provided `Micro` effect, and add it to the\n * current context.\n *\n * @since 3.4.6\n * @experimental\n * @category environment\n */\nexport const provideServiceEffect: {\n  /**\n   * Create a service using the provided `Micro` effect, and add it to the\n   * current context.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category environment\n   */\n  <I, S, E2, R2>(tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>\n  /**\n   * Create a service using the provided `Micro` effect, and add it to the\n   * current context.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category environment\n   */\n  <A, E, R, I, S, E2, R2>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): Micro<A, E | E2, Exclude<R, I> | R2>\n} = dual(\n  3,\n  <A, E, R, I, S, E2, R2>(\n    self: Micro<A, E, R>,\n    tag: Context.Tag<I, S>,\n    acquire: Micro<S, E2, R2>\n  ): Micro<A, E | E2, Exclude<R, I> | R2> => flatMap(acquire, (service) => provideService(self, tag, service))\n)\n\n// ========================================================================\n// References\n// ========================================================================\n\n/**\n * @since 3.11.0\n * @experimental\n * @category references\n */\nexport class MaxOpsBeforeYield extends Context.Reference<MaxOpsBeforeYield>()<\n  \"effect/Micro/currentMaxOpsBeforeYield\",\n  number\n>(\n  \"effect/Micro/currentMaxOpsBeforeYield\",\n  { defaultValue: () => 2048 }\n) {}\n\n/**\n * @since 3.11.0\n * @experimental\n * @category environment refs\n */\nexport class CurrentConcurrency extends Context.Reference<CurrentConcurrency>()<\n  \"effect/Micro/currentConcurrency\",\n  \"unbounded\" | number\n>(\n  \"effect/Micro/currentConcurrency\",\n  { defaultValue: () => \"unbounded\" }\n) {}\n\n/**\n * @since 3.11.0\n * @experimental\n * @category environment refs\n */\nexport class CurrentScheduler extends Context.Reference<CurrentScheduler>()<\n  \"effect/Micro/currentScheduler\",\n  MicroScheduler\n>(\n  \"effect/Micro/currentScheduler\",\n  { defaultValue: () => new MicroSchedulerDefault() }\n) {}\n\n/**\n * If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\n * api to control the concurrency of that `Micro` when it is run.\n *\n * @example\n * ```ts\n * import * as Micro from \"effect/Micro\"\n *\n * Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n *   concurrency: \"inherit\"\n * }).pipe(\n *   Micro.withConcurrency(2) // use a concurrency of 2\n * )\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category environment refs\n */\nexport const withConcurrency: {\n  /**\n   * If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\n   * api to control the concurrency of that `Micro` when it is run.\n   *\n   * @example\n   * ```ts\n   * import * as Micro from \"effect/Micro\"\n   *\n   * Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n   *   concurrency: \"inherit\"\n   * }).pipe(\n   *   Micro.withConcurrency(2) // use a concurrency of 2\n   * )\n   * ```\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment refs\n   */\n  (concurrency: \"unbounded\" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>\n  /**\n   * If you have a `Micro` that uses `concurrency: \"inherit\"`, you can use this\n   * api to control the concurrency of that `Micro` when it is run.\n   *\n   * @example\n   * ```ts\n   * import * as Micro from \"effect/Micro\"\n   *\n   * Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {\n   *   concurrency: \"inherit\"\n   * }).pipe(\n   *   Micro.withConcurrency(2) // use a concurrency of 2\n   * )\n   * ```\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category environment refs\n   */\n  <A, E, R>(self: Micro<A, E, R>, concurrency: \"unbounded\" | number): Micro<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    concurrency: \"unbounded\" | number\n  ): Micro<A, E, R> => provideService(self, CurrentConcurrency, concurrency)\n)\n\n// ----------------------------------------------------------------------------\n// zipping\n// ----------------------------------------------------------------------------\n\n/**\n * Combine two `Micro` effects into a single effect that produces a tuple of\n * their results.\n *\n * @since 3.4.0\n * @experimental\n * @category zipping\n */\nexport const zip: {\n  // ----------------------------------------------------------------------------\n  // zipping\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Combine two `Micro` effects into a single effect that produces a tuple of\n   * their results.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category zipping\n   */\n  <A2, E2, R2>(\n    that: Micro<A2, E2, R2>,\n    options?:\n      | { readonly concurrent?: boolean | undefined }\n      | undefined\n  ): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>\n  // ----------------------------------------------------------------------------\n  // zipping\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Combine two `Micro` effects into a single effect that produces a tuple of\n   * their results.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category zipping\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Micro<A, E, R>,\n    that: Micro<A2, E2, R2>,\n    options?: { readonly concurrent?: boolean | undefined }\n  ): Micro<[A, A2], E | E2, R | R2>\n} = dual((args) => isMicro(args[1]), <A, E, R, A2, E2, R2>(\n  self: Micro<A, E, R>,\n  that: Micro<A2, E2, R2>,\n  options?: { readonly concurrent?: boolean | undefined }\n): Micro<[A, A2], E | E2, R | R2> => zipWith(self, that, (a, a2) => [a, a2], options))\n\n/**\n * The `Micro.zipWith` function combines two `Micro` effects and allows you to\n * apply a function to the results of the combined effects, transforming them\n * into a single value.\n *\n * @since 3.4.3\n * @experimental\n * @category zipping\n */\nexport const zipWith: {\n  /**\n   * The `Micro.zipWith` function combines two `Micro` effects and allows you to\n   * apply a function to the results of the combined effects, transforming them\n   * into a single value.\n   *\n   * @since 3.4.3\n   * @experimental\n   * @category zipping\n   */\n  <A2, E2, R2, A, B>(\n    that: Micro<A2, E2, R2>,\n    f: (a: A, b: A2) => B,\n    options?: { readonly concurrent?: boolean | undefined }\n  ): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>\n  /**\n   * The `Micro.zipWith` function combines two `Micro` effects and allows you to\n   * apply a function to the results of the combined effects, transforming them\n   * into a single value.\n   *\n   * @since 3.4.3\n   * @experimental\n   * @category zipping\n   */\n  <A, E, R, A2, E2, R2, B>(\n    self: Micro<A, E, R>,\n    that: Micro<A2, E2, R2>,\n    f: (a: A, b: A2) => B,\n    options?: { readonly concurrent?: boolean | undefined }\n  ): Micro<B, E2 | E, R2 | R>\n} = dual((args) => isMicro(args[1]), <A, E, R, A2, E2, R2, B>(\n  self: Micro<A, E, R>,\n  that: Micro<A2, E2, R2>,\n  f: (a: A, b: A2) => B,\n  options?: { readonly concurrent?: boolean | undefined }\n): Micro<B, E2 | E, R2 | R> =>\n  options?.concurrent\n    // Use `all` exclusively for concurrent cases, as it introduces additional overhead due to the management of concurrency\n    ? map(all([self, that], { concurrency: 2 }), ([a, a2]) => f(a, a2))\n    : flatMap(self, (a) => map(that, (a2) => f(a, a2))))\n\n// ----------------------------------------------------------------------------\n// filtering & conditionals\n// ----------------------------------------------------------------------------\n\n/**\n * Filter the specified effect with the provided function, failing with specified\n * `MicroCause` if the predicate fails.\n *\n * In addition to the filtering capabilities discussed earlier, you have the option to further\n * refine and narrow down the type of the success channel by providing a\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */\nexport const filterOrFailCause: {\n  // ----------------------------------------------------------------------------\n  // filtering & conditionals\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * `MicroCause` if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, B extends A, E2>(\n    refinement: Refinement<A, B>,\n    orFailWith: (a: NoInfer<A>) => MicroCause<E2>\n  ): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>\n  // ----------------------------------------------------------------------------\n  // filtering & conditionals\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * `MicroCause` if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E2>(\n    predicate: Predicate<NoInfer<A>>,\n    orFailWith: (a: NoInfer<A>) => MicroCause<E2>\n  ): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>\n  // ----------------------------------------------------------------------------\n  // filtering & conditionals\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * `MicroCause` if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E, R, B extends A, E2>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<A, B>,\n    orFailWith: (a: A) => MicroCause<E2>\n  ): Micro<B, E | E2, R>\n  // ----------------------------------------------------------------------------\n  // filtering & conditionals\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * `MicroCause` if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E, R, E2>(\n    self: Micro<A, E, R>,\n    predicate: Predicate<A>,\n    orFailWith: (a: A) => MicroCause<E2>\n  ): Micro<A, E | E2, R>\n} = dual((args) => isMicro(args[0]), <A, E, R, B extends A, E2>(\n  self: Micro<A, E, R>,\n  refinement: Refinement<A, B>,\n  orFailWith: (a: A) => MicroCause<E2>\n): Micro<B, E | E2, R> => flatMap(self, (a) => refinement(a) ? succeed(a) : failCause(orFailWith(a))))\n\n/**\n * Filter the specified effect with the provided function, failing with specified\n * error if the predicate fails.\n *\n * In addition to the filtering capabilities discussed earlier, you have the option to further\n * refine and narrow down the type of the success channel by providing a\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */\nexport const filterOrFail: {\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * error if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * error if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * error if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E, R, B extends A, E2>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<A, B>,\n    orFailWith: (a: A) => E2\n  ): Micro<B, E | E2, R>\n  /**\n   * Filter the specified effect with the provided function, failing with specified\n   * error if the predicate fails.\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the option to further\n   * refine and narrow down the type of the success channel by providing a\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>\n} = dual((args) => isMicro(args[0]), <A, E, R, B extends A, E2>(\n  self: Micro<A, E, R>,\n  refinement: Refinement<A, B>,\n  orFailWith: (a: A) => E2\n): Micro<B, E | E2, R> => flatMap(self, (a) => refinement(a) ? succeed(a) : fail(orFailWith(a))))\n\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 3.4.0\n * @experimental\n * @category filtering & conditionals\n */\nexport const when: {\n  /**\n   * The moral equivalent of `if (p) exp`.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <E2 = never, R2 = never>(condition: LazyArg<boolean> | Micro<boolean, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>\n  /**\n   * The moral equivalent of `if (p) exp`.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category filtering & conditionals\n   */\n  <A, E, R, E2 = never, R2 = never>(self: Micro<A, E, R>, condition: LazyArg<boolean> | Micro<boolean, E2, R2>): Micro<Option.Option<A>, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, E2 = never, R2 = never>(\n    self: Micro<A, E, R>,\n    condition: LazyArg<boolean> | Micro<boolean, E2, R2>\n  ): Micro<Option.Option<A>, E | E2, R | R2> =>\n    flatMap(isMicro(condition) ? condition : sync(condition), (pass) => pass ? asSome(self) : succeedNone)\n)\n\n// ----------------------------------------------------------------------------\n// repetition\n// ----------------------------------------------------------------------------\n\n/**\n * Repeat the given `Micro` using the provided options.\n *\n * The `while` predicate will be checked after each iteration, and can use the\n * fall `MicroExit` of the effect to determine if the repetition should continue.\n *\n * @since 3.4.6\n * @experimental\n * @category repetition\n */\nexport const repeatExit: {\n  // ----------------------------------------------------------------------------\n  // repetition\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Repeat the given `Micro` using the provided options.\n   *\n   * The `while` predicate will be checked after each iteration, and can use the\n   * fall `MicroExit` of the effect to determine if the repetition should continue.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category repetition\n   */\n  <A, E>(\n    options: {\n      while: Predicate<MicroExit<A, E>>\n      times?: number | undefined\n      schedule?: MicroSchedule | undefined\n    }\n  ): <R>(self: Micro<A, E, R>) => Micro<A, E, R>\n  // ----------------------------------------------------------------------------\n  // repetition\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Repeat the given `Micro` using the provided options.\n   *\n   * The `while` predicate will be checked after each iteration, and can use the\n   * fall `MicroExit` of the effect to determine if the repetition should continue.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category repetition\n   */\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    options: {\n      while: Predicate<MicroExit<A, E>>\n      times?: number | undefined\n      schedule?: MicroSchedule | undefined\n    }\n  ): Micro<A, E, R>\n} = dual(2, <A, E, R>(self: Micro<A, E, R>, options: {\n  while: Predicate<MicroExit<A, E>>\n  times?: number | undefined\n  schedule?: MicroSchedule | undefined\n}): Micro<A, E, R> =>\n  suspend(() => {\n    const startedAt = options.schedule ? Date.now() : 0\n    let attempt = 0\n\n    const loop: Micro<A, E, R> = flatMap(exit(self), (exit) => {\n      if (options.while !== undefined && !options.while(exit)) {\n        return exit\n      } else if (options.times !== undefined && attempt >= options.times) {\n        return exit\n      }\n      attempt++\n      let delayEffect = yieldNow\n      if (options.schedule !== undefined) {\n        const elapsed = Date.now() - startedAt\n        const duration = options.schedule(attempt, elapsed)\n        if (Option.isNone(duration)) {\n          return exit\n        }\n        delayEffect = sleep(duration.value)\n      }\n      return flatMap(delayEffect, () => loop)\n    })\n\n    return loop\n  }))\n\n/**\n * Repeat the given `Micro` effect using the provided options. Only successful\n * results will be repeated.\n *\n * @since 3.4.0\n * @experimental\n * @category repetition\n */\nexport const repeat: {\n  /**\n   * Repeat the given `Micro` effect using the provided options. Only successful\n   * results will be repeated.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category repetition\n   */\n  <A, E>(\n    options?: {\n      while?: Predicate<A> | undefined\n      times?: number | undefined\n      schedule?: MicroSchedule | undefined\n    } | undefined\n  ): <R>(self: Micro<A, E, R>) => Micro<A, E, R>\n  /**\n   * Repeat the given `Micro` effect using the provided options. Only successful\n   * results will be repeated.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category repetition\n   */\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    options?: {\n      while?: Predicate<A> | undefined\n      times?: number | undefined\n      schedule?: MicroSchedule | undefined\n    } | undefined\n  ): Micro<A, E, R>\n} = dual((args) => isMicro(args[0]), <A, E, R>(\n  self: Micro<A, E, R>,\n  options?: {\n    while?: Predicate<A> | undefined\n    times?: number | undefined\n    schedule?: MicroSchedule | undefined\n  } | undefined\n): Micro<A, E, R> =>\n  repeatExit(self, {\n    ...options,\n    while: (exit) => exit._tag === \"Success\" && (options?.while === undefined || options.while(exit.value))\n  }))\n\n/**\n * Replicates the given effect `n` times.\n *\n * @since 3.11.0\n * @experimental\n * @category repetition\n */\nexport const replicate: {\n  /**\n   * Replicates the given effect `n` times.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category repetition\n   */\n  (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>\n  /**\n   * Replicates the given effect `n` times.\n   *\n   * @since 3.11.0\n   * @experimental\n   * @category repetition\n   */\n  <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>\n} = dual(\n  2,\n  <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>> => Array.from({ length: n }, () => self)\n)\n\n/**\n * Performs this effect the specified number of times and collects the\n * results.\n *\n * @since 3.11.0\n * @category repetition\n */\nexport const replicateEffect: {\n  /**\n   * Performs this effect the specified number of times and collects the\n   * results.\n   *\n   * @since 3.11.0\n   * @category repetition\n   */\n  (\n    n: number,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard?: false | undefined\n    }\n  ): <A, E, R>(self: Micro<A, E, R>) => Micro<Array<A>, E, R>\n  /**\n   * Performs this effect the specified number of times and collects the\n   * results.\n   *\n   * @since 3.11.0\n   * @category repetition\n   */\n  (\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard: true\n    }\n  ): <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>\n  /**\n   * Performs this effect the specified number of times and collects the\n   * results.\n   *\n   * @since 3.11.0\n   * @category repetition\n   */\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    n: number,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard?: false | undefined\n    }\n  ): Micro<Array<A>, E, R>\n  /**\n   * Performs this effect the specified number of times and collects the\n   * results.\n   *\n   * @since 3.11.0\n   * @category repetition\n   */\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard: true\n    }\n  ): Micro<void, E, R>\n} = dual(\n  (args) => isMicro(args[0]),\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard: true\n    }\n  ): Micro<void, E, R> => all(replicate(self, n), options)\n)\n\n/**\n * Repeat the given `Micro` effect forever, only stopping if the effect fails.\n *\n * @since 3.4.0\n * @experimental\n * @category repetition\n */\nexport const forever = <A, E, R>(self: Micro<A, E, R>): Micro<never, E, R> => repeat(self) as any\n\n// ----------------------------------------------------------------------------\n// scheduling\n// ----------------------------------------------------------------------------\n\n/**\n * The `MicroSchedule` type represents a function that can be used to calculate\n * the delay between repeats.\n *\n * The function takes the current attempt number and the elapsed time since the\n * first attempt, and returns the delay for the next attempt. If the function\n * returns `None`, the repetition will stop.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport type MicroSchedule = (attempt: number, elapsed: number) => Option.Option<number>\n\n/**\n * Create a `MicroSchedule` that will stop repeating after the specified number\n * of attempts.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleRecurs = (n: number): MicroSchedule => (attempt) => attempt <= n ? Option.some(0) : Option.none()\n\n/**\n * Create a `MicroSchedule` that will generate a constant delay.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleSpaced = (millis: number): MicroSchedule => () => Option.some(millis)\n\n/**\n * Create a `MicroSchedule` that will generate a delay with an exponential backoff.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleExponential = (baseMillis: number, factor = 2): MicroSchedule => (attempt) =>\n  Option.some(Math.pow(factor, attempt) * baseMillis)\n\n/**\n * Returns a new `MicroSchedule` with an added calculated delay to each delay\n * returned by this schedule.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleAddDelay: {\n  /**\n   * Returns a new `MicroSchedule` with an added calculated delay to each delay\n   * returned by this schedule.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (f: () => number): (self: MicroSchedule) => MicroSchedule\n  /**\n   * Returns a new `MicroSchedule` with an added calculated delay to each delay\n   * returned by this schedule.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (self: MicroSchedule, f: () => number): MicroSchedule\n} = dual(\n  2,\n  (self: MicroSchedule, f: () => number): MicroSchedule => (attempt, elapsed) =>\n    Option.map(self(attempt, elapsed), (duration) => duration + f())\n)\n\n/**\n * Transform a `MicroSchedule` to one that will have a delay that will never exceed\n * the specified maximum.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleWithMaxDelay: {\n  /**\n   * Transform a `MicroSchedule` to one that will have a delay that will never exceed\n   * the specified maximum.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (max: number): (self: MicroSchedule) => MicroSchedule\n  /**\n   * Transform a `MicroSchedule` to one that will have a delay that will never exceed\n   * the specified maximum.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (self: MicroSchedule, max: number): MicroSchedule\n} = dual(\n  2,\n  (self: MicroSchedule, max: number): MicroSchedule => (attempt, elapsed) =>\n    Option.map(self(attempt, elapsed), (duration) => Math.min(duration, max))\n)\n\n/**\n * Transform a `MicroSchedule` to one that will stop repeating after the specified\n * amount of time.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleWithMaxElapsed: {\n  /**\n   * Transform a `MicroSchedule` to one that will stop repeating after the specified\n   * amount of time.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (max: number): (self: MicroSchedule) => MicroSchedule\n  /**\n   * Transform a `MicroSchedule` to one that will stop repeating after the specified\n   * amount of time.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (self: MicroSchedule, max: number): MicroSchedule\n} = dual(\n  2,\n  (self: MicroSchedule, max: number): MicroSchedule => (attempt, elapsed) =>\n    elapsed < max ? self(attempt, elapsed) : Option.none()\n)\n\n/**\n * Combines two `MicroSchedule`s, by recurring if either schedule wants to\n * recur, using the minimum of the two durations between recurrences.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleUnion: {\n  /**\n   * Combines two `MicroSchedule`s, by recurring if either schedule wants to\n   * recur, using the minimum of the two durations between recurrences.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule\n  /**\n   * Combines two `MicroSchedule`s, by recurring if either schedule wants to\n   * recur, using the minimum of the two durations between recurrences.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (self: MicroSchedule, that: MicroSchedule): MicroSchedule\n} = dual(\n  2,\n  (self: MicroSchedule, that: MicroSchedule): MicroSchedule => (attempt, elapsed) =>\n    Option.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2) => Math.min(d1, d2))\n)\n\n/**\n * Combines two `MicroSchedule`s, by recurring only if both schedules want to\n * recur, using the maximum of the two durations between recurrences.\n *\n * @since 3.4.6\n * @experimental\n * @category scheduling\n */\nexport const scheduleIntersect: {\n  /**\n   * Combines two `MicroSchedule`s, by recurring only if both schedules want to\n   * recur, using the maximum of the two durations between recurrences.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule\n  /**\n   * Combines two `MicroSchedule`s, by recurring only if both schedules want to\n   * recur, using the maximum of the two durations between recurrences.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category scheduling\n   */\n  (self: MicroSchedule, that: MicroSchedule): MicroSchedule\n} = dual(\n  2,\n  (self: MicroSchedule, that: MicroSchedule): MicroSchedule => (attempt, elapsed) =>\n    Option.zipWith(self(attempt, elapsed), that(attempt, elapsed), (d1, d2) => Math.max(d1, d2))\n)\n\n// ----------------------------------------------------------------------------\n// error handling\n// ----------------------------------------------------------------------------\n\n/**\n * Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\n * recover from any kind of cause.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const catchAllCause: {\n  // ----------------------------------------------------------------------------\n  // error handling\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\n   * recover from any kind of cause.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>\n  // ----------------------------------------------------------------------------\n  // error handling\n  // ----------------------------------------------------------------------------\n\n  /**\n   * Catch the full `MicroCause` object of the given `Micro` effect, allowing you to\n   * recover from any kind of cause.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): Micro<A | B, E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): Micro<A | B, E2, R | R2> => {\n    const onFailure = Object.create(OnFailureProto)\n    onFailure[args] = self\n    onFailure[failureCont] = f\n    return onFailure\n  }\n)\nconst OnFailureProto = makePrimitiveProto({\n  op: \"OnFailure\",\n  eval(this: any, fiber: MicroFiberImpl): Primitive {\n    fiber._stack.push(this as any)\n    return this[args]\n  }\n})\n\n/**\n * Selectively catch a `MicroCause` object of the given `Micro` effect,\n * using the provided predicate to determine if the failure should be caught.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const catchCauseIf: {\n  /**\n   * Selectively catch a `MicroCause` object of the given `Micro` effect,\n   * using the provided predicate to determine if the failure should be caught.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2, EB extends MicroCause<E>>(\n    refinement: Refinement<MicroCause<E>, EB>,\n    f: (cause: EB) => Micro<B, E2, R2>\n  ): <A, R>(\n    self: Micro<A, E, R>\n  ) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>\n  /**\n   * Selectively catch a `MicroCause` object of the given `Micro` effect,\n   * using the provided predicate to determine if the failure should be caught.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(\n    predicate: Predicate<MicroCause<NoInfer<E>>>,\n    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>\n  /**\n   * Selectively catch a `MicroCause` object of the given `Micro` effect,\n   * using the provided predicate to determine if the failure should be caught.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2, EB extends MicroCause<E>>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<MicroCause<E>, EB>,\n    f: (cause: EB) => Micro<B, E2, R2>\n  ): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>\n  /**\n   * Selectively catch a `MicroCause` object of the given `Micro` effect,\n   * using the provided predicate to determine if the failure should be caught.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    predicate: Predicate<MicroCause<NoInfer<E>>>,\n    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): Micro<A | B, E | E2, R | R2>\n} = dual(\n  3,\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    predicate: Predicate<MicroCause<E>>,\n    f: (cause: MicroCause<E>) => Micro<B, E2, R2>\n  ): Micro<A | B, E | E2, R | R2> =>\n    catchAllCause(self, (cause) => predicate(cause) ? f(cause) : failCause(cause) as any)\n)\n\n/**\n * Catch the error of the given `Micro` effect, allowing you to recover from it.\n *\n * It only catches expected errors.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const catchAll: {\n  /**\n   * Catch the error of the given `Micro` effect, allowing you to recover from it.\n   *\n   * It only catches expected errors.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>\n  /**\n   * Catch the error of the given `Micro` effect, allowing you to recover from it.\n   *\n   * It only catches expected errors.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    f: (a: NoInfer<E>) => Micro<B, E2, R2>\n  ): Micro<A | B, E2, R | R2> => catchCauseIf(self, causeIsFail, (cause) => f(cause.error))\n)\n\n/**\n * Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const catchAllDefect: {\n  /**\n   * Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>\n  /**\n   * Catch any unexpected errors of the given `Micro` effect, allowing you to recover from them.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2> =>\n    catchCauseIf(self, causeIsDie, (die) => f(die.defect))\n)\n\n/**\n * Perform a side effect using the full `MicroCause` object of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const tapErrorCause: {\n  /**\n   * Perform a side effect using the full `MicroCause` object of the given `Micro`.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>\n  /**\n   * Perform a side effect using the full `MicroCause` object of the given `Micro`.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): Micro<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): Micro<A, E | E2, R | R2> => tapErrorCauseIf(self, constTrue, f)\n)\n\n/**\n * Perform a side effect using if a `MicroCause` object matches the specified\n * predicate.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const tapErrorCauseIf: {\n  /**\n   * Perform a side effect using if a `MicroCause` object matches the specified\n   * predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>\n  /**\n   * Perform a side effect using if a `MicroCause` object matches the specified\n   * predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(\n    predicate: (cause: NoInfer<MicroCause<E>>) => boolean,\n    f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>\n  /**\n   * Perform a side effect using if a `MicroCause` object matches the specified\n   * predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2, EB extends MicroCause<E>>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<MicroCause<E>, EB>,\n    f: (a: EB) => Micro<B, E2, R2>\n  ): Micro<A, E | E2, R | R2>\n  /**\n   * Perform a side effect using if a `MicroCause` object matches the specified\n   * predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(\n    self: Micro<A, E, R>,\n    predicate: (cause: NoInfer<MicroCause<E>>) => boolean,\n    f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>\n  ): Micro<A, E | E2, R | R2>\n} = dual(\n  3,\n  <A, E, R, B, E2, R2, EB extends MicroCause<E>>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<MicroCause<E>, EB>,\n    f: (a: EB) => Micro<B, E2, R2>\n  ): Micro<A, E | E2, R | R2> => catchCauseIf(self, refinement, (cause) => andThen(f(cause), failCause(cause)))\n)\n\n/**\n * Perform a side effect from expected errors of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const tapError: {\n  /**\n   * Perform a side effect from expected errors of the given `Micro`.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>\n  /**\n   * Perform a side effect from expected errors of the given `Micro`.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2> =>\n    tapErrorCauseIf(self, causeIsFail, (fail) => f(fail.error))\n)\n\n/**\n * Perform a side effect from unexpected errors of the given `Micro`.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const tapDefect: {\n  /**\n   * Perform a side effect from unexpected errors of the given `Micro`.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>\n  /**\n   * Perform a side effect from unexpected errors of the given `Micro`.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2> =>\n    tapErrorCauseIf(self, causeIsDie, (die) => f(die.defect))\n)\n\n/**\n * Catch any expected errors that match the specified predicate.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const catchIf: {\n  /**\n   * Catch any expected errors that match the specified predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  /**\n   * Catch any expected errors that match the specified predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>\n  /**\n   * Catch any expected errors that match the specified predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Micro<A2, E2, R2>\n  ): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>\n  /**\n   * Catch any expected errors that match the specified predicate.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Micro<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Micro<A2, E2, R2>\n  ): Micro<A | A2, E | E2, R | R2>\n} = dual(\n  3,\n  <A, E, R, A2, E2, R2>(\n    self: Micro<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Micro<A2, E2, R2>\n  ): Micro<A | A2, E | E2, R | R2> =>\n    catchCauseIf(\n      self,\n      (f): f is MicroCause.Fail<E> => causeIsFail(f) && predicate(f.error),\n      (fail) => f(fail.error)\n    )\n)\n\n/**\n * Recovers from the specified tagged error.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const catchTag: {\n  /**\n   * Recovers from the specified tagged error.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K }>) => Micro<A1, E1, R1>): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K }>, R1 | R>\n  /**\n   * Recovers from the specified tagged error.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, K extends E extends { _tag: string } ? E[\"_tag\"] : never, R1, E1, A1>(\n    self: Micro<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Micro<A1, E1, R1>\n  ): Micro<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1>\n} = dual(3, <A, E, R, K extends E extends { _tag: string } ? E[\"_tag\"] : never, R1, E1, A1>(\n  self: Micro<A, E, R>,\n  k: K,\n  f: (e: Extract<E, { _tag: K }>) => Micro<A1, E1, R1>\n): Micro<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1> =>\n  catchIf(self, isTagged(k) as Refinement<E, Extract<E, { _tag: K }>>, f) as any)\n\n/**\n * Transform the full `MicroCause` object of the given `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category error handling\n */\nexport const mapErrorCause: {\n  /**\n   * Transform the full `MicroCause` object of the given `Micro` effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>\n  /**\n   * Transform the full `MicroCause` object of the given `Micro` effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R> =>\n    catchAllCause(self, (cause) => failCause(f(cause)))\n)\n\n/**\n * Transform any expected errors of the given `Micro` effect.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const mapError: {\n  /**\n   * Transform any expected errors of the given `Micro` effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>\n  /**\n   * Transform any expected errors of the given `Micro` effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R> => catchAll(self, (error) => fail(f(error)))\n)\n\n/**\n * Elevate any expected errors of the given `Micro` effect to unexpected errors,\n * resulting in an error type of `never`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const orDie = <A, E, R>(self: Micro<A, E, R>): Micro<A, never, R> => catchAll(self, die)\n\n/**\n * Recover from all errors by succeeding with the given value.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const orElseSucceed: {\n  /**\n   * Recover from all errors by succeeding with the given value.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>\n  /**\n   * Recover from all errors by succeeding with the given value.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>\n} = dual(\n  2,\n  <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R> => catchAll(self, (_) => sync(f))\n)\n\n/**\n * Ignore any expected errors of the given `Micro` effect, returning `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const ignore = <A, E, R>(self: Micro<A, E, R>): Micro<void, never, R> =>\n  matchEffect(self, { onFailure: (_) => void_, onSuccess: (_) => void_ })\n\n/**\n * Ignore any expected errors of the given `Micro` effect, returning `void`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const ignoreLogged = <A, E, R>(self: Micro<A, E, R>): Micro<void, never, R> =>\n  matchEffect(self, {\n    // eslint-disable-next-line no-console\n    onFailure: (error) => sync(() => console.error(error)),\n    onSuccess: (_) => void_\n  })\n\n/**\n * Replace the success value of the given `Micro` effect with an `Option`,\n * wrapping the success value in `Some` and returning `None` if the effect fails\n * with an expected error.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const option = <A, E, R>(self: Micro<A, E, R>): Micro<Option.Option<A>, never, R> =>\n  match(self, { onFailure: Option.none, onSuccess: Option.some })\n\n/**\n * Replace the success value of the given `Micro` effect with an `Either`,\n * wrapping the success value in `Right` and wrapping any expected errors with\n * a `Left`.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const either = <A, E, R>(self: Micro<A, E, R>): Micro<Either.Either<A, E>, never, R> =>\n  match(self, { onFailure: Either.left, onSuccess: Either.right })\n\n/**\n * Retry the given `Micro` effect using the provided options.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const retry: {\n  /**\n   * Retry the given `Micro` effect using the provided options.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E>(\n    options?: {\n      while?: Predicate<E> | undefined\n      times?: number | undefined\n      schedule?: MicroSchedule | undefined\n    } | undefined\n  ): <R>(self: Micro<A, E, R>) => Micro<A, E, R>\n  /**\n   * Retry the given `Micro` effect using the provided options.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R>(\n    self: Micro<A, E, R>,\n    options?: {\n      while?: Predicate<E> | undefined\n      times?: number | undefined\n      schedule?: MicroSchedule | undefined\n    } | undefined\n  ): Micro<A, E, R>\n} = dual((args) => isMicro(args[0]), <A, E, R>(\n  self: Micro<A, E, R>,\n  options?: {\n    while?: Predicate<E> | undefined\n    times?: number | undefined\n    schedule?: MicroSchedule | undefined\n  } | undefined\n): Micro<A, E, R> =>\n  repeatExit(self, {\n    ...options,\n    while: (exit) =>\n      exit._tag === \"Failure\" && exit.cause._tag === \"Fail\" &&\n      (options?.while === undefined || options.while(exit.cause.error))\n  }))\n\n/**\n * Add a stack trace to any failures that occur in the effect. The trace will be\n * added to the `traces` field of the `MicroCause` object.\n *\n * @since 3.4.0\n * @experimental\n * @category error handling\n */\nexport const withTrace: {\n  /**\n   * Add a stack trace to any failures that occur in the effect. The trace will be\n   * added to the `traces` field of the `MicroCause` object.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>\n  /**\n   * Add a stack trace to any failures that occur in the effect. The trace will be\n   * added to the `traces` field of the `MicroCause` object.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category error handling\n   */\n  <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>\n} = function() {\n  const prevLimit = globalThis.Error.stackTraceLimit\n  globalThis.Error.stackTraceLimit = 2\n  const error = new globalThis.Error()\n  globalThis.Error.stackTraceLimit = prevLimit\n  function generate(name: string, cause: MicroCause<any>) {\n    const stack = error.stack\n    if (!stack) {\n      return cause\n    }\n    const line = stack.split(\"\\n\")[2]?.trim().replace(/^at /, \"\")\n    if (!line) {\n      return cause\n    }\n    const lineMatch = line.match(/\\((.*)\\)$/)\n    return causeWithTrace(cause, `at ${name} (${lineMatch ? lineMatch[1] : line})`)\n  }\n  const f = (name: string) => (self: Micro<any, any, any>) => onError(self, (cause) => failCause(generate(name, cause)))\n  if (arguments.length === 2) {\n    return f(arguments[1])(arguments[0])\n  }\n  return f(arguments[0])\n} as any\n\n// ----------------------------------------------------------------------------\n// pattern matching\n// ----------------------------------------------------------------------------\n\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */\nexport const matchCauseEffect: {\n  // ----------------------------------------------------------------------------\n  // pattern matching\n  // ----------------------------------------------------------------------------\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category pattern matching\n   */\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>\n      readonly onSuccess: (a: A) => Micro<A3, E3, R3>\n    }\n  ): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, E2 | E3, R2 | R3 | R>\n  // ----------------------------------------------------------------------------\n  // pattern matching\n  // ----------------------------------------------------------------------------\n\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category pattern matching\n   */\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>\n      readonly onSuccess: (a: A) => Micro<A3, E3, R3>\n    }\n  ): Micro<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (cause: MicroCause<E>) => Micro<A2, E2, R2>\n      readonly onSuccess: (a: A) => Micro<A3, E3, R3>\n    }\n  ): Micro<A2 | A3, E2 | E3, R2 | R3 | R> => {\n    const primitive = Object.create(OnSuccessAndFailureProto)\n    primitive[args] = self\n    primitive[successCont] = options.onSuccess\n    primitive[failureCont] = options.onFailure\n    return primitive\n  }\n)\nconst OnSuccessAndFailureProto = makePrimitiveProto({\n  op: \"OnSuccessAndFailure\",\n  eval(this: any, fiber: MicroFiberImpl): Primitive {\n    fiber._stack.push(this)\n    return this[args]\n  }\n})\n\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */\nexport const matchCause: {\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category pattern matching\n   */\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: MicroCause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, never, R>\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category pattern matching\n   */\n  <A, E, R, A2, A3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (cause: MicroCause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Micro<A2 | A3, never, R>\n} = dual(\n  2,\n  <A, E, R, A2, A3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (cause: MicroCause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Micro<A2 | A3, never, R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => sync(() => options.onFailure(cause)),\n      onSuccess: (value) => sync(() => options.onSuccess(value))\n    })\n)\n\n/**\n * @since 3.4.6\n * @experimental\n * @category pattern matching\n */\nexport const matchEffect: {\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category pattern matching\n   */\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Micro<A2, E2, R2>\n      readonly onSuccess: (a: A) => Micro<A3, E3, R3>\n    }\n  ): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, E2 | E3, R2 | R3 | R>\n  /**\n   * @since 3.4.6\n   * @experimental\n   * @category pattern matching\n   */\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Micro<A2, E2, R2>\n      readonly onSuccess: (a: A) => Micro<A3, E3, R3>\n    }\n  ): Micro<A2 | A3, E2 | E3, R2 | R3 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Micro<A2, E2, R2>\n      readonly onSuccess: (a: A) => Micro<A3, E3, R3>\n    }\n  ): Micro<A2 | A3, E2 | E3, R2 | R3 | R> =>\n    matchCauseEffect(self, {\n      onFailure: (cause) => cause._tag === \"Fail\" ? options.onFailure(cause.error) : failCause(cause),\n      onSuccess: options.onSuccess\n    })\n)\n\n/**\n * @since 3.4.0\n * @experimental\n * @category pattern matching\n */\nexport const match: {\n  /**\n   * @since 3.4.0\n   * @experimental\n   * @category pattern matching\n   */\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): <R>(self: Micro<A, E, R>) => Micro<A2 | A3, never, R>\n  /**\n   * @since 3.4.0\n   * @experimental\n   * @category pattern matching\n   */\n  <A, E, R, A2, A3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): Micro<A2 | A3, never, R>\n} = dual(\n  2,\n  <A, E, R, A2, A3>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): Micro<A2 | A3, never, R> =>\n    matchEffect(self, {\n      onFailure: (error) => sync(() => options.onFailure(error)),\n      onSuccess: (value) => sync(() => options.onSuccess(value))\n    })\n)\n\n// ----------------------------------------------------------------------------\n// delays & timeouts\n// ----------------------------------------------------------------------------\n\n/**\n * Create a `Micro` effect that will sleep for the specified duration.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nexport const sleep = (millis: number): Micro<void> =>\n  async((resume) => {\n    const timeout = setTimeout(() => {\n      resume(void_)\n    }, millis)\n    return sync(() => {\n      clearTimeout(timeout)\n    })\n  })\n\n/**\n * Returns an effect that will delay the execution of this effect by the\n * specified duration.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nexport const delay: {\n  /**\n   * Returns an effect that will delay the execution of this effect by the\n   * specified duration.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>\n  /**\n   * Returns an effect that will delay the execution of this effect by the\n   * specified duration.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R> => andThen(sleep(millis), self)\n)\n\n/**\n * Returns an effect that will timeout this effect, that will execute the\n * fallback effect if the timeout elapses before the effect has produced a value.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nexport const timeoutOrElse: {\n  /**\n   * Returns an effect that will timeout this effect, that will execute the\n   * fallback effect if the timeout elapses before the effect has produced a value.\n   *\n   * If the timeout elapses, the running effect will be safely interrupted.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  <A2, E2, R2>(\n    options: {\n      readonly duration: number\n      readonly onTimeout: LazyArg<Micro<A2, E2, R2>>\n    }\n  ): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>\n  /**\n   * Returns an effect that will timeout this effect, that will execute the\n   * fallback effect if the timeout elapses before the effect has produced a value.\n   *\n   * If the timeout elapses, the running effect will be safely interrupted.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Micro<A, E, R>,\n    options: {\n      readonly duration: number\n      readonly onTimeout: LazyArg<Micro<A2, E2, R2>>\n    }\n  ): Micro<A | A2, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, options: {\n    readonly duration: number\n    readonly onTimeout: LazyArg<Micro<A2, E2, R2>>\n  }): Micro<A | A2, E | E2, R | R2> =>\n    raceFirst(self, andThen(interruptible(sleep(options.duration)), options.onTimeout))\n)\n\n/**\n * Returns an effect that will timeout this effect, that will fail with a\n * `TimeoutException` if the timeout elapses before the effect has produced a\n * value.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nexport const timeout: {\n  /**\n   * Returns an effect that will timeout this effect, that will fail with a\n   * `TimeoutException` if the timeout elapses before the effect has produced a\n   * value.\n   *\n   * If the timeout elapses, the running effect will be safely interrupted.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>\n  /**\n   * Returns an effect that will timeout this effect, that will fail with a\n   * `TimeoutException` if the timeout elapses before the effect has produced a\n   * value.\n   *\n   * If the timeout elapses, the running effect will be safely interrupted.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>\n} = dual(\n  2,\n  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R> =>\n    timeoutOrElse(self, { duration: millis, onTimeout: () => fail(new TimeoutException()) })\n)\n\n/**\n * Returns an effect that will timeout this effect, succeeding with a `None`\n * if the timeout elapses before the effect has produced a value; and `Some` of\n * the produced value otherwise.\n *\n * If the timeout elapses, the running effect will be safely interrupted.\n *\n * @since 3.4.0\n * @experimental\n * @category delays & timeouts\n */\nexport const timeoutOption: {\n  /**\n   * Returns an effect that will timeout this effect, succeeding with a `None`\n   * if the timeout elapses before the effect has produced a value; and `Some` of\n   * the produced value otherwise.\n   *\n   * If the timeout elapses, the running effect will be safely interrupted.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>\n  /**\n   * Returns an effect that will timeout this effect, succeeding with a `None`\n   * if the timeout elapses before the effect has produced a value; and `Some` of\n   * the produced value otherwise.\n   *\n   * If the timeout elapses, the running effect will be safely interrupted.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category delays & timeouts\n   */\n  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R> =>\n    raceFirst(\n      asSome(self),\n      as(interruptible(sleep(millis)), Option.none())\n    )\n)\n\n// ----------------------------------------------------------------------------\n// resources & finalization\n// ----------------------------------------------------------------------------\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const MicroScopeTypeId: unique symbol = Symbol.for(\"effect/Micro/MicroScope\")\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport type MicroScopeTypeId = typeof MicroScopeTypeId\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport interface MicroScope {\n  readonly [MicroScopeTypeId]: MicroScopeTypeId\n  readonly addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void>\n  readonly fork: Micro<MicroScope.Closeable>\n}\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport declare namespace MicroScope {\n  /**\n   * @since 3.4.0\n   * @experimental\n   * @category resources & finalization\n   */\n  export interface Closeable extends MicroScope {\n    readonly close: (exit: MicroExit<any, any>) => Micro<void>\n  }\n}\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const MicroScope: Context.Tag<MicroScope, MicroScope> = Context.GenericTag<MicroScope>(\"effect/Micro/MicroScope\")\n\nclass MicroScopeImpl implements MicroScope.Closeable {\n  readonly [MicroScopeTypeId]: MicroScopeTypeId\n  state: {\n    readonly _tag: \"Open\"\n    readonly finalizers: Set<(exit: MicroExit<any, any>) => Micro<void>>\n  } | {\n    readonly _tag: \"Closed\"\n    readonly exit: MicroExit<any, any>\n  } = { _tag: \"Open\", finalizers: new Set() }\n\n  constructor() {\n    this[MicroScopeTypeId] = MicroScopeTypeId\n  }\n\n  unsafeAddFinalizer(finalizer: (exit: MicroExit<any, any>) => Micro<void>): void {\n    if (this.state._tag === \"Open\") {\n      this.state.finalizers.add(finalizer)\n    }\n  }\n  addFinalizer(finalizer: (exit: MicroExit<any, any>) => Micro<void>): Micro<void> {\n    return suspend(() => {\n      if (this.state._tag === \"Open\") {\n        this.state.finalizers.add(finalizer)\n        return void_\n      }\n      return finalizer(this.state.exit)\n    })\n  }\n  unsafeRemoveFinalizer(finalizer: (exit: MicroExit<any, any>) => Micro<void>): void {\n    if (this.state._tag === \"Open\") {\n      this.state.finalizers.delete(finalizer)\n    }\n  }\n  close(microExit: MicroExit<any, any>): Micro<void> {\n    return suspend(() => {\n      if (this.state._tag === \"Open\") {\n        const finalizers = Array.from(this.state.finalizers).reverse()\n        this.state = { _tag: \"Closed\", exit: microExit }\n        return flatMap(\n          forEach(finalizers, (finalizer) => exit(finalizer(microExit))),\n          exitVoidAll\n        )\n      }\n      return void_\n    })\n  }\n  get fork() {\n    return sync(() => {\n      const newScope = new MicroScopeImpl()\n      if (this.state._tag === \"Closed\") {\n        newScope.state = this.state\n        return newScope\n      }\n      function fin(exit: MicroExit<any, any>) {\n        return newScope.close(exit)\n      }\n      this.state.finalizers.add(fin)\n      newScope.unsafeAddFinalizer((_) => sync(() => this.unsafeRemoveFinalizer(fin)))\n      return newScope\n    })\n  }\n}\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const scopeMake: Micro<MicroScope.Closeable> = sync(() => new MicroScopeImpl())\n\n/**\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const scopeUnsafeMake = (): MicroScope.Closeable => new MicroScopeImpl()\n\n/**\n * Access the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const scope: Micro<MicroScope, never, MicroScope> = service(MicroScope)\n\n/**\n * Provide a `MicroScope` to an effect.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const provideScope: {\n  /**\n   * Provide a `MicroScope` to an effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category resources & finalization\n   */\n  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>\n  /**\n   * Provide a `MicroScope` to an effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>>\n} = dual(\n  2,\n  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<A, E, Exclude<R, MicroScope>> =>\n    provideService(self, MicroScope, scope)\n)\n\n/**\n * Provide a `MicroScope` to the given effect, closing it after the effect has\n * finished executing.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const scoped = <A, E, R>(self: Micro<A, E, R>): Micro<A, E, Exclude<R, MicroScope>> =>\n  suspend(() => {\n    const scope = new MicroScopeImpl()\n    return onExit(provideService(self, MicroScope, scope), (exit) => scope.close(exit))\n  })\n\n/**\n * Create a resource with a cleanup `Micro` effect, ensuring the cleanup is\n * executed when the `MicroScope` is closed.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const acquireRelease = <A, E, R>(\n  acquire: Micro<A, E, R>,\n  release: (a: A, exit: MicroExit<unknown, unknown>) => Micro<void>\n): Micro<A, E, R | MicroScope> =>\n  uninterruptible(flatMap(\n    scope,\n    (scope) => tap(acquire, (a) => scope.addFinalizer((exit) => release(a, exit)))\n  ))\n\n/**\n * Add a finalizer to the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const addFinalizer = (\n  finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>\n): Micro<void, never, MicroScope> => flatMap(scope, (scope) => scope.addFinalizer(finalizer))\n\n/**\n * When the `Micro` effect is completed, run the given finalizer effect with the\n * `MicroExit` of the executed effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nexport const onExit: {\n  /**\n   * When the `Micro` effect is completed, run the given finalizer effect with the\n   * `MicroExit` of the executed effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, XE, XR>(f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>\n  /**\n   * When the `Micro` effect is completed, run the given finalizer effect with the\n   * `MicroExit` of the executed effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>\n} = dual(\n  2,\n  <A, E, R, XE, XR>(\n    self: Micro<A, E, R>,\n    f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR> =>\n    uninterruptibleMask((restore) =>\n      matchCauseEffect(restore(self), {\n        onFailure: (cause) => flatMap(f(exitFailCause(cause)), () => failCause(cause)),\n        onSuccess: (a) => flatMap(f(exitSucceed(a)), () => succeed(a))\n      })\n    )\n)\n\n/**\n * Regardless of the result of the this `Micro` effect, run the finalizer effect.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const ensuring: {\n  /**\n   * Regardless of the result of the this `Micro` effect, run the finalizer effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category resources & finalization\n   */\n  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>\n  /**\n   * Regardless of the result of the this `Micro` effect, run the finalizer effect.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>\n} = dual(\n  2,\n  <A, E, R, XE, XR>(\n    self: Micro<A, E, R>,\n    finalizer: Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR> => onExit(self, (_) => finalizer)\n)\n\n/**\n * When the `Micro` effect is completed, run the given finalizer effect if it\n * matches the specified predicate.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nexport const onExitIf: {\n  /**\n   * When the `Micro` effect is completed, run the given finalizer effect if it\n   * matches the specified predicate.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, XE, XR, B extends MicroExit<A, E>>(\n    refinement: Refinement<MicroExit<A, E>, B>,\n    f: (exit: B) => Micro<void, XE, XR>\n  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>\n  /**\n   * When the `Micro` effect is completed, run the given finalizer effect if it\n   * matches the specified predicate.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, XE, XR>(\n    predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>,\n    f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>\n  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>\n  /**\n   * When the `Micro` effect is completed, run the given finalizer effect if it\n   * matches the specified predicate.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R, XE, XR, B extends MicroExit<A, E>>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<MicroExit<A, E>, B>,\n    f: (exit: B) => Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR>\n  /**\n   * When the `Micro` effect is completed, run the given finalizer effect if it\n   * matches the specified predicate.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R, XE, XR>(\n    self: Micro<A, E, R>,\n    predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>,\n    f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR>\n} = dual(\n  3,\n  <A, E, R, XE, XR, B extends MicroExit<A, E>>(\n    self: Micro<A, E, R>,\n    refinement: Refinement<MicroExit<A, E>, B>,\n    f: (exit: B) => Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR> => onExit(self, (exit) => (refinement(exit) ? f(exit) : exitVoid))\n)\n\n/**\n * When the `Micro` effect fails, run the given finalizer effect with the\n * `MicroCause` of the executed effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nexport const onError: {\n  /**\n   * When the `Micro` effect fails, run the given finalizer effect with the\n   * `MicroCause` of the executed effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, XE, XR>(f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>\n  /**\n   * When the `Micro` effect fails, run the given finalizer effect with the\n   * `MicroCause` of the executed effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R, XE, XR>(\n    self: Micro<A, E, R>,\n    f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR>\n} = dual(\n  2,\n  <A, E, R, XE, XR>(\n    self: Micro<A, E, R>,\n    f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>\n  ): Micro<A, E | XE, R | XR> => onExitIf(self, exitIsFailure, (exit) => f(exit.cause))\n)\n\n/**\n * If this `Micro` effect is aborted, run the finalizer effect.\n *\n * @since 3.4.6\n * @experimental\n * @category resources & finalization\n */\nexport const onInterrupt: {\n  /**\n   * If this `Micro` effect is aborted, run the finalizer effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>\n  /**\n   * If this `Micro` effect is aborted, run the finalizer effect.\n   *\n   * @since 3.4.6\n   * @experimental\n   * @category resources & finalization\n   */\n  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>\n} = dual(\n  2,\n  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR> =>\n    onExitIf(self, exitIsInterrupt, (_) => finalizer)\n)\n\n/**\n * Acquire a resource, use it, and then release the resource when the `use`\n * effect has completed.\n *\n * @since 3.4.0\n * @experimental\n * @category resources & finalization\n */\nexport const acquireUseRelease = <Resource, E, R, A, E2, R2, E3, R3>(\n  acquire: Micro<Resource, E, R>,\n  use: (a: Resource) => Micro<A, E2, R2>,\n  release: (a: Resource, exit: MicroExit<A, E2>) => Micro<void, E3, R3>\n): Micro<A, E | E2 | E3, R | R2 | R3> =>\n  uninterruptibleMask((restore) =>\n    flatMap(\n      acquire,\n      (a) =>\n        flatMap(\n          exit(restore(use(a))),\n          (exit) => andThen(release(a, exit), exit)\n        )\n    )\n  )\n\n// ----------------------------------------------------------------------------\n// interruption\n// ----------------------------------------------------------------------------\n\n/**\n * Abort the current `Micro` effect.\n *\n * @since 3.4.6\n * @experimental\n * @category interruption\n */\nexport const interrupt: Micro<never> = failCause(causeInterrupt())\n\n/**\n * Flag the effect as uninterruptible, which means that when the effect is\n * interrupted, it will be allowed to continue running until completion.\n *\n * @since 3.4.0\n * @experimental\n * @category flags\n */\nexport const uninterruptible = <A, E, R>(\n  self: Micro<A, E, R>\n): Micro<A, E, R> =>\n  withMicroFiber((fiber) => {\n    if (!fiber.interruptible) return self\n    fiber.interruptible = false\n    fiber._stack.push(setInterruptible(true))\n    return self\n  })\n\nconst setInterruptible: (interruptible: boolean) => Primitive = makePrimitive({\n  op: \"SetInterruptible\",\n  ensure(fiber) {\n    fiber.interruptible = this[args]\n    if (fiber._interrupted && fiber.interruptible) {\n      return () => exitInterrupt\n    }\n  }\n})\n\n/**\n * Flag the effect as interruptible, which means that when the effect is\n * interrupted, it will be interrupted immediately.\n *\n * @since 3.4.0\n * @experimental\n * @category flags\n */\nexport const interruptible = <A, E, R>(\n  self: Micro<A, E, R>\n): Micro<A, E, R> =>\n  withMicroFiber((fiber) => {\n    if (fiber.interruptible) return self\n    fiber.interruptible = true\n    fiber._stack.push(setInterruptible(false))\n    if (fiber._interrupted) return exitInterrupt\n    return self\n  })\n\n/**\n * Wrap the given `Micro` effect in an uninterruptible region, preventing the\n * effect from being aborted.\n *\n * You can use the `restore` function to restore a `Micro` effect to the\n * interruptibility state before the `uninterruptibleMask` was applied.\n *\n * @example\n * ```ts\n * import * as Micro from \"effect/Micro\"\n *\n * Micro.uninterruptibleMask((restore) =>\n *   Micro.sleep(1000).pipe( // uninterruptible\n *     Micro.andThen(restore(Micro.sleep(1000))) // interruptible\n *   )\n * )\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category interruption\n */\nexport const uninterruptibleMask = <A, E, R>(\n  f: (\n    restore: <A, E, R>(effect: Micro<A, E, R>) => Micro<A, E, R>\n  ) => Micro<A, E, R>\n): Micro<A, E, R> =>\n  withMicroFiber((fiber) => {\n    if (!fiber.interruptible) return f(identity)\n    fiber.interruptible = false\n    fiber._stack.push(setInterruptible(true))\n    return f(interruptible)\n  })\n\n// ========================================================================\n// collecting & elements\n// ========================================================================\n\n/**\n * @since 3.4.0\n * @experimental\n */\nexport declare namespace All {\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type MicroAny = Micro<any, any, any>\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type ReturnIterable<T extends Iterable<MicroAny>, Discard extends boolean> = [T] extends\n    [Iterable<Micro<infer A, infer E, infer R>>] ? Micro<\n      Discard extends true ? void : Array<A>,\n      E,\n      R\n    >\n    : never\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type ReturnTuple<T extends ReadonlyArray<unknown>, Discard extends boolean> = Micro<\n    Discard extends true ? void\n      : T[number] extends never ? []\n      : { -readonly [K in keyof T]: T[K] extends Micro<infer _A, infer _E, infer _R> ? _A : never },\n    T[number] extends never ? never\n      : T[number] extends Micro<infer _A, infer _E, infer _R> ? _E\n      : never,\n    T[number] extends never ? never\n      : T[number] extends Micro<infer _A, infer _E, infer _R> ? _R\n      : never\n  > extends infer X ? X : never\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type ReturnObject<T, Discard extends boolean> = [T] extends [{ [K: string]: MicroAny }] ? Micro<\n      Discard extends true ? void :\n        { -readonly [K in keyof T]: [T[K]] extends [Micro<infer _A, infer _E, infer _R>] ? _A : never },\n      keyof T extends never ? never\n        : T[keyof T] extends Micro<infer _A, infer _E, infer _R> ? _E\n        : never,\n      keyof T extends never ? never\n        : T[keyof T] extends Micro<infer _A, infer _E, infer _R> ? _R\n        : never\n    >\n    : never\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type IsDiscard<A> = [Extract<A, { readonly discard: true }>] extends [never] ? false : true\n\n  /**\n   * @since 3.4.0\n   * @experimental\n   */\n  export type Return<\n    Arg extends Iterable<MicroAny> | Record<string, MicroAny>,\n    O extends NoExcessProperties<{\n      readonly concurrency?: Concurrency | undefined\n      readonly discard?: boolean | undefined\n    }, O>\n  > = [Arg] extends [ReadonlyArray<MicroAny>] ? ReturnTuple<Arg, IsDiscard<O>>\n    : [Arg] extends [Iterable<MicroAny>] ? ReturnIterable<Arg, IsDiscard<O>>\n    : [Arg] extends [Record<string, MicroAny>] ? ReturnObject<Arg, IsDiscard<O>>\n    : never\n}\n\n/**\n * Runs all the provided effects in sequence respecting the structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record / struct.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nexport const all = <\n  const Arg extends Iterable<Micro<any, any, any>> | Record<string, Micro<any, any, any>>,\n  O extends NoExcessProperties<{\n    readonly concurrency?: Concurrency | undefined\n    readonly discard?: boolean | undefined\n  }, O>\n>(arg: Arg, options?: O): All.Return<Arg, O> => {\n  if (Array.isArray(arg) || isIterable(arg)) {\n    return (forEach as any)(arg, identity, options)\n  } else if (options?.discard) {\n    return (forEach as any)(Object.values(arg), identity, options)\n  }\n  return suspend(() => {\n    const out: Record<string, unknown> = {}\n    return as(\n      forEach(Object.entries(arg), ([key, effect]) =>\n        map(effect, (value) => {\n          out[key] = value\n        }), {\n        discard: true,\n        concurrency: options?.concurrency\n      }),\n      out\n    )\n  }) as any\n}\n\n/**\n * @since 3.11.0\n * @experimental\n * @category collecting & elements\n */\nexport const whileLoop: <A, E, R>(options: {\n  readonly while: LazyArg<boolean>\n  readonly body: LazyArg<Micro<A, E, R>>\n  readonly step: (a: A) => void\n}) => Micro<void, E, R> = makePrimitive({\n  op: \"While\",\n  contA(value, fiber) {\n    this[args].step(value)\n    if (this[args].while()) {\n      fiber._stack.push(this)\n      return this[args].body()\n    }\n    return exitVoid\n  },\n  eval(fiber) {\n    if (this[args].while()) {\n      fiber._stack.push(this)\n      return this[args].body()\n    }\n    return exitVoid\n  }\n})\n\n/**\n * For each element of the provided iterable, run the effect and collect the\n * results.\n *\n * If the `discard` option is set to `true`, the results will be discarded and\n * the effect will return `void`.\n *\n * The `concurrency` option can be set to control how many effects are run\n * concurrently. By default, the effects are run sequentially.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nexport const forEach: {\n  /**\n   * For each element of the provided iterable, run the effect and collect the\n   * results.\n   *\n   * If the `discard` option is set to `true`, the results will be discarded and\n   * the effect will return `void`.\n   *\n   * The `concurrency` option can be set to control how many effects are run\n   * concurrently. By default, the effects are run sequentially.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category collecting & elements\n   */\n  <A, B, E, R>(\n    iterable: Iterable<A>,\n    f: (a: A, index: number) => Micro<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard?: false | undefined\n    }\n  ): Micro<Array<B>, E, R>\n  /**\n   * For each element of the provided iterable, run the effect and collect the\n   * results.\n   *\n   * If the `discard` option is set to `true`, the results will be discarded and\n   * the effect will return `void`.\n   *\n   * The `concurrency` option can be set to control how many effects are run\n   * concurrently. By default, the effects are run sequentially.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category collecting & elements\n   */\n  <A, B, E, R>(\n    iterable: Iterable<A>,\n    f: (a: A, index: number) => Micro<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly discard: true\n    }\n  ): Micro<void, E, R>\n} = <\n  A,\n  B,\n  E,\n  R\n>(iterable: Iterable<A>, f: (a: A, index: number) => Micro<B, E, R>, options?: {\n  readonly concurrency?: Concurrency | undefined\n  readonly discard?: boolean | undefined\n}): Micro<any, E, R> =>\n  withMicroFiber((parent) => {\n    const concurrencyOption = options?.concurrency === \"inherit\"\n      ? parent.getRef(CurrentConcurrency)\n      : options?.concurrency ?? 1\n    const concurrency = concurrencyOption === \"unbounded\"\n      ? Number.POSITIVE_INFINITY\n      : Math.max(1, concurrencyOption)\n\n    const items = Arr.fromIterable(iterable)\n    let length = items.length\n    if (length === 0) {\n      return options?.discard ? void_ : succeed([])\n    }\n\n    const out: Array<B> | undefined = options?.discard ? undefined : new Array(length)\n    let index = 0\n\n    if (concurrency === 1) {\n      return as(\n        whileLoop({\n          while: () => index < items.length,\n          body: () => f(items[index], index),\n          step: out ?\n            (b) => out[index++] = b :\n            (_) => index++\n        }),\n        out as any\n      )\n    }\n    return async((resume) => {\n      const fibers = new Set<MicroFiber<unknown, unknown>>()\n      let result: MicroExit<any, any> | undefined = undefined\n      let inProgress = 0\n      let doneCount = 0\n      let pumping = false\n      let interrupted = false\n      function pump() {\n        pumping = true\n        while (inProgress < concurrency && index < length) {\n          const currentIndex = index\n          const item = items[currentIndex]\n          index++\n          inProgress++\n          try {\n            const child = unsafeFork(parent, f(item, currentIndex), true, true)\n            fibers.add(child)\n            child.addObserver((exit) => {\n              fibers.delete(child)\n              if (interrupted) {\n                return\n              } else if (exit._tag === \"Failure\") {\n                if (result === undefined) {\n                  result = exit\n                  length = index\n                  fibers.forEach((fiber) => fiber.unsafeInterrupt())\n                }\n              } else if (out !== undefined) {\n                out[currentIndex] = exit.value\n              }\n              doneCount++\n              inProgress--\n              if (doneCount === length) {\n                resume(result ?? succeed(out))\n              } else if (!pumping && inProgress < concurrency) {\n                pump()\n              }\n            })\n          } catch (err) {\n            result = exitDie(err)\n            length = index\n            fibers.forEach((fiber) => fiber.unsafeInterrupt())\n          }\n        }\n        pumping = false\n      }\n      pump()\n\n      return suspend(() => {\n        interrupted = true\n        index = length\n        return fiberInterruptAll(fibers)\n      })\n    })\n  })\n\n/**\n * Effectfully filter the elements of the provided iterable.\n *\n * Use the `concurrency` option to control how many elements are processed\n * concurrently.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nexport const filter = <A, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<boolean, E, R>, options?: {\n  readonly concurrency?: Concurrency | undefined\n  readonly negate?: boolean | undefined\n}): Micro<Array<A>, E, R> =>\n  filterMap(iterable, (a) =>\n    map(f(a), (pass) => {\n      pass = options?.negate ? !pass : pass\n      return pass ? Option.some(a) : Option.none()\n    }), options)\n\n/**\n * Effectfully filter the elements of the provided iterable.\n *\n * Use the `concurrency` option to control how many elements are processed\n * concurrently.\n *\n * @since 3.4.0\n * @experimental\n * @category collecting & elements\n */\nexport const filterMap = <A, B, E, R>(\n  iterable: Iterable<A>,\n  f: (a: NoInfer<A>) => Micro<Option.Option<B>, E, R>,\n  options?: {\n    readonly concurrency?: Concurrency | undefined\n  }\n): Micro<Array<B>, E, R> =>\n  suspend(() => {\n    const out: Array<B> = []\n    return as(\n      forEach(iterable, (a) =>\n        map(f(a), (o) => {\n          if (o._tag === \"Some\") {\n            out.push(o.value)\n          }\n        }), {\n        discard: true,\n        concurrency: options?.concurrency\n      }),\n      out\n    )\n  })\n\n// ----------------------------------------------------------------------------\n// do notation\n// ----------------------------------------------------------------------------\n\n/**\n * Start a do notation block.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */\nexport const Do: Micro<{}> = succeed({})\n\n/**\n * Bind the success value of this `Micro` effect to the provided name.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */\nexport const bindTo: {\n  /**\n   * Bind the success value of this `Micro` effect to the provided name.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category do notation\n   */\n  <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A }, E, R>\n  /**\n   * Bind the success value of this `Micro` effect to the provided name.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category do notation\n   */\n  <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A }, E, R>\n} = doNotation.bindTo<MicroTypeLambda>(map)\n\n/**\n * Bind the success value of this `Micro` effect to the provided name.\n *\n * @since 3.4.0\n * @experimental\n * @category do notation\n */\nexport const bind: {\n  /**\n   * Bind the success value of this `Micro` effect to the provided name.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category do notation\n   */\n  <N extends string, A extends Record<string, any>, B, E2, R2>(name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B }>, E | E2, R | R2>\n  /**\n   * Bind the success value of this `Micro` effect to the provided name.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category do notation\n   */\n  <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): Micro<Simplify<Omit<A, N> & { [K in N]: B }>, E | E2, R | R2>\n} = doNotation.bind<MicroTypeLambda>(map, flatMap)\n\nconst let_: {\n  <N extends string, A extends Record<string, any>, B>(\n    name: N,\n    f: (a: NoInfer<A>) => B\n  ): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B }>, E, R>\n  <A extends Record<string, any>, E, R, B, N extends string>(\n    self: Micro<A, E, R>,\n    name: N,\n    f: (a: NoInfer<A>) => B\n  ): Micro<Simplify<Omit<A, N> & { [K in N]: B }>, E, R>\n} = doNotation.let_<MicroTypeLambda>(map)\n\nexport {\n  /**\n   * Bind the result of a synchronous computation to the given name.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category do notation\n   */\n  let_ as let\n}\n\n// ----------------------------------------------------------------------------\n// fibers & forking\n// ----------------------------------------------------------------------------\n\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * When the parent `Micro` finishes, this `Micro` will be aborted.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */\nexport const fork = <A, E, R>(\n  self: Micro<A, E, R>\n): Micro<MicroFiber<A, E>, never, R> =>\n  withMicroFiber((fiber) => {\n    fiberMiddleware.interruptChildren ??= fiberInterruptChildren\n    return succeed(unsafeFork(fiber, self))\n  })\n\nconst unsafeFork = <FA, FE, A, E, R>(\n  parent: MicroFiberImpl<FA, FE>,\n  effect: Micro<A, E, R>,\n  immediate = false,\n  daemon = false\n): MicroFiber<A, E> => {\n  const child = new MicroFiberImpl<A, E>(parent.context, parent.interruptible)\n  if (!daemon) {\n    parent.children().add(child)\n    child.addObserver(() => parent.children().delete(child))\n  }\n  if (immediate) {\n    child.evaluate(effect as any)\n  } else {\n    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect as any), 0)\n  }\n  return child\n}\n\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * It will not be aborted when the parent `Micro` finishes.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */\nexport const forkDaemon = <A, E, R>(\n  self: Micro<A, E, R>\n): Micro<MicroFiber<A, E>, never, R> => withMicroFiber((fiber) => succeed(unsafeFork(fiber, self, false, true)))\n\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * The lifetime of the handle will be attached to the provided `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */\nexport const forkIn: {\n  /**\n   * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n   * aborted.\n   *\n   * The lifetime of the handle will be attached to the provided `MicroScope`.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category fiber & forking\n   */\n  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>\n  /**\n   * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n   * aborted.\n   *\n   * The lifetime of the handle will be attached to the provided `MicroScope`.\n   *\n   * @since 3.4.0\n   * @experimental\n   * @category fiber & forking\n   */\n  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>\n} = dual(\n  2,\n  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R> =>\n    uninterruptibleMask((restore) =>\n      flatMap(scope.fork, (scope) =>\n        tap(\n          restore(forkDaemon(onExit(self, (exit) => scope.close(exit)))),\n          (fiber) => scope.addFinalizer((_) => fiberInterrupt(fiber))\n        ))\n    )\n)\n\n/**\n * Run the `Micro` effect in a new `MicroFiber` that can be awaited, joined, or\n * aborted.\n *\n * The lifetime of the handle will be attached to the current `MicroScope`.\n *\n * @since 3.4.0\n * @experimental\n * @category fiber & forking\n */\nexport const forkScoped = <A, E, R>(self: Micro<A, E, R>): Micro<MicroFiber<A, E>, never, R | MicroScope> =>\n  flatMap(scope, (scope) => forkIn(self, scope))\n\n// ----------------------------------------------------------------------------\n// execution\n// ----------------------------------------------------------------------------\n\n/**\n * Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,\n * or aborted.\n *\n * You can listen for the result by adding an observer using the handle's\n * `addObserver` method.\n *\n * @example\n * ```ts\n * import * as Micro from \"effect/Micro\"\n *\n * const handle = Micro.succeed(42).pipe(\n *   Micro.delay(1000),\n *   Micro.runFork\n * )\n *\n * handle.addObserver((exit) => {\n *   console.log(exit)\n * })\n * ```\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */\nexport const runFork = <A, E>(\n  effect: Micro<A, E>,\n  options?: {\n    readonly signal?: AbortSignal | undefined\n    readonly scheduler?: MicroScheduler | undefined\n  } | undefined\n): MicroFiberImpl<A, E> => {\n  const fiber = new MicroFiberImpl<A, E>(CurrentScheduler.context(\n    options?.scheduler ?? new MicroSchedulerDefault()\n  ))\n  fiber.evaluate(effect as any)\n  if (options?.signal) {\n    if (options.signal.aborted) {\n      fiber.unsafeInterrupt()\n    } else {\n      const abort = () => fiber.unsafeInterrupt()\n      options.signal.addEventListener(\"abort\", abort, { once: true })\n      fiber.addObserver(() => options.signal!.removeEventListener(\"abort\", abort))\n    }\n  }\n  return fiber\n}\n\n/**\n * Execute the `Micro` effect and return a `Promise` that resolves with the\n * `MicroExit` of the computation.\n *\n * @since 3.4.6\n * @experimental\n * @category execution\n */\nexport const runPromiseExit = <A, E>(\n  effect: Micro<A, E>,\n  options?: {\n    readonly signal?: AbortSignal | undefined\n    readonly scheduler?: MicroScheduler | undefined\n  } | undefined\n): Promise<MicroExit<A, E>> =>\n  new Promise((resolve, _reject) => {\n    const handle = runFork(effect, options)\n    handle.addObserver(resolve)\n  })\n\n/**\n * Execute the `Micro` effect and return a `Promise` that resolves with the\n * successful value of the computation.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */\nexport const runPromise = <A, E>(\n  effect: Micro<A, E>,\n  options?: {\n    readonly signal?: AbortSignal | undefined\n    readonly scheduler?: MicroScheduler | undefined\n  } | undefined\n): Promise<A> =>\n  runPromiseExit(effect, options).then((exit) => {\n    if (exit._tag === \"Failure\") {\n      throw exit.cause\n    }\n    return exit.value\n  })\n\n/**\n * Attempt to execute the `Micro` effect synchronously and return the `MicroExit`.\n *\n * If any asynchronous effects are encountered, the function will return a\n * `CauseDie` containing the `MicroFiber`.\n *\n * @since 3.4.6\n * @experimental\n * @category execution\n */\nexport const runSyncExit = <A, E>(effect: Micro<A, E>): MicroExit<A, E> => {\n  const scheduler = new MicroSchedulerDefault()\n  const fiber = runFork(effect, { scheduler })\n  scheduler.flush()\n  return fiber._exit ?? exitDie(fiber)\n}\n\n/**\n * Attempt to execute the `Micro` effect synchronously and return the success\n * value.\n *\n * @since 3.4.0\n * @experimental\n * @category execution\n */\nexport const runSync = <A, E>(effect: Micro<A, E>): A => {\n  const exit = runSyncExit(effect)\n  if (exit._tag === \"Failure\") throw exit.cause\n  return exit.value\n}\n\n// ----------------------------------------------------------------------------\n// Errors\n// ----------------------------------------------------------------------------\n\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */\nexport interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {\n  readonly [Effectable.EffectTypeId]: Effect.VarianceStruct<never, this, never>\n  readonly [Effectable.StreamTypeId]: Stream.VarianceStruct<never, this, never>\n  readonly [Effectable.SinkTypeId]: Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Effectable.ChannelTypeId]: Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  readonly [TypeId]: Micro.Variance<never, this, never>\n  [Symbol.iterator](): MicroIterator<Micro<never, this, never>>\n}\n\nconst YieldableError: new(message?: string) => YieldableError = (function() {\n  class YieldableError extends globalThis.Error {}\n  // @effect-diagnostics-next-line floatingEffect:off\n  Object.assign(YieldableError.prototype, MicroProto, StructuralPrototype, {\n    [identifier]: \"Failure\",\n    [evaluate]() {\n      return fail(this)\n    },\n    toString(this: Error) {\n      return this.message ? `${this.name}: ${this.message}` : this.name\n    },\n    toJSON() {\n      return { ...this }\n    },\n    [NodeInspectSymbol](this: Error): string {\n      const stack = this.stack\n      if (stack) {\n        return `${this.toString()}\\n${stack.split(\"\\n\").slice(1).join(\"\\n\")}`\n      }\n      return this.toString()\n    }\n  })\n  return YieldableError as any\n})()\n\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */\nexport const Error: new<A extends Record<string, any> = {}>(\n  args: Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => YieldableError & Readonly<A> = (function() {\n  return class extends YieldableError {\n    constructor(args: any) {\n      super()\n      if (args) {\n        Object.assign(this, args)\n      }\n    }\n  } as any\n})()\n\n/**\n * @since 3.4.0\n * @experimental\n * @category errors\n */\nexport const TaggedError = <Tag extends string>(tag: Tag): new<A extends Record<string, any> = {}>(\n  args: Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P] }\n) => YieldableError & { readonly _tag: Tag } & Readonly<A> => {\n  class Base extends Error<{}> {\n    readonly _tag = tag\n  }\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 3.4.4\n * @experimental\n * @category errors\n */\nexport class NoSuchElementException extends TaggedError(\"NoSuchElementException\")<{ message?: string | undefined }> {}\n\n/**\n * Represents a checked exception which occurs when a timeout occurs.\n *\n * @since 3.4.4\n * @experimental\n * @category errors\n */\nexport class TimeoutException extends TaggedError(\"TimeoutException\") {}\n","import type * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { constFalse } from \"../Function.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nconst ClockSymbolKey = \"effect/Clock\"\n\n/** @internal */\nexport const ClockTypeId: Clock.ClockTypeId = Symbol.for(ClockSymbolKey) as Clock.ClockTypeId\n\n/** @internal */\nexport const clockTag: Context.Tag<Clock.Clock, Clock.Clock> = Context.GenericTag(\"effect/Clock\")\n\n/** @internal */\nexport const MAX_TIMER_MILLIS = 2 ** 31 - 1\n\n/** @internal */\nexport const globalClockScheduler: Clock.ClockScheduler = {\n  unsafeSchedule(task: Clock.Task, duration: Duration.Duration): Clock.CancelToken {\n    const millis = Duration.toMillis(duration)\n    // If the duration is greater than the value allowable by the JS timer\n    // functions, treat the value as an infinite duration\n    if (millis > MAX_TIMER_MILLIS) {\n      return constFalse\n    }\n    let completed = false\n    const handle = setTimeout(() => {\n      completed = true\n      task()\n    }, millis)\n    return () => {\n      clearTimeout(handle)\n      return !completed\n    }\n  }\n}\n\nconst performanceNowNanos = (function() {\n  const bigint1e6 = BigInt(1_000_000)\n  if (typeof performance === \"undefined\") {\n    return () => BigInt(Date.now()) * bigint1e6\n  }\n  let origin: bigint\n  return () => {\n    if (origin === undefined) {\n      origin = (BigInt(Date.now()) * bigint1e6) - BigInt(Math.round(performance.now() * 1_000_000))\n    }\n    return origin + BigInt(Math.round(performance.now() * 1000000))\n  }\n})()\nconst processOrPerformanceNow = (function() {\n  const processHrtime =\n    typeof process === \"object\" && \"hrtime\" in process && typeof process.hrtime.bigint === \"function\" ?\n      process.hrtime :\n      undefined\n  if (!processHrtime) {\n    return performanceNowNanos\n  }\n  const origin = performanceNowNanos() - processHrtime.bigint()\n  return () => origin + processHrtime.bigint()\n})()\n\n/** @internal */\nclass ClockImpl implements Clock.Clock {\n  readonly [ClockTypeId]: Clock.ClockTypeId = ClockTypeId\n\n  unsafeCurrentTimeMillis(): number {\n    return Date.now()\n  }\n\n  unsafeCurrentTimeNanos(): bigint {\n    return processOrPerformanceNow()\n  }\n\n  currentTimeMillis: Effect.Effect<number> = core.sync(() => this.unsafeCurrentTimeMillis())\n\n  currentTimeNanos: Effect.Effect<bigint> = core.sync(() => this.unsafeCurrentTimeNanos())\n\n  scheduler(): Effect.Effect<Clock.ClockScheduler> {\n    return core.succeed(globalClockScheduler)\n  }\n\n  sleep(duration: Duration.Duration): Effect.Effect<void> {\n    return core.async<void>((resume) => {\n      const canceler = globalClockScheduler.unsafeSchedule(() => resume(core.void), duration)\n      return core.asVoid(core.sync(canceler))\n    })\n  }\n}\n\n/** @internal */\nexport const make = (): Clock.Clock => new ClockImpl()\n","import { globalValue } from \"../GlobalValue.js\"\nimport type * as Request from \"../Request.js\"\nimport { fiberRefUnsafeMake } from \"./core.js\"\n\n/** @internal */\nexport const currentRequestMap = globalValue(\n  Symbol.for(\"effect/FiberRef/currentRequestMap\"),\n  () => fiberRefUnsafeMake(new Map<any, Request.Entry<any>>())\n)\n","import type { Effect } from \"../Effect.js\"\nimport type { Concurrency } from \"../Types.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nexport const match = <A, E, R>(\n  concurrency: Concurrency | undefined,\n  sequential: () => Effect<A, E, R>,\n  unbounded: () => Effect<A, E, R>,\n  bounded: (limit: number) => Effect<A, E, R>\n): Effect<A, E, R> => {\n  switch (concurrency) {\n    case undefined:\n      return sequential()\n    case \"unbounded\":\n      return unbounded()\n    case \"inherit\":\n      return core.fiberRefGetWith(\n        core.currentConcurrency,\n        (concurrency) =>\n          concurrency === \"unbounded\" ?\n            unbounded() :\n            concurrency > 1 ?\n            bounded(concurrency) :\n            sequential()\n      )\n    default:\n      return concurrency > 1 ? bounded(concurrency) : sequential()\n  }\n}\n\n/** @internal */\nexport const matchSimple = <A, E, R>(\n  concurrency: Concurrency | undefined,\n  sequential: () => Effect<A, E, R>,\n  concurrent: () => Effect<A, E, R>\n): Effect<A, E, R> => {\n  switch (concurrency) {\n    case undefined:\n      return sequential()\n    case \"unbounded\":\n      return concurrent()\n    case \"inherit\":\n      return core.fiberRefGetWith(\n        core.currentConcurrency,\n        (concurrency) =>\n          concurrency === \"unbounded\" || concurrency > 1 ?\n            concurrent() :\n            sequential()\n      )\n    default:\n      return concurrency > 1 ? concurrent() : sequential()\n  }\n}\n","/**\n * This module provides utility functions for working with RegExp in TypeScript.\n *\n * @since 2.0.0\n */\nimport * as predicate from \"./Predicate.js\"\n\n/**\n * Tests if a value is a `RegExp`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { RegExp } from \"effect\"\n *\n * assert.deepStrictEqual(RegExp.isRegExp(/a/), true)\n * assert.deepStrictEqual(RegExp.isRegExp(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 3.9.0\n */\nexport const isRegExp: (input: unknown) => input is RegExp = predicate.isRegExp\n\n/**\n * Escapes special characters in a regular expression pattern.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { RegExp } from \"effect\"\n *\n * assert.deepStrictEqual(RegExp.escape(\"a*b\"), \"a\\\\*b\")\n * ```\n *\n * @since 2.0.0\n */\nexport const escape = (string: string): string => string.replace(/[/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n","import * as RA from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport type * as ConfigError from \"../ConfigError.js\"\nimport * as Either from \"../Either.js\"\nimport { constFalse, constTrue, dual, pipe } from \"../Function.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport * as OpCodes from \"./opCodes/configError.js\"\n\n/** @internal */\nconst ConfigErrorSymbolKey = \"effect/ConfigError\"\n\n/** @internal */\nexport const ConfigErrorTypeId: ConfigError.ConfigErrorTypeId = Symbol.for(\n  ConfigErrorSymbolKey\n) as ConfigError.ConfigErrorTypeId\n\n/** @internal */\nexport const proto = {\n  _tag: \"ConfigError\",\n  [ConfigErrorTypeId]: ConfigErrorTypeId\n}\n\n/** @internal */\nexport const And = (self: ConfigError.ConfigError, that: ConfigError.ConfigError): ConfigError.ConfigError => {\n  const error = Object.create(proto)\n  error._op = OpCodes.OP_AND\n  error.left = self\n  error.right = that\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value(this: ConfigError.And) {\n      return `${this.left} and ${this.right}`\n    }\n  })\n  Object.defineProperty(error, \"message\", {\n    enumerable: false,\n    get(this: ConfigError.And) {\n      return this.toString()\n    }\n  })\n  return error\n}\n\n/** @internal */\nexport const Or = (self: ConfigError.ConfigError, that: ConfigError.ConfigError): ConfigError.ConfigError => {\n  const error = Object.create(proto)\n  error._op = OpCodes.OP_OR\n  error.left = self\n  error.right = that\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value(this: ConfigError.Or) {\n      return `${this.left} or ${this.right}`\n    }\n  })\n  Object.defineProperty(error, \"message\", {\n    enumerable: false,\n    get(this: ConfigError.Or) {\n      return this.toString()\n    }\n  })\n  return error\n}\n\n/** @internal */\nexport const InvalidData = (\n  path: ReadonlyArray<string>,\n  message: string,\n  options: ConfigError.Options = { pathDelim: \".\" }\n): ConfigError.ConfigError => {\n  const error = Object.create(proto)\n  error._op = OpCodes.OP_INVALID_DATA\n  error.path = path\n  error.message = message\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value(this: ConfigError.InvalidData) {\n      const path = pipe(this.path, RA.join(options.pathDelim))\n      return `(Invalid data at ${path}: \"${this.message}\")`\n    }\n  })\n  return error\n}\n\n/** @internal */\nexport const MissingData = (\n  path: ReadonlyArray<string>,\n  message: string,\n  options: ConfigError.Options = { pathDelim: \".\" }\n): ConfigError.ConfigError => {\n  const error = Object.create(proto)\n  error._op = OpCodes.OP_MISSING_DATA\n  error.path = path\n  error.message = message\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value(this: ConfigError.MissingData) {\n      const path = pipe(this.path, RA.join(options.pathDelim))\n      return `(Missing data at ${path}: \"${this.message}\")`\n    }\n  })\n  return error\n}\n\n/** @internal */\nexport const SourceUnavailable = (\n  path: ReadonlyArray<string>,\n  message: string,\n  cause: Cause.Cause<unknown>,\n  options: ConfigError.Options = { pathDelim: \".\" }\n): ConfigError.ConfigError => {\n  const error = Object.create(proto)\n  error._op = OpCodes.OP_SOURCE_UNAVAILABLE\n  error.path = path\n  error.message = message\n  error.cause = cause\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value(this: ConfigError.SourceUnavailable) {\n      const path = pipe(this.path, RA.join(options.pathDelim))\n      return `(Source unavailable at ${path}: \"${this.message}\")`\n    }\n  })\n  return error\n}\n\n/** @internal */\nexport const Unsupported = (\n  path: ReadonlyArray<string>,\n  message: string,\n  options: ConfigError.Options = { pathDelim: \".\" }\n): ConfigError.ConfigError => {\n  const error = Object.create(proto)\n  error._op = OpCodes.OP_UNSUPPORTED\n  error.path = path\n  error.message = message\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value(this: ConfigError.Unsupported) {\n      const path = pipe(this.path, RA.join(options.pathDelim))\n      return `(Unsupported operation at ${path}: \"${this.message}\")`\n    }\n  })\n  return error\n}\n\n/** @internal */\nexport const isConfigError = (u: unknown): u is ConfigError.ConfigError => hasProperty(u, ConfigErrorTypeId)\n\n/** @internal */\nexport const isAnd = (self: ConfigError.ConfigError): self is ConfigError.And => self._op === OpCodes.OP_AND\n\n/** @internal */\nexport const isOr = (self: ConfigError.ConfigError): self is ConfigError.Or => self._op === OpCodes.OP_OR\n\n/** @internal */\nexport const isInvalidData = (self: ConfigError.ConfigError): self is ConfigError.InvalidData =>\n  self._op === OpCodes.OP_INVALID_DATA\n\n/** @internal */\nexport const isMissingData = (self: ConfigError.ConfigError): self is ConfigError.MissingData =>\n  self._op === OpCodes.OP_MISSING_DATA\n\n/** @internal */\nexport const isSourceUnavailable = (self: ConfigError.ConfigError): self is ConfigError.SourceUnavailable =>\n  self._op === OpCodes.OP_SOURCE_UNAVAILABLE\n\n/** @internal */\nexport const isUnsupported = (self: ConfigError.ConfigError): self is ConfigError.Unsupported =>\n  self._op === OpCodes.OP_UNSUPPORTED\n\n/** @internal */\nexport const prefixed: {\n  (prefix: ReadonlyArray<string>): (self: ConfigError.ConfigError) => ConfigError.ConfigError\n  (self: ConfigError.ConfigError, prefix: ReadonlyArray<string>): ConfigError.ConfigError\n} = dual<\n  (prefix: ReadonlyArray<string>) => (self: ConfigError.ConfigError) => ConfigError.ConfigError,\n  (self: ConfigError.ConfigError, prefix: ReadonlyArray<string>) => ConfigError.ConfigError\n>(2, (self, prefix) => {\n  switch (self._op) {\n    case OpCodes.OP_AND: {\n      return And(prefixed(self.left, prefix), prefixed(self.right, prefix))\n    }\n    case OpCodes.OP_OR: {\n      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix))\n    }\n    case OpCodes.OP_INVALID_DATA: {\n      return InvalidData([...prefix, ...self.path], self.message)\n    }\n    case OpCodes.OP_MISSING_DATA: {\n      return MissingData([...prefix, ...self.path], self.message)\n    }\n    case OpCodes.OP_SOURCE_UNAVAILABLE: {\n      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause)\n    }\n    case OpCodes.OP_UNSUPPORTED: {\n      return Unsupported([...prefix, ...self.path], self.message)\n    }\n  }\n})\n\n/** @internal */\nconst IsMissingDataOnlyReducer: ConfigError.ConfigErrorReducer<unknown, boolean> = {\n  andCase: (_, left, right) => left && right,\n  orCase: (_, left, right) => left && right,\n  invalidDataCase: constFalse,\n  missingDataCase: constTrue,\n  sourceUnavailableCase: constFalse,\n  unsupportedCase: constFalse\n}\n\n/** @internal */\ntype ConfigErrorCase = AndCase | OrCase\n\n/** @internal */\ninterface AndCase {\n  readonly _op: \"AndCase\"\n}\n\n/** @internal */\ninterface OrCase {\n  readonly _op: \"OrCase\"\n}\n\n/** @internal */\nexport const reduceWithContext = dual<\n  <C, Z>(context: C, reducer: ConfigError.ConfigErrorReducer<C, Z>) => (self: ConfigError.ConfigError) => Z,\n  <C, Z>(self: ConfigError.ConfigError, context: C, reducer: ConfigError.ConfigErrorReducer<C, Z>) => Z\n>(3, <C, Z>(self: ConfigError.ConfigError, context: C, reducer: ConfigError.ConfigErrorReducer<C, Z>) => {\n  const input: Array<ConfigError.ConfigError> = [self]\n  const output: Array<Either.Either<Z, ConfigErrorCase>> = []\n  while (input.length > 0) {\n    const error = input.pop()!\n    switch (error._op) {\n      case OpCodes.OP_AND: {\n        input.push(error.right)\n        input.push(error.left)\n        output.push(Either.left({ _op: \"AndCase\" }))\n        break\n      }\n      case OpCodes.OP_OR: {\n        input.push(error.right)\n        input.push(error.left)\n        output.push(Either.left({ _op: \"OrCase\" }))\n        break\n      }\n      case OpCodes.OP_INVALID_DATA: {\n        output.push(Either.right(reducer.invalidDataCase(context, error.path, error.message)))\n        break\n      }\n      case OpCodes.OP_MISSING_DATA: {\n        output.push(Either.right(reducer.missingDataCase(context, error.path, error.message)))\n        break\n      }\n      case OpCodes.OP_SOURCE_UNAVAILABLE: {\n        output.push(Either.right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)))\n        break\n      }\n      case OpCodes.OP_UNSUPPORTED: {\n        output.push(Either.right(reducer.unsupportedCase(context, error.path, error.message)))\n        break\n      }\n    }\n  }\n  const accumulator: Array<Z> = []\n  while (output.length > 0) {\n    const either = output.pop()!\n    switch (either._op) {\n      case \"Left\": {\n        switch (either.left._op) {\n          case \"AndCase\": {\n            const left = accumulator.pop()!\n            const right = accumulator.pop()!\n            const value = reducer.andCase(context, left, right)\n            accumulator.push(value)\n            break\n          }\n          case \"OrCase\": {\n            const left = accumulator.pop()!\n            const right = accumulator.pop()!\n            const value = reducer.orCase(context, left, right)\n            accumulator.push(value)\n            break\n          }\n        }\n        break\n      }\n      case \"Right\": {\n        accumulator.push(either.right)\n        break\n      }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\n      \"BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues\"\n    )\n  }\n  return accumulator.pop()!\n})\n\n/** @internal */\nexport const isMissingDataOnly = (self: ConfigError.ConfigError): boolean =>\n  reduceWithContext(self, void 0, IsMissingDataOnlyReducer)\n","/** @internal */\nexport type OP_AND = typeof OP_AND\n\n/** @internal */\nexport const OP_AND = \"And\" as const\n\n/** @internal */\nexport type OP_OR = typeof OP_OR\n\n/** @internal */\nexport const OP_OR = \"Or\" as const\n\n/** @internal */\nexport type OP_INVALID_DATA = typeof OP_INVALID_DATA\n\n/** @internal */\nexport const OP_INVALID_DATA = \"InvalidData\" as const\n\n/** @internal */\nexport type OP_MISSING_DATA = typeof OP_MISSING_DATA\n\n/** @internal */\nexport const OP_MISSING_DATA = \"MissingData\" as const\n\n/** @internal */\nexport type OP_SOURCE_UNAVAILABLE = typeof OP_SOURCE_UNAVAILABLE\n\n/** @internal */\nexport const OP_SOURCE_UNAVAILABLE = \"SourceUnavailable\" as const\n\n/** @internal */\nexport type OP_UNSUPPORTED = typeof OP_UNSUPPORTED\n\n/** @internal */\nexport const OP_UNSUPPORTED = \"Unsupported\" as const\n","/** @internal */\nexport type OP_CONSTANT = typeof OP_CONSTANT\n\n/** @internal */\nexport const OP_CONSTANT = \"Constant\" as const\n\n/** @internal */\nexport type OP_FAIL = typeof OP_FAIL\n\n/** @internal */\nexport const OP_FAIL = \"Fail\" as const\n\n/** @internal */\nexport type OP_FALLBACK = typeof OP_FALLBACK\n\n/** @internal */\nexport const OP_FALLBACK = \"Fallback\" as const\n\n/** @internal */\nexport type OP_DESCRIBED = typeof OP_DESCRIBED\n\n/** @internal */\nexport const OP_DESCRIBED = \"Described\" as const\n\n/** @internal */\nexport type OP_LAZY = typeof OP_LAZY\n\n/** @internal */\nexport const OP_LAZY = \"Lazy\" as const\n\n/** @internal */\nexport type OP_MAP_OR_FAIL = typeof OP_MAP_OR_FAIL\n\n/** @internal */\nexport const OP_MAP_OR_FAIL = \"MapOrFail\" as const\n\n/** @internal */\nexport type OP_NESTED = typeof OP_NESTED\n\n/** @internal */\nexport const OP_NESTED = \"Nested\" as const\n\n/** @internal */\nexport type OP_PRIMITIVE = typeof OP_PRIMITIVE\n\n/** @internal */\nexport const OP_PRIMITIVE = \"Primitive\" as const\n\n/** @internal */\nexport type OP_SEQUENCE = typeof OP_SEQUENCE\n\n/** @internal */\nexport const OP_SEQUENCE = \"Sequence\" as const\n\n/** @internal */\nexport type OP_HASHMAP = typeof OP_HASHMAP\n\n/** @internal */\nexport const OP_HASHMAP = \"HashMap\" as const\n\n/** @internal */\nexport type OP_ZIP_WITH = typeof OP_ZIP_WITH\n\n/** @internal */\nexport const OP_ZIP_WITH = \"ZipWith\" as const\n","/* eslint-disable no-console */\nimport type * as Console from \"../../Console.js\"\nimport * as Context from \"../../Context.js\"\nimport * as core from \"../core.js\"\n\n/** @internal */\nexport const TypeId: Console.TypeId = Symbol.for(\"effect/Console\") as Console.TypeId\n\n/** @internal */\nexport const consoleTag: Context.Tag<Console.Console, Console.Console> = Context.GenericTag<Console.Console>(\n  \"effect/Console\"\n)\n\n/** @internal */\nexport const defaultConsole: Console.Console = {\n  [TypeId]: TypeId,\n  assert(condition, ...args) {\n    return core.sync(() => {\n      console.assert(condition, ...args)\n    })\n  },\n  clear: core.sync(() => {\n    console.clear()\n  }),\n  count(label) {\n    return core.sync(() => {\n      console.count(label)\n    })\n  },\n  countReset(label) {\n    return core.sync(() => {\n      console.countReset(label)\n    })\n  },\n  debug(...args) {\n    return core.sync(() => {\n      console.debug(...args)\n    })\n  },\n  dir(item, options) {\n    return core.sync(() => {\n      console.dir(item, options)\n    })\n  },\n  dirxml(...args) {\n    return core.sync(() => {\n      console.dirxml(...args)\n    })\n  },\n  error(...args) {\n    return core.sync(() => {\n      console.error(...args)\n    })\n  },\n  group(options) {\n    return options?.collapsed ?\n      core.sync(() => console.groupCollapsed(options?.label)) :\n      core.sync(() => console.group(options?.label))\n  },\n  groupEnd: core.sync(() => {\n    console.groupEnd()\n  }),\n  info(...args) {\n    return core.sync(() => {\n      console.info(...args)\n    })\n  },\n  log(...args) {\n    return core.sync(() => {\n      console.log(...args)\n    })\n  },\n  table(tabularData, properties) {\n    return core.sync(() => {\n      console.table(tabularData, properties)\n    })\n  },\n  time(label) {\n    return core.sync(() => console.time(label))\n  },\n  timeEnd(label) {\n    return core.sync(() => console.timeEnd(label))\n  },\n  timeLog(label, ...args) {\n    return core.sync(() => {\n      console.timeLog(label, ...args)\n    })\n  },\n  trace(...args) {\n    return core.sync(() => {\n      console.trace(...args)\n    })\n  },\n  warn(...args) {\n    return core.sync(() => {\n      console.warn(...args)\n    })\n  },\n  unsafe: console\n}\n","import * as RA from \"../../Array.js\"\nimport type * as ConfigError from \"../../ConfigError.js\"\nimport type * as PathPatch from \"../../ConfigProviderPathPatch.js\"\nimport * as Either from \"../../Either.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as List from \"../../List.js\"\nimport * as Option from \"../../Option.js\"\nimport * as configError from \"../configError.js\"\n\n/** @internal */\nexport const empty: PathPatch.PathPatch = {\n  _tag: \"Empty\"\n}\n\n/** @internal */\nexport const andThen = dual<\n  (that: PathPatch.PathPatch) => (self: PathPatch.PathPatch) => PathPatch.PathPatch,\n  (self: PathPatch.PathPatch, that: PathPatch.PathPatch) => PathPatch.PathPatch\n>(2, (self, that) => ({\n  _tag: \"AndThen\",\n  first: self,\n  second: that\n}))\n\n/** @internal */\nexport const mapName = dual<\n  (f: (string: string) => string) => (self: PathPatch.PathPatch) => PathPatch.PathPatch,\n  (self: PathPatch.PathPatch, f: (string: string) => string) => PathPatch.PathPatch\n>(2, (self, f) => andThen(self, { _tag: \"MapName\", f }))\n\n/** @internal */\nexport const nested = dual<\n  (name: string) => (self: PathPatch.PathPatch) => PathPatch.PathPatch,\n  (self: PathPatch.PathPatch, name: string) => PathPatch.PathPatch\n>(2, (self, name) => andThen(self, { _tag: \"Nested\", name }))\n\n/** @internal */\nexport const unnested = dual<\n  (name: string) => (self: PathPatch.PathPatch) => PathPatch.PathPatch,\n  (self: PathPatch.PathPatch, name: string) => PathPatch.PathPatch\n>(2, (self, name) => andThen(self, { _tag: \"Unnested\", name }))\n\n/** @internal */\nexport const patch = dual<\n  (\n    patch: PathPatch.PathPatch\n  ) => (\n    path: ReadonlyArray<string>\n  ) => Either.Either<ReadonlyArray<string>, ConfigError.ConfigError>,\n  (\n    path: ReadonlyArray<string>,\n    patch: PathPatch.PathPatch\n  ) => Either.Either<ReadonlyArray<string>, ConfigError.ConfigError>\n>(2, (path, patch) => {\n  let input: List.List<PathPatch.PathPatch> = List.of(patch)\n  let output: ReadonlyArray<string> = path\n  while (List.isCons(input)) {\n    const patch: PathPatch.PathPatch = input.head\n    switch (patch._tag) {\n      case \"Empty\": {\n        input = input.tail\n        break\n      }\n      case \"AndThen\": {\n        input = List.cons(patch.first, List.cons(patch.second, input.tail))\n        break\n      }\n      case \"MapName\": {\n        output = RA.map(output, patch.f)\n        input = input.tail\n        break\n      }\n      case \"Nested\": {\n        output = RA.prepend(output, patch.name)\n        input = input.tail\n        break\n      }\n      case \"Unnested\": {\n        const containsName = pipe(\n          RA.head(output),\n          Option.contains(patch.name)\n        )\n        if (containsName) {\n          output = RA.tailNonEmpty(output as RA.NonEmptyArray<string>)\n          input = input.tail\n        } else {\n          return Either.left(configError.MissingData(\n            output,\n            `Expected ${patch.name} to be in path in ConfigProvider#unnested`\n          ))\n        }\n        break\n      }\n    }\n  }\n  return Either.right(output)\n})\n","import type * as Arr from \"../Array.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport type * as Random from \"../Random.js\"\nimport * as PCGRandom from \"../Utils.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nconst RandomSymbolKey = \"effect/Random\"\n\n/** @internal */\nexport const RandomTypeId: Random.RandomTypeId = Symbol.for(\n  RandomSymbolKey\n) as Random.RandomTypeId\n\n/** @internal */\nexport const randomTag: Context.Tag<Random.Random, Random.Random> = Context.GenericTag(\"effect/Random\")\n/** @internal */\nclass RandomImpl implements Random.Random {\n  readonly [RandomTypeId]: Random.RandomTypeId = RandomTypeId\n\n  readonly PRNG: PCGRandom.PCGRandom\n\n  constructor(readonly seed: number) {\n    this.PRNG = new PCGRandom.PCGRandom(seed)\n  }\n\n  get next(): Effect.Effect<number> {\n    return core.sync(() => this.PRNG.number())\n  }\n\n  get nextBoolean(): Effect.Effect<boolean> {\n    return core.map(this.next, (n) => n > 0.5)\n  }\n\n  get nextInt(): Effect.Effect<number> {\n    return core.sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER))\n  }\n\n  nextRange(min: number, max: number): Effect.Effect<number> {\n    return core.map(this.next, (n) => (max - min) * n + min)\n  }\n\n  nextIntBetween(min: number, max: number): Effect.Effect<number> {\n    return core.sync(() => this.PRNG.integer(max - min) + min)\n  }\n\n  shuffle<A>(elements: Iterable<A>): Effect.Effect<Chunk.Chunk<A>> {\n    return shuffleWith(elements, (n) => this.nextIntBetween(0, n))\n  }\n}\n\nconst shuffleWith = <A>(\n  elements: Iterable<A>,\n  nextIntBounded: (n: number) => Effect.Effect<number>\n): Effect.Effect<Chunk.Chunk<A>> => {\n  return core.suspend(() =>\n    pipe(\n      core.sync(() => Array.from(elements)),\n      core.flatMap((buffer) => {\n        const numbers: Array<number> = []\n        for (let i = buffer.length; i >= 2; i = i - 1) {\n          numbers.push(i)\n        }\n        return pipe(\n          numbers,\n          core.forEachSequentialDiscard((n) =>\n            pipe(\n              nextIntBounded(n),\n              core.map((k) => swap(buffer, n - 1, k))\n            )\n          ),\n          core.as(Chunk.fromIterable(buffer))\n        )\n      })\n    )\n  )\n}\n\nconst swap = <A>(buffer: Array<A>, index1: number, index2: number): Array<A> => {\n  const tmp = buffer[index1]!\n  buffer[index1] = buffer[index2]!\n  buffer[index2] = tmp\n  return buffer\n}\n\nexport const make = <A>(seed: A): Random.Random => new RandomImpl(Hash.hash(seed))\n\n/** @internal */\nclass FixedRandomImpl implements Random.Random {\n  readonly [RandomTypeId]: Random.RandomTypeId = RandomTypeId\n\n  private index = 0\n\n  constructor(readonly values: Arr.NonEmptyArray<any>) {\n    if (values.length === 0) {\n      throw new Error(\"Requires at least one value\")\n    }\n  }\n\n  private getNextValue(): any {\n    const value = this.values[this.index]\n    this.index = (this.index + 1) % this.values.length\n    return value\n  }\n\n  get next(): Effect.Effect<number> {\n    return core.sync(() => {\n      const value = this.getNextValue()\n      if (typeof value === \"number\") {\n        return Math.max(0, Math.min(1, value))\n      }\n      return Hash.hash(value) / 2147483647\n    })\n  }\n\n  get nextBoolean(): Effect.Effect<boolean> {\n    return core.sync(() => {\n      const value = this.getNextValue()\n      if (typeof value === \"boolean\") {\n        return value\n      }\n      return Hash.hash(value) % 2 === 0\n    })\n  }\n\n  get nextInt(): Effect.Effect<number> {\n    return core.sync(() => {\n      const value = this.getNextValue()\n      if (typeof value === \"number\" && Number.isFinite(value)) {\n        return Math.round(value)\n      }\n      return Math.abs(Hash.hash(value))\n    })\n  }\n\n  nextRange(min: number, max: number): Effect.Effect<number> {\n    return core.map(this.next, (n) => (max - min) * n + min)\n  }\n\n  nextIntBetween(min: number, max: number): Effect.Effect<number> {\n    return core.sync(() => {\n      const value = this.getNextValue()\n      if (typeof value === \"number\" && Number.isFinite(value)) {\n        return Math.max(min, Math.min(max - 1, Math.round(value)))\n      }\n      const hash = Math.abs(Hash.hash(value))\n      return min + (hash % (max - min))\n    })\n  }\n\n  shuffle<A>(elements: Iterable<A>): Effect.Effect<Chunk.Chunk<A>> {\n    return shuffleWith(elements, (n) => this.nextIntBetween(0, n))\n  }\n}\n\n/** @internal */\nexport const fixed = <T extends Arr.NonEmptyArray<any>>(values: T): Random.Random => new FixedRandomImpl(values)\n","import * as Arr from \"../Array.js\"\nimport type * as Config from \"../Config.js\"\nimport type * as ConfigError from \"../ConfigError.js\"\nimport type * as ConfigProvider from \"../ConfigProvider.js\"\nimport type * as PathPatch from \"../ConfigProviderPathPatch.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as number from \"../Number.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport * as regexp from \"../RegExp.js\"\nimport type * as _config from \"./config.js\"\nimport * as configError from \"./configError.js\"\nimport * as pathPatch from \"./configProvider/pathPatch.js\"\nimport * as core from \"./core.js\"\nimport * as OpCodes from \"./opCodes/config.js\"\nimport * as StringUtils from \"./string-utils.js\"\n\ntype KeyComponent = ConfigProvider.ConfigProvider.KeyComponent\n\nconst concat = <A, B>(l: ReadonlyArray<A>, r: ReadonlyArray<B>): ReadonlyArray<A | B> => [...l, ...r]\n\n/** @internal */\nconst ConfigProviderSymbolKey = \"effect/ConfigProvider\"\n\n/** @internal */\nexport const ConfigProviderTypeId: ConfigProvider.ConfigProviderTypeId = Symbol.for(\n  ConfigProviderSymbolKey\n) as ConfigProvider.ConfigProviderTypeId\n\n/** @internal */\nexport const configProviderTag: Context.Tag<ConfigProvider.ConfigProvider, ConfigProvider.ConfigProvider> = Context\n  .GenericTag(\n    \"effect/ConfigProvider\"\n  )\n\n/** @internal */\nconst FlatConfigProviderSymbolKey = \"effect/ConfigProviderFlat\"\n\n/** @internal */\nexport const FlatConfigProviderTypeId: ConfigProvider.FlatConfigProviderTypeId = Symbol.for(\n  FlatConfigProviderSymbolKey\n) as ConfigProvider.FlatConfigProviderTypeId\n\n/** @internal */\nexport const make = (\n  options: {\n    readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>\n    readonly flattened: ConfigProvider.ConfigProvider.Flat\n  }\n): ConfigProvider.ConfigProvider => ({\n  [ConfigProviderTypeId]: ConfigProviderTypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  ...options\n})\n\n/** @internal */\nexport const makeFlat = (\n  options: {\n    readonly load: <A>(\n      path: ReadonlyArray<string>,\n      config: Config.Config.Primitive<A>,\n      split: boolean\n    ) => Effect.Effect<Array<A>, ConfigError.ConfigError>\n    readonly enumerateChildren: (\n      path: ReadonlyArray<string>\n    ) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>\n    readonly patch: PathPatch.PathPatch\n  }\n): ConfigProvider.ConfigProvider.Flat => ({\n  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,\n  patch: options.patch,\n  load: (path, config, split = true) => options.load(path, config, split),\n  enumerateChildren: options.enumerateChildren\n})\n\n/** @internal */\nexport const fromFlat = (flat: ConfigProvider.ConfigProvider.Flat): ConfigProvider.ConfigProvider =>\n  make({\n    load: (config) =>\n      core.flatMap(fromFlatLoop(flat, Arr.empty(), config, false), (chunk) =>\n        Option.match(Arr.head(chunk), {\n          onNone: () =>\n            core.fail(\n              configError.MissingData(\n                Arr.empty(),\n                `Expected a single value having structure: ${config}`\n              )\n            ),\n          onSome: core.succeed\n        })),\n    flattened: flat\n  })\n\n/** @internal */\nexport const fromEnv = (\n  options?: Partial<ConfigProvider.ConfigProvider.FromEnvConfig>\n): ConfigProvider.ConfigProvider => {\n  const { pathDelim, seqDelim } = Object.assign({}, { pathDelim: \"_\", seqDelim: \",\" }, options)\n  const makePathString = (path: ReadonlyArray<string>): string => pipe(path, Arr.join(pathDelim))\n  const unmakePathString = (pathString: string): ReadonlyArray<string> => pathString.split(pathDelim)\n\n  const getEnv = () =>\n    typeof process !== \"undefined\" && \"env\" in process && typeof process.env === \"object\" ? process.env : {}\n\n  const load = <A>(\n    path: ReadonlyArray<string>,\n    primitive: Config.Config.Primitive<A>,\n    split = true\n  ): Effect.Effect<Array<A>, ConfigError.ConfigError> => {\n    const pathString = makePathString(path)\n    const current = getEnv()\n    const valueOpt = pathString in current ? Option.some(current[pathString]!) : Option.none()\n    return pipe(\n      valueOpt,\n      core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the process context`)),\n      core.flatMap((value) => parsePrimitive(value, path, primitive, seqDelim, split))\n    )\n  }\n\n  const enumerateChildren = (\n    path: ReadonlyArray<string>\n  ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError> =>\n    core.sync(() => {\n      const current = getEnv()\n      const keys = Object.keys(current)\n      const keyPaths = keys.map((value) => unmakePathString(value.toUpperCase()))\n      const filteredKeyPaths = keyPaths.filter((keyPath) => {\n        for (let i = 0; i < path.length; i++) {\n          const pathComponent = pipe(path, Arr.unsafeGet(i))\n          const currentElement = keyPath[i]\n          if (currentElement === undefined || pathComponent !== currentElement) {\n            return false\n          }\n        }\n        return true\n      }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1))\n      return HashSet.fromIterable(filteredKeyPaths)\n    })\n\n  return fromFlat(makeFlat({ load, enumerateChildren, patch: pathPatch.empty }))\n}\n\n/** @internal */\nexport const fromMap = (\n  map: Map<string, string>,\n  config?: Partial<ConfigProvider.ConfigProvider.FromMapConfig>\n): ConfigProvider.ConfigProvider => {\n  const { pathDelim, seqDelim } = Object.assign({ seqDelim: \",\", pathDelim: \".\" }, config)\n  const makePathString = (path: ReadonlyArray<string>): string => pipe(path, Arr.join(pathDelim))\n  const unmakePathString = (pathString: string): ReadonlyArray<string> => pathString.split(pathDelim)\n  const mapWithIndexSplit = splitIndexInKeys(\n    map,\n    (str) => unmakePathString(str),\n    makePathString\n  )\n  const load = <A>(\n    path: ReadonlyArray<string>,\n    primitive: Config.Config.Primitive<A>,\n    split = true\n  ): Effect.Effect<Array<A>, ConfigError.ConfigError> => {\n    const pathString = makePathString(path)\n    const valueOpt = mapWithIndexSplit.has(pathString) ?\n      Option.some(mapWithIndexSplit.get(pathString)!) :\n      Option.none()\n    return pipe(\n      valueOpt,\n      core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the provided map`)),\n      core.flatMap((value) => parsePrimitive(value, path, primitive, seqDelim, split))\n    )\n  }\n  const enumerateChildren = (\n    path: ReadonlyArray<string>\n  ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError> =>\n    core.sync(() => {\n      const keyPaths = Arr.fromIterable(mapWithIndexSplit.keys()).map(unmakePathString)\n      const filteredKeyPaths = keyPaths.filter((keyPath) => {\n        for (let i = 0; i < path.length; i++) {\n          const pathComponent = pipe(path, Arr.unsafeGet(i))\n          const currentElement = keyPath[i]\n          if (currentElement === undefined || pathComponent !== currentElement) {\n            return false\n          }\n        }\n        return true\n      }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1))\n      return HashSet.fromIterable(filteredKeyPaths)\n    })\n\n  return fromFlat(makeFlat({ load, enumerateChildren, patch: pathPatch.empty }))\n}\n\nconst extend = <A, B>(\n  leftDef: (n: number) => A,\n  rightDef: (n: number) => B,\n  left: ReadonlyArray<A>,\n  right: ReadonlyArray<B>\n): [ReadonlyArray<A>, ReadonlyArray<B>] => {\n  const leftPad = Arr.unfold(\n    left.length,\n    (index) =>\n      index >= right.length ?\n        Option.none() :\n        Option.some([leftDef(index), index + 1])\n  )\n  const rightPad = Arr.unfold(\n    right.length,\n    (index) =>\n      index >= left.length ?\n        Option.none() :\n        Option.some([rightDef(index), index + 1])\n  )\n  const leftExtension = concat(left, leftPad)\n  const rightExtension = concat(right, rightPad)\n  return [leftExtension, rightExtension]\n}\n\nconst appendConfigPath = (path: ReadonlyArray<string>, config: Config.Config<unknown>): ReadonlyArray<string> => {\n  let op = config as _config.ConfigPrimitive\n  if (op._tag === \"Nested\") {\n    const out = path.slice()\n    while (op._tag === \"Nested\") {\n      out.push(op.name)\n      op = op.config as _config.ConfigPrimitive\n    }\n    return out\n  }\n  return path\n}\n\nconst fromFlatLoop = <A>(\n  flat: ConfigProvider.ConfigProvider.Flat,\n  prefix: ReadonlyArray<string>,\n  config: Config.Config<A>,\n  split: boolean\n): Effect.Effect<Array<A>, ConfigError.ConfigError> => {\n  const op = config as _config.ConfigPrimitive\n  switch (op._tag) {\n    case OpCodes.OP_CONSTANT: {\n      return core.succeed(Arr.of(op.value)) as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_DESCRIBED: {\n      return core.suspend(\n        () => fromFlatLoop(flat, prefix, op.config, split)\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_FAIL: {\n      return core.fail(configError.MissingData(prefix, op.message)) as Effect.Effect<\n        Array<A>,\n        ConfigError.ConfigError\n      >\n    }\n    case OpCodes.OP_FALLBACK: {\n      return pipe(\n        core.suspend(() => fromFlatLoop(flat, prefix, op.first, split)),\n        core.catchAll((error1) => {\n          if (op.condition(error1)) {\n            return pipe(\n              fromFlatLoop(flat, prefix, op.second, split),\n              core.catchAll((error2) => core.fail(configError.Or(error1, error2)))\n            )\n          }\n          return core.fail(error1)\n        })\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_LAZY: {\n      return core.suspend(() => fromFlatLoop(flat, prefix, op.config(), split)) as Effect.Effect<\n        Array<A>,\n        ConfigError.ConfigError\n      >\n    }\n    case OpCodes.OP_MAP_OR_FAIL: {\n      return core.suspend(() =>\n        pipe(\n          fromFlatLoop(flat, prefix, op.original, split),\n          core.flatMap(\n            core.forEachSequential((a) =>\n              pipe(\n                op.mapOrFail(a),\n                core.mapError(configError.prefixed(appendConfigPath(prefix, op.original)))\n              )\n            )\n          )\n        )\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_NESTED: {\n      return core.suspend(() =>\n        fromFlatLoop(\n          flat,\n          concat(prefix, Arr.of(op.name)),\n          op.config,\n          split\n        )\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_PRIMITIVE: {\n      return pipe(\n        pathPatch.patch(prefix, flat.patch),\n        core.flatMap((prefix) =>\n          pipe(\n            flat.load(prefix, op, split),\n            core.flatMap((values) => {\n              if (values.length === 0) {\n                const name = pipe(Arr.last(prefix), Option.getOrElse(() => \"<n/a>\"))\n                return core.fail(configError.MissingData([], `Expected ${op.description} with name ${name}`))\n              }\n              return core.succeed(values)\n            })\n          )\n        )\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_SEQUENCE: {\n      return pipe(\n        pathPatch.patch(prefix, flat.patch),\n        core.flatMap((patchedPrefix) =>\n          pipe(\n            flat.enumerateChildren(patchedPrefix),\n            core.flatMap(indicesFrom),\n            core.flatMap((indices) => {\n              if (indices.length === 0) {\n                return core.suspend(() =>\n                  core.map(fromFlatLoop(flat, prefix, op.config, true), Arr.of)\n                ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n              }\n              return pipe(\n                core.forEachSequential(\n                  indices,\n                  (index) => fromFlatLoop(flat, Arr.append(prefix, `[${index}]`), op.config, true)\n                ),\n                core.map((chunkChunk) => {\n                  const flattened = Arr.flatten(chunkChunk)\n                  if (flattened.length === 0) {\n                    return Arr.of(Arr.empty<A>())\n                  }\n                  return Arr.of(flattened)\n                })\n              ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n            })\n          )\n        )\n      )\n    }\n    case OpCodes.OP_HASHMAP: {\n      return core.suspend(() =>\n        pipe(\n          pathPatch.patch(prefix, flat.patch),\n          core.flatMap((prefix) =>\n            pipe(\n              flat.enumerateChildren(prefix),\n              core.flatMap((keys) => {\n                return pipe(\n                  keys,\n                  core.forEachSequential((key) =>\n                    fromFlatLoop(\n                      flat,\n                      concat(prefix, Arr.of(key)),\n                      op.valueConfig,\n                      split\n                    )\n                  ),\n                  core.map((matrix) => {\n                    if (matrix.length === 0) {\n                      return Arr.of(HashMap.empty())\n                    }\n                    return pipe(\n                      transpose(matrix),\n                      Arr.map((values) => HashMap.fromIterable(Arr.zip(Arr.fromIterable(keys), values)))\n                    )\n                  })\n                )\n              })\n            )\n          )\n        )\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n    case OpCodes.OP_ZIP_WITH: {\n      return core.suspend(() =>\n        pipe(\n          fromFlatLoop(flat, prefix, op.left, split),\n          core.either,\n          core.flatMap((left) =>\n            pipe(\n              fromFlatLoop(flat, prefix, op.right, split),\n              core.either,\n              core.flatMap((right) => {\n                if (Either.isLeft(left) && Either.isLeft(right)) {\n                  return core.fail(configError.And(left.left, right.left))\n                }\n                if (Either.isLeft(left) && Either.isRight(right)) {\n                  return core.fail(left.left)\n                }\n                if (Either.isRight(left) && Either.isLeft(right)) {\n                  return core.fail(right.left)\n                }\n                if (Either.isRight(left) && Either.isRight(right)) {\n                  const path = pipe(prefix, Arr.join(\".\"))\n                  const fail = fromFlatLoopFail(prefix, path)\n                  const [lefts, rights] = extend(\n                    fail,\n                    fail,\n                    pipe(left.right, Arr.map(Either.right)),\n                    pipe(right.right, Arr.map(Either.right))\n                  )\n                  return pipe(\n                    lefts,\n                    Arr.zip(rights),\n                    core.forEachSequential(([left, right]) =>\n                      pipe(\n                        core.zip(left, right),\n                        core.map(([left, right]) => op.zip(left, right))\n                      )\n                    )\n                  )\n                }\n                throw new Error(\n                  \"BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues\"\n                )\n              })\n            )\n          )\n        )\n      ) as unknown as Effect.Effect<Array<A>, ConfigError.ConfigError>\n    }\n  }\n}\n\nconst fromFlatLoopFail =\n  (prefix: ReadonlyArray<string>, path: string) => (index: number): Either.Either<unknown, ConfigError.ConfigError> =>\n    Either.left(\n      configError.MissingData(\n        prefix,\n        `The element at index ${index} in a sequence at path \"${path}\" was missing`\n      )\n    )\n\n/** @internal */\nexport const mapInputPath = dual<\n  (f: (path: string) => string) => (self: ConfigProvider.ConfigProvider) => ConfigProvider.ConfigProvider,\n  (self: ConfigProvider.ConfigProvider, f: (path: string) => string) => ConfigProvider.ConfigProvider\n>(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)))\n\nconst mapInputPathFlat = (\n  self: ConfigProvider.ConfigProvider.Flat,\n  f: (path: string) => string\n): ConfigProvider.ConfigProvider.Flat =>\n  makeFlat({\n    load: (path, config, split = true) => self.load(path, config, split),\n    enumerateChildren: (path) => self.enumerateChildren(path),\n    patch: pathPatch.mapName(self.patch, f)\n  })\n\n/** @internal */\nexport const nested = dual<\n  (name: string) => (self: ConfigProvider.ConfigProvider) => ConfigProvider.ConfigProvider,\n  (self: ConfigProvider.ConfigProvider, name: string) => ConfigProvider.ConfigProvider\n>(2, (self, name) =>\n  fromFlat(makeFlat({\n    load: (path, config) => self.flattened.load(path, config, true),\n    enumerateChildren: (path) => self.flattened.enumerateChildren(path),\n    patch: pathPatch.nested(self.flattened.patch, name)\n  })))\n\n/** @internal */\nexport const unnested = dual<\n  (name: string) => (self: ConfigProvider.ConfigProvider) => ConfigProvider.ConfigProvider,\n  (self: ConfigProvider.ConfigProvider, name: string) => ConfigProvider.ConfigProvider\n>(2, (self, name) =>\n  fromFlat(makeFlat({\n    load: (path, config) => self.flattened.load(path, config, true),\n    enumerateChildren: (path) => self.flattened.enumerateChildren(path),\n    patch: pathPatch.unnested(self.flattened.patch, name)\n  })))\n\n/** @internal */\nexport const orElse = dual<\n  (\n    that: LazyArg<ConfigProvider.ConfigProvider>\n  ) => (\n    self: ConfigProvider.ConfigProvider\n  ) => ConfigProvider.ConfigProvider,\n  (\n    self: ConfigProvider.ConfigProvider,\n    that: LazyArg<ConfigProvider.ConfigProvider>\n  ) => ConfigProvider.ConfigProvider\n>(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)))\n\nconst orElseFlat = (\n  self: ConfigProvider.ConfigProvider.Flat,\n  that: LazyArg<ConfigProvider.ConfigProvider.Flat>\n): ConfigProvider.ConfigProvider.Flat =>\n  makeFlat({\n    load: (path, config, split) =>\n      pipe(\n        pathPatch.patch(path, self.patch),\n        core.flatMap((patch) => self.load(patch, config, split)),\n        core.catchAll((error1) =>\n          pipe(\n            core.sync(that),\n            core.flatMap((that) =>\n              pipe(\n                pathPatch.patch(path, that.patch),\n                core.flatMap((patch) => that.load(patch, config, split)),\n                core.catchAll((error2) => core.fail(configError.Or(error1, error2)))\n              )\n            )\n          )\n        )\n      ),\n    enumerateChildren: (path) =>\n      pipe(\n        pathPatch.patch(path, self.patch),\n        core.flatMap((patch) => self.enumerateChildren(patch)),\n        core.either,\n        core.flatMap((left) =>\n          pipe(\n            core.sync(that),\n            core.flatMap((that) =>\n              pipe(\n                pathPatch.patch(path, that.patch),\n                core.flatMap((patch) => that.enumerateChildren(patch)),\n                core.either,\n                core.flatMap((right) => {\n                  if (Either.isLeft(left) && Either.isLeft(right)) {\n                    return core.fail(configError.And(left.left, right.left))\n                  }\n                  if (Either.isLeft(left) && Either.isRight(right)) {\n                    return core.succeed(right.right)\n                  }\n                  if (Either.isRight(left) && Either.isLeft(right)) {\n                    return core.succeed(left.right)\n                  }\n                  if (Either.isRight(left) && Either.isRight(right)) {\n                    return core.succeed(pipe(left.right, HashSet.union(right.right)))\n                  }\n                  throw new Error(\n                    \"BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues\"\n                  )\n                })\n              )\n            )\n          )\n        )\n      ),\n    patch: pathPatch.empty\n  })\n\n/** @internal */\nexport const constantCase = (self: ConfigProvider.ConfigProvider): ConfigProvider.ConfigProvider =>\n  mapInputPath(self, StringUtils.constantCase)\n\n/** @internal */\nexport const kebabCase = (self: ConfigProvider.ConfigProvider): ConfigProvider.ConfigProvider =>\n  mapInputPath(self, StringUtils.kebabCase)\n\n/** @internal */\nexport const lowerCase = (self: ConfigProvider.ConfigProvider): ConfigProvider.ConfigProvider =>\n  mapInputPath(self, StringUtils.lowerCase)\n\n/** @internal */\nexport const snakeCase = (self: ConfigProvider.ConfigProvider): ConfigProvider.ConfigProvider =>\n  mapInputPath(self, StringUtils.snakeCase)\n\n/** @internal */\nexport const upperCase = (self: ConfigProvider.ConfigProvider): ConfigProvider.ConfigProvider =>\n  mapInputPath(self, StringUtils.upperCase)\n\n/** @internal */\nexport const within = dual<\n  (\n    path: ReadonlyArray<string>,\n    f: (self: ConfigProvider.ConfigProvider) => ConfigProvider.ConfigProvider\n  ) => (self: ConfigProvider.ConfigProvider) => ConfigProvider.ConfigProvider,\n  (\n    self: ConfigProvider.ConfigProvider,\n    path: ReadonlyArray<string>,\n    f: (self: ConfigProvider.ConfigProvider) => ConfigProvider.ConfigProvider\n  ) => ConfigProvider.ConfigProvider\n>(3, (self, path, f) => {\n  const unnest = Arr.reduce(path, self, (provider, name) => unnested(provider, name))\n  const nest = Arr.reduceRight(path, f(unnest), (provider, name) => nested(provider, name))\n  return orElse(nest, () => self)\n})\n\nconst splitPathString = (text: string, delim: string): Array<string> => {\n  const split = text.split(new RegExp(`\\\\s*${regexp.escape(delim)}\\\\s*`))\n  return split\n}\n\nconst parsePrimitive = <A>(\n  text: string,\n  path: ReadonlyArray<string>,\n  primitive: Config.Config.Primitive<A>,\n  delimiter: string,\n  split: boolean\n): Effect.Effect<Array<A>, ConfigError.ConfigError> => {\n  if (!split) {\n    return pipe(\n      primitive.parse(text),\n      core.mapBoth({\n        onFailure: configError.prefixed(path),\n        onSuccess: Arr.of\n      })\n    )\n  }\n  return pipe(\n    splitPathString(text, delimiter),\n    core.forEachSequential((char) => primitive.parse(char.trim())),\n    core.mapError(configError.prefixed(path))\n  )\n}\n\nconst transpose = <A>(array: ReadonlyArray<ReadonlyArray<A>>): Array<Array<A>> => {\n  return Object.keys(array[0]).map((column) => array.map((row) => row[column as any]))\n}\n\nconst indicesFrom = (quotedIndices: HashSet.HashSet<string>): Effect.Effect<Array<number>> =>\n  pipe(\n    core.forEachSequential(quotedIndices, parseQuotedIndex),\n    core.mapBoth({\n      onFailure: () => Arr.empty<number>(),\n      onSuccess: Arr.sort(number.Order)\n    }),\n    core.either,\n    core.map(Either.merge)\n  )\n\nconst STR_INDEX_REGEX = /(^.+)(\\[(\\d+)\\])$/\nconst QUOTED_INDEX_REGEX = /^(\\[(\\d+)\\])$/\n\nconst parseQuotedIndex = (str: string): Option.Option<number> => {\n  const match = str.match(QUOTED_INDEX_REGEX)\n  if (match !== null) {\n    const matchedIndex = match[2]\n    return pipe(\n      matchedIndex !== undefined && matchedIndex.length > 0 ?\n        Option.some(matchedIndex) :\n        Option.none(),\n      Option.flatMap(parseInteger)\n    )\n  }\n  return Option.none()\n}\n\nconst splitIndexInKeys = (\n  map: Map<string, string>,\n  unmakePathString: (str: string) => ReadonlyArray<string>,\n  makePathString: (chunk: ReadonlyArray<string>) => string\n): Map<string, string> => {\n  const newMap: Map<string, string> = new Map()\n  for (const [pathString, value] of map) {\n    const keyWithIndex = pipe(\n      unmakePathString(pathString),\n      Arr.flatMap((key) =>\n        Option.match(splitIndexFrom(key), {\n          onNone: () => Arr.of(key),\n          onSome: ([key, index]) => Arr.make(key, `[${index}]`)\n        })\n      )\n    )\n    newMap.set(makePathString(keyWithIndex), value)\n  }\n  return newMap\n}\n\nconst splitIndexFrom = (key: string): Option.Option<[string, number]> => {\n  const match = key.match(STR_INDEX_REGEX)\n  if (match !== null) {\n    const matchedString = match[1]\n    const matchedIndex = match[3]\n    const optionalString = matchedString !== undefined && matchedString.length > 0 ?\n      Option.some(matchedString) :\n      Option.none()\n    const optionalIndex = pipe(\n      matchedIndex !== undefined && matchedIndex.length > 0 ?\n        Option.some(matchedIndex) :\n        Option.none(),\n      Option.flatMap(parseInteger)\n    )\n    return Option.all([optionalString, optionalIndex])\n  }\n  return Option.none()\n}\n\nconst parseInteger = (str: string): Option.Option<number> => {\n  const parsedIndex = Number.parseInt(str)\n  return Number.isNaN(parsedIndex) ?\n    Option.none() :\n    Option.some(parsedIndex)\n}\n\nconst keyName = (name: string): KeyComponent => ({\n  _tag: \"KeyName\",\n  name\n})\n\nconst keyIndex = (index: number): KeyComponent => ({\n  _tag: \"KeyIndex\",\n  index\n})\n\ninterface JsonMap {\n  [member: string]: string | number | boolean | null | JsonArray | JsonMap\n}\ninterface JsonArray extends Array<string | number | boolean | null | JsonArray | JsonMap> {}\n\n/** @internal */\nexport const fromJson = (json: unknown): ConfigProvider.ConfigProvider => {\n  const hiddenDelimiter = \"\\ufeff\"\n  const indexedEntries = Arr.map(\n    getIndexedEntries(json as JsonMap),\n    ([key, value]): [string, string] => [configPathToString(key).join(hiddenDelimiter), value]\n  )\n  return fromMap(new Map(indexedEntries), {\n    pathDelim: hiddenDelimiter,\n    seqDelim: hiddenDelimiter\n  })\n}\n\nconst configPathToString = (path: ReadonlyArray<KeyComponent>): ReadonlyArray<string> => {\n  const output: Array<string> = []\n  let i = 0\n  while (i < path.length) {\n    const component = path[i]\n    if (component._tag === \"KeyName\") {\n      if (i + 1 < path.length) {\n        const nextComponent = path[i + 1]\n        if (nextComponent._tag === \"KeyIndex\") {\n          output.push(`${component.name}[${nextComponent.index}]`)\n          i += 2\n        } else {\n          output.push(component.name)\n          i += 1\n        }\n      } else {\n        output.push(component.name)\n        i += 1\n      }\n    }\n  }\n  return output\n}\n\nconst getIndexedEntries = (\n  config: JsonMap\n): ReadonlyArray<[path: ReadonlyArray<KeyComponent>, value: string]> => {\n  const loopAny = (\n    path: ReadonlyArray<KeyComponent>,\n    value: string | number | boolean | JsonMap | JsonArray | null\n  ): ReadonlyArray<[path: ReadonlyArray<KeyComponent>, value: string]> => {\n    if (typeof value === \"string\") {\n      return Arr.make([path, value] as [ReadonlyArray<KeyComponent>, string])\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      return Arr.make([path, String(value)] as [ReadonlyArray<KeyComponent>, string])\n    }\n    if (Arr.isArray(value)) {\n      return loopArray(path, value)\n    }\n    if (typeof value === \"object\" && value !== null) {\n      return loopObject(path, value)\n    }\n    return Arr.empty<[ReadonlyArray<KeyComponent>, string]>()\n  }\n  const loopArray = (\n    path: ReadonlyArray<KeyComponent>,\n    values: JsonArray\n  ): ReadonlyArray<[path: ReadonlyArray<KeyComponent>, value: string]> =>\n    Arr.match(values, {\n      onEmpty: () => Arr.make([path, \"<nil>\"] as [ReadonlyArray<KeyComponent>, string]),\n      onNonEmpty: Arr.flatMap((value, index) => loopAny(Arr.append(path, keyIndex(index)), value))\n    })\n  const loopObject = (\n    path: ReadonlyArray<KeyComponent>,\n    value: JsonMap\n  ): ReadonlyArray<[path: ReadonlyArray<KeyComponent>, value: string]> =>\n    Object.entries(value)\n      .filter(([, value]) => Predicate.isNotNullable(value))\n      .flatMap(([key, value]) => {\n        const newPath = Arr.append(path, keyName(key))\n        const result = loopAny(newPath, value)\n        if (Arr.isEmptyReadonlyArray(result)) {\n          return Arr.make([newPath, \"\"] as [ReadonlyArray<KeyComponent>, string])\n        }\n        return result\n      })\n  return loopObject(Arr.empty(), config)\n}\n","import * as Array from \"../Array.js\"\nimport type * as Chunk from \"../Chunk.js\"\nimport type * as Clock from \"../Clock.js\"\nimport type * as Config from \"../Config.js\"\nimport type * as ConfigProvider from \"../ConfigProvider.js\"\nimport * as Context from \"../Context.js\"\nimport type * as DefaultServices from \"../DefaultServices.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport type * as Random from \"../Random.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport * as clock from \"./clock.js\"\nimport * as configProvider from \"./configProvider.js\"\nimport * as core from \"./core.js\"\nimport * as console_ from \"./defaultServices/console.js\"\nimport * as random from \"./random.js\"\nimport * as tracer from \"./tracer.js\"\n\n/** @internal */\nexport const liveServices: Context.Context<DefaultServices.DefaultServices> = pipe(\n  Context.empty(),\n  Context.add(clock.clockTag, clock.make()),\n  Context.add(console_.consoleTag, console_.defaultConsole),\n  Context.add(random.randomTag, random.make(Math.random())),\n  Context.add(configProvider.configProviderTag, configProvider.fromEnv()),\n  Context.add(tracer.tracerTag, tracer.nativeTracer)\n)\n\n/**\n * The `FiberRef` holding the default `Effect` services.\n *\n * @since 2.0.0\n * @category fiberRefs\n */\nexport const currentServices = globalValue(\n  Symbol.for(\"effect/DefaultServices/currentServices\"),\n  () => core.fiberRefUnsafeMakeContext(liveServices)\n)\n\n// circular with Clock\n\n/** @internal */\nexport const sleep = (duration: Duration.DurationInput): Effect.Effect<void> => {\n  const decodedDuration = Duration.decode(duration)\n  return clockWith((clock) => clock.sleep(decodedDuration))\n}\n\n/** @internal */\nexport const defaultServicesWith = <A, E, R>(\n  f: (services: Context.Context<DefaultServices.DefaultServices>) => Effect.Effect<A, E, R>\n) => core.withFiberRuntime<A, E, R>((fiber) => f(fiber.currentDefaultServices))\n\n/** @internal */\nexport const clockWith = <A, E, R>(f: (clock: Clock.Clock) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  defaultServicesWith((services) => f(services.unsafeMap.get(clock.clockTag.key)))\n\n/** @internal */\nexport const currentTimeMillis: Effect.Effect<number> = clockWith((clock) => clock.currentTimeMillis)\n\n/** @internal */\nexport const currentTimeNanos: Effect.Effect<bigint> = clockWith((clock) => clock.currentTimeNanos)\n\n/** @internal */\nexport const withClock = dual<\n  <C extends Clock.Clock>(clock: C) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <C extends Clock.Clock, A, E, R>(effect: Effect.Effect<A, E, R>, clock: C) => Effect.Effect<A, E, R>\n>(2, (effect, c) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(clock.clockTag, c)\n  )(effect))\n\n// circular with ConfigProvider\n\n/** @internal */\nexport const withConfigProvider = dual<\n  (provider: ConfigProvider.ConfigProvider) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, provider: ConfigProvider.ConfigProvider) => Effect.Effect<A, E, R>\n>(2, (self, provider) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(configProvider.configProviderTag, provider)\n  )(self))\n\n/** @internal */\nexport const configProviderWith = <A, E, R>(\n  f: (provider: ConfigProvider.ConfigProvider) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  defaultServicesWith((services) => f(services.unsafeMap.get(configProvider.configProviderTag.key)))\n\n/** @internal */\nexport const config = <A>(config: Config.Config<A>) => configProviderWith((_) => _.load(config))\n\n/** @internal */\nexport const configOrDie = <A>(config: Config.Config<A>) => core.orDie(configProviderWith((_) => _.load(config)))\n\n// circular with Random\n\n/** @internal */\nexport const randomWith = <A, E, R>(f: (random: Random.Random) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  defaultServicesWith((services) => f(services.unsafeMap.get(random.randomTag.key)))\n\n/** @internal */\nexport const withRandom = dual<\n  <X extends Random.Random>(value: X) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <X extends Random.Random, A, E, R>(effect: Effect.Effect<A, E, R>, value: X) => Effect.Effect<A, E, R>\n>(2, (effect, value) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(random.randomTag, value)\n  )(effect))\n\n/** @internal */\nexport const next: Effect.Effect<number> = randomWith((random) => random.next)\n\n/** @internal */\nexport const nextInt: Effect.Effect<number> = randomWith((random) => random.nextInt)\n\n/** @internal */\nexport const nextBoolean: Effect.Effect<boolean> = randomWith((random) => random.nextBoolean)\n\n/** @internal */\nexport const nextRange = (min: number, max: number): Effect.Effect<number> =>\n  randomWith((random) => random.nextRange(min, max))\n\n/** @internal */\nexport const nextIntBetween = (min: number, max: number): Effect.Effect<number> =>\n  randomWith((random) => random.nextIntBetween(min, max))\n\n/** @internal */\nexport const shuffle = <A>(elements: Iterable<A>): Effect.Effect<Chunk.Chunk<A>> =>\n  randomWith((random) => random.shuffle(elements))\n\n/** @internal */\nexport const choice = <Self extends Iterable<unknown>>(\n  elements: Self\n) => {\n  const array = Array.fromIterable(elements)\n  return core.map(\n    array.length === 0\n      ? core.fail(new core.NoSuchElementException(\"Cannot select a random element from an empty array\"))\n      : randomWith((random) => random.nextIntBetween(0, array.length)),\n    (i) => array[i]\n  ) as any\n}\n\n// circular with Tracer\n\n/** @internal */\nexport const tracerWith = <A, E, R>(f: (tracer: Tracer.Tracer) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  defaultServicesWith((services) => f(services.unsafeMap.get(tracer.tracerTag.key)))\n\n/** @internal */\nexport const withTracer = dual<\n  (value: Tracer.Tracer) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, value: Tracer.Tracer) => Effect.Effect<A, E, R>\n>(2, (effect, value) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(tracer.tracerTag, value)\n  )(effect))\n","/**\n * @since 2.0.0\n */\nimport * as Context from \"../Context.js\"\nimport type * as Exit from \"../Exit.js\"\nimport { constFalse } from \"../Function.js\"\nimport type * as Option from \"../Option.js\"\nimport type * as Tracer from \"../Tracer.js\"\n\n/** @internal */\nexport const TracerTypeId: Tracer.TracerTypeId = Symbol.for(\"effect/Tracer\") as Tracer.TracerTypeId\n\n/** @internal */\nexport const make = (options: Omit<Tracer.Tracer, Tracer.TracerTypeId>): Tracer.Tracer => ({\n  [TracerTypeId]: TracerTypeId,\n  ...options\n})\n\n/** @internal */\nexport const tracerTag = Context.GenericTag<Tracer.Tracer>(\"effect/Tracer\")\n\n/** @internal */\nexport const spanTag = Context.GenericTag<Tracer.ParentSpan, Tracer.AnySpan>(\"effect/ParentSpan\")\n\nconst randomHexString = (function() {\n  const characters = \"abcdef0123456789\"\n  const charactersLength = characters.length\n  return function(length: number) {\n    let result = \"\"\n    for (let i = 0; i < length; i++) {\n      result += characters.charAt(Math.floor(Math.random() * charactersLength))\n    }\n    return result\n  }\n})()\n\n/** @internal */\nexport class NativeSpan implements Tracer.Span {\n  readonly _tag = \"Span\"\n  readonly spanId: string\n  readonly traceId: string = \"native\"\n  readonly sampled = true\n\n  status: Tracer.SpanStatus\n  attributes: Map<string, unknown>\n  events: Array<[name: string, startTime: bigint, attributes: Record<string, unknown>]> = []\n  links: Array<Tracer.SpanLink>\n\n  constructor(\n    readonly name: string,\n    readonly parent: Option.Option<Tracer.AnySpan>,\n    readonly context: Context.Context<never>,\n    links: Iterable<Tracer.SpanLink>,\n    readonly startTime: bigint,\n    readonly kind: Tracer.SpanKind\n  ) {\n    this.status = {\n      _tag: \"Started\",\n      startTime\n    }\n    this.attributes = new Map()\n    this.traceId = parent._tag === \"Some\" ? parent.value.traceId : randomHexString(32)\n    this.spanId = randomHexString(16)\n    this.links = Array.from(links)\n  }\n\n  end(endTime: bigint, exit: Exit.Exit<unknown, unknown>): void {\n    this.status = {\n      _tag: \"Ended\",\n      endTime,\n      exit,\n      startTime: this.status.startTime\n    }\n  }\n\n  attribute(key: string, value: unknown): void {\n    this.attributes.set(key, value)\n  }\n\n  event(name: string, startTime: bigint, attributes?: Record<string, unknown>): void {\n    this.events.push([name, startTime, attributes ?? {}])\n  }\n\n  addLinks(links: ReadonlyArray<Tracer.SpanLink>): void {\n    // eslint-disable-next-line no-restricted-syntax\n    this.links.push(...links)\n  }\n}\n\n/** @internal */\nexport const nativeTracer: Tracer.Tracer = make({\n  span: (name, parent, context, links, startTime, kind) =>\n    new NativeSpan(\n      name,\n      parent,\n      context,\n      links,\n      startTime,\n      kind\n    ),\n  context: (f) => f()\n})\n\n/** @internal */\nexport const externalSpan = (options: {\n  readonly spanId: string\n  readonly traceId: string\n  readonly sampled?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n}): Tracer.ExternalSpan => ({\n  _tag: \"ExternalSpan\",\n  spanId: options.spanId,\n  traceId: options.traceId,\n  sampled: options.sampled ?? true,\n  context: options.context ?? Context.empty()\n})\n\n/** @internal */\nexport const addSpanStackTrace = (options: Tracer.SpanOptions | undefined): Tracer.SpanOptions => {\n  if (options?.captureStackTrace === false) {\n    return options\n  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== \"boolean\") {\n    return options\n  }\n  const limit = Error.stackTraceLimit\n  Error.stackTraceLimit = 3\n  const traceError = new Error()\n  Error.stackTraceLimit = limit\n  let cache: false | string = false\n  return {\n    ...options,\n    captureStackTrace: () => {\n      if (cache !== false) {\n        return cache\n      }\n      if (traceError.stack !== undefined) {\n        const stack = traceError.stack.split(\"\\n\")\n        if (stack[3] !== undefined) {\n          cache = stack[3].trim()\n          return cache\n        }\n      }\n    }\n  }\n}\n\n/** @internal */\nexport const DisablePropagation = Context.Reference<Tracer.DisablePropagation>()(\"effect/Tracer/DisablePropagation\", {\n  defaultValue: constFalse\n})\n","/**\n * Adapted from the `change-case` library.\n *\n * Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)\n */\n\n/** @internal */\nexport const lowerCase = (str: string) => str.toLowerCase()\n\n/** @internal */\nexport const upperCase = (str: string) => str.toUpperCase()\n\ninterface Options {\n  splitRegexp?: RegExp | ReadonlyArray<RegExp>\n  stripRegexp?: RegExp | ReadonlyArray<RegExp>\n  delimiter?: string\n  transform?: (part: string, index: number, parts: ReadonlyArray<string>) => string\n}\n\n/**\n * Replace `re` in the input string with the replacement value.\n */\nconst replace = (input: string, re: RegExp | ReadonlyArray<RegExp>, value: string): string =>\n  re instanceof RegExp\n    ? input.replace(re, value)\n    : re.reduce((input, re) => input.replace(re, value), input)\n\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nconst DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g]\n\n// Remove all non-word characters.\nconst DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi\n\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nconst noCase = (input: string, options: Options = {}): string => {\n  const {\n    delimiter = \" \",\n    splitRegexp = DEFAULT_SPLIT_REGEXP,\n    stripRegexp = DEFAULT_STRIP_REGEXP,\n    transform = lowerCase\n  } = options\n  const result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\")\n  let start = 0\n  let end = result.length\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") {\n    start++\n  }\n  while (result.charAt(end - 1) === \"\\0\") {\n    end--\n  }\n  // Transform each token independently.\n  return result.slice(start, end).split(\"\\0\").map(transform).join(delimiter)\n}\n\nconst pascalCaseTransform = (input: string, index: number): string => {\n  const firstChar = input.charAt(0)\n  const lowerChars = input.substring(1).toLowerCase()\n  if (index > 0 && firstChar >= \"0\" && firstChar <= \"9\") {\n    return `_${firstChar}${lowerChars}`\n  }\n  return `${firstChar.toUpperCase()}${lowerChars}`\n}\n\n/** @internal */\nexport const pascalCase = (input: string, options?: Options): string =>\n  noCase(input, {\n    delimiter: \"\",\n    transform: pascalCaseTransform,\n    ...options\n  })\n\nconst camelCaseTransform = (input: string, index: number): string =>\n  index === 0\n    ? input.toLowerCase()\n    : pascalCaseTransform(input, index)\n\n/** @internal */\nexport const camelCase = (input: string, options?: Options): string =>\n  pascalCase(input, {\n    transform: camelCaseTransform,\n    ...options\n  })\n\n/** @internal */\nexport const constantCase = (input: string, options?: Options): string =>\n  noCase(input, {\n    delimiter: \"_\",\n    transform: upperCase,\n    ...options\n  })\n\n/** @internal */\nexport const kebabCase = (input: string, options?: Options) =>\n  noCase(input, {\n    delimiter: \"-\",\n    ...options\n  })\n\n/** @internal */\nexport const snakeCase = (input: string, options?: Options) =>\n  noCase(input, {\n    delimiter: \"_\",\n    ...options\n  })\n","import * as RA from \"../Array.js\"\nimport * as Boolean from \"../Boolean.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport type * as Clock from \"../Clock.js\"\nimport type { ConfigProvider } from \"../ConfigProvider.js\"\nimport * as Context from \"../Context.js\"\nimport type { DefaultServices } from \"../DefaultServices.js\"\nimport type * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Effectable from \"../Effectable.js\"\nimport type * as Either from \"../Either.js\"\nimport * as ExecutionStrategy from \"../ExecutionStrategy.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport * as FiberRefs from \"../FiberRefs.js\"\nimport * as FiberRefsPatch from \"../FiberRefsPatch.js\"\nimport * as FiberStatus from \"../FiberStatus.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as Inspectable from \"../Inspectable.js\"\nimport type { Logger } from \"../Logger.js\"\nimport * as LogLevel from \"../LogLevel.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as Micro from \"../Micro.js\"\nimport * as MRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type * as Random from \"../Random.js\"\nimport * as Ref from \"../Ref.js\"\nimport type { Entry, Request } from \"../Request.js\"\nimport type * as RequestBlock from \"../RequestBlock.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as RuntimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport { currentScheduler, type Scheduler } from \"../Scheduler.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Supervisor from \"../Supervisor.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type { Concurrency, NoExcessProperties, NoInfer } from \"../Types.js\"\nimport { internalCall, yieldWrapGet } from \"../Utils.js\"\nimport * as RequestBlock_ from \"./blockedRequests.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as clock from \"./clock.js\"\nimport { currentRequestMap } from \"./completedRequestMap.js\"\nimport * as concurrency from \"./concurrency.js\"\nimport { configProviderTag } from \"./configProvider.js\"\nimport * as internalEffect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport { consoleTag } from \"./defaultServices/console.js\"\nimport * as executionStrategy from \"./executionStrategy.js\"\nimport * as internalFiber from \"./fiber.js\"\nimport * as FiberMessage from \"./fiberMessage.js\"\nimport * as fiberRefs from \"./fiberRefs.js\"\nimport * as fiberScope from \"./fiberScope.js\"\nimport * as internalLogger from \"./logger.js\"\nimport * as metric from \"./metric.js\"\nimport * as metricBoundaries from \"./metric/boundaries.js\"\nimport * as metricLabel from \"./metric/label.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport { randomTag } from \"./random.js\"\nimport { complete } from \"./request.js\"\nimport * as runtimeFlags_ from \"./runtimeFlags.js\"\nimport { OpSupervision } from \"./runtimeFlags.js\"\nimport * as supervisor from \"./supervisor.js\"\nimport * as SupervisorPatch from \"./supervisor/patch.js\"\nimport * as tracer from \"./tracer.js\"\nimport * as version from \"./version.js\"\n\n/** @internal */\nexport const fiberStarted = metric.counter(\"effect_fiber_started\", { incremental: true })\n/** @internal */\nexport const fiberActive = metric.counter(\"effect_fiber_active\")\n/** @internal */\nexport const fiberSuccesses = metric.counter(\"effect_fiber_successes\", { incremental: true })\n/** @internal */\nexport const fiberFailures = metric.counter(\"effect_fiber_failures\", { incremental: true })\n/** @internal */\nexport const fiberLifetimes = metric.tagged(\n  metric.histogram(\n    \"effect_fiber_lifetimes\",\n    metricBoundaries.exponential({\n      start: 0.5,\n      factor: 2,\n      count: 35\n    })\n  ),\n  \"time_unit\",\n  \"milliseconds\"\n)\n\n/** @internal */\ntype EvaluationSignal =\n  | EvaluationSignalContinue\n  | EvaluationSignalDone\n  | EvaluationSignalYieldNow\n\n/** @internal */\nconst EvaluationSignalContinue = \"Continue\" as const\n\n/** @internal */\ntype EvaluationSignalContinue = typeof EvaluationSignalContinue\n\n/** @internal */\nconst EvaluationSignalDone = \"Done\" as const\n\n/** @internal */\ntype EvaluationSignalDone = typeof EvaluationSignalDone\n\n/** @internal */\nconst EvaluationSignalYieldNow = \"Yield\" as const\n\n/** @internal */\ntype EvaluationSignalYieldNow = typeof EvaluationSignalYieldNow\n\nconst runtimeFiberVariance = {\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: never) => _\n}\n\nconst absurd = (_: never): never => {\n  throw new Error(\n    `BUG: FiberRuntime - ${\n      Inspectable.toStringUnknown(_)\n    } - please report an issue at https://github.com/Effect-TS/effect/issues`\n  )\n}\n\nconst YieldedOp = Symbol.for(\"effect/internal/fiberRuntime/YieldedOp\")\ntype YieldedOp = typeof YieldedOp\nconst yieldedOpChannel: {\n  currentOp: core.Primitive | null\n} = globalValue(\"effect/internal/fiberRuntime/yieldedOpChannel\", () => ({\n  currentOp: null\n}))\n\nconst contOpSuccess = {\n  [OpCodes.OP_ON_SUCCESS]: (\n    _: FiberRuntime<any, any>,\n    cont: core.OnSuccess,\n    value: unknown\n  ) => {\n    return internalCall(() => cont.effect_instruction_i1(value))\n  },\n  [\"OnStep\"]: (\n    _: FiberRuntime<any, any>,\n    _cont: core.OnStep,\n    value: unknown\n  ) => {\n    return core.exitSucceed(core.exitSucceed(value))\n  },\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE]: (\n    _: FiberRuntime<any, any>,\n    cont: core.OnSuccessAndFailure,\n    value: unknown\n  ) => {\n    return internalCall(() => cont.effect_instruction_i2(value))\n  },\n  [OpCodes.OP_REVERT_FLAGS]: (\n    self: FiberRuntime<any, any>,\n    cont: core.RevertFlags,\n    value: unknown\n  ) => {\n    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch)\n    if (runtimeFlags_.interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {\n      return core.exitFailCause(self.getInterruptedCause())\n    } else {\n      return core.exitSucceed(value)\n    }\n  },\n  [OpCodes.OP_WHILE]: (\n    self: FiberRuntime<any, any>,\n    cont: core.While,\n    value: unknown\n  ) => {\n    internalCall(() => cont.effect_instruction_i2(value))\n    if (internalCall(() => cont.effect_instruction_i0())) {\n      self.pushStack(cont)\n      return internalCall(() => cont.effect_instruction_i1())\n    } else {\n      return core.void\n    }\n  },\n  [OpCodes.OP_ITERATOR]: (\n    self: FiberRuntime<any, any>,\n    cont: core.FromIterator,\n    value: unknown\n  ) => {\n    const state = internalCall(() => cont.effect_instruction_i0.next(value))\n    if (state.done) return core.exitSucceed(state.value)\n    self.pushStack(cont)\n    return yieldWrapGet(state.value)\n  }\n}\n\nconst drainQueueWhileRunningTable = {\n  [FiberMessage.OP_INTERRUPT_SIGNAL]: (\n    self: FiberRuntime<any, any>,\n    runtimeFlags: RuntimeFlags.RuntimeFlags,\n    cur: Effect.Effect<any, any, any>,\n    message: FiberMessage.FiberMessage & { _tag: FiberMessage.OP_INTERRUPT_SIGNAL }\n  ) => {\n    self.processNewInterruptSignal(message.cause)\n    return runtimeFlags_.interruptible(runtimeFlags) ? core.exitFailCause(message.cause) : cur\n  },\n  [FiberMessage.OP_RESUME]: (\n    _self: FiberRuntime<any, any>,\n    _runtimeFlags: RuntimeFlags.RuntimeFlags,\n    _cur: Effect.Effect<any, any, any>,\n    _message: FiberMessage.FiberMessage\n  ) => {\n    throw new Error(\"It is illegal to have multiple concurrent run loops in a single fiber\")\n  },\n  [FiberMessage.OP_STATEFUL]: (\n    self: FiberRuntime<any, any>,\n    runtimeFlags: RuntimeFlags.RuntimeFlags,\n    cur: Effect.Effect<any, any, any>,\n    message: FiberMessage.FiberMessage & { _tag: FiberMessage.OP_STATEFUL }\n  ) => {\n    message.onFiber(self, FiberStatus.running(runtimeFlags))\n    return cur\n  },\n  [FiberMessage.OP_YIELD_NOW]: (\n    _self: FiberRuntime<any, any>,\n    _runtimeFlags: RuntimeFlags.RuntimeFlags,\n    cur: Effect.Effect<any, any, any>,\n    _message: FiberMessage.FiberMessage & { _tag: FiberMessage.OP_YIELD_NOW }\n  ) => {\n    return core.flatMap(core.yieldNow(), () => cur)\n  }\n}\n\n/**\n * Executes all requests, submitting requests to each data source in parallel.\n */\nconst runBlockedRequests = (self: RequestBlock.RequestBlock) =>\n  core.forEachSequentialDiscard(\n    RequestBlock_.flatten(self),\n    (requestsByRequestResolver) =>\n      forEachConcurrentDiscard(\n        RequestBlock_.sequentialCollectionToChunk(requestsByRequestResolver),\n        ([dataSource, sequential]) => {\n          const map = new Map<Request<any, any>, Entry<any>>()\n          const arr: Array<Array<Entry<any>>> = []\n          for (const block of sequential) {\n            arr.push(Chunk.toReadonlyArray(block) as any)\n            for (const entry of block) {\n              map.set(entry.request as Request<any, any>, entry)\n            }\n          }\n          const flat = arr.flat()\n          return core.fiberRefLocally(\n            invokeWithInterrupt(dataSource.runAll(arr), flat, () =>\n              flat.forEach((entry) => {\n                entry.listeners.interrupted = true\n              })),\n            currentRequestMap,\n            map\n          )\n        },\n        false,\n        false\n      )\n  )\n\n/** @internal */\nexport interface Snapshot {\n  refs: FiberRefs.FiberRefs\n  flags: RuntimeFlags.RuntimeFlags\n}\n\nconst _version = version.getCurrentVersion()\n\n/** @internal */\nexport class FiberRuntime<in out A, in out E = never> extends Effectable.Class<A, E>\n  implements Fiber.RuntimeFiber<A, E>\n{\n  readonly [internalFiber.FiberTypeId] = internalFiber.fiberVariance\n  readonly [internalFiber.RuntimeFiberTypeId] = runtimeFiberVariance\n  private _fiberRefs: FiberRefs.FiberRefs\n  private _fiberId: FiberId.Runtime\n  private _queue = new Array<FiberMessage.FiberMessage>()\n  private _children: Set<FiberRuntime<any, any>> | null = null\n  private _observers = new Array<(exit: Exit.Exit<A, E>) => void>()\n  private _running = false\n  private _stack: Array<core.Continuation> = []\n  private _asyncInterruptor: ((effect: Effect.Effect<any, any, any>) => any) | null = null\n  private _asyncBlockingOn: FiberId.FiberId | null = null\n  private _exitValue: Exit.Exit<A, E> | null = null\n  private _steps: Array<Snapshot> = []\n  private _isYielding = false\n\n  public currentRuntimeFlags: RuntimeFlags.RuntimeFlags\n  public currentOpCount: number = 0\n  public currentSupervisor!: Supervisor.Supervisor<any>\n  public currentScheduler!: Scheduler\n  public currentTracer!: Tracer.Tracer\n  public currentSpan!: Tracer.AnySpan | undefined\n  public currentContext!: Context.Context<never>\n  public currentDefaultServices!: Context.Context<DefaultServices>\n\n  constructor(\n    fiberId: FiberId.Runtime,\n    fiberRefs0: FiberRefs.FiberRefs,\n    runtimeFlags0: RuntimeFlags.RuntimeFlags\n  ) {\n    super()\n    this.currentRuntimeFlags = runtimeFlags0\n    this._fiberId = fiberId\n    this._fiberRefs = fiberRefs0\n    if (runtimeFlags_.runtimeMetrics(runtimeFlags0)) {\n      const tags = this.getFiberRef(core.currentMetricLabels)\n      fiberStarted.unsafeUpdate(1, tags)\n      fiberActive.unsafeUpdate(1, tags)\n    }\n    this.refreshRefCache()\n  }\n\n  commit(): Effect.Effect<A, E, never> {\n    return internalFiber.join(this)\n  }\n\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.Runtime {\n    return this._fiberId\n  }\n\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background. This can be called to \"kick off\" execution of a fiber after\n   * it has been created.\n   */\n  resume<A, E>(effect: Effect.Effect<A, E, any>): void {\n    this.tell(FiberMessage.resume(effect))\n  }\n\n  /**\n   * The status of the fiber.\n   */\n  get status(): Effect.Effect<FiberStatus.FiberStatus> {\n    return this.ask((_, status) => status)\n  }\n\n  /**\n   * Gets the fiber runtime flags.\n   */\n  get runtimeFlags(): Effect.Effect<RuntimeFlags.RuntimeFlags> {\n    return this.ask((state, status) => {\n      if (FiberStatus.isDone(status)) {\n        return state.currentRuntimeFlags\n      }\n      return status.runtimeFlags\n    })\n  }\n\n  /**\n   * Returns the current `FiberScope` for the fiber.\n   */\n  scope(): fiberScope.FiberScope {\n    return fiberScope.unsafeMake(this)\n  }\n\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  get children(): Effect.Effect<Array<Fiber.RuntimeFiber<any, any>>> {\n    return this.ask((fiber) => Array.from(fiber.getChildren()))\n  }\n\n  /**\n   * Gets the fiber's set of children.\n   */\n  getChildren(): Set<FiberRuntime<any, any>> {\n    if (this._children === null) {\n      this._children = new Set()\n    }\n    return this._children\n  }\n\n  /**\n   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`\n   * if the fiber has not been interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getInterruptedCause() {\n    return this.getFiberRef(core.currentInterruptedCause)\n  }\n\n  /**\n   * Retrieves the whole set of fiber refs.\n   */\n  fiberRefs(): Effect.Effect<FiberRefs.FiberRefs> {\n    return this.ask((fiber) => fiber.getFiberRefs())\n  }\n\n  /**\n   * Returns an effect that will contain information computed from the fiber\n   * state and status while running on the fiber.\n   *\n   * This allows the outside world to interact safely with mutable fiber state\n   * without locks or immutable data.\n   */\n  ask<Z>(\n    f: (runtime: FiberRuntime<any, any>, status: FiberStatus.FiberStatus) => Z\n  ): Effect.Effect<Z> {\n    return core.suspend(() => {\n      const deferred = core.deferredUnsafeMake<Z>(this._fiberId)\n      this.tell(\n        FiberMessage.stateful((fiber, status) => {\n          core.deferredUnsafeDone(deferred, core.sync(() => f(fiber, status)))\n        })\n      )\n      return core.deferredAwait(deferred)\n    })\n  }\n\n  /**\n   * Adds a message to be processed by the fiber on the fiber.\n   */\n  tell(message: FiberMessage.FiberMessage): void {\n    this._queue.push(message)\n    if (!this._running) {\n      this._running = true\n      this.drainQueueLaterOnExecutor()\n    }\n  }\n\n  get await(): Effect.Effect<Exit.Exit<A, E>> {\n    return core.async((resume) => {\n      const cb = (exit: Exit.Exit<A, E>) => resume(core.succeed(exit))\n      this.tell(\n        FiberMessage.stateful((fiber, _) => {\n          if (fiber._exitValue !== null) {\n            cb(this._exitValue!)\n          } else {\n            fiber.addObserver(cb)\n          }\n        })\n      )\n      return core.sync(() =>\n        this.tell(\n          FiberMessage.stateful((fiber, _) => {\n            fiber.removeObserver(cb)\n          })\n        )\n      )\n    }, this.id())\n  }\n\n  get inheritAll(): Effect.Effect<void> {\n    return core.withFiberRuntime((parentFiber, parentStatus) => {\n      const parentFiberId = parentFiber.id()\n      const parentFiberRefs = parentFiber.getFiberRefs()\n      const parentRuntimeFlags = parentStatus.runtimeFlags\n      const childFiberRefs = this.getFiberRefs()\n      const updatedFiberRefs = fiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs)\n\n      parentFiber.setFiberRefs(updatedFiberRefs)\n\n      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags)\n\n      const patch = pipe(\n        runtimeFlags_.diff(parentRuntimeFlags, updatedRuntimeFlags),\n        // Do not inherit WindDown or Interruption!\n        RuntimeFlagsPatch.exclude(runtimeFlags_.Interruption),\n        RuntimeFlagsPatch.exclude(runtimeFlags_.WindDown)\n      )\n\n      return core.updateRuntimeFlags(patch)\n    })\n  }\n\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  get poll(): Effect.Effect<Option.Option<Exit.Exit<A, E>>> {\n    return core.sync(() => Option.fromNullable(this._exitValue))\n  }\n\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll(): Exit.Exit<A, E> | null {\n    return this._exitValue\n  }\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void> {\n    return core.sync(() => this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId))))\n  }\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  unsafeInterruptAsFork(fiberId: FiberId.FiberId) {\n    this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId)))\n  }\n\n  /**\n   * Adds an observer to the list of observers.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void {\n    if (this._exitValue !== null) {\n      observer(this._exitValue!)\n    } else {\n      this._observers.push(observer)\n    }\n  }\n\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void {\n    this._observers = this._observers.filter((o) => o !== observer)\n  }\n  /**\n   * Retrieves all fiber refs of the fiber.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRefs(): FiberRefs.FiberRefs {\n    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags)\n    return this._fiberRefs\n  }\n\n  /**\n   * Deletes the specified fiber ref.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeDeleteFiberRef<X>(fiberRef: FiberRef.FiberRef<X>): void {\n    this._fiberRefs = fiberRefs.delete_(this._fiberRefs, fiberRef)\n  }\n\n  /**\n   * Retrieves the state of the fiber ref, or else its initial value.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRef<X>(fiberRef: FiberRef.FiberRef<X>): X {\n    if (this._fiberRefs.locals.has(fiberRef)) {\n      return this._fiberRefs.locals.get(fiberRef)![0][1] as X\n    }\n    return fiberRef.initial\n  }\n\n  /**\n   * Sets the fiber ref to the specified value.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRef<X>(fiberRef: FiberRef.FiberRef<X>, value: X): void {\n    this._fiberRefs = fiberRefs.updateAs(this._fiberRefs, {\n      fiberId: this._fiberId,\n      fiberRef,\n      value\n    })\n    this.refreshRefCache()\n  }\n\n  refreshRefCache() {\n    this.currentDefaultServices = this.getFiberRef(defaultServices.currentServices)\n    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracer.tracerTag.key)\n    this.currentSupervisor = this.getFiberRef(currentSupervisor)\n    this.currentScheduler = this.getFiberRef(currentScheduler)\n    this.currentContext = this.getFiberRef(core.currentContext)\n    this.currentSpan = this.currentContext.unsafeMap.get(tracer.spanTag.key)\n  }\n\n  /**\n   * Wholesale replaces all fiber refs of this fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRefs(fiberRefs: FiberRefs.FiberRefs): void {\n    this._fiberRefs = fiberRefs\n    this.refreshRefCache()\n  }\n\n  /**\n   * Adds a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addChild(child: FiberRuntime<any, any>) {\n    this.getChildren().add(child)\n  }\n\n  /**\n   * Removes a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeChild(child: FiberRuntime<any, any>) {\n    this.getChildren().delete(child)\n  }\n\n  /**\n   * Transfers all children of this fiber that are currently running to the\n   * specified fiber scope.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself after it has\n   * evaluated the effects but prior to exiting.\n   */\n  transferChildren(scope: fiberScope.FiberScope) {\n    const children = this._children\n    // Clear the children of the current fiber\n    this._children = null\n    if (children !== null && children.size > 0) {\n      for (const child of children) {\n        // If the child is still running, add it to the scope\n        if (child._exitValue === null) {\n          scope.add(this.currentRuntimeFlags, child)\n        }\n      }\n    }\n  }\n\n  /**\n   * On the current thread, executes all messages in the fiber's inbox. This\n   * method may return before all work is done, in the event the fiber executes\n   * an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueOnCurrentThread() {\n    let recurse = true\n    while (recurse) {\n      let evaluationSignal: EvaluationSignal = EvaluationSignalContinue\n      const prev = (globalThis as any)[internalFiber.currentFiberURI]\n      ;(globalThis as any)[internalFiber.currentFiberURI] = this\n      try {\n        while (evaluationSignal === EvaluationSignalContinue) {\n          evaluationSignal = this._queue.length === 0 ?\n            EvaluationSignalDone :\n            this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]!)\n        }\n      } finally {\n        this._running = false\n        ;(globalThis as any)[internalFiber.currentFiberURI] = prev\n      }\n      // Maybe someone added something to the queue between us checking, and us\n      // giving up the drain. If so, we need to restart the draining, but only\n      // if we beat everyone else to the restart:\n      if (this._queue.length > 0 && !this._running) {\n        this._running = true\n        if (evaluationSignal === EvaluationSignalYieldNow) {\n          this.drainQueueLaterOnExecutor()\n          recurse = false\n        } else {\n          recurse = true\n        }\n      } else {\n        recurse = false\n      }\n    }\n  }\n\n  /**\n   * Schedules the execution of all messages in the fiber's inbox.\n   *\n   * This method will return immediately after the scheduling\n   * operation is completed, but potentially before such messages have been\n   * executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueLaterOnExecutor() {\n    this.currentScheduler.scheduleTask(\n      this.run,\n      this.getFiberRef(core.currentSchedulingPriority)\n    )\n  }\n\n  /**\n   * Drains the fiber's message queue while the fiber is actively running,\n   * returning the next effect to execute, which may be the input effect if no\n   * additional effect needs to be executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueWhileRunning(\n    runtimeFlags: RuntimeFlags.RuntimeFlags,\n    cur0: Effect.Effect<any, any, any>\n  ) {\n    let cur = cur0\n    while (this._queue.length > 0) {\n      const message = this._queue.splice(0, 1)[0]\n      // @ts-expect-error\n      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message)\n    }\n    return cur\n  }\n\n  /**\n   * Determines if the fiber is interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  isInterrupted(): boolean {\n    return !internalCause.isEmpty(this.getFiberRef(core.currentInterruptedCause))\n  }\n\n  /**\n   * Adds an interruptor to the set of interruptors that are interrupting this\n   * fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addInterruptedCause(cause: Cause.Cause<never>) {\n    const oldSC = this.getFiberRef(core.currentInterruptedCause)\n    this.setFiberRef(core.currentInterruptedCause, internalCause.sequential(oldSC, cause))\n  }\n\n  /**\n   * Processes a new incoming interrupt signal.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  processNewInterruptSignal(cause: Cause.Cause<never>): void {\n    this.addInterruptedCause(cause)\n    this.sendInterruptSignalToAllChildren()\n  }\n\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  sendInterruptSignalToAllChildren(): boolean {\n    if (this._children === null || this._children.size === 0) {\n      return false\n    }\n    let told = false\n    for (const child of this._children) {\n      child.tell(FiberMessage.interruptSignal(internalCause.interrupt(this.id())))\n      told = true\n    }\n    return told\n  }\n\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  interruptAllChildren() {\n    if (this.sendInterruptSignalToAllChildren()) {\n      const it = this._children!.values()\n      this._children = null\n      let isDone = false\n      const body = () => {\n        const next = it.next()\n        if (!next.done) {\n          return core.asVoid(next.value.await)\n        } else {\n          return core.sync(() => {\n            isDone = true\n          })\n        }\n      }\n      return core.whileLoop({\n        while: () => !isDone,\n        body,\n        step: () => {\n          //\n        }\n      })\n    }\n    return null\n  }\n\n  reportExitValue(exit: Exit.Exit<A, E>) {\n    if (runtimeFlags_.runtimeMetrics(this.currentRuntimeFlags)) {\n      const tags = this.getFiberRef(core.currentMetricLabels)\n      const startTimeMillis = this.id().startTimeMillis\n      const endTimeMillis = Date.now()\n      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags)\n      fiberActive.unsafeUpdate(-1, tags)\n      switch (exit._tag) {\n        case OpCodes.OP_SUCCESS: {\n          fiberSuccesses.unsafeUpdate(1, tags)\n          break\n        }\n        case OpCodes.OP_FAILURE: {\n          fiberFailures.unsafeUpdate(1, tags)\n          break\n        }\n      }\n    }\n    if (exit._tag === \"Failure\") {\n      const level = this.getFiberRef(core.currentUnhandledErrorLogLevel)\n      if (!internalCause.isInterruptedOnly(exit.cause) && level._tag === \"Some\") {\n        this.log(\"Fiber terminated with an unhandled error\", exit.cause, level)\n      }\n    }\n  }\n\n  setExitValue(exit: Exit.Exit<A, E>) {\n    this._exitValue = exit\n    this.reportExitValue(exit)\n    for (let i = this._observers.length - 1; i >= 0; i--) {\n      this._observers[i](exit)\n    }\n    this._observers = []\n  }\n\n  getLoggers() {\n    return this.getFiberRef(currentLoggers)\n  }\n\n  log(\n    message: unknown,\n    cause: Cause.Cause<any>,\n    overrideLogLevel: Option.Option<LogLevel.LogLevel>\n  ): void {\n    const logLevel = Option.isSome(overrideLogLevel) ?\n      overrideLogLevel.value :\n      this.getFiberRef(core.currentLogLevel)\n    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel)\n    if (LogLevel.greaterThan(minimumLogLevel, logLevel)) {\n      return\n    }\n    const spans = this.getFiberRef(core.currentLogSpan)\n    const annotations = this.getFiberRef(core.currentLogAnnotations)\n    const loggers = this.getLoggers()\n    const contextMap = this.getFiberRefs()\n    if (HashSet.size(loggers) > 0) {\n      const clockService = Context.get(this.getFiberRef(defaultServices.currentServices), clock.clockTag)\n      const date = new Date(clockService.unsafeCurrentTimeMillis())\n      Inspectable.withRedactableContext(contextMap, () => {\n        for (const logger of loggers) {\n          logger.log({\n            fiberId: this.id(),\n            logLevel,\n            message,\n            cause,\n            context: contextMap,\n            spans,\n            annotations,\n            date\n          })\n        }\n      })\n    }\n  }\n\n  /**\n   * Evaluates a single message on the current thread, while the fiber is\n   * suspended. This method should only be called while evaluation of the\n   * fiber's effect is suspended due to an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateMessageWhileSuspended(message: FiberMessage.FiberMessage): EvaluationSignal {\n    switch (message._tag) {\n      case FiberMessage.OP_YIELD_NOW: {\n        return EvaluationSignalYieldNow\n      }\n      case FiberMessage.OP_INTERRUPT_SIGNAL: {\n        this.processNewInterruptSignal(message.cause)\n        if (this._asyncInterruptor !== null) {\n          this._asyncInterruptor(core.exitFailCause(message.cause))\n          this._asyncInterruptor = null\n        }\n        return EvaluationSignalContinue\n      }\n      case FiberMessage.OP_RESUME: {\n        this._asyncInterruptor = null\n        this._asyncBlockingOn = null\n        this.evaluateEffect(message.effect)\n        return EvaluationSignalContinue\n      }\n      case FiberMessage.OP_STATEFUL: {\n        message.onFiber(\n          this,\n          this._exitValue !== null ?\n            FiberStatus.done :\n            FiberStatus.suspended(this.currentRuntimeFlags, this._asyncBlockingOn!)\n        )\n        return EvaluationSignalContinue\n      }\n      default: {\n        return absurd(message)\n      }\n    }\n  }\n\n  /**\n   * Evaluates an effect until completion, potentially asynchronously.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateEffect(effect0: Effect.Effect<any, any, any>) {\n    this.currentSupervisor.onResume(this)\n    try {\n      let effect: Effect.Effect<any, any, any> | null =\n        runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted() ?\n          core.exitFailCause(this.getInterruptedCause()) :\n          effect0\n      while (effect !== null) {\n        const eff: Effect.Effect<any, any, any> = effect\n        const exit = this.runLoop(eff)\n        if (exit === YieldedOp) {\n          const op = yieldedOpChannel.currentOp!\n          yieldedOpChannel.currentOp = null\n          if (op._op === OpCodes.OP_YIELD) {\n            if (runtimeFlags_.cooperativeYielding(this.currentRuntimeFlags)) {\n              this.tell(FiberMessage.yieldNow())\n              this.tell(FiberMessage.resume(core.exitVoid))\n              effect = null\n            } else {\n              effect = core.exitVoid\n            }\n          } else if (op._op === OpCodes.OP_ASYNC) {\n            // Terminate this evaluation, async resumption will continue evaluation:\n            effect = null\n          }\n        } else {\n          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, runtimeFlags_.enable(runtimeFlags_.WindDown))\n          const interruption = this.interruptAllChildren()\n          if (interruption !== null) {\n            effect = core.flatMap(interruption, () => exit)\n          } else {\n            if (this._queue.length === 0) {\n              // No more messages to process, so we will allow the fiber to end life:\n              this.setExitValue(exit)\n            } else {\n              // There are messages, possibly added by the final op executed by\n              // the fiber. To be safe, we should execute those now before we\n              // allow the fiber to end life:\n              this.tell(FiberMessage.resume(exit))\n            }\n            effect = null\n          }\n        }\n      }\n    } finally {\n      this.currentSupervisor.onSuspend(this)\n    }\n  }\n\n  /**\n   * Begins execution of the effect associated with this fiber on the current\n   * thread. This can be called to \"kick off\" execution of a fiber after it has\n   * been created, in hopes that the effect can be executed synchronously.\n   *\n   * This is not the normal way of starting a fiber, but it is useful when the\n   * express goal of executing the fiber is to synchronously produce its exit.\n   */\n  start<R>(effect: Effect.Effect<A, E, R>): void {\n    if (!this._running) {\n      this._running = true\n      const prev = (globalThis as any)[internalFiber.currentFiberURI]\n      ;(globalThis as any)[internalFiber.currentFiberURI] = this\n      try {\n        this.evaluateEffect(effect)\n      } finally {\n        this._running = false\n        ;(globalThis as any)[internalFiber.currentFiberURI] = prev\n        // Because we're special casing `start`, we have to be responsible\n        // for spinning up the fiber if there were new messages added to\n        // the queue between the completion of the effect and the transition\n        // to the not running state.\n        if (this._queue.length > 0) {\n          this.drainQueueLaterOnExecutor()\n        }\n      }\n    } else {\n      this.tell(FiberMessage.resume(effect))\n    }\n  }\n\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background, and on the correct thread pool. This can be called to \"kick\n   * off\" execution of a fiber after it has been created, in hopes that the\n   * effect can be executed synchronously.\n   */\n  startFork<R>(effect: Effect.Effect<A, E, R>): void {\n    this.tell(FiberMessage.resume(effect))\n  }\n\n  /**\n   * Takes the current runtime flags, patches them to return the new runtime\n   * flags, and then makes any changes necessary to fiber state based on the\n   * specified patch.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  patchRuntimeFlags(oldRuntimeFlags: RuntimeFlags.RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch) {\n    const newRuntimeFlags = runtimeFlags_.patch(oldRuntimeFlags, patch)\n    ;(globalThis as any)[internalFiber.currentFiberURI] = this\n    this.currentRuntimeFlags = newRuntimeFlags\n    return newRuntimeFlags\n  }\n\n  /**\n   * Initiates an asynchronous operation, by building a callback that will\n   * resume execution, and then feeding that callback to the registration\n   * function, handling error cases and repeated resumptions appropriately.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  initiateAsync(\n    runtimeFlags: RuntimeFlags.RuntimeFlags,\n    asyncRegister: (resume: (effect: Effect.Effect<any, any, any>) => void) => void\n  ) {\n    let alreadyCalled = false\n    const callback = (effect: Effect.Effect<any, any, any>) => {\n      if (!alreadyCalled) {\n        alreadyCalled = true\n        this.tell(FiberMessage.resume(effect))\n      }\n    }\n    if (runtimeFlags_.interruptible(runtimeFlags)) {\n      this._asyncInterruptor = callback\n    }\n    try {\n      asyncRegister(callback)\n    } catch (e) {\n      callback(core.failCause(internalCause.die(e)))\n    }\n  }\n\n  pushStack(cont: core.Continuation) {\n    this._stack.push(cont)\n    if (cont._op === \"OnStep\") {\n      this._steps.push({ refs: this.getFiberRefs(), flags: this.currentRuntimeFlags })\n    }\n  }\n\n  popStack() {\n    const item = this._stack.pop()\n    if (item) {\n      if (item._op === \"OnStep\") {\n        this._steps.pop()\n      }\n      return item\n    }\n    return\n  }\n\n  getNextSuccessCont() {\n    let frame = this.popStack()\n    while (frame) {\n      if (frame._op !== OpCodes.OP_ON_FAILURE) {\n        return frame\n      }\n      frame = this.popStack()\n    }\n  }\n\n  getNextFailCont() {\n    let frame = this.popStack()\n    while (frame) {\n      if (frame._op !== OpCodes.OP_ON_SUCCESS && frame._op !== OpCodes.OP_WHILE && frame._op !== OpCodes.OP_ITERATOR) {\n        return frame\n      }\n      frame = this.popStack()\n    }\n  }\n\n  [OpCodes.OP_TAG](op: core.Primitive & { _op: OpCodes.OP_SYNC }) {\n    return core.sync(() => Context.unsafeGet(this.currentContext, op as unknown as Context.Tag<any, any>))\n  }\n\n  [\"Left\"](op: core.Primitive & { _op: \"Left\" }) {\n    return core.fail(op.left)\n  }\n\n  [\"None\"](_: core.Primitive & { _op: \"None\" }) {\n    return core.fail(new core.NoSuchElementException())\n  }\n\n  [\"Right\"](op: core.Primitive & { _op: \"Right\" }) {\n    return core.exitSucceed(op.right)\n  }\n\n  [\"Some\"](op: core.Primitive & { _op: \"Some\" }) {\n    return core.exitSucceed(op.value)\n  }\n\n  [\"Micro\"](op: Micro.Micro<any, any, never> & { _op: \"Micro\" }) {\n    return core.unsafeAsync<any, any>((microResume) => {\n      let resume = microResume\n      const fiber = Micro.runFork(Micro.provideContext(op, this.currentContext))\n      fiber.addObserver((exit) => {\n        if (exit._tag === \"Success\") {\n          return resume(core.exitSucceed(exit.value))\n        }\n        switch (exit.cause._tag) {\n          case \"Interrupt\": {\n            return resume(core.exitFailCause(internalCause.interrupt(FiberId.none)))\n          }\n          case \"Fail\": {\n            return resume(core.fail(exit.cause.error))\n          }\n          case \"Die\": {\n            return resume(core.die(exit.cause.defect))\n          }\n        }\n      })\n      return core.unsafeAsync<void>((abortResume) => {\n        resume = (_: any) => {\n          abortResume(core.void)\n        }\n        fiber.unsafeInterrupt()\n      })\n    })\n  }\n\n  [OpCodes.OP_SYNC](op: core.Primitive & { _op: OpCodes.OP_SYNC }) {\n    const value = internalCall(() => op.effect_instruction_i0())\n    const cont = this.getNextSuccessCont()\n    if (cont !== undefined) {\n      if (!(cont._op in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont)\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._op](this, cont, value)\n    } else {\n      yieldedOpChannel.currentOp = core.exitSucceed(value) as any\n      return YieldedOp\n    }\n  }\n\n  [OpCodes.OP_SUCCESS](op: core.Primitive & { _op: OpCodes.OP_SUCCESS }) {\n    const oldCur = op\n    const cont = this.getNextSuccessCont()\n    if (cont !== undefined) {\n      if (!(cont._op in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont)\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0)\n    } else {\n      yieldedOpChannel.currentOp = oldCur\n      return YieldedOp\n    }\n  }\n\n  [OpCodes.OP_FAILURE](op: core.Primitive & { _op: OpCodes.OP_FAILURE }) {\n    const cause = op.effect_instruction_i0\n    const cont = this.getNextFailCont()\n    if (cont !== undefined) {\n      switch (cont._op) {\n        case OpCodes.OP_ON_FAILURE:\n        case OpCodes.OP_ON_SUCCESS_AND_FAILURE: {\n          if (!(runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {\n            return internalCall(() => cont.effect_instruction_i1(cause))\n          } else {\n            return core.exitFailCause(internalCause.stripFailures(cause))\n          }\n        }\n        case \"OnStep\": {\n          if (!(runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {\n            return core.exitSucceed(core.exitFailCause(cause))\n          } else {\n            return core.exitFailCause(internalCause.stripFailures(cause))\n          }\n        }\n        case OpCodes.OP_REVERT_FLAGS: {\n          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch)\n          if (runtimeFlags_.interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {\n            return core.exitFailCause(internalCause.sequential(cause, this.getInterruptedCause()))\n          } else {\n            return core.exitFailCause(cause)\n          }\n        }\n        default: {\n          absurd(cont)\n        }\n      }\n    } else {\n      yieldedOpChannel.currentOp = core.exitFailCause(cause) as any\n      return YieldedOp\n    }\n  }\n\n  [OpCodes.OP_WITH_RUNTIME](op: core.Primitive & { _op: OpCodes.OP_WITH_RUNTIME }) {\n    return internalCall(() =>\n      op.effect_instruction_i0(\n        this as FiberRuntime<unknown, unknown>,\n        FiberStatus.running(this.currentRuntimeFlags) as FiberStatus.Running\n      )\n    )\n  }\n\n  [\"Blocked\"](op: core.Primitive & { _op: \"Blocked\" }) {\n    const refs = this.getFiberRefs()\n    const flags = this.currentRuntimeFlags\n    if (this._steps.length > 0) {\n      const frames: Array<core.Continuation> = []\n      const snap = this._steps[this._steps.length - 1]\n      let frame = this.popStack()\n      while (frame && frame._op !== \"OnStep\") {\n        frames.push(frame)\n        frame = this.popStack()\n      }\n      this.setFiberRefs(snap.refs)\n      this.currentRuntimeFlags = snap.flags\n      const patchRefs = FiberRefsPatch.diff(snap.refs, refs)\n      const patchFlags = runtimeFlags_.diff(snap.flags, flags)\n      return core.exitSucceed(core.blocked(\n        op.effect_instruction_i0,\n        core.withFiberRuntime<unknown, unknown>((newFiber) => {\n          while (frames.length > 0) {\n            newFiber.pushStack(frames.pop()!)\n          }\n          newFiber.setFiberRefs(\n            FiberRefsPatch.patch(newFiber.id(), newFiber.getFiberRefs())(patchRefs)\n          )\n          newFiber.currentRuntimeFlags = runtimeFlags_.patch(patchFlags)(newFiber.currentRuntimeFlags)\n          return op.effect_instruction_i1\n        })\n      ))\n    }\n    return core.uninterruptibleMask((restore) =>\n      core.flatMap(\n        forkDaemon(core.runRequestBlock(op.effect_instruction_i0)),\n        () => restore(op.effect_instruction_i1)\n      )\n    )\n  }\n\n  [\"RunBlocked\"](op: core.Primitive & { _op: \"RunBlocked\" }) {\n    return runBlockedRequests(op.effect_instruction_i0)\n  }\n\n  [OpCodes.OP_UPDATE_RUNTIME_FLAGS](op: core.Primitive & { _op: OpCodes.OP_UPDATE_RUNTIME_FLAGS }) {\n    const updateFlags = op.effect_instruction_i0\n    const oldRuntimeFlags = this.currentRuntimeFlags\n    const newRuntimeFlags = runtimeFlags_.patch(oldRuntimeFlags, updateFlags)\n    // One more chance to short circuit: if we're immediately going\n    // to interrupt. Interruption will cause immediate reversion of\n    // the flag, so as long as we \"peek ahead\", there's no need to\n    // set them to begin with.\n    if (runtimeFlags_.interruptible(newRuntimeFlags) && this.isInterrupted()) {\n      return core.exitFailCause(this.getInterruptedCause())\n    } else {\n      // Impossible to short circuit, so record the changes\n      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags)\n      if (op.effect_instruction_i1) {\n        // Since we updated the flags, we need to revert them\n        const revertFlags = runtimeFlags_.diff(newRuntimeFlags, oldRuntimeFlags)\n        this.pushStack(new core.RevertFlags(revertFlags, op))\n        return internalCall(() => op.effect_instruction_i1!(oldRuntimeFlags))\n      } else {\n        return core.exitVoid\n      }\n    }\n  }\n\n  [OpCodes.OP_ON_SUCCESS](op: core.Primitive & { _op: OpCodes.OP_ON_SUCCESS }) {\n    this.pushStack(op)\n    return op.effect_instruction_i0\n  }\n\n  [\"OnStep\"](op: core.Primitive & { _op: \"OnStep\" }) {\n    this.pushStack(op)\n    return op.effect_instruction_i0\n  }\n\n  [OpCodes.OP_ON_FAILURE](op: core.Primitive & { _op: OpCodes.OP_ON_FAILURE }) {\n    this.pushStack(op)\n    return op.effect_instruction_i0\n  }\n\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE](op: core.Primitive & { _op: OpCodes.OP_ON_SUCCESS_AND_FAILURE }) {\n    this.pushStack(op)\n    return op.effect_instruction_i0\n  }\n\n  [OpCodes.OP_ASYNC](op: core.Primitive & { _op: OpCodes.OP_ASYNC }) {\n    this._asyncBlockingOn = op.effect_instruction_i1\n    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0)\n    yieldedOpChannel.currentOp = op\n    return YieldedOp\n  }\n\n  [OpCodes.OP_YIELD](op: core.Primitive & { op: OpCodes.OP_YIELD }) {\n    this._isYielding = false\n    yieldedOpChannel.currentOp = op\n    return YieldedOp\n  }\n\n  [OpCodes.OP_WHILE](op: core.Primitive & { _op: OpCodes.OP_WHILE }) {\n    const check = op.effect_instruction_i0\n    const body = op.effect_instruction_i1\n    if (check()) {\n      this.pushStack(op)\n      return body()\n    } else {\n      return core.exitVoid\n    }\n  }\n\n  [OpCodes.OP_ITERATOR](op: core.Primitive & { _op: OpCodes.OP_ITERATOR }) {\n    return contOpSuccess[OpCodes.OP_ITERATOR](this, op, undefined)\n  }\n\n  [OpCodes.OP_COMMIT](op: core.Primitive & { _op: OpCodes.OP_COMMIT }) {\n    return internalCall(() => op.commit())\n  }\n\n  /**\n   * The main run-loop for evaluating effects.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  runLoop(effect0: Effect.Effect<any, any, any>): Exit.Exit<any, any> | YieldedOp {\n    let cur: Effect.Effect<any, any, any> | YieldedOp = effect0\n    this.currentOpCount = 0\n\n    while (true) {\n      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {\n        this.currentSupervisor.onEffect(this, cur)\n      }\n      if (this._queue.length > 0) {\n        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur)\n      }\n      if (!this._isYielding) {\n        this.currentOpCount += 1\n        const shouldYield = this.currentScheduler.shouldYield(this)\n        if (shouldYield !== false) {\n          this._isYielding = true\n          this.currentOpCount = 0\n          const oldCur = cur\n          cur = core.flatMap(core.yieldNow({ priority: shouldYield }), () => oldCur)\n        }\n      }\n      try {\n        // @ts-expect-error\n        cur = this.currentTracer.context(\n          () => {\n            if (_version !== (cur as core.Primitive)[core.EffectTypeId]._V) {\n              const level = this.getFiberRef(core.currentVersionMismatchErrorLogLevel)\n              if (level._tag === \"Some\") {\n                const effectVersion = (cur as core.Primitive)[core.EffectTypeId]._V\n                this.log(\n                  `Executing an Effect versioned ${effectVersion} with a Runtime of version ${version.getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`,\n                  internalCause.empty,\n                  level\n                )\n              }\n            }\n            // @ts-expect-error\n            return this[(cur as core.Primitive)._op](cur as core.Primitive)\n          },\n          this\n        )\n\n        if (cur === YieldedOp) {\n          const op = yieldedOpChannel.currentOp!\n          if (\n            op._op === OpCodes.OP_YIELD ||\n            op._op === OpCodes.OP_ASYNC\n          ) {\n            return YieldedOp\n          }\n\n          yieldedOpChannel.currentOp = null\n          return (\n              op._op === OpCodes.OP_SUCCESS ||\n              op._op === OpCodes.OP_FAILURE\n            ) ?\n            op as unknown as Exit.Exit<A, E> :\n            core.exitFailCause(internalCause.die(op))\n        }\n      } catch (e) {\n        if (cur !== YieldedOp && !Predicate.hasProperty(cur, \"_op\") || !((cur as core.Primitive)._op in this)) {\n          cur = core.dieMessage(`Not a valid effect: ${Inspectable.toStringUnknown(cur)}`)\n        } else if (core.isInterruptedException(e)) {\n          cur = core.exitFailCause(\n            internalCause.sequential(internalCause.die(e), internalCause.interrupt(FiberId.none))\n          )\n        } else {\n          cur = core.die(e)\n        }\n      }\n    }\n  }\n\n  run = () => {\n    this.drainQueueOnCurrentThread()\n  }\n}\n\n// circular with Logger\n\n/** @internal */\nexport const currentMinimumLogLevel: FiberRef.FiberRef<LogLevel.LogLevel> = globalValue(\n  \"effect/FiberRef/currentMinimumLogLevel\",\n  () => core.fiberRefUnsafeMake<LogLevel.LogLevel>(LogLevel.fromLiteral(\"Info\"))\n)\n\n/** @internal */\nexport const loggerWithConsoleLog = <M, O>(self: Logger<M, O>): Logger<M, void> =>\n  internalLogger.makeLogger((opts) => {\n    const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices)\n    Context.get(services, consoleTag).unsafe.log(self.log(opts))\n  })\n\n/** @internal */\nexport const loggerWithLeveledLog = <M, O>(self: Logger<M, O>): Logger<M, void> =>\n  internalLogger.makeLogger((opts) => {\n    const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices)\n    const unsafeLogger = Context.get(services, consoleTag).unsafe\n    switch (opts.logLevel._tag) {\n      case \"Debug\":\n        return unsafeLogger.debug(self.log(opts))\n      case \"Info\":\n        return unsafeLogger.info(self.log(opts))\n      case \"Trace\":\n        return unsafeLogger.trace(self.log(opts))\n      case \"Warning\":\n        return unsafeLogger.warn(self.log(opts))\n      case \"Error\":\n      case \"Fatal\":\n        return unsafeLogger.error(self.log(opts))\n      default:\n        return unsafeLogger.log(self.log(opts))\n    }\n  })\n\n/** @internal */\nexport const loggerWithConsoleError = <M, O>(self: Logger<M, O>): Logger<M, void> =>\n  internalLogger.makeLogger((opts) => {\n    const services = FiberRefs.getOrDefault(opts.context, defaultServices.currentServices)\n    Context.get(services, consoleTag).unsafe.error(self.log(opts))\n  })\n\n/** @internal */\nexport const defaultLogger: Logger<unknown, void> = globalValue(\n  Symbol.for(\"effect/Logger/defaultLogger\"),\n  () => loggerWithConsoleLog(internalLogger.stringLogger)\n)\n\n/** @internal */\nexport const jsonLogger: Logger<unknown, void> = globalValue(\n  Symbol.for(\"effect/Logger/jsonLogger\"),\n  () => loggerWithConsoleLog(internalLogger.jsonLogger)\n)\n\n/** @internal */\nexport const logFmtLogger: Logger<unknown, void> = globalValue(\n  Symbol.for(\"effect/Logger/logFmtLogger\"),\n  () => loggerWithConsoleLog(internalLogger.logfmtLogger)\n)\n\n/** @internal */\nexport const prettyLogger: Logger<unknown, void> = globalValue(\n  Symbol.for(\"effect/Logger/prettyLogger\"),\n  () => internalLogger.prettyLoggerDefault\n)\n\n/** @internal */\nexport const structuredLogger: Logger<unknown, void> = globalValue(\n  Symbol.for(\"effect/Logger/structuredLogger\"),\n  () => loggerWithConsoleLog(internalLogger.structuredLogger)\n)\n\n/** @internal */\nexport const tracerLogger = globalValue(\n  Symbol.for(\"effect/Logger/tracerLogger\"),\n  () =>\n    internalLogger.makeLogger<unknown, void>(({\n      annotations,\n      cause,\n      context,\n      fiberId,\n      logLevel,\n      message\n    }) => {\n      const span = Context.getOption(\n        fiberRefs.getOrDefault(context, core.currentContext),\n        tracer.spanTag\n      )\n      if (span._tag === \"None\" || span.value._tag === \"ExternalSpan\") {\n        return\n      }\n      const clockService = Context.unsafeGet(\n        fiberRefs.getOrDefault(context, defaultServices.currentServices),\n        clock.clockTag\n      )\n\n      const attributes: Record<string, unknown> = {}\n      for (const [key, value] of annotations) {\n        attributes[key] = value\n      }\n      attributes[\"effect.fiberId\"] = FiberId.threadName(fiberId)\n      attributes[\"effect.logLevel\"] = logLevel.label\n\n      if (cause !== null && cause._tag !== \"Empty\") {\n        attributes[\"effect.cause\"] = internalCause.pretty(cause, { renderErrorCause: true })\n      }\n\n      span.value.event(\n        Inspectable.toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message),\n        clockService.unsafeCurrentTimeNanos(),\n        attributes\n      )\n    })\n)\n\n/** @internal */\nexport const loggerWithSpanAnnotations = <Message, Output>(self: Logger<Message, Output>): Logger<Message, Output> =>\n  internalLogger.mapInputOptions(self, (options: Logger.Options<Message>) => {\n    const span = Option.flatMap(fiberRefs.get(options.context, core.currentContext), Context.getOption(tracer.spanTag))\n    if (span._tag === \"None\") {\n      return options\n    }\n    return {\n      ...options,\n      annotations: pipe(\n        options.annotations,\n        HashMap.set(\"effect.traceId\", span.value.traceId as unknown),\n        HashMap.set(\"effect.spanId\", span.value.spanId as unknown),\n        span.value._tag === \"Span\" ? HashMap.set(\"effect.spanName\", span.value.name as unknown) : identity\n      )\n    }\n  })\n\n/** @internal */\nexport const currentLoggers: FiberRef.FiberRef<\n  HashSet.HashSet<Logger<unknown, any>>\n> = globalValue(\n  Symbol.for(\"effect/FiberRef/currentLoggers\"),\n  () => core.fiberRefUnsafeMakeHashSet(HashSet.make(defaultLogger, tracerLogger))\n)\n\n/** @internal */\nexport const batchedLogger = dual<\n  <Output, R>(\n    window: Duration.DurationInput,\n    f: (messages: Array<NoInfer<Output>>) => Effect.Effect<void, never, R>\n  ) => <Message>(\n    self: Logger<Message, Output>\n  ) => Effect.Effect<Logger<Message, void>, never, Scope.Scope | R>,\n  <Message, Output, R>(\n    self: Logger<Message, Output>,\n    window: Duration.DurationInput,\n    f: (messages: Array<NoInfer<Output>>) => Effect.Effect<void, never, R>\n  ) => Effect.Effect<Logger<Message, void>, never, Scope.Scope | R>\n>(3, <Message, Output, R>(\n  self: Logger<Message, Output>,\n  window: Duration.DurationInput,\n  f: (messages: Array<NoInfer<Output>>) => Effect.Effect<void, never, R>\n): Effect.Effect<Logger<Message, void>, never, Scope.Scope | R> =>\n  core.flatMap(scope, (scope) => {\n    let buffer: Array<Output> = []\n    const flush = core.suspend(() => {\n      if (buffer.length === 0) {\n        return core.void\n      }\n      const arr = buffer\n      buffer = []\n      return f(arr)\n    })\n\n    return core.uninterruptibleMask((restore) =>\n      pipe(\n        internalEffect.sleep(window),\n        core.zipRight(flush),\n        internalEffect.forever,\n        restore,\n        forkDaemon,\n        core.flatMap((fiber) => core.scopeAddFinalizer(scope, core.interruptFiber(fiber))),\n        core.zipRight(addFinalizer(() => flush)),\n        core.as(\n          internalLogger.makeLogger((options) => {\n            buffer.push(self.log(options))\n          })\n        )\n      )\n    )\n  }))\n\nexport const annotateLogsScoped: {\n  (key: string, value: unknown): Effect.Effect<void, never, Scope.Scope>\n  (values: Record<string, unknown>): Effect.Effect<void, never, Scope.Scope>\n} = function() {\n  if (typeof arguments[0] === \"string\") {\n    return fiberRefLocallyScopedWith(\n      core.currentLogAnnotations,\n      HashMap.set(arguments[0], arguments[1])\n    )\n  }\n  const entries = Object.entries(arguments[0])\n  return fiberRefLocallyScopedWith(\n    core.currentLogAnnotations,\n    HashMap.mutate((annotations) => {\n      for (let i = 0; i < entries.length; i++) {\n        const [key, value] = entries[i]\n        HashMap.set(annotations, key, value)\n      }\n      return annotations\n    })\n  )\n}\n\n/** @internal */\nexport const whenLogLevel = dual<\n  (\n    level: LogLevel.LogLevel | LogLevel.Literal\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    level: LogLevel.LogLevel | LogLevel.Literal\n  ) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (effect, level) => {\n  const requiredLogLevel = typeof level === \"string\" ? LogLevel.fromLiteral(level) : level\n\n  return core.withFiberRuntime((fiberState) => {\n    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel)\n\n    // Imitate the behaviour of `FiberRuntime.log`\n    if (LogLevel.greaterThan(minimumLogLevel, requiredLogLevel)) {\n      return core.succeed(Option.none())\n    }\n\n    return core.map(effect, Option.some)\n  })\n})\n\n// circular with Effect\n\n/* @internal */\nexport const acquireRelease: {\n  <A, X, R2>(\n    release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>\n  ): <E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R2 | R | Scope.Scope>\n  <A, E, R, X, R2>(\n    acquire: Effect.Effect<A, E, R>,\n    release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, R2 | R | Scope.Scope>\n} = dual((args) => core.isEffect(args[0]), (acquire, release) =>\n  core.uninterruptible(\n    core.tap(acquire, (a) => addFinalizer((exit) => release(a, exit)))\n  ))\n\n/* @internal */\nexport const acquireReleaseInterruptible: {\n  <X, R2>(\n    release: (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>\n  ): <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Scope.Scope | R2 | R>\n  <A, E, R, X, R2>(\n    acquire: Effect.Effect<A, E, R>,\n    release: (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>\n  ): Effect.Effect<A, E, Scope.Scope | R2 | R>\n} = dual((args) => core.isEffect(args[0]), (acquire, release) =>\n  ensuring(\n    acquire,\n    addFinalizer((exit) => release(exit))\n  ))\n\n/* @internal */\nexport const addFinalizer = <X, R>(\n  finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R>\n): Effect.Effect<void, never, R | Scope.Scope> =>\n  core.withFiberRuntime(\n    (runtime) => {\n      const acquireRefs = runtime.getFiberRefs()\n      const acquireFlags = runtimeFlags_.disable(runtime.currentRuntimeFlags, runtimeFlags_.Interruption)\n      return core.flatMap(scope, (scope) =>\n        core.scopeAddFinalizerExit(scope, (exit) =>\n          core.withFiberRuntime((runtimeFinalizer) => {\n            const preRefs = runtimeFinalizer.getFiberRefs()\n            const preFlags = runtimeFinalizer.currentRuntimeFlags\n            const patchRefs = FiberRefsPatch.diff(preRefs, acquireRefs)\n            const patchFlags = runtimeFlags_.diff(preFlags, acquireFlags)\n            const inverseRefs = FiberRefsPatch.diff(acquireRefs, preRefs)\n            runtimeFinalizer.setFiberRefs(\n              FiberRefsPatch.patch(patchRefs, runtimeFinalizer.id(), acquireRefs)\n            )\n\n            return ensuring(\n              core.withRuntimeFlags(finalizer(exit) as Effect.Effect<X>, patchFlags),\n              core.sync(() => {\n                runtimeFinalizer.setFiberRefs(\n                  FiberRefsPatch.patch(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs())\n                )\n              })\n            )\n          })))\n    }\n  )\n\n/* @internal */\nexport const daemonChildren = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n  const forkScope = core.fiberRefLocally(core.currentForkScopeOverride, Option.some(fiberScope.globalScope))\n  return forkScope(self)\n}\n\n/** @internal */\nconst _existsParFound = Symbol.for(\"effect/Effect/existsPar/found\")\n\n/* @internal */\nexport const exists: {\n  <A, E, R>(predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }): (elements: Iterable<A>) => Effect.Effect<boolean, E, R>\n  <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }): Effect.Effect<boolean, E, R>\n} = dual(\n  (args) => Predicate.isIterable(args[0]) && !core.isEffect(args[0]),\n  <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n  }) =>\n    concurrency.matchSimple(\n      options?.concurrency,\n      () => core.suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)),\n      () =>\n        core.matchEffect(\n          forEach(\n            elements,\n            (a, i) => core.if_(predicate(a, i), { onTrue: () => core.fail(_existsParFound), onFalse: () => core.void }),\n            options\n          ),\n          {\n            onFailure: (e) => e === _existsParFound ? core.succeed(true) : core.fail(e),\n            onSuccess: () => core.succeed(false)\n          }\n        )\n    )\n)\n\nconst existsLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>\n): Effect.Effect<boolean, E, R> => {\n  const next = iterator.next()\n  if (next.done) {\n    return core.succeed(false)\n  }\n  return core.flatMap(\n    f(next.value, index),\n    (b) => b ? core.succeed(b) : existsLoop(iterator, index + 1, f)\n  )\n}\n\n/* @internal */\nexport const filter = dual<\n  <A, E, R>(\n    predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly negate?: boolean | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>,\n  <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly negate?: boolean | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }) => Effect.Effect<Array<A>, E, R>\n>(\n  (args) => Predicate.isIterable(args[0]) && !core.isEffect(args[0]),\n  <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly negate?: boolean | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }) => {\n    const predicate_ = options?.negate ? (a: A, i: number) => core.map(predicate(a, i), Boolean.not) : predicate\n    return concurrency.matchSimple(\n      options?.concurrency,\n      () =>\n        core.suspend(() =>\n          RA.fromIterable(elements).reduceRight(\n            (effect, a, i) =>\n              core.zipWith(\n                effect,\n                core.suspend(() => predicate_(a, i)),\n                (list, b) => b ? [a, ...list] : list\n              ),\n            core.sync(() => new Array<A>()) as Effect.Effect<Array<A>, E, R>\n          )\n        ),\n      () =>\n        core.map(\n          forEach(\n            elements,\n            (a, i) => core.map(predicate_(a, i), (b) => (b ? Option.some(a) : Option.none())),\n            options\n          ),\n          RA.getSomes\n        )\n    )\n  }\n)\n\n// === all\n\nconst allResolveInput = (\n  input: Iterable<Effect.Effect<any, any, any>> | Record<string, Effect.Effect<any, any, any>>\n): [Iterable<Effect.Effect<any, any, any>>, Option.Option<(as: ReadonlyArray<any>) => any>] => {\n  if (Array.isArray(input) || Predicate.isIterable(input)) {\n    return [input, Option.none()]\n  }\n  const keys = Object.keys(input)\n  const size = keys.length\n  return [\n    keys.map((k) => input[k]),\n    Option.some((values: ReadonlyArray<any>) => {\n      const res = {}\n      for (let i = 0; i < size; i++) {\n        ;(res as any)[keys[i]] = values[i]\n      }\n      return res\n    })\n  ]\n}\n\nconst allValidate = (\n  effects: Iterable<Effect.Effect<any, any, any>>,\n  reconcile: Option.Option<(as: ReadonlyArray<any>) => any>,\n  options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n) => {\n  const eitherEffects: Array<Effect.Effect<Either.Either<unknown, unknown>, never, unknown>> = []\n  for (const effect of effects) {\n    eitherEffects.push(core.either(effect))\n  }\n  return core.flatMap(\n    forEach(eitherEffects, identity, {\n      concurrency: options?.concurrency,\n      batching: options?.batching,\n      concurrentFinalizers: options?.concurrentFinalizers\n    }),\n    (eithers) => {\n      const none = Option.none()\n      const size = eithers.length\n      const errors: Array<unknown> = new Array(size)\n      const successes: Array<unknown> = new Array(size)\n      let errored = false\n      for (let i = 0; i < size; i++) {\n        const either = eithers[i] as Either.Either<unknown, unknown>\n        if (either._tag === \"Left\") {\n          errors[i] = Option.some(either.left)\n          errored = true\n        } else {\n          successes[i] = either.right\n          errors[i] = none\n        }\n      }\n      if (errored) {\n        return reconcile._tag === \"Some\" ?\n          core.fail(reconcile.value(errors)) :\n          core.fail(errors)\n      } else if (options?.discard) {\n        return core.void\n      }\n      return reconcile._tag === \"Some\" ?\n        core.succeed(reconcile.value(successes)) :\n        core.succeed(successes)\n    }\n  )\n}\n\nconst allEither = (\n  effects: Iterable<Effect.Effect<any, any, any>>,\n  reconcile: Option.Option<(as: ReadonlyArray<any>) => any>,\n  options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n) => {\n  const eitherEffects: Array<Effect.Effect<Either.Either<unknown, unknown>, never, unknown>> = []\n  for (const effect of effects) {\n    eitherEffects.push(core.either(effect))\n  }\n\n  if (options?.discard) {\n    return forEach(eitherEffects, identity, {\n      concurrency: options?.concurrency,\n      batching: options?.batching,\n      discard: true,\n      concurrentFinalizers: options?.concurrentFinalizers\n    })\n  }\n\n  return core.map(\n    forEach(eitherEffects, identity, {\n      concurrency: options?.concurrency,\n      batching: options?.batching,\n      concurrentFinalizers: options?.concurrentFinalizers\n    }),\n    (eithers) =>\n      reconcile._tag === \"Some\" ?\n        reconcile.value(eithers) :\n        eithers\n  )\n}\n\n/* @internal */\nexport const all = <\n  const Arg extends Iterable<Effect.Effect<any, any, any>> | Record<string, Effect.Effect<any, any, any>>,\n  O extends NoExcessProperties<{\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }, O>\n>(\n  arg: Arg,\n  options?: O\n): Effect.All.Return<Arg, O> => {\n  const [effects, reconcile] = allResolveInput(arg)\n\n  if (options?.mode === \"validate\") {\n    return allValidate(effects, reconcile, options) as any\n  } else if (options?.mode === \"either\") {\n    return allEither(effects, reconcile, options) as any\n  }\n\n  return options?.discard !== true && reconcile._tag === \"Some\"\n    ? core.map(\n      forEach(effects, identity, options as any),\n      reconcile.value\n    ) as any\n    : forEach(effects, identity, options as any) as any\n}\n\n/* @internal */\nexport const allWith = <\n  O extends NoExcessProperties<{\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }, O>\n>(options?: O) =>\n<const Arg extends Iterable<Effect.Effect<any, any, any>> | Record<string, Effect.Effect<any, any, any>>>(\n  arg: Arg\n): Effect.All.Return<Arg, O> => all(arg, options)\n\n/* @internal */\nexport const allSuccesses = <Eff extends Effect.Effect<any, any, any>>(\n  elements: Iterable<Eff>,\n  options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n): Effect.Effect<Array<Effect.Effect.Success<Eff>>, never, Effect.Effect.Context<Eff>> =>\n  core.map(\n    all(RA.fromIterable(elements).map(core.exit), options),\n    RA.filterMap((exit) => core.exitIsSuccess(exit) ? Option.some(exit.effect_instruction_i0) : Option.none())\n  )\n\n/* @internal */\nexport const replicate = dual<\n  (n: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Array<Effect.Effect<A, E, R>>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, n: number) => Array<Effect.Effect<A, E, R>>\n>(2, (self, n) => Array.from({ length: n }, () => self))\n\n/* @internal */\nexport const replicateEffect: {\n  (\n    n: number,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Array<A>, E, R>\n  (\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    n: number,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect.Effect<void, E, R>\n} = dual(\n  (args) => core.isEffect(args[0]),\n  (self, n, options) => all(replicate(self, n), options)\n)\n\n/* @internal */\nexport const forEach: {\n  <B, E, R, S extends Iterable<any>>(\n    f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect.Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): (\n    self: S\n  ) => Effect.Effect<RA.ReadonlyArray.With<S, B>, E, R>\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect.Effect<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): (self: Iterable<A>) => Effect.Effect<void, E, R>\n  <A, B, E, R>(\n    self: RA.NonEmptyReadonlyArray<A>,\n    f: (a: A, i: number) => Effect.Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<RA.NonEmptyArray<B>, E, R>\n  <A, B, E, R>(\n    self: Iterable<A>,\n    f: (a: A, i: number) => Effect.Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<Array<B>, E, R>\n  <A, B, E, R>(\n    self: Iterable<A>,\n    f: (a: A, i: number) => Effect.Effect<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect.Effect<void, E, R>\n} = dual((args) => Predicate.isIterable(args[0]), <A, R, E, B>(\n  self: Iterable<A>,\n  f: (a: A, i: number) => Effect.Effect<B, E, R>,\n  options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n) =>\n  core.withFiberRuntime<A | void, E, R>((r) => {\n    const isRequestBatchingEnabled = options?.batching === true ||\n      (options?.batching === \"inherit\" && r.getFiberRef(core.currentRequestBatching))\n\n    if (options?.discard) {\n      return concurrency.match(\n        options.concurrency,\n        () =>\n          finalizersMaskInternal(ExecutionStrategy.sequential, options?.concurrentFinalizers)((restore) =>\n            isRequestBatchingEnabled\n              ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1)\n              : core.forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))\n          ),\n        () =>\n          finalizersMaskInternal(ExecutionStrategy.parallel, options?.concurrentFinalizers)((restore) =>\n            forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)\n          ),\n        (n) =>\n          finalizersMaskInternal(ExecutionStrategy.parallelN(n), options?.concurrentFinalizers)((restore) =>\n            forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)\n          )\n      )\n    }\n\n    return concurrency.match(\n      options?.concurrency,\n      () =>\n        finalizersMaskInternal(ExecutionStrategy.sequential, options?.concurrentFinalizers)((restore) =>\n          isRequestBatchingEnabled\n            ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true)\n            : core.forEachSequential(self, (a, i) => restore(f(a, i)))\n        ),\n      () =>\n        finalizersMaskInternal(ExecutionStrategy.parallel, options?.concurrentFinalizers)((restore) =>\n          forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)\n        ),\n      (n) =>\n        finalizersMaskInternal(ExecutionStrategy.parallelN(n), options?.concurrentFinalizers)((restore) =>\n          forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)\n        )\n    )\n  }))\n\n/* @internal */\nexport const forEachParUnbounded = <A, B, E, R>(\n  self: Iterable<A>,\n  f: (a: A, i: number) => Effect.Effect<B, E, R>,\n  batching: boolean\n): Effect.Effect<Array<B>, E, R> =>\n  core.suspend(() => {\n    const as = RA.fromIterable(self)\n    const array = new Array<B>(as.length)\n    const fn = (a: A, i: number) => core.flatMap(f(a, i), (b) => core.sync(() => array[i] = b))\n    return core.zipRight(forEachConcurrentDiscard(as, fn, batching, false), core.succeed(array))\n  })\n\n/** @internal */\nexport const forEachConcurrentDiscard = <A, X, E, R>(\n  self: Iterable<A>,\n  f: (a: A, i: number) => Effect.Effect<X, E, R>,\n  batching: boolean,\n  processAll: boolean,\n  n?: number\n): Effect.Effect<void, E, R> =>\n  core.uninterruptibleMask((restore) =>\n    core.transplant((graft) =>\n      core.withFiberRuntime<void, E, R>((parent) => {\n        let todos = Array.from(self).reverse()\n        let target = todos.length\n        if (target === 0) {\n          return core.void\n        }\n        let counter = 0\n        let interrupted = false\n        const fibersCount = n ? Math.min(todos.length, n) : todos.length\n        const fibers = new Set<FiberRuntime<Exit.Exit<X, E> | Effect.Blocked<X, E>>>()\n        const results = new Array()\n        const interruptAll = () =>\n          fibers.forEach((fiber) => {\n            fiber.currentScheduler.scheduleTask(() => {\n              fiber.unsafeInterruptAsFork(parent.id())\n            }, 0)\n          })\n        const startOrder = new Array<FiberRuntime<Exit.Exit<X, E> | Effect.Blocked<X, E>>>()\n        const joinOrder = new Array<FiberRuntime<Exit.Exit<X, E> | Effect.Blocked<X, E>>>()\n        const residual = new Array<core.Blocked>()\n        const collectExits = () => {\n          const exits: Array<Exit.Exit<any, E>> = results\n            .filter(({ exit }) => exit._tag === \"Failure\")\n            .sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1)\n            .map(({ exit }) => exit)\n          if (exits.length === 0) {\n            exits.push(core.exitVoid)\n          }\n          return exits\n        }\n        const runFiber = <A, E, R>(eff: Effect.Effect<A, E, R>, interruptImmediately = false) => {\n          const runnable = core.uninterruptible(graft(eff))\n          const fiber = unsafeForkUnstarted(\n            runnable,\n            parent,\n            parent.currentRuntimeFlags,\n            fiberScope.globalScope\n          )\n          parent.currentScheduler.scheduleTask(() => {\n            if (interruptImmediately) {\n              fiber.unsafeInterruptAsFork(parent.id())\n            }\n            fiber.resume(runnable)\n          }, 0)\n          return fiber\n        }\n        const onInterruptSignal = () => {\n          if (!processAll) {\n            target -= todos.length\n            todos = []\n          }\n          interrupted = true\n          interruptAll()\n        }\n        const stepOrExit = batching ? core.step : core.exit\n        const processingFiber = runFiber(\n          core.async<any, any, any>((resume) => {\n            const pushResult = <X, E>(res: Exit.Exit<X, E> | Effect.Blocked<X, E>, index: number) => {\n              if (res._op === \"Blocked\") {\n                residual.push(res as core.Blocked)\n              } else {\n                results.push({ index, exit: res })\n                if (res._op === \"Failure\" && !interrupted) {\n                  onInterruptSignal()\n                }\n              }\n            }\n            const next = () => {\n              if (todos.length > 0) {\n                const a = todos.pop()!\n                let index = counter++\n                const returnNextElement = () => {\n                  const a = todos.pop()!\n                  index = counter++\n                  return core.flatMap(core.yieldNow(), () =>\n                    core.flatMap(\n                      stepOrExit(restore(f(a, index))),\n                      onRes\n                    ))\n                }\n                const onRes = (\n                  res: Exit.Exit<X, E> | Effect.Blocked<X, E>\n                ): Effect.Effect<Exit.Exit<X, E> | Effect.Blocked<X, E>, never, R> => {\n                  if (todos.length > 0) {\n                    pushResult(res, index)\n                    if (todos.length > 0) {\n                      return returnNextElement()\n                    }\n                  }\n                  return core.succeed(res)\n                }\n                const todo = core.flatMap(\n                  stepOrExit(restore(f(a, index))),\n                  onRes\n                )\n                const fiber = runFiber(todo)\n                startOrder.push(fiber)\n                fibers.add(fiber)\n                if (interrupted) {\n                  fiber.currentScheduler.scheduleTask(() => {\n                    fiber.unsafeInterruptAsFork(parent.id())\n                  }, 0)\n                }\n                fiber.addObserver((wrapped) => {\n                  let exit: Exit.Exit<any, any> | core.Blocked\n                  if (wrapped._op === \"Failure\") {\n                    exit = wrapped\n                  } else {\n                    exit = wrapped.effect_instruction_i0 as any\n                  }\n                  joinOrder.push(fiber)\n                  fibers.delete(fiber)\n                  pushResult(exit, index)\n                  if (results.length === target) {\n                    resume(core.succeed(Option.getOrElse(\n                      core.exitCollectAll(collectExits(), { parallel: true }),\n                      () => core.exitVoid\n                    )))\n                  } else if (residual.length + results.length === target) {\n                    const exits = collectExits()\n                    const requests = residual.map((blocked) => blocked.effect_instruction_i0).reduce(RequestBlock_.par)\n                    resume(core.succeed(core.blocked(\n                      requests,\n                      forEachConcurrentDiscard(\n                        [\n                          Option.getOrElse(\n                            core.exitCollectAll(exits, { parallel: true }),\n                            () => core.exitVoid\n                          ),\n                          ...residual.map((blocked) => blocked.effect_instruction_i1)\n                        ],\n                        (i) => i,\n                        batching,\n                        true,\n                        n\n                      )\n                    )))\n                  } else {\n                    next()\n                  }\n                })\n              }\n            }\n            for (let i = 0; i < fibersCount; i++) {\n              next()\n            }\n          })\n        )\n        return core.asVoid(\n          core.onExit(\n            core.flatten(restore(internalFiber.join(processingFiber))),\n            core.exitMatch({\n              onFailure: (cause) => {\n                onInterruptSignal()\n                const target = residual.length + 1\n                const concurrency = Math.min(typeof n === \"number\" ? n : residual.length, residual.length)\n                const toPop = Array.from(residual)\n                return core.async<any, any>((cb) => {\n                  const exits: Array<Exit.Exit<any, any>> = []\n                  let count = 0\n                  let index = 0\n                  const check = (index: number, hitNext: boolean) => (exit: Exit.Exit<any, any>) => {\n                    exits[index] = exit\n                    count++\n                    if (count === target) {\n                      cb(core.exitSucceed(core.exitFailCause(cause)))\n                    }\n                    if (toPop.length > 0 && hitNext) {\n                      next()\n                    }\n                  }\n                  const next = () => {\n                    runFiber(toPop.pop()!, true).addObserver(check(index, true))\n                    index++\n                  }\n                  processingFiber.addObserver(check(index, false))\n                  index++\n                  for (let i = 0; i < concurrency; i++) {\n                    next()\n                  }\n                }) as any\n              },\n              onSuccess: () => core.forEachSequential(joinOrder, (f) => f.inheritAll)\n            })\n          )\n        )\n      })\n    )\n  )\n\n/* @internal */\nexport const forEachParN = <A, B, E, R>(\n  self: Iterable<A>,\n  n: number,\n  f: (a: A, i: number) => Effect.Effect<B, E, R>,\n  batching: boolean\n): Effect.Effect<Array<B>, E, R> =>\n  core.suspend(() => {\n    const as = RA.fromIterable(self)\n    const array = new Array<B>(as.length)\n    const fn = (a: A, i: number) => core.map(f(a, i), (b) => array[i] = b)\n    return core.zipRight(forEachConcurrentDiscard(as, fn, batching, false, n), core.succeed(array))\n  })\n\n/* @internal */\nexport const fork = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R> =>\n  core.withFiberRuntime((state, status) => core.succeed(unsafeFork(self, state, status.runtimeFlags)))\n\n/* @internal */\nexport const forkDaemon = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R> =>\n  forkWithScopeOverride(self, fiberScope.globalScope)\n\n/* @internal */\nexport const forkWithErrorHandler = dual<\n  <E, X>(\n    handler: (e: E) => Effect.Effect<X>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R>,\n  <A, E, R, X>(\n    self: Effect.Effect<A, E, R>,\n    handler: (e: E) => Effect.Effect<X>\n  ) => Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R>\n>(2, (self, handler) =>\n  fork(core.onError(self, (cause) => {\n    const either = internalCause.failureOrCause(cause)\n    switch (either._tag) {\n      case \"Left\":\n        return handler(either.left)\n      case \"Right\":\n        return core.failCause(either.right)\n    }\n  })))\n\n/** @internal */\nexport const unsafeFork = <A, E, R, E2, B>(\n  effect: Effect.Effect<A, E, R>,\n  parentFiber: FiberRuntime<B, E2>,\n  parentRuntimeFlags: RuntimeFlags.RuntimeFlags,\n  overrideScope: fiberScope.FiberScope | null = null\n): FiberRuntime<A, E> => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope)\n  childFiber.resume(effect)\n  return childFiber\n}\n\n/** @internal */\nexport const unsafeForkUnstarted = <A, E, R, E2, B>(\n  effect: Effect.Effect<A, E, R>,\n  parentFiber: FiberRuntime<B, E2>,\n  parentRuntimeFlags: RuntimeFlags.RuntimeFlags,\n  overrideScope: fiberScope.FiberScope | null = null\n): FiberRuntime<A, E> => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope)\n  return childFiber\n}\n\n/** @internal */\nexport const unsafeMakeChildFiber = <A, E, R, E2, B>(\n  effect: Effect.Effect<A, E, R>,\n  parentFiber: FiberRuntime<B, E2>,\n  parentRuntimeFlags: RuntimeFlags.RuntimeFlags,\n  overrideScope: fiberScope.FiberScope | null = null\n): FiberRuntime<A, E> => {\n  const childId = FiberId.unsafeMake()\n  const parentFiberRefs = parentFiber.getFiberRefs()\n  const childFiberRefs = fiberRefs.forkAs(parentFiberRefs, childId)\n  const childFiber = new FiberRuntime<A, E>(childId, childFiberRefs, parentRuntimeFlags)\n  const childContext = fiberRefs.getOrDefault(\n    childFiberRefs,\n    core.currentContext as unknown as FiberRef.FiberRef<Context.Context<R>>\n  )\n  const supervisor = childFiber.currentSupervisor\n\n  supervisor.onStart(\n    childContext,\n    effect,\n    Option.some(parentFiber),\n    childFiber\n  )\n\n  childFiber.addObserver((exit) => supervisor.onEnd(exit, childFiber))\n\n  const parentScope = overrideScope !== null ? overrideScope : pipe(\n    parentFiber.getFiberRef(core.currentForkScopeOverride),\n    Option.getOrElse(() => parentFiber.scope())\n  )\n\n  parentScope.add(parentRuntimeFlags, childFiber)\n\n  return childFiber\n}\n\n/* @internal */\nconst forkWithScopeOverride = <A, E, R>(\n  self: Effect.Effect<A, E, R>,\n  scopeOverride: fiberScope.FiberScope\n): Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R> =>\n  core.withFiberRuntime((parentFiber, parentStatus) =>\n    core.succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride))\n  )\n\n/* @internal */\nexport const mergeAll = dual<\n  <Z, Eff extends Effect.Effect<any, any, any>>(\n    zero: Z,\n    f: (z: Z, a: Effect.Effect.Success<Eff>, i: number) => Z,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => (elements: Iterable<Eff>) => Effect.Effect<Z, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>,\n  <Eff extends Effect.Effect<any, any, any>, Z>(\n    elements: Iterable<Eff>,\n    zero: Z,\n    f: (z: Z, a: Effect.Effect.Success<Eff>, i: number) => Z,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<Z, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>\n>(\n  (args) => Predicate.isFunction(args[2]),\n  <A, E, R, Z>(elements: Iterable<Effect.Effect<A, E, R>>, zero: Z, f: (z: Z, a: A, i: number) => Z, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }) =>\n    concurrency.matchSimple(\n      options?.concurrency,\n      () =>\n        RA.fromIterable(elements).reduce(\n          (acc, a, i) => core.zipWith(acc, a, (acc, a) => f(acc, a, i)),\n          core.succeed(zero) as Effect.Effect<Z, E, R>\n        ),\n      () =>\n        core.flatMap(Ref.make(zero), (acc) =>\n          core.flatMap(\n            forEach(\n              elements,\n              (effect, i) => core.flatMap(effect, (a) => Ref.update(acc, (b) => f(b, a, i))),\n              options\n            ),\n            () => Ref.get(acc)\n          ))\n    )\n)\n\n/* @internal */\nexport const partition = dual<\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect.Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => (elements: Iterable<A>) => Effect.Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>,\n  <A, B, E, R>(\n    elements: Iterable<A>,\n    f: (a: A, i: number) => Effect.Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>\n>((args) => Predicate.isIterable(args[0]), (elements, f, options) =>\n  pipe(\n    forEach(elements, (a, i) => core.either(f(a, i)), options),\n    core.map((chunk) => core.partitionMap(chunk, identity))\n  ))\n\n/* @internal */\nexport const validateAll = dual<\n  {\n    <A, B, E, R>(\n      f: (a: A, i: number) => Effect.Effect<B, E, R>,\n      options?: {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly discard?: false | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n    ): (elements: Iterable<A>) => Effect.Effect<Array<B>, RA.NonEmptyArray<E>, R>\n    <A, B, E, R>(\n      f: (a: A, i: number) => Effect.Effect<B, E, R>,\n      options: {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly discard: true\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n    ): (elements: Iterable<A>) => Effect.Effect<void, RA.NonEmptyArray<E>, R>\n  },\n  {\n    <A, B, E, R>(\n      elements: Iterable<A>,\n      f: (a: A, i: number) => Effect.Effect<B, E, R>,\n      options?: {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly discard?: false | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n    ): Effect.Effect<Array<B>, RA.NonEmptyArray<E>, R>\n    <A, B, E, R>(\n      elements: Iterable<A>,\n      f: (a: A, i: number) => Effect.Effect<B, E, R>,\n      options: {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly discard: true\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n    ): Effect.Effect<void, RA.NonEmptyArray<E>, R>\n  }\n>(\n  (args) => Predicate.isIterable(args[0]),\n  <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }): Effect.Effect<any, RA.NonEmptyArray<E>, R> =>\n    core.flatMap(\n      partition(elements, f, {\n        concurrency: options?.concurrency,\n        batching: options?.batching,\n        concurrentFinalizers: options?.concurrentFinalizers\n      }),\n      ([es, bs]) =>\n        RA.isNonEmptyArray(es)\n          ? core.fail(es)\n          : options?.discard\n          ? core.void\n          : core.succeed(bs)\n    )\n)\n\n/* @internal */\nexport const raceAll: <Eff extends Effect.Effect<any, any, any>>(\n  all: Iterable<Eff>\n) => Effect.Effect<Effect.Effect.Success<Eff>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>> = <\n  A,\n  E,\n  R\n>(all: Iterable<Effect.Effect<A, E, R>>): Effect.Effect<A, E, R> =>\n  core.withFiberRuntime((state, status) =>\n    core.async<A, E, R>((resume) => {\n      const fibers = new Set<FiberRuntime<A, E>>()\n      let winner: FiberRuntime<A, E> | undefined\n      let failures: Cause.Cause<E> = internalCause.empty\n      const interruptAll = () => {\n        for (const fiber of fibers) {\n          fiber.unsafeInterruptAsFork(state.id())\n        }\n      }\n      let latch = false\n      let empty = true\n      for (const self of all) {\n        empty = false\n        const fiber = unsafeFork(\n          core.interruptible(self),\n          state,\n          status.runtimeFlags\n        )\n        fibers.add(fiber)\n        fiber.addObserver((exit) => {\n          fibers.delete(fiber)\n          if (!winner) {\n            if (exit._tag === \"Success\") {\n              latch = true\n              winner = fiber\n              failures = internalCause.empty\n              interruptAll()\n            } else {\n              failures = internalCause.parallel(exit.cause, failures)\n            }\n          }\n          if (latch && fibers.size === 0) {\n            resume(\n              winner ? core.zipRight(internalFiber.inheritAll(winner), winner.unsafePoll()!) : core.failCause(failures)\n            )\n          }\n        })\n        if (winner) break\n      }\n      if (empty) {\n        return resume(core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`)))\n      }\n      latch = true\n      return internalFiber.interruptAllAs(fibers, state.id())\n    })\n  )\n\n/* @internal */\nexport const reduceEffect = dual<\n  <Z, E, R, Eff extends Effect.Effect<any, any, any>>(\n    zero: Effect.Effect<Z, E, R>,\n    f: (z: NoInfer<Z>, a: Effect.Effect.Success<Eff>, i: number) => Z,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => (elements: Iterable<Eff>) => Effect.Effect<Z, E | Effect.Effect.Error<Eff>, R | Effect.Effect.Context<Eff>>,\n  <Eff extends Effect.Effect<any, any, any>, Z, E, R>(\n    elements: Iterable<Eff>,\n    zero: Effect.Effect<Z, E, R>,\n    f: (z: NoInfer<Z>, a: Effect.Effect.Success<Eff>, i: number) => Z,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<Z, E | Effect.Effect.Error<Eff>, R | Effect.Effect.Context<Eff>>\n>((args) => Predicate.isIterable(args[0]) && !core.isEffect(args[0]), <A, E, R, Z>(\n  elements: Iterable<Effect.Effect<A, E, R>>,\n  zero: Effect.Effect<Z, E, R>,\n  f: (z: NoInfer<Z>, a: NoInfer<A>, i: number) => Z,\n  options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n) =>\n  concurrency.matchSimple(\n    options?.concurrency,\n    () => RA.fromIterable(elements).reduce((acc, a, i) => core.zipWith(acc, a, (acc, a) => f(acc, a, i)), zero),\n    () =>\n      core.suspend(() =>\n        pipe(\n          mergeAll(\n            [zero, ...elements],\n            Option.none<Z>(),\n            (acc, elem, i) => {\n              switch (acc._tag) {\n                case \"None\": {\n                  return Option.some(elem as Z)\n                }\n                case \"Some\": {\n                  return Option.some(f(acc.value, elem as A, i))\n                }\n              }\n            },\n            options\n          ),\n          core.map((option) => {\n            switch (option._tag) {\n              case \"None\": {\n                throw new Error(\n                  \"BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues\"\n                )\n              }\n              case \"Some\": {\n                return option.value\n              }\n            }\n          })\n        )\n      )\n  ))\n\n/* @internal */\nexport const parallelFinalizers = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  core.contextWithEffect((context) =>\n    Option.match(Context.getOption(context, scopeTag), {\n      onNone: () => self,\n      onSome: (scope) => {\n        switch (scope.strategy._tag) {\n          case \"Parallel\":\n            return self\n          case \"Sequential\":\n          case \"ParallelN\":\n            return core.flatMap(\n              core.scopeFork(scope, ExecutionStrategy.parallel),\n              (inner) => scopeExtend(self, inner)\n            )\n        }\n      }\n    })\n  )\n\n/* @internal */\nexport const parallelNFinalizers =\n  (parallelism: number) => <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n    core.contextWithEffect((context) =>\n      Option.match(Context.getOption(context, scopeTag), {\n        onNone: () => self,\n        onSome: (scope) => {\n          if (scope.strategy._tag === \"ParallelN\" && scope.strategy.parallelism === parallelism) {\n            return self\n          }\n          return core.flatMap(\n            core.scopeFork(scope, ExecutionStrategy.parallelN(parallelism)),\n            (inner) => scopeExtend(self, inner)\n          )\n        }\n      })\n    )\n\n/* @internal */\nexport const finalizersMask = (strategy: ExecutionStrategy.ExecutionStrategy) =>\n<A, E, R>(\n  self: (\n    restore: <A1, E1, R1>(self: Effect.Effect<A1, E1, R1>) => Effect.Effect<A1, E1, R1>\n  ) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => finalizersMaskInternal(strategy, true)(self)\n\n/* @internal */\nexport const finalizersMaskInternal =\n  (strategy: ExecutionStrategy.ExecutionStrategy, concurrentFinalizers?: boolean | undefined) =>\n  <A, E, R>(\n    self: (\n      restore: <A1, E1, R1>(self: Effect.Effect<A1, E1, R1>) => Effect.Effect<A1, E1, R1>\n    ) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R> =>\n    core.contextWithEffect((context) =>\n      Option.match(Context.getOption(context, scopeTag), {\n        onNone: () => self(identity),\n        onSome: (scope) => {\n          if (concurrentFinalizers === true) {\n            const patch = strategy._tag === \"Parallel\"\n              ? parallelFinalizers\n              : strategy._tag === \"Sequential\"\n              ? sequentialFinalizers\n              : parallelNFinalizers(strategy.parallelism)\n            switch (scope.strategy._tag) {\n              case \"Parallel\":\n                return patch(self(parallelFinalizers))\n              case \"Sequential\":\n                return patch(self(sequentialFinalizers))\n              case \"ParallelN\":\n                return patch(self(parallelNFinalizers(scope.strategy.parallelism)))\n            }\n          } else {\n            return self(identity)\n          }\n        }\n      })\n    )\n\n/* @internal */\nexport const scopeWith = <A, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R | Scope.Scope> => core.flatMap(scopeTag, f)\n\n/** @internal */\nexport const scopedWith = <A, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> => core.flatMap(scopeMake(), (scope) => core.onExit(f(scope), (exit) => scope.close(exit)))\n\n/* @internal */\nexport const scopedEffect = <A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, Exclude<R, Scope.Scope>> =>\n  core.flatMap(scopeMake(), (scope) => scopeUse(effect, scope))\n\n/* @internal */\nexport const sequentialFinalizers = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  core.contextWithEffect((context) =>\n    Option.match(Context.getOption(context, scopeTag), {\n      onNone: () => self,\n      onSome: (scope) => {\n        switch (scope.strategy._tag) {\n          case \"Sequential\":\n            return self\n          case \"Parallel\":\n          case \"ParallelN\":\n            return core.flatMap(\n              core.scopeFork(scope, ExecutionStrategy.sequential),\n              (inner) => scopeExtend(self, inner)\n            )\n        }\n      }\n    })\n  )\n\n/* @internal */\nexport const tagMetricsScoped = (key: string, value: string): Effect.Effect<void, never, Scope.Scope> =>\n  labelMetricsScoped([metricLabel.make(key, value)])\n\n/* @internal */\nexport const labelMetricsScoped = (\n  labels: Iterable<MetricLabel.MetricLabel>\n): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRefLocallyScopedWith(core.currentMetricLabels, (old) => RA.union(old, labels))\n\n/* @internal */\nexport const using = dual<\n  <A, A2, E2, R2>(\n    use: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, Exclude<R, Scope.Scope> | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    use: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2, E | E2, Exclude<R, Scope.Scope> | R2>\n>(2, (self, use) => scopedWith((scope) => core.flatMap(scopeExtend(self, scope), use)))\n\n/** @internal */\nexport const validate = dual<\n  <B, E1, R1>(\n    that: Effect.Effect<B, E1, R1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[A, B], E | E1, R | R1>,\n  <A, E, R, B, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<B, E1, R1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<[A, B], E | E1, R | R1>\n>(\n  (args) => core.isEffect(args[1]),\n  (self, that, options) => validateWith(self, that, (a, b) => [a, b], options)\n)\n\n/** @internal */\nexport const validateWith = dual<\n  <B, E1, R1, A, C>(\n    that: Effect.Effect<B, E1, R1>,\n    f: (a: A, b: B) => C,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<C, E | E1, R | R1>,\n  <A, E, R, B, E1, R1, C>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<B, E1, R1>,\n    f: (a: A, b: B) => C,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<C, E | E1, R | R1>\n>((args) => core.isEffect(args[1]), (self, that, f, options) =>\n  core.flatten(zipWithOptions(\n    core.exit(self),\n    core.exit(that),\n    (ea, eb) =>\n      core.exitZipWith(ea, eb, {\n        onSuccess: f,\n        onFailure: (ca, cb) => options?.concurrent ? internalCause.parallel(ca, cb) : internalCause.sequential(ca, cb)\n      }),\n    options\n  )))\n\n/* @internal */\nexport const validateAllPar = dual<\n  <A, B, E, R>(\n    f: (a: A) => Effect.Effect<B, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Array<B>, Array<E>, R>,\n  <A, B, E, R>(\n    elements: Iterable<A>,\n    f: (a: A) => Effect.Effect<B, E, R>\n  ) => Effect.Effect<Array<B>, Array<E>, R>\n>(2, (elements, f) =>\n  core.flatMap(\n    partition(elements, f),\n    ([es, bs]) =>\n      es.length === 0\n        ? core.succeed(bs)\n        : core.fail(es)\n  ))\n\n/* @internal */\nexport const validateAllParDiscard = dual<\n  <A, B, E, R>(\n    f: (a: A) => Effect.Effect<B, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<void, Array<E>, R>,\n  <A, B, E, R>(elements: Iterable<A>, f: (a: A) => Effect.Effect<B, E, R>) => Effect.Effect<void, Array<E>, R>\n>(2, (elements, f) =>\n  core.flatMap(\n    partition(elements, f),\n    ([es, _]) =>\n      es.length === 0\n        ? core.void\n        : core.fail(es)\n  ))\n\n/* @internal */\nexport const validateFirst = dual<\n  <A, B, E, R>(f: (a: A, i: number) => Effect.Effect<B, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }) => (elements: Iterable<A>) => Effect.Effect<B, Array<E>, R>,\n  <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect.Effect<B, E, R>, options?: {\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }) => Effect.Effect<B, Array<E>, R>\n>(\n  (args) => Predicate.isIterable(args[0]),\n  (elements, f, options) => core.flip(forEach(elements, (a, i) => core.flip(f(a, i)), options))\n)\n\n/* @internal */\nexport const withClockScoped = <C extends Clock.Clock>(c: C) =>\n  fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(clock.clockTag, c))\n\n/* @internal */\nexport const withRandomScoped = <A extends Random.Random>(value: A) =>\n  fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(randomTag, value))\n\n/* @internal */\nexport const withConfigProviderScoped = (provider: ConfigProvider) =>\n  fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(configProviderTag, provider))\n\n/* @internal */\nexport const withEarlyRelease = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[Effect.Effect<void>, A], E, R | Scope.Scope> =>\n  scopeWith((parent) =>\n    core.flatMap(core.scopeFork(parent, executionStrategy.sequential), (child) =>\n      pipe(\n        self,\n        scopeExtend(child),\n        core.map((value) => [\n          core.fiberIdWith((fiberId) => core.scopeClose(child, core.exitInterrupt(fiberId))),\n          value\n        ])\n      ))\n  )\n\n/** @internal */\nexport const zipOptions = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<[A, A2], E | E2, R | R2>\n>((args) => core.isEffect(args[1]), (\n  self,\n  that,\n  options\n) => zipWithOptions(self, that, (a, b) => [a, b], options))\n\n/** @internal */\nexport const zipLeftOptions = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(\n  (args) => core.isEffect(args[1]),\n  (self, that, options) => {\n    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {\n      return core.zipLeft(self, that)\n    }\n    return zipWithOptions(self, that, (a, _) => a, options)\n  }\n)\n\n/** @internal */\nexport const zipRightOptions: {\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2 | E, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect.Effect<A2, E2 | E, R2 | R>\n} = dual((args) => core.isEffect(args[1]), <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  options?: {\n    readonly concurrent?: boolean | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n): Effect.Effect<A2, E2 | E, R2 | R> => {\n  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {\n    return core.zipRight(self, that)\n  }\n  return zipWithOptions(self, that, (_, b) => b, options)\n})\n\n/** @internal */\nexport const zipWithOptions: {\n  <A2, E2, R2, A, B>(\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E2 | E, R2 | R>\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect.Effect<B, E2 | E, R2 | R>\n} = dual((args) => core.isEffect(args[1]), <A, E, R, A2, E2, R2, B>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>,\n  f: (a: A, b: A2) => B,\n  options?: {\n    readonly concurrent?: boolean | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }\n): Effect.Effect<B, E2 | E, R2 | R> =>\n  core.map(\n    all([self, that], {\n      concurrency: options?.concurrent ? 2 : 1,\n      batching: options?.batching,\n      concurrentFinalizers: options?.concurrentFinalizers\n    }),\n    ([a, a2]) => f(a, a2)\n  ))\n\n/* @internal */\nexport const withRuntimeFlagsScoped = (\n  update: RuntimeFlagsPatch.RuntimeFlagsPatch\n): Effect.Effect<void, never, Scope.Scope> => {\n  if (update === RuntimeFlagsPatch.empty) {\n    return core.void\n  }\n  return pipe(\n    core.runtimeFlags,\n    core.flatMap((runtimeFlags) => {\n      const updatedRuntimeFlags = runtimeFlags_.patch(runtimeFlags, update)\n      const revertRuntimeFlags = runtimeFlags_.diff(updatedRuntimeFlags, runtimeFlags)\n      return pipe(\n        core.updateRuntimeFlags(update),\n        core.zipRight(addFinalizer(() => core.updateRuntimeFlags(revertRuntimeFlags))),\n        core.asVoid\n      )\n    }),\n    core.uninterruptible\n  )\n}\n\n// circular with Scope\n\n/** @internal */\nexport const scopeTag = Context.GenericTag<Scope.Scope>(\"effect/Scope\")\n\n/* @internal */\nexport const scope: Effect.Effect<Scope.Scope, never, Scope.Scope> = scopeTag\n\n/** @internal */\nexport interface ScopeImpl extends Scope.CloseableScope {\n  state: {\n    readonly _tag: \"Open\"\n    readonly finalizers: Map<{}, Scope.Scope.Finalizer>\n  } | {\n    readonly _tag: \"Closed\"\n    readonly exit: Exit.Exit<unknown, unknown>\n  }\n}\n\nconst scopeUnsafeAddFinalizer = (scope: ScopeImpl, fin: Scope.Scope.Finalizer): void => {\n  if (scope.state._tag === \"Open\") {\n    scope.state.finalizers.set({}, fin)\n  }\n}\n\nconst ScopeImplProto: Omit<ScopeImpl, \"strategy\" | \"state\"> = {\n  [core.ScopeTypeId]: core.ScopeTypeId,\n  [core.CloseableScopeTypeId]: core.CloseableScopeTypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  fork(this: ScopeImpl, strategy) {\n    return core.sync(() => {\n      const newScope = scopeUnsafeMake(strategy)\n      if (this.state._tag === \"Closed\") {\n        newScope.state = this.state\n        return newScope\n      }\n      const key = {}\n      const fin = (exit: Exit.Exit<unknown, unknown>) => newScope.close(exit)\n      this.state.finalizers.set(key, fin)\n      scopeUnsafeAddFinalizer(newScope, (_) =>\n        core.sync(() => {\n          if (this.state._tag === \"Open\") {\n            this.state.finalizers.delete(key)\n          }\n        }))\n      return newScope\n    })\n  },\n  close(this: ScopeImpl, exit) {\n    return core.suspend(() => {\n      if (this.state._tag === \"Closed\") {\n        return core.void\n      }\n      const finalizers = Array.from(this.state.finalizers.values()).reverse()\n      this.state = { _tag: \"Closed\", exit }\n      if (finalizers.length === 0) {\n        return core.void\n      }\n      return executionStrategy.isSequential(this.strategy) ?\n        pipe(\n          core.forEachSequential(finalizers, (fin) => core.exit(fin(exit))),\n          core.flatMap((results) =>\n            pipe(\n              core.exitCollectAll(results),\n              Option.map(core.exitAsVoid),\n              Option.getOrElse(() => core.exitVoid)\n            )\n          )\n        ) :\n        executionStrategy.isParallel(this.strategy) ?\n        pipe(\n          forEachParUnbounded(finalizers, (fin) => core.exit(fin(exit)), false),\n          core.flatMap((results) =>\n            pipe(\n              core.exitCollectAll(results, { parallel: true }),\n              Option.map(core.exitAsVoid),\n              Option.getOrElse(() => core.exitVoid)\n            )\n          )\n        ) :\n        pipe(\n          forEachParN(finalizers, this.strategy.parallelism, (fin) => core.exit(fin(exit)), false),\n          core.flatMap((results) =>\n            pipe(\n              core.exitCollectAll(results, { parallel: true }),\n              Option.map(core.exitAsVoid),\n              Option.getOrElse(() => core.exitVoid)\n            )\n          )\n        )\n    })\n  },\n  addFinalizer(this: ScopeImpl, fin) {\n    return core.suspend(() => {\n      if (this.state._tag === \"Closed\") {\n        return fin(this.state.exit)\n      }\n      this.state.finalizers.set({}, fin)\n      return core.void\n    })\n  }\n}\n\nconst scopeUnsafeMake = (\n  strategy: ExecutionStrategy.ExecutionStrategy = executionStrategy.sequential\n): ScopeImpl => {\n  const scope = Object.create(ScopeImplProto)\n  scope.strategy = strategy\n  scope.state = { _tag: \"Open\", finalizers: new Map() }\n  return scope\n}\n\n/* @internal */\nexport const scopeMake = (\n  strategy: ExecutionStrategy.ExecutionStrategy = executionStrategy.sequential\n): Effect.Effect<Scope.Scope.Closeable> => core.sync(() => scopeUnsafeMake(strategy))\n\n/* @internal */\nexport const scopeExtend = dual<\n  (scope: Scope.Scope) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope.Scope>>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope.Scope) => Effect.Effect<A, E, Exclude<R, Scope.Scope>>\n>(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope.Scope) =>\n    core.mapInputContext<A, E, R, Exclude<R, Scope.Scope>>(\n      effect,\n      // @ts-expect-error\n      Context.merge(Context.make(scopeTag, scope))\n    )\n)\n\n/* @internal */\nexport const scopeUse = dual<\n  (\n    scope: Scope.Scope.Closeable\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope.Scope>>,\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    scope: Scope.Scope.Closeable\n  ) => Effect.Effect<A, E, Exclude<R, Scope.Scope>>\n>(2, (effect, scope) =>\n  pipe(\n    effect,\n    scopeExtend(scope),\n    core.onExit((exit) => scope.close(exit))\n  ))\n\n// circular with Supervisor\n\n/** @internal */\nexport const fiberRefUnsafeMakeSupervisor = (\n  initial: Supervisor.Supervisor<any>\n): FiberRef.FiberRef<Supervisor.Supervisor<any>> =>\n  core.fiberRefUnsafeMakePatch(initial, {\n    differ: SupervisorPatch.differ,\n    fork: SupervisorPatch.empty\n  })\n\n// circular with FiberRef\n\n/* @internal */\nexport const fiberRefLocallyScoped = dual<\n  <A>(value: A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void, never, Scope.Scope>,\n  <A>(self: FiberRef.FiberRef<A>, value: A) => Effect.Effect<void, never, Scope.Scope>\n>(2, (self, value) =>\n  core.asVoid(\n    acquireRelease(\n      core.flatMap(\n        core.fiberRefGet(self),\n        (oldValue) => core.as(core.fiberRefSet(self, value), oldValue)\n      ),\n      (oldValue) => core.fiberRefSet(self, oldValue)\n    )\n  ))\n\n/* @internal */\nexport const fiberRefLocallyScopedWith = dual<\n  <A>(f: (a: A) => A) => (self: FiberRef.FiberRef<A>) => Effect.Effect<void, never, Scope.Scope>,\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A) => Effect.Effect<void, never, Scope.Scope>\n>(2, (self, f) => core.fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))))\n\n/* @internal */\nexport const fiberRefMake = <A>(\n  initial: A,\n  options?: {\n    readonly fork?: ((a: A) => A) | undefined\n    readonly join?: ((left: A, right: A) => A) | undefined\n  }\n): Effect.Effect<FiberRef.FiberRef<A>, never, Scope.Scope> =>\n  fiberRefMakeWith(() => core.fiberRefUnsafeMake(initial, options))\n\n/* @internal */\nexport const fiberRefMakeWith = <Value>(\n  ref: LazyArg<FiberRef.FiberRef<Value>>\n): Effect.Effect<FiberRef.FiberRef<Value>, never, Scope.Scope> =>\n  acquireRelease(\n    core.tap(core.sync(ref), (ref) => core.fiberRefUpdate(ref, identity)),\n    (fiberRef) => core.fiberRefDelete(fiberRef)\n  )\n\n/* @internal */\nexport const fiberRefMakeContext = <A>(\n  initial: Context.Context<A>\n): Effect.Effect<FiberRef.FiberRef<Context.Context<A>>, never, Scope.Scope> =>\n  fiberRefMakeWith(() => core.fiberRefUnsafeMakeContext(initial))\n\n/* @internal */\nexport const fiberRefMakeRuntimeFlags = (\n  initial: RuntimeFlags.RuntimeFlags\n): Effect.Effect<FiberRef.FiberRef<RuntimeFlags.RuntimeFlags>, never, Scope.Scope> =>\n  fiberRefMakeWith(() => core.fiberRefUnsafeMakeRuntimeFlags(initial))\n\n/** @internal */\nexport const currentRuntimeFlags: FiberRef.FiberRef<RuntimeFlags.RuntimeFlags> = core.fiberRefUnsafeMakeRuntimeFlags(\n  runtimeFlags_.none\n)\n\n/** @internal */\nexport const currentSupervisor: FiberRef.FiberRef<Supervisor.Supervisor<any>> = fiberRefUnsafeMakeSupervisor(\n  supervisor.none\n)\n\n// circular with Fiber\n\n/* @internal */\nexport const fiberAwaitAll = <const T extends Iterable<Fiber.Fiber<any, any>>>(\n  fibers: T\n): Effect.Effect<\n  [T] extends [ReadonlyArray<infer U>]\n    ? number extends T[\"length\"] ? Array<U extends Fiber.Fiber<infer A, infer E> ? Exit.Exit<A, E> : never>\n    : { -readonly [K in keyof T]: T[K] extends Fiber.Fiber<infer A, infer E> ? Exit.Exit<A, E> : never }\n    : Array<T extends Iterable<infer U> ? U extends Fiber.Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>\n> => forEach(fibers, internalFiber._await) as any\n\n/** @internal */\nexport const fiberAll = <A, E>(fibers: Iterable<Fiber.Fiber<A, E>>): Fiber.Fiber<Array<A>, E> => {\n  const _fiberAll = {\n    ...Effectable.CommitPrototype,\n    commit() {\n      return internalFiber.join(this)\n    },\n    [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n    id: () =>\n      RA.fromIterable(fibers).reduce((id, fiber) => FiberId.combine(id, fiber.id()), FiberId.none as FiberId.FiberId),\n    await: core.exit(forEachParUnbounded(fibers, (fiber) => core.flatten(fiber.await), false)),\n    children: core.map(forEachParUnbounded(fibers, (fiber) => fiber.children, false), RA.flatten),\n    inheritAll: core.forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),\n    poll: core.map(\n      core.forEachSequential(fibers, (fiber) => fiber.poll),\n      RA.reduceRight(\n        Option.some<Exit.Exit<Array<A>, E>>(core.exitSucceed(new Array())),\n        (optionB, optionA) => {\n          switch (optionA._tag) {\n            case \"None\": {\n              return Option.none()\n            }\n            case \"Some\": {\n              switch (optionB._tag) {\n                case \"None\": {\n                  return Option.none()\n                }\n                case \"Some\": {\n                  return Option.some(\n                    core.exitZipWith(optionA.value, optionB.value, {\n                      onSuccess: (a, chunk) => [a, ...chunk],\n                      onFailure: internalCause.parallel\n                    })\n                  )\n                }\n              }\n            }\n          }\n        }\n      )\n    ),\n    interruptAsFork: (fiberId: FiberId.FiberId) =>\n      core.forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId))\n  }\n  return _fiberAll\n}\n\n/* @internal */\nexport const fiberInterruptFork = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<void> =>\n  core.asVoid(forkDaemon(core.interruptFiber(self)))\n\n/* @internal */\nexport const fiberJoinAll = <A, E>(fibers: Iterable<Fiber.Fiber<A, E>>): Effect.Effect<Array<A>, E> =>\n  internalFiber.join(fiberAll(fibers))\n\n/* @internal */\nexport const fiberScoped = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Fiber.Fiber<A, E>, never, Scope.Scope> =>\n  acquireRelease(core.succeed(self), core.interruptFiber)\n\n//\n// circular race\n//\n\n/** @internal */\nexport const raceWith = dual<\n  <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(\n    other: Effect.Effect<A1, E1, R1>,\n    options: {\n      readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect.Effect<A2, E2, R2>\n      readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect.Effect<A3, E3, R3>\n    }\n  ) => <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>,\n  <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    other: Effect.Effect<A1, E1, R1>,\n    options: {\n      readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect.Effect<A2, E2, R2>\n      readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect.Effect<A3, E3, R3>\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>\n>(3, (self, other, options) =>\n  raceFibersWith(self, other, {\n    onSelfWin: (winner, loser) =>\n      core.flatMap(winner.await, (exit) => {\n        switch (exit._tag) {\n          case OpCodes.OP_SUCCESS: {\n            return core.flatMap(\n              winner.inheritAll,\n              () => options.onSelfDone(exit, loser)\n            )\n          }\n          case OpCodes.OP_FAILURE: {\n            return options.onSelfDone(exit, loser)\n          }\n        }\n      }),\n    onOtherWin: (winner, loser) =>\n      core.flatMap(winner.await, (exit) => {\n        switch (exit._tag) {\n          case OpCodes.OP_SUCCESS: {\n            return core.flatMap(\n              winner.inheritAll,\n              () => options.onOtherDone(exit, loser)\n            )\n          }\n          case OpCodes.OP_FAILURE: {\n            return options.onOtherDone(exit, loser)\n          }\n        }\n      })\n  }))\n\n/** @internal */\nexport const disconnect = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  core.uninterruptibleMask((restore) =>\n    core.fiberIdWith((fiberId) =>\n      core.flatMap(forkDaemon(restore(self)), (fiber) =>\n        pipe(\n          restore(internalFiber.join(fiber)),\n          core.onInterrupt(() => pipe(fiber, internalFiber.interruptAsFork(fiberId)))\n        ))\n    )\n  )\n\n/** @internal */\nexport const race = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(\n  2,\n  (self, that) =>\n    core.fiberIdWith((parentFiberId) =>\n      raceWith(self, that, {\n        onSelfDone: (exit, right) =>\n          core.exitMatchEffect(exit, {\n            onFailure: (cause) =>\n              pipe(\n                internalFiber.join(right),\n                internalEffect.mapErrorCause((cause2) => internalCause.parallel(cause, cause2))\n              ),\n            onSuccess: (value) =>\n              pipe(\n                right,\n                core.interruptAsFiber(parentFiberId),\n                core.as(value)\n              )\n          }),\n        onOtherDone: (exit, left) =>\n          core.exitMatchEffect(exit, {\n            onFailure: (cause) =>\n              pipe(\n                internalFiber.join(left),\n                internalEffect.mapErrorCause((cause2) => internalCause.parallel(cause2, cause))\n              ),\n            onSuccess: (value) =>\n              pipe(\n                left,\n                core.interruptAsFiber(parentFiberId),\n                core.as(value)\n              )\n          })\n      })\n    )\n)\n\n/** @internal */\nexport const raceFibersWith = dual<\n  <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(\n    other: Effect.Effect<A1, E1, R1>,\n    options: {\n      readonly onSelfWin: (\n        winner: Fiber.RuntimeFiber<A, E>,\n        loser: Fiber.RuntimeFiber<A1, E1>\n      ) => Effect.Effect<A2, E2, R2>\n      readonly onOtherWin: (\n        winner: Fiber.RuntimeFiber<A1, E1>,\n        loser: Fiber.RuntimeFiber<A, E>\n      ) => Effect.Effect<A3, E3, R3>\n      readonly selfScope?: fiberScope.FiberScope | undefined\n      readonly otherScope?: fiberScope.FiberScope | undefined\n    }\n  ) => <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>,\n  <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    other: Effect.Effect<A1, E1, R1>,\n    options: {\n      readonly onSelfWin: (\n        winner: Fiber.RuntimeFiber<A, E>,\n        loser: Fiber.RuntimeFiber<A1, E1>\n      ) => Effect.Effect<A2, E2, R2>\n      readonly onOtherWin: (\n        winner: Fiber.RuntimeFiber<A1, E1>,\n        loser: Fiber.RuntimeFiber<A, E>\n      ) => Effect.Effect<A3, E3, R3>\n      readonly selfScope?: fiberScope.FiberScope | undefined\n      readonly otherScope?: fiberScope.FiberScope | undefined\n    }\n  ) => Effect.Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>\n>(3, <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(\n  self: Effect.Effect<A, E, R>,\n  other: Effect.Effect<A1, E1, R1>,\n  options: {\n    readonly onSelfWin: (\n      winner: Fiber.RuntimeFiber<A, E>,\n      loser: Fiber.RuntimeFiber<A1, E1>\n    ) => Effect.Effect<A2, E2, R2>\n    readonly onOtherWin: (\n      winner: Fiber.RuntimeFiber<A1, E1>,\n      loser: Fiber.RuntimeFiber<A, E>\n    ) => Effect.Effect<A3, E3, R3>\n    readonly selfScope?: fiberScope.FiberScope | undefined\n    readonly otherScope?: fiberScope.FiberScope | undefined\n  }\n) =>\n  core.withFiberRuntime((parentFiber, parentStatus) => {\n    const parentRuntimeFlags = parentStatus.runtimeFlags\n    const raceIndicator = MRef.make(true)\n    const leftFiber: FiberRuntime<A, E> = unsafeMakeChildFiber(\n      self,\n      parentFiber,\n      parentRuntimeFlags,\n      options.selfScope\n    )\n    const rightFiber: FiberRuntime<A1, E1> = unsafeMakeChildFiber(\n      other,\n      parentFiber,\n      parentRuntimeFlags,\n      options.otherScope\n    )\n    return core.async((cb) => {\n      leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb))\n      rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb))\n      leftFiber.startFork(self)\n      rightFiber.startFork(other)\n    }, FiberId.combine(leftFiber.id(), rightFiber.id()))\n  }))\n\nconst completeRace = <A2, A3, E2, E3, R, R1, R2, R3>(\n  winner: Fiber.RuntimeFiber<any, any>,\n  loser: Fiber.RuntimeFiber<any, any>,\n  cont: (winner: Fiber.RuntimeFiber<any, any>, loser: Fiber.RuntimeFiber<any, any>) => Effect.Effect<any, any, any>,\n  ab: MRef.MutableRef<boolean>,\n  cb: (_: Effect.Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>) => void\n): void => {\n  if (MRef.compareAndSet(true, false)(ab)) {\n    cb(cont(winner, loser))\n  }\n}\n\n/** @internal */\nexport const ensuring: {\n  <X, R1>(\n    finalizer: Effect.Effect<X, never, R1>\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R1 | R>\n  <A, E, R, X, R1>(self: Effect.Effect<A, E, R>, finalizer: Effect.Effect<X, never, R1>): Effect.Effect<A, E, R1 | R>\n} = dual(\n  2,\n  <A, E, R, X, R1>(self: Effect.Effect<A, E, R>, finalizer: Effect.Effect<X, never, R1>): Effect.Effect<A, E, R1 | R> =>\n    core.uninterruptibleMask((restore) =>\n      core.matchCauseEffect(restore(self), {\n        onFailure: (cause1) =>\n          core.matchCauseEffect(finalizer, {\n            onFailure: (cause2) => core.failCause(internalCause.sequential(cause1, cause2)),\n            onSuccess: () => core.failCause(cause1)\n          }),\n        onSuccess: (a) => core.as(finalizer, a)\n      })\n    )\n)\n\n/** @internal */\nexport const invokeWithInterrupt: <A, E, R>(\n  self: Effect.Effect<A, E, R>,\n  entries: ReadonlyArray<Entry<unknown>>,\n  onInterrupt?: () => void\n) => Effect.Effect<void, E, R> = <A, E, R>(\n  self: Effect.Effect<A, E, R>,\n  entries: ReadonlyArray<Entry<unknown>>,\n  onInterrupt?: () => void\n) =>\n  core.fiberIdWith((id) =>\n    core.flatMap(\n      core.flatMap(\n        forkDaemon(core.interruptible(self)),\n        (processing) =>\n          core.async<void, E>((cb) => {\n            const counts = entries.map((_) => _.listeners.count)\n            const checkDone = () => {\n              if (counts.every((count) => count === 0)) {\n                if (\n                  entries.every((_) => {\n                    if (_.result.state.current._tag === \"Pending\") {\n                      return true\n                    } else if (\n                      _.result.state.current._tag === \"Done\" &&\n                      core.exitIsExit(_.result.state.current.effect) &&\n                      _.result.state.current.effect._tag === \"Failure\" &&\n                      internalCause.isInterrupted(_.result.state.current.effect.cause)\n                    ) {\n                      return true\n                    } else {\n                      return false\n                    }\n                  })\n                ) {\n                  cleanup.forEach((f) => f())\n                  onInterrupt?.()\n                  cb(core.interruptFiber(processing))\n                }\n              }\n            }\n            processing.addObserver((exit) => {\n              cleanup.forEach((f) => f())\n              cb(exit)\n            })\n            const cleanup = entries.map((r, i) => {\n              const observer = (count: number) => {\n                counts[i] = count\n                checkDone()\n              }\n              r.listeners.addObserver(observer)\n              return () => r.listeners.removeObserver(observer)\n            })\n            checkDone()\n            return core.sync(() => {\n              cleanup.forEach((f) => f())\n            })\n          })\n      ),\n      () =>\n        core.suspend(() => {\n          const residual = entries.flatMap((entry) => {\n            if (!entry.state.completed) {\n              return [entry]\n            }\n            return []\n          })\n          return core.forEachSequentialDiscard(\n            residual,\n            (entry) => complete(entry.request as any, core.exitInterrupt(id))\n          )\n        })\n    )\n  )\n\n/** @internal */\nexport const interruptWhenPossible = dual<\n  (all: Iterable<Request<any, any>>) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<void, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    all: Iterable<Request<any, any>>\n  ) => Effect.Effect<void, E, R>\n>(2, (self, all) =>\n  core.fiberRefGetWith(\n    currentRequestMap,\n    (map) =>\n      core.suspend(() => {\n        const entries = RA.fromIterable(all).flatMap((_) => map.has(_) ? [map.get(_)!] : [])\n        return invokeWithInterrupt(self, entries)\n      })\n  ))\n\n// circular Tracer\n\n/** @internal */\nexport const makeSpanScoped = (\n  name: string,\n  options?: Tracer.SpanOptions | undefined\n): Effect.Effect<Tracer.Span, never, Scope.Scope> => {\n  options = tracer.addSpanStackTrace(options)\n  return core.uninterruptible(\n    core.withFiberRuntime((fiber) => {\n      const scope = Context.unsafeGet(fiber.getFiberRef(core.currentContext), scopeTag)\n      const span = internalEffect.unsafeMakeSpan(fiber, name, options)\n      const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n      const clock_ = Context.get(fiber.getFiberRef(defaultServices.currentServices), clock.clockTag)\n      return core.as(\n        core.scopeAddFinalizerExit(scope, (exit) => internalEffect.endSpan(span, exit, clock_, timingEnabled)),\n        span\n      )\n    })\n  )\n}\n\n/* @internal */\nexport const withTracerScoped = (value: Tracer.Tracer): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(tracer.tracerTag, value))\n\n/** @internal */\nexport const withSpanScoped: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Scope.Scope | Exclude<R, Tracer.ParentSpan>>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions\n  ): Effect.Effect<A, E, Scope.Scope | Exclude<R, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  if (dataFirst) {\n    const self = arguments[0]\n    return core.flatMap(\n      makeSpanScoped(name, tracer.addSpanStackTrace(options)),\n      (span) => internalEffect.provideService(self, tracer.spanTag, span)\n    )\n  }\n  return (self: Effect.Effect<any, any, any>) =>\n    core.flatMap(\n      makeSpanScoped(name, tracer.addSpanStackTrace(options)),\n      (span) => internalEffect.provideService(self, tracer.spanTag, span)\n    )\n} as any\n","/**\n * @since 2.0.0\n */\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\nimport * as internal from \"./internal/tracer.js\"\nimport type * as Option from \"./Option.js\"\n\n/**\n * @since 2.0.0\n */\nexport const TracerTypeId: unique symbol = internal.TracerTypeId\n\n/**\n * @since 2.0.0\n */\nexport type TracerTypeId = typeof TracerTypeId\n\n/**\n * @since 2.0.0\n */\nexport interface Tracer {\n  readonly [TracerTypeId]: TracerTypeId\n  span(\n    name: string,\n    parent: Option.Option<AnySpan>,\n    context: Context.Context<never>,\n    links: ReadonlyArray<SpanLink>,\n    startTime: bigint,\n    kind: SpanKind,\n    options?: SpanOptions\n  ): Span\n  context<X>(f: () => X, fiber: Fiber.RuntimeFiber<any, any>): X\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type SpanStatus = {\n  _tag: \"Started\"\n  startTime: bigint\n} | {\n  _tag: \"Ended\"\n  startTime: bigint\n  endTime: bigint\n  exit: Exit.Exit<unknown, unknown>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type AnySpan = Span | ExternalSpan\n\n/**\n * @since 2.0.0\n * @category tags\n */\nexport interface ParentSpan {\n  readonly _: unique symbol\n}\n\n/**\n * @since 2.0.0\n * @category tags\n */\nexport const ParentSpan: Context.Tag<ParentSpan, AnySpan> = internal.spanTag\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface ExternalSpan {\n  readonly _tag: \"ExternalSpan\"\n  readonly spanId: string\n  readonly traceId: string\n  readonly sampled: boolean\n  readonly context: Context.Context<never>\n}\n\n/**\n * @since 3.1.0\n * @category models\n */\nexport interface SpanOptions {\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<SpanLink> | undefined\n  readonly parent?: AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: SpanKind | undefined\n  readonly captureStackTrace?: boolean | LazyArg<string | undefined> | undefined\n}\n\n/**\n * @since 3.1.0\n * @category models\n */\nexport type SpanKind = \"internal\" | \"server\" | \"client\" | \"producer\" | \"consumer\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Span {\n  readonly _tag: \"Span\"\n  readonly name: string\n  readonly spanId: string\n  readonly traceId: string\n  readonly parent: Option.Option<AnySpan>\n  readonly context: Context.Context<never>\n  readonly status: SpanStatus\n  readonly attributes: ReadonlyMap<string, unknown>\n  readonly links: ReadonlyArray<SpanLink>\n  readonly sampled: boolean\n  readonly kind: SpanKind\n  end(endTime: bigint, exit: Exit.Exit<unknown, unknown>): void\n  attribute(key: string, value: unknown): void\n  event(name: string, startTime: bigint, attributes?: Record<string, unknown>): void\n  addLinks(links: ReadonlyArray<SpanLink>): void\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface SpanLink {\n  readonly _tag: \"SpanLink\"\n  readonly span: AnySpan\n  readonly attributes: Readonly<Record<string, unknown>>\n}\n\n/**\n * @since 2.0.0\n * @category tags\n */\nexport const Tracer: Context.Tag<Tracer, Tracer> = internal.tracerTag\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (options: Omit<Tracer, typeof TracerTypeId>) => Tracer = internal.make\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const externalSpan: (\n  options: {\n    readonly spanId: string\n    readonly traceId: string\n    readonly sampled?: boolean | undefined\n    readonly context?: Context.Context<never> | undefined\n  }\n) => ExternalSpan = internal.externalSpan\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const tracerWith: <A, E, R>(f: (tracer: Tracer) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  defaultServices.tracerWith\n\n/**\n * @since 3.12.0\n * @category annotations\n */\nexport interface DisablePropagation {\n  readonly _: unique symbol\n}\n\n/**\n * @since 3.12.0\n * @category annotations\n */\nexport const DisablePropagation: Context.Reference<DisablePropagation, boolean> = internal.DisablePropagation\n","import * as Arr from \"../Array.js\"\nimport * as Context from \"../Context.js\"\nimport * as FiberRefs from \"../FiberRefs.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constVoid, dual } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as Inspectable from \"../Inspectable.js\"\nimport * as List from \"../List.js\"\nimport type * as Logger from \"../Logger.js\"\nimport type * as LogLevel from \"../LogLevel.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Cause from \"./cause.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport { consoleTag } from \"./defaultServices/console.js\"\nimport * as fiberId_ from \"./fiberId.js\"\nimport * as logSpan_ from \"./logSpan.js\"\n\n/** @internal */\nconst LoggerSymbolKey = \"effect/Logger\"\n\n/** @internal */\nexport const LoggerTypeId: Logger.LoggerTypeId = Symbol.for(\n  LoggerSymbolKey\n) as Logger.LoggerTypeId\n\nconst loggerVariance = {\n  /* c8 ignore next */\n  _Message: (_: unknown) => _,\n  /* c8 ignore next */\n  _Output: (_: never) => _\n}\n\n/** @internal */\nexport const makeLogger = <Message, Output>(\n  log: (options: Logger.Logger.Options<Message>) => Output\n): Logger.Logger<Message, Output> => ({\n  [LoggerTypeId]: loggerVariance,\n  log,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n})\n\n/** @internal */\nexport const mapInput = dual<\n  <Message, Message2>(\n    f: (message: Message2) => Message\n  ) => <Output>(self: Logger.Logger<Message, Output>) => Logger.Logger<Message2, Output>,\n  <Output, Message, Message2>(\n    self: Logger.Logger<Message, Output>,\n    f: (message: Message2) => Message\n  ) => Logger.Logger<Message2, Output>\n>(2, (self, f) =>\n  makeLogger(\n    (options) => self.log({ ...options, message: f(options.message) })\n  ))\n\n/** @internal */\nexport const mapInputOptions = dual<\n  <Message, Message2>(\n    f: (options: Logger.Logger.Options<Message2>) => Logger.Logger.Options<Message>\n  ) => <Output>(self: Logger.Logger<Message, Output>) => Logger.Logger<Message2, Output>,\n  <Output, Message, Message2>(\n    self: Logger.Logger<Message, Output>,\n    f: (options: Logger.Logger.Options<Message2>) => Logger.Logger.Options<Message>\n  ) => Logger.Logger<Message2, Output>\n>(2, (self, f) => makeLogger((options) => self.log(f(options))))\n\n/** @internal */\nexport const filterLogLevel = dual<\n  (\n    f: (logLevel: LogLevel.LogLevel) => boolean\n  ) => <Message, Output>(self: Logger.Logger<Message, Output>) => Logger.Logger<Message, Option.Option<Output>>,\n  <Message, Output>(\n    self: Logger.Logger<Message, Output>,\n    f: (logLevel: LogLevel.LogLevel) => boolean\n  ) => Logger.Logger<Message, Option.Option<Output>>\n>(2, (self, f) =>\n  makeLogger((options) =>\n    f(options.logLevel)\n      ? Option.some(self.log(options))\n      : Option.none()\n  ))\n\n/** @internal */\nexport const map = dual<\n  <Output, Output2>(\n    f: (output: Output) => Output2\n  ) => <Message>(self: Logger.Logger<Message, Output>) => Logger.Logger<Message, Output2>,\n  <Message, Output, Output2>(\n    self: Logger.Logger<Message, Output>,\n    f: (output: Output) => Output2\n  ) => Logger.Logger<Message, Output2>\n>(2, (self, f) => makeLogger((options) => f(self.log(options))))\n\n/** @internal */\nexport const none: Logger.Logger<unknown, void> = {\n  [LoggerTypeId]: loggerVariance,\n  log: constVoid,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n} as Logger.Logger<unknown, void>\n\n/** @internal */\nexport const simple = <A, B>(log: (a: A) => B): Logger.Logger<A, B> => ({\n  [LoggerTypeId]: loggerVariance,\n  log: ({ message }) => log(message),\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n})\n\n/** @internal */\nexport const succeed = <A>(value: A): Logger.Logger<unknown, A> => {\n  return simple(() => value)\n}\n\n/** @internal */\nexport const sync = <A>(evaluate: LazyArg<A>): Logger.Logger<unknown, A> => {\n  return simple(evaluate)\n}\n\n/** @internal */\nexport const zip = dual<\n  <Message2, Output2>(\n    that: Logger.Logger<Message2, Output2>\n  ) => <Message, Output>(\n    self: Logger.Logger<Message, Output>\n  ) => Logger.Logger<Message & Message2, [Output, Output2]>,\n  <Message, Output, Message2, Output2>(\n    self: Logger.Logger<Message, Output>,\n    that: Logger.Logger<Message2, Output2>\n  ) => Logger.Logger<Message & Message2, [Output, Output2]>\n>(2, (self, that) => makeLogger((options) => [self.log(options), that.log(options)]))\n\n/** @internal */\nexport const zipLeft = dual<\n  <Message2, Output2>(\n    that: Logger.Logger<Message2, Output2>\n  ) => <Message, Output>(\n    self: Logger.Logger<Message, Output>\n  ) => Logger.Logger<Message & Message2, Output>,\n  <Message, Output, Message2, Output2>(\n    self: Logger.Logger<Message, Output>,\n    that: Logger.Logger<Message2, Output2>\n  ) => Logger.Logger<Message & Message2, Output>\n>(2, (self, that) => map(zip(self, that), (tuple) => tuple[0]))\n\n/** @internal */\nexport const zipRight = dual<\n  <Message2, Output2>(\n    that: Logger.Logger<Message2, Output2>\n  ) => <Message, Output>(\n    self: Logger.Logger<Message, Output>\n  ) => Logger.Logger<Message & Message2, Output2>,\n  <Message, Output, Message2, Output2>(\n    self: Logger.Logger<Message, Output>,\n    that: Logger.Logger<Message2, Output2>\n  ) => Logger.Logger<Message & Message2, Output2>\n>(2, (self, that) => map(zip(self, that), (tuple) => tuple[1]))\n\n/**\n * Match strings that do not contain any whitespace characters, double quotes,\n * or equal signs.\n *\n * @internal\n */\nconst textOnly = /^[^\\s\"=]*$/\n\n/**\n * Used by both {@link stringLogger} and {@link logfmtLogger} to render a log\n * message.\n *\n * @internal\n */\nconst format = (quoteValue: (s: string) => string, whitespace?: number | string | undefined) =>\n(\n  { annotations, cause, date, fiberId, logLevel, message, spans }: Logger.Logger.Options<unknown>\n): string => {\n  const formatValue = (value: string): string => value.match(textOnly) ? value : quoteValue(value)\n  const format = (label: string, value: string): string => `${logSpan_.formatLabel(label)}=${formatValue(value)}`\n  const append = (label: string, value: string): string => \" \" + format(label, value)\n\n  let out = format(\"timestamp\", date.toISOString())\n  out += append(\"level\", logLevel.label)\n  out += append(\"fiber\", fiberId_.threadName(fiberId))\n\n  const messages = Arr.ensure(message)\n  for (let i = 0; i < messages.length; i++) {\n    out += append(\"message\", Inspectable.toStringUnknown(messages[i], whitespace))\n  }\n\n  if (!Cause.isEmptyType(cause)) {\n    out += append(\"cause\", Cause.pretty(cause, { renderErrorCause: true }))\n  }\n\n  for (const span of spans) {\n    out += \" \" + logSpan_.render(date.getTime())(span)\n  }\n\n  for (const [label, value] of annotations) {\n    out += append(label, Inspectable.toStringUnknown(value, whitespace))\n  }\n\n  return out\n}\n\n/** @internal */\nconst escapeDoubleQuotes = (s: string) => `\"${s.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\")}\"`\n\n/** @internal */\nexport const stringLogger: Logger.Logger<unknown, string> = makeLogger(format(escapeDoubleQuotes))\n\n/** @internal */\nexport const logfmtLogger: Logger.Logger<unknown, string> = makeLogger(format(JSON.stringify, 0))\n\n/** @internal */\nexport const structuredLogger = makeLogger<unknown, {\n  readonly logLevel: string\n  readonly fiberId: string\n  readonly timestamp: string\n  readonly message: unknown\n  readonly cause: string | undefined\n  readonly annotations: Record<string, unknown>\n  readonly spans: Record<string, number>\n}>(\n  ({ annotations, cause, date, fiberId, logLevel, message, spans }) => {\n    const now = date.getTime()\n    const annotationsObj: Record<string, unknown> = {}\n    const spansObj: Record<string, number> = {}\n\n    if (HashMap.size(annotations) > 0) {\n      for (const [k, v] of annotations) {\n        annotationsObj[k] = structuredMessage(v)\n      }\n    }\n\n    if (List.isCons(spans)) {\n      for (const span of spans) {\n        spansObj[span.label] = now - span.startTime\n      }\n    }\n\n    const messageArr = Arr.ensure(message)\n    return {\n      message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),\n      logLevel: logLevel.label,\n      timestamp: date.toISOString(),\n      cause: Cause.isEmpty(cause) ? undefined : Cause.pretty(cause, { renderErrorCause: true }),\n      annotations: annotationsObj,\n      spans: spansObj,\n      fiberId: fiberId_.threadName(fiberId)\n    }\n  }\n)\n\n/** @internal */\nexport const structuredMessage = (u: unknown): unknown => {\n  switch (typeof u) {\n    case \"bigint\":\n    case \"function\":\n    case \"symbol\": {\n      return String(u)\n    }\n    default: {\n      return Inspectable.toJSON(u)\n    }\n  }\n}\n\n/** @internal */\nexport const jsonLogger = map(structuredLogger, Inspectable.stringifyCircular)\n\n/** @internal */\nexport const isLogger = (u: unknown): u is Logger.Logger<unknown, unknown> => {\n  return typeof u === \"object\" && u != null && LoggerTypeId in u\n}\n\nconst withColor = (text: string, ...colors: ReadonlyArray<string>) => {\n  let out = \"\"\n  for (let i = 0; i < colors.length; i++) {\n    out += `\\x1b[${colors[i]}m`\n  }\n  return out + text + \"\\x1b[0m\"\n}\nconst withColorNoop = (text: string, ..._colors: ReadonlyArray<string>) => text\nconst colors = {\n  bold: \"1\",\n  red: \"31\",\n  green: \"32\",\n  yellow: \"33\",\n  blue: \"34\",\n  cyan: \"36\",\n  white: \"37\",\n  gray: \"90\",\n  black: \"30\",\n  bgBrightRed: \"101\"\n} as const\n\nconst logLevelColors: Record<LogLevel.LogLevel[\"_tag\"], ReadonlyArray<string>> = {\n  None: [],\n  All: [],\n  Trace: [colors.gray],\n  Debug: [colors.blue],\n  Info: [colors.green],\n  Warning: [colors.yellow],\n  Error: [colors.red],\n  Fatal: [colors.bgBrightRed, colors.black]\n}\nconst logLevelStyle: Record<LogLevel.LogLevel[\"_tag\"], string> = {\n  None: \"\",\n  All: \"\",\n  Trace: \"color:gray\",\n  Debug: \"color:blue\",\n  Info: \"color:green\",\n  Warning: \"color:orange\",\n  Error: \"color:red\",\n  Fatal: \"background-color:red;color:white\"\n}\n\nconst defaultDateFormat = (date: Date): string =>\n  `${date.getHours().toString().padStart(2, \"0\")}:${date.getMinutes().toString().padStart(2, \"0\")}:${\n    date.getSeconds().toString().padStart(2, \"0\")\n  }.${date.getMilliseconds().toString().padStart(3, \"0\")}`\n\nconst hasProcessStdout = typeof process === \"object\" &&\n  process !== null &&\n  typeof process.stdout === \"object\" &&\n  process.stdout !== null\nconst processStdoutIsTTY = hasProcessStdout &&\n  process.stdout.isTTY === true\nconst hasProcessStdoutOrDeno = hasProcessStdout || \"Deno\" in globalThis\n\n/** @internal */\nexport const prettyLogger = (options?: {\n  readonly colors?: \"auto\" | boolean | undefined\n  readonly stderr?: boolean | undefined\n  readonly formatDate?: ((date: Date) => string) | undefined\n  readonly mode?: \"browser\" | \"tty\" | \"auto\" | undefined\n}) => {\n  const mode_ = options?.mode ?? \"auto\"\n  const mode = mode_ === \"auto\" ? (hasProcessStdoutOrDeno ? \"tty\" : \"browser\") : mode_\n  const isBrowser = mode === \"browser\"\n  const showColors = typeof options?.colors === \"boolean\" ? options.colors : processStdoutIsTTY || isBrowser\n  const formatDate = options?.formatDate ?? defaultDateFormat\n  return isBrowser\n    ? prettyLoggerBrowser({ colors: showColors, formatDate })\n    : prettyLoggerTty({ colors: showColors, formatDate, stderr: options?.stderr === true })\n}\n\nconst prettyLoggerTty = (options: {\n  readonly colors: boolean\n  readonly stderr: boolean\n  readonly formatDate: (date: Date) => string\n}) => {\n  const color = options.colors ? withColor : withColorNoop\n  return makeLogger<unknown, void>(\n    ({ annotations, cause, context, date, fiberId, logLevel, message: message_, spans }) => {\n      const services = FiberRefs.getOrDefault(context, defaultServices.currentServices)\n      const console = Context.get(services, consoleTag).unsafe\n      const log = options.stderr === true ? console.error : console.log\n\n      const message = Arr.ensure(message_)\n\n      let firstLine = color(`[${options.formatDate(date)}]`, colors.white)\n        + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])}`\n        + ` (${fiberId_.threadName(fiberId)})`\n\n      if (List.isCons(spans)) {\n        const now = date.getTime()\n        const render = logSpan_.render(now)\n        for (const span of spans) {\n          firstLine += \" \" + render(span)\n        }\n      }\n\n      firstLine += \":\"\n      let messageIndex = 0\n      if (message.length > 0) {\n        const firstMaybeString = structuredMessage(message[0])\n        if (typeof firstMaybeString === \"string\") {\n          firstLine += \" \" + color(firstMaybeString, colors.bold, colors.cyan)\n          messageIndex++\n        }\n      }\n\n      log(firstLine)\n      console.group()\n\n      if (!Cause.isEmpty(cause)) {\n        log(Cause.pretty(cause, { renderErrorCause: true }))\n      }\n\n      if (messageIndex < message.length) {\n        for (; messageIndex < message.length; messageIndex++) {\n          log(Inspectable.redact(message[messageIndex]))\n        }\n      }\n\n      if (HashMap.size(annotations) > 0) {\n        for (const [key, value] of annotations) {\n          log(color(`${key}:`, colors.bold, colors.white), Inspectable.redact(value))\n        }\n      }\n\n      console.groupEnd()\n    }\n  )\n}\n\nconst prettyLoggerBrowser = (options: {\n  readonly colors: boolean\n  readonly formatDate: (date: Date) => string\n}) => {\n  const color = options.colors ? \"%c\" : \"\"\n  return makeLogger<unknown, void>(\n    ({ annotations, cause, context, date, fiberId, logLevel, message: message_, spans }) => {\n      const services = FiberRefs.getOrDefault(context, defaultServices.currentServices)\n      const console = Context.get(services, consoleTag).unsafe\n      const message = Arr.ensure(message_)\n\n      let firstLine = `${color}[${options.formatDate(date)}]`\n      const firstParams = []\n      if (options.colors) {\n        firstParams.push(\"color:gray\")\n      }\n      firstLine += ` ${color}${logLevel.label}${color} (${fiberId_.threadName(fiberId)})`\n      if (options.colors) {\n        firstParams.push(logLevelStyle[logLevel._tag], \"\")\n      }\n      if (List.isCons(spans)) {\n        const now = date.getTime()\n        const render = logSpan_.render(now)\n        for (const span of spans) {\n          firstLine += \" \" + render(span)\n        }\n      }\n\n      firstLine += \":\"\n\n      let messageIndex = 0\n      if (message.length > 0) {\n        const firstMaybeString = structuredMessage(message[0])\n        if (typeof firstMaybeString === \"string\") {\n          firstLine += ` ${color}${firstMaybeString}`\n          if (options.colors) {\n            firstParams.push(\"color:deepskyblue\")\n          }\n          messageIndex++\n        }\n      }\n\n      console.groupCollapsed(firstLine, ...firstParams)\n\n      if (!Cause.isEmpty(cause)) {\n        console.error(Cause.pretty(cause, { renderErrorCause: true }))\n      }\n\n      if (messageIndex < message.length) {\n        for (; messageIndex < message.length; messageIndex++) {\n          console.log(Inspectable.redact(message[messageIndex]))\n        }\n      }\n\n      if (HashMap.size(annotations) > 0) {\n        for (const [key, value] of annotations) {\n          const redacted = Inspectable.redact(value)\n          if (options.colors) {\n            console.log(`%c${key}:`, \"color:gray\", redacted)\n          } else {\n            console.log(`${key}:`, redacted)\n          }\n        }\n      }\n\n      console.groupEnd()\n    }\n  )\n}\n\n/** @internal */\nexport const prettyLoggerDefault = globalValue(\"effect/Logger/prettyLoggerDefault\", () => prettyLogger())\n","import * as Arr from \"../../Array.js\"\nimport * as Chunk from \"../../Chunk.js\"\nimport * as Equal from \"../../Equal.js\"\nimport { pipe } from \"../../Function.js\"\nimport * as Hash from \"../../Hash.js\"\nimport type * as MetricBoundaries from \"../../MetricBoundaries.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport { hasProperty } from \"../../Predicate.js\"\n\n/** @internal */\nconst MetricBoundariesSymbolKey = \"effect/MetricBoundaries\"\n\n/** @internal */\nexport const MetricBoundariesTypeId: MetricBoundaries.MetricBoundariesTypeId = Symbol.for(\n  MetricBoundariesSymbolKey\n) as MetricBoundaries.MetricBoundariesTypeId\n\n/** @internal */\nclass MetricBoundariesImpl implements MetricBoundaries.MetricBoundaries {\n  readonly [MetricBoundariesTypeId]: MetricBoundaries.MetricBoundariesTypeId = MetricBoundariesTypeId\n  constructor(readonly values: ReadonlyArray<number>) {\n    this._hash = pipe(\n      Hash.string(MetricBoundariesSymbolKey),\n      Hash.combine(Hash.array(this.values))\n    )\n  }\n  readonly _hash: number;\n  [Hash.symbol](): number {\n    return this._hash\n  }\n  [Equal.symbol](u: unknown): boolean {\n    return isMetricBoundaries(u) && Equal.equals(this.values, u.values)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isMetricBoundaries = (u: unknown): u is MetricBoundaries.MetricBoundaries =>\n  hasProperty(u, MetricBoundariesTypeId)\n\n/** @internal */\nexport const fromIterable = (iterable: Iterable<number>): MetricBoundaries.MetricBoundaries => {\n  const values = pipe(\n    iterable,\n    Arr.appendAll(Chunk.of(Number.POSITIVE_INFINITY)),\n    Arr.dedupe\n  )\n  return new MetricBoundariesImpl(values)\n}\n\n/** @internal */\nexport const linear = (options: {\n  readonly start: number\n  readonly width: number\n  readonly count: number\n}): MetricBoundaries.MetricBoundaries =>\n  pipe(\n    Arr.makeBy(options.count - 1, (i) => options.start + i * options.width),\n    Chunk.unsafeFromArray,\n    fromIterable\n  )\n\n/** @internal */\nexport const exponential = (options: {\n  readonly start: number\n  readonly factor: number\n  readonly count: number\n}): MetricBoundaries.MetricBoundaries =>\n  pipe(\n    Arr.makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)),\n    Chunk.unsafeFromArray,\n    fromIterable\n  )\n","import * as Duration from \"../../Duration.js\"\nimport * as Equal from \"../../Equal.js\"\nimport { pipe } from \"../../Function.js\"\nimport * as Hash from \"../../Hash.js\"\nimport type * as MetricBoundaries from \"../../MetricBoundaries.js\"\nimport type * as MetricKeyType from \"../../MetricKeyType.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport { hasProperty } from \"../../Predicate.js\"\n\n/** @internal */\nconst MetricKeyTypeSymbolKey = \"effect/MetricKeyType\"\n\n/** @internal */\nexport const MetricKeyTypeTypeId: MetricKeyType.MetricKeyTypeTypeId = Symbol.for(\n  MetricKeyTypeSymbolKey\n) as MetricKeyType.MetricKeyTypeTypeId\n\n/** @internal */\nconst CounterKeyTypeSymbolKey = \"effect/MetricKeyType/Counter\"\n\n/** @internal */\nexport const CounterKeyTypeTypeId: MetricKeyType.CounterKeyTypeTypeId = Symbol.for(\n  CounterKeyTypeSymbolKey\n) as MetricKeyType.CounterKeyTypeTypeId\n\n/** @internal */\nconst FrequencyKeyTypeSymbolKey = \"effect/MetricKeyType/Frequency\"\n\n/** @internal */\nexport const FrequencyKeyTypeTypeId: MetricKeyType.FrequencyKeyTypeTypeId = Symbol.for(\n  FrequencyKeyTypeSymbolKey\n) as MetricKeyType.FrequencyKeyTypeTypeId\n\n/** @internal */\nconst GaugeKeyTypeSymbolKey = \"effect/MetricKeyType/Gauge\"\n\n/** @internal */\nexport const GaugeKeyTypeTypeId: MetricKeyType.GaugeKeyTypeTypeId = Symbol.for(\n  GaugeKeyTypeSymbolKey\n) as MetricKeyType.GaugeKeyTypeTypeId\n\n/** @internal */\nconst HistogramKeyTypeSymbolKey = \"effect/MetricKeyType/Histogram\"\n\n/** @internal */\nexport const HistogramKeyTypeTypeId: MetricKeyType.HistogramKeyTypeTypeId = Symbol.for(\n  HistogramKeyTypeSymbolKey\n) as MetricKeyType.HistogramKeyTypeTypeId\n\n/** @internal */\nconst SummaryKeyTypeSymbolKey = \"effect/MetricKeyType/Summary\"\n\n/** @internal */\nexport const SummaryKeyTypeTypeId: MetricKeyType.SummaryKeyTypeTypeId = Symbol.for(\n  SummaryKeyTypeSymbolKey\n) as MetricKeyType.SummaryKeyTypeTypeId\n\nconst metricKeyTypeVariance = {\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _Out: (_: never) => _\n}\n\n/** @internal */\nclass CounterKeyType<A extends (number | bigint)> implements MetricKeyType.MetricKeyType.Counter<A> {\n  readonly [MetricKeyTypeTypeId] = metricKeyTypeVariance\n  readonly [CounterKeyTypeTypeId]: MetricKeyType.CounterKeyTypeTypeId = CounterKeyTypeTypeId\n  constructor(readonly incremental: boolean, readonly bigint: boolean) {\n    this._hash = Hash.string(CounterKeyTypeSymbolKey)\n  }\n  readonly _hash: number;\n  [Hash.symbol](): number {\n    return this._hash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isCounterKey(that)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst FrequencyKeyTypeHash = Hash.string(FrequencyKeyTypeSymbolKey)\n\n/** @internal */\nclass FrequencyKeyType implements MetricKeyType.MetricKeyType.Frequency {\n  readonly [MetricKeyTypeTypeId] = metricKeyTypeVariance\n  readonly [FrequencyKeyTypeTypeId]: MetricKeyType.FrequencyKeyTypeTypeId = FrequencyKeyTypeTypeId\n  constructor(readonly preregisteredWords: ReadonlyArray<string>) {}\n  [Hash.symbol](): number {\n    return FrequencyKeyTypeHash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isFrequencyKey(that)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst GaugeKeyTypeHash = Hash.string(GaugeKeyTypeSymbolKey)\n\n/** @internal */\nclass GaugeKeyType<A extends (number | bigint)> implements MetricKeyType.MetricKeyType.Gauge<A> {\n  readonly [MetricKeyTypeTypeId] = metricKeyTypeVariance\n  readonly [GaugeKeyTypeTypeId]: MetricKeyType.GaugeKeyTypeTypeId = GaugeKeyTypeTypeId\n  constructor(readonly bigint: boolean) {}\n  [Hash.symbol](): number {\n    return GaugeKeyTypeHash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isGaugeKey(that)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport class HistogramKeyType implements MetricKeyType.MetricKeyType.Histogram {\n  readonly [MetricKeyTypeTypeId] = metricKeyTypeVariance\n  readonly [HistogramKeyTypeTypeId]: MetricKeyType.HistogramKeyTypeTypeId = HistogramKeyTypeTypeId\n  constructor(readonly boundaries: MetricBoundaries.MetricBoundaries) {\n    this._hash = pipe(\n      Hash.string(HistogramKeyTypeSymbolKey),\n      Hash.combine(Hash.hash(this.boundaries))\n    )\n  }\n  readonly _hash: number;\n  [Hash.symbol](): number {\n    return this._hash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isHistogramKey(that) && Equal.equals(this.boundaries, that.boundaries)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nclass SummaryKeyType implements MetricKeyType.MetricKeyType.Summary {\n  readonly [MetricKeyTypeTypeId] = metricKeyTypeVariance\n  readonly [SummaryKeyTypeTypeId]: MetricKeyType.SummaryKeyTypeTypeId = SummaryKeyTypeTypeId\n  constructor(\n    readonly maxAge: Duration.Duration,\n    readonly maxSize: number,\n    readonly error: number,\n    readonly quantiles: ReadonlyArray<number>\n  ) {\n    this._hash = pipe(\n      Hash.string(SummaryKeyTypeSymbolKey),\n      Hash.combine(Hash.hash(this.maxAge)),\n      Hash.combine(Hash.hash(this.maxSize)),\n      Hash.combine(Hash.hash(this.error)),\n      Hash.combine(Hash.array(this.quantiles))\n    )\n  }\n  readonly _hash: number;\n  [Hash.symbol](): number {\n    return this._hash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isSummaryKey(that) &&\n      Equal.equals(this.maxAge, that.maxAge) &&\n      this.maxSize === that.maxSize &&\n      this.error === that.error &&\n      Equal.equals(this.quantiles, that.quantiles)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const counter: <A extends number | bigint>(options?: {\n  readonly bigint: boolean\n  readonly incremental: boolean\n}) => CounterKeyType<A> = (options) =>\n  new CounterKeyType(\n    options?.incremental ?? false,\n    options?.bigint ?? false\n  )\n\n/** @internal */\nexport const frequency = (options?: {\n  readonly preregisteredWords?: ReadonlyArray<string> | undefined\n}): MetricKeyType.MetricKeyType.Frequency => new FrequencyKeyType(options?.preregisteredWords ?? [])\n\n/** @internal */\nexport const gauge: <A extends number | bigint>(options?: {\n  readonly bigint: boolean\n}) => GaugeKeyType<A> = (options) =>\n  new GaugeKeyType(\n    options?.bigint ?? false\n  )\n\n/** @internal */\nexport const histogram = (boundaries: MetricBoundaries.MetricBoundaries): MetricKeyType.MetricKeyType.Histogram => {\n  return new HistogramKeyType(boundaries)\n}\n\n/** @internal */\nexport const summary = (\n  options: {\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n  }\n): MetricKeyType.MetricKeyType.Summary => {\n  return new SummaryKeyType(Duration.decode(options.maxAge), options.maxSize, options.error, options.quantiles)\n}\n\n/** @internal */\nexport const isMetricKeyType = (u: unknown): u is MetricKeyType.MetricKeyType<unknown, unknown> =>\n  hasProperty(u, MetricKeyTypeTypeId)\n\n/** @internal */\nexport const isCounterKey = (u: unknown): u is MetricKeyType.MetricKeyType.Counter<number | bigint> =>\n  hasProperty(u, CounterKeyTypeTypeId)\n\n/** @internal */\nexport const isFrequencyKey = (u: unknown): u is MetricKeyType.MetricKeyType.Frequency =>\n  hasProperty(u, FrequencyKeyTypeTypeId)\n\n/** @internal */\nexport const isGaugeKey = (u: unknown): u is MetricKeyType.MetricKeyType.Gauge<number | bigint> =>\n  hasProperty(u, GaugeKeyTypeTypeId)\n\n/** @internal */\nexport const isHistogramKey = (u: unknown): u is MetricKeyType.MetricKeyType.Histogram =>\n  hasProperty(u, HistogramKeyTypeTypeId)\n\n/** @internal */\nexport const isSummaryKey = (u: unknown): u is MetricKeyType.MetricKeyType.Summary =>\n  hasProperty(u, SummaryKeyTypeTypeId)\n","import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type { Exit } from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport * as FiberRefs from \"../FiberRefs.js\"\nimport type * as FiberRefsPatch from \"../FiberRefsPatch.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constFalse, constTrue, constVoid, dual, identity, pipe } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as List from \"../List.js\"\nimport * as LogLevel from \"../LogLevel.js\"\nimport * as LogSpan from \"../LogSpan.js\"\nimport type * as Metric from \"../Metric.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as Option from \"../Option.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type * as Random from \"../Random.js\"\nimport * as Ref from \"../Ref.js\"\nimport type * as runtimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport * as Tracer from \"../Tracer.js\"\nimport type * as Types from \"../Types.js\"\nimport type { Unify } from \"../Unify.js\"\nimport { internalCall } from \"../Utils.js\"\nimport * as internalCause from \"./cause.js\"\nimport { clockTag } from \"./clock.js\"\nimport * as core from \"./core.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport * as doNotation from \"./doNotation.js\"\nimport * as fiberRefsPatch from \"./fiberRefs/patch.js\"\nimport type { FiberRuntime } from \"./fiberRuntime.js\"\nimport * as metricLabel from \"./metric/label.js\"\nimport * as runtimeFlags from \"./runtimeFlags.js\"\nimport * as internalTracer from \"./tracer.js\"\n\n/* @internal */\nexport const annotateLogs = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: unknown): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, unknown>): Effect.Effect<A, E, R>\n  }\n>(\n  (args) => core.isEffect(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return core.fiberRefLocallyWith(\n      args[0] as Effect.Effect<A, E, R>,\n      core.currentLogAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/* @internal */\nexport const asSome = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Option.Option<A>, E, R> =>\n  core.map(self, Option.some)\n\n/* @internal */\nexport const asSomeError = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Option.Option<E>, R> =>\n  core.mapError(self, Option.some)\n\n/* @internal */\nexport const try_: {\n  <A, E>(options: {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }): Effect.Effect<A, E>\n  <A>(thunk: LazyArg<A>): Effect.Effect<A, Cause.UnknownException>\n} = <A, E>(\n  arg: LazyArg<A> | {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }\n) => {\n  let evaluate: LazyArg<A>\n  let onFailure: ((error: unknown) => E) | undefined = undefined\n  if (typeof arg === \"function\") {\n    evaluate = arg\n  } else {\n    evaluate = arg.try\n    onFailure = arg.catch\n  }\n  return core.suspend(() => {\n    try {\n      return core.succeed(internalCall(evaluate))\n    } catch (error) {\n      return core.fail(\n        onFailure\n          ? internalCall(() => onFailure(error))\n          : new core.UnknownException(error, \"An unknown error occurred in Effect.try\")\n      )\n    }\n  })\n}\n\n/* @internal */\nexport const _catch: {\n  <N extends keyof E, K extends E[N] & string, E, A1, E1, R1>(\n    discriminator: N,\n    options: {\n      readonly failure: K\n      readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect.Effect<A1, E1, R1>\n    }\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<\n    A | A1,\n    Exclude<E, { [n in N]: K }> | E1,\n    R | R1\n  >\n  <A, E, R, N extends keyof E, K extends E[N] & string, A1, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    discriminator: N,\n    options: {\n      readonly failure: K\n      readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect.Effect<A1, E1, R1>\n    }\n  ): Effect.Effect<A | A1, Exclude<E, { [n in N]: K }> | E1, R | R1>\n} = dual(\n  3,\n  (self, tag, options) =>\n    core.catchAll(self, (e) => {\n      if (Predicate.hasProperty(e, tag) && e[tag] === options.failure) {\n        return options.onFailure(e)\n      }\n      return core.fail(e)\n    })\n)\n\n/* @internal */\nexport const catchAllDefect = dual<\n  <A2, E2, R2>(\n    f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  core.catchAllCause(\n    self,\n    (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n      const option = internalCause.find(cause, (_) => internalCause.isDieType(_) ? Option.some(_) : Option.none())\n      switch (option._tag) {\n        case \"None\": {\n          return core.failCause(cause)\n        }\n        case \"Some\": {\n          return f(option.value.defect)\n        }\n      }\n    }\n  ))\n\n/* @internal */\nexport const catchSomeCause: {\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E | E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E | E2, R2 | R> =>\n    core.matchCauseEffect(self, {\n      onFailure: (cause): Effect.Effect<A2, E | E2, R2> => {\n        const option = f(cause)\n        switch (option._tag) {\n          case \"None\": {\n            return core.failCause(cause)\n          }\n          case \"Some\": {\n            return option.value\n          }\n        }\n      },\n      onSuccess: core.succeed\n    })\n)\n\n/* @internal */\nexport const catchSomeDefect = dual<\n  <A2, E2, R2>(\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A | A2, E | E2, R | R2> =>\n    core.catchAllCause(\n      self,\n      (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n        const option = internalCause.find(cause, (_) => internalCause.isDieType(_) ? Option.some(_) : Option.none())\n        switch (option._tag) {\n          case \"None\": {\n            return core.failCause(cause)\n          }\n          case \"Some\": {\n            const optionEffect = pf(option.value.defect)\n            return optionEffect._tag === \"Some\" ? optionEffect.value : core.failCause(cause)\n          }\n        }\n      }\n    )\n)\n\n/* @internal */\nexport const catchTag: {\n  <\n    E,\n    const K extends Arr.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>,\n    A1,\n    E1,\n    R1\n  >(\n    ...args: [\n      ...tags: K,\n      f: (e: Extract<Types.NoInfer<E>, { _tag: K[number] }>) => Effect.Effect<A1, E1, R1>\n    ]\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1>\n  <\n    A,\n    E,\n    R,\n    const K extends Arr.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>,\n    A1,\n    E1,\n    R1\n  >(\n    self: Effect.Effect<A, E, R>,\n    ...args: [\n      ...tags: K,\n      f: (e: Extract<Types.NoInfer<E>, { _tag: K[number] }>) => Effect.Effect<A1, E1, R1>\n    ]\n  ): Effect.Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1>\n} = dual(\n  (args: any) => core.isEffect(args[0]),\n  <A, E, R, const K extends Arr.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>, R1, E1, A1>(\n    self: Effect.Effect<A, E, R>,\n    ...args: [\n      ...tags: K & { [I in keyof K]: E extends { _tag: string } ? E[\"_tag\"] : never },\n      f: (e: Extract<Types.NoInfer<E>, { _tag: K[number] }>) => Effect.Effect<A1, E1, R1>\n    ]\n  ): Effect.Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1> => {\n    const f = args[args.length - 1] as any\n    let predicate: Predicate.Predicate<E>\n    if (args.length === 2) {\n      predicate = Predicate.isTagged(args[0] as string)\n    } else {\n      predicate = (e) => {\n        const tag = Predicate.hasProperty(e, \"_tag\") ? e[\"_tag\"] : undefined\n        if (!tag) return false\n        for (let i = 0; i < args.length - 1; i++) {\n          if (args[i] === tag) return true\n        }\n        return false\n      }\n    }\n    return core.catchIf(self, predicate as Predicate.Refinement<E, Extract<E, { _tag: K[number] }>>, f) as any\n  }\n) as any\n\n/** @internal */\nexport const catchTags: {\n  <\n    E,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Effect.Effect<any, any, any>\n      } :\n      {})\n  >(\n    cases: Cases\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<infer A, any, any>) ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n    }[keyof Cases]\n  >\n  <\n    R,\n    E,\n    A,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Effect.Effect<any, any, any>\n      } :\n      {})\n  >(\n    self: Effect.Effect<A, E, R>,\n    cases: Cases\n  ): Effect.Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<infer A, any, any>) ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n    }[keyof Cases]\n  >\n} = dual(2, (self, cases) => {\n  let keys: Array<string>\n  return core.catchIf(\n    self,\n    (e): e is { readonly _tag: string } => {\n      keys ??= Object.keys(cases)\n      return Predicate.hasProperty(e, \"_tag\") && Predicate.isString(e[\"_tag\"]) && keys.includes(e[\"_tag\"])\n    },\n    (e) => cases[e[\"_tag\"]](e)\n  )\n})\n\n/* @internal */\nexport const cause = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Cause.Cause<E>, never, R> =>\n  core.matchCause(self, { onFailure: identity, onSuccess: () => internalCause.empty })\n\n/* @internal */\nexport const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  Clock.clockWith\n\n/* @internal */\nexport const clock: Effect.Effect<Clock.Clock> = clockWith(core.succeed)\n\n/* @internal */\nexport const delay = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, duration: Duration.DurationInput) => Effect.Effect<A, E, R>\n>(2, (self, duration) => core.zipRight(Clock.sleep(duration), self))\n\n/* @internal */\nexport const descriptorWith = <A, E, R>(\n  f: (descriptor: Fiber.Fiber.Descriptor) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  core.withFiberRuntime((state, status) =>\n    f({\n      id: state.id(),\n      status,\n      interruptors: internalCause.interruptors(state.getFiberRef(core.currentInterruptedCause))\n    })\n  ) as Effect.Effect<A, E, R>\n\n/* @internal */\nexport const allowInterrupt: Effect.Effect<void> = descriptorWith(\n  (descriptor) =>\n    HashSet.size(descriptor.interruptors) > 0\n      ? core.interrupt\n      : core.void\n)\n\n/* @internal */\nexport const descriptor: Effect.Effect<Fiber.Fiber.Descriptor> = descriptorWith(core.succeed)\n\n/* @internal */\nexport const diffFiberRefs = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R> => summarized(self, fiberRefs, fiberRefsPatch.diff)\n\n/* @internal */\nexport const diffFiberRefsAndRuntimeFlags = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[[FiberRefsPatch.FiberRefsPatch, runtimeFlagsPatch.RuntimeFlagsPatch], A], E, R> =>\n  summarized(\n    self,\n    core.zip(fiberRefs, core.runtimeFlags),\n    ([refs, flags], [refsNew, flagsNew]) => [fiberRefsPatch.diff(refs, refsNew), runtimeFlags.diff(flags, flagsNew)]\n  )\n\n/* @internal */\nexport const Do: Effect.Effect<{}> = core.succeed({})\n\n/* @internal */\nexport const bind: {\n  <N extends string, A extends object, B, E2, R2>(\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): <E1, R1>(\n    self: Effect.Effect<A, E1, R1>\n  ) => Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E2 | E1, R2 | R1>\n  <A extends object, N extends string, E1, R1, B, E2, R2>(\n    self: Effect.Effect<A, E1, R1>,\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E1 | E2, R1 | R2>\n} = doNotation.bind<Effect.EffectTypeLambda>(core.map, core.flatMap)\n\n/* @internal */\nexport const bindTo: {\n  <N extends string>(name: N): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<{ [K in N]: A }, E, R>\n  <A, E, R, N extends string>(self: Effect.Effect<A, E, R>, name: N): Effect.Effect<{ [K in N]: A }, E, R>\n} = doNotation.bindTo<Effect.EffectTypeLambda>(core.map)\n\n/* @internal */\nexport const let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => B\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n  <A extends object, N extends string, E, R, B>(\n    self: Effect.Effect<A, E, R>,\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => B\n  ): Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n} = doNotation.let_<Effect.EffectTypeLambda>(core.map)\n\n/* @internal */\nexport const dropUntil: {\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let dropping: Effect.Effect<boolean, E, R> = core.succeed(false)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        dropping = core.flatMap(dropping, (bool) => {\n          if (bool) {\n            builder.push(a)\n            return core.succeed(true)\n          }\n          return predicate(a, index)\n        })\n      }\n      return core.map(dropping, () => builder)\n    })\n)\n\n/* @internal */\nexport const dropWhile: {\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next\n      let dropping: Effect.Effect<boolean, E, R> = core.succeed(true)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        dropping = core.flatMap(dropping, (d) =>\n          core.map(d ? predicate(a, index) : core.succeed(false), (b) => {\n            if (!b) {\n              builder.push(a)\n            }\n            return b\n          }))\n      }\n      return core.map(dropping, () => builder)\n    })\n)\n\n/* @internal */\nexport const contextWith = <R, A>(f: (context: Context.Context<R>) => A): Effect.Effect<A, never, R> =>\n  core.map(core.context<R>(), f)\n\n/* @internal */\nexport const eventually = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> =>\n  core.orElse(self, () => core.flatMap(core.yieldNow(), () => eventually(self)))\n\n/* @internal */\nexport const filterMap = dual<\n  <Eff extends Effect.Effect<any, any, any>, B>(\n    pf: (a: Effect.Effect.Success<Eff>) => Option.Option<B>\n  ) => (elements: Iterable<Eff>) => Effect.Effect<Array<B>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>,\n  <Eff extends Effect.Effect<any, any, any>, B>(\n    elements: Iterable<Eff>,\n    pf: (a: Effect.Effect.Success<Eff>) => Option.Option<B>\n  ) => Effect.Effect<Array<B>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>\n>(2, (elements, pf) =>\n  core.map(\n    core.forEachSequential(elements, identity),\n    Arr.filterMap(pf)\n  ))\n\n/* @internal */\nexport const filterOrDie: {\n  <A, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    orDieWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => unknown\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    orDieWith: (a: Types.NoInfer<A>) => unknown\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orDieWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => unknown\n  ): Effect.Effect<B, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<A, E, R>\n} = dual(\n  3,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<A, E, R> => filterOrElse(self, predicate, (a) => core.dieSync(() => orDieWith(a)))\n)\n\n/* @internal */\nexport const filterOrDieMessage: {\n  <A, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    message: string\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    message: string\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    message: string\n  ): Effect.Effect<B, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    message: string\n  ): Effect.Effect<A, E, R>\n} = dual(\n  3,\n  <A, E, R>(self: Effect.Effect<A, E, R>, predicate: Predicate.Predicate<A>, message: string): Effect.Effect<A, E, R> =>\n    filterOrElse(self, predicate, () => core.dieMessage(message))\n)\n\n/* @internal */\nexport const filterOrElse: {\n  <A, C, E2, R2, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    orElse: (a: Types.EqualsWith<A, B, Types.NoInfer<A>, Exclude<Types.NoInfer<A>, B>>) => Effect.Effect<C, E2, R2>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B | C, E2 | E, R2 | R>\n  <A, C, E2, R2>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    orElse: (a: Types.NoInfer<A>) => Effect.Effect<C, E2, R2>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | C, E2 | E, R2 | R>\n  <A, E, R, C, E2, R2, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orElse: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => Effect.Effect<C, E2, R2>\n  ): Effect.Effect<B | C, E | E2, R | R2>\n  <A, E, R, C, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orElse: (a: A) => Effect.Effect<C, E2, R2>\n  ): Effect.Effect<A | C, E | E2, R | R2>\n} = dual(3, <A, E, R, B, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate.Predicate<A>,\n  orElse: (a: A) => Effect.Effect<B, E2, R2>\n): Effect.Effect<A | B, E | E2, R | R2> =>\n  core.flatMap(\n    self,\n    (a) => predicate(a) ? core.succeed<A | B>(a) : orElse(a)\n  ))\n\n/** @internal */\nexport const liftPredicate = dual<\n  <T extends A, E, B extends T = T, A = T>(\n    predicate: Predicate.Refinement<T, B> | Predicate.Predicate<T>,\n    orFailWith: (a: Types.EqualsWith<T, B, A, Exclude<A, B>>) => E\n  ) => (a: A) => Effect.Effect<Types.EqualsWith<T, B, A, B>, E>,\n  <A, E, B extends A = A>(\n    self: A,\n    predicate: Predicate.Refinement<A, B> | Predicate.Predicate<A>,\n    orFailWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => E\n  ) => Effect.Effect<B, E>\n>(\n  3,\n  <A, E, B extends A = A>(\n    self: A,\n    predicate: Predicate.Refinement<A, B> | Predicate.Predicate<A>,\n    orFailWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => E\n  ): Effect.Effect<B, E> =>\n    core.suspend(() => predicate(self) ? core.succeed(self as B) : core.fail(orFailWith(self as any)))\n)\n\n/* @internal */\nexport const filterOrFail: {\n  <A, E2, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    orFailWith: (a: Types.EqualsWith<A, B, Types.NoInfer<A>, Exclude<Types.NoInfer<A>, B>>) => E2\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Types.NoInfer<B>, E2 | E, R>\n  <A, E2>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    orFailWith: (a: Types.NoInfer<A>) => E2\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2 | E, R>\n  <A, E, R, E2, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orFailWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => E2\n  ): Effect.Effect<Types.NoInfer<B>, E2 | E, R>\n  <A, E, R, E2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orFailWith: (a: A) => E2\n  ): Effect.Effect<A, E2 | E, R>\n  <A, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Types.NoInfer<B>, Cause.NoSuchElementException | E, R>\n  <A>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, Cause.NoSuchElementException | E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>\n  ): Effect.Effect<Types.NoInfer<B>, E | Cause.NoSuchElementException, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>\n  ): Effect.Effect<A, E | Cause.NoSuchElementException, R>\n} = dual((args) => core.isEffect(args[0]), <A, E, R, E2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate.Predicate<A>,\n  orFailWith?: (a: A) => E2\n): Effect.Effect<A, E | E2 | Cause.NoSuchElementException, R> =>\n  filterOrElse(\n    self,\n    predicate,\n    (a): Effect.Effect<never, E2 | Cause.NoSuchElementException, never> =>\n      orFailWith === undefined ? core.fail(new core.NoSuchElementException()) : core.failSync(() => orFailWith(a))\n  ))\n\n/* @internal */\nexport const findFirst: {\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Option.Option<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const next = iterator.next()\n      if (!next.done) {\n        return findLoop(iterator, 0, predicate, next.value)\n      }\n      return core.succeed(Option.none())\n    })\n)\n\nconst findLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>,\n  value: A\n): Effect.Effect<Option.Option<A>, E, R> =>\n  core.flatMap(f(value, index), (result) => {\n    if (result) {\n      return core.succeed(Option.some(value))\n    }\n    const next = iterator.next()\n    if (!next.done) {\n      return findLoop(iterator, index + 1, f, next.value)\n    }\n    return core.succeed(Option.none())\n  })\n\n/* @internal */\nexport const firstSuccessOf = <Eff extends Effect.Effect<any, any, any>>(\n  effects: Iterable<Eff>\n): Effect.Effect<Effect.Effect.Success<Eff>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>> =>\n  core.suspend(() => {\n    const list = Chunk.fromIterable(effects)\n    if (!Chunk.isNonEmpty(list)) {\n      return core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`))\n    }\n    return pipe(\n      Chunk.tailNonEmpty(list),\n      Arr.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right) as Eff)\n    )\n  })\n\n/* @internal */\nexport const flipWith: {\n  <E, A, R, E2, A2, R2>(\n    f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n  ): (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>\n  <A, E, R, E2, A2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n  ): Effect.Effect<A2, E2, R2>\n} = dual(2, <A, E, R, E2, A2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n): Effect.Effect<A2, E2, R2> => core.flip(f(core.flip(self))))\n\n/* @internal */\nexport const match: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (error: E) => A2\n    readonly onSuccess: (value: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  core.matchEffect(self, {\n    onFailure: (e) => core.succeed(options.onFailure(e)),\n    onSuccess: (a) => core.succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const every: {\n  <A, E, R>(\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<boolean, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<boolean, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<boolean, E, R> => core.suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate))\n)\n\nconst forAllLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>\n): Effect.Effect<boolean, E, R> => {\n  const next = iterator.next()\n  return next.done\n    ? core.succeed(true)\n    : core.flatMap(\n      f(next.value, index),\n      (b) => b ? forAllLoop(iterator, index + 1, f) : core.succeed(b)\n    )\n}\n\n/* @internal */\nexport const forever = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<never, E, R> => {\n  const loop: Effect.Effect<never, E, R> = core.flatMap(core.flatMap(self, () => core.yieldNow()), () => loop)\n  return loop\n}\n\n/* @internal */\nexport const fiberRefs: Effect.Effect<FiberRefs.FiberRefs> = core.withFiberRuntime((state) =>\n  core.succeed(state.getFiberRefs())\n)\n\n/* @internal */\nexport const head = <A, E, R>(\n  self: Effect.Effect<Iterable<A>, E, R>\n): Effect.Effect<A, E | Cause.NoSuchElementException, R> =>\n  core.flatMap(self, (as) => {\n    const iterator = as[Symbol.iterator]()\n    const next = iterator.next()\n    if (next.done) {\n      return core.fail(new core.NoSuchElementException())\n    }\n    return core.succeed(next.value)\n  })\n\n/* @internal */\nexport const ignore = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> =>\n  match(self, { onFailure: constVoid, onSuccess: constVoid })\n\n/* @internal */\nexport const ignoreLogged = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => logDebug(cause, \"An error was silently ignored because it is not anticipated to be useful\"),\n    onSuccess: () => core.void\n  })\n\n/* @internal */\nexport const inheritFiberRefs = (childFiberRefs: FiberRefs.FiberRefs) =>\n  updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs))\n\n/* @internal */\nexport const isFailure = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<boolean, never, R> =>\n  match(self, { onFailure: constTrue, onSuccess: constFalse })\n\n/* @internal */\nexport const isSuccess = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<boolean, never, R> =>\n  match(self, { onFailure: constFalse, onSuccess: constTrue })\n\n/* @internal */\nexport const iterate: {\n  <A, B extends A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly body: (b: B) => Effect.Effect<A, E, R>\n    }\n  ): Effect.Effect<A, E, R>\n  <A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Predicate<A>\n      readonly body: (a: A) => Effect.Effect<A, E, R>\n    }\n  ): Effect.Effect<A, E, R>\n} = <A, E, R>(\n  initial: A,\n  options: {\n    readonly while: Predicate.Predicate<A>\n    readonly body: (z: A) => Effect.Effect<A, E, R>\n  }\n): Effect.Effect<A, E, R> =>\n  core.suspend<A, E, R>(() => {\n    if (options.while(initial)) {\n      return core.flatMap(options.body(initial), (z2) => iterate(z2, options))\n    }\n    return core.succeed(initial)\n  })\n\n/** @internal */\nexport const logWithLevel = (level?: LogLevel.LogLevel) =>\n(\n  ...message: ReadonlyArray<any>\n): Effect.Effect<void> => {\n  const levelOption = Option.fromNullable(level)\n  let cause: Cause.Cause<unknown> | undefined = undefined\n  for (let i = 0, len = message.length; i < len; i++) {\n    const msg = message[i]\n    if (internalCause.isCause(msg)) {\n      if (cause !== undefined) {\n        cause = internalCause.sequential(cause, msg)\n      } else {\n        cause = msg\n      }\n      message = [...message.slice(0, i), ...message.slice(i + 1)]\n      i--\n    }\n  }\n  if (cause === undefined) {\n    cause = internalCause.empty\n  }\n  return core.withFiberRuntime((fiberState) => {\n    fiberState.log(message, cause, levelOption)\n    return core.void\n  })\n}\n\n/** @internal */\nexport const log: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel()\n\n/** @internal */\nexport const logTrace: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Trace\n)\n\n/** @internal */\nexport const logDebug: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Debug\n)\n\n/** @internal */\nexport const logInfo: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Info\n)\n\n/** @internal */\nexport const logWarning: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Warning\n)\n\n/** @internal */\nexport const logError: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Error\n)\n\n/** @internal */\nexport const logFatal: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Fatal\n)\n\n/* @internal */\nexport const withLogSpan = dual<\n  (label: string) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, label: string) => Effect.Effect<A, E, R>\n>(2, (effect, label) =>\n  core.flatMap(Clock.currentTimeMillis, (now) =>\n    core.fiberRefLocallyWith(\n      effect,\n      core.currentLogSpan,\n      List.prepend(LogSpan.make(label, now))\n    )))\n\n/* @internal */\nexport const logAnnotations: Effect.Effect<HashMap.HashMap<string, unknown>> = core\n  .fiberRefGet(\n    core.currentLogAnnotations\n  )\n\n/* @internal */\nexport const loop: {\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect.Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<Array<C>, E, R>\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect.Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<Array<C>, E, R>\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect.Effect<R, E, C>\n      readonly discard: true\n    }\n  ): Effect.Effect<void, E, R>\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect.Effect<C, E, R>\n      readonly discard: true\n    }\n  ): Effect.Effect<void, E, R>\n} = <A, C, E, R>(\n  initial: A,\n  options: {\n    readonly while: Predicate.Predicate<A>\n    readonly step: (a: A) => A\n    readonly body: (a: A) => Effect.Effect<C, E, R>\n    readonly discard?: boolean | undefined\n  }\n): any =>\n  options.discard\n    ? loopDiscard(initial, options.while, options.step, options.body)\n    : core.map(loopInternal(initial, options.while, options.step, options.body), Arr.fromIterable)\n\nconst loopInternal = <Z, A, E, R>(\n  initial: Z,\n  cont: Predicate.Predicate<Z>,\n  inc: (z: Z) => Z,\n  body: (z: Z) => Effect.Effect<A, E, R>\n): Effect.Effect<List.List<A>, E, R> =>\n  core.suspend(() =>\n    cont(initial)\n      ? core.flatMap(body(initial), (a) =>\n        core.map(\n          loopInternal(inc(initial), cont, inc, body),\n          List.prepend(a)\n        ))\n      : core.sync(() => List.empty())\n  )\n\nconst loopDiscard = <S, X, E, R>(\n  initial: S,\n  cont: Predicate.Predicate<S>,\n  inc: (s: S) => S,\n  body: (s: S) => Effect.Effect<X, E, R>\n): Effect.Effect<void, E, R> =>\n  core.suspend(() =>\n    cont(initial)\n      ? core.flatMap(\n        body(initial),\n        () => loopDiscard(inc(initial), cont, inc, body)\n      )\n      : core.void\n  )\n\n/* @internal */\nexport const mapAccum: {\n  <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    initial: S,\n    f: (state: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n  ): (elements: I) => Effect.Effect<[S, Arr.ReadonlyArray.With<I, B>], E, R>\n  <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    elements: I,\n    initial: S,\n    f: (state: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n  ): Effect.Effect<[S, Arr.ReadonlyArray.With<I, B>], E, R>\n} = dual(3, <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n  elements: I,\n  initial: S,\n  f: (state: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n): Effect.Effect<[S, Array<B>], E, R> =>\n  core.suspend(() => {\n    const iterator = elements[Symbol.iterator]()\n    const builder: Array<B> = []\n    let result: Effect.Effect<S, E, R> = core.succeed(initial)\n    let next: IteratorResult<A, any>\n    let i = 0\n    while (!(next = iterator.next()).done) {\n      const index = i++\n      const value = next.value\n      result = core.flatMap(result, (state) =>\n        core.map(f(state, value, index), ([z, b]) => {\n          builder.push(b)\n          return z\n        }))\n    }\n    return core.map(result, (z) => [z, builder])\n  }))\n\n/* @internal */\nexport const mapErrorCause: {\n  <E, E2>(\n    f: (cause: Cause.Cause<E>) => Cause.Cause<E2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect.Effect<A, E2, R> =>\n    core.matchCauseEffect(self, {\n      onFailure: (c) => core.failCauseSync(() => f(c)),\n      onSuccess: core.succeed\n    })\n)\n\n/* @internal */\nexport const memoize = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Effect.Effect<A, E, R>> =>\n  pipe(\n    core.deferredMake<[[FiberRefsPatch.FiberRefsPatch, runtimeFlagsPatch.RuntimeFlagsPatch], A], E>(),\n    core.flatMap((deferred) =>\n      pipe(\n        diffFiberRefsAndRuntimeFlags(self),\n        core.intoDeferred(deferred),\n        once,\n        core.map((complete) =>\n          core.zipRight(\n            complete,\n            pipe(\n              core.deferredAwait(deferred),\n              core.flatMap(([patch, a]) =>\n                core.as(core.zip(patchFiberRefs(patch[0]), core.updateRuntimeFlags(patch[1])), a)\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n\n/* @internal */\nexport const merge = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E | A, never, R> =>\n  core.matchEffect(self, {\n    onFailure: (e) => core.succeed(e),\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const negate = <E, R>(self: Effect.Effect<boolean, E, R>): Effect.Effect<boolean, E, R> =>\n  core.map(self, (b) => !b)\n\n/* @internal */\nexport const none = <A, E, R>(\n  self: Effect.Effect<Option.Option<A>, E, R>\n): Effect.Effect<void, E | Cause.NoSuchElementException, R> =>\n  core.flatMap(self, (option) => {\n    switch (option._tag) {\n      case \"None\":\n        return core.void\n      case \"Some\":\n        return core.fail(new core.NoSuchElementException())\n    }\n  })\n\n/* @internal */\nexport const once = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Effect.Effect<void, E, R>> =>\n  core.map(\n    Ref.make(true),\n    (ref) => core.asVoid(core.whenEffect(self, Ref.getAndSet(ref, false)))\n  )\n\n/* @internal */\nexport const option = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Option.Option<A>, never, R> =>\n  core.matchEffect(self, {\n    onFailure: () => core.succeed(Option.none()),\n    onSuccess: (a) => core.succeed(Option.some(a))\n  })\n\n/* @internal */\nexport const orElseFail = dual<\n  <E2>(evaluate: LazyArg<E2>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, evaluate: LazyArg<E2>) => Effect.Effect<A, E2, R>\n>(2, (self, evaluate) => core.orElse(self, () => core.failSync(evaluate)))\n\n/* @internal */\nexport const orElseSucceed = dual<\n  <A2>(evaluate: LazyArg<A2>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, never, R>,\n  <A, E, R, A2>(self: Effect.Effect<A, E, R>, evaluate: LazyArg<A2>) => Effect.Effect<A | A2, never, R>\n>(2, (self, evaluate) => core.orElse(self, () => core.sync(evaluate)))\n\n/* @internal */\nexport const parallelErrors = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Array<E>, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const errors = Arr.fromIterable(internalCause.failures(cause))\n      return errors.length === 0\n        ? core.failCause(cause as Cause.Cause<never>)\n        : core.fail(errors)\n    },\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const patchFiberRefs = (patch: FiberRefsPatch.FiberRefsPatch): Effect.Effect<void> =>\n  updateFiberRefs((fiberId, fiberRefs) => pipe(patch, fiberRefsPatch.patch(fiberId, fiberRefs)))\n\n/* @internal */\nexport const promise = <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect.Effect<A> =>\n  evaluate.length >= 1\n    ? core.async((resolve, signal) => {\n      try {\n        evaluate(signal)\n          .then((a) => resolve(core.succeed(a)), (e) => resolve(core.die(e)))\n      } catch (e) {\n        resolve(core.die(e))\n      }\n    })\n    : core.async((resolve) => {\n      try {\n        ;(evaluate as LazyArg<PromiseLike<A>>)()\n          .then((a) => resolve(core.succeed(a)), (e) => resolve(core.die(e)))\n      } catch (e) {\n        resolve(core.die(e))\n      }\n    })\n\n/* @internal */\nexport const provideService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, I>>,\n  <A, E, R, I, S>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => Effect.Effect<A, E, Exclude<R, I>>\n>(\n  3,\n  <A, E, R, I, S>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ): Effect.Effect<A, E, Exclude<R, I>> =>\n    core.contextWithEffect((env) =>\n      core.provideContext(\n        self as Effect.Effect<A, E, I | Exclude<R, I>>,\n        Context.add(env, tag, service)\n      )\n    )\n)\n\n/* @internal */\nexport const provideServiceEffect = dual<\n  <I, S, E1, R1>(\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E1, R1>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R1 | Exclude<R, I>>,\n  <A, E, R, I, S, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E1, R1>\n  ) => Effect.Effect<A, E | E1, R1 | Exclude<R, I>>\n>(3, <A, E, R, I, S, E1, R1>(\n  self: Effect.Effect<A, E, R>,\n  tag: Context.Tag<I, S>,\n  effect: Effect.Effect<Types.NoInfer<S>, E1, R1>\n) =>\n  core.contextWithEffect((env: Context.Context<R1 | Exclude<R, I>>) =>\n    core.flatMap(\n      effect,\n      (service) => core.provideContext(self, pipe(env, Context.add(tag, service)) as Context.Context<R | R1>)\n    )\n  ))\n\n/* @internal */\nexport const random: Effect.Effect<Random.Random> = defaultServices.randomWith(core.succeed)\n\n/* @internal */\nexport const reduce = dual<\n  <Z, A, E, R>(\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) => Effect.Effect<Z, E, R>\n>(\n  3,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) =>\n    Arr.fromIterable(elements).reduce(\n      (acc, el, i) => core.flatMap(acc, (a) => f(a, el, i)),\n      core.succeed(zero) as Effect.Effect<Z, E, R>\n    )\n)\n\n/* @internal */\nexport const reduceRight = dual<\n  <A, Z, R, E>(\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, R, E>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>\n  ) => Effect.Effect<Z, E, R>\n>(\n  3,\n  <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>) =>\n    Arr.fromIterable(elements).reduceRight(\n      (acc, el, i) => core.flatMap(acc, (a) => f(el, a, i)),\n      core.succeed(zero) as Effect.Effect<Z, E, R>\n    )\n)\n\n/* @internal */\nexport const reduceWhile = dual<\n  <Z, A, E, R>(\n    zero: Z,\n    options: {\n      readonly while: Predicate.Predicate<Z>\n      readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n    }\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    options: {\n      readonly while: Predicate.Predicate<Z>\n      readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n    }\n  ) => Effect.Effect<Z, E, R>\n>(3, <A, Z, E, R>(\n  elements: Iterable<A>,\n  zero: Z,\n  options: {\n    readonly while: Predicate.Predicate<Z>\n    readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  }\n) =>\n  core.flatMap(\n    core.sync(() => elements[Symbol.iterator]()),\n    (iterator) => reduceWhileLoop(iterator, 0, zero, options.while, options.body)\n  ))\n\nconst reduceWhileLoop = <A, R, E, Z>(\n  iterator: Iterator<A>,\n  index: number,\n  state: Z,\n  predicate: Predicate.Predicate<Z>,\n  f: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n): Effect.Effect<Z, E, R> => {\n  const next = iterator.next()\n  if (!next.done && predicate(state)) {\n    return core.flatMap(\n      f(state, next.value, index),\n      (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f)\n    )\n  }\n  return core.succeed(state)\n}\n\n/* @internal */\nexport const repeatN = dual<\n  (n: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, n: number) => Effect.Effect<A, E, R>\n>(2, (self, n) => core.suspend(() => repeatNLoop(self, n)))\n\n/* @internal */\nconst repeatNLoop = <A, E, R>(self: Effect.Effect<A, E, R>, n: number): Effect.Effect<A, E, R> =>\n  core.flatMap(self, (a) =>\n    n <= 0\n      ? core.succeed(a)\n      : core.zipRight(core.yieldNow(), repeatNLoop(self, n - 1)))\n\n/* @internal */\nexport const sandbox = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Cause.Cause<E>, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: core.fail,\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const setFiberRefs = (fiberRefs: FiberRefs.FiberRefs): Effect.Effect<void> =>\n  core.suspend(() => FiberRefs.setAll(fiberRefs))\n\n/* @internal */\nexport const sleep: (duration: Duration.DurationInput) => Effect.Effect<void> = Clock.sleep\n\n/* @internal */\nexport const succeedNone: Effect.Effect<Option.Option<never>> = core.succeed(Option.none())\n\n/* @internal */\nexport const succeedSome = <A>(value: A): Effect.Effect<Option.Option<A>> => core.succeed(Option.some(value))\n\n/* @internal */\nexport const summarized: {\n  <B, E2, R2, C>(\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[C, A], E2 | E, R2 | R>\n  <A, E, R, B, E2, R2, C>(\n    self: Effect.Effect<A, E, R>,\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect.Effect<[C, A], E2 | E, R2 | R>\n} = dual(\n  3,\n  <A, E, R, B, E2, R2, C>(\n    self: Effect.Effect<A, E, R>,\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect.Effect<[C, A], E2 | E, R2 | R> =>\n    core.flatMap(\n      summary,\n      (start) => core.flatMap(self, (value) => core.map(summary, (end) => [f(start, end), value]))\n    )\n)\n\n/* @internal */\nexport const tagMetrics = dual<\n  {\n    (key: string, value: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, string>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: string): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, string>): Effect.Effect<A, E, R>\n  }\n>((args) => core.isEffect(args[0]), function() {\n  return labelMetrics(\n    arguments[0],\n    typeof arguments[1] === \"string\"\n      ? [metricLabel.make(arguments[1], arguments[2])]\n      : Object.entries<string>(arguments[1]).map(([k, v]) => metricLabel.make(k, v))\n  )\n})\n\n/* @internal */\nexport const labelMetrics = dual<\n  (labels: Iterable<MetricLabel.MetricLabel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>) => Effect.Effect<A, E, R>\n>(\n  2,\n  (self, labels) => core.fiberRefLocallyWith(self, core.currentMetricLabels, (old) => Arr.union(old, labels))\n)\n\n/* @internal */\nexport const takeUntil: {\n  <A, R, E>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let effect: Effect.Effect<boolean, E, R> = core.succeed(false)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        effect = core.flatMap(effect, (bool) => {\n          if (bool) {\n            return core.succeed(true)\n          }\n          builder.push(a)\n          return predicate(a, index)\n        })\n      }\n      return core.map(effect, () => builder)\n    })\n)\n\n/* @internal */\nexport const takeWhile = dual<\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ) => Effect.Effect<Array<A>, E, R>\n>(\n  2,\n  <A, E, R>(elements: Iterable<A>, predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>) =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let taking: Effect.Effect<boolean, E, R> = core.succeed(true)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        taking = core.flatMap(taking, (taking) =>\n          pipe(\n            taking ? predicate(a, index) : core.succeed(false),\n            core.map((bool) => {\n              if (bool) {\n                builder.push(a)\n              }\n              return bool\n            })\n          ))\n      }\n      return core.map(taking, () => builder)\n    })\n)\n\n/* @internal */\nexport const tapBoth = dual<\n  <E, X, E2, R2, A, X1, E3, R3>(\n    options: {\n      readonly onFailure: (e: Types.NoInfer<E>) => Effect.Effect<X, E2, R2>\n      readonly onSuccess: (a: Types.NoInfer<A>) => Effect.Effect<X1, E3, R3>\n    }\n  ) => <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2 | E3, R | R2 | R3>,\n  <A, E, R, X, E2, R2, X1, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<X, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<X1, E3, R3>\n    }\n  ) => Effect.Effect<A, E | E2 | E3, R | R2 | R3>\n>(2, (self, { onFailure, onSuccess }) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const either = internalCause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\": {\n          return core.zipRight(onFailure(either.left as any), core.failCause(cause))\n        }\n        case \"Right\": {\n          return core.failCause(cause)\n        }\n      }\n    },\n    onSuccess: (a) => core.as(onSuccess(a as any), a)\n  }))\n\n/* @internal */\nexport const tapDefect = dual<\n  <X, E2, R2>(\n    f: (cause: Cause.Cause<never>) => Effect.Effect<X, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<never>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.catchAllCause(self, (cause) =>\n    Option.match(internalCause.keepDefects(cause), {\n      onNone: () => core.failCause(cause),\n      onSome: (a) => core.zipRight(f(a), core.failCause(cause))\n    })))\n\n/* @internal */\nexport const tapError = dual<\n  <E, X, E2, R2>(\n    f: (e: Types.NoInfer<E>) => Effect.Effect<X, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const either = internalCause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\":\n          return core.zipRight(f(either.left as any), core.failCause(cause))\n        case \"Right\":\n          return core.failCause(cause)\n      }\n    },\n    onSuccess: core.succeed\n  }))\n\n/* @internal */\nexport const tapErrorTag = dual<\n  <K extends (E extends { _tag: string } ? E[\"_tag\"] : never), E, A1, E1, R1>(\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R | R1>,\n  <A, E, R, K extends (E extends { _tag: string } ? E[\"_tag\"] : never), A1, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => Effect.Effect<A, E | E1, R | R1>\n>(3, (self, k, f) =>\n  tapError(self, (e) => {\n    if (Predicate.isTagged(e, k)) {\n      return f(e as any)\n    }\n    return core.void as any\n  }))\n\n/* @internal */\nexport const tapErrorCause = dual<\n  <E, X, E2, R2>(\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Effect.Effect<X, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => core.zipRight(f(cause), core.failCause(cause)),\n    onSuccess: core.succeed\n  }))\n\n/* @internal */\nexport const timed = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[duration: Duration.Duration, result: A], E, R> => timedWith(self, Clock.currentTimeNanos)\n\n/* @internal */\nexport const timedWith = dual<\n  <E1, R1>(\n    nanoseconds: Effect.Effect<bigint, E1, R1>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[Duration.Duration, A], E | E1, R | R1>,\n  <A, E, R, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    nanoseconds: Effect.Effect<bigint, E1, R1>\n  ) => Effect.Effect<[Duration.Duration, A], E | E1, R | R1>\n>(\n  2,\n  (self, nanos) => summarized(self, nanos, (start, end) => Duration.nanos(end - start))\n)\n\n/* @internal */\nexport const tracerWith: <A, E, R>(f: (tracer: Tracer.Tracer) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  Tracer.tracerWith\n\n/** @internal */\nexport const tracer: Effect.Effect<Tracer.Tracer> = tracerWith(core.succeed)\n\n/* @internal */\nexport const tryPromise: {\n  <A, E>(\n    options: {\n      readonly try: (signal: AbortSignal) => PromiseLike<A>\n      readonly catch: (error: unknown) => E\n    }\n  ): Effect.Effect<A, E>\n  <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect.Effect<A, Cause.UnknownException>\n} = <A, E>(\n  arg: ((signal: AbortSignal) => PromiseLike<A>) | {\n    readonly try: (signal: AbortSignal) => PromiseLike<A>\n    readonly catch: (error: unknown) => E\n  }\n): Effect.Effect<A, E | Cause.UnknownException> => {\n  let evaluate: (signal?: AbortSignal) => PromiseLike<A>\n  let catcher: ((error: unknown) => E) | undefined = undefined\n  if (typeof arg === \"function\") {\n    evaluate = arg as (signal?: AbortSignal) => PromiseLike<A>\n  } else {\n    evaluate = arg.try as (signal?: AbortSignal) => PromiseLike<A>\n    catcher = arg.catch\n  }\n  const fail = (e: unknown) =>\n    catcher\n      ? core.failSync(() => catcher(e))\n      : core.fail(new core.UnknownException(e, \"An unknown error occurred in Effect.tryPromise\"))\n\n  if (evaluate.length >= 1) {\n    return core.async((resolve, signal) => {\n      try {\n        evaluate(signal).then(\n          (a) => resolve(core.succeed(a)),\n          (e) => resolve(fail(e))\n        )\n      } catch (e) {\n        resolve(fail(e))\n      }\n    })\n  }\n\n  return core.async((resolve) => {\n    try {\n      evaluate()\n        .then(\n          (a) => resolve(core.succeed(a)),\n          (e) => resolve(fail(e))\n        )\n    } catch (e) {\n      resolve(fail(e))\n    }\n  })\n}\n\n/* @internal */\nexport const tryMap = dual<\n  <A, B, E1>(\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E1, R>,\n  <A, E, R, B, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ) => Effect.Effect<B, E | E1, R>\n>(2, (self, options) =>\n  core.flatMap(self, (a) =>\n    try_({\n      try: () => options.try(a),\n      catch: options.catch\n    })))\n\n/* @internal */\nexport const tryMapPromise = dual<\n  <A, B, E1>(\n    options: {\n      readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n      readonly catch: (error: unknown) => E1\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E1, R>,\n  <A, E, R, B, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n      readonly catch: (error: unknown) => E1\n    }\n  ) => Effect.Effect<B, E | E1, R>\n>(2, <A, E, R, B, E1>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n    readonly catch: (error: unknown) => E1\n  }\n) =>\n  core.flatMap(self, (a) =>\n    tryPromise({\n      try: options.try.length >= 1\n        ? (signal) => options.try(a, signal)\n        : () => (options.try as (a: A) => PromiseLike<B>)(a),\n      catch: options.catch\n    })))\n\n/* @internal */\nexport const unless = dual<\n  (condition: LazyArg<boolean>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, condition: LazyArg<boolean>) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, condition) =>\n  core.suspend(() =>\n    condition()\n      ? succeedNone\n      : asSome(self)\n  ))\n\n/* @internal */\nexport const unlessEffect = dual<\n  <E2, R2>(\n    condition: Effect.Effect<boolean, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E | E2, R | R2>,\n  <A, E, R, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    condition: Effect.Effect<boolean, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n>(2, (self, condition) => core.flatMap(condition, (b) => (b ? succeedNone : asSome(self))))\n\n/* @internal */\nexport const unsandbox = <A, E, R>(self: Effect.Effect<A, Cause.Cause<E>, R>) =>\n  mapErrorCause(self, internalCause.flatten)\n\n/* @internal */\nexport const updateFiberRefs = (\n  f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs\n): Effect.Effect<void> =>\n  core.withFiberRuntime((state) => {\n    state.setFiberRefs(f(state.id(), state.getFiberRefs()))\n    return core.void\n  })\n\n/* @internal */\nexport const updateService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | I>,\n  <A, E, R, I, S>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => Effect.Effect<A, E, R | I>\n>(3, <A, E, R, I, S>(\n  self: Effect.Effect<A, E, R>,\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n) =>\n  core.mapInputContext(self, (context) =>\n    Context.add(\n      context,\n      tag,\n      f(Context.unsafeGet(context, tag))\n    )) as Effect.Effect<A, E, R | I>)\n\n/* @internal */\nexport const when = dual<\n  (condition: LazyArg<boolean>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, condition: LazyArg<boolean>) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, condition) =>\n  core.suspend(() =>\n    condition()\n      ? core.map(self, Option.some)\n      : core.succeed(Option.none())\n  ))\n\n/* @internal */\nexport const whenFiberRef = dual<\n  <S>(\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[S, Option.Option<A>], E, R>,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) => Effect.Effect<[S, Option.Option<A>], E, R>\n>(\n  3,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) =>\n    core.flatMap(core.fiberRefGet(fiberRef), (s) =>\n      predicate(s)\n        ? core.map(self, (a) => [s, Option.some(a)])\n        : core.succeed<[S, Option.Option<A>]>([s, Option.none()]))\n)\n\n/* @internal */\nexport const whenRef = dual<\n  <S>(\n    ref: Ref.Ref<S>,\n    predicate: Predicate.Predicate<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[S, Option.Option<A>], E, R>,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    ref: Ref.Ref<S>,\n    predicate: Predicate.Predicate<S>\n  ) => Effect.Effect<[S, Option.Option<A>], E, R>\n>(\n  3,\n  <A, E, R, S>(self: Effect.Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate.Predicate<S>) =>\n    core.flatMap(Ref.get(ref), (s) =>\n      predicate(s)\n        ? core.map(self, (a) => [s, Option.some(a)])\n        : core.succeed<[S, Option.Option<A>]>([s, Option.none()]))\n)\n\n/* @internal */\nexport const withMetric = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>\n  ) => <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A extends In, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, metric) => metric(self))\n\n/** @internal */\nexport const serviceFunctionEffect = <T extends Effect.Effect<any, any, any>, Args extends Array<any>, A, E, R>(\n  getService: T,\n  f: (_: Effect.Effect.Success<T>) => (...args: Args) => Effect.Effect<A, E, R>\n) =>\n(...args: Args): Effect.Effect<A, E | Effect.Effect.Error<T>, R | Effect.Effect.Context<T>> =>\n  core.flatMap(getService, (a) => f(a)(...args))\n\n/** @internal */\nexport const serviceFunction = <T extends Effect.Effect<any, any, any>, Args extends Array<any>, A>(\n  getService: T,\n  f: (_: Effect.Effect.Success<T>) => (...args: Args) => A\n) =>\n(...args: Args): Effect.Effect<A, Effect.Effect.Error<T>, Effect.Effect.Context<T>> =>\n  core.map(getService, (a) => f(a)(...args))\n\n/** @internal */\nexport const serviceFunctions = <S, SE, SR>(\n  getService: Effect.Effect<S, SE, SR>\n): {\n  [k in keyof S as S[k] extends (...args: Array<any>) => Effect.Effect<any, any, any> ? k : never]: S[k] extends\n    (...args: infer Args) => Effect.Effect<infer A, infer E, infer R>\n    ? (...args: Args) => Effect.Effect<A, E | SE, R | SR>\n    : never\n} =>\n  new Proxy({} as any, {\n    get(_target: any, prop: any, _receiver) {\n      return (...args: Array<any>) => core.flatMap(getService, (s: any) => s[prop](...args))\n    }\n  })\n\n/** @internal */\nexport const serviceConstants = <S, SE, SR>(\n  getService: Effect.Effect<S, SE, SR>\n): {\n  [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect.Effect<infer A, infer E, infer R> ?\n    Effect.Effect<A, E | SE, R | SR> :\n    Effect.Effect<S[k], SE, SR>\n} =>\n  new Proxy({} as any, {\n    get(_target: any, prop: any, _receiver) {\n      return core.flatMap(getService, (s: any) => core.isEffect(s[prop]) ? s[prop] : core.succeed(s[prop]))\n    }\n  })\n\n/** @internal */\nexport const serviceMembers = <S, SE, SR>(getService: Effect.Effect<S, SE, SR>): {\n  functions: {\n    [k in keyof S as S[k] extends (...args: Array<any>) => Effect.Effect<any, any, any> ? k : never]: S[k] extends\n      (...args: infer Args) => Effect.Effect<infer A, infer E, infer R>\n      ? (...args: Args) => Effect.Effect<A, E | SE, R | SR>\n      : never\n  }\n  constants: {\n    [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect.Effect<infer A, infer E, infer R> ?\n      Effect.Effect<A, E | SE, R | SR> :\n      Effect.Effect<S[k], SE, SR>\n  }\n} => ({\n  functions: serviceFunctions(getService) as any,\n  constants: serviceConstants(getService)\n})\n\n/** @internal */\nexport const serviceOption = <I, S>(tag: Context.Tag<I, S>) => core.map(core.context<never>(), Context.getOption(tag))\n\n/** @internal */\nexport const serviceOptional = <I, S>(tag: Context.Tag<I, S>) =>\n  core.flatMap(core.context<never>(), Context.getOption(tag))\n\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const annotateCurrentSpan: {\n  (key: string, value: unknown): Effect.Effect<void>\n  (values: Record<string, unknown>): Effect.Effect<void>\n} = function(): Effect.Effect<void> {\n  const args = arguments\n  return ignore(core.flatMap(\n    currentSpan,\n    (span) =>\n      core.sync(() => {\n        if (typeof args[0] === \"string\") {\n          span.attribute(args[0], args[1])\n        } else {\n          for (const key in args[0]) {\n            span.attribute(key, args[0][key])\n          }\n        }\n      })\n  ))\n}\n\n/* @internal */\nexport const linkSpanCurrent: {\n  (span: Tracer.AnySpan, attributes?: Readonly<Record<string, unknown>> | undefined): Effect.Effect<void>\n  (links: ReadonlyArray<Tracer.SpanLink>): Effect.Effect<void>\n} = function(): Effect.Effect<void> {\n  const args = arguments\n  const links: ReadonlyArray<Tracer.SpanLink> = Array.isArray(args[0])\n    ? args[0]\n    : [{ _tag: \"SpanLink\", span: args[0], attributes: args[1] ?? {} }]\n  return ignore(core.flatMap(\n    currentSpan,\n    (span) => core.sync(() => span.addLinks(links))\n  ))\n}\n\n/* @internal */\nexport const annotateSpans = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: unknown): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, unknown>): Effect.Effect<A, E, R>\n  }\n>(\n  (args) => core.isEffect(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return core.fiberRefLocallyWith(\n      args[0] as Effect.Effect<A, E, R>,\n      core.currentTracerSpanAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/** @internal */\nexport const currentParentSpan: Effect.Effect<Tracer.AnySpan, Cause.NoSuchElementException> = serviceOptional(\n  internalTracer.spanTag\n)\n\n/** @internal */\nexport const currentSpan: Effect.Effect<Tracer.Span, Cause.NoSuchElementException> = core.flatMap(\n  core.context<never>(),\n  (context) => {\n    const span = context.unsafeMap.get(internalTracer.spanTag.key) as Tracer.AnySpan | undefined\n    return span !== undefined && span._tag === \"Span\"\n      ? core.succeed(span)\n      : core.fail(new core.NoSuchElementException())\n  }\n)\n\n/* @internal */\nexport const linkSpans = dual<\n  (\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ) => Effect.Effect<A, E, R>\n>(\n  (args) => core.isEffect(args[0]),\n  (self, span, attributes) =>\n    core.fiberRefLocallyWith(\n      self,\n      core.currentTracerSpanLinks,\n      Chunk.append(\n        {\n          _tag: \"SpanLink\",\n          span,\n          attributes: attributes ?? {}\n        } as const\n      )\n    )\n)\n\nconst bigint0 = BigInt(0)\n\nconst filterDisablePropagation: (self: Option.Option<Tracer.AnySpan>) => Option.Option<Tracer.AnySpan> = Option.flatMap(\n  (span) =>\n    Context.get(span.context, internalTracer.DisablePropagation)\n      ? span._tag === \"Span\" ? filterDisablePropagation(span.parent) : Option.none()\n      : Option.some(span)\n)\n\n/** @internal */\nexport const unsafeMakeSpan = <XA, XE>(\n  fiber: FiberRuntime<XA, XE>,\n  name: string,\n  options: Tracer.SpanOptions\n) => {\n  const disablePropagation = !fiber.getFiberRef(core.currentTracerEnabled) ||\n    (options.context && Context.get(options.context, internalTracer.DisablePropagation))\n  const context = fiber.getFiberRef(core.currentContext)\n  const parent = options.parent\n    ? Option.some(options.parent)\n    : options.root\n    ? Option.none()\n    : filterDisablePropagation(Context.getOption(context, internalTracer.spanTag))\n\n  let span: Tracer.Span\n\n  if (disablePropagation) {\n    span = core.noopSpan({\n      name,\n      parent,\n      context: Context.add(options.context ?? Context.empty(), internalTracer.DisablePropagation, true)\n    })\n  } else {\n    const services = fiber.getFiberRef(defaultServices.currentServices)\n\n    const tracer = Context.get(services, internalTracer.tracerTag)\n    const clock = Context.get(services, Clock.Clock)\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n\n    const fiberRefs = fiber.getFiberRefs()\n    const annotationsFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanAnnotations)\n    const linksFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanLinks)\n\n    const links = linksFromEnv._tag === \"Some\" ?\n      options.links !== undefined ?\n        [\n          ...Chunk.toReadonlyArray(linksFromEnv.value),\n          ...(options.links ?? [])\n        ] :\n        Chunk.toReadonlyArray(linksFromEnv.value) :\n      options.links ?? Arr.empty()\n\n    span = tracer.span(\n      name,\n      parent,\n      options.context ?? Context.empty(),\n      links,\n      timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0,\n      options.kind ?? \"internal\",\n      options\n    )\n\n    if (annotationsFromEnv._tag === \"Some\") {\n      HashMap.forEach(annotationsFromEnv.value, (value, key) => span.attribute(key, value))\n    }\n    if (options.attributes !== undefined) {\n      Object.entries(options.attributes).forEach(([k, v]) => span.attribute(k, v))\n    }\n  }\n\n  if (typeof options.captureStackTrace === \"function\") {\n    internalCause.spanToTrace.set(span, options.captureStackTrace)\n  }\n\n  return span\n}\n\n/** @internal */\nexport const makeSpan = (\n  name: string,\n  options?: Tracer.SpanOptions\n): Effect.Effect<Tracer.Span> => {\n  options = internalTracer.addSpanStackTrace(options)\n  return core.withFiberRuntime((fiber) => core.succeed(unsafeMakeSpan(fiber, name, options)))\n}\n\n/* @internal */\nexport const spanAnnotations: Effect.Effect<HashMap.HashMap<string, unknown>> = core\n  .fiberRefGet(core.currentTracerSpanAnnotations)\n\n/* @internal */\nexport const spanLinks: Effect.Effect<Chunk.Chunk<Tracer.SpanLink>> = core\n  .fiberRefGet(core.currentTracerSpanLinks)\n\n/** @internal */\nexport const endSpan = <A, E>(span: Tracer.Span, exit: Exit<A, E>, clock: Clock.Clock, timingEnabled: boolean) =>\n  core.sync(() => {\n    if (span.status._tag === \"Ended\") {\n      return\n    }\n    if (core.exitIsFailure(exit) && internalCause.spanToTrace.has(span)) {\n      // https://opentelemetry.io/docs/specs/semconv/registry/attributes/code/#code-stacktrace\n      span.attribute(\"code.stacktrace\", internalCause.spanToTrace.get(span)!())\n    }\n    span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, exit)\n  })\n\n/** @internal */\nexport const useSpan: {\n  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <A, E, R>(\n    name: string,\n    options: Tracer.SpanOptions,\n    evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = <A, E, R>(\n  name: string,\n  ...args: [evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>] | [\n    options: any,\n    evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>\n  ]\n) => {\n  const options = internalTracer.addSpanStackTrace(args.length === 1 ? undefined : args[0])\n  const evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R> = args[args.length - 1]\n\n  return core.withFiberRuntime<A, E, R>((fiber) => {\n    const span = unsafeMakeSpan(fiber, name, options)\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n    const clock = Context.get(fiber.getFiberRef(defaultServices.currentServices), clockTag)\n    return core.onExit(evaluate(span), (exit) => endSpan(span, exit, clock, timingEnabled))\n  })\n}\n\n/** @internal */\nexport const withParentSpan = dual<\n  (\n    span: Tracer.AnySpan\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, span: Tracer.AnySpan) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n>(2, (self, span) => provideService(self, internalTracer.spanTag, span))\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = internalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  if (dataFirst) {\n    const self = arguments[0]\n    return useSpan(name, options, (span) => withParentSpan(self, span))\n  }\n  return (self: Effect.Effect<any, any, any>) => useSpan(name, options, (span) => withParentSpan(self, span))\n} as any\n\nexport const functionWithSpan = <Args extends Array<any>, Ret extends Effect.Effect<any, any, any>>(\n  options: {\n    readonly body: (...args: Args) => Ret\n    readonly options: Effect.FunctionWithSpanOptions | ((...args: Args) => Effect.FunctionWithSpanOptions)\n    readonly captureStackTrace?: boolean | undefined\n  }\n): (...args: Args) => Unify<Ret> =>\n  (function(this: any) {\n    let captureStackTrace: LazyArg<string | undefined> | boolean = options.captureStackTrace ?? false\n    if (options.captureStackTrace !== false) {\n      const limit = Error.stackTraceLimit\n      Error.stackTraceLimit = 2\n      const error = new Error()\n      Error.stackTraceLimit = limit\n      let cache: false | string = false\n      captureStackTrace = () => {\n        if (cache !== false) {\n          return cache\n        }\n        if (error.stack) {\n          const stack = error.stack.trim().split(\"\\n\")\n          cache = stack.slice(2).join(\"\\n\").trim()\n          return cache\n        }\n      }\n    }\n    return core.suspend(() => {\n      const opts = typeof options.options === \"function\"\n        ? options.options.apply(null, arguments as any)\n        : options.options\n      return withSpan(\n        core.suspend(() => internalCall(() => options.body.apply(this, arguments as any))),\n        opts.name,\n        {\n          ...opts,\n          captureStackTrace\n        }\n      )\n    })\n  }) as any\n\n// -------------------------------------------------------------------------------------\n// optionality\n// -------------------------------------------------------------------------------------\n\n/* @internal */\nexport const fromNullable = <A>(value: A): Effect.Effect<NonNullable<A>, Cause.NoSuchElementException> =>\n  value == null ? core.fail(new core.NoSuchElementException()) : core.succeed(value as NonNullable<A>)\n\n/* @internal */\nexport const optionFromOptional = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R> =>\n  core.catchAll(\n    core.map(self, Option.some),\n    (error) =>\n      core.isNoSuchElementException(error) ?\n        succeedNone :\n        core.fail(error as Exclude<E, Cause.NoSuchElementException>)\n  )\n","import * as Arr from \"../../Array.js\"\nimport type * as Duration from \"../../Duration.js\"\nimport * as Equal from \"../../Equal.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Hash from \"../../Hash.js\"\nimport type * as MetricBoundaries from \"../../MetricBoundaries.js\"\nimport type * as MetricKey from \"../../MetricKey.js\"\nimport type * as MetricKeyType from \"../../MetricKeyType.js\"\nimport type * as MetricLabel from \"../../MetricLabel.js\"\nimport * as Option from \"../../Option.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport { hasProperty } from \"../../Predicate.js\"\nimport * as metricKeyType from \"./keyType.js\"\nimport * as metricLabel from \"./label.js\"\n\n/** @internal */\nconst MetricKeySymbolKey = \"effect/MetricKey\"\n\n/** @internal */\nexport const MetricKeyTypeId: MetricKey.MetricKeyTypeId = Symbol.for(\n  MetricKeySymbolKey\n) as MetricKey.MetricKeyTypeId\n\nconst metricKeyVariance = {\n  /* c8 ignore next */\n  _Type: (_: never) => _\n}\n\nconst arrayEquivilence = Arr.getEquivalence(Equal.equals)\n\n/** @internal */\nclass MetricKeyImpl<out Type extends MetricKeyType.MetricKeyType<any, any>> implements MetricKey.MetricKey<Type> {\n  readonly [MetricKeyTypeId] = metricKeyVariance\n  constructor(\n    readonly name: string,\n    readonly keyType: Type,\n    readonly description: Option.Option<string>,\n    readonly tags: ReadonlyArray<MetricLabel.MetricLabel> = []\n  ) {\n    this._hash = pipe(\n      Hash.string(this.name + this.description),\n      Hash.combine(Hash.hash(this.keyType)),\n      Hash.combine(Hash.array(this.tags))\n    )\n  }\n  readonly _hash: number;\n  [Hash.symbol](): number {\n    return this._hash\n  }\n  [Equal.symbol](u: unknown): boolean {\n    return isMetricKey(u) &&\n      this.name === u.name &&\n      Equal.equals(this.keyType, u.keyType) &&\n      Equal.equals(this.description, u.description) &&\n      arrayEquivilence(this.tags, u.tags)\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isMetricKey = (u: unknown): u is MetricKey.MetricKey<MetricKeyType.MetricKeyType<unknown, unknown>> =>\n  hasProperty(u, MetricKeyTypeId)\n\n/** @internal */\nexport const counter: {\n  (name: string, options?: {\n    readonly description?: string | undefined\n    readonly bigint?: false | undefined\n    readonly incremental?: boolean | undefined\n  }): MetricKey.MetricKey.Counter<number>\n  (name: string, options: {\n    readonly description?: string | undefined\n    readonly bigint: true\n    readonly incremental?: boolean | undefined\n  }): MetricKey.MetricKey.Counter<bigint>\n} = (name: string, options) =>\n  new MetricKeyImpl(\n    name,\n    metricKeyType.counter(options as any),\n    Option.fromNullable(options?.description)\n  )\n\n/** @internal */\nexport const frequency = (name: string, options?: {\n  readonly description?: string | undefined\n  readonly preregisteredWords?: ReadonlyArray<string> | undefined\n}): MetricKey.MetricKey.Frequency =>\n  new MetricKeyImpl(name, metricKeyType.frequency(options), Option.fromNullable(options?.description))\n\n/** @internal */\nexport const gauge: {\n  (name: string, options?: {\n    readonly description?: string | undefined\n    readonly bigint?: false | undefined\n  }): MetricKey.MetricKey.Gauge<number>\n  (name: string, options: {\n    readonly description?: string | undefined\n    readonly bigint: true\n  }): MetricKey.MetricKey.Gauge<bigint>\n} = (name, options) =>\n  new MetricKeyImpl(\n    name,\n    metricKeyType.gauge(options as any),\n    Option.fromNullable(options?.description)\n  )\n\n/** @internal */\nexport const histogram = (\n  name: string,\n  boundaries: MetricBoundaries.MetricBoundaries,\n  description?: string\n): MetricKey.MetricKey.Histogram =>\n  new MetricKeyImpl(\n    name,\n    metricKeyType.histogram(boundaries),\n    Option.fromNullable(description)\n  )\n\n/** @internal */\nexport const summary = (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n): MetricKey.MetricKey.Summary =>\n  new MetricKeyImpl(\n    options.name,\n    metricKeyType.summary(options),\n    Option.fromNullable(options.description)\n  )\n\n/** @internal */\nexport const tagged = dual<\n  (\n    key: string,\n    value: string\n  ) => <Type extends MetricKeyType.MetricKeyType<any, any>>(\n    self: MetricKey.MetricKey<Type>\n  ) => MetricKey.MetricKey<Type>,\n  <Type extends MetricKeyType.MetricKeyType<any, any>>(\n    self: MetricKey.MetricKey<Type>,\n    key: string,\n    value: string\n  ) => MetricKey.MetricKey<Type>\n>(3, (self, key, value) => taggedWithLabels(self, [metricLabel.make(key, value)]))\n\n/** @internal */\nexport const taggedWithLabels = dual<\n  (\n    extraTags: ReadonlyArray<MetricLabel.MetricLabel>\n  ) => <Type extends MetricKeyType.MetricKeyType<any, any>>(\n    self: MetricKey.MetricKey<Type>\n  ) => MetricKey.MetricKey<Type>,\n  <Type extends MetricKeyType.MetricKeyType<any, any>>(\n    self: MetricKey.MetricKey<Type>,\n    extraTags: ReadonlyArray<MetricLabel.MetricLabel>\n  ) => MetricKey.MetricKey<Type>\n>(2, (self, extraTags) =>\n  extraTags.length === 0\n    ? self\n    : new MetricKeyImpl(self.name, self.keyType, self.description, Arr.union(self.tags, extraTags)))\n","/**\n * @since 2.0.0\n */\nimport type { NonEmptyArray } from \"./Array.js\"\nimport * as Equal from \"./Equal.js\"\nimport { dual } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/MutableHashMap\") as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MutableHashMap<out K, out V> extends Iterable<[K, V]>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n  /** @internal */\n  readonly referential: Map<K, V>\n  /** @internal */\n  readonly buckets: Map<number, NonEmptyArray<readonly [K & Equal.Equal, V]>>\n  /** @internal */\n  bucketsSize: number\n}\n\nconst MutableHashMapProto: Omit<MutableHashMap<unknown, unknown>, \"referential\" | \"buckets\" | \"bucketsSize\"> = {\n  [TypeId]: TypeId,\n  [Symbol.iterator](this: MutableHashMap<unknown, unknown>): Iterator<[unknown, unknown]> {\n    return new MutableHashMapIterator(this)\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"MutableHashMap\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nclass MutableHashMapIterator<K, V> implements IterableIterator<[K, V]> {\n  readonly referentialIterator: Iterator<[K, V]>\n  bucketIterator: Iterator<[K, V]> | undefined\n\n  constructor(readonly self: MutableHashMap<K, V>) {\n    this.referentialIterator = self.referential[Symbol.iterator]()\n  }\n  next(): IteratorResult<[K, V]> {\n    if (this.bucketIterator !== undefined) {\n      return this.bucketIterator.next()\n    }\n    const result = this.referentialIterator.next()\n    if (result.done) {\n      this.bucketIterator = new BucketIterator(this.self.buckets.values())\n      return this.next()\n    }\n    return result\n  }\n\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return new MutableHashMapIterator(this.self)\n  }\n}\n\nclass BucketIterator<K, V> implements Iterator<[K, V]> {\n  constructor(readonly backing: Iterator<NonEmptyArray<readonly [K, V]>>) {}\n  currentBucket: Iterator<readonly [K, V]> | undefined\n  next(): IteratorResult<[K, V]> {\n    if (this.currentBucket === undefined) {\n      const result = this.backing.next()\n      if (result.done) {\n        return result\n      }\n      this.currentBucket = result.value[Symbol.iterator]()\n    }\n    const result = this.currentBucket.next()\n    if (result.done) {\n      this.currentBucket = undefined\n      return this.next()\n    }\n    return result as IteratorResult<[K, V]>\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = <K = never, V = never>(): MutableHashMap<K, V> => {\n  const self = Object.create(MutableHashMapProto)\n  self.referential = new Map()\n  self.buckets = new Map()\n  self.bucketsSize = 0\n  return self\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Entries extends Array<readonly [any, any]>>(\n  ...entries: Entries\n) => MutableHashMap<\n  Entries[number] extends readonly [infer K, any] ? K : never,\n  Entries[number] extends readonly [any, infer V] ? V : never\n> = (...entries) => fromIterable(entries)\n\n/**\n * Creates a new `MutableHashMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = <K, V>(entries: Iterable<readonly [K, V]>): MutableHashMap<K, V> => {\n  const self = empty<K, V>()\n  for (const [key, value] of entries) {\n    set(self, key, value)\n  }\n  return self\n}\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const get: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: MutableHashMap<K, V>) => Option.Option<V>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K): Option.Option<V>\n} = dual<\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K) => <V>(self: MutableHashMap<K, V>) => Option.Option<V>,\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K) => Option.Option<V>\n>(2, <K, V>(self: MutableHashMap<K, V>, key: K): Option.Option<V> => {\n  if (Equal.isEqual(key) === false) {\n    return self.referential.has(key) ? Option.some(self.referential.get(key)!) : Option.none()\n  }\n\n  const hash = key[Hash.symbol]()\n  const bucket = self.buckets.get(hash)\n  if (bucket === undefined) {\n    return Option.none()\n  }\n\n  return getFromBucket(self, bucket, key)\n})\n\n/**\n * @since 3.8.0\n * @category elements\n */\nexport const keys = <K, V>(self: MutableHashMap<K, V>): Array<K> => {\n  const keys = Array.from(self.referential.keys())\n  for (const bucket of self.buckets.values()) {\n    for (let i = 0, len = bucket.length; i < len; i++) {\n      keys.push(bucket[i][0])\n    }\n  }\n  return keys\n}\n\n/**\n * @since 3.8.0\n * @category elements\n */\nexport const values = <K, V>(self: MutableHashMap<K, V>): Array<V> => {\n  const values = Array.from(self.referential.values())\n  for (const bucket of self.buckets.values()) {\n    for (let i = 0, len = bucket.length; i < len; i++) {\n      values.push(bucket[i][1])\n    }\n  }\n  return values\n}\n\nconst getFromBucket = <K, V>(\n  self: MutableHashMap<K, V>,\n  bucket: NonEmptyArray<readonly [K & Equal.Equal, V]>,\n  key: K & Equal.Equal,\n  remove = false\n): Option.Option<V> => {\n  for (let i = 0, len = bucket.length; i < len; i++) {\n    if (key[Equal.symbol](bucket[i][0])) {\n      const value = bucket[i][1]\n      if (remove) {\n        bucket.splice(i, 1)\n        self.bucketsSize--\n      }\n      return Option.some(value)\n    }\n  }\n\n  return Option.none()\n}\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: MutableHashMap<K, V>) => boolean\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K): boolean\n} = dual<\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K) => <V>(self: MutableHashMap<K, V>) => boolean,\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K) => boolean\n>(2, (self, key) => Option.isSome(get(self, key)))\n\n/**\n * @since 2.0.0\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(key: K, value: V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K, value: V): MutableHashMap<K, V>\n} = dual<\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(key: K, value: V) => (self: MutableHashMap<K, V>) => MutableHashMap<K, V>,\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K, value: V) => MutableHashMap<K, V>\n>(3, <K, V>(self: MutableHashMap<K, V>, key: K, value: V) => {\n  if (Equal.isEqual(key) === false) {\n    self.referential.set(key, value)\n    return self\n  }\n\n  const hash = key[Hash.symbol]()\n  const bucket = self.buckets.get(hash)\n  if (bucket === undefined) {\n    self.buckets.set(hash, [[key, value]])\n    self.bucketsSize++\n    return self\n  }\n\n  removeFromBucket(self, bucket, key)\n  bucket.push([key, value])\n  self.bucketsSize++\n  return self\n})\n\nconst removeFromBucket = <K, V>(\n  self: MutableHashMap<K, V>,\n  bucket: NonEmptyArray<readonly [K & Equal.Equal, V]>,\n  key: K & Equal.Equal\n) => {\n  for (let i = 0, len = bucket.length; i < len; i++) {\n    if (key[Equal.symbol](bucket[i][0])) {\n      bucket.splice(i, 1)\n      self.bucketsSize--\n      return\n    }\n  }\n}\n\n/**\n * Updates the value of the specified key within the `MutableHashMap` if it exists.\n *\n * @since 2.0.0\n */\nexport const modify: {\n  /**\n   * Updates the value of the specified key within the `MutableHashMap` if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>\n  /**\n   * Updates the value of the specified key within the `MutableHashMap` if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>\n} = dual<\n  /**\n   * Updates the value of the specified key within the `MutableHashMap` if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, f: (v: V) => V) => (self: MutableHashMap<K, V>) => MutableHashMap<K, V>,\n  /**\n   * Updates the value of the specified key within the `MutableHashMap` if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V) => MutableHashMap<K, V>\n>(3, <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V) => {\n  if (Equal.isEqual(key) === false) {\n    if (self.referential.has(key)) {\n      self.referential.set(key, f(self.referential.get(key)!))\n    }\n    return self\n  }\n\n  const hash = key[Hash.symbol]()\n  const bucket = self.buckets.get(hash)\n  if (bucket === undefined) {\n    return self\n  }\n\n  const value = getFromBucket(self, bucket, key, true)\n  if (Option.isNone(value)) {\n    return self\n  }\n  bucket.push([key, f(value.value)])\n  self.bucketsSize++\n  return self\n})\n\n/**\n * Set or remove the specified key in the `MutableHashMap` using the specified\n * update function.\n *\n * @since 2.0.0\n */\nexport const modifyAt: {\n  /**\n   * Set or remove the specified key in the `MutableHashMap` using the specified\n   * update function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>\n  /**\n   * Set or remove the specified key in the `MutableHashMap` using the specified\n   * update function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(\n    self: MutableHashMap<K, V>,\n    key: K,\n    f: (value: Option.Option<V>) => Option.Option<V>\n  ): MutableHashMap<K, V>\n} = dual<\n  /**\n   * Set or remove the specified key in the `MutableHashMap` using the specified\n   * update function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>) => (self: MutableHashMap<K, V>) => MutableHashMap<K, V>,\n  /**\n   * Set or remove the specified key in the `MutableHashMap` using the specified\n   * update function.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(\n    self: MutableHashMap<K, V>,\n    key: K,\n    f: (value: Option.Option<V>) => Option.Option<V>\n  ) => MutableHashMap<K, V>\n>(3, (self, key, f) => {\n  if (Equal.isEqual(key) === false) {\n    const result = f(get(self, key))\n    if (Option.isSome(result)) {\n      set(self, key, result.value)\n    } else {\n      remove(self, key)\n    }\n    return self\n  }\n\n  const hash = key[Hash.symbol]()\n  const bucket = self.buckets.get(hash)\n  if (bucket === undefined) {\n    const result = f(Option.none())\n    return Option.isSome(result) ? set(self, key, result.value) : self\n  }\n\n  const result = f(getFromBucket(self, bucket, key, true))\n  if (Option.isNone(result)) {\n    if (bucket.length === 0) {\n      self.buckets.delete(hash)\n    }\n    return self\n  }\n  bucket.push([key, result.value])\n  self.bucketsSize++\n  return self\n})\n\n/**\n * @since 2.0.0\n */\nexport const remove: {\n  /**\n   * @since 2.0.0\n   */\n  <K>(key: K): <V>(self: MutableHashMap<K, V>) => MutableHashMap<K, V>\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K): MutableHashMap<K, V>\n} = dual<\n  /**\n   * @since 2.0.0\n   */\n  <K>(key: K) => <V>(self: MutableHashMap<K, V>) => MutableHashMap<K, V>,\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, key: K) => MutableHashMap<K, V>\n>(2, <K, V>(self: MutableHashMap<K, V>, key: K) => {\n  if (Equal.isEqual(key) === false) {\n    self.referential.delete(key)\n    return self\n  }\n\n  const hash = key[Hash.symbol]()\n  const bucket = self.buckets.get(hash)\n  if (bucket === undefined) {\n    return self\n  }\n  removeFromBucket(self, bucket, key)\n  if (bucket.length === 0) {\n    self.buckets.delete(hash)\n  }\n  return self\n})\n\n/**\n * @since 2.0.0\n */\nexport const clear = <K, V>(self: MutableHashMap<K, V>) => {\n  self.referential.clear()\n  self.buckets.clear()\n  self.bucketsSize = 0\n  return self\n}\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const size = <K, V>(self: MutableHashMap<K, V>): number => {\n  return self.referential.size + self.bucketsSize\n}\n\n/**\n * @since 2.0.0\n */\nexport const isEmpty = <K, V>(self: MutableHashMap<K, V>): boolean => size(self) === 0\n\n/**\n * @since 2.0.0\n */\nexport const forEach: {\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(f: (value: V, key: K) => void): (self: MutableHashMap<K, V>) => void\n  /**\n   * @since 2.0.0\n   */\n  <K, V>(self: MutableHashMap<K, V>, f: (value: V, key: K) => void): void\n} = dual(2, <K, V>(self: MutableHashMap<K, V>, f: (value: V, key: K) => void) => {\n  self.referential.forEach(f)\n  for (const bucket of self.buckets.values()) {\n    for (const [key, value] of bucket) {\n      f(value, key)\n    }\n  }\n})\n","import * as Arr from \"../../Array.js\"\nimport * as Equal from \"../../Equal.js\"\nimport { pipe } from \"../../Function.js\"\nimport * as Hash from \"../../Hash.js\"\nimport type * as MetricState from \"../../MetricState.js\"\nimport type * as Option from \"../../Option.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport { hasProperty } from \"../../Predicate.js\"\n\n/** @internal */\nconst MetricStateSymbolKey = \"effect/MetricState\"\n\n/** @internal */\nexport const MetricStateTypeId: MetricState.MetricStateTypeId = Symbol.for(\n  MetricStateSymbolKey\n) as MetricState.MetricStateTypeId\n\n/** @internal */\nconst CounterStateSymbolKey = \"effect/MetricState/Counter\"\n\n/** @internal */\nexport const CounterStateTypeId: MetricState.CounterStateTypeId = Symbol.for(\n  CounterStateSymbolKey\n) as MetricState.CounterStateTypeId\n\n/** @internal */\nconst FrequencyStateSymbolKey = \"effect/MetricState/Frequency\"\n\n/** @internal */\nexport const FrequencyStateTypeId: MetricState.FrequencyStateTypeId = Symbol.for(\n  FrequencyStateSymbolKey\n) as MetricState.FrequencyStateTypeId\n\n/** @internal */\nconst GaugeStateSymbolKey = \"effect/MetricState/Gauge\"\n\n/** @internal */\nexport const GaugeStateTypeId: MetricState.GaugeStateTypeId = Symbol.for(\n  GaugeStateSymbolKey\n) as MetricState.GaugeStateTypeId\n\n/** @internal */\nconst HistogramStateSymbolKey = \"effect/MetricState/Histogram\"\n\n/** @internal */\nexport const HistogramStateTypeId: MetricState.HistogramStateTypeId = Symbol.for(\n  HistogramStateSymbolKey\n) as MetricState.HistogramStateTypeId\n\n/** @internal */\nconst SummaryStateSymbolKey = \"effect/MetricState/Summary\"\n\n/** @internal */\nexport const SummaryStateTypeId: MetricState.SummaryStateTypeId = Symbol.for(\n  SummaryStateSymbolKey\n) as MetricState.SummaryStateTypeId\n\nconst metricStateVariance = {\n  /* c8 ignore next */\n  _A: (_: unknown) => _\n}\n\n/** @internal */\nclass CounterState<A extends (number | bigint)> implements MetricState.MetricState.Counter<A> {\n  readonly [MetricStateTypeId] = metricStateVariance\n  readonly [CounterStateTypeId]: MetricState.CounterStateTypeId = CounterStateTypeId\n  constructor(readonly count: A) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(CounterStateSymbolKey),\n      Hash.combine(Hash.hash(this.count)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isCounterState(that) && this.count === that.count\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst arrayEquals = Arr.getEquivalence(Equal.equals)\n\n/** @internal */\nclass FrequencyState implements MetricState.MetricState.Frequency {\n  readonly [MetricStateTypeId] = metricStateVariance\n  readonly [FrequencyStateTypeId]: MetricState.FrequencyStateTypeId = FrequencyStateTypeId\n  constructor(readonly occurrences: ReadonlyMap<string, number>) {}\n  _hash: number | undefined;\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.string(FrequencyStateSymbolKey),\n      Hash.combine(Hash.array(Arr.fromIterable(this.occurrences.entries()))),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isFrequencyState(that) && arrayEquals(\n      Arr.fromIterable(this.occurrences.entries()),\n      Arr.fromIterable(that.occurrences.entries())\n    )\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nclass GaugeState<A extends (number | bigint)> implements MetricState.MetricState.Gauge<A> {\n  readonly [MetricStateTypeId] = metricStateVariance\n  readonly [GaugeStateTypeId]: MetricState.GaugeStateTypeId = GaugeStateTypeId\n  constructor(readonly value: A) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(GaugeStateSymbolKey),\n      Hash.combine(Hash.hash(this.value)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](u: unknown): boolean {\n    return isGaugeState(u) && this.value === u.value\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport class HistogramState implements MetricState.MetricState.Histogram {\n  readonly [MetricStateTypeId] = metricStateVariance\n  readonly [HistogramStateTypeId]: MetricState.HistogramStateTypeId = HistogramStateTypeId\n  constructor(\n    readonly buckets: ReadonlyArray<readonly [number, number]>,\n    readonly count: number,\n    readonly min: number,\n    readonly max: number,\n    readonly sum: number\n  ) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(HistogramStateSymbolKey),\n      Hash.combine(Hash.hash(this.buckets)),\n      Hash.combine(Hash.hash(this.count)),\n      Hash.combine(Hash.hash(this.min)),\n      Hash.combine(Hash.hash(this.max)),\n      Hash.combine(Hash.hash(this.sum)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isHistogramState(that) &&\n      Equal.equals(this.buckets, that.buckets) &&\n      this.count === that.count &&\n      this.min === that.min &&\n      this.max === that.max &&\n      this.sum === that.sum\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport class SummaryState implements MetricState.MetricState.Summary {\n  readonly [MetricStateTypeId] = metricStateVariance\n  readonly [SummaryStateTypeId]: MetricState.SummaryStateTypeId = SummaryStateTypeId\n  constructor(\n    readonly error: number,\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>,\n    readonly count: number,\n    readonly min: number,\n    readonly max: number,\n    readonly sum: number\n  ) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(SummaryStateSymbolKey),\n      Hash.combine(Hash.hash(this.error)),\n      Hash.combine(Hash.hash(this.quantiles)),\n      Hash.combine(Hash.hash(this.count)),\n      Hash.combine(Hash.hash(this.min)),\n      Hash.combine(Hash.hash(this.max)),\n      Hash.combine(Hash.hash(this.sum)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isSummaryState(that) &&\n      this.error === that.error &&\n      Equal.equals(this.quantiles, that.quantiles) &&\n      this.count === that.count &&\n      this.min === that.min &&\n      this.max === that.max &&\n      this.sum === that.sum\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const counter: {\n  (count: number): MetricState.MetricState.Counter<number>\n  (count: bigint): MetricState.MetricState.Counter<bigint>\n} = (count) => new CounterState(count) as any\n\n/** @internal */\nexport const frequency = (occurrences: ReadonlyMap<string, number>): MetricState.MetricState.Frequency => {\n  return new FrequencyState(occurrences)\n}\n\n/** @internal */\nexport const gauge: {\n  (count: number): MetricState.MetricState.Gauge<number>\n  (count: bigint): MetricState.MetricState.Gauge<bigint>\n} = (count) => new GaugeState(count) as any\n\n/** @internal */\nexport const histogram = (\n  options: {\n    readonly buckets: ReadonlyArray<readonly [number, number]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n): MetricState.MetricState.Histogram =>\n  new HistogramState(\n    options.buckets,\n    options.count,\n    options.min,\n    options.max,\n    options.sum\n  )\n\n/** @internal */\nexport const summary = (\n  options: {\n    readonly error: number\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n): MetricState.MetricState.Summary =>\n  new SummaryState(\n    options.error,\n    options.quantiles,\n    options.count,\n    options.min,\n    options.max,\n    options.sum\n  )\n\n/** @internal */\nexport const isMetricState = (u: unknown): u is MetricState.MetricState.Counter<number | bigint> =>\n  hasProperty(u, MetricStateTypeId)\n\n/** @internal */\nexport const isCounterState = (u: unknown): u is MetricState.MetricState.Counter<number | bigint> =>\n  hasProperty(u, CounterStateTypeId)\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isFrequencyState = (u: unknown): u is MetricState.MetricState.Frequency =>\n  hasProperty(u, FrequencyStateTypeId)\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isGaugeState = (u: unknown): u is MetricState.MetricState.Gauge<number | bigint> =>\n  hasProperty(u, GaugeStateTypeId)\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHistogramState = (u: unknown): u is MetricState.MetricState.Histogram =>\n  hasProperty(u, HistogramStateTypeId)\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSummaryState = (u: unknown): u is MetricState.MetricState.Summary => hasProperty(u, SummaryStateTypeId)\n","import * as Arr from \"../../Array.js\"\nimport * as Duration from \"../../Duration.js\"\nimport type { LazyArg } from \"../../Function.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport type * as MetricHook from \"../../MetricHook.js\"\nimport type * as MetricKey from \"../../MetricKey.js\"\nimport type * as MetricState from \"../../MetricState.js\"\nimport * as number from \"../../Number.js\"\nimport * as Option from \"../../Option.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport * as metricState from \"./state.js\"\n\n/** @internal */\nconst MetricHookSymbolKey = \"effect/MetricHook\"\n\n/** @internal */\nexport const MetricHookTypeId: MetricHook.MetricHookTypeId = Symbol.for(\n  MetricHookSymbolKey\n) as MetricHook.MetricHookTypeId\n\nconst metricHookVariance = {\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _Out: (_: never) => _\n}\n\n/** @internal */\nexport const make = <In, Out>(\n  options: {\n    readonly get: LazyArg<Out>\n    readonly update: (input: In) => void\n    readonly modify: (input: In) => void\n  }\n): MetricHook.MetricHook<In, Out> => ({\n  [MetricHookTypeId]: metricHookVariance,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  ...options\n})\n\n/** @internal */\nexport const onModify = dual<\n  <In, Out>(f: (input: In) => void) => (self: MetricHook.MetricHook<In, Out>) => MetricHook.MetricHook<In, Out>,\n  <In, Out>(self: MetricHook.MetricHook<In, Out>, f: (input: In) => void) => MetricHook.MetricHook<In, Out>\n>(2, (self, f) => ({\n  [MetricHookTypeId]: metricHookVariance,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  get: self.get,\n  update: self.update,\n  modify: (input) => {\n    self.modify(input)\n    return f(input)\n  }\n}))\n\n/** @internal */\nexport const onUpdate = dual<\n  <In, Out>(f: (input: In) => void) => (self: MetricHook.MetricHook<In, Out>) => MetricHook.MetricHook<In, Out>,\n  <In, Out>(self: MetricHook.MetricHook<In, Out>, f: (input: In) => void) => MetricHook.MetricHook<In, Out>\n>(2, (self, f) => ({\n  [MetricHookTypeId]: metricHookVariance,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  get: self.get,\n  update: (input) => {\n    self.update(input)\n    return f(input)\n  },\n  modify: self.modify\n}))\n\nconst bigint0 = BigInt(0)\n\n/** @internal */\nexport const counter = <A extends (number | bigint)>(\n  key: MetricKey.MetricKey.Counter<A>\n): MetricHook.MetricHook.Counter<A> => {\n  let sum: A = key.keyType.bigint ? bigint0 as A : 0 as A\n  const canUpdate = key.keyType.incremental\n    ? key.keyType.bigint\n      ? (value: A) => value >= bigint0\n      : (value: A) => value >= 0\n    : (_value: A) => true\n  const update = (value: A) => {\n    if (canUpdate(value)) {\n      sum = (sum as any) + value\n    }\n  }\n  return make({\n    get: () => metricState.counter(sum as number) as unknown as MetricState.MetricState.Counter<A>,\n    update,\n    modify: update\n  })\n}\n\n/** @internal */\nexport const frequency = (key: MetricKey.MetricKey.Frequency): MetricHook.MetricHook.Frequency => {\n  const values = new Map<string, number>()\n  for (const word of key.keyType.preregisteredWords) {\n    values.set(word, 0)\n  }\n  const update = (word: string) => {\n    const slotCount = values.get(word) ?? 0\n    values.set(word, slotCount + 1)\n  }\n  return make({\n    get: () => metricState.frequency(values),\n    update,\n    modify: update\n  })\n}\n\n/** @internal */\nexport const gauge: {\n  (key: MetricKey.MetricKey.Gauge<number>, startAt: number): MetricHook.MetricHook.Gauge<number>\n  (key: MetricKey.MetricKey.Gauge<bigint>, startAt: bigint): MetricHook.MetricHook.Gauge<bigint>\n} = <A extends (number | bigint)>(\n  _key: MetricKey.MetricKey.Gauge<A>,\n  startAt: A\n): MetricHook.MetricHook.Gauge<A> => {\n  let value = startAt\n  return make({\n    get: () => metricState.gauge(value as number) as unknown as MetricState.MetricState.Gauge<A>,\n    update: (v) => {\n      value = v\n    },\n    modify: (v) => {\n      value = (value as any) + v\n    }\n  })\n}\n\n/** @internal */\nexport const histogram = (key: MetricKey.MetricKey.Histogram): MetricHook.MetricHook.Histogram => {\n  const bounds = key.keyType.boundaries.values\n  const size = bounds.length\n  const values = new Uint32Array(size + 1)\n  // NOTE: while 64-bit floating point precision shoule be enough for any\n  // practical histogram boundary values, there is still a small chance that\n  // precision will be lost with very large / very small numbers. If we find\n  // that is the case, a more complex approach storing the histogram boundary\n  // values as a tuple of `[original: string, numeric: number]` may be warranted\n  const boundaries = new Float64Array(size)\n  let count = 0\n  let sum = 0\n  let min = Number.MAX_VALUE\n  let max = Number.MIN_VALUE\n\n  pipe(\n    bounds,\n    Arr.sort(number.Order),\n    Arr.map((n, i) => {\n      boundaries[i] = n\n    })\n  )\n\n  // Insert the value into the right bucket with a binary search\n  const update = (value: number) => {\n    let from = 0\n    let to = size\n    while (from !== to) {\n      const mid = Math.floor(from + (to - from) / 2)\n      const boundary = boundaries[mid]\n      if (value <= boundary) {\n        to = mid\n      } else {\n        from = mid\n      }\n      // The special case when to / from have a distance of one\n      if (to === from + 1) {\n        if (value <= boundaries[from]) {\n          to = from\n        } else {\n          from = to\n        }\n      }\n    }\n    values[from] = values[from]! + 1\n    count = count + 1\n    sum = sum + value\n    if (value < min) {\n      min = value\n    }\n    if (value > max) {\n      max = value\n    }\n  }\n\n  const getBuckets = (): ReadonlyArray<readonly [number, number]> => {\n    const builder: Array<readonly [number, number]> = Arr.allocate(size) as any\n    let cumulated = 0\n    for (let i = 0; i < size; i++) {\n      const boundary = boundaries[i]\n      const value = values[i]\n      cumulated = cumulated + value\n      builder[i] = [boundary, cumulated]\n    }\n    return builder\n  }\n\n  return make({\n    get: () =>\n      metricState.histogram({\n        buckets: getBuckets(),\n        count,\n        min,\n        max,\n        sum\n      }),\n    update,\n    modify: update\n  })\n}\n\n/** @internal */\nexport const summary = (key: MetricKey.MetricKey.Summary): MetricHook.MetricHook.Summary => {\n  const { error, maxAge, maxSize, quantiles } = key.keyType\n  const sortedQuantiles = pipe(quantiles, Arr.sort(number.Order))\n  const values = Arr.allocate<readonly [number, number]>(maxSize)\n\n  let head = 0\n  let count = 0\n  let sum = 0\n  let min = 0\n  let max = 0\n\n  // Just before the snapshot we filter out all values older than maxAge\n  const snapshot = (now: number): ReadonlyArray<readonly [number, Option.Option<number>]> => {\n    const builder: Array<number> = []\n    // If the buffer is not full yet it contains valid items at the 0..last\n    // indices and null values at the rest of the positions.\n    //\n    // If the buffer is already full then all elements contains a valid\n    // measurement with timestamp.\n    //\n    // At any given point in time we can enumerate all the non-null elements in\n    // the buffer and filter them by timestamp to get a valid view of a time\n    // window.\n    //\n    // The order does not matter because it gets sorted before passing to\n    // `calculateQuantiles`.\n    let i = 0\n    while (i !== maxSize - 1) {\n      const item = values[i]\n      if (item != null) {\n        const [t, v] = item\n        const age = Duration.millis(now - t)\n        if (Duration.greaterThanOrEqualTo(age, Duration.zero) && Duration.lessThanOrEqualTo(age, maxAge)) {\n          builder.push(v)\n        }\n      }\n      i = i + 1\n    }\n    return calculateQuantiles(\n      error,\n      sortedQuantiles,\n      Arr.sort(builder, number.Order)\n    )\n  }\n\n  const observe = (value: number, timestamp: number) => {\n    if (maxSize > 0) {\n      head = head + 1\n      const target = head % maxSize\n      values[target] = [timestamp, value] as const\n    }\n\n    min = count === 0 ? value : Math.min(min, value)\n    max = count === 0 ? value : Math.max(max, value)\n\n    count = count + 1\n    sum = sum + value\n  }\n\n  return make({\n    get: () =>\n      metricState.summary({\n        error,\n        quantiles: snapshot(Date.now()),\n        count,\n        min,\n        max,\n        sum\n      }),\n    update: ([value, timestamp]) => observe(value, timestamp),\n    modify: ([value, timestamp]) => observe(value, timestamp)\n  })\n}\n\n/** @internal */\ninterface ResolvedQuantile {\n  /**\n   * The quantile that shall be resolved.\n   */\n  readonly quantile: number\n  /**\n   * `Some<number>` if a value for the quantile could be found, otherwise\n   * `None`.\n   */\n  readonly value: Option.Option<number>\n  /**\n   * How many samples have been consumed prior to this quantile.\n   */\n  readonly consumed: number\n  /**\n   * The rest of the samples after the quantile has been resolved.\n   */\n  readonly rest: ReadonlyArray<number>\n}\n\n/** @internal */\nconst calculateQuantiles = (\n  error: number,\n  sortedQuantiles: ReadonlyArray<number>,\n  sortedSamples: ReadonlyArray<number>\n): ReadonlyArray<readonly [number, Option.Option<number>]> => {\n  // The number of samples examined\n  const sampleCount = sortedSamples.length\n  if (!Arr.isNonEmptyReadonlyArray(sortedQuantiles)) {\n    return Arr.empty()\n  }\n  const head = sortedQuantiles[0]\n  const tail = sortedQuantiles.slice(1)\n  const resolvedHead = resolveQuantile(\n    error,\n    sampleCount,\n    Option.none(),\n    0,\n    head,\n    sortedSamples\n  )\n  const resolved = Arr.of(resolvedHead)\n  tail.forEach((quantile) => {\n    resolved.push(\n      resolveQuantile(\n        error,\n        sampleCount,\n        resolvedHead.value,\n        resolvedHead.consumed,\n        quantile,\n        resolvedHead.rest\n      )\n    )\n  })\n  return Arr.map(resolved, (rq) => [rq.quantile, rq.value] as const)\n}\n\n/** @internal */\nconst resolveQuantile = (\n  error: number,\n  sampleCount: number,\n  current: Option.Option<number>,\n  consumed: number,\n  quantile: number,\n  rest: ReadonlyArray<number>\n): ResolvedQuantile => {\n  let error_1 = error\n  let sampleCount_1 = sampleCount\n  let current_1 = current\n  let consumed_1 = consumed\n  let quantile_1 = quantile\n  let rest_1 = rest\n  let error_2 = error\n  let sampleCount_2 = sampleCount\n  let current_2 = current\n  let consumed_2 = consumed\n  let quantile_2 = quantile\n  let rest_2 = rest\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    // If the remaining list of samples is empty, there is nothing more to resolve\n    if (!Arr.isNonEmptyReadonlyArray(rest_1)) {\n      return {\n        quantile: quantile_1,\n        value: Option.none(),\n        consumed: consumed_1,\n        rest: []\n      }\n    }\n    // If the quantile is the 100% quantile, we can take the maximum of all the\n    // remaining values as the result\n    if (quantile_1 === 1) {\n      return {\n        quantile: quantile_1,\n        value: Option.some(Arr.lastNonEmpty(rest_1)),\n        consumed: consumed_1 + rest_1.length,\n        rest: []\n      }\n    }\n    // Split into two chunks - the first chunk contains all elements of the same\n    // value as the chunk head\n    const headValue = Arr.headNonEmpty(rest_1) // Get head value since rest_1 is non-empty\n    const sameHead = Arr.span(rest_1, (n) => n === headValue)\n    // How many elements do we want to accept for this quantile\n    const desired = quantile_1 * sampleCount_1\n    // The error margin\n    const allowedError = (error_1 / 2) * desired\n    // Taking into account the elements consumed from the samples so far and the\n    // number of same elements at the beginning of the chunk, calculate the number\n    // of elements we would have if we selected the current head as result\n    const candConsumed = consumed_1 + sameHead[0].length\n    const candError = Math.abs(candConsumed - desired)\n    // If we haven't got enough elements yet, recurse\n    if (candConsumed < desired - allowedError) {\n      error_2 = error_1\n      sampleCount_2 = sampleCount_1\n      current_2 = Arr.head(rest_1)\n      consumed_2 = candConsumed\n      quantile_2 = quantile_1\n      rest_2 = sameHead[1]\n      error_1 = error_2\n      sampleCount_1 = sampleCount_2\n      current_1 = current_2\n      consumed_1 = consumed_2\n      quantile_1 = quantile_2\n      rest_1 = rest_2\n      continue\n    }\n    // If consuming this chunk leads to too many elements (rank is too high)\n    if (candConsumed > desired + allowedError) {\n      const valueToReturn = Option.isNone(current_1)\n        ? Option.some(headValue)\n        : current_1\n      return {\n        quantile: quantile_1,\n        value: valueToReturn,\n        consumed: consumed_1,\n        rest: rest_1\n      }\n    }\n    // If we are in the target interval, select the current head and hand back the leftover after dropping all elements\n    // from the sample chunk that are equal to the current head\n    switch (current_1._tag) {\n      case \"None\": {\n        error_2 = error_1\n        sampleCount_2 = sampleCount_1\n        current_2 = Arr.head(rest_1)\n        consumed_2 = candConsumed\n        quantile_2 = quantile_1\n        rest_2 = sameHead[1]\n        error_1 = error_2\n        sampleCount_1 = sampleCount_2\n        current_1 = current_2\n        consumed_1 = consumed_2\n        quantile_1 = quantile_2\n        rest_1 = rest_2\n        continue\n      }\n      case \"Some\": {\n        const prevError = Math.abs(desired - current_1.value)\n        if (candError < prevError) {\n          error_2 = error_1\n          sampleCount_2 = sampleCount_1\n          current_2 = Arr.head(rest_1)\n          consumed_2 = candConsumed\n          quantile_2 = quantile_1\n          rest_2 = sameHead[1]\n          error_1 = error_2\n          sampleCount_1 = sampleCount_2\n          current_1 = current_2\n          consumed_1 = consumed_2\n          quantile_1 = quantile_2\n          rest_1 = rest_2\n          continue\n        }\n        return {\n          quantile: quantile_1,\n          value: Option.some(current_1.value),\n          consumed: consumed_1,\n          rest: rest_1\n        }\n      }\n    }\n  }\n  throw new Error(\n    \"BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues\"\n  )\n}\n","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as core from \"./internal/core.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { NoInfer } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * An `Exit<A, E = never>` describes the result of a executing an `Effect` workflow.\n *\n * There are two possible values for an `Exit<A, E>`:\n *   - `Exit.Success` contain a success value of type `A`\n *   - `Exit.Failure` contains a failure `Cause` of type `E`\n *\n * @since 2.0.0\n * @category models\n */\nexport type Exit<A, E = never> = Success<A, E> | Failure<A, E>\n\n/**\n * Represents a failed `Effect` workflow containing the `Cause` of the failure\n * of type `E`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Failure<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Failure\"\n  readonly _op: \"Failure\"\n  readonly cause: Cause.Cause<E>\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: Cause.Cause<E>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface ExitUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Exit?: () => A[Unify.typeSymbol] extends Exit<infer A0, infer E0> | infer _ ? Exit<A0, E0> : never\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface ExitUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * Represents a successful `Effect` workflow and containing the returned value\n * of type `A`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Success<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {\n  readonly _tag: \"Success\"\n  readonly _op: \"Success\"\n  readonly value: A\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: ExitUnify<this>\n  [Unify.ignoreSymbol]?: ExitUnifyIgnore\n  /** @internal */\n  readonly effect_instruction_i0: A\n}\n\n/**\n * Returns `true` if the specified value is an `Exit`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isExit: (u: unknown) => u is Exit<unknown, unknown> = core.exitIsExit\n\n/**\n * Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E> = core.exitIsFailure\n\n/**\n * Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E> = core.exitIsSuccess\n\n/**\n * Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\n * the failure was due to interruption, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isInterrupted: <A, E>(self: Exit<A, E>) => boolean = core.exitIsInterrupted\n\n/**\n * Maps the `Success` value of the specified exit to the provided constant\n * value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const as: {\n  /**\n   * Maps the `Success` value of the specified exit to the provided constant\n   * value.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>\n  /**\n   * Maps the `Success` value of the specified exit to the provided constant\n   * value.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>\n} = core.exitAs\n\n/**\n * Maps the `Success` value of the specified exit to a void.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E> = core.exitAsVoid\n\n/**\n * Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>> = core.exitCauseOption\n\n/**\n * Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If\n * the provided iterable contains no elements, `None` will be returned.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const all: <A, E>(\n  exits: Iterable<Exit<A, E>>,\n  options?: { readonly parallel?: boolean | undefined } | undefined\n) => Option.Option<Exit<Array<A>, E>> = core.exitCollectAll\n\n/**\n * Constructs a new `Exit.Failure` from the specified unrecoverable defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const die: (defect: unknown) => Exit<never> = core.exitDie\n\n/**\n * Executes the predicate on the value of the specified exit if it is a\n * `Success`, otherwise returns `false`.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const exists: {\n  /**\n   * Executes the predicate on the value of the specified exit if it is a\n   * `Success`, otherwise returns `false`.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>\n  /**\n   * Executes the predicate on the value of the specified exit if it is a\n   * `Success`, otherwise returns `false`.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean\n  /**\n   * Executes the predicate on the value of the specified exit if it is a\n   * `Success`, otherwise returns `false`.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>\n  /**\n   * Executes the predicate on the value of the specified exit if it is a\n   * `Success`, otherwise returns `false`.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean\n} = core.exitExists\n\n/**\n * Constructs a new `Exit.Failure` from the specified recoverable error of type\n * `E`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fail: <E>(error: E) => Exit<never, E> = core.exitFail\n\n/**\n * Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E> = core.exitFailCause\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, A2, E2>(f: (a: A) => Exit<A2, E2>): <E>(self: Exit<A, E>) => Exit<A2, E2 | E>\n  /**\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, E2, A2>(self: Exit<A, E>, f: (a: A) => Exit<A2, E2>): Exit<A2, E | E2>\n} = core.exitFlatMap\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMapEffect: {\n  /**\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, A2, E2, R>(f: (a: A) => Effect.Effect<Exit<A2, E>, E2, R>): (self: Exit<A, E>) => Effect.Effect<Exit<A2, E>, E2, R>\n  /**\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, A2, E2, R>(self: Exit<A, E>, f: (a: A) => Effect.Effect<Exit<A2, E>, E2, R>): Effect.Effect<Exit<A2, E>, E2, R>\n} = core.exitFlatMapEffect\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten: <A, E, E2>(self: Exit<Exit<A, E>, E2>) => Exit<A, E | E2> = core.exitFlatten\n\n/**\n * @since 2.0.0\n * @category traversing\n */\nexport const forEachEffect: {\n  /**\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, B, E2, R>(f: (a: A) => Effect.Effect<B, E2, R>): <E>(self: Exit<A, E>) => Effect.Effect<Exit<B, E2 | E>, never, R>\n  /**\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, E, B, E2, R>(self: Exit<A, E>, f: (a: A) => Effect.Effect<B, E2, R>): Effect.Effect<Exit<B, E | E2>, never, R>\n} = core.exitForEachEffect\n\n/**\n * Converts an `Either<R, L>` into an `Exit<R, L>`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L> = core.exitFromEither\n\n/**\n * Converts an `Option<A>` into an `Exit<void, A>`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const fromOption: <A>(option: Option.Option<A>) => Exit<A, void> = core.exitFromOption\n\n/**\n * Returns the `A` if specified exit is a `Success`, otherwise returns the\n * alternate `A` value computed from the specified function which receives the\n * `Cause<E>` of the exit `Failure`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOrElse: {\n  /**\n   * Returns the `A` if specified exit is a `Success`, otherwise returns the\n   * alternate `A` value computed from the specified function which receives the\n   * `Cause<E>` of the exit `Failure`.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A\n  /**\n   * Returns the `A` if specified exit is a `Success`, otherwise returns the\n   * alternate `A` value computed from the specified function which receives the\n   * `Cause<E>` of the exit `Failure`.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2\n} = core.exitGetOrElse\n\n/**\n * Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\n * the `Fiber` running an `Effect` workflow was terminated due to interruption.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const interrupt: (fiberId: FiberId.FiberId) => Exit<never> = core.exitInterrupt\n\n/**\n * Maps over the `Success` value of the specified exit using the provided\n * function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Maps over the `Success` value of the specified exit using the provided\n   * function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>\n  /**\n   * Maps over the `Success` value of the specified exit using the provided\n   * function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>\n} = core.exitMap\n\n/**\n * Maps over the `Success` and `Failure` cases of the specified exit using the\n * provided functions.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapBoth: {\n  /**\n   * Maps over the `Success` and `Failure` cases of the specified exit using the\n   * provided functions.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, A, E2, A2>(\n   options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): (self: Exit<A, E>) => Exit<A2, E2>\n  /**\n   * Maps over the `Success` and `Failure` cases of the specified exit using the\n   * provided functions.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, E2, A2>(\n   self: Exit<A, E>,\n   options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Exit<A2, E2>\n} = core.exitMapBoth\n\n/**\n * Maps over the error contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapError: {\n  /**\n   * Maps over the error contained in the `Failure` of the specified exit using\n   * the provided function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>\n  /**\n   * Maps over the error contained in the `Failure` of the specified exit using\n   * the provided function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>\n} = core.exitMapError\n\n/**\n * Maps over the `Cause` contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapErrorCause: {\n  /**\n   * Maps over the `Cause` contained in the `Failure` of the specified exit using\n   * the provided function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>\n  /**\n   * Maps over the `Cause` contained in the `Failure` of the specified exit using\n   * the provided function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>\n} = core.exitMapErrorCause\n\n/**\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <E, A, Z1, Z2>(\n   options: { readonly onFailure: (cause: Cause.Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2 }\n  ): (self: Exit<A, E>) => Z1 | Z2\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, E, Z1, Z2>(\n   self: Exit<A, E>,\n   options: { readonly onFailure: (cause: Cause.Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2 }\n  ): Z1 | Z2\n} = core.exitMatch\n\n/**\n * @since 2.0.0\n * @category folding\n */\nexport const matchEffect: {\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <E, A2, E2, R, A, A3, E3, R2>(\n   options: {\n     readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n     readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n   }\n  ): (self: Exit<A, E>) => Effect.Effect<A2 | A3, E2 | E3, R | R2>\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, E, A2, E2, R, A3, E3, R2>(\n   self: Exit<A, E>,\n   options: {\n     readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<A2, E2, R>\n     readonly onSuccess: (a: A) => Effect.Effect<A3, E3, R2>\n   }\n  ): Effect.Effect<A2 | A3, E2 | E3, R | R2>\n} = core.exitMatchEffect\n\n/**\n * Constructs a new `Exit.Success` containing the specified value of type `A`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <A>(value: A) => Exit<A> = core.exitSucceed\n\nconst void_: Exit<void> = core.exitVoid\nexport {\n  /**\n   * Represents an `Exit` which succeeds with `undefined`.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  void_ as void\n}\n\n/**\n * Sequentially zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Sequentially zips the this result with the specified result or else returns\n   * the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>\n  /**\n   * Sequentially zips the this result with the specified result or else returns\n   * the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>\n} = core.exitZip\n\n/**\n * Sequentially zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft: {\n  /**\n   * Sequentially zips the this result with the specified result discarding the\n   * second element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>\n  /**\n   * Sequentially zips the this result with the specified result discarding the\n   * second element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>\n} = core.exitZipLeft\n\n/**\n * Sequentially zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight: {\n  /**\n   * Sequentially zips the this result with the specified result discarding the\n   * first element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>\n  /**\n   * Sequentially zips the this result with the specified result discarding the\n   * first element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>\n} = core.exitZipRight\n\n/**\n * Parallelly zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipPar: {\n  /**\n   * Parallelly zips the this result with the specified result or else returns\n   * the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>\n  /**\n   * Parallelly zips the this result with the specified result or else returns\n   * the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>\n} = core.exitZipPar\n\n/**\n * Parallelly zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipParLeft: {\n  /**\n   * Parallelly zips the this result with the specified result discarding the\n   * second element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>\n  /**\n   * Parallelly zips the this result with the specified result discarding the\n   * second element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>\n} = core.exitZipParLeft\n\n/**\n * Parallelly zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipParRight: {\n  /**\n   * Parallelly zips the this result with the specified result discarding the\n   * first element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>\n  /**\n   * Parallelly zips the this result with the specified result discarding the\n   * first element of the tuple or else returns the failed `Cause<E | E2>`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>\n} = core.exitZipParRight\n\n/**\n * Zips this exit together with that exit using the specified combination\n * functions.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith: {\n  /**\n   * Zips this exit together with that exit using the specified combination\n   * functions.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <B, E2, A, C, E>(\n   that: Exit<B, E2>,\n   options: {\n     readonly onSuccess: (a: A, b: B) => C\n     readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>\n   }\n  ): (self: Exit<A, E>) => Exit<C, any>\n  /**\n   * Zips this exit together with that exit using the specified combination\n   * functions.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, B, E2, C>(\n   self: Exit<A, E>,\n   that: Exit<B, E2>,\n   options: {\n     readonly onSuccess: (a: A, b: B) => C\n     readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>\n   }\n  ): Exit<C, E | E2>\n} = core.exitZipWith\n","import * as Arr from \"../Array.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constVoid, dual, identity, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport type * as Metric from \"../Metric.js\"\nimport type * as MetricBoundaries from \"../MetricBoundaries.js\"\nimport type * as MetricHook from \"../MetricHook.js\"\nimport type * as MetricKey from \"../MetricKey.js\"\nimport type * as MetricKeyType from \"../MetricKeyType.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport type * as MetricPair from \"../MetricPair.js\"\nimport type * as MetricRegistry from \"../MetricRegistry.js\"\nimport type * as MetricState from \"../MetricState.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Cause from \"./cause.js\"\nimport * as effect_ from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as metricBoundaries from \"./metric/boundaries.js\"\nimport * as metricKey from \"./metric/key.js\"\nimport * as metricKeyType from \"./metric/keyType.js\"\nimport * as metricLabel from \"./metric/label.js\"\nimport * as metricRegistry from \"./metric/registry.js\"\n\n/** @internal */\nconst MetricSymbolKey = \"effect/Metric\"\n\n/** @internal */\nexport const MetricTypeId: Metric.MetricTypeId = Symbol.for(\n  MetricSymbolKey\n) as Metric.MetricTypeId\n\nconst metricVariance = {\n  /* c8 ignore next */\n  _Type: (_: any) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _Out: (_: never) => _\n}\n\n/** @internal */\nexport const globalMetricRegistry: MetricRegistry.MetricRegistry = globalValue(\n  Symbol.for(\"effect/Metric/globalMetricRegistry\"),\n  () => metricRegistry.make()\n)\n\n/** @internal */\nexport const make: Metric.MetricApply = function<Type, In, Out>(\n  keyType: Type,\n  unsafeUpdate: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void,\n  unsafeValue: (extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => Out,\n  unsafeModify: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void\n): Metric.Metric<Type, In, Out> {\n  const metric: Metric.Metric<Type, In, Out> = Object.assign(\n    <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n      core.tap(effect, (a) => update(metric, a)),\n    {\n      [MetricTypeId]: metricVariance,\n      keyType,\n      unsafeUpdate,\n      unsafeValue,\n      unsafeModify,\n      register() {\n        this.unsafeValue([])\n        return this as any\n      },\n      pipe() {\n        return pipeArguments(this, arguments)\n      }\n    } as const\n  )\n  return metric\n}\n\n/** @internal */\nexport const mapInput = dual<\n  <In, In2>(f: (input: In2) => In) => <Type, Out>(self: Metric.Metric<Type, In, Out>) => Metric.Metric<Type, In2, Out>,\n  <Type, In, Out, In2>(self: Metric.Metric<Type, In, Out>, f: (input: In2) => In) => Metric.Metric<Type, In2, Out>\n>(2, (self, f) =>\n  make(\n    self.keyType,\n    (input, extraTags) => self.unsafeUpdate(f(input), extraTags),\n    self.unsafeValue,\n    (input, extraTags) => self.unsafeModify(f(input), extraTags)\n  ))\n\n/** @internal */\nexport const counter: {\n  (name: string, options?: {\n    readonly description?: string | undefined\n    readonly bigint?: false | undefined\n    readonly incremental?: boolean | undefined\n  }): Metric.Metric.Counter<number>\n  (name: string, options: {\n    readonly description?: string | undefined\n    readonly bigint: true\n    readonly incremental?: boolean | undefined\n  }): Metric.Metric.Counter<bigint>\n} = (name, options) => fromMetricKey(metricKey.counter(name, options as any)) as any\n\n/** @internal */\nexport const frequency = (name: string, options?: {\n  readonly description?: string | undefined\n  readonly preregisteredWords?: ReadonlyArray<string> | undefined\n}): Metric.Metric.Frequency<string> => fromMetricKey(metricKey.frequency(name, options))\n\n/** @internal */\nexport const withConstantInput = dual<\n  <In>(input: In) => <Type, Out>(self: Metric.Metric<Type, In, Out>) => Metric.Metric<Type, unknown, Out>,\n  <Type, In, Out>(self: Metric.Metric<Type, In, Out>, input: In) => Metric.Metric<Type, unknown, Out>\n>(2, (self, input) => mapInput(self, () => input))\n\n/** @internal */\nexport const fromMetricKey = <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  key: MetricKey.MetricKey<Type>\n): Metric.Metric<\n  Type,\n  MetricKeyType.MetricKeyType.InType<Type>,\n  MetricKeyType.MetricKeyType.OutType<Type>\n> => {\n  let untaggedHook:\n    | MetricHook.MetricHook<\n      MetricKeyType.MetricKeyType.InType<Type>,\n      MetricKeyType.MetricKeyType.OutType<Type>\n    >\n    | undefined\n  const hookCache = new WeakMap<ReadonlyArray<MetricLabel.MetricLabel>, MetricHook.MetricHook<any, any>>()\n\n  const hook = (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricHook.MetricHook<\n    MetricKeyType.MetricKeyType.InType<Type>,\n    MetricKeyType.MetricKeyType.OutType<Type>\n  > => {\n    if (extraTags.length === 0) {\n      if (untaggedHook !== undefined) {\n        return untaggedHook\n      }\n      untaggedHook = globalMetricRegistry.get(key)\n      return untaggedHook\n    }\n\n    let hook = hookCache.get(extraTags)\n    if (hook !== undefined) {\n      return hook\n    }\n    hook = globalMetricRegistry.get(metricKey.taggedWithLabels(key, extraTags))\n    hookCache.set(extraTags, hook)\n    return hook\n  }\n\n  return make(\n    key.keyType,\n    (input, extraTags) => hook(extraTags).update(input),\n    (extraTags) => hook(extraTags).get(),\n    (input, extraTags) => hook(extraTags).modify(input)\n  )\n}\n\n/** @internal */\nexport const gauge: {\n  (name: string, options?: {\n    readonly description?: string | undefined\n    readonly bigint?: false | undefined\n  }): Metric.Metric.Gauge<number>\n  (name: string, options: {\n    readonly description?: string | undefined\n    readonly bigint: true\n  }): Metric.Metric.Gauge<bigint>\n} = (name, options) => fromMetricKey(metricKey.gauge(name, options as any)) as any\n\n/** @internal */\nexport const histogram = (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) =>\n  fromMetricKey(metricKey.histogram(name, boundaries, description))\n\n/* @internal */\nexport const increment = (\n  self:\n    | Metric.Metric.Counter<number>\n    | Metric.Metric.Counter<bigint>\n    | Metric.Metric.Gauge<number>\n    | Metric.Metric.Gauge<bigint>\n): Effect.Effect<void> =>\n  metricKeyType.isCounterKey(self.keyType)\n    ? update(self as Metric.Metric.Counter<number>, self.keyType.bigint ? BigInt(1) as any : 1)\n    : modify(self as Metric.Metric.Gauge<number>, self.keyType.bigint ? BigInt(1) as any : 1)\n\n/* @internal */\nexport const incrementBy = dual<\n  {\n    (amount: number): (self: Metric.Metric.Counter<number> | Metric.Metric.Counter<number>) => Effect.Effect<void>\n    (amount: bigint): (self: Metric.Metric.Counter<bigint> | Metric.Metric.Gauge<bigint>) => Effect.Effect<void>\n  },\n  {\n    (self: Metric.Metric.Counter<number> | Metric.Metric.Gauge<number>, amount: number): Effect.Effect<void>\n    (self: Metric.Metric.Counter<bigint> | Metric.Metric.Gauge<bigint>, amount: bigint): Effect.Effect<void>\n  }\n>(2, (self, amount) =>\n  metricKeyType.isCounterKey(self.keyType)\n    ? update(self as any, amount)\n    : modify(self as any, amount))\n\n/** @internal */\nexport const map = dual<\n  <Out, Out2>(f: (out: Out) => Out2) => <Type, In>(self: Metric.Metric<Type, In, Out>) => Metric.Metric<Type, In, Out2>,\n  <Type, In, Out, Out2>(self: Metric.Metric<Type, In, Out>, f: (out: Out) => Out2) => Metric.Metric<Type, In, Out2>\n>(2, (self, f) =>\n  make(\n    self.keyType,\n    self.unsafeUpdate,\n    (extraTags) => f(self.unsafeValue(extraTags)),\n    self.unsafeModify\n  ))\n\n/** @internal */\nexport const mapType = dual<\n  <Type, Type2>(\n    f: (type: Type) => Type2\n  ) => <In, Out>(\n    self: Metric.Metric<Type, In, Out>\n  ) => Metric.Metric<Type2, In, Out>,\n  <Type, In, Out, Type2>(\n    self: Metric.Metric<Type, In, Out>,\n    f: (type: Type) => Type2\n  ) => Metric.Metric<Type2, In, Out>\n>(2, (self, f) =>\n  make(\n    f(self.keyType),\n    self.unsafeUpdate,\n    self.unsafeValue,\n    self.unsafeModify\n  ))\n\n/** @internal */\nexport const modify = dual<\n  <In>(input: In) => <Type, Out>(self: Metric.Metric<Type, In, Out>) => Effect.Effect<void>,\n  <Type, In, Out>(self: Metric.Metric<Type, In, Out>, input: In) => Effect.Effect<void>\n>(2, (self, input) =>\n  core.fiberRefGetWith(\n    core.currentMetricLabels,\n    (tags) => core.sync(() => self.unsafeModify(input, tags))\n  ))\n\n/* @internal */\nexport const set = dual<\n  {\n    (value: number): (self: Metric.Metric.Gauge<number>) => Effect.Effect<void>\n    (value: bigint): (self: Metric.Metric.Gauge<bigint>) => Effect.Effect<void>\n  },\n  {\n    (self: Metric.Metric.Gauge<number>, value: number): Effect.Effect<void>\n    (self: Metric.Metric.Gauge<bigint>, value: bigint): Effect.Effect<void>\n  }\n>(2, (self, value) => update(self as any, value))\n\n/** @internal */\nexport const succeed = <Out>(out: Out): Metric.Metric<void, unknown, Out> =>\n  make(void 0 as void, constVoid, () => out, constVoid)\n\n/** @internal */\nexport const sync = <Out>(evaluate: LazyArg<Out>): Metric.Metric<void, unknown, Out> =>\n  make(void 0 as void, constVoid, evaluate, constVoid)\n\n/** @internal */\nexport const summary = (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n): Metric.Metric.Summary<number> => withNow(summaryTimestamp(options))\n\n/** @internal */\nexport const summaryTimestamp = (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n): Metric.Metric.Summary<readonly [value: number, timestamp: number]> => fromMetricKey(metricKey.summary(options))\n\n/** @internal */\nexport const tagged = dual<\n  <Type, In, Out>(key: string, value: string) => (self: Metric.Metric<Type, In, Out>) => Metric.Metric<Type, In, Out>,\n  <Type, In, Out>(self: Metric.Metric<Type, In, Out>, key: string, value: string) => Metric.Metric<Type, In, Out>\n>(3, (self, key, value) => taggedWithLabels(self, [metricLabel.make(key, value)]))\n\n/** @internal */\nexport const taggedWithLabelsInput = dual<\n  <In>(\n    f: (input: In) => Iterable<MetricLabel.MetricLabel>\n  ) => <Type, Out>(self: Metric.Metric<Type, In, Out>) => Metric.Metric<Type, In, void>,\n  <Type, In, Out>(\n    self: Metric.Metric<Type, In, Out>,\n    f: (input: In) => Iterable<MetricLabel.MetricLabel>\n  ) => Metric.Metric<Type, In, void>\n>(2, (self, f) =>\n  map(\n    make(\n      self.keyType,\n      (input, extraTags) =>\n        self.unsafeUpdate(\n          input,\n          Arr.union(f(input), extraTags)\n        ),\n      self.unsafeValue,\n      (input, extraTags) =>\n        self.unsafeModify(\n          input,\n          Arr.union(f(input), extraTags)\n        )\n    ),\n    constVoid\n  ))\n\n/** @internal */\nexport const taggedWithLabels = dual<\n  <Type, In, Out>(\n    extraTags: Iterable<MetricLabel.MetricLabel>\n  ) => (self: Metric.Metric<Type, In, Out>) => Metric.Metric<Type, In, Out>,\n  <Type, In, Out>(\n    self: Metric.Metric<Type, In, Out>,\n    extraTags: Iterable<MetricLabel.MetricLabel>\n  ) => Metric.Metric<Type, In, Out>\n>(2, (self, extraTags) => {\n  return make(\n    self.keyType,\n    (input, extraTags1) => self.unsafeUpdate(input, Arr.union(extraTags, extraTags1)),\n    (extraTags1) => self.unsafeValue(Arr.union(extraTags, extraTags1)),\n    (input, extraTags1) => self.unsafeModify(input, Arr.union(extraTags, extraTags1))\n  )\n})\n\n/** @internal */\nexport const timer = (name: string, description?: string): Metric.Metric<\n  MetricKeyType.MetricKeyType.Histogram,\n  Duration.Duration,\n  MetricState.MetricState.Histogram\n> => {\n  const boundaries = metricBoundaries.exponential({\n    start: 0.5,\n    factor: 2,\n    count: 35\n  })\n  const base = pipe(histogram(name, boundaries, description), tagged(\"time_unit\", \"milliseconds\"))\n  return mapInput(base, Duration.toMillis)\n}\n\n/** @internal */\nexport const timerWithBoundaries = (\n  name: string,\n  boundaries: ReadonlyArray<number>,\n  description?: string\n): Metric.Metric<\n  MetricKeyType.MetricKeyType.Histogram,\n  Duration.Duration,\n  MetricState.MetricState.Histogram\n> => {\n  const base = pipe(\n    histogram(name, metricBoundaries.fromIterable(boundaries), description),\n    tagged(\"time_unit\", \"milliseconds\")\n  )\n  return mapInput(base, Duration.toMillis)\n}\n\n/* @internal */\nexport const trackAll = dual<\n  <In>(\n    input: In\n  ) => <Type, Out>(\n    self: Metric.Metric<Type, In, Out>\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <Type, In, Out>(\n    self: Metric.Metric<Type, In, Out>,\n    input: In\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n>(2, (self, input) => (effect) =>\n  core.matchCauseEffect(effect, {\n    onFailure: (cause) => core.zipRight(update(self, input), core.failCause(cause)),\n    onSuccess: (value) => core.zipRight(update(self, input), core.succeed(value))\n  }))\n\n/* @internal */\nexport const trackDefect = dual<\n  <Type, Out>(\n    metric: Metric.Metric<Type, unknown, Out>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R, Type, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, unknown, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, metric) => trackDefectWith(self, metric, identity))\n\n/* @internal */\nexport const trackDefectWith = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>,\n    f: (defect: unknown) => In\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>,\n    f: (defect: unknown) => In\n  ) => Effect.Effect<A, E, R>\n>(3, (self, metric, f) => {\n  const updater = (defect: unknown) => update(metric, f(defect))\n  return effect_.tapDefect(self, (cause) => core.forEachSequentialDiscard(Cause.defects(cause), updater))\n})\n\n/* @internal */\nexport const trackDuration = dual<\n  <Type, Out>(\n    metric: Metric.Metric<Type, Duration.Duration, Out>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R, Type, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, Duration.Duration, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, metric) => trackDurationWith(self, metric, identity))\n\n/* @internal */\nexport const trackDurationWith = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>,\n    f: (duration: Duration.Duration) => In\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>,\n    f: (duration: Duration.Duration) => In\n  ) => Effect.Effect<A, E, R>\n>(3, (self, metric, f) =>\n  Clock.clockWith((clock) => {\n    const startTime = clock.unsafeCurrentTimeNanos()\n    return core.tap(self, (_) => {\n      const endTime = clock.unsafeCurrentTimeNanos()\n      const duration = Duration.nanos(endTime - startTime)\n      return update(metric, f(duration))\n    })\n  }))\n\n/* @internal */\nexport const trackError = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>\n  ) => <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E extends In, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, <A, E extends In, R, Type, In, Out>(\n  self: Effect.Effect<A, E, R>,\n  metric: Metric.Metric<Type, In, Out>\n) => trackErrorWith(self, metric, (a: In) => a))\n\n/* @internal */\nexport const trackErrorWith = dual<\n  <Type, In, Out, In2>(\n    metric: Metric.Metric<Type, In, Out>,\n    f: (error: In2) => In\n  ) => <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E extends In2, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>,\n    f: (error: In2) => In\n  ) => Effect.Effect<A, E, R>\n>(3, <A, E extends In2, R, Type, In, Out, In2>(\n  self: Effect.Effect<A, E, R>,\n  metric: Metric.Metric<Type, In, Out>,\n  f: (error: In2) => In\n) => {\n  const updater = (error: E): Effect.Effect<void> => update(metric, f(error))\n  return effect_.tapError(self, updater)\n})\n\n/* @internal */\nexport const trackSuccess = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>\n  ) => <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A extends In, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, <A extends In, E, R, Type, In, Out>(\n  self: Effect.Effect<A, E, R>,\n  metric: Metric.Metric<Type, In, Out>\n) => trackSuccessWith(self, metric, (a: In) => a))\n\n/* @internal */\nexport const trackSuccessWith = dual<\n  <Type, In, Out, In2>(\n    metric: Metric.Metric<Type, In, Out>,\n    f: (value: In2) => In\n  ) => <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A extends In2, E, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>,\n    f: (value: In2) => In\n  ) => Effect.Effect<A, E, R>\n>(3, <A extends In2, E, R, Type, In, Out, In2>(\n  self: Effect.Effect<A, E, R>,\n  metric: Metric.Metric<Type, In, Out>,\n  f: (value: In2) => In\n) => {\n  const updater = (value: A): Effect.Effect<void> => update(metric, f(value))\n  return core.tap(self, updater)\n})\n\n/* @internal */\nexport const update = dual<\n  <In>(input: In) => <Type, Out>(self: Metric.Metric<Type, In, Out>) => Effect.Effect<void>,\n  <Type, In, Out>(self: Metric.Metric<Type, In, Out>, input: In) => Effect.Effect<void>\n>(2, (self, input) =>\n  core.fiberRefGetWith(\n    core.currentMetricLabels,\n    (tags) => core.sync(() => self.unsafeUpdate(input, tags))\n  ))\n\n/* @internal */\nexport const value = <Type, In, Out>(\n  self: Metric.Metric<Type, In, Out>\n): Effect.Effect<Out> =>\n  core.fiberRefGetWith(\n    core.currentMetricLabels,\n    (tags) => core.sync(() => self.unsafeValue(tags))\n  )\n\n/** @internal */\nexport const withNow = <Type, In, Out>(\n  self: Metric.Metric<Type, readonly [In, number], Out>\n): Metric.Metric<Type, In, Out> => mapInput(self, (input: In) => [input, Date.now()] as const)\n\n/** @internal */\nexport const zip = dual<\n  <Type2, In2, Out2>(\n    that: Metric.Metric<Type2, In2, Out2>\n  ) => <Type, In, Out>(\n    self: Metric.Metric<Type, In, Out>\n  ) => Metric.Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>,\n  <Type, In, Out, Type2, In2, Out2>(\n    self: Metric.Metric<Type, In, Out>,\n    that: Metric.Metric<Type2, In2, Out2>\n  ) => Metric.Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>\n>(\n  2,\n  <Type, In, Out, Type2, In2, Out2>(self: Metric.Metric<Type, In, Out>, that: Metric.Metric<Type2, In2, Out2>) =>\n    make(\n      [self.keyType, that.keyType] as const,\n      (input: readonly [In, In2], extraTags) => {\n        const [l, r] = input\n        self.unsafeUpdate(l, extraTags)\n        that.unsafeUpdate(r, extraTags)\n      },\n      (extraTags) => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)],\n      (input: readonly [In, In2], extraTags) => {\n        const [l, r] = input\n        self.unsafeModify(l, extraTags)\n        that.unsafeModify(r, extraTags)\n      }\n    )\n)\n\n/** @internal */\nexport const unsafeSnapshot = (): Array<MetricPair.MetricPair.Untyped> => globalMetricRegistry.snapshot()\n\n/** @internal */\nexport const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>> = core.sync(\n  unsafeSnapshot\n)\n","import * as Arr from \"../../Array.js\"\nimport * as Option from \"../../Option.js\"\nimport type * as RBT from \"../../RedBlackTree.js\"\nimport type { RedBlackTreeImpl } from \"../redBlackTree.js\"\nimport type * as Node from \"./node.js\"\n\n/** @internal */\nexport const Direction = {\n  Forward: 0 as RBT.RedBlackTree.Direction,\n  Backward: 1 << 0 as RBT.RedBlackTree.Direction\n} as const\n\n/** @internal */\nexport class RedBlackTreeIterator<in out K, out V> implements Iterator<[K, V]> {\n  private count = 0\n\n  constructor(\n    readonly self: RBT.RedBlackTree<K, V>,\n    readonly stack: Array<Node.Node<K, V>>,\n    readonly direction: RBT.RedBlackTree.Direction\n  ) {}\n\n  /**\n   * Clones the iterator\n   */\n  clone(): RedBlackTreeIterator<K, V> {\n    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction)\n  }\n\n  /**\n   * Reverse the traversal direction\n   */\n  reversed(): RedBlackTreeIterator<K, V> {\n    return new RedBlackTreeIterator(\n      this.self,\n      this.stack.slice(),\n      this.direction === Direction.Forward ? Direction.Backward : Direction.Forward\n    )\n  }\n\n  /**\n   * Iterator next\n   */\n  next(): IteratorResult<[K, V], number> {\n    const entry = this.entry\n    this.count++\n    if (this.direction === Direction.Forward) {\n      this.moveNext()\n    } else {\n      this.movePrev()\n    }\n    switch (entry._tag) {\n      case \"None\": {\n        return { done: true, value: this.count }\n      }\n      case \"Some\": {\n        return { done: false, value: entry.value }\n      }\n    }\n  }\n\n  /**\n   * Returns the key\n   */\n  get key(): Option.Option<K> {\n    if (this.stack.length > 0) {\n      return Option.some(this.stack[this.stack.length - 1]!.key)\n    }\n    return Option.none()\n  }\n\n  /**\n   * Returns the value\n   */\n  get value(): Option.Option<V> {\n    if (this.stack.length > 0) {\n      return Option.some(this.stack[this.stack.length - 1]!.value)\n    }\n    return Option.none()\n  }\n\n  /**\n   * Returns the key\n   */\n  get entry(): Option.Option<[K, V]> {\n    return Option.map(Arr.last(this.stack), (node) => [node.key, node.value])\n  }\n\n  /**\n   * Returns the position of this iterator in the sorted list\n   */\n  get index(): number {\n    let idx = 0\n    const stack = this.stack\n    if (stack.length === 0) {\n      const r = (this.self as RedBlackTreeImpl<K, V>)._root\n      if (r != null) {\n        return r.count\n      }\n      return 0\n    } else if (stack[stack.length - 1]!.left != null) {\n      idx = stack[stack.length - 1]!.left!.count\n    }\n    for (let s = stack.length - 2; s >= 0; --s) {\n      if (stack[s + 1] === stack[s]!.right) {\n        ++idx\n        if (stack[s]!.left != null) {\n          idx += stack[s]!.left!.count\n        }\n      }\n    }\n    return idx\n  }\n\n  /**\n   * Advances iterator to next element in list\n   */\n  moveNext() {\n    const stack = this.stack\n    if (stack.length === 0) {\n      return\n    }\n    let n: Node.Node<K, V> | undefined = stack[stack.length - 1]!\n    if (n.right != null) {\n      n = n.right\n      while (n != null) {\n        stack.push(n)\n        n = n.left\n      }\n    } else {\n      stack.pop()\n      while (stack.length > 0 && stack[stack.length - 1]!.right === n) {\n        n = stack[stack.length - 1]\n        stack.pop()\n      }\n    }\n  }\n\n  /**\n   * Checks if there is a next element\n   */\n  get hasNext() {\n    const stack = this.stack\n    if (stack.length === 0) {\n      return false\n    }\n    if (stack[stack.length - 1]!.right != null) {\n      return true\n    }\n    for (let s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1]!.left === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Advances iterator to previous element in list\n   */\n  movePrev() {\n    const stack = this.stack\n    if (stack.length === 0) {\n      return\n    }\n    let n: Node.Node<K, V> | undefined = stack[stack.length - 1]\n    if (n != null && n.left != null) {\n      n = n.left\n      while (n != null) {\n        stack.push(n)\n        n = n.right\n      }\n    } else {\n      stack.pop()\n      while (stack.length > 0 && stack[stack.length - 1]!.left === n) {\n        n = stack[stack.length - 1]\n        stack.pop()\n      }\n    }\n  }\n\n  /**\n   * Checks if there is a previous element\n   */\n  get hasPrev() {\n    const stack = this.stack\n    if (stack.length === 0) {\n      return false\n    }\n    if (stack[stack.length - 1]!.left != null) {\n      return true\n    }\n    for (let s = stack.length - 1; s > 0; --s) {\n      if (stack[s - 1]!.right === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n}\n","import * as Equal from \"../../Equal.js\"\nimport * as Hash from \"../../Hash.js\"\nimport type * as MetricLabel from \"../../MetricLabel.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport { hasProperty } from \"../../Predicate.js\"\n\n/** @internal */\nconst MetricLabelSymbolKey = \"effect/MetricLabel\"\n\n/** @internal */\nexport const MetricLabelTypeId: MetricLabel.MetricLabelTypeId = Symbol.for(\n  MetricLabelSymbolKey\n) as MetricLabel.MetricLabelTypeId\n\n/** @internal */\nclass MetricLabelImpl implements MetricLabel.MetricLabel {\n  readonly [MetricLabelTypeId]: MetricLabel.MetricLabelTypeId = MetricLabelTypeId\n  readonly _hash: number\n  constructor(readonly key: string, readonly value: string) {\n    this._hash = Hash.string(MetricLabelSymbolKey + this.key + this.value)\n  }\n  [Hash.symbol](): number {\n    return this._hash\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isMetricLabel(that) &&\n      this.key === that.key &&\n      this.value === that.value\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const make = (key: string, value: string): MetricLabel.MetricLabel => {\n  return new MetricLabelImpl(key, value)\n}\n\n/** @internal */\nexport const isMetricLabel = (u: unknown): u is MetricLabel.MetricLabel => hasProperty(u, MetricLabelTypeId)\n","import * as Chunk from \"../Chunk.js\"\nimport * as Equal from \"../Equal.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport type * as Order from \"../Order.js\"\nimport type * as Ordering from \"../Ordering.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as RBT from \"../RedBlackTree.js\"\nimport { Direction, RedBlackTreeIterator } from \"./redBlackTree/iterator.js\"\nimport * as Node from \"./redBlackTree/node.js\"\nimport * as Stack from \"./stack.js\"\n\nconst RedBlackTreeSymbolKey = \"effect/RedBlackTree\"\n\n/** @internal */\nexport const RedBlackTreeTypeId: RBT.TypeId = Symbol.for(RedBlackTreeSymbolKey) as RBT.TypeId\n\n/** @internal */\nexport interface RedBlackTreeImpl<in out K, out V> extends RBT.RedBlackTree<K, V> {\n  readonly _ord: Order.Order<K>\n  readonly _root: Node.Node<K, V> | undefined\n}\n\nconst redBlackTreeVariance = {\n  /* c8 ignore next */\n  _Key: (_: any) => _,\n  /* c8 ignore next */\n  _Value: (_: never) => _\n}\n\nconst RedBlackTreeProto: RBT.RedBlackTree<unknown, unknown> = {\n  [RedBlackTreeTypeId]: redBlackTreeVariance,\n  [Hash.symbol](this: RBT.RedBlackTree<unknown, unknown>): number {\n    let hash = Hash.hash(RedBlackTreeSymbolKey)\n    for (const item of this) {\n      hash ^= pipe(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])))\n    }\n    return Hash.cached(this, hash)\n  },\n  [Equal.symbol]<K, V>(this: RedBlackTreeImpl<K, V>, that: unknown): boolean {\n    if (isRedBlackTree(that)) {\n      if ((this._root?.count ?? 0) !== ((that as RedBlackTreeImpl<K, V>)._root?.count ?? 0)) {\n        return false\n      }\n      const entries = Array.from(that)\n      return Array.from(this).every((itemSelf, i) => {\n        const itemThat = entries[i]\n        return Equal.equals(itemSelf[0], itemThat[0]) && Equal.equals(itemSelf[1], itemThat[1])\n      })\n    }\n    return false\n  },\n  [Symbol.iterator]<K, V>(this: RedBlackTreeImpl<K, V>): RedBlackTreeIterator<K, V> {\n    const stack: Array<Node.Node<K, V>> = []\n    let n = this._root\n    while (n != null) {\n      stack.push(n)\n      n = n.left\n    }\n    return new RedBlackTreeIterator(this, stack, Direction.Forward)\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"RedBlackTree\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeImpl = <K, V>(ord: Order.Order<K>, root: Node.Node<K, V> | undefined): RedBlackTreeImpl<K, V> => {\n  const tree = Object.create(RedBlackTreeProto)\n  tree._ord = ord\n  tree._root = root\n  return tree\n}\n\n/** @internal */\nexport const isRedBlackTree: {\n  <K, V>(u: Iterable<readonly [K, V]>): u is RBT.RedBlackTree<K, V>\n  (u: unknown): u is RBT.RedBlackTree<unknown, unknown>\n} = (u: unknown): u is RBT.RedBlackTree<unknown, unknown> => hasProperty(u, RedBlackTreeTypeId)\n\n/** @internal */\nexport const empty = <K, V = never>(ord: Order.Order<K>): RBT.RedBlackTree<K, V> => makeImpl<K, V>(ord, undefined)\n\n/** @internal */\nexport const fromIterable = dual<\n  <B>(ord: Order.Order<B>) => <K extends B, V>(entries: Iterable<readonly [K, V]>) => RBT.RedBlackTree<K, V>,\n  <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order.Order<B>) => RBT.RedBlackTree<K, V>\n>(2, <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order.Order<B>) => {\n  let tree = empty<K, V>(ord)\n  for (const [key, value] of entries) {\n    tree = insert(tree, key, value)\n  }\n  return tree\n})\n\n/** @internal */\nexport const make =\n  <K>(ord: Order.Order<K>) =>\n  <Entries extends Array<readonly [K, any]>>(...entries: Entries): RBT.RedBlackTree<\n    K,\n    Entries[number] extends readonly [any, infer V] ? V : never\n  > => {\n    return fromIterable(entries, ord)\n  }\n\n/** @internal */\nexport const atBackwards = dual<\n  (index: number) => <K, V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, index: number) => Iterable<[K, V]>\n>(2, (self, index) => at(self, index, Direction.Backward))\n\n/** @internal */\nexport const atForwards = dual<\n  (index: number) => <K, V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, index: number) => Iterable<[K, V]>\n>(2, (self, index) => at(self, index, Direction.Forward))\n\nconst at = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  index: number,\n  direction: RBT.RedBlackTree.Direction\n): Iterable<[K, V]> => {\n  return {\n    [Symbol.iterator]: () => {\n      if (index < 0) {\n        return new RedBlackTreeIterator(self, [], direction)\n      }\n      let node = (self as RedBlackTreeImpl<K, V>)._root\n      const stack: Array<Node.Node<K, V>> = []\n      while (node !== undefined) {\n        stack.push(node)\n        if (node.left !== undefined) {\n          if (index < node.left.count) {\n            node = node.left\n            continue\n          }\n          index -= node.left.count\n        }\n        if (!index) {\n          return new RedBlackTreeIterator(self, stack, direction)\n        }\n        index -= 1\n        if (node.right !== undefined) {\n          if (index >= node.right.count) {\n            break\n          }\n          node = node.right\n        } else {\n          break\n        }\n      }\n      return new RedBlackTreeIterator(self, [], direction)\n    }\n  }\n}\n\n/** @internal */\nexport const findAll = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Chunk.Chunk<V>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Chunk.Chunk<V>\n>(2, <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => {\n  const stack: Array<Node.Node<K, V>> = []\n  let node = (self as RedBlackTreeImpl<K, V>)._root\n  let result = Chunk.empty<V>()\n  while (node !== undefined || stack.length > 0) {\n    if (node) {\n      stack.push(node)\n      node = node.left\n    } else {\n      const current = stack.pop()!\n      if (Equal.equals(key, current.key)) {\n        result = Chunk.prepend(current.value)(result)\n      }\n      node = current.right\n    }\n  }\n  return result\n})\n\n/** @internal */\nexport const findFirst = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Option.Option<V>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Option.Option<V>\n>(2, <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => {\n  const cmp = (self as RedBlackTreeImpl<K, V>)._ord\n  let node = (self as RedBlackTreeImpl<K, V>)._root\n  while (node !== undefined) {\n    const d = cmp(key, node.key)\n    if (Equal.equals(key, node.key)) {\n      return Option.some(node.value)\n    }\n    if (d <= 0) {\n      node = node.left\n    } else {\n      node = node.right\n    }\n  }\n  return Option.none()\n})\n\n/** @internal */\nexport const first = <K, V>(self: RBT.RedBlackTree<K, V>): Option.Option<[K, V]> => {\n  let node: Node.Node<K, V> | undefined = (self as RedBlackTreeImpl<K, V>)._root\n  let current: Node.Node<K, V> | undefined = (self as RedBlackTreeImpl<K, V>)._root\n  while (node !== undefined) {\n    current = node\n    node = node.left\n  }\n  return current ? Option.some([current.key, current.value]) : Option.none()\n}\n\n/** @internal */\nexport const getAt = dual<\n  (index: number) => <K, V>(self: RBT.RedBlackTree<K, V>) => Option.Option<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, index: number) => Option.Option<[K, V]>\n>(2, <K, V>(self: RBT.RedBlackTree<K, V>, index: number) => {\n  if (index < 0) {\n    return Option.none()\n  }\n  let root = (self as RedBlackTreeImpl<K, V>)._root\n  let node: Node.Node<K, V> | undefined = undefined\n  while (root !== undefined) {\n    node = root\n    if (root.left) {\n      if (index < root.left.count) {\n        root = root.left\n        continue\n      }\n      index -= root.left.count\n    }\n    if (!index) {\n      return Option.some([node.key, node.value])\n    }\n    index -= 1\n    if (root.right) {\n      if (index >= root.right.count) {\n        break\n      }\n      root = root.right\n    } else {\n      break\n    }\n  }\n  return Option.none()\n})\n\n/** @internal */\nexport const getOrder = <K, V>(tree: RBT.RedBlackTree<K, V>): Order.Order<K> => (tree as RedBlackTreeImpl<K, V>)._ord\n\n/** @internal */\nexport const has = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => boolean,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => boolean\n>(2, (self, key) => Option.isSome(findFirst(self, key)))\n\n/** @internal */\nexport const insert = dual<\n  <K, V>(key: K, value: V) => (self: RBT.RedBlackTree<K, V>) => RBT.RedBlackTree<K, V>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K, value: V) => RBT.RedBlackTree<K, V>\n>(3, <K, V>(self: RBT.RedBlackTree<K, V>, key: K, value: V) => {\n  const cmp = (self as RedBlackTreeImpl<K, V>)._ord\n  // Find point to insert new node at\n  let n: Node.Node<K, V> | undefined = (self as RedBlackTreeImpl<K, V>)._root\n  const n_stack: Array<Node.Node<K, V>> = []\n  const d_stack: Array<Ordering.Ordering> = []\n  while (n != null) {\n    const d = cmp(key, n.key)\n    n_stack.push(n)\n    d_stack.push(d)\n    if (d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  // Rebuild path to leaf node\n  n_stack.push({\n    color: Node.Color.Red,\n    key,\n    value,\n    left: undefined,\n    right: undefined,\n    count: 1\n  })\n  for (let s = n_stack.length - 2; s >= 0; --s) {\n    const n2 = n_stack[s]!\n    if (d_stack[s]! <= 0) {\n      n_stack[s] = {\n        color: n2.color,\n        key: n2.key,\n        value: n2.value,\n        left: n_stack[s + 1],\n        right: n2.right,\n        count: n2.count + 1\n      }\n    } else {\n      n_stack[s] = {\n        color: n2.color,\n        key: n2.key,\n        value: n2.value,\n        left: n2.left,\n        right: n_stack[s + 1],\n        count: n2.count + 1\n      }\n    }\n  }\n  // Rebalance tree using rotations\n  for (let s = n_stack.length - 1; s > 1; --s) {\n    const p = n_stack[s - 1]!\n    const n3 = n_stack[s]!\n    if (p.color === Node.Color.Black || n3.color === Node.Color.Black) {\n      break\n    }\n    const pp = n_stack[s - 2]!\n    if (pp.left === p) {\n      if (p.left === n3) {\n        const y = pp.right\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black\n          pp.right = Node.repaint(y, Node.Color.Black)\n          pp.color = Node.Color.Red\n          s -= 1\n        } else {\n          pp.color = Node.Color.Red\n          pp.left = p.right\n          p.color = Node.Color.Black\n          p.right = pp\n          n_stack[s - 2] = p\n          n_stack[s - 1] = n3\n          Node.recount(pp)\n          Node.recount(p)\n          if (s >= 3) {\n            const ppp = n_stack[s - 3]!\n            if (ppp.left === pp) {\n              ppp.left = p\n            } else {\n              ppp.right = p\n            }\n          }\n          break\n        }\n      } else {\n        const y = pp.right\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black\n          pp.right = Node.repaint(y, Node.Color.Black)\n          pp.color = Node.Color.Red\n          s -= 1\n        } else {\n          p.right = n3.left\n          pp.color = Node.Color.Red\n          pp.left = n3.right\n          n3.color = Node.Color.Black\n          n3.left = p\n          n3.right = pp\n          n_stack[s - 2] = n3\n          n_stack[s - 1] = p\n          Node.recount(pp)\n          Node.recount(p)\n          Node.recount(n3)\n          if (s >= 3) {\n            const ppp = n_stack[s - 3]!\n            if (ppp.left === pp) {\n              ppp.left = n3\n            } else {\n              ppp.right = n3\n            }\n          }\n          break\n        }\n      }\n    } else {\n      if (p.right === n3) {\n        const y = pp.left\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black\n          pp.left = Node.repaint(y, Node.Color.Black)\n          pp.color = Node.Color.Red\n          s -= 1\n        } else {\n          pp.color = Node.Color.Red\n          pp.right = p.left\n          p.color = Node.Color.Black\n          p.left = pp\n          n_stack[s - 2] = p\n          n_stack[s - 1] = n3\n          Node.recount(pp)\n          Node.recount(p)\n          if (s >= 3) {\n            const ppp = n_stack[s - 3]!\n            if (ppp.right === pp) {\n              ppp.right = p\n            } else {\n              ppp.left = p\n            }\n          }\n          break\n        }\n      } else {\n        const y = pp.left\n        if (y && y.color === Node.Color.Red) {\n          p.color = Node.Color.Black\n          pp.left = Node.repaint(y, Node.Color.Black)\n          pp.color = Node.Color.Red\n          s -= 1\n        } else {\n          p.left = n3.right\n          pp.color = Node.Color.Red\n          pp.right = n3.left\n          n3.color = Node.Color.Black\n          n3.right = p\n          n3.left = pp\n          n_stack[s - 2] = n3\n          n_stack[s - 1] = p\n          Node.recount(pp)\n          Node.recount(p)\n          Node.recount(n3)\n          if (s >= 3) {\n            const ppp = n_stack[s - 3]!\n            if (ppp.right === pp) {\n              ppp.right = n3\n            } else {\n              ppp.left = n3\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n  // Return new tree\n  n_stack[0]!.color = Node.Color.Black\n  return makeImpl((self as RedBlackTreeImpl<K, V>)._ord, n_stack[0])\n})\n\n/** @internal */\nexport const keysForward = <K, V>(self: RBT.RedBlackTree<K, V>): IterableIterator<K> => keys(self, Direction.Forward)\n\n/** @internal */\nexport const keysBackward = <K, V>(self: RBT.RedBlackTree<K, V>): IterableIterator<K> => keys(self, Direction.Backward)\n\nconst keys = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  direction: RBT.RedBlackTree.Direction\n): IterableIterator<K> => {\n  const begin: RedBlackTreeIterator<K, V> = self[Symbol.iterator]() as RedBlackTreeIterator<K, V>\n  let count = 0\n  return {\n    [Symbol.iterator]: () => keys(self, direction),\n    next: (): IteratorResult<K, number> => {\n      count++\n      const entry = begin.key\n      if (direction === Direction.Forward) {\n        begin.moveNext()\n      } else {\n        begin.movePrev()\n      }\n      switch (entry._tag) {\n        case \"None\": {\n          return { done: true, value: count }\n        }\n        case \"Some\": {\n          return { done: false, value: entry.value }\n        }\n      }\n    }\n  }\n}\n\n/** @internal */\nexport const last = <K, V>(self: RBT.RedBlackTree<K, V>): Option.Option<[K, V]> => {\n  let node: Node.Node<K, V> | undefined = (self as RedBlackTreeImpl<K, V>)._root\n  let current: Node.Node<K, V> | undefined = (self as RedBlackTreeImpl<K, V>)._root\n  while (node !== undefined) {\n    current = node\n    node = node.right\n  }\n  return current ? Option.some([current.key, current.value]) : Option.none()\n}\n\n/** @internal */\nexport const reversed = <K, V>(self: RBT.RedBlackTree<K, V>): Iterable<[K, V]> => {\n  return {\n    [Symbol.iterator]: () => {\n      const stack: Array<Node.Node<K, V>> = []\n      let node = (self as RedBlackTreeImpl<K, V>)._root\n      while (node !== undefined) {\n        stack.push(node)\n        node = node.right\n      }\n      return new RedBlackTreeIterator(self, stack, Direction.Backward)\n    }\n  }\n}\n\n/** @internal */\nexport const greaterThanBackwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => greaterThan(self, key, Direction.Backward))\n\n/** @internal */\nexport const greaterThanForwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => greaterThan(self, key, Direction.Forward))\n\nconst greaterThan = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  key: K,\n  direction: RBT.RedBlackTree.Direction\n): Iterable<[K, V]> => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = (self as RedBlackTreeImpl<K, V>)._ord\n      let node = (self as RedBlackTreeImpl<K, V>)._root\n      const stack = []\n      let last_ptr = 0\n      while (node !== undefined) {\n        const d = cmp(key, node.key)\n        stack.push(node)\n        if (d < 0) {\n          last_ptr = stack.length\n        }\n        if (d < 0) {\n          node = node.left\n        } else {\n          node = node.right\n        }\n      }\n      stack.length = last_ptr\n      return new RedBlackTreeIterator(self, stack, direction)\n    }\n  }\n}\n\n/** @internal */\nexport const greaterThanEqualBackwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => greaterThanEqual(self, key, Direction.Backward))\n\n/** @internal */\nexport const greaterThanEqualForwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => greaterThanEqual(self, key, Direction.Forward))\n\nconst greaterThanEqual = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  key: K,\n  direction: RBT.RedBlackTree.Direction = Direction.Forward\n): Iterable<[K, V]> => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = (self as RedBlackTreeImpl<K, V>)._ord\n      let node = (self as RedBlackTreeImpl<K, V>)._root\n      const stack = []\n      let last_ptr = 0\n      while (node !== undefined) {\n        const d = cmp(key, node.key)\n        stack.push(node)\n        if (d <= 0) {\n          last_ptr = stack.length\n        }\n        if (d <= 0) {\n          node = node.left\n        } else {\n          node = node.right\n        }\n      }\n      stack.length = last_ptr\n      return new RedBlackTreeIterator(self, stack, direction)\n    }\n  }\n}\n\n/** @internal */\nexport const lessThanBackwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => lessThan(self, key, Direction.Backward))\n\n/** @internal */\nexport const lessThanForwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => lessThan(self, key, Direction.Forward))\n\nconst lessThan = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  key: K,\n  direction: RBT.RedBlackTree.Direction\n): Iterable<[K, V]> => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = (self as RedBlackTreeImpl<K, V>)._ord\n      let node = (self as RedBlackTreeImpl<K, V>)._root\n      const stack = []\n      let last_ptr = 0\n      while (node !== undefined) {\n        const d = cmp(key, node.key)\n        stack.push(node)\n        if (d > 0) {\n          last_ptr = stack.length\n        }\n        if (d <= 0) {\n          node = node.left\n        } else {\n          node = node.right\n        }\n      }\n      stack.length = last_ptr\n      return new RedBlackTreeIterator(self, stack, direction)\n    }\n  }\n}\n\n/** @internal */\nexport const lessThanEqualBackwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => lessThanEqual(self, key, Direction.Backward))\n\n/** @internal */\nexport const lessThanEqualForwards = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => Iterable<[K, V]>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => Iterable<[K, V]>\n>(2, (self, key) => lessThanEqual(self, key, Direction.Forward))\n\nconst lessThanEqual = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  key: K,\n  direction: RBT.RedBlackTree.Direction\n): Iterable<[K, V]> => {\n  return {\n    [Symbol.iterator]: () => {\n      const cmp = (self as RedBlackTreeImpl<K, V>)._ord\n      let node = (self as RedBlackTreeImpl<K, V>)._root\n      const stack = []\n      let last_ptr = 0\n      while (node !== undefined) {\n        const d = cmp(key, node.key)\n        stack.push(node)\n        if (d >= 0) {\n          last_ptr = stack.length\n        }\n        if (d < 0) {\n          node = node.left\n        } else {\n          node = node.right\n        }\n      }\n      stack.length = last_ptr\n      return new RedBlackTreeIterator(self, stack, direction)\n    }\n  }\n}\n\n/** @internal */\nexport const forEach = dual<\n  <K, V>(f: (key: K, value: V) => void) => (self: RBT.RedBlackTree<K, V>) => void,\n  <K, V>(self: RBT.RedBlackTree<K, V>, f: (key: K, value: V) => void) => void\n>(2, <K, V>(self: RBT.RedBlackTree<K, V>, f: (key: K, value: V) => void) => {\n  const root = (self as RedBlackTreeImpl<K, V>)._root\n  if (root !== undefined) {\n    visitFull(root, (key, value) => {\n      f(key, value)\n      return Option.none()\n    })\n  }\n})\n\n/** @internal */\nexport const forEachGreaterThanEqual = dual<\n  <K, V>(min: K, f: (key: K, value: V) => void) => (self: RBT.RedBlackTree<K, V>) => void,\n  <K, V>(self: RBT.RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void) => void\n>(3, <K, V>(self: RBT.RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void) => {\n  const root = (self as RedBlackTreeImpl<K, V>)._root\n  const ord = (self as RedBlackTreeImpl<K, V>)._ord\n  if (root !== undefined) {\n    visitGreaterThanEqual(root, min, ord, (key, value) => {\n      f(key, value)\n      return Option.none()\n    })\n  }\n})\n\n/** @internal */\nexport const forEachLessThan = dual<\n  <K, V>(max: K, f: (key: K, value: V) => void) => (self: RBT.RedBlackTree<K, V>) => void,\n  <K, V>(self: RBT.RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void) => void\n>(3, <K, V>(self: RBT.RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void) => {\n  const root = (self as RedBlackTreeImpl<K, V>)._root\n  const ord = (self as RedBlackTreeImpl<K, V>)._ord\n  if (root !== undefined) {\n    visitLessThan(root, max, ord, (key, value) => {\n      f(key, value)\n      return Option.none()\n    })\n  }\n})\n\n/** @internal */\nexport const forEachBetween = dual<\n  <K, V>(options: {\n    readonly min: K\n    readonly max: K\n    readonly body: (key: K, value: V) => void\n  }) => (self: RBT.RedBlackTree<K, V>) => void,\n  <K, V>(self: RBT.RedBlackTree<K, V>, options: {\n    readonly min: K\n    readonly max: K\n    readonly body: (key: K, value: V) => void\n  }) => void\n>(2, <K, V>(self: RBT.RedBlackTree<K, V>, { body, max, min }: {\n  readonly min: K\n  readonly max: K\n  readonly body: (key: K, value: V) => void\n}) => {\n  const root = (self as RedBlackTreeImpl<K, V>)._root\n  const ord = (self as RedBlackTreeImpl<K, V>)._ord\n  if (root) {\n    visitBetween(root, min, max, ord, (key, value) => {\n      body(key, value)\n      return Option.none()\n    })\n  }\n})\n\n/** @internal */\nexport const reduce = dual<\n  <Z, V, K>(\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ) => (self: RBT.RedBlackTree<K, V>) => Z,\n  <Z, V, K>(self: RBT.RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z) => Z\n>(3, (self, zero, f) => {\n  let accumulator = zero\n  for (const entry of self) {\n    accumulator = f(accumulator, entry[1], entry[0])\n  }\n  return accumulator\n})\n\n/** @internal */\nexport const removeFirst = dual<\n  <K>(key: K) => <V>(self: RBT.RedBlackTree<K, V>) => RBT.RedBlackTree<K, V>,\n  <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => RBT.RedBlackTree<K, V>\n>(2, <K, V>(self: RBT.RedBlackTree<K, V>, key: K) => {\n  if (!has(self, key)) {\n    return self\n  }\n  const ord = (self as RedBlackTreeImpl<K, V>)._ord\n  const cmp = ord\n  let node: Node.Node<K, V> | undefined = (self as RedBlackTreeImpl<K, V>)._root\n  const stack = []\n  while (node !== undefined) {\n    const d = cmp(key, node.key)\n    stack.push(node)\n    if (Equal.equals(key, node.key)) {\n      node = undefined\n    } else if (d <= 0) {\n      node = node.left\n    } else {\n      node = node.right\n    }\n  }\n  if (stack.length === 0) {\n    return self\n  }\n  const cstack = new Array<Node.Node<K, V>>(stack.length)\n  let n = stack[stack.length - 1]!\n  cstack[cstack.length - 1] = {\n    color: n.color,\n    key: n.key,\n    value: n.value,\n    left: n.left,\n    right: n.right,\n    count: n.count\n  }\n  for (let i = stack.length - 2; i >= 0; --i) {\n    n = stack[i]!\n    if (n.left === stack[i + 1]) {\n      cstack[i] = {\n        color: n.color,\n        key: n.key,\n        value: n.value,\n        left: cstack[i + 1],\n        right: n.right,\n        count: n.count\n      }\n    } else {\n      cstack[i] = {\n        color: n.color,\n        key: n.key,\n        value: n.value,\n        left: n.left,\n        right: cstack[i + 1],\n        count: n.count\n      }\n    }\n  }\n  // Get node\n  n = cstack[cstack.length - 1]!\n  // If not leaf, then swap with previous node\n  if (n.left !== undefined && n.right !== undefined) {\n    // First walk to previous leaf\n    const split = cstack.length\n    n = n.left\n    while (n.right != null) {\n      cstack.push(n)\n      n = n.right\n    }\n    // Copy path to leaf\n    const v = cstack[split - 1]\n    cstack.push({\n      color: n.color,\n      key: v!.key,\n      value: v!.value,\n      left: n.left,\n      right: n.right,\n      count: n.count\n    })\n    cstack[split - 1]!.key = n.key\n    cstack[split - 1]!.value = n.value\n    // Fix up stack\n    for (let i = cstack.length - 2; i >= split; --i) {\n      n = cstack[i]!\n      cstack[i] = {\n        color: n.color,\n        key: n.key,\n        value: n.value,\n        left: n.left,\n        right: cstack[i + 1],\n        count: n.count\n      }\n    }\n    cstack[split - 1]!.left = cstack[split]\n  }\n\n  // Remove leaf node\n  n = cstack[cstack.length - 1]!\n  if (n.color === Node.Color.Red) {\n    // Easy case: removing red leaf\n    const p = cstack[cstack.length - 2]!\n    if (p.left === n) {\n      p.left = undefined\n    } else if (p.right === n) {\n      p.right = undefined\n    }\n    cstack.pop()\n    for (let i = 0; i < cstack.length; ++i) {\n      cstack[i]!.count--\n    }\n    return makeImpl(ord, cstack[0])\n  } else {\n    if (n.left !== undefined || n.right !== undefined) {\n      // Second easy case:  Single child black parent\n      if (n.left !== undefined) {\n        Node.swap(n, n.left)\n      } else if (n.right !== undefined) {\n        Node.swap(n, n.right)\n      }\n      // Child must be red, so repaint it black to balance color\n      n.color = Node.Color.Black\n      for (let i = 0; i < cstack.length - 1; ++i) {\n        cstack[i]!.count--\n      }\n      return makeImpl(ord, cstack[0])\n    } else if (cstack.length === 1) {\n      // Third easy case: root\n      return makeImpl(ord, undefined)\n    } else {\n      // Hard case: Repaint n, and then do some nasty stuff\n      for (let i = 0; i < cstack.length; ++i) {\n        cstack[i]!.count--\n      }\n      const parent = cstack[cstack.length - 2]\n      fixDoubleBlack(cstack)\n      // Fix up links\n      if (parent!.left === n) {\n        parent!.left = undefined\n      } else {\n        parent!.right = undefined\n      }\n    }\n  }\n  return makeImpl(ord, cstack[0])\n})\n\n/** @internal */\nexport const size = <K, V>(self: RBT.RedBlackTree<K, V>): number => (self as RedBlackTreeImpl<K, V>)._root?.count ?? 0\n\n/** @internal */\nexport const valuesForward = <K, V>(self: RBT.RedBlackTree<K, V>): IterableIterator<V> =>\n  values(self, Direction.Forward)\n\n/** @internal */\nexport const valuesBackward = <K, V>(self: RBT.RedBlackTree<K, V>): IterableIterator<V> =>\n  values(self, Direction.Backward)\n\n/** @internal */\nconst values = <K, V>(\n  self: RBT.RedBlackTree<K, V>,\n  direction: RBT.RedBlackTree.Direction\n): IterableIterator<V> => {\n  const begin: RedBlackTreeIterator<K, V> = self[Symbol.iterator]() as RedBlackTreeIterator<K, V>\n  let count = 0\n  return {\n    [Symbol.iterator]: () => values(self, direction),\n    next: (): IteratorResult<V, number> => {\n      count++\n      const entry = begin.value\n      if (direction === Direction.Forward) {\n        begin.moveNext()\n      } else {\n        begin.movePrev()\n      }\n      switch (entry._tag) {\n        case \"None\": {\n          return { done: true, value: count }\n        }\n        case \"Some\": {\n          return { done: false, value: entry.value }\n        }\n      }\n    }\n  }\n}\n\nconst visitFull = <K, V, A>(\n  node: Node.Node<K, V>,\n  visit: (key: K, value: V) => Option.Option<A>\n): Option.Option<A> => {\n  let current: Node.Node<K, V> | undefined = node\n  let stack: Stack.Stack<Node.Node<K, V>> | undefined = undefined\n  let done = false\n  while (!done) {\n    if (current != null) {\n      stack = Stack.make(current, stack)\n      current = current.left\n    } else if (stack != null) {\n      const value = visit(stack.value.key, stack.value.value)\n      if (Option.isSome(value)) {\n        return value\n      }\n      current = stack.value.right\n      stack = stack.previous\n    } else {\n      done = true\n    }\n  }\n  return Option.none()\n}\n\nconst visitGreaterThanEqual = <K, V, A>(\n  node: Node.Node<K, V>,\n  min: K,\n  ord: Order.Order<K>,\n  visit: (key: K, value: V) => Option.Option<A>\n): Option.Option<A> => {\n  let current: Node.Node<K, V> | undefined = node\n  let stack: Stack.Stack<Node.Node<K, V>> | undefined = undefined\n  let done = false\n  while (!done) {\n    if (current !== undefined) {\n      stack = Stack.make(current, stack)\n      if (ord(min, current.key) <= 0) {\n        current = current.left\n      } else {\n        current = undefined\n      }\n    } else if (stack !== undefined) {\n      if (ord(min, stack.value.key) <= 0) {\n        const value = visit(stack.value.key, stack.value.value)\n        if (Option.isSome(value)) {\n          return value\n        }\n      }\n      current = stack.value.right\n      stack = stack.previous\n    } else {\n      done = true\n    }\n  }\n  return Option.none()\n}\n\nconst visitLessThan = <K, V, A>(\n  node: Node.Node<K, V>,\n  max: K,\n  ord: Order.Order<K>,\n  visit: (key: K, value: V) => Option.Option<A>\n): Option.Option<A> => {\n  let current: Node.Node<K, V> | undefined = node\n  let stack: Stack.Stack<Node.Node<K, V>> | undefined = undefined\n  let done = false\n  while (!done) {\n    if (current !== undefined) {\n      stack = Stack.make(current, stack)\n      current = current.left\n    } else if (stack !== undefined && ord(max, stack.value.key) > 0) {\n      const value = visit(stack.value.key, stack.value.value)\n      if (Option.isSome(value)) {\n        return value\n      }\n      current = stack.value.right\n      stack = stack.previous\n    } else {\n      done = true\n    }\n  }\n  return Option.none()\n}\n\nconst visitBetween = <K, V, A>(\n  node: Node.Node<K, V>,\n  min: K,\n  max: K,\n  ord: Order.Order<K>,\n  visit: (key: K, value: V) => Option.Option<A>\n): Option.Option<A> => {\n  let current: Node.Node<K, V> | undefined = node\n  let stack: Stack.Stack<Node.Node<K, V>> | undefined = undefined\n  let done = false\n  while (!done) {\n    if (current !== undefined) {\n      stack = Stack.make(current, stack)\n      if (ord(min, current.key) <= 0) {\n        current = current.left\n      } else {\n        current = undefined\n      }\n    } else if (stack !== undefined && ord(max, stack.value.key) > 0) {\n      if (ord(min, stack.value.key) <= 0) {\n        const value = visit(stack.value.key, stack.value.value)\n        if (Option.isSome(value)) {\n          return value\n        }\n      }\n      current = stack.value.right\n      stack = stack.previous\n    } else {\n      done = true\n    }\n  }\n  return Option.none()\n}\n\n/**\n * Fix up a double black node in a Red-Black Tree.\n */\nconst fixDoubleBlack = <K, V>(stack: Array<Node.Node<K, V>>) => {\n  let n, p, s, z\n  for (let i = stack.length - 1; i >= 0; --i) {\n    n = stack[i]!\n    if (i === 0) {\n      n.color = Node.Color.Black\n      return\n    }\n    p = stack[i - 1]!\n    if (p.left === n) {\n      s = p.right\n      if (s !== undefined && s.right !== undefined && s.right.color === Node.Color.Red) {\n        s = p.right = Node.clone(s)\n        z = s.right = Node.clone(s.right!)\n        p.right = s.left\n        s.left = p\n        s.right = z\n        s.color = p.color\n        n.color = Node.Color.Black\n        p.color = Node.Color.Black\n        z.color = Node.Color.Black\n        Node.recount(p)\n        Node.recount(s)\n        if (i > 1) {\n          const pp = stack[i - 2]!\n          if (pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i - 1] = s\n        return\n      } else if (s !== undefined && s.left !== undefined && s.left.color === Node.Color.Red) {\n        s = p.right = Node.clone(s)\n        z = s.left = Node.clone(s.left!)\n        p.right = z.left\n        s.left = z.right\n        z.left = p\n        z.right = s\n        z.color = p.color\n        p.color = Node.Color.Black\n        s.color = Node.Color.Black\n        n.color = Node.Color.Black\n        Node.recount(p)\n        Node.recount(s)\n        Node.recount(z)\n        if (i > 1) {\n          const pp = stack[i - 2]!\n          if (pp.left === p) {\n            pp.left = z\n          } else {\n            pp.right = z\n          }\n        }\n        stack[i - 1] = z\n        return\n      }\n      if (s !== undefined && s.color === Node.Color.Black) {\n        if (p.color === Node.Color.Red) {\n          p.color = Node.Color.Black\n          p.right = Node.repaint(s, Node.Color.Red)\n          return\n        } else {\n          p.right = Node.repaint(s, Node.Color.Red)\n          continue\n        }\n      } else if (s !== undefined) {\n        s = Node.clone(s)\n        p.right = s.left\n        s.left = p\n        s.color = p.color\n        p.color = Node.Color.Red\n        Node.recount(p)\n        Node.recount(s)\n        if (i > 1) {\n          const pp = stack[i - 2]!\n          if (pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i - 1] = s\n        stack[i] = p\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i + 2\n      }\n    } else {\n      s = p.left\n      if (s !== undefined && s.left !== undefined && s.left.color === Node.Color.Red) {\n        s = p.left = Node.clone(s)\n        z = s.left = Node.clone(s.left!)\n        p.left = s.right\n        s.right = p\n        s.left = z\n        s.color = p.color\n        n.color = Node.Color.Black\n        p.color = Node.Color.Black\n        z.color = Node.Color.Black\n        Node.recount(p)\n        Node.recount(s)\n        if (i > 1) {\n          const pp = stack[i - 2]!\n          if (pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i - 1] = s\n        return\n      } else if (s !== undefined && s.right !== undefined && s.right.color === Node.Color.Red) {\n        s = p.left = Node.clone(s)\n        z = s.right = Node.clone(s.right!)\n        p.left = z.right\n        s.right = z.left\n        z.right = p\n        z.left = s\n        z.color = p.color\n        p.color = Node.Color.Black\n        s.color = Node.Color.Black\n        n.color = Node.Color.Black\n        Node.recount(p)\n        Node.recount(s)\n        Node.recount(z)\n        if (i > 1) {\n          const pp = stack[i - 2]!\n          if (pp.right === p) {\n            pp.right = z\n          } else {\n            pp.left = z\n          }\n        }\n        stack[i - 1] = z\n        return\n      }\n      if (s !== undefined && s.color === Node.Color.Black) {\n        if (p.color === Node.Color.Red) {\n          p.color = Node.Color.Black\n          p.left = Node.repaint(s, Node.Color.Red)\n          return\n        } else {\n          p.left = Node.repaint(s, Node.Color.Red)\n          continue\n        }\n      } else if (s !== undefined) {\n        s = Node.clone(s)\n        p.left = s.right\n        s.right = p\n        s.color = p.color\n        p.color = Node.Color.Red\n        Node.recount(p)\n        Node.recount(s)\n        if (i > 1) {\n          const pp = stack[i - 2]!\n          if (pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i - 1] = s\n        stack[i] = p\n        if (i + 1 < stack.length) {\n          stack[i + 1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i + 2\n      }\n    }\n  }\n}\n","/**\n * @since 2.0.0\n */\nimport type { Chunk } from \"./Chunk.js\"\nimport type { Equal } from \"./Equal.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as RBT from \"./internal/redBlackTree.js\"\nimport * as RBTI from \"./internal/redBlackTree/iterator.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Order } from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\nconst TypeId: unique symbol = RBT.RedBlackTreeTypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category constants\n */\nexport const Direction = RBTI.Direction\n\n/**\n * A Red-Black Tree.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface RedBlackTree<in out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Key: Types.Invariant<Key>\n    readonly _Value: Types.Covariant<Value>\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace RedBlackTree {\n  /**\n   * @since 2.0.0\n   */\n  export type Direction = number & {\n    readonly Direction: unique symbol\n  }\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isRedBlackTree: {\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  <K, V>(u: Iterable<readonly [K, V]>): u is RedBlackTree<K, V>\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  (u: unknown): u is RedBlackTree<unknown, unknown>\n} = RBT.isRedBlackTree\n\n/**\n * Creates an empty `RedBlackTree`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <K, V = never>(ord: Order<K>) => RedBlackTree<K, V> = RBT.empty\n\n/**\n * Creates a new `RedBlackTree` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: {\n  /**\n   * Creates a new `RedBlackTree` from an iterable collection of key/value pairs.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>\n  /**\n   * Creates a new `RedBlackTree` from an iterable collection of key/value pairs.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>\n} = RBT.fromIterable\n\n/**\n * Constructs a new `RedBlackTree` from the specified entries.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <K>(\n  ord: Order<K>\n) => <Entries extends Array<readonly [K, any]>>(\n  ...entries: Entries\n) => RedBlackTree<K, Entries[number] extends readonly [any, infer V] ? V : never> = RBT.make\n\n/**\n * Returns an iterator that points to the element at the specified index of the\n * tree.\n *\n * **Note**: The iterator will run through elements in order.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const at: {\n  /**\n   * Returns an iterator that points to the element at the specified index of the\n   * tree.\n   *\n   * **Note**: The iterator will run through elements in order.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that points to the element at the specified index of the\n   * tree.\n   *\n   * **Note**: The iterator will run through elements in order.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>\n} = RBT.atForwards\n\n/**\n * Returns an iterator that points to the element at the specified index of the\n * tree.\n *\n * **Note**: The iterator will run through elements in reverse order.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const atReversed: {\n  /**\n   * Returns an iterator that points to the element at the specified index of the\n   * tree.\n   *\n   * **Note**: The iterator will run through elements in reverse order.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that points to the element at the specified index of the\n   * tree.\n   *\n   * **Note**: The iterator will run through elements in reverse order.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>\n} = RBT.atBackwards\n\n/**\n * Finds all values in the tree associated with the specified key.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findAll: {\n  /**\n   * Finds all values in the tree associated with the specified key.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>\n  /**\n   * Finds all values in the tree associated with the specified key.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>\n} = RBT.findAll\n\n/**\n * Finds the first value in the tree associated with the specified key, if it exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  /**\n   * Finds the first value in the tree associated with the specified key, if it exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>\n  /**\n   * Finds the first value in the tree associated with the specified key, if it exists.\n   *\n   * @category elements\n   * @since 2.0.0\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>\n} = RBT.findFirst\n\n/**\n * Returns the first entry in the tree, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]> = RBT.first\n\n/**\n * Returns the element at the specified index within the tree or `None` if the\n * specified index does not exist.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const getAt: {\n  /**\n   * Returns the element at the specified index within the tree or `None` if the\n   * specified index does not exist.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>\n  /**\n   * Returns the element at the specified index within the tree or `None` if the\n   * specified index does not exist.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>\n} = RBT.getAt\n\n/**\n * Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K> = RBT.getOrder\n\n/**\n * Returns an iterator that traverse entries in order with keys greater than the\n * specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const greaterThan: {\n  /**\n   * Returns an iterator that traverse entries in order with keys greater than the\n   * specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in order with keys greater than the\n   * specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.greaterThanForwards\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys greater\n * than the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const greaterThanReversed: {\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys greater\n   * than the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys greater\n   * than the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.greaterThanBackwards\n\n/**\n * Returns an iterator that traverse entries in order with keys greater than or\n * equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const greaterThanEqual: {\n  /**\n   * Returns an iterator that traverse entries in order with keys greater than or\n   * equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in order with keys greater than or\n   * equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.greaterThanEqualForwards\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys greater\n * than or equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const greaterThanEqualReversed: {\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys greater\n   * than or equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys greater\n   * than or equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.greaterThanEqualBackwards\n\n/**\n * Finds the item with key, if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * Finds the item with key, if it exists.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => boolean\n  /**\n   * Finds the item with key, if it exists.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): boolean\n} = RBT.has\n\n/**\n * Insert a new item into the tree.\n *\n * @since 2.0.0\n */\nexport const insert: {\n  /**\n   * Insert a new item into the tree.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>\n  /**\n   * Insert a new item into the tree.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>\n} = RBT.insert\n\n/**\n * Get all the keys present in the tree in order.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K> = RBT.keysForward\n\n/**\n * Get all the keys present in the tree in reverse order.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K> = RBT.keysBackward\n\n/**\n * Returns the last entry in the tree, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]> = RBT.last\n\n/**\n * Returns an iterator that traverse entries in order with keys less than the\n * specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const lessThan: {\n  /**\n   * Returns an iterator that traverse entries in order with keys less than the\n   * specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in order with keys less than the\n   * specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.lessThanForwards\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys less\n * than the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const lessThanReversed: {\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys less\n   * than the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys less\n   * than the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.lessThanBackwards\n\n/**\n * Returns an iterator that traverse entries in order with keys less than or\n * equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const lessThanEqual: {\n  /**\n   * Returns an iterator that traverse entries in order with keys less than or\n   * equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in order with keys less than or\n   * equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.lessThanEqualForwards\n\n/**\n * Returns an iterator that traverse entries in reverse order with keys less\n * than or equal to the specified key.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const lessThanEqualReversed: {\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys less\n   * than or equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>\n  /**\n   * Returns an iterator that traverse entries in reverse order with keys less\n   * than or equal to the specified key.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>\n} = RBT.lessThanEqualBackwards\n\n/**\n * Execute the specified function for each node of the tree, in order.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach: {\n  /**\n   * Execute the specified function for each node of the tree, in order.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void\n  /**\n   * Execute the specified function for each node of the tree, in order.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void\n} = RBT.forEach\n\n/**\n * Visit each node of the tree in order with key greater then or equal to max.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEachGreaterThanEqual: {\n  /**\n   * Visit each node of the tree in order with key greater then or equal to max.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void\n  /**\n   * Visit each node of the tree in order with key greater then or equal to max.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void\n} = RBT.forEachGreaterThanEqual\n\n/**\n * Visit each node of the tree in order with key lower then max.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEachLessThan: {\n  /**\n   * Visit each node of the tree in order with key lower then max.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void\n  /**\n   * Visit each node of the tree in order with key lower then max.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void\n} = RBT.forEachLessThan\n\n/**\n * Visit each node of the tree in order with key lower than max and greater\n * than or equal to min.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEachBetween: {\n  /**\n   * Visit each node of the tree in order with key lower than max and greater\n   * than or equal to min.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(\n   options: {\n     readonly min: K\n     readonly max: K\n     readonly body: (key: K, value: V) => void\n   }\n  ): (self: RedBlackTree<K, V>) => void\n  /**\n   * Visit each node of the tree in order with key lower than max and greater\n   * than or equal to min.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <K, V>(\n   self: RedBlackTree<K, V>,\n   options: {\n     readonly min: K\n     readonly max: K\n     readonly body: (key: K, value: V) => void\n   }\n  ): void\n} = RBT.forEachBetween\n\n/**\n * Reduce a state over the entries of the tree.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Reduce a state over the entries of the tree.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z\n  /**\n   * Reduce a state over the entries of the tree.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V, K>(\n   self: RedBlackTree<K, V>,\n   zero: Z,\n   f: (accumulator: Z, value: V, key: K) => Z\n  ): Z\n} = RBT.reduce\n\n/**\n * Removes the entry with the specified key, if it exists.\n *\n * @since 2.0.0\n */\nexport const removeFirst: {\n  /**\n   * Removes the entry with the specified key, if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>\n  /**\n   * Removes the entry with the specified key, if it exists.\n   *\n   * @since 2.0.0\n   */\n  <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>\n} = RBT.removeFirst\n\n/**\n * Traverse the tree in reverse order.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]> = RBT.reversed\n\n/**\n * Returns the size of the tree.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <K, V>(self: RedBlackTree<K, V>) => number = RBT.size\n\n/**\n * Get all values present in the tree in order.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V> = RBT.valuesForward\n\n/**\n * Get all values present in the tree in reverse order.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V> = RBT.valuesBackward\n","import * as FiberId from \"../FiberId.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as FiberMessage from \"./fiberMessage.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\n\n/** @internal */\nconst FiberScopeSymbolKey = \"effect/FiberScope\"\n\n/** @internal */\nexport const FiberScopeTypeId = Symbol.for(FiberScopeSymbolKey)\n\nexport type FiberScopeTypeId = typeof FiberScopeTypeId\n\n/**\n * A `FiberScope` represents the scope of a fiber lifetime. The scope of a\n * fiber can be retrieved using `Effect.descriptor`, and when forking fibers,\n * you can specify a custom scope to fork them on by using the `forkIn`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface FiberScope {\n  readonly [FiberScopeTypeId]: FiberScopeTypeId\n  get fiberId(): FiberId.FiberId\n  add(runtimeFlags: RuntimeFlags.RuntimeFlags, child: FiberRuntime.FiberRuntime<any, any>): void\n}\n\n/** @internal */\nclass Global implements FiberScope {\n  readonly [FiberScopeTypeId]: FiberScopeTypeId = FiberScopeTypeId\n  readonly fiberId = FiberId.none\n  readonly roots = new Set<FiberRuntime.FiberRuntime<any, any>>()\n  add(_runtimeFlags: RuntimeFlags.RuntimeFlags, child: FiberRuntime.FiberRuntime<any, any>): void {\n    this.roots.add(child)\n    child.addObserver(() => {\n      this.roots.delete(child)\n    })\n  }\n}\n\n/** @internal */\nclass Local implements FiberScope {\n  readonly [FiberScopeTypeId]: FiberScopeTypeId = FiberScopeTypeId\n  constructor(\n    readonly fiberId: FiberId.FiberId,\n    readonly parent: FiberRuntime.FiberRuntime<any, any>\n  ) {\n  }\n  add(_runtimeFlags: RuntimeFlags.RuntimeFlags, child: FiberRuntime.FiberRuntime<any, any>): void {\n    this.parent.tell(\n      FiberMessage.stateful((parentFiber) => {\n        parentFiber.addChild(child)\n        child.addObserver(() => {\n          parentFiber.removeChild(child)\n        })\n      })\n    )\n  }\n}\n\n/** @internal */\nexport const unsafeMake = (fiber: FiberRuntime.FiberRuntime<any, any>): FiberScope => {\n  return new Local(fiber.id(), fiber)\n}\n\n/** @internal */\nexport const globalScope = globalValue(\n  Symbol.for(\"effect/FiberScope/Global\"),\n  () => new Global()\n)\n","import type * as Cause from \"../Cause.js\"\nimport * as Clock from \"../Clock.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport * as FiberStatus from \"../FiberStatus.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as number from \"../Number.js\"\nimport * as Option from \"../Option.js\"\nimport * as order from \"../Order.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport * as core from \"./core.js\"\nimport * as effectable from \"./effectable.js\"\nimport * as fiberScope from \"./fiberScope.js\"\nimport * as runtimeFlags from \"./runtimeFlags.js\"\n\n/** @internal */\nconst FiberSymbolKey = \"effect/Fiber\"\n\n/** @internal */\nexport const FiberTypeId: Fiber.FiberTypeId = Symbol.for(\n  FiberSymbolKey\n) as Fiber.FiberTypeId\n\n/** @internal */\nexport const fiberVariance = {\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: never) => _\n}\n\n/** @internal */\nconst fiberProto = {\n  [FiberTypeId]: fiberVariance,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nconst RuntimeFiberSymbolKey = \"effect/Fiber\"\n\n/** @internal */\nexport const RuntimeFiberTypeId: Fiber.RuntimeFiberTypeId = Symbol.for(\n  RuntimeFiberSymbolKey\n) as Fiber.RuntimeFiberTypeId\n\n/** @internal */\nexport const Order: order.Order<Fiber.RuntimeFiber<unknown, unknown>> = pipe(\n  order.tuple(number.Order, number.Order),\n  order.mapInput((fiber: Fiber.RuntimeFiber<unknown, unknown>) =>\n    [\n      (fiber.id() as FiberId.Runtime).startTimeMillis,\n      (fiber.id() as FiberId.Runtime).id\n    ] as const\n  )\n)\n\n/** @internal */\nexport const isFiber = (u: unknown): u is Fiber.Fiber<unknown, unknown> => hasProperty(u, FiberTypeId)\n\n/** @internal */\nexport const isRuntimeFiber = <A, E>(self: Fiber.Fiber<A, E>): self is Fiber.RuntimeFiber<A, E> =>\n  RuntimeFiberTypeId in self\n\n/** @internal */\nexport const _await = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Exit.Exit<A, E>> => self.await\n\n/** @internal */\nexport const children = <A, E>(\n  self: Fiber.Fiber<A, E>\n): Effect.Effect<Array<Fiber.RuntimeFiber<any, any>>> => self.children\n\n/** @internal */\nexport const done = <A, E>(exit: Exit.Exit<A, E>): Fiber.Fiber<A, E> => {\n  const _fiber = {\n    ...effectable.CommitPrototype,\n    commit() {\n      return join(this)\n    },\n    ...fiberProto,\n    id: () => FiberId.none,\n    await: core.succeed(exit),\n    children: core.succeed([]),\n    inheritAll: core.void,\n    poll: core.succeed(Option.some(exit)),\n    interruptAsFork: () => core.void\n  }\n\n  return _fiber\n}\n\n/** @internal */\nexport const dump = <A, E>(self: Fiber.RuntimeFiber<A, E>): Effect.Effect<Fiber.Fiber.Dump> =>\n  core.map(self.status, (status) => ({ id: self.id(), status }))\n\n/** @internal */\nexport const dumpAll = (\n  fibers: Iterable<Fiber.RuntimeFiber<unknown, unknown>>\n): Effect.Effect<Array<Fiber.Fiber.Dump>> => core.forEachSequential(fibers, dump)\n\n/** @internal */\nexport const fail = <E>(error: E): Fiber.Fiber<never, E> => done(Exit.fail(error))\n\n/** @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Fiber.Fiber<never, E> => done(Exit.failCause(cause))\n\n/** @internal */\nexport const fromEffect = <A, E>(effect: Effect.Effect<A, E>): Effect.Effect<Fiber.Fiber<A, E>> =>\n  core.map(core.exit(effect), done)\n\n/** @internal */\nexport const id = <A, E>(self: Fiber.Fiber<A, E>): FiberId.FiberId => self.id()\n\n/** @internal */\nexport const inheritAll = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<void> => self.inheritAll\n\n/** @internal */\nexport const interrupted = (fiberId: FiberId.FiberId): Fiber.Fiber<never> => done(Exit.interrupt(fiberId))\n\n/** @internal */\nexport const interruptAll = (fibers: Iterable<Fiber.Fiber<any, any>>): Effect.Effect<void> =>\n  core.flatMap(core.fiberId, (fiberId) => pipe(fibers, interruptAllAs(fiberId)))\n\n/** @internal */\nexport const interruptAllAs = dual<\n  (fiberId: FiberId.FiberId) => (fibers: Iterable<Fiber.Fiber<any, any>>) => Effect.Effect<void>,\n  (fibers: Iterable<Fiber.Fiber<any, any>>, fiberId: FiberId.FiberId) => Effect.Effect<void>\n>(\n  2,\n  core.fnUntraced(function*(fibers, fiberId) {\n    for (const fiber of fibers) {\n      if (isRuntimeFiber(fiber)) {\n        fiber.unsafeInterruptAsFork(fiberId)\n        continue\n      }\n      yield* fiber.interruptAsFork(fiberId)\n    }\n    for (const fiber of fibers) {\n      if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {\n        continue\n      }\n      yield* fiber.await\n    }\n  })\n)\n\n/** @internal */\nexport const interruptAsFork = dual<\n  (fiberId: FiberId.FiberId) => <A, E>(self: Fiber.Fiber<A, E>) => Effect.Effect<void>,\n  <A, E>(self: Fiber.Fiber<A, E>, fiberId: FiberId.FiberId) => Effect.Effect<void>\n>(2, (self, fiberId) => self.interruptAsFork(fiberId))\n\n/** @internal */\nexport const join = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<A, E> =>\n  core.zipLeft(core.flatten(self.await), self.inheritAll)\n\n/** @internal */\nexport const map = dual<\n  <A, B>(f: (a: A) => B) => <E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<B, E>,\n  <A, E, B>(self: Fiber.Fiber<A, E>, f: (a: A) => B) => Fiber.Fiber<B, E>\n>(2, (self, f) => mapEffect(self, (a) => core.sync(() => f(a))))\n\n/** @internal */\nexport const mapEffect = dual<\n  <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>) => <E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<A2, E | E2>,\n  <A, E, A2, E2>(self: Fiber.Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>) => Fiber.Fiber<A2, E | E2>\n>(2, (self, f) => {\n  const _fiber = {\n    ...effectable.CommitPrototype,\n    commit() {\n      return join(this)\n    },\n    ...fiberProto,\n    id: () => self.id(),\n    await: core.flatMap(self.await, Exit.forEachEffect(f)),\n    children: self.children,\n    inheritAll: self.inheritAll,\n    poll: core.flatMap(self.poll, (result) => {\n      switch (result._tag) {\n        case \"None\":\n          return core.succeed(Option.none())\n        case \"Some\":\n          return pipe(\n            Exit.forEachEffect(result.value, f),\n            core.map(Option.some)\n          )\n      }\n    }),\n    interruptAsFork: (id: FiberId.FiberId) => self.interruptAsFork(id)\n  }\n  return _fiber\n})\n\n/** @internal */\nexport const mapFiber = dual<\n  <E, E2, A, B>(\n    f: (a: A) => Fiber.Fiber<B, E2>\n  ) => (self: Fiber.Fiber<A, E>) => Effect.Effect<Fiber.Fiber<B, E | E2>>,\n  <A, E, E2, B>(\n    self: Fiber.Fiber<A, E>,\n    f: (a: A) => Fiber.Fiber<B, E2>\n  ) => Effect.Effect<Fiber.Fiber<B, E | E2>>\n>(2, <A, E, E2, B>(\n  self: Fiber.Fiber<A, E>,\n  f: (a: A) => Fiber.Fiber<B, E2>\n) =>\n  core.map(\n    self.await,\n    Exit.match({\n      onFailure: (cause): Fiber.Fiber<B, E | E2> => failCause(cause),\n      onSuccess: (a) => f(a)\n    })\n  ))\n\n/** @internal */\nexport const match = dual<\n  <A, E, Z>(\n    options: {\n      readonly onFiber: (fiber: Fiber.Fiber<A, E>) => Z\n      readonly onRuntimeFiber: (fiber: Fiber.RuntimeFiber<A, E>) => Z\n    }\n  ) => (self: Fiber.Fiber<A, E>) => Z,\n  <A, E, Z>(\n    self: Fiber.Fiber<A, E>,\n    options: {\n      readonly onFiber: (fiber: Fiber.Fiber<A, E>) => Z\n      readonly onRuntimeFiber: (fiber: Fiber.RuntimeFiber<A, E>) => Z\n    }\n  ) => Z\n>(2, (self, { onFiber, onRuntimeFiber }) => {\n  if (isRuntimeFiber(self)) {\n    return onRuntimeFiber(self)\n  }\n  return onFiber(self)\n})\n\n/** @internal */\nconst _never = {\n  ...effectable.CommitPrototype,\n  commit() {\n    return join(this)\n  },\n  ...fiberProto,\n  id: () => FiberId.none,\n  await: core.never,\n  children: core.succeed([]),\n  inheritAll: core.never,\n  poll: core.succeed(Option.none()),\n  interruptAsFork: () => core.never\n}\n\n/** @internal */\nexport const never: Fiber.Fiber<never> = _never\n\n/** @internal */\nexport const orElse = dual<\n  <A2, E2>(that: Fiber.Fiber<A2, E2>) => <A, E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<A | A2, E | E2>,\n  <A, E, A2, E2>(self: Fiber.Fiber<A, E>, that: Fiber.Fiber<A2, E2>) => Fiber.Fiber<A | A2, E | E2>\n>(2, (self, that) => ({\n  ...effectable.CommitPrototype,\n  commit() {\n    return join(this)\n  },\n  ...fiberProto,\n  id: () => FiberId.getOrElse(self.id(), that.id()),\n  await: core.zipWith(\n    self.await,\n    that.await,\n    (exit1, exit2) => (Exit.isSuccess(exit1) ? exit1 : exit2)\n  ),\n  children: self.children,\n  inheritAll: core.zipRight(that.inheritAll, self.inheritAll),\n  poll: core.zipWith(\n    self.poll,\n    that.poll,\n    (option1, option2) => {\n      switch (option1._tag) {\n        case \"None\": {\n          return Option.none()\n        }\n        case \"Some\": {\n          return Exit.isSuccess(option1.value) ? option1 : option2\n        }\n      }\n    }\n  ),\n  interruptAsFork: (id) =>\n    pipe(\n      core.interruptAsFiber(self, id),\n      core.zipRight(pipe(that, core.interruptAsFiber(id))),\n      core.asVoid\n    )\n}))\n\n/** @internal */\nexport const orElseEither = dual<\n  <A2, E2>(that: Fiber.Fiber<A2, E2>) => <A, E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<Either.Either<A2, A>, E | E2>,\n  <A, E, A2, E2>(self: Fiber.Fiber<A, E>, that: Fiber.Fiber<A2, E2>) => Fiber.Fiber<Either.Either<A2, A>, E | E2>\n>(2, (self, that) => orElse(map(self, Either.left), map(that, Either.right)))\n\n/** @internal */\nexport const poll = <A, E>(self: Fiber.Fiber<A, E>): Effect.Effect<Option.Option<Exit.Exit<A, E>>> => self.poll\n\n// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js\n// MIT License\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n/** @internal */\nconst parseMs = (milliseconds: number) => {\n  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil\n  return {\n    days: roundTowardsZero(milliseconds / 86400000),\n    hours: roundTowardsZero(milliseconds / 3600000) % 24,\n    minutes: roundTowardsZero(milliseconds / 60000) % 60,\n    seconds: roundTowardsZero(milliseconds / 1000) % 60,\n    milliseconds: roundTowardsZero(milliseconds) % 1000,\n    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,\n    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000\n  }\n}\n\n/** @internal */\nconst renderStatus = (status: FiberStatus.FiberStatus): string => {\n  if (FiberStatus.isDone(status)) {\n    return \"Done\"\n  }\n  if (FiberStatus.isRunning(status)) {\n    return \"Running\"\n  }\n\n  const isInterruptible = runtimeFlags.interruptible(status.runtimeFlags) ?\n    \"interruptible\" :\n    \"uninterruptible\"\n  return `Suspended(${isInterruptible})`\n}\n\n/** @internal */\nexport const pretty = <A, E>(self: Fiber.RuntimeFiber<A, E>): Effect.Effect<string> =>\n  core.flatMap(Clock.currentTimeMillis, (now) =>\n    core.map(dump(self), (dump) => {\n      const time = now - dump.id.startTimeMillis\n      const { days, hours, milliseconds, minutes, seconds } = parseMs(time)\n      const lifeMsg = (days === 0 ? \"\" : `${days}d`) +\n        (days === 0 && hours === 0 ? \"\" : `${hours}h`) +\n        (days === 0 && hours === 0 && minutes === 0 ? \"\" : `${minutes}m`) +\n        (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? \"\" : `${seconds}s`) +\n        `${milliseconds}ms`\n      const waitMsg = FiberStatus.isSuspended(dump.status) ?\n        (() => {\n          const ids = FiberId.ids(dump.status.blockingOn)\n          return HashSet.size(ids) > 0\n            ? `waiting on ` + Array.from(ids).map((id) => `${id}`).join(\", \")\n            : \"\"\n        })() :\n        \"\"\n      const statusMsg = renderStatus(dump.status)\n      return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\\n   Status: ${statusMsg}`\n    }))\n\n/** @internal */\nexport const unsafeRoots = (): Array<Fiber.RuntimeFiber<any, any>> => Array.from(fiberScope.globalScope.roots)\n\n/** @internal */\nexport const roots: Effect.Effect<Array<Fiber.RuntimeFiber<any, any>>> = core.sync(unsafeRoots)\n\n/** @internal */\nexport const status = <A, E>(self: Fiber.RuntimeFiber<A, E>): Effect.Effect<FiberStatus.FiberStatus> => self.status\n\n/** @internal */\nexport const succeed = <A>(value: A): Fiber.Fiber<A> => done(Exit.succeed(value))\n\nconst void_: Fiber.Fiber<void> = succeed(void 0)\nexport {\n  /** @internal */\n  void_ as void\n}\n\n/** @internal */\nexport const currentFiberURI = \"effect/FiberCurrent\"\n\n/** @internal */\nexport const getCurrentFiber = (): Option.Option<Fiber.RuntimeFiber<any, any>> =>\n  Option.fromNullable((globalThis as any)[currentFiberURI])\n","/**\n * @since 2.0.0\n */\nimport type * as Context from \"./Context.js\"\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/clock.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ClockTypeId: unique symbol = internal.ClockTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ClockTypeId = typeof ClockTypeId\n\n/**\n * Represents a time-based clock which provides functionality related to time\n * and scheduling.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Clock {\n  readonly [ClockTypeId]: ClockTypeId\n  /**\n   * Unsafely returns the current time in milliseconds.\n   */\n  unsafeCurrentTimeMillis(): number\n  /**\n   * Returns the current time in milliseconds.\n   */\n  readonly currentTimeMillis: Effect.Effect<number>\n  /**\n   * Unsafely returns the current time in nanoseconds.\n   */\n  unsafeCurrentTimeNanos(): bigint\n  /**\n   * Returns the current time in nanoseconds.\n   */\n  readonly currentTimeNanos: Effect.Effect<bigint>\n  /**\n   * Asynchronously sleeps for the specified duration.\n   */\n  sleep(duration: Duration.Duration): Effect.Effect<void>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type CancelToken = () => boolean\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type Task = () => void\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface ClockScheduler {\n  /**\n   * Unsafely schedules the specified task for the specified duration.\n   */\n  unsafeSchedule(task: Task, duration: Duration.Duration): CancelToken\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (_: void) => Clock = internal.make\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const sleep: (duration: Duration.DurationInput) => Effect.Effect<void> = defaultServices.sleep\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const currentTimeMillis: Effect.Effect<number> = defaultServices.currentTimeMillis\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const currentTimeNanos: Effect.Effect<bigint> = defaultServices.currentTimeNanos\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const clockWith: <A, E, R>(f: (clock: Clock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  defaultServices.clockWith\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const Clock: Context.Tag<Clock, Clock> = internal.clockTag\n","/**\n * @since 2.0.0\n */\nimport type { Chunk } from \"./Chunk.js\"\nimport type { Context } from \"./Context.js\"\nimport type { Either } from \"./Either.js\"\nimport type { Equal } from \"./Equal.js\"\nimport * as Dual from \"./Function.js\"\nimport type { HashMap } from \"./HashMap.js\"\nimport type { HashSet } from \"./HashSet.js\"\nimport * as internal from \"./internal/differ.js\"\nimport * as ChunkPatch from \"./internal/differ/chunkPatch.js\"\nimport * as ContextPatch from \"./internal/differ/contextPatch.js\"\nimport * as HashMapPatch from \"./internal/differ/hashMapPatch.js\"\nimport * as HashSetPatch from \"./internal/differ/hashSetPatch.js\"\nimport * as OrPatch from \"./internal/differ/orPatch.js\"\nimport * as ReadonlyArrayPatch from \"./internal/differ/readonlyArrayPatch.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const TypeId: unique symbol = internal.DifferTypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * A `Differ<Value, Patch>` knows how to compare an old value and new value of\n * type `Value` to produce a patch of type `Patch` that describes the\n * differences between those values. A `Differ` also knows how to apply a patch\n * to an old value to produce a new value that represents the old value updated\n * with the changes described by the patch.\n *\n * A `Differ` can be used to construct a `FiberRef` supporting compositional\n * updates using the `FiberRef.makePatch` constructor.\n *\n * The `Differ` companion object contains constructors for `Differ` values for\n * common data types such as `Chunk`, `HashMap`, and `HashSet``. In addition,\n * `Differ`values can be transformed using the `transform` operator and combined\n * using the `orElseEither` and `zip` operators. This allows creating `Differ`\n * values for arbitrarily complex data types compositionally.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Differ<in out Value, in out Patch> extends Pipeable {\n  readonly [TypeId]: {\n    readonly _V: Types.Invariant<Value>\n    readonly _P: Types.Invariant<Patch>\n  }\n  readonly empty: Patch\n  diff(oldValue: Value, newValue: Value): Patch\n  combine(first: Patch, second: Patch): Patch\n  patch(patch: Patch, oldValue: Value): Value\n}\n\nconst ChunkPatchTypeId: unique symbol = ChunkPatch.ChunkPatchTypeId as Differ.Chunk.TypeId\nconst ContextPatchTypeId: unique symbol = ContextPatch.ContextPatchTypeId as Differ.Context.TypeId\nconst HashMapPatchTypeId: unique symbol = HashMapPatch.HashMapPatchTypeId as Differ.HashMap.TypeId\nconst HashSetPatchTypeId: unique symbol = HashSetPatch.HashSetPatchTypeId as Differ.HashSet.TypeId\nconst OrPatchTypeId: unique symbol = OrPatch.OrPatchTypeId as Differ.Or.TypeId\nconst ReadonlyArrayPatchTypeId: unique symbol = ReadonlyArrayPatch\n  .ReadonlyArrayPatchTypeId as Differ.ReadonlyArray.TypeId\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Differ {\n  /**\n   * @since 2.0.0\n   */\n  export namespace Context {\n    /**\n     * @since 2.0.0\n     * @category symbol\n     */\n    export type TypeId = typeof ContextPatchTypeId\n    /**\n     * A `Patch<Input, Output>` describes an update that transforms a `Env<Input>`\n     * to a `Env<Output>` as a data structure. This allows combining updates to\n     * different services in the environment in a compositional way.\n     *\n     * @since 2.0.0\n     * @category models\n     */\n    export interface Patch<in Input, out Output> extends Equal {\n      readonly [ContextPatchTypeId]: {\n        readonly _Input: Types.Contravariant<Input>\n        readonly _Output: Types.Covariant<Output>\n      }\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export namespace Chunk {\n    /**\n     * @since 2.0.0\n     * @category symbol\n     */\n    export type TypeId = typeof ChunkPatchTypeId\n    /**\n     * A patch which describes updates to a chunk of values.\n     *\n     * @since 2.0.0\n     * @category models\n     */\n    export interface Patch<in out Value, in out Patch> extends Equal {\n      readonly [ChunkPatchTypeId]: {\n        readonly _Value: Types.Invariant<Value>\n        readonly _Patch: Types.Invariant<Patch>\n      }\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export namespace HashMap {\n    /**\n     * @since 2.0.0\n     * @category symbol\n     */\n    export type TypeId = typeof HashMapPatchTypeId\n    /**\n     * A patch which describes updates to a map of keys and values.\n     *\n     * @since 2.0.0\n     * @category models\n     */\n    export interface Patch<in out Key, in out Value, in out Patch> extends Equal {\n      readonly [HashMapPatchTypeId]: {\n        readonly _Key: Types.Invariant<Key>\n        readonly _Value: Types.Invariant<Value>\n        readonly _Patch: Types.Invariant<Patch>\n      }\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export namespace HashSet {\n    /**\n     * @since 2.0.0\n     * @category symbol\n     */\n    export type TypeId = typeof HashSetPatchTypeId\n    /**\n     * A patch which describes updates to a set of values.\n     *\n     * @since 2.0.0\n     * @category models\n     */\n    export interface Patch<in out Value> extends Equal {\n      readonly [HashSetPatchTypeId]: {\n        readonly _Value: Types.Invariant<Value>\n      }\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export namespace Or {\n    /**\n     * @since 2.0.0\n     * @category symbol\n     */\n    export type TypeId = typeof OrPatchTypeId\n    /**\n     * A patch which describes updates to either one value or another.\n     *\n     * @since 2.0.0\n     * @category models\n     */\n    export interface Patch<in out Value, in out Value2, in out Patch, in out Patch2> extends Equal {\n      readonly [OrPatchTypeId]: {\n        readonly _Value: Types.Invariant<Value>\n        readonly _Value2: Types.Invariant<Value2>\n        readonly _Patch: Types.Invariant<Patch>\n        readonly _Patch2: Types.Invariant<Patch2>\n      }\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export namespace ReadonlyArray {\n    /**\n     * @since 2.0.0\n     * @category symbol\n     */\n    export type TypeId = typeof ReadonlyArrayPatchTypeId\n    /**\n     * A patch which describes updates to a ReadonlyArray of values.\n     *\n     * @since 2.0.0\n     * @category models\n     */\n    export interface Patch<in out Value, in out Patch> extends Equal {\n      readonly [ReadonlyArrayPatchTypeId]: {\n        readonly _Value: Types.Invariant<Value>\n        readonly _Patch: Types.Invariant<Patch>\n      }\n    }\n  }\n}\n\n/**\n * An empty patch that describes no changes.\n *\n * @since 2.0.0\n * @category patch\n */\nexport const empty: <Value, Patch>(self: Differ<Value, Patch>) => Patch = (\n  self\n) => self.empty\n\n/**\n * @since 2.0.0\n * @category patch\n */\nexport const diff: {\n  /**\n   * @since 2.0.0\n   * @category patch\n   */\n  <Value>(oldValue: Value, newValue: Value): <Patch>(\n    self: Differ<Value, Patch>\n  ) => Patch\n  /**\n   * @since 2.0.0\n   * @category patch\n   */\n  <Value, Patch>(self: Differ<Value, Patch>, oldValue: Value, newValue: Value): Patch\n} = Dual.dual(\n  3,\n  <Value, Patch>(\n    self: Differ<Value, Patch>,\n    oldValue: Value,\n    newValue: Value\n  ): Patch => self.diff(oldValue, newValue)\n)\n\n/**\n * Combines two patches to produce a new patch that describes the updates of\n * the first patch and then the updates of the second patch. The combine\n * operation should be associative. In addition, if the combine operation is\n * commutative then joining multiple fibers concurrently will result in\n * deterministic `FiberRef` values.\n *\n * @since 2.0.0\n * @category patch\n */\nexport const combine: {\n  /**\n   * Combines two patches to produce a new patch that describes the updates of\n   * the first patch and then the updates of the second patch. The combine\n   * operation should be associative. In addition, if the combine operation is\n   * commutative then joining multiple fibers concurrently will result in\n   * deterministic `FiberRef` values.\n   *\n   * @since 2.0.0\n   * @category patch\n   */\n  <Patch>(first: Patch, second: Patch): <Value>(\n    self: Differ<Value, Patch>\n  ) => Patch\n  /**\n   * Combines two patches to produce a new patch that describes the updates of\n   * the first patch and then the updates of the second patch. The combine\n   * operation should be associative. In addition, if the combine operation is\n   * commutative then joining multiple fibers concurrently will result in\n   * deterministic `FiberRef` values.\n   *\n   * @since 2.0.0\n   * @category patch\n   */\n  <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch\n} = Dual.dual(\n  3,\n  <Value, Patch>(\n    self: Differ<Value, Patch>,\n    first: Patch,\n    second: Patch\n  ): Patch => self.combine(first, second)\n)\n\n/**\n * Applies a patch to an old value to produce a new value that is equal to the\n * old value with the updates described by the patch.\n *\n * @since 2.0.0\n * @category patch\n */\nexport const patch: {\n  /**\n   * Applies a patch to an old value to produce a new value that is equal to the\n   * old value with the updates described by the patch.\n   *\n   * @since 2.0.0\n   * @category patch\n   */\n  <Patch, Value>(patch: Patch, oldValue: Value): (\n    self: Differ<Value, Patch>\n  ) => Value\n  /**\n   * Applies a patch to an old value to produce a new value that is equal to the\n   * old value with the updates described by the patch.\n   *\n   * @since 2.0.0\n   * @category patch\n   */\n  <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value\n} = Dual.dual(\n  3,\n  <Patch, Value>(\n    self: Differ<Value, Patch>,\n    patch: Patch,\n    oldValue: Value\n  ): Value => self.patch(patch, oldValue)\n)\n\n/**\n * Constructs a new `Differ`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Value, Patch>(params: {\n  readonly empty: Patch\n  readonly diff: (oldValue: Value, newValue: Value) => Patch\n  readonly combine: (first: Patch, second: Patch) => Patch\n  readonly patch: (patch: Patch, oldValue: Value) => Value\n}) => Differ<Value, Patch> = internal.make\n\n/**\n * Constructs a differ that knows how to diff `Env` values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const environment: <A>() => Differ<\n  Context<A>,\n  Differ.Context.Patch<A, A>\n> = internal.environment\n\n/**\n * Constructs a differ that knows how to diff a `Chunk` of values given a\n * differ that knows how to diff the values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const chunk: <Value, Patch>(\n  differ: Differ<Value, Patch>\n) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>> = internal.chunk\n\n/**\n * Constructs a differ that knows how to diff a `HashMap` of keys and values given\n * a differ that knows how to diff the values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const hashMap: <Key, Value, Patch>(\n  differ: Differ<Value, Patch>\n) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>> = internal.hashMap\n\n/**\n * Constructs a differ that knows how to diff a `HashSet` of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const hashSet: <Value>() => Differ<\n  HashSet<Value>,\n  Differ.HashSet.Patch<Value>\n> = internal.hashSet\n\n/**\n * Combines this differ and the specified differ to produce a differ that\n * knows how to diff the sum of their values.\n *\n * @since 2.0.0\n */\nexport const orElseEither: {\n  /**\n   * Combines this differ and the specified differ to produce a differ that\n   * knows how to diff the sum of their values.\n   *\n   * @since 2.0.0\n   */\n  <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(\n    self: Differ<Value, Patch>\n  ) => Differ<\n    Either<Value2, Value>,\n    Differ.Or.Patch<Value, Value2, Patch, Patch2>\n  >\n  /**\n   * Combines this differ and the specified differ to produce a differ that\n   * knows how to diff the sum of their values.\n   *\n   * @since 2.0.0\n   */\n  <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<\n    Either<Value2, Value>,\n    Differ.Or.Patch<Value, Value2, Patch, Patch2>\n  >\n} = internal.orElseEither\n\n/**\n * Constructs a differ that knows how to diff a `ReadonlyArray` of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const readonlyArray: <Value, Patch>(\n  differ: Differ<Value, Patch>\n) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>> = internal.readonlyArray\n\n/**\n * Transforms the type of values that this differ knows how to differ using\n * the specified functions that map the new and old value types to each other.\n *\n * @since 2.0.0\n */\nexport const transform: {\n  /**\n   * Transforms the type of values that this differ knows how to differ using\n   * the specified functions that map the new and old value types to each other.\n   *\n   * @since 2.0.0\n   */\n  <Value, Value2>(\n    options: {\n      readonly toNew: (value: Value) => Value2\n      readonly toOld: (value: Value2) => Value\n    }\n  ): <Patch>(self: Differ<Value, Patch>) => Differ<Value2, Patch>\n  /**\n   * Transforms the type of values that this differ knows how to differ using\n   * the specified functions that map the new and old value types to each other.\n   *\n   * @since 2.0.0\n   */\n  <Value, Patch, Value2>(\n    self: Differ<Value, Patch>,\n    options: {\n      readonly toNew: (value: Value) => Value2\n      readonly toOld: (value: Value2) => Value\n    }\n  ): Differ<Value2, Patch>\n} = internal.transform\n\n/**\n * Constructs a differ that just diffs two values by returning a function that\n * sets the value to the new value. This differ does not support combining\n * multiple updates to the value compositionally and should only be used when\n * there is no compositional way to update them.\n *\n * @since 2.0.0\n */\nexport const update: <A>() => Differ<A, (a: A) => A> = internal.update\n\n/**\n * A variant of `update` that allows specifying the function that will be used\n * to combine old values with new values.\n *\n * @since 2.0.0\n */\nexport const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A> = internal.updateWith\n\n/**\n * Combines this differ and the specified differ to produce a new differ that\n * knows how to diff the product of their values.\n *\n * @since 2.0.0\n */\nexport const zip: {\n  /**\n   * Combines this differ and the specified differ to produce a new differ that\n   * knows how to diff the product of their values.\n   *\n   * @since 2.0.0\n   */\n  <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(\n    self: Differ<Value, Patch>\n  ) => Differ<\n    readonly [Value, Value2], // readonly because invariant\n    readonly [Patch, Patch2] // readonly because invariant\n  >\n  /**\n   * Combines this differ and the specified differ to produce a new differ that\n   * knows how to diff the product of their values.\n   *\n   * @since 2.0.0\n   */\n  <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<\n    readonly [Value, Value2], // readonly because invariant\n    readonly [Patch, Patch2] // readonly because invariant\n  >\n} = internal.zip\n","import * as Chunk from \"../../Chunk.js\"\nimport * as Differ from \"../../Differ.js\"\nimport * as Equal from \"../../Equal.js\"\nimport { pipe } from \"../../Function.js\"\nimport * as HashSet from \"../../HashSet.js\"\nimport type * as Supervisor from \"../../Supervisor.js\"\nimport * as supervisor from \"../supervisor.js\"\n\n/** @internal */\nexport type SupervisorPatch = Empty | AddSupervisor | RemoveSupervisor | AndThen\n\n/** @internal */\nexport const OP_EMPTY = \"Empty\" as const\n\n/** @internal */\nexport type OP_EMPTY = typeof OP_EMPTY\n\n/** @internal */\nexport const OP_ADD_SUPERVISOR = \"AddSupervisor\" as const\n\n/** @internal */\nexport type OP_ADD_SUPERVISOR = typeof OP_ADD_SUPERVISOR\n\n/** @internal */\nexport const OP_REMOVE_SUPERVISOR = \"RemoveSupervisor\" as const\n\n/** @internal */\nexport type OP_REMOVE_SUPERVISOR = typeof OP_REMOVE_SUPERVISOR\n\n/** @internal */\nexport const OP_AND_THEN = \"AndThen\" as const\n\n/** @internal */\nexport type OP_AND_THEN = typeof OP_AND_THEN\n\n/** @internal */\nexport interface Empty {\n  readonly _tag: OP_EMPTY\n}\n\n/** @internal */\nexport interface AddSupervisor {\n  readonly _tag: OP_ADD_SUPERVISOR\n  readonly supervisor: Supervisor.Supervisor<any>\n}\n\n/** @internal */\nexport interface RemoveSupervisor {\n  readonly _tag: OP_REMOVE_SUPERVISOR\n  readonly supervisor: Supervisor.Supervisor<any>\n}\n\n/** @internal */\nexport interface AndThen {\n  readonly _tag: OP_AND_THEN\n  readonly first: SupervisorPatch\n  readonly second: SupervisorPatch\n}\n\n/**\n * The empty `SupervisorPatch`.\n *\n * @internal\n */\nexport const empty: SupervisorPatch = { _tag: OP_EMPTY }\n\n/**\n * Combines two patches to produce a new patch that describes applying the\n * updates from this patch and then the updates from the specified patch.\n *\n * @internal\n */\nexport const combine = (self: SupervisorPatch, that: SupervisorPatch): SupervisorPatch => {\n  return {\n    _tag: OP_AND_THEN,\n    first: self,\n    second: that\n  }\n}\n\n/**\n * Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.\n *\n * @internal\n */\nexport const patch = (\n  self: SupervisorPatch,\n  supervisor: Supervisor.Supervisor<any>\n): Supervisor.Supervisor<any> => {\n  return patchLoop(supervisor, Chunk.of(self))\n}\n\n/** @internal */\nconst patchLoop = (\n  _supervisor: Supervisor.Supervisor<any>,\n  _patches: Chunk.Chunk<SupervisorPatch>\n): Supervisor.Supervisor<any> => {\n  let supervisor = _supervisor\n  let patches = _patches\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches)\n    switch (head._tag) {\n      case OP_EMPTY: {\n        patches = Chunk.tailNonEmpty(patches)\n        break\n      }\n      case OP_ADD_SUPERVISOR: {\n        supervisor = supervisor.zip(head.supervisor)\n        patches = Chunk.tailNonEmpty(patches)\n        break\n      }\n      case OP_REMOVE_SUPERVISOR: {\n        supervisor = removeSupervisor(supervisor, head.supervisor)\n        patches = Chunk.tailNonEmpty(patches)\n        break\n      }\n      case OP_AND_THEN: {\n        patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(Chunk.tailNonEmpty(patches)))\n        break\n      }\n    }\n  }\n  return supervisor\n}\n\n/** @internal */\nconst removeSupervisor = (\n  self: Supervisor.Supervisor<any>,\n  that: Supervisor.Supervisor<any>\n): Supervisor.Supervisor<any> => {\n  if (Equal.equals(self, that)) {\n    return supervisor.none\n  } else {\n    if (supervisor.isZip(self)) {\n      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that))\n    } else {\n      return self\n    }\n  }\n}\n\n/** @internal */\nconst toSet = (self: Supervisor.Supervisor<any>): HashSet.HashSet<Supervisor.Supervisor<any>> => {\n  if (Equal.equals(self, supervisor.none)) {\n    return HashSet.empty()\n  } else {\n    if (supervisor.isZip(self)) {\n      return pipe(toSet(self.left), HashSet.union(toSet(self.right)))\n    } else {\n      return HashSet.make(self)\n    }\n  }\n}\n\n/** @internal */\nexport const diff = (\n  oldValue: Supervisor.Supervisor<any>,\n  newValue: Supervisor.Supervisor<any>\n): SupervisorPatch => {\n  if (Equal.equals(oldValue, newValue)) {\n    return empty\n  }\n  const oldSupervisors = toSet(oldValue)\n  const newSupervisors = toSet(newValue)\n  const added = pipe(\n    newSupervisors,\n    HashSet.difference(oldSupervisors),\n    HashSet.reduce(\n      empty as SupervisorPatch,\n      (patch, supervisor) => combine(patch, { _tag: OP_ADD_SUPERVISOR, supervisor })\n    )\n  )\n  const removed = pipe(\n    oldSupervisors,\n    HashSet.difference(newSupervisors),\n    HashSet.reduce(\n      empty as SupervisorPatch,\n      (patch, supervisor) => combine(patch, { _tag: OP_REMOVE_SUPERVISOR, supervisor })\n    )\n  )\n  return combine(added, removed)\n}\n\n/** @internal */\nexport const differ = Differ.make<Supervisor.Supervisor<any>, SupervisorPatch>({\n  empty,\n  patch,\n  combine,\n  diff\n})\n","import type * as MetricKey from \"../../MetricKey.js\"\nimport type * as MetricKeyType from \"../../MetricKeyType.js\"\nimport type * as MetricPair from \"../../MetricPair.js\"\nimport type * as MetricState from \"../../MetricState.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\n\n/** @internal */\nconst MetricPairSymbolKey = \"effect/MetricPair\"\n\n/** @internal */\nexport const MetricPairTypeId: MetricPair.MetricPairTypeId = Symbol.for(\n  MetricPairSymbolKey\n) as MetricPair.MetricPairTypeId\n\nconst metricPairVariance = {\n  /* c8 ignore next */\n  _Type: (_: never) => _\n}\n\n/** @internal */\nexport const make = <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  metricKey: MetricKey.MetricKey<Type>,\n  metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>\n): MetricPair.MetricPair.Untyped => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState,\n    pipe() {\n      return pipeArguments(this, arguments)\n    }\n  }\n}\n\n/** @internal */\nexport const unsafeMake = <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  metricKey: MetricKey.MetricKey<Type>,\n  metricState: MetricState.MetricState.Untyped\n): MetricPair.MetricPair.Untyped => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState,\n    pipe() {\n      return pipeArguments(this, arguments)\n    }\n  }\n}\n","import { pipe } from \"../../Function.js\"\nimport type * as MetricHook from \"../../MetricHook.js\"\nimport type * as MetricKey from \"../../MetricKey.js\"\nimport type * as MetricKeyType from \"../../MetricKeyType.js\"\nimport type * as MetricPair from \"../../MetricPair.js\"\nimport type * as MetricRegistry from \"../../MetricRegistry.js\"\nimport * as MutableHashMap from \"../../MutableHashMap.js\"\nimport * as Option from \"../../Option.js\"\nimport * as metricHook from \"./hook.js\"\nimport * as metricKeyType from \"./keyType.js\"\nimport * as metricPair from \"./pair.js\"\n\n/** @internal */\nconst MetricRegistrySymbolKey = \"effect/MetricRegistry\"\n\n/** @internal */\nexport const MetricRegistryTypeId: MetricRegistry.MetricRegistryTypeId = Symbol.for(\n  MetricRegistrySymbolKey\n) as MetricRegistry.MetricRegistryTypeId\n\n/** @internal */\nclass MetricRegistryImpl implements MetricRegistry.MetricRegistry {\n  readonly [MetricRegistryTypeId]: MetricRegistry.MetricRegistryTypeId = MetricRegistryTypeId\n\n  private map = MutableHashMap.empty<\n    MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>,\n    MetricHook.MetricHook.Root\n  >()\n\n  snapshot(): Array<MetricPair.MetricPair.Untyped> {\n    const result: Array<MetricPair.MetricPair.Untyped> = []\n    for (const [key, hook] of this.map) {\n      result.push(metricPair.unsafeMake(key, hook.get()))\n    }\n    return result\n  }\n\n  get<Type extends MetricKeyType.MetricKeyType<any, any>>(\n    key: MetricKey.MetricKey<Type>\n  ): MetricHook.MetricHook<\n    MetricKeyType.MetricKeyType.InType<typeof key[\"keyType\"]>,\n    MetricKeyType.MetricKeyType.OutType<typeof key[\"keyType\"]>\n  > {\n    const hook = pipe(\n      this.map,\n      MutableHashMap.get(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>),\n      Option.getOrUndefined\n    )\n    if (hook == null) {\n      if (metricKeyType.isCounterKey(key.keyType)) {\n        return this.getCounter(key as unknown as MetricKey.MetricKey.Counter<any>) as any\n      }\n      if (metricKeyType.isGaugeKey(key.keyType)) {\n        return this.getGauge(key as unknown as MetricKey.MetricKey.Gauge<any>) as any\n      }\n      if (metricKeyType.isFrequencyKey(key.keyType)) {\n        return this.getFrequency(key as unknown as MetricKey.MetricKey.Frequency) as any\n      }\n      if (metricKeyType.isHistogramKey(key.keyType)) {\n        return this.getHistogram(key as unknown as MetricKey.MetricKey.Histogram) as any\n      }\n      if (metricKeyType.isSummaryKey(key.keyType)) {\n        return this.getSummary(key as unknown as MetricKey.MetricKey.Summary) as any\n      }\n      throw new Error(\n        \"BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues\"\n      )\n    } else {\n      return hook as any\n    }\n  }\n\n  getCounter<A extends (number | bigint)>(key: MetricKey.MetricKey.Counter<A>): MetricHook.MetricHook.Counter<A> {\n    let value = pipe(\n      this.map,\n      MutableHashMap.get(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>),\n      Option.getOrUndefined\n    )\n    if (value == null) {\n      const counter = metricHook.counter(key)\n      if (!pipe(this.map, MutableHashMap.has(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>))) {\n        pipe(\n          this.map,\n          MutableHashMap.set(\n            key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>,\n            counter as MetricHook.MetricHook.Root\n          )\n        )\n      }\n      value = counter\n    }\n    return value as MetricHook.MetricHook.Counter<A>\n  }\n\n  getFrequency(key: MetricKey.MetricKey.Frequency): MetricHook.MetricHook.Frequency {\n    let value = pipe(\n      this.map,\n      MutableHashMap.get(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>),\n      Option.getOrUndefined\n    )\n    if (value == null) {\n      const frequency = metricHook.frequency(key)\n      if (!pipe(this.map, MutableHashMap.has(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>))) {\n        pipe(\n          this.map,\n          MutableHashMap.set(\n            key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>,\n            frequency as MetricHook.MetricHook.Root\n          )\n        )\n      }\n      value = frequency\n    }\n    return value as MetricHook.MetricHook.Frequency\n  }\n\n  getGauge<A extends (number | bigint)>(key: MetricKey.MetricKey.Gauge<A>): MetricHook.MetricHook.Gauge<A> {\n    let value = pipe(\n      this.map,\n      MutableHashMap.get(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>),\n      Option.getOrUndefined\n    )\n    if (value == null) {\n      const gauge = metricHook.gauge(key as any, key.keyType.bigint ? BigInt(0) as any : 0)\n      if (!pipe(this.map, MutableHashMap.has(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>))) {\n        pipe(\n          this.map,\n          MutableHashMap.set(\n            key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>,\n            gauge as MetricHook.MetricHook.Root\n          )\n        )\n      }\n      value = gauge\n    }\n    return value as MetricHook.MetricHook.Gauge<A>\n  }\n\n  getHistogram(key: MetricKey.MetricKey.Histogram): MetricHook.MetricHook.Histogram {\n    let value = pipe(\n      this.map,\n      MutableHashMap.get(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>),\n      Option.getOrUndefined\n    )\n    if (value == null) {\n      const histogram = metricHook.histogram(key)\n      if (!pipe(this.map, MutableHashMap.has(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>))) {\n        pipe(\n          this.map,\n          MutableHashMap.set(\n            key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>,\n            histogram as MetricHook.MetricHook.Root\n          )\n        )\n      }\n      value = histogram\n    }\n    return value as MetricHook.MetricHook.Histogram\n  }\n\n  getSummary(key: MetricKey.MetricKey.Summary): MetricHook.MetricHook.Summary {\n    let value = pipe(\n      this.map,\n      MutableHashMap.get(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>),\n      Option.getOrUndefined\n    )\n    if (value == null) {\n      const summary = metricHook.summary(key)\n      if (!pipe(this.map, MutableHashMap.has(key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>))) {\n        pipe(\n          this.map,\n          MutableHashMap.set(\n            key as MetricKey.MetricKey<MetricKeyType.MetricKeyType.Untyped>,\n            summary as MetricHook.MetricHook.Root\n          )\n        )\n      }\n      value = summary\n    }\n    return value as MetricHook.MetricHook.Summary\n  }\n}\n\n/** @internal */\nexport const make = (): MetricRegistry.MetricRegistry => {\n  return new MetricRegistryImpl()\n}\n","import type * as Cause from \"../Cause.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { dual } from \"../Function.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as Types from \"../Types.js\"\nimport * as completedRequestMap from \"./completedRequestMap.js\"\nimport * as core from \"./core.js\"\nimport { StructuralPrototype } from \"./effectable.js\"\n\n/** @internal */\nconst RequestSymbolKey = \"effect/Request\"\n\n/** @internal */\nexport const RequestTypeId: Request.RequestTypeId = Symbol.for(\n  RequestSymbolKey\n) as Request.RequestTypeId\n\nconst requestVariance = {\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: never) => _\n}\n\nconst RequestPrototype = {\n  ...StructuralPrototype,\n  [RequestTypeId]: requestVariance\n}\n\n/** @internal */\nexport const isRequest = (u: unknown): u is Request.Request<unknown, unknown> => hasProperty(u, RequestTypeId)\n\n/** @internal */\nexport const of = <R extends Request.Request<any, any>>(): Request.Request.Constructor<R> => (args) =>\n  Object.assign(Object.create(RequestPrototype), args)\n\n/** @internal */\nexport const tagged = <R extends Request.Request<any, any> & { _tag: string }>(\n  tag: R[\"_tag\"]\n): Request.Request.Constructor<R, \"_tag\"> =>\n(args) => {\n  const request = Object.assign(Object.create(RequestPrototype), args)\n  request._tag = tag\n  return request\n}\n\n/** @internal */\nexport const Class: new<Success, Error, A extends Record<string, any>>(\n  args: Types.Equals<Omit<A, keyof Request.Request<unknown, unknown>>, {}> extends true ? void\n    : { readonly [P in keyof A as P extends keyof Request.Request<unknown, unknown> ? never : P]: A[P] }\n) => Request.Request<Success, Error> & Readonly<A> = (function() {\n  function Class(this: any, args: any) {\n    if (args) {\n      Object.assign(this, args)\n    }\n  }\n  Class.prototype = RequestPrototype\n  return Class as any\n})()\n\n/** @internal */\nexport const TaggedClass = <Tag extends string>(\n  tag: Tag\n): new<Success, Error, A extends Record<string, any>>(\n  args: Types.Equals<Omit<A, keyof Request.Request<unknown, unknown>>, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" | keyof Request.Request<unknown, unknown> ? never : P]: A[P] }\n) => Request.Request<Success, Error> & Readonly<A> & { readonly _tag: Tag } => {\n  return class TaggedClass extends Class<any, any, any> {\n    readonly _tag = tag\n  } as any\n}\n\n/** @internal */\nexport const complete = dual<\n  <A extends Request.Request<any, any>>(\n    result: Request.Request.Result<A>\n  ) => (self: A) => Effect.Effect<void>,\n  <A extends Request.Request<any, any>>(\n    self: A,\n    result: Request.Request.Result<A>\n  ) => Effect.Effect<void>\n>(2, (self, result) =>\n  core.fiberRefGetWith(\n    completedRequestMap.currentRequestMap,\n    (map) =>\n      core.sync(() => {\n        if (map.has(self)) {\n          const entry = map.get(self)!\n          if (!entry.state.completed) {\n            entry.state.completed = true\n            core.deferredUnsafeDone(entry.result, result)\n          }\n        }\n      })\n  ))\n\n/** @internal */\nexport const completeEffect = dual<\n  <A extends Request.Request<any, any>, R>(\n    effect: Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>\n  ) => (self: A) => Effect.Effect<void, never, R>,\n  <A extends Request.Request<any, any>, R>(\n    self: A,\n    effect: Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>\n  ) => Effect.Effect<void, never, R>\n>(2, (self, effect) =>\n  core.matchEffect(effect, {\n    onFailure: (error) => complete(self, core.exitFail(error) as any),\n    onSuccess: (value) => complete(self, core.exitSucceed(value) as any)\n  }))\n\n/** @internal */\nexport const fail = dual<\n  <A extends Request.Request<any, any>>(\n    error: Request.Request.Error<A>\n  ) => (self: A) => Effect.Effect<void>,\n  <A extends Request.Request<any, any>>(\n    self: A,\n    error: Request.Request.Error<A>\n  ) => Effect.Effect<void>\n>(2, (self, error) => complete(self, core.exitFail(error) as any))\n\n/** @internal */\nexport const failCause = dual<\n  <A extends Request.Request<any, any>>(\n    cause: Cause.Cause<Request.Request.Error<A>>\n  ) => (self: A) => Effect.Effect<void>,\n  <A extends Request.Request<any, any>>(\n    self: A,\n    cause: Cause.Cause<Request.Request.Error<A>>\n  ) => Effect.Effect<void>\n>(2, (self, cause) => complete(self, core.exitFailCause(cause) as any))\n\n/** @internal */\nexport const succeed = dual<\n  <A extends Request.Request<any, any>>(\n    value: Request.Request.Success<A>\n  ) => (self: A) => Effect.Effect<void>,\n  <A extends Request.Request<any, any>>(\n    self: A,\n    value: Request.Request.Success<A>\n  ) => Effect.Effect<void>\n>(2, (self, value) => complete(self, core.exitSucceed(value) as any))\n\n/** @internal */\nexport class Listeners {\n  count = 0\n  observers: Set<(count: number) => void> = new Set()\n  interrupted = false\n  addObserver(f: (count: number) => void): void {\n    this.observers.add(f)\n  }\n  removeObserver(f: (count: number) => void): void {\n    this.observers.delete(f)\n  }\n  increment() {\n    this.count++\n    this.observers.forEach((f) => f(this.count))\n  }\n  decrement() {\n    this.count--\n    this.observers.forEach((f) => f(this.count))\n  }\n}\n\n/**\n * @internal\n */\nexport const filterOutCompleted = <A extends Request.Request<any, any>>(requests: Array<A>) =>\n  core.fiberRefGetWith(\n    completedRequestMap.currentRequestMap,\n    (map) =>\n      core.succeed(\n        requests.filter((request) => !(map.get(request)?.state.completed === true))\n      )\n  )\n","import type * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport { pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport type * as Option from \"../Option.js\"\nimport { hasProperty, isTagged } from \"../Predicate.js\"\nimport * as SortedSet from \"../SortedSet.js\"\nimport type * as Supervisor from \"../Supervisor.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nconst SupervisorSymbolKey = \"effect/Supervisor\"\n\n/** @internal */\nexport const SupervisorTypeId: Supervisor.SupervisorTypeId = Symbol.for(\n  SupervisorSymbolKey\n) as Supervisor.SupervisorTypeId\n\n/** @internal */\nexport const supervisorVariance = {\n  /* c8 ignore next */\n  _T: (_: never) => _\n}\n\n/** @internal */\nexport class ProxySupervisor<out T> implements Supervisor.Supervisor<T> {\n  readonly [SupervisorTypeId] = supervisorVariance\n\n  constructor(\n    readonly underlying: Supervisor.Supervisor<any>,\n    readonly value0: Effect.Effect<T>\n  ) {\n  }\n\n  get value(): Effect.Effect<T> {\n    return this.value0\n  }\n\n  onStart<A, E, R>(\n    context: Context.Context<R>,\n    effect: Effect.Effect<A, E, R>,\n    parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    this.underlying.onStart(context, effect, parent, fiber)\n  }\n\n  onEnd<A, E>(value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.underlying.onEnd(value, fiber)\n  }\n\n  onEffect<A, E>(fiber: Fiber.RuntimeFiber<A, E>, effect: Effect.Effect<any, any, any>): void {\n    this.underlying.onEffect(fiber, effect)\n  }\n\n  onSuspend<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.underlying.onSuspend(fiber)\n  }\n\n  onResume<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.underlying.onResume(fiber)\n  }\n\n  map<B>(f: (a: T) => B): Supervisor.Supervisor<B> {\n    return new ProxySupervisor(this, pipe(this.value, core.map(f)))\n  }\n\n  zip<B>(right: Supervisor.Supervisor<B>): Supervisor.Supervisor<[T, B]> {\n    return new Zip(this, right)\n  }\n}\n\n/** @internal */\nexport class Zip<out T0, out T1> implements Supervisor.Supervisor<readonly [T0, T1]> {\n  readonly _tag = \"Zip\"\n  readonly [SupervisorTypeId] = supervisorVariance\n\n  constructor(\n    readonly left: Supervisor.Supervisor<T0>,\n    readonly right: Supervisor.Supervisor<T1>\n  ) {\n  }\n\n  get value(): Effect.Effect<[T0, T1]> {\n    return core.zip(this.left.value, this.right.value)\n  }\n\n  onStart<A, E, R>(\n    context: Context.Context<R>,\n    effect: Effect.Effect<A, E, R>,\n    parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    this.left.onStart(context, effect, parent, fiber)\n    this.right.onStart(context, effect, parent, fiber)\n  }\n\n  onEnd<A, E>(value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.left.onEnd(value, fiber)\n    this.right.onEnd(value, fiber)\n  }\n\n  onEffect<A, E>(fiber: Fiber.RuntimeFiber<A, E>, effect: Effect.Effect<any, any, any>): void {\n    this.left.onEffect(fiber, effect)\n    this.right.onEffect(fiber, effect)\n  }\n\n  onSuspend<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.left.onSuspend(fiber)\n    this.right.onSuspend(fiber)\n  }\n\n  onResume<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.left.onResume(fiber)\n    this.right.onResume(fiber)\n  }\n\n  map<B>(f: (a: [T0, T1]) => B): Supervisor.Supervisor<B> {\n    return new ProxySupervisor(this, pipe(this.value, core.map(f)))\n  }\n\n  zip<A>(right: Supervisor.Supervisor<A>): Supervisor.Supervisor<[[T0, T1], A]> {\n    return new Zip(this, right)\n  }\n}\n\n/** @internal */\nexport const isZip = (self: unknown): self is Zip<any, any> =>\n  hasProperty(self, SupervisorTypeId) && isTagged(self, \"Zip\")\n\n/** @internal */\nexport class Track implements Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>> {\n  readonly [SupervisorTypeId] = supervisorVariance\n\n  readonly fibers: Set<Fiber.RuntimeFiber<any, any>> = new Set()\n\n  get value(): Effect.Effect<Array<Fiber.RuntimeFiber<any, any>>> {\n    return core.sync(() => Array.from(this.fibers))\n  }\n\n  onStart<A, E, R>(\n    _context: Context.Context<R>,\n    _effect: Effect.Effect<A, E, R>,\n    _parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    this.fibers.add(fiber)\n  }\n\n  onEnd<A, E>(_value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void {\n    this.fibers.delete(fiber)\n  }\n\n  onEffect<A, E>(_fiber: Fiber.RuntimeFiber<A, E>, _effect: Effect.Effect<any, any, any>): void {\n    //\n  }\n\n  onSuspend<A, E>(_fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  onResume<A, E>(_fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  map<B>(f: (a: Array<Fiber.RuntimeFiber<any, any>>) => B): Supervisor.Supervisor<B> {\n    return new ProxySupervisor(this, pipe(this.value, core.map(f)))\n  }\n\n  zip<A>(\n    right: Supervisor.Supervisor<A>\n  ): Supervisor.Supervisor<[Array<Fiber.RuntimeFiber<any, any>>, A]> {\n    return new Zip(this, right)\n  }\n\n  onRun<E, A, X>(execution: () => X, _fiber: Fiber.RuntimeFiber<A, E>): X {\n    return execution()\n  }\n}\n\n/** @internal */\nexport class Const<out T> implements Supervisor.Supervisor<T> {\n  readonly [SupervisorTypeId] = supervisorVariance\n\n  constructor(readonly effect: Effect.Effect<T>) {\n  }\n\n  get value(): Effect.Effect<T> {\n    return this.effect\n  }\n\n  onStart<A, E, R>(\n    _context: Context.Context<R>,\n    _effect: Effect.Effect<A, E, R>,\n    _parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    _fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    //\n  }\n\n  onEnd<A, E>(_value: Exit.Exit<A, E>, _fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  onEffect<A, E>(_fiber: Fiber.RuntimeFiber<A, E>, _effect: Effect.Effect<any, any, any>): void {\n    //\n  }\n\n  onSuspend<A, E>(_fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  onResume<A, E>(_fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  map<B>(f: (a: T) => B): Supervisor.Supervisor<B> {\n    return new ProxySupervisor(this, pipe(this.value, core.map(f)))\n  }\n\n  zip<A>(right: Supervisor.Supervisor<A>): Supervisor.Supervisor<[T, A]> {\n    return new Zip(this, right)\n  }\n\n  onRun<E, A, X>(execution: () => X, _fiber: Fiber.RuntimeFiber<A, E>): X {\n    return execution()\n  }\n}\n\nclass FibersIn implements Supervisor.Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>> {\n  readonly [SupervisorTypeId] = supervisorVariance\n\n  constructor(readonly ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>) {\n  }\n\n  get value(): Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>> {\n    return core.sync(() => MutableRef.get(this.ref))\n  }\n\n  onStart<A, E, R>(\n    _context: Context.Context<R>,\n    _effect: Effect.Effect<A, E, R>,\n    _parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    pipe(this.ref, MutableRef.set(pipe(MutableRef.get(this.ref), SortedSet.add(fiber))))\n  }\n\n  onEnd<A, E>(_value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void {\n    pipe(this.ref, MutableRef.set(pipe(MutableRef.get(this.ref), SortedSet.remove(fiber))))\n  }\n\n  onEffect<A, E>(_fiber: Fiber.RuntimeFiber<A, E>, _effect: Effect.Effect<any, any, any>): void {\n    //\n  }\n\n  onSuspend<A, E>(_fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  onResume<A, E>(_fiber: Fiber.RuntimeFiber<A, E>): void {\n    //\n  }\n\n  map<B>(f: (a: SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>) => B): Supervisor.Supervisor<B> {\n    return new ProxySupervisor(this, pipe(this.value, core.map(f)))\n  }\n\n  zip<A>(\n    right: Supervisor.Supervisor<A>\n  ): Supervisor.Supervisor<[SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>, A]> {\n    return new Zip(this, right)\n  }\n\n  onRun<E, A, X>(execution: () => X, _fiber: Fiber.RuntimeFiber<A, E>): X {\n    return execution()\n  }\n}\n\n/** @internal */\nexport const unsafeTrack = (): Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>> => {\n  return new Track()\n}\n\n/** @internal */\nexport const track: Effect.Effect<Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>> = core.sync(unsafeTrack)\n\n/** @internal */\nexport const fromEffect = <A>(effect: Effect.Effect<A>): Supervisor.Supervisor<A> => {\n  return new Const(effect)\n}\n\n/** @internal */\nexport const none = globalValue(\"effect/Supervisor/none\", () => fromEffect(core.void))\n\n/** @internal */\nexport const fibersIn = (\n  ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<Supervisor.Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>> =>\n  core.sync(() => new FibersIn(ref))\n","/** @internal */\nexport const Color = {\n  Red: 0 as Node.Color,\n  Black: 1 << 0 as Node.Color\n} as const\n\nexport declare namespace Node {\n  export type Color = number & {\n    readonly Color: unique symbol\n  }\n}\n\nexport interface Node<out K, out V> {\n  color: Node.Color\n  key: K\n  value: V\n  left: Node<K, V> | undefined\n  right: Node<K, V> | undefined\n  count: number\n}\n\n/** @internal */\nexport const clone = <K, V>({\n  color,\n  count,\n  key,\n  left,\n  right,\n  value\n}: Node<K, V>) => ({\n  color,\n  key,\n  value,\n  left,\n  right,\n  count\n})\n\n/** @internal */\nexport function swap<K, V>(n: Node<K, V>, v: Node<K, V>) {\n  n.key = v.key\n  n.value = v.value\n  n.left = v.left\n  n.right = v.right\n  n.color = v.color\n  n.count = v.count\n}\n\n/** @internal */\nexport const repaint = <K, V>({\n  count,\n  key,\n  left,\n  right,\n  value\n}: Node<K, V>, color: Node.Color) => ({\n  color,\n  key,\n  value,\n  left,\n  right,\n  count\n})\n\n/** @internal */\nexport const recount = <K, V>(node: Node<K, V>) => {\n  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0)\n}\n","import type * as LogSpan from \"../LogSpan.js\"\n\n/** @internal */\nexport const make = (label: string, startTime: number): LogSpan.LogSpan => ({\n  label,\n  startTime\n})\n\n/**\n * Sanitize a given string by replacing spaces, equal signs, and double quotes with underscores.\n *\n * @internal\n */\nexport const formatLabel = (key: string) => key.replace(/[\\s=\"]/g, \"_\")\n\n/** @internal */\nexport const render = (now: number) => (self: LogSpan.LogSpan): string => {\n  const label = formatLabel(self.label)\n  return `${label}=${now - self.startTime}ms`\n}\n","import type * as Cause from \"../Cause.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type * as FiberStatus from \"../FiberStatus.js\"\nimport type * as FiberRuntime from \"./fiberRuntime.js\"\n\n/** @internal */\nexport type FiberMessage = InterruptSignal | Stateful | Resume | YieldNow\n\n/** @internal */\nexport const OP_INTERRUPT_SIGNAL = \"InterruptSignal\" as const\n\n/** @internal */\nexport type OP_INTERRUPT_SIGNAL = typeof OP_INTERRUPT_SIGNAL\n\n/** @internal */\nexport const OP_STATEFUL = \"Stateful\" as const\n\n/** @internal */\nexport type OP_STATEFUL = typeof OP_STATEFUL\n\n/** @internal */\nexport const OP_RESUME = \"Resume\" as const\n\n/** @internal */\nexport type OP_RESUME = typeof OP_RESUME\n\n/** @internal */\nexport const OP_YIELD_NOW = \"YieldNow\" as const\n\n/** @internal */\nexport type OP_YIELD_NOW = typeof OP_YIELD_NOW\n\n/** @internal */\nexport interface InterruptSignal {\n  readonly _tag: OP_INTERRUPT_SIGNAL\n  readonly cause: Cause.Cause<never>\n}\n\n/** @internal */\nexport interface Stateful {\n  readonly _tag: OP_STATEFUL\n  onFiber(fiber: FiberRuntime.FiberRuntime<any, any>, status: FiberStatus.FiberStatus): void\n}\n\n/** @internal */\nexport interface Resume {\n  readonly _tag: OP_RESUME\n  readonly effect: Effect.Effect<any, any, any>\n}\n\n/** @internal */\nexport interface YieldNow {\n  readonly _tag: OP_YIELD_NOW\n}\n\n/** @internal */\nexport const interruptSignal = (cause: Cause.Cause<never>): FiberMessage => ({\n  _tag: OP_INTERRUPT_SIGNAL,\n  cause\n})\n\n/** @internal */\nexport const stateful = (\n  onFiber: (\n    fiber: FiberRuntime.FiberRuntime<any, any>,\n    status: FiberStatus.FiberStatus\n  ) => void\n): FiberMessage => ({\n  _tag: OP_STATEFUL,\n  onFiber\n})\n\n/** @internal */\nexport const resume = (effect: Effect.Effect<any, any, any>): FiberMessage => ({\n  _tag: OP_RESUME,\n  effect\n})\n\n/** @internal */\nexport const yieldNow = (): FiberMessage => ({\n  _tag: OP_YIELD_NOW\n})\n","/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\"\nimport type * as Equivalence from \"./Equivalence.js\"\nimport * as Dual from \"./Function.js\"\nimport { pipe } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport type { Order } from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport type { Predicate } from \"./Predicate.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport * as RBT from \"./RedBlackTree.js\"\nimport type { Invariant, NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/SortedSet\")\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface SortedSet<in out A> extends Iterable<A>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _A: Invariant<A>\n  }\n  /** @internal */\n  readonly keyTree: RBT.RedBlackTree<A, boolean>\n}\n\nconst SortedSetProto: Omit<SortedSet<unknown>, \"keyTree\"> = {\n  [TypeId]: {\n    _A: (_: any) => _\n  },\n  [Hash.symbol]<A>(this: SortedSet<A>): number {\n    return pipe(\n      Hash.hash(this.keyTree),\n      Hash.combine(Hash.hash(TypeId)),\n      Hash.cached(this)\n    )\n  },\n  [Equal.symbol]<A>(this: SortedSet<A>, that: unknown): boolean {\n    return isSortedSet(that) && Equal.equals(this.keyTree, that.keyTree)\n  },\n  [Symbol.iterator]<A>(this: SortedSet<A>): Iterator<A> {\n    return RBT.keys(this.keyTree)\n  },\n  toString<A>(this: SortedSet<A>) {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"SortedSet\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst fromTree = <A>(keyTree: RBT.RedBlackTree<A, boolean>): SortedSet<A> => {\n  const a = Object.create(SortedSetProto)\n  a.keyTree = keyTree\n  return a\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSortedSet: {\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  <A>(u: Iterable<A>): u is SortedSet<A>\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  (u: unknown): u is SortedSet<unknown>\n} = (u: unknown): u is SortedSet<unknown> => hasProperty(u, TypeId)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = <A>(O: Order<A>): SortedSet<A> => fromTree(RBT.empty(O))\n\n/**\n * Creates a new `SortedSet` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: {\n  /**\n   * Creates a new `SortedSet` from an iterable collection of values.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>\n  /**\n   * Creates a new `SortedSet` from an iterable collection of values.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>\n} = Dual.dual(\n  2,\n  <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A> =>\n    fromTree(RBT.fromIterable(Array.from(iterable).map((k) => [k, true]), ord))\n)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make =\n  <K>(ord: Order<K>) => <Entries extends ReadonlyArray<K>>(...entries: Entries): SortedSet<Entries[number]> =>\n    fromIterable(entries, ord)\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const add: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, value: A): SortedSet<A>\n} = Dual.dual<\n  <A>(value: A) => (self: SortedSet<A>) => SortedSet<A>,\n  <A>(self: SortedSet<A>, value: A) => SortedSet<A>\n>(2, (self, value) =>\n  RBT.has(self.keyTree, value)\n    ? self\n    : fromTree(RBT.insert(self.keyTree, value, true)))\n\n/**\n * @since 2.0.0\n */\nexport const difference: {\n  /**\n   * @since 2.0.0\n   */\n  <A, B extends A>(that: Iterable<B>): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   */\n  <A, B extends A>(self: SortedSet<A>, that: Iterable<B>): SortedSet<A>\n} = Dual.dual<\n  <A, B extends A>(that: Iterable<B>) => (self: SortedSet<A>) => SortedSet<A>,\n  <A, B extends A>(self: SortedSet<A>, that: Iterable<B>) => SortedSet<A>\n>(2, <A, B extends A>(self: SortedSet<A>, that: Iterable<B>) => {\n  let out = self\n  for (const value of that) {\n    out = remove<A | B>(out, value)\n  }\n  return out\n})\n\n/**\n * Check if a predicate holds true for every `SortedSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every: {\n  /**\n   * Check if a predicate holds true for every `SortedSet` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean\n  /**\n   * Check if a predicate holds true for every `SortedSet` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean\n} = Dual.dual(2, <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean => {\n  for (const value of self) {\n    if (!predicate(value)) {\n      return false\n    }\n  }\n  return true\n})\n\n/**\n * @since 2.0.0\n * @category filtering\n */\nexport const filter: {\n  /**\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(predicate: Predicate<B>): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(self: SortedSet<A>, predicate: Predicate<A>): SortedSet<A>\n} = Dual.dual(2, <A>(self: SortedSet<A>, predicate: Predicate<A>): SortedSet<A> => {\n  const ord = RBT.getOrder(self.keyTree)\n  let out = empty<A>(ord)\n  for (const value of self) {\n    if (predicate(value)) {\n      out = add(out, value)\n    }\n  }\n  return out\n})\n\n/**\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <B, A>(O: Order<B>, f: (a: A) => Iterable<B>): (self: SortedSet<A>) => SortedSet<B>\n  /**\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, B>(self: SortedSet<A>, O: Order<B>, f: (a: A) => Iterable<B>): SortedSet<B>\n} = Dual.dual<\n  <B, A>(O: Order<B>, f: (a: A) => Iterable<B>) => (self: SortedSet<A>) => SortedSet<B>,\n  <A, B>(self: SortedSet<A>, O: Order<B>, f: (a: A) => Iterable<B>) => SortedSet<B>\n>(3, (self, O, f) => {\n  let out = empty(O)\n  forEach(self, (a) => {\n    for (const b of f(a)) {\n      out = add(out, b)\n    }\n  })\n  return out\n})\n\n/**\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach: {\n  /**\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A>(f: (a: A) => void): (self: SortedSet<A>) => void\n  /**\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A>(self: SortedSet<A>, f: (a: A) => void): void\n} = Dual.dual<\n  <A>(f: (a: A) => void) => (self: SortedSet<A>) => void,\n  <A>(self: SortedSet<A>, f: (a: A) => void) => void\n>(2, (self, f) => RBT.forEach(self.keyTree, f))\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: SortedSet<A>) => boolean\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, value: A): boolean\n} = Dual.dual<\n  <A>(value: A) => (self: SortedSet<A>) => boolean,\n  <A>(self: SortedSet<A>, value: A) => boolean\n>(2, (self, value) => RBT.has(self.keyTree, value))\n\n/**\n * @since 2.0.0\n */\nexport const intersection: {\n  /**\n   * @since 2.0.0\n   */\n  <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   */\n  <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>\n} = Dual.dual<\n  <A>(that: Iterable<A>) => (self: SortedSet<A>) => SortedSet<A>,\n  <A>(self: SortedSet<A>, that: Iterable<A>) => SortedSet<A>\n>(2, (self, that) => {\n  const ord = RBT.getOrder(self.keyTree)\n  let out = empty(ord)\n  for (const value of that) {\n    if (has(self, value)) {\n      out = add(out, value)\n    }\n  }\n  return out\n})\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const isSubset: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(that: SortedSet<A>): (self: SortedSet<A>) => boolean\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, that: SortedSet<A>): boolean\n} = Dual.dual<\n  <A>(that: SortedSet<A>) => (self: SortedSet<A>) => boolean,\n  <A>(self: SortedSet<A>, that: SortedSet<A>) => boolean\n>(2, (self, that) => every(self, (a) => has(that, a)))\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <B, A>(O: Order<B>, f: (a: A) => B): (self: SortedSet<A>) => SortedSet<B>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <B, A>(self: SortedSet<A>, O: Order<B>, f: (a: A) => B): SortedSet<B>\n} = Dual.dual<\n  <B, A>(O: Order<B>, f: (a: A) => B) => (self: SortedSet<A>) => SortedSet<B>,\n  <B, A>(self: SortedSet<A>, O: Order<B>, f: (a: A) => B) => SortedSet<B>\n>(3, (self, O, f) => {\n  let out = empty(O)\n  forEach(self, (a) => {\n    const b = f(a)\n    if (!has(out, b)) {\n      out = add(out, b)\n    }\n  })\n  return out\n})\n\n/**\n * @since 2.0.0\n * @category filtering\n */\nexport const partition: {\n  /**\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(predicate: (a: NoInfer<A>) => boolean): (self: SortedSet<A>) => [excluded: SortedSet<A>, satisfying: SortedSet<A>]\n  /**\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(self: SortedSet<A>, predicate: (a: A) => boolean): [excluded: SortedSet<A>, satisfying: SortedSet<A>]\n} = Dual.dual(\n  2,\n  <A>(self: SortedSet<A>, predicate: (a: A) => boolean): [excluded: SortedSet<A>, satisfying: SortedSet<A>] => {\n    const ord = RBT.getOrder(self.keyTree)\n    let right = empty(ord)\n    let left = empty(ord)\n    for (const value of self) {\n      if (predicate(value)) {\n        right = add(right, value)\n      } else {\n        left = add(left, value)\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const remove: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, value: A): SortedSet<A>\n} = Dual.dual<\n  <A>(value: A) => (self: SortedSet<A>) => SortedSet<A>,\n  <A>(self: SortedSet<A>, value: A) => SortedSet<A>\n>(2, (self, value) => fromTree(RBT.removeFirst(self.keyTree, value)))\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const size = <A>(self: SortedSet<A>): number => RBT.size(self.keyTree)\n\n/**\n * Check if a predicate holds true for some `SortedSet` element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some: {\n  /**\n   * Check if a predicate holds true for some `SortedSet` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean\n  /**\n   * Check if a predicate holds true for some `SortedSet` element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean\n} = Dual.dual<\n  <A>(predicate: Predicate<A>) => (self: SortedSet<A>) => boolean,\n  <A>(self: SortedSet<A>, predicate: Predicate<A>) => boolean\n>(2, (self, predicate) => {\n  for (const value of self) {\n    if (predicate(value)) {\n      return true\n    }\n  }\n  return false\n})\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const toggle: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: SortedSet<A>, value: A): SortedSet<A>\n} = Dual.dual<\n  <A>(value: A) => (self: SortedSet<A>) => SortedSet<A>,\n  <A>(self: SortedSet<A>, value: A) => SortedSet<A>\n>(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value))\n\n/**\n * @since 2.0.0\n */\nexport const union: {\n  /**\n   * @since 2.0.0\n   */\n  <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>\n  /**\n   * @since 2.0.0\n   */\n  <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>\n} = Dual.dual<\n  <A>(that: Iterable<A>) => (self: SortedSet<A>) => SortedSet<A>,\n  <A>(self: SortedSet<A>, that: Iterable<A>) => SortedSet<A>\n>(2, <A>(self: SortedSet<A>, that: Iterable<A>) => {\n  const ord = RBT.getOrder(self.keyTree)\n  let out = empty<A>(ord)\n  for (const value of self) {\n    out = add(value)(out)\n  }\n  for (const value of that) {\n    out = add(value)(out)\n  }\n  return out\n})\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const values = <A>(self: SortedSet<A>): IterableIterator<A> => RBT.keys(self.keyTree)\n\n/**\n * @since 2.0.0\n * @category equivalence\n */\nexport const getEquivalence = <A>(): Equivalence.Equivalence<SortedSet<A>> => (a, b) => isSubset(a, b) && isSubset(b, a)\n","/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/logSpan.js\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface LogSpan {\n  readonly label: string\n  readonly startTime: number\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (label: string, startTime: number) => LogSpan = internal.make\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nexport const render: (now: number) => (self: LogSpan) => string = internal.render\n","/**\n * @since 2.0.0\n */\n\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as ExecutionStrategy from \"./ExecutionStrategy.js\"\nimport type * as Exit from \"./Exit.js\"\nimport * as core from \"./internal/core.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * A unique identifier for the `Scope` type.\n *\n * @since 2.0.0\n * @category symbols\n */\nexport const ScopeTypeId: unique symbol = core.ScopeTypeId\n\n/**\n * The type of the unique identifier for `Scope`.\n *\n * @since 2.0.0\n * @category symbols\n */\nexport type ScopeTypeId = typeof ScopeTypeId\n\n/**\n * A unique identifier for the `CloseableScope` type.\n *\n * @since 2.0.0\n * @category symbols\n */\nexport const CloseableScopeTypeId: unique symbol = core.CloseableScopeTypeId\n\n/**\n * The type of the unique identifier for `CloseableScope`.\n *\n * @since 2.0.0\n * @category symbols\n */\nexport type CloseableScopeTypeId = typeof CloseableScopeTypeId\n\n/**\n * Represents a scope that manages finalizers and can fork child scopes.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Scope extends Pipeable {\n  readonly [ScopeTypeId]: ScopeTypeId\n  /**\n   * The execution strategy for running finalizers in this scope.\n   */\n  readonly strategy: ExecutionStrategy.ExecutionStrategy\n  /**\n   * Forks a new child scope with the specified execution strategy. The child scope\n   * will automatically be closed when this scope is closed.\n   *\n   * @internal\n   */\n  fork(strategy: ExecutionStrategy.ExecutionStrategy): Effect.Effect<Scope.Closeable>\n  /**\n   * Adds a finalizer to this scope. The finalizer will be run when the scope is closed.\n   *\n   * @internal\n   */\n  addFinalizer(finalizer: Scope.Finalizer): Effect.Effect<void>\n}\n\n/**\n * A scope that can be explicitly closed with a specified exit value.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface CloseableScope extends Scope, Pipeable {\n  readonly [CloseableScopeTypeId]: CloseableScopeTypeId\n\n  /**\n   * Closes this scope with the given exit value, running all finalizers.\n   *\n   * @internal\n   */\n  close(exit: Exit.Exit<unknown, unknown>): Effect.Effect<void>\n}\n\n/**\n * A tag representing the current `Scope` in the environment.\n *\n * @since 2.0.0\n * @category context\n */\nexport const Scope: Context.Tag<Scope, Scope> = fiberRuntime.scopeTag\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Scope {\n  /**\n   * A finalizer function that takes an `Exit` value and returns an `Effect`.\n   *\n   * @since 2.0.0\n   * @category model\n   */\n  export type Finalizer = (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>\n  /**\n   * A closeable scope that can be explicitly closed.\n   *\n   * @since 2.0.0\n   * @category model\n   */\n  export type Closeable = CloseableScope\n}\n\n/**\n * Adds a finalizer to this scope. The finalizer is guaranteed to be run when\n * the scope is closed. Use this when the finalizer does not need to know the\n * `Exit` value that the scope is closed with.\n *\n * @see {@link addFinalizerExit}\n *\n * @since 2.0.0\n * @category utils\n */\nexport const addFinalizer: (\n  self: Scope,\n  finalizer: Effect.Effect<unknown>\n) => Effect.Effect<void> = core.scopeAddFinalizer\n\n/**\n * Adds a finalizer to this scope. The finalizer receives the `Exit` value\n * when the scope is closed, allowing it to perform different actions based\n * on the exit status.\n *\n * @see {@link addFinalizer}\n *\n * @since 2.0.0\n * @category utils\n */\nexport const addFinalizerExit: (self: Scope, finalizer: Scope.Finalizer) => Effect.Effect<void> =\n  core.scopeAddFinalizerExit\n\n/**\n * Closes this scope with the specified exit value, running all finalizers that\n * have been added to the scope.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const close: (self: CloseableScope, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void> = core.scopeClose\n\n/**\n * Extends the scope of an `Effect` that requires a scope into this scope.\n * It provides this scope to the effect but does not close the scope when the\n * effect completes execution. This allows extending a scoped value into a\n * larger scope.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const extend: {\n  /**\n   * Extends the scope of an `Effect` that requires a scope into this scope.\n   * It provides this scope to the effect but does not close the scope when the\n   * effect completes execution. This allows extending a scoped value into a\n   * larger scope.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>\n  /**\n   * Extends the scope of an `Effect` that requires a scope into this scope.\n   * It provides this scope to the effect but does not close the scope when the\n   * effect completes execution. This allows extending a scoped value into a\n   * larger scope.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>\n} = fiberRuntime.scopeExtend\n\n/**\n * Forks a new child scope with the specified execution strategy. The child scope\n * will automatically be closed when this scope is closed.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const fork: (\n  self: Scope,\n  strategy: ExecutionStrategy.ExecutionStrategy\n) => Effect.Effect<CloseableScope> = core.scopeFork\n\n/**\n * Provides this closeable scope to an `Effect` that requires a scope,\n * guaranteeing that the scope is closed with the result of that effect as\n * soon as the effect completes execution, whether by success, failure, or\n * interruption.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const use: {\n  /**\n   * Provides this closeable scope to an `Effect` that requires a scope,\n   * guaranteeing that the scope is closed with the result of that effect as\n   * soon as the effect completes execution, whether by success, failure, or\n   * interruption.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>\n  /**\n   * Provides this closeable scope to an `Effect` that requires a scope,\n   * guaranteeing that the scope is closed with the result of that effect as\n   * soon as the effect completes execution, whether by success, failure, or\n   * interruption.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>\n} = fiberRuntime.scopeUse\n\n/**\n * Creates a new closeable scope where finalizers will run according to the\n * specified `ExecutionStrategy`. If no execution strategy is provided, `sequential`\n * will be used by default.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (\n  executionStrategy?: ExecutionStrategy.ExecutionStrategy\n) => Effect.Effect<CloseableScope> = fiberRuntime.scopeMake\n","/**\n * The `Effect<A, E, R>` type is polymorphic in values of type `E` and we can\n * work with any error type that we want. However, there is a lot of information\n * that is not inside an arbitrary `E` value. So as a result, an `Effect` needs\n * somewhere to store things like unexpected errors or defects, stack and\n * execution traces, causes of fiber interruptions, and so forth.\n *\n * Effect-TS is very strict about preserving the full information related to a\n * failure. It captures all type of errors into the `Cause` data type. `Effect`\n * uses the `Cause<E>` data type to store the full story of failure. So its\n * error model is lossless. It doesn't throw information related to the failure\n * result. So we can figure out exactly what happened during the operation of\n * our effects.\n *\n * It is important to note that `Cause` is an underlying data type representing\n * errors occuring within an `Effect` workflow. Thus, we don't usually deal with\n * `Cause`s directly. Even though it is not a data type that we deal with very\n * often, the `Cause` of a failing `Effect` workflow can be accessed at any\n * time, which gives us total access to all parallel and sequential errors in\n * occurring within our codebase.\n *\n * @since 2.0.0\n */\nimport type * as Channel from \"./Channel.js\"\nimport type * as Chunk from \"./Chunk.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as Equal from \"./Equal.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as internal from \"./internal/cause.js\"\nimport * as core from \"./internal/core.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type * as Sink from \"./Sink.js\"\nimport type * as Stream from \"./Stream.js\"\nimport type { Span } from \"./Tracer.js\"\nimport type { Covariant, NoInfer } from \"./Types.js\"\n\n/**\n * A unique symbol identifying the `Cause` type.\n *\n * **Details**\n *\n * This provides a symbol that helps identify instances of the `Cause` data\n * type. This can be used for advanced operations such as refining types or\n * building internal utilities that check whether an unknown value is a `Cause`.\n *\n * @see {@link isCause} Check if a value is a `Cause`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const CauseTypeId: unique symbol = internal.CauseTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type CauseTypeId = typeof CauseTypeId\n\n/**\n * A unique symbol identifying the `RuntimeException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies a `RuntimeException`. This is\n * typically used internally by the library to recognize checked exceptions that\n * occur during runtime.\n *\n * @see {@link RuntimeException} Create or work with a `RuntimeException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const RuntimeExceptionTypeId: unique symbol = core.RuntimeExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type RuntimeExceptionTypeId = typeof RuntimeExceptionTypeId\n\n/**\n * A unique symbol identifying the `InterruptedException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies an `InterruptedException`. This is\n * typically used internally to recognize when a fiber has been interrupted,\n * helping the framework handle interruption logic correctly.\n *\n * @see {@link InterruptedException} Create or work with an `InterruptedException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const InterruptedExceptionTypeId: unique symbol = core.InterruptedExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type InterruptedExceptionTypeId = typeof InterruptedExceptionTypeId\n\n/**\n * A unique symbol identifying the `IllegalArgumentException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies an `IllegalArgumentException`. This is\n * often used in scenarios where invalid arguments are supplied to methods that\n * expect specific input.\n *\n * @see {@link IllegalArgumentException} Create or work with an `IllegalArgumentException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const IllegalArgumentExceptionTypeId: unique symbol = core.IllegalArgumentExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type IllegalArgumentExceptionTypeId = typeof IllegalArgumentExceptionTypeId\n\n/**\n * A unique symbol identifying the `NoSuchElementException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies a `NoSuchElementException`. It helps\n * differentiate cases where a required element is missing within a data\n * structure.\n *\n * @see {@link NoSuchElementException} Create or work with a `NoSuchElementException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const NoSuchElementExceptionTypeId: unique symbol = core.NoSuchElementExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type NoSuchElementExceptionTypeId = typeof NoSuchElementExceptionTypeId\n\n/**\n * A unique symbol identifying the `InvalidPubSubCapacityException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies an `InvalidPubSubCapacityException`.\n * It indicates an error related to an invalid capacity passed to a `PubSub`\n * structure.\n *\n * @see {@link InvalidPubSubCapacityException} Create or work with an `InvalidPubSubCapacityException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const InvalidPubSubCapacityExceptionTypeId: unique symbol = core.InvalidPubSubCapacityExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type InvalidPubSubCapacityExceptionTypeId = typeof InvalidPubSubCapacityExceptionTypeId\n\n/**\n * A unique symbol identifying the `ExceededCapacityException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies an `ExceededCapacityException`. It\n * denotes situations where a resource has exceeded its configured capacity\n * limit.\n *\n * @see {@link ExceededCapacityException} Create or work with an `ExceededCapacityException`\n *\n * @since 3.5.0\n * @category Symbols\n */\nexport const ExceededCapacityExceptionTypeId: unique symbol = core.ExceededCapacityExceptionTypeId\n\n/**\n * @since 3.5.0\n * @category Symbols\n */\nexport type ExceededCapacityExceptionTypeId = typeof ExceededCapacityExceptionTypeId\n\n/**\n * A unique symbol identifying the `TimeoutException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies a `TimeoutException`. It helps the\n * framework recognize errors related to operations that fail to complete within\n * a given timeframe.\n *\n * @see {@link TimeoutException} Create or work with a `TimeoutException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const TimeoutExceptionTypeId: unique symbol = core.TimeoutExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type TimeoutExceptionTypeId = typeof TimeoutExceptionTypeId\n\n/**\n * A unique symbol identifying the `UnknownException` type.\n *\n * **Details**\n *\n * This provides a symbol that identifies an `UnknownException`. It is typically\n * used for generic or unexpected errors that do not fit other specific\n * exception categories.\n *\n * @see {@link UnknownException} Create or work with an `UnknownException`\n *\n * @since 2.0.0\n * @category Symbols\n */\nexport const UnknownExceptionTypeId: unique symbol = core.UnknownExceptionTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type UnknownExceptionTypeId = typeof UnknownExceptionTypeId\n\n/**\n * Represents the full history of a failure within an `Effect`.\n *\n * **Details**\n *\n * This type is a data structure that captures all information about why and how\n * an effect has failed, including parallel errors, sequential errors, defects,\n * and interruptions. It enables a \"lossless\" error model: no error-related\n * information is discarded, which helps in debugging and understanding the root\n * cause of failures.\n *\n * @since 2.0.0\n * @category Models\n */\nexport type Cause<E> =\n  | Empty\n  | Fail<E>\n  | Die\n  | Interrupt\n  | Sequential<E>\n  | Parallel<E>\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Cause {\n  /**\n   * This interface is used internally to manage the type variance of `Cause`.\n   *\n   * @since 2.0.0\n   * @category Models\n   */\n  export interface Variance<out E> {\n    readonly [CauseTypeId]: {\n      readonly _E: Covariant<E>\n    }\n  }\n}\n\n/**\n * Describes methods for reducing a `Cause<E>` into a value of type `Z` with\n * access to contextual information.\n *\n * **Details**\n *\n * This interface is meant for advanced transformations of `Cause`. By\n * implementing each method, you can define how different parts of the `Cause`\n * structure (like `Fail`, `Die`, or `Interrupt`) should be transformed into a\n * final type `Z`. The `context` parameter carries additional data needed during\n * this reduction.\n *\n * @see {@link reduceWithContext} Apply a `CauseReducer` to transform a `Cause`\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface CauseReducer<in C, in E, in out Z> {\n  emptyCase(context: C): Z\n  failCase(context: C, error: E): Z\n  dieCase(context: C, defect: unknown): Z\n  interruptCase(context: C, fiberId: FiberId.FiberId): Z\n  sequentialCase(context: C, left: Z, right: Z): Z\n  parallelCase(context: C, left: Z, right: Z): Z\n}\n\n/**\n * Represents an error object that can be yielded in `Effect.gen`.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface YieldableError extends Pipeable, Inspectable, Error {\n  readonly [Effect.EffectTypeId]: Effect.Effect.VarianceStruct<never, this, never>\n  readonly [Stream.StreamTypeId]: Stream.Stream.VarianceStruct<never, this, never>\n  readonly [Sink.SinkTypeId]: Sink.Sink.VarianceStruct<never, unknown, never, this, never>\n  readonly [Channel.ChannelTypeId]: Channel.Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>\n  [Symbol.iterator](): Effect.EffectGenerator<Effect.Effect<never, this, never>>\n}\n\n/**\n * Creates an error that occurs at runtime, extendable for other exception\n * types.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const YieldableError: new(message?: string | undefined) => YieldableError = core.YieldableError\n\n/**\n * An error representing a runtime error.\n *\n * **Details**\n *\n * This interface is used for errors that occur at runtime but are still\n * considered recoverable or typed.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface RuntimeException extends YieldableError {\n  readonly _tag: \"RuntimeException\"\n  readonly [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}\n\n/**\n * An error representing fiber interruption.\n *\n * **Details**\n *\n * This interface represents errors that occur when a fiber is forcefully\n * interrupted. Interruption can happen for various reasons, including\n * cancellations or system directives to halt operations. Code that deals with\n * concurrency might need to catch or handle these to ensure proper cleanup.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface InterruptedException extends YieldableError {\n  readonly _tag: \"InterruptedException\"\n  readonly [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}\n\n/**\n * An error representing an invalid argument passed to a method.\n *\n * **Details**\n *\n * This interface is used for signaling that a function or method received an\n * argument that does not meet its preconditions.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface IllegalArgumentException extends YieldableError {\n  readonly _tag: \"IllegalArgumentException\"\n  readonly [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}\n\n/**\n * An error that occurs when an expected element is missing.\n *\n * **Details**\n *\n * This interface indicates scenarios like looking up an item in a collection\n * or searching for data that should be present but isn't. It helps your code\n * signal a more specific issue rather than a general error.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface NoSuchElementException extends YieldableError {\n  readonly _tag: \"NoSuchElementException\"\n  readonly [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}\n\n/**\n * An error indicating invalid capacity for a `PubSub`.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface InvalidPubSubCapacityException extends YieldableError {\n  readonly _tag: \"InvalidPubSubCapacityException\"\n  readonly [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId\n}\n\n/**\n * An error that occurs when resource capacity is exceeded.\n *\n * @since 3.5.0\n * @category Models\n */\nexport interface ExceededCapacityException extends YieldableError {\n  readonly _tag: \"ExceededCapacityException\"\n  readonly [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId\n}\n\n/**\n * An error representing a computation that timed out.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface TimeoutException extends YieldableError {\n  readonly _tag: \"TimeoutException\"\n  readonly [TimeoutExceptionTypeId]: TimeoutExceptionTypeId\n}\n\n/**\n * A checked exception for handling unknown or unexpected errors.\n *\n * **Details**\n *\n * This interface captures errors that don't fall under known categories. It is\n * especially helpful for wrapping low-level or third-party library errors that\n * might provide little or no context, such as from a rejected promise.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface UnknownException extends YieldableError {\n  readonly _tag: \"UnknownException\"\n  readonly [UnknownExceptionTypeId]: UnknownExceptionTypeId\n  readonly error: unknown\n}\n\n/**\n * Represents a lack of errors within a `Cause`.\n *\n * @see {@link empty} Construct a new `Empty` cause\n * @see {@link isEmptyType} Check if a `Cause` is an `Empty` type\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Empty extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Empty\"\n}\n\n/**\n * Represents an expected error within a `Cause`.\n *\n * **Details**\n *\n * This interface models a `Cause` that carries an expected or known error of\n * type `E`. For example, if you validate user input and find it invalid, you\n * might store that error within a `Fail`.\n *\n * @see {@link fail} Construct a `Fail` cause\n * @see {@link isFailType} Check if a `Cause` is a `Fail`\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Fail<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Fail\"\n  readonly error: E\n}\n\n/**\n * Represents an unexpected defect within a `Cause`.\n *\n * **Details**\n *\n * This interface models a `Cause` for errors that are typically unrecoverable or\n * unanticipatedlike runtime exceptions or bugs. When code \"dies,\" it indicates a\n * severe failure that wasn't accounted for.\n *\n * @see {@link die} Construct a `Die` cause\n * @see {@link isDieType} Check if a `Cause` is a `Die`\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Die extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Die\"\n  readonly defect: unknown\n}\n\n/**\n * Represents fiber interruption within a `Cause`.\n *\n * **Details**\n *\n * This interface models a scenario where an effect was halted by an external\n * signal, carrying a `FiberId` that identifies which fiber was interrupted.\n * Interruption is a normal part of concurrency, used for cancellation or\n * resource cleanup.\n *\n * @see {@link interrupt} Construct an `Interrupt` cause\n * @see {@link isInterruptType} Check if a `Cause` is an `Interrupt`\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Interrupt extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Interrupt\"\n  readonly fiberId: FiberId.FiberId\n}\n\n/**\n * Represents parallel composition of two `Cause`s.\n *\n * **Details**\n *\n * This interface captures failures that happen simultaneously. In scenarios\n * with concurrency, more than one operation can fail in parallel. Instead of\n * losing information, this structure stores both errors together.\n *\n * @see {@link parallel} Combine two `Cause`s in parallel\n * @see {@link isParallelType} Check if a `Cause` is a `Parallel`\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Parallel<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Parallel\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}\n\n/**\n * Represents sequential composition of two `Cause`s.\n *\n * **Details**\n *\n * This interface models the scenario where one error follows another in\n * sequence, such as when a main effect fails and then a finalizer also fails.\n * It ensures both errors are retained in the final `Cause`.\n *\n * @see {@link sequential} Combine two `Cause`s sequentially\n * @see {@link isSequentialType} Check if a `Cause` is a `Sequential`\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Sequential<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {\n  readonly _tag: \"Sequential\"\n  readonly left: Cause<E>\n  readonly right: Cause<E>\n}\n\n/**\n * Creates an `Empty` cause.\n *\n * **Details**\n *\n * This function returns a cause that signifies \"no error.\" It's commonly used\n * to represent an absence of failure conditions.\n *\n * @see {@link isEmpty} Check if a `Cause` is empty\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const empty: Cause<never> = internal.empty\n\n/**\n * Creates a `Fail` cause from an expected error.\n *\n * **Details**\n *\n * This function constructs a `Cause` carrying an error of type `E`. It's used\n * when you want to represent a known or anticipated failure in your effectful\n * computations.\n *\n * @see {@link isFailure} Check if a `Cause` contains a failure\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const fail: <E>(error: E) => Cause<E> = internal.fail\n\n/**\n * Creates a `Die` cause from an unexpected error.\n *\n * **Details**\n *\n * This function wraps an unhandled or unknown defect (like a runtime crash)\n * into a `Cause`. It's useful for capturing unforeseen issues in a structured\n * way.\n *\n * @see {@link isDie} Check if a `Cause` contains a defect\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const die: (defect: unknown) => Cause<never> = internal.die\n\n/**\n * Creates an `Interrupt` cause from a `FiberId`.\n *\n * **Details**\n *\n * This function represents a fiber that has been interrupted. It stores the\n * identifier of the interrupted fiber, enabling precise tracking of concurrent\n * cancellations.\n *\n * @see {@link isInterrupted} Check if a `Cause` contains an interruption\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const interrupt: (fiberId: FiberId.FiberId) => Cause<never> = internal.interrupt\n\n/**\n * Combines two `Cause`s in parallel.\n *\n * **Details**\n *\n * This function merges two errors that occurred simultaneously. Instead of\n * discarding one error, both are retained, allowing for richer error reporting\n * and debugging.\n *\n * @see {@link isParallelType} Check if a `Cause` is a `Parallel`\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2> = internal.parallel\n\n/**\n * Combines two `Cause`s sequentially.\n *\n * **Details**\n *\n * This function merges two errors that occurred in sequence, such as a main\n * error followed by a finalization error. It preserves both errors for complete\n * failure information.\n *\n * @see {@link isSequentialType} Check if a `Cause` is a `Sequential`\n *\n * @since 2.0.0\n * @category Constructors\n */\nexport const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2> = internal.sequential\n\n/**\n * Checks if a value is a `Cause`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isCause: (u: unknown) => u is Cause<unknown> = internal.isCause\n\n/**\n * Checks if a `Cause` is an `Empty` type.\n *\n * @see {@link empty} Create a new `Empty` cause\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isEmptyType: <E>(self: Cause<E>) => self is Empty = internal.isEmptyType\n\n/**\n * Checks if a `Cause` is a `Fail` type.\n *\n * @see {@link fail} Create a new `Fail` cause\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isFailType: <E>(self: Cause<E>) => self is Fail<E> = internal.isFailType\n\n/**\n * Checks if a `Cause` is a `Die` type.\n *\n * @see {@link die} Create a new `Die` cause\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isDieType: <E>(self: Cause<E>) => self is Die = internal.isDieType\n\n/**\n * Checks if a `Cause` is an `Interrupt` type.\n *\n * @see {@link interrupt} Create an `Interrupt` cause\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isInterruptType: <E>(self: Cause<E>) => self is Interrupt = internal.isInterruptType\n\n/**\n * Checks if a `Cause` is a `Sequential` type.\n *\n * @see {@link sequential} Combine two `Cause`s sequentially\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E> = internal.isSequentialType\n\n/**\n * Checks if a `Cause` is a `Parallel` type.\n *\n * @see {@link parallel} Combine two `Cause`s in parallel\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isParallelType: <E>(self: Cause<E>) => self is Parallel<E> = internal.isParallelType\n\n/**\n * Calculates the size of a `Cause`.\n *\n * **Details**\n *\n * This function returns the total number of `Cause` nodes in the semiring\n * structure, reflecting how many individual error elements are recorded.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const size: <E>(self: Cause<E>) => number = internal.size\n\n/**\n * Checks if a `Cause` is entirely empty.\n *\n * **Details**\n *\n * This function returns `true` if the `Cause` contains no errors, defects, or\n * interruptions. It's helpful for verifying if a computation truly had no\n * failures.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const isEmpty: <E>(self: Cause<E>) => boolean = internal.isEmpty\n\n/**\n * Checks if a `Cause` contains a failure.\n *\n * **Details**\n *\n * This function returns `true` if the `Cause` includes any `Fail` error. It's\n * commonly used to confirm whether a workflow encountered an anticipated error\n * versus just defects or interruptions.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const isFailure: <E>(self: Cause<E>) => boolean = internal.isFailure\n\n/**\n * Checks if a `Cause` contains a defect.\n *\n * **Details**\n *\n * This function returns `true` if the `Cause` includes any unexpected or\n * unhandled errors (`Die`). It's useful for differentiating known failures from\n * unexpected ones.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const isDie: <E>(self: Cause<E>) => boolean = internal.isDie\n\n/**\n * Checks if a `Cause` contains an interruption.\n *\n * **Details**\n *\n * This function returns `true` if the `Cause` includes any fiber interruptions.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const isInterrupted: <E>(self: Cause<E>) => boolean = internal.isInterrupted\n\n/**\n * Checks if a `Cause` contains only interruptions.\n *\n * **Details**\n *\n * This function returns `true` if the `Cause` has been interrupted but does not\n * contain any other failures, such as `Fail` or `Die`. It's helpful for\n * verifying purely \"cancellation\" scenarios.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const isInterruptedOnly: <E>(self: Cause<E>) => boolean = internal.isInterruptedOnly\n\n/**\n * Extracts all recoverable errors of type `E` from a `Cause`.\n *\n * **Details**\n *\n * This function returns a chunk of errors, providing a list of all `Fail`\n * values found in the cause. It's useful for collecting all known failures for\n * logging or combined error handling.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const failures: <E>(self: Cause<E>) => Chunk.Chunk<E> = internal.failures\n\n/**\n * Extracts all unrecoverable defects from a `Cause`.\n *\n * **Details**\n *\n * This function returns a chunk of values representing unexpected errors\n * (`Die`). It's handy for capturing or logging unanticipated failures that\n * might need special handling, such as bug reports.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown> = internal.defects\n\n/**\n * Collects all `FiberId`s responsible for interrupting a fiber.\n *\n * **Details**\n *\n * This function returns a set of IDs indicating which fibers caused\n * interruptions within this `Cause`. It's useful for debugging concurrency\n * issues or tracing cancellations.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId> = internal.interruptors\n\n/**\n * Retrieves the first `Fail` error in a `Cause`, if present.\n *\n * **Details**\n *\n * This function returns an `Option` containing the first recoverable error\n * (`E`) from the cause. It's often used to quickly check if there's a primary\n * error to handle or display.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const failureOption: <E>(self: Cause<E>) => Option.Option<E> = internal.failureOption\n\n/**\n * Splits a `Cause` into either its first `Fail` error or the rest of the cause\n * (which might only contain `Die` or `Interrupt`).\n *\n * **Details**\n *\n * This function either returns the checked error (`E`) or the remaining\n * `Cause<never>` with defects/interruptions. It helps you decide if there's a\n * recoverable path or if only unhandled issues remain.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E> = internal.failureOrCause\n\n/**\n * Strips out failures with an error of `None` from a `Cause<Option<E>>`.\n *\n * **Details**\n *\n * This function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the\n * cause only contains failures of `None`, it becomes `None`; otherwise, it\n * returns a `Cause` of the remaining errors. It's helpful when working with\n * optional errors and filtering out certain error paths.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>> = internal.flipCauseOption\n\n/**\n * Retrieves the first `Die` defect in a `Cause`, if present.\n *\n * **Details**\n *\n * This function returns an `Option` containing the first unexpected failure\n * (`Die`) discovered. It's helpful for diagnosing the primary defect in a chain\n * of errors.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const dieOption: <E>(self: Cause<E>) => Option.Option<unknown> = internal.dieOption\n\n/**\n * Retrieves the first `Interrupt` in a `Cause`, if present.\n *\n * **Details**\n *\n * This function returns an `Option` with the first fiber interruption\n * discovered. This is particularly useful for concurrency analysis or debugging\n * cancellations.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId> = internal.interruptOption\n\n/**\n * Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a\n * `Cause`.\n *\n * **Details**\n *\n * This function strips a cause of recoverable errors and interruptions, leaving\n * only unexpected failures. If no defects remain, it returns `None`. It's\n * valuable for focusing only on unanticipated problems when both known errors\n * and defects could occur.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>> = internal.keepDefects\n\n// TODO(4.0): remove? what's the point of this API?\n/**\n * Linearizes a `Cause` into a set of parallel causes, each containing a\n * sequential chain of failures.\n *\n * **Details**\n *\n * This function reorganizes the cause structure so that you can analyze each\n * parallel branch separately, even if they have multiple sequential errors.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const linearize: <E>(self: Cause<E>) => HashSet.HashSet<Cause<E>> = internal.linearize\n\n/**\n * Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects\n * (`Die`).\n *\n * **Details**\n *\n * This function is similar to `keepDefects` but returns a `Cause<never>`\n * directly, which can still store `Die` or finalizer-related defects. It's\n * helpful for analyzing only the irrecoverable portion of the error.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const stripFailures: <E>(self: Cause<E>) => Cause<never> = internal.stripFailures\n\n/**\n * Removes matching defects from a `Cause` using a partial function, returning\n * the remainder.\n *\n * **Details**\n *\n * This function applies a user-defined extraction function to each defect\n * (`Die`). If the function matches the defect, that defect is removed. If all\n * defects match, the result is `None`. Otherwise, you get a `Cause` with the\n * unmatched defects.\n *\n * @since 2.0.0\n * @category Getters\n */\nexport const stripSomeDefects: {\n  /**\n   * Removes matching defects from a `Cause` using a partial function, returning\n   * the remainder.\n   *\n   * **Details**\n   *\n   * This function applies a user-defined extraction function to each defect\n   * (`Die`). If the function matches the defect, that defect is removed. If all\n   * defects match, the result is `None`. Otherwise, you get a `Cause` with the\n   * unmatched defects.\n   *\n   * @since 2.0.0\n   * @category Getters\n   */\n  (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>\n  /**\n   * Removes matching defects from a `Cause` using a partial function, returning\n   * the remainder.\n   *\n   * **Details**\n   *\n   * This function applies a user-defined extraction function to each defect\n   * (`Die`). If the function matches the defect, that defect is removed. If all\n   * defects match, the result is `None`. Otherwise, you get a `Cause` with the\n   * unmatched defects.\n   *\n   * @since 2.0.0\n   * @category Getters\n   */\n  <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>\n} = internal.stripSomeDefects\n\n/**\n * Replaces any errors in a `Cause` with a provided constant error.\n *\n * **Details**\n *\n * This function transforms all `Fail` errors into the specified error value,\n * preserving the structure of the `Cause`. It's useful when you no longer need\n * the original error details but still want to keep the cause shape.\n *\n * @see {@link map} Apply a custom transformation to `Fail` errors\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const as: {\n  /**\n   * Replaces any errors in a `Cause` with a provided constant error.\n   *\n   * **Details**\n   *\n   * This function transforms all `Fail` errors into the specified error value,\n   * preserving the structure of the `Cause`. It's useful when you no longer need\n   * the original error details but still want to keep the cause shape.\n   *\n   * @see {@link map} Apply a custom transformation to `Fail` errors\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>\n  /**\n   * Replaces any errors in a `Cause` with a provided constant error.\n   *\n   * **Details**\n   *\n   * This function transforms all `Fail` errors into the specified error value,\n   * preserving the structure of the `Cause`. It's useful when you no longer need\n   * the original error details but still want to keep the cause shape.\n   *\n   * @see {@link map} Apply a custom transformation to `Fail` errors\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, E2>(self: Cause<E>, error: E2): Cause<E2>\n} = internal.as\n\n/**\n * Transforms the errors in a `Cause` using a user-provided function.\n *\n * **Details**\n *\n * This function applies `f` to each `Fail` error while leaving defects (`Die`)\n * and interruptions untouched. It's useful for changing or simplifying error\n * types in your effectful workflows.\n *\n * @see {@link as} Replace errors with a single constant\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const map: {\n  /**\n   * Transforms the errors in a `Cause` using a user-provided function.\n   *\n   * **Details**\n   *\n   * This function applies `f` to each `Fail` error while leaving defects (`Die`)\n   * and interruptions untouched. It's useful for changing or simplifying error\n   * types in your effectful workflows.\n   *\n   * @see {@link as} Replace errors with a single constant\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>\n  /**\n   * Transforms the errors in a `Cause` using a user-provided function.\n   *\n   * **Details**\n   *\n   * This function applies `f` to each `Fail` error while leaving defects (`Die`)\n   * and interruptions untouched. It's useful for changing or simplifying error\n   * types in your effectful workflows.\n   *\n   * @see {@link as} Replace errors with a single constant\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>\n} = internal.map\n\n/**\n * Transforms errors in a `Cause` into new causes.\n *\n * **Details**\n *\n * This function applies a function `f` to each `Fail` error, converting it into\n * a new `Cause`. This is especially powerful for merging or restructuring error\n * types while preserving or combining cause information.\n *\n * @see {@link map} Apply a simpler transformation to errors\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const flatMap: {\n  /**\n   * Transforms errors in a `Cause` into new causes.\n   *\n   * **Details**\n   *\n   * This function applies a function `f` to each `Fail` error, converting it into\n   * a new `Cause`. This is especially powerful for merging or restructuring error\n   * types while preserving or combining cause information.\n   *\n   * @see {@link map} Apply a simpler transformation to errors\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>\n  /**\n   * Transforms errors in a `Cause` into new causes.\n   *\n   * **Details**\n   *\n   * This function applies a function `f` to each `Fail` error, converting it into\n   * a new `Cause`. This is especially powerful for merging or restructuring error\n   * types while preserving or combining cause information.\n   *\n   * @see {@link map} Apply a simpler transformation to errors\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>\n} = internal.flatMap\n\n/**\n * Sequences two `Cause`s. The second `Cause` can be dependent on the result of\n * the first `Cause`.\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const andThen: {\n  /**\n   * Sequences two `Cause`s. The second `Cause` can be dependent on the result of\n   * the first `Cause`.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>\n  /**\n   * Sequences two `Cause`s. The second `Cause` can be dependent on the result of\n   * the first `Cause`.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>\n  /**\n   * Sequences two `Cause`s. The second `Cause` can be dependent on the result of\n   * the first `Cause`.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>\n  /**\n   * Sequences two `Cause`s. The second `Cause` can be dependent on the result of\n   * the first `Cause`.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>\n} = internal.andThen\n\n/**\n * Flattens a nested `Cause` structure.\n *\n * **Details**\n *\n * This function takes a `Cause<Cause<E>>` and merges the layers into a single\n * `Cause<E>`. It's useful for eliminating additional nesting created by\n * repeated transformations or compositions.\n *\n * @see {@link flatMap} Compose nested causes\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const flatten: <E>(self: Cause<Cause<E>>) => Cause<E> = internal.flatten\n\n/**\n * Checks if the current `Cause` contains or is equal to another `Cause`.\n *\n * **Details**\n *\n * This function returns `true` if `that` cause is part of or the same as\n * the current `Cause`. It's useful when you need to check for specific\n * error patterns or deduplicate repeated failures.\n *\n * @since 2.0.0\n * @category Elements\n */\nexport const contains: {\n  /**\n   * Checks if the current `Cause` contains or is equal to another `Cause`.\n   *\n   * **Details**\n   *\n   * This function returns `true` if `that` cause is part of or the same as\n   * the current `Cause`. It's useful when you need to check for specific\n   * error patterns or deduplicate repeated failures.\n   *\n   * @since 2.0.0\n   * @category Elements\n   */\n  <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean\n  /**\n   * Checks if the current `Cause` contains or is equal to another `Cause`.\n   *\n   * **Details**\n   *\n   * This function returns `true` if `that` cause is part of or the same as\n   * the current `Cause`. It's useful when you need to check for specific\n   * error patterns or deduplicate repeated failures.\n   *\n   * @since 2.0.0\n   * @category Elements\n   */\n  <E, E2>(self: Cause<E>, that: Cause<E2>): boolean\n} = internal.contains\n\n/**\n * Extracts the most \"important\" defect from a `Cause`.\n *\n * **Details**\n *\n * This function reduces a `Cause` to a single, prioritized defect. It evaluates\n * the `Cause` in the following order of priority:\n *\n * 1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns\n *    the raw error value.\n * 2. If there is no failure, it looks for the first defect (e.g., from\n *    `Effect.die`).\n * 3. If neither of the above is present, and the `Cause` stems from an\n *    interruption, it creates and returns an `InterruptedException`.\n *\n * This function ensures you can always extract a meaningful representation of\n * the primary issue from a potentially complex `Cause` structure.\n *\n * **When to Use**\n *\n * Use this function when you need to extract the most relevant error or defect\n * from a `Cause`, especially in scenarios where multiple errors or defects may\n * be present. It's particularly useful for simplifying error reporting or\n * logging.\n *\n * @see {@link squashWith} Allows transforming failures into defects when squashing.\n *\n * @since 2.0.0\n * @category Destructors\n */\nexport const squash: <E>(self: Cause<E>) => unknown = core.causeSquash\n\n/**\n * Extracts the most \"important\" defect from a `Cause`, transforming failures\n * into defects using a provided function.\n *\n * **Details**\n *\n * This function reduces a `Cause` to a single, prioritized defect, while\n * allowing you to transform recoverable failures into defects through a custom\n * function. It processes the `Cause` in the following order:\n *\n * 1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies\n *    the provided function `f` to the error to transform it into a defect.\n * 2. If there is no failure, it looks for the first defect (e.g., from\n *    `Effect.die`) and returns it.\n * 3. If neither is present and the `Cause` stems from an interruption, it\n *    returns an `InterruptedException`.\n *\n * This function is particularly useful when you need custom handling or\n * transformation of errors while processing a `Cause`.\n *\n * @see {@link squash} Extracts the most \"important\" defect without transforming failures.\n *\n * @since 2.0.0\n * @category Destructors\n */\nexport const squashWith: {\n  /**\n   * Extracts the most \"important\" defect from a `Cause`, transforming failures\n   * into defects using a provided function.\n   *\n   * **Details**\n   *\n   * This function reduces a `Cause` to a single, prioritized defect, while\n   * allowing you to transform recoverable failures into defects through a custom\n   * function. It processes the `Cause` in the following order:\n   *\n   * 1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies\n   *    the provided function `f` to the error to transform it into a defect.\n   * 2. If there is no failure, it looks for the first defect (e.g., from\n   *    `Effect.die`) and returns it.\n   * 3. If neither is present and the `Cause` stems from an interruption, it\n   *    returns an `InterruptedException`.\n   *\n   * This function is particularly useful when you need custom handling or\n   * transformation of errors while processing a `Cause`.\n   *\n   * @see {@link squash} Extracts the most \"important\" defect without transforming failures.\n   *\n   * @since 2.0.0\n   * @category Destructors\n   */\n  <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown\n  /**\n   * Extracts the most \"important\" defect from a `Cause`, transforming failures\n   * into defects using a provided function.\n   *\n   * **Details**\n   *\n   * This function reduces a `Cause` to a single, prioritized defect, while\n   * allowing you to transform recoverable failures into defects through a custom\n   * function. It processes the `Cause` in the following order:\n   *\n   * 1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies\n   *    the provided function `f` to the error to transform it into a defect.\n   * 2. If there is no failure, it looks for the first defect (e.g., from\n   *    `Effect.die`) and returns it.\n   * 3. If neither is present and the `Cause` stems from an interruption, it\n   *    returns an `InterruptedException`.\n   *\n   * This function is particularly useful when you need custom handling or\n   * transformation of errors while processing a `Cause`.\n   *\n   * @see {@link squash} Extracts the most \"important\" defect without transforming failures.\n   *\n   * @since 2.0.0\n   * @category Destructors\n   */\n  <E>(self: Cause<E>, f: (error: E) => unknown): unknown\n} = core.causeSquashWith\n\n/**\n * Searches a `Cause` using a partial function to extract information.\n *\n * **Details**\n *\n * This function allows you to search through a `Cause` using a custom partial\n * function. The partial function is applied to the `Cause`, and if it matches,\n * the result is returned wrapped in a `Some`. If no match is found, the result\n * is `None`.\n *\n * This is particularly useful when you are only interested in specific types of\n * errors, defects, or interruption causes within a potentially complex `Cause`\n * structure. By leveraging a partial function, you can focus on extracting only\n * the relevant information you care about.\n *\n * The partial function should return an `Option` indicating whether it matched\n * and the value it extracted.\n *\n * @since 2.0.0\n * @category Elements\n */\nexport const find: {\n  /**\n   * Searches a `Cause` using a partial function to extract information.\n   *\n   * **Details**\n   *\n   * This function allows you to search through a `Cause` using a custom partial\n   * function. The partial function is applied to the `Cause`, and if it matches,\n   * the result is returned wrapped in a `Some`. If no match is found, the result\n   * is `None`.\n   *\n   * This is particularly useful when you are only interested in specific types of\n   * errors, defects, or interruption causes within a potentially complex `Cause`\n   * structure. By leveraging a partial function, you can focus on extracting only\n   * the relevant information you care about.\n   *\n   * The partial function should return an `Option` indicating whether it matched\n   * and the value it extracted.\n   *\n   * @since 2.0.0\n   * @category Elements\n   */\n  <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>\n  /**\n   * Searches a `Cause` using a partial function to extract information.\n   *\n   * **Details**\n   *\n   * This function allows you to search through a `Cause` using a custom partial\n   * function. The partial function is applied to the `Cause`, and if it matches,\n   * the result is returned wrapped in a `Some`. If no match is found, the result\n   * is `None`.\n   *\n   * This is particularly useful when you are only interested in specific types of\n   * errors, defects, or interruption causes within a potentially complex `Cause`\n   * structure. By leveraging a partial function, you can focus on extracting only\n   * the relevant information you care about.\n   *\n   * The partial function should return an `Option` indicating whether it matched\n   * and the value it extracted.\n   *\n   * @since 2.0.0\n   * @category Elements\n   */\n  <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>\n} = internal.find\n\n/**\n * Preserves parts of a `Cause` that match a given predicate.\n *\n * **Details**\n *\n * This function allows you to retain only the parts of a `Cause` structure that\n * match a specified predicate or refinement. Any parts of the `Cause` that do\n * not match the provided condition are excluded from the result.\n *\n * You can use this function in two ways:\n * - With a `Predicate`: A function that evaluates whether a `Cause` should be\n *   retained based on its value.\n * - With a `Refinement`: A more specific predicate that can refine the type of\n *   the `Cause`.\n *\n * This is useful when you need to extract specific types of errors, defects, or\n * interruptions from a `Cause` while discarding unrelated parts.\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filter: {\n  /**\n   * Preserves parts of a `Cause` that match a given predicate.\n   *\n   * **Details**\n   *\n   * This function allows you to retain only the parts of a `Cause` structure that\n   * match a specified predicate or refinement. Any parts of the `Cause` that do\n   * not match the provided condition are excluded from the result.\n   *\n   * You can use this function in two ways:\n   * - With a `Predicate`: A function that evaluates whether a `Cause` should be\n   *   retained based on its value.\n   * - With a `Refinement`: A more specific predicate that can refine the type of\n   *   the `Cause`.\n   *\n   * This is useful when you need to extract specific types of errors, defects, or\n   * interruptions from a `Cause` while discarding unrelated parts.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>\n  /**\n   * Preserves parts of a `Cause` that match a given predicate.\n   *\n   * **Details**\n   *\n   * This function allows you to retain only the parts of a `Cause` structure that\n   * match a specified predicate or refinement. Any parts of the `Cause` that do\n   * not match the provided condition are excluded from the result.\n   *\n   * You can use this function in two ways:\n   * - With a `Predicate`: A function that evaluates whether a `Cause` should be\n   *   retained based on its value.\n   * - With a `Refinement`: A more specific predicate that can refine the type of\n   *   the `Cause`.\n   *\n   * This is useful when you need to extract specific types of errors, defects, or\n   * interruptions from a `Cause` while discarding unrelated parts.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>\n  /**\n   * Preserves parts of a `Cause` that match a given predicate.\n   *\n   * **Details**\n   *\n   * This function allows you to retain only the parts of a `Cause` structure that\n   * match a specified predicate or refinement. Any parts of the `Cause` that do\n   * not match the provided condition are excluded from the result.\n   *\n   * You can use this function in two ways:\n   * - With a `Predicate`: A function that evaluates whether a `Cause` should be\n   *   retained based on its value.\n   * - With a `Refinement`: A more specific predicate that can refine the type of\n   *   the `Cause`.\n   *\n   * This is useful when you need to extract specific types of errors, defects, or\n   * interruptions from a `Cause` while discarding unrelated parts.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>\n  /**\n   * Preserves parts of a `Cause` that match a given predicate.\n   *\n   * **Details**\n   *\n   * This function allows you to retain only the parts of a `Cause` structure that\n   * match a specified predicate or refinement. Any parts of the `Cause` that do\n   * not match the provided condition are excluded from the result.\n   *\n   * You can use this function in two ways:\n   * - With a `Predicate`: A function that evaluates whether a `Cause` should be\n   *   retained based on its value.\n   * - With a `Refinement`: A more specific predicate that can refine the type of\n   *   the `Cause`.\n   *\n   * This is useful when you need to extract specific types of errors, defects, or\n   * interruptions from a `Cause` while discarding unrelated parts.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>\n} = internal.filter\n\n/**\n * Transforms a `Cause` into a single value using custom handlers for each\n * possible case.\n *\n * **Details**\n *\n * This function processes a `Cause` by applying a set of custom handlers to\n * each possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,\n * `Sequential`, and `Parallel`. The result of this function is a single value\n * of type `Z`. This function allows you to define exactly how to handle each\n * part of a `Cause`, whether it's a failure, defect, interruption, or a\n * combination of these.\n *\n * The options parameter provides handlers for:\n * - `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors\n *   occurred.\n * - `onFail`: Processes a failure with an error of type `E`.\n * - `onDie`: Processes a defect (unexpected error).\n * - `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the\n *   interruption.\n * - `onSequential`: Combines two sequential causes into a single value of type\n *   `Z`.\n * - `onParallel`: Combines two parallel causes into a single value of type `Z`.\n *\n * @since 2.0.0\n * @category Matching\n */\nexport const match: {\n  /**\n   * Transforms a `Cause` into a single value using custom handlers for each\n   * possible case.\n   *\n   * **Details**\n   *\n   * This function processes a `Cause` by applying a set of custom handlers to\n   * each possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,\n   * `Sequential`, and `Parallel`. The result of this function is a single value\n   * of type `Z`. This function allows you to define exactly how to handle each\n   * part of a `Cause`, whether it's a failure, defect, interruption, or a\n   * combination of these.\n   *\n   * The options parameter provides handlers for:\n   * - `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors\n   *   occurred.\n   * - `onFail`: Processes a failure with an error of type `E`.\n   * - `onDie`: Processes a defect (unexpected error).\n   * - `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the\n   *   interruption.\n   * - `onSequential`: Combines two sequential causes into a single value of type\n   *   `Z`.\n   * - `onParallel`: Combines two parallel causes into a single value of type `Z`.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <Z, E>(\n   options: {\n     readonly onEmpty: Z\n     readonly onFail: (error: E) => Z\n     readonly onDie: (defect: unknown) => Z\n     readonly onInterrupt: (fiberId: FiberId.FiberId) => Z\n     readonly onSequential: (left: Z, right: Z) => Z\n     readonly onParallel: (left: Z, right: Z) => Z\n   }\n  ): (self: Cause<E>) => Z\n  /**\n   * Transforms a `Cause` into a single value using custom handlers for each\n   * possible case.\n   *\n   * **Details**\n   *\n   * This function processes a `Cause` by applying a set of custom handlers to\n   * each possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,\n   * `Sequential`, and `Parallel`. The result of this function is a single value\n   * of type `Z`. This function allows you to define exactly how to handle each\n   * part of a `Cause`, whether it's a failure, defect, interruption, or a\n   * combination of these.\n   *\n   * The options parameter provides handlers for:\n   * - `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors\n   *   occurred.\n   * - `onFail`: Processes a failure with an error of type `E`.\n   * - `onDie`: Processes a defect (unexpected error).\n   * - `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the\n   *   interruption.\n   * - `onSequential`: Combines two sequential causes into a single value of type\n   *   `Z`.\n   * - `onParallel`: Combines two parallel causes into a single value of type `Z`.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <Z, E>(\n   self: Cause<E>,\n   options: {\n     readonly onEmpty: Z\n     readonly onFail: (error: E) => Z\n     readonly onDie: (defect: unknown) => Z\n     readonly onInterrupt: (fiberId: FiberId.FiberId) => Z\n     readonly onSequential: (left: Z, right: Z) => Z\n     readonly onParallel: (left: Z, right: Z) => Z\n   }\n  ): Z\n} = internal.match\n\n/**\n * Combines all parts of a `Cause` into a single value by starting with an\n * initial value.\n *\n * **Details**\n *\n * This function processes a `Cause` by starting with an initial value (`zero`)\n * and applying a custom function (`pf`) to combine all elements of the `Cause`\n * into a single result of type `Z`. The custom function determines how each\n * part of the `Cause` contributes to the final result. The function can return\n * an `Option` to either continue combining values or skip specific parts of the\n * `Cause`.\n *\n * This function is useful for tasks such as:\n * - Aggregating error messages from a `Cause` into a single string.\n * - Summarizing the structure of a `Cause` into a simplified result.\n * - Filtering or processing only specific parts of a `Cause`.\n *\n * The reduction proceeds in a top-down manner, visiting all nodes in the\n * `Cause` structure. This gives you complete control over how each part of the\n * `Cause` contributes to the final result.\n *\n * @since 2.0.0\n * @category Reducing\n */\nexport const reduce: {\n  /**\n   * Combines all parts of a `Cause` into a single value by starting with an\n   * initial value.\n   *\n   * **Details**\n   *\n   * This function processes a `Cause` by starting with an initial value (`zero`)\n   * and applying a custom function (`pf`) to combine all elements of the `Cause`\n   * into a single result of type `Z`. The custom function determines how each\n   * part of the `Cause` contributes to the final result. The function can return\n   * an `Option` to either continue combining values or skip specific parts of the\n   * `Cause`.\n   *\n   * This function is useful for tasks such as:\n   * - Aggregating error messages from a `Cause` into a single string.\n   * - Summarizing the structure of a `Cause` into a simplified result.\n   * - Filtering or processing only specific parts of a `Cause`.\n   *\n   * The reduction proceeds in a top-down manner, visiting all nodes in the\n   * `Cause` structure. This gives you complete control over how each part of the\n   * `Cause` contributes to the final result.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z\n  /**\n   * Combines all parts of a `Cause` into a single value by starting with an\n   * initial value.\n   *\n   * **Details**\n   *\n   * This function processes a `Cause` by starting with an initial value (`zero`)\n   * and applying a custom function (`pf`) to combine all elements of the `Cause`\n   * into a single result of type `Z`. The custom function determines how each\n   * part of the `Cause` contributes to the final result. The function can return\n   * an `Option` to either continue combining values or skip specific parts of the\n   * `Cause`.\n   *\n   * This function is useful for tasks such as:\n   * - Aggregating error messages from a `Cause` into a single string.\n   * - Summarizing the structure of a `Cause` into a simplified result.\n   * - Filtering or processing only specific parts of a `Cause`.\n   *\n   * The reduction proceeds in a top-down manner, visiting all nodes in the\n   * `Cause` structure. This gives you complete control over how each part of the\n   * `Cause` contributes to the final result.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <Z, E>(\n   self: Cause<E>,\n   zero: Z,\n   pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>\n  ): Z\n} = internal.reduce\n\n/**\n * Combines all parts of a `Cause` into a single value using a custom reducer\n * and a context.\n *\n * **Details**\n *\n * This function allows you to reduce a `Cause` into a single value of type `Z`\n * using a custom `CauseReducer`. A `CauseReducer` provides methods to handle\n * specific parts of the `Cause`, such as failures, defects, or interruptions.\n * Additionally, this function provides access to a `context` value, which can\n * be used to carry information or maintain state during the reduction process.\n *\n * This is particularly useful when the reduction process needs additional\n * context or configuration, such as:\n * - Aggregating error details with dynamic formatting.\n * - Collecting logs or statistics about the `Cause`.\n * - Performing stateful transformations based on the `context`.\n *\n * @see {@link reduce} To reduce a `Cause` without additional context.\n *\n * @since 2.0.0\n * @category Reducing\n */\nexport const reduceWithContext: {\n  /**\n   * Combines all parts of a `Cause` into a single value using a custom reducer\n   * and a context.\n   *\n   * **Details**\n   *\n   * This function allows you to reduce a `Cause` into a single value of type `Z`\n   * using a custom `CauseReducer`. A `CauseReducer` provides methods to handle\n   * specific parts of the `Cause`, such as failures, defects, or interruptions.\n   * Additionally, this function provides access to a `context` value, which can\n   * be used to carry information or maintain state during the reduction process.\n   *\n   * This is particularly useful when the reduction process needs additional\n   * context or configuration, such as:\n   * - Aggregating error details with dynamic formatting.\n   * - Collecting logs or statistics about the `Cause`.\n   * - Performing stateful transformations based on the `context`.\n   *\n   * @see {@link reduce} To reduce a `Cause` without additional context.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z\n  /**\n   * Combines all parts of a `Cause` into a single value using a custom reducer\n   * and a context.\n   *\n   * **Details**\n   *\n   * This function allows you to reduce a `Cause` into a single value of type `Z`\n   * using a custom `CauseReducer`. A `CauseReducer` provides methods to handle\n   * specific parts of the `Cause`, such as failures, defects, or interruptions.\n   * Additionally, this function provides access to a `context` value, which can\n   * be used to carry information or maintain state during the reduction process.\n   *\n   * This is particularly useful when the reduction process needs additional\n   * context or configuration, such as:\n   * - Aggregating error details with dynamic formatting.\n   * - Collecting logs or statistics about the `Cause`.\n   * - Performing stateful transformations based on the `context`.\n   *\n   * @see {@link reduce} To reduce a `Cause` without additional context.\n   *\n   * @since 2.0.0\n   * @category Reducing\n   */\n  <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z\n} = internal.reduceWithContext\n\n/**\n * Creates an error that indicates a `Fiber` was interrupted.\n *\n * **Details**\n *\n * This function constructs an `InterruptedException` recognized by the Effect\n * runtime. It is usually thrown or returned when a fiber's execution is\n * interrupted by external events or by another fiber. This is particularly\n * helpful in concurrent programs where fibers may halt each other before\n * completion.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const InterruptedException: new(message?: string | undefined) => InterruptedException = core.InterruptedException\n\n/**\n * Checks if a given unknown value is an `InterruptedException`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isInterruptedException: (u: unknown) => u is InterruptedException = core.isInterruptedException\n\n/**\n * Creates an error indicating an invalid method argument.\n *\n * **Details**\n *\n * This function constructs an `IllegalArgumentException`. It is typically\n * thrown or returned when an operation receives improper inputs, such as\n * out-of-range values or invalid object states.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const IllegalArgumentException: new(message?: string | undefined) => IllegalArgumentException =\n  core.IllegalArgumentException\n\n/**\n * Checks if a given unknown value is an `IllegalArgumentException`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException = core.isIllegalArgumentException\n\n/**\n * Creates an error indicating a missing element.\n *\n * **Details**\n *\n * This function constructs a `NoSuchElementException`. It helps you clearly\n * communicate that a required element is unavailable.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const NoSuchElementException: new(message?: string | undefined) => NoSuchElementException =\n  core.NoSuchElementException\n\n/**\n * Checks if a given unknown value is a `NoSuchElementException`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isNoSuchElementException: (u: unknown) => u is NoSuchElementException = core.isNoSuchElementException\n\n/**\n * Creates an error for general runtime errors.\n *\n * **Details**\n *\n * This function constructs a `RuntimeException`, for errors that occur at\n * runtime but are not specifically typed or categorized as interruptions,\n * missing elements, or invalid arguments. It helps unify a wide range of\n * unexpected conditions under a single, recognizable error type.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const RuntimeException: new(message?: string | undefined) => RuntimeException = core.RuntimeException\n\n/**\n * Checks if a given unknown value is a `RuntimeException`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isRuntimeException: (u: unknown) => u is RuntimeException = core.isRuntimeException\n\n/**\n * Creates an error for operations that exceed their expected time.\n *\n * **Details**\n *\n * This function constructs a `TimeoutException`. It is typically used to signal\n * that an operation or fiber did not complete within a designated time limit,\n * allowing you to handle slow or hanging processes.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const TimeoutException: new(message?: string | undefined) => TimeoutException = core.TimeoutException\n\n/**\n * Checks if a given unknown value is a `TimeoutException`.\n *\n * @since 3.15.0\n * @category Guards\n */\nexport const isTimeoutException: (u: unknown) => u is TimeoutException = core.isTimeoutException\n\n/**\n * Creates an instance of `UnknownException`, an error object used to handle\n * unknown errors such as those from rejected promises.\n *\n * **Details**\n *\n * This function constructs an `UnknownException` with flexible behavior for\n * managing the error message and cause.\n *\n * The required `error` argument is passed as the `cause` to the global `Error`\n * constructor, ensuring that the original cause is preserved in the error chain\n * for debugging purposes. This ensures that the origin stack trace is\n * preserved.\n *\n * The `error` argument is always stored in the `error` property of the\n * `UnknownException` instance for reference, regardless of its type.\n *\n * Additionally, if you provide a `message` argument, it is used as the error\n * message. If no `message` is provided, the error message defaults to `\"An\n * unknown error occurred\"`.\n *\n * **When to Use**\n *\n * Use this function when you need to handle unexpected or unknown errors in\n * your application, particularly when the source of the error might not provide\n * a clear message. This is useful for wrapping generic errors thrown from\n * promises or external APIs.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const UnknownException: new(error: unknown, message?: string | undefined) => UnknownException =\n  core.UnknownException\n\n/**\n * Checks if a given unknown value is an `UnknownException`.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isUnknownException: (u: unknown) => u is UnknownException = core.isUnknownException\n\n/**\n * Creates an error indicating resource capacity has been exceeded.\n *\n * **Details**\n *\n * This function constructs an `ExceededCapacityException`, signifying that an\n * operation or resource usage surpassed established limits. This can be\n * essential for concurrency or resource management situations, ensuring your\n * application doesn't go beyond acceptable thresholds.\n *\n * @since 3.5.0\n * @category Errors\n */\nexport const ExceededCapacityException: new(message?: string | undefined) => ExceededCapacityException =\n  core.ExceededCapacityException\n\n/**\n * Checks if a given unknown value is an `ExceededCapacityException`.\n *\n * @since 3.5.0\n * @category Guards\n */\nexport const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException =\n  core.isExceededCapacityException\n\n/**\n * Converts a `Cause` into a human-readable string.\n *\n * **Details**\n *\n * This function pretty-prints the entire `Cause`, including any failures,\n * defects, and interruptions. It can be especially helpful for logging,\n * debugging, or displaying structured errors to users.\n *\n * You can optionally pass `options` to configure how the error cause is\n * rendered. By default, it includes essential details of all errors in the\n * `Cause`.\n *\n * @see {@link prettyErrors} Get a list of `PrettyError` objects instead of a single string.\n *\n * @since 2.0.0\n * @category Formatting\n */\nexport const pretty: <E>(cause: Cause<E>, options?: {\n  readonly renderErrorCause?: boolean | undefined\n}) => string = internal.pretty\n\n/**\n * A shape for prettified errors, optionally including a source span.\n *\n * @since 3.2.0\n * @category Models\n */\nexport interface PrettyError extends Error {\n  readonly span: Span | undefined\n}\n\n/**\n * Returns a list of prettified errors (`PrettyError`) from a `Cause`.\n *\n * **Details**\n *\n * This function inspects the entire `Cause` and produces an array of\n * `PrettyError` objects. Each object may include additional metadata, such as a\n * `Span`, to provide deeper insights into where and how the error occurred.\n *\n * @since 3.2.0\n * @category Formatting\n */\nexport const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError> = internal.prettyErrors\n\n/**\n * Retrieves the original, unproxied error instance from an error object.\n *\n * **Details**\n *\n * This function returns the underlying error object without any\n * library-specific wrapping or proxying that might occur during error handling.\n * This can be essential if you need direct access to the error's native\n * properties, such as stack traces or custom data fields, for detailed\n * debugging or integration with external systems.\n *\n * @since 2.0.0\n * @category Errors\n */\nexport const originalError: <E>(obj: E) => E = core.originalInstance\n","import * as Chunk from \"../../Chunk.js\"\nimport type * as ScheduleDecision from \"../../ScheduleDecision.js\"\nimport type * as Interval from \"../../ScheduleInterval.js\"\nimport * as Intervals from \"../../ScheduleIntervals.js\"\n\n/** @internal */\nexport const OP_CONTINUE = \"Continue\" as const\n\n/** @internal */\nexport type OP_CONTINUE = typeof OP_CONTINUE\n\n/** @internal */\nexport const OP_DONE = \"Done\" as const\n\n/** @internal */\nexport type OP_DONE = typeof OP_DONE\n\n/** @internal */\nexport const _continue = (intervals: Intervals.Intervals): ScheduleDecision.ScheduleDecision => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals\n  }\n}\n\n/** @internal */\nexport const continueWith = (interval: Interval.Interval): ScheduleDecision.ScheduleDecision => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals: Intervals.make(Chunk.of(interval))\n  }\n}\n\n/** @internal */\nexport const done: ScheduleDecision.ScheduleDecision = {\n  _tag: OP_DONE\n}\n\n/** @internal */\nexport const isContinue = (self: ScheduleDecision.ScheduleDecision): self is ScheduleDecision.Continue => {\n  return self._tag === OP_CONTINUE\n}\n\n/** @internal */\nexport const isDone = (self: ScheduleDecision.ScheduleDecision): self is ScheduleDecision.Done => {\n  return self._tag === OP_DONE\n}\n","/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport * as internal from \"./internal/schedule/interval.js\"\nimport type * as Option from \"./Option.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const IntervalTypeId: unique symbol = internal.IntervalTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type IntervalTypeId = typeof IntervalTypeId\n\n/**\n * An `Interval` represents an interval of time. Intervals can encompass all\n * time, or no time at all.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Interval {\n  readonly [IntervalTypeId]: IntervalTypeId\n  readonly startMillis: number\n  readonly endMillis: number\n}\n\n/**\n * Constructs a new interval from the two specified endpoints. If the start\n * endpoint greater than the end endpoint, then a zero size interval will be\n * returned.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (startMillis: number, endMillis: number) => Interval = internal.make\n\n/**\n * An `Interval` of zero-width.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: Interval = internal.empty\n\n/**\n * Returns `true` if this `Interval` is less than `that` interval, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const lessThan: {\n  /**\n   * Returns `true` if this `Interval` is less than `that` interval, `false`\n   * otherwise.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: Interval): (self: Interval) => boolean\n  /**\n   * Returns `true` if this `Interval` is less than `that` interval, `false`\n   * otherwise.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: Interval, that: Interval): boolean\n} = internal.lessThan\n\n/**\n * Returns the minimum of two `Interval`s.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const min: {\n  /**\n   * Returns the minimum of two `Interval`s.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: Interval): (self: Interval) => Interval\n  /**\n   * Returns the minimum of two `Interval`s.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: Interval, that: Interval): Interval\n} = internal.min\n\n/**\n * Returns the maximum of two `Interval`s.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const max: {\n  /**\n   * Returns the maximum of two `Interval`s.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: Interval): (self: Interval) => Interval\n  /**\n   * Returns the maximum of two `Interval`s.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: Interval, that: Interval): Interval\n} = internal.max\n\n/**\n * Returns `true` if the specified `Interval` is empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const isEmpty: (self: Interval) => boolean = internal.isEmpty\n\n/**\n * Returns `true` if the specified `Interval` is non-empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const isNonEmpty: (self: Interval) => boolean = internal.isNonEmpty\n\n/**\n * Computes a new `Interval` which is the intersection of this `Interval` and\n * that `Interval`.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const intersect: {\n  /**\n   * Computes a new `Interval` which is the intersection of this `Interval` and\n   * that `Interval`.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: Interval): (self: Interval) => Interval\n  /**\n   * Computes a new `Interval` which is the intersection of this `Interval` and\n   * that `Interval`.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: Interval, that: Interval): Interval\n} = internal.intersect\n\n/**\n * Calculates the size of the `Interval` as the `Duration` from the start of the\n * interval to the end of the interval.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: (self: Interval) => Duration.Duration = internal.size\n\n/**\n * Computes a new `Interval` which is the union of this `Interval` and that\n * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\n * form a union.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const union: {\n  /**\n   * Computes a new `Interval` which is the union of this `Interval` and that\n   * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\n   * form a union.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: Interval): (self: Interval) => Option.Option<Interval>\n  /**\n   * Computes a new `Interval` which is the union of this `Interval` and that\n   * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\n   * form a union.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: Interval, that: Interval): Option.Option<Interval>\n} = internal.union\n\n/**\n * Construct an `Interval` that includes all time equal to and after the\n * specified start time.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const after: (startMilliseconds: number) => Interval = internal.after\n\n/**\n * Construct an `Interval` that includes all time equal to and before the\n * specified end time.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const before: (endMilliseconds: number) => Interval = internal.before\n","import * as Chunk from \"../../Chunk.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Option from \"../../Option.js\"\nimport * as Interval from \"../../ScheduleInterval.js\"\nimport type * as Intervals from \"../../ScheduleIntervals.js\"\nimport { getBugErrorMessage } from \"../errors.js\"\n\n/** @internal */\nconst IntervalsSymbolKey = \"effect/ScheduleIntervals\"\n\n/** @internal */\nexport const IntervalsTypeId: Intervals.IntervalsTypeId = Symbol.for(\n  IntervalsSymbolKey\n) as Intervals.IntervalsTypeId\n\n/** @internal */\nexport const make = (intervals: Chunk.Chunk<Interval.Interval>): Intervals.Intervals => {\n  return {\n    [IntervalsTypeId]: IntervalsTypeId,\n    intervals\n  }\n}\n/** @internal */\nexport const empty: Intervals.Intervals = make(Chunk.empty())\n\n/** @internal */\nexport const fromIterable = (intervals: Iterable<Interval.Interval>): Intervals.Intervals =>\n  Array.from(intervals).reduce(\n    (intervals, interval) => pipe(intervals, union(make(Chunk.of(interval)))),\n    empty\n  )\n\n/** @internal */\nexport const union = dual<\n  (that: Intervals.Intervals) => (self: Intervals.Intervals) => Intervals.Intervals,\n  (self: Intervals.Intervals, that: Intervals.Intervals) => Intervals.Intervals\n>(2, (self, that) => {\n  if (!Chunk.isNonEmpty(that.intervals)) {\n    return self\n  }\n  if (!Chunk.isNonEmpty(self.intervals)) {\n    return that\n  }\n  if (Chunk.headNonEmpty(self.intervals).startMillis < Chunk.headNonEmpty(that.intervals).startMillis) {\n    return unionLoop(\n      Chunk.tailNonEmpty(self.intervals),\n      that.intervals,\n      Chunk.headNonEmpty(self.intervals),\n      Chunk.empty()\n    )\n  }\n  return unionLoop(\n    self.intervals,\n    Chunk.tailNonEmpty(that.intervals),\n    Chunk.headNonEmpty(that.intervals),\n    Chunk.empty()\n  )\n})\n\n/** @internal */\nconst unionLoop = (\n  _self: Chunk.Chunk<Interval.Interval>,\n  _that: Chunk.Chunk<Interval.Interval>,\n  _interval: Interval.Interval,\n  _acc: Chunk.Chunk<Interval.Interval>\n): Intervals.Intervals => {\n  let self = _self\n  let that = _that\n  let interval = _interval\n  let acc = _acc\n  while (Chunk.isNonEmpty(self) || Chunk.isNonEmpty(that)) {\n    if (!Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {\n      if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {\n        acc = pipe(acc, Chunk.prepend(interval))\n        interval = Chunk.headNonEmpty(that)\n        that = Chunk.tailNonEmpty(that)\n        self = Chunk.empty()\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis)\n        that = Chunk.tailNonEmpty(that)\n        self = Chunk.empty()\n      }\n    } else if (Chunk.isNonEmpty(self) && Chunk.isEmpty(that)) {\n      if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {\n        acc = pipe(acc, Chunk.prepend(interval))\n        interval = Chunk.headNonEmpty(self)\n        that = Chunk.empty()\n        self = Chunk.tailNonEmpty(self)\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis)\n        that = Chunk.empty()\n        self = Chunk.tailNonEmpty(self)\n      }\n    } else if (Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {\n      if (Chunk.headNonEmpty(self).startMillis < Chunk.headNonEmpty(that).startMillis) {\n        if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {\n          acc = pipe(acc, Chunk.prepend(interval))\n          interval = Chunk.headNonEmpty(self)\n          self = Chunk.tailNonEmpty(self)\n        } else {\n          interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis)\n          self = Chunk.tailNonEmpty(self)\n        }\n      } else if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {\n        acc = pipe(acc, Chunk.prepend(interval))\n        interval = Chunk.headNonEmpty(that)\n        that = Chunk.tailNonEmpty(that)\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis)\n        that = Chunk.tailNonEmpty(that)\n      }\n    } else {\n      throw new Error(getBugErrorMessage(\"Intervals.unionLoop\"))\n    }\n  }\n  return make(pipe(acc, Chunk.prepend(interval), Chunk.reverse))\n}\n\n/** @internal */\nexport const intersect = dual<\n  (that: Intervals.Intervals) => (self: Intervals.Intervals) => Intervals.Intervals,\n  (self: Intervals.Intervals, that: Intervals.Intervals) => Intervals.Intervals\n>(2, (self, that) => intersectLoop(self.intervals, that.intervals, Chunk.empty()))\n\n/** @internal */\nconst intersectLoop = (\n  _left: Chunk.Chunk<Interval.Interval>,\n  _right: Chunk.Chunk<Interval.Interval>,\n  _acc: Chunk.Chunk<Interval.Interval>\n): Intervals.Intervals => {\n  let left = _left\n  let right = _right\n  let acc = _acc\n  while (Chunk.isNonEmpty(left) && Chunk.isNonEmpty(right)) {\n    const interval = pipe(Chunk.headNonEmpty(left), Interval.intersect(Chunk.headNonEmpty(right)))\n    const intervals = Interval.isEmpty(interval) ? acc : pipe(acc, Chunk.prepend(interval))\n    if (pipe(Chunk.headNonEmpty(left), Interval.lessThan(Chunk.headNonEmpty(right)))) {\n      left = Chunk.tailNonEmpty(left)\n    } else {\n      right = Chunk.tailNonEmpty(right)\n    }\n    acc = intervals\n  }\n  return make(Chunk.reverse(acc))\n}\n\n/** @internal */\nexport const start = (self: Intervals.Intervals): number => {\n  return pipe(\n    self.intervals,\n    Chunk.head,\n    Option.getOrElse(() => Interval.empty)\n  ).startMillis\n}\n\n/** @internal */\nexport const end = (self: Intervals.Intervals): number => {\n  return pipe(\n    self.intervals,\n    Chunk.head,\n    Option.getOrElse(() => Interval.empty)\n  ).endMillis\n}\n\n/** @internal */\nexport const lessThan = dual<\n  (that: Intervals.Intervals) => (self: Intervals.Intervals) => boolean,\n  (self: Intervals.Intervals, that: Intervals.Intervals) => boolean\n>(2, (self, that) => start(self) < start(that))\n\n/** @internal */\nexport const isNonEmpty = (self: Intervals.Intervals): boolean => {\n  return Chunk.isNonEmpty(self.intervals)\n}\n\n/** @internal */\nexport const max = dual<\n  (that: Intervals.Intervals) => (self: Intervals.Intervals) => Intervals.Intervals,\n  (self: Intervals.Intervals, that: Intervals.Intervals) => Intervals.Intervals\n>(2, (self, that) => lessThan(self, that) ? that : self)\n","/**\n * @since 2.0.0\n */\nimport type * as Check from \"./Chunk.js\"\nimport * as internal from \"./internal/schedule/intervals.js\"\nimport type * as Interval from \"./ScheduleInterval.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const IntervalsTypeId: unique symbol = internal.IntervalsTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type IntervalsTypeId = typeof IntervalsTypeId\n\n/**\n * An `Intervals` represents a list of several `Interval`s.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Intervals {\n  readonly [IntervalsTypeId]: IntervalsTypeId\n  readonly intervals: Check.Chunk<Interval.Interval>\n}\n\n/**\n * Creates a new `Intervals` from a `List` of `Interval`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals = internal.make\n\n/**\n * Constructs an empty list of `Interval`s.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: Intervals = internal.empty\n\n/**\n * Creates `Intervals` from the specified `Iterable<Interval>`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals = internal.fromIterable\n\n/**\n * Computes the union of this `Intervals` and  that `Intervals`\n *\n * @since 2.0.0\n * @category utils\n */\nexport const union: {\n  /**\n   * Computes the union of this `Intervals` and  that `Intervals`\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: Intervals): (self: Intervals) => Intervals\n  /**\n   * Computes the union of this `Intervals` and  that `Intervals`\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: Intervals, that: Intervals): Intervals\n} = internal.union\n\n/**\n * Produces the intersection of this `Intervals` and that `Intervals`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const intersect: {\n  /**\n   * Produces the intersection of this `Intervals` and that `Intervals`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: Intervals): (self: Intervals) => Intervals\n  /**\n   * Produces the intersection of this `Intervals` and that `Intervals`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: Intervals, that: Intervals): Intervals\n} = internal.intersect\n\n/**\n * The start of the earliest interval in the specified `Intervals`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const start: (self: Intervals) => number = internal.start\n\n/**\n * The end of the latest interval in the specified `Intervals`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const end: (self: Intervals) => number = internal.end\n\n/**\n * Returns `true` if the start of this `Intervals` is before the start of that\n * `Intervals`, `false` otherwise.\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const lessThan: {\n  /**\n   * Returns `true` if the start of this `Intervals` is before the start of that\n   * `Intervals`, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: Intervals): (self: Intervals) => boolean\n  /**\n   * Returns `true` if the start of this `Intervals` is before the start of that\n   * `Intervals`, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: Intervals, that: Intervals): boolean\n} = internal.lessThan\n\n/**\n * Returns `true` if this `Intervals` is non-empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isNonEmpty: (self: Intervals) => boolean = internal.isNonEmpty\n\n/**\n * Returns the maximum of the two `Intervals` (i.e. which has the latest start).\n *\n * @since 2.0.0\n * @category ordering\n */\nexport const max: {\n  /**\n   * Returns the maximum of the two `Intervals` (i.e. which has the latest start).\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (that: Intervals): (self: Intervals) => Intervals\n  /**\n   * Returns the maximum of the two `Intervals` (i.e. which has the latest start).\n   *\n   * @since 2.0.0\n   * @category ordering\n   */\n  (self: Intervals, that: Intervals): Intervals\n} = internal.max\n","import * as Duration from \"../../Duration.js\"\nimport { dual } from \"../../Function.js\"\nimport * as Option from \"../../Option.js\"\nimport type * as Interval from \"../../ScheduleInterval.js\"\n\n/** @internal */\nconst IntervalSymbolKey = \"effect/ScheduleInterval\"\n\n/** @internal */\nexport const IntervalTypeId: Interval.IntervalTypeId = Symbol.for(\n  IntervalSymbolKey\n) as Interval.IntervalTypeId\n\n/** @internal */\nexport const empty: Interval.Interval = {\n  [IntervalTypeId]: IntervalTypeId,\n  startMillis: 0,\n  endMillis: 0\n}\n\n/** @internal */\nexport const make = (startMillis: number, endMillis: number): Interval.Interval => {\n  if (startMillis > endMillis) {\n    return empty\n  }\n  return {\n    [IntervalTypeId]: IntervalTypeId,\n    startMillis,\n    endMillis\n  }\n}\n\n/** @internal */\nexport const lessThan = dual<\n  (that: Interval.Interval) => (self: Interval.Interval) => boolean,\n  (self: Interval.Interval, that: Interval.Interval) => boolean\n>(2, (self, that) => min(self, that) === self)\n\n/** @internal */\nexport const min = dual<\n  (that: Interval.Interval) => (self: Interval.Interval) => Interval.Interval,\n  (self: Interval.Interval, that: Interval.Interval) => Interval.Interval\n>(2, (self, that) => {\n  if (self.endMillis <= that.startMillis) return self\n  if (that.endMillis <= self.startMillis) return that\n  if (self.startMillis < that.startMillis) return self\n  if (that.startMillis < self.startMillis) return that\n  if (self.endMillis <= that.endMillis) return self\n  return that\n})\n\n/** @internal */\nexport const max = dual<\n  (that: Interval.Interval) => (self: Interval.Interval) => Interval.Interval,\n  (self: Interval.Interval, that: Interval.Interval) => Interval.Interval\n>(2, (self, that) => min(self, that) === self ? that : self)\n\n/** @internal */\nexport const isEmpty = (self: Interval.Interval): boolean => {\n  return self.startMillis >= self.endMillis\n}\n\n/** @internal */\nexport const isNonEmpty = (self: Interval.Interval): boolean => {\n  return !isEmpty(self)\n}\n\n/** @internal */\nexport const intersect = dual<\n  (that: Interval.Interval) => (self: Interval.Interval) => Interval.Interval,\n  (self: Interval.Interval, that: Interval.Interval) => Interval.Interval\n>(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis)\n  const end = Math.min(self.endMillis, that.endMillis)\n  return make(start, end)\n})\n\n/** @internal */\nexport const size = (self: Interval.Interval): Duration.Duration => {\n  return Duration.millis(self.endMillis - self.startMillis)\n}\n\n/** @internal */\nexport const union = dual<\n  (that: Interval.Interval) => (self: Interval.Interval) => Option.Option<Interval.Interval>,\n  (self: Interval.Interval, that: Interval.Interval) => Option.Option<Interval.Interval>\n>(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis)\n  const end = Math.min(self.endMillis, that.endMillis)\n  return start < end ? Option.none() : Option.some(make(start, end))\n})\n\n/** @internal */\nexport const after = (startMilliseconds: number): Interval.Interval => {\n  return make(startMilliseconds, Number.POSITIVE_INFINITY)\n}\n\n/** @internal */\nexport const before = (endMilliseconds: number): Interval.Interval => {\n  return make(Number.NEGATIVE_INFINITY, endMilliseconds)\n}\n","/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/schedule/decision.js\"\nimport type * as Interval from \"./ScheduleInterval.js\"\nimport type * as Intervals from \"./ScheduleIntervals.js\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type ScheduleDecision = Continue | Done\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Continue {\n  readonly _tag: \"Continue\"\n  readonly intervals: Intervals.Intervals\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Done {\n  readonly _tag: \"Done\"\n}\n\nconst _continue = internal._continue\nexport {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  _continue as continue\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const continueWith: (interval: Interval.Interval) => ScheduleDecision = internal.continueWith\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const done: ScheduleDecision = internal.done\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isContinue: (self: ScheduleDecision) => self is Continue = internal.isContinue\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isDone: (self: ScheduleDecision) => self is Done = internal.isDone\n","import * as Cause from \"../Cause.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type * as Exit from \"../Exit.js\"\nimport type { FiberRef } from \"../FiberRef.js\"\nimport * as FiberRefsPatch from \"../FiberRefsPatch.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constTrue, dual, pipe } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as Layer from \"../Layer.js\"\nimport type * as ManagedRuntime from \"../ManagedRuntime.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as Runtime from \"../Runtime.js\"\nimport type * as Schedule from \"../Schedule.js\"\nimport * as ScheduleDecision from \"../ScheduleDecision.js\"\nimport * as Intervals from \"../ScheduleIntervals.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as Synchronized from \"../SynchronizedRef.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport type * as Types from \"../Types.js\"\nimport * as effect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as circular from \"./effect/circular.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as circularManagedRuntime from \"./managedRuntime/circular.js\"\nimport * as EffectOpCodes from \"./opCodes/effect.js\"\nimport * as OpCodes from \"./opCodes/layer.js\"\nimport * as ref from \"./ref.js\"\nimport * as runtime from \"./runtime.js\"\nimport * as runtimeFlags from \"./runtimeFlags.js\"\nimport * as synchronized from \"./synchronizedRef.js\"\nimport * as tracer from \"./tracer.js\"\n\n/** @internal */\nconst LayerSymbolKey = \"effect/Layer\"\n\n/** @internal */\nexport const LayerTypeId: Layer.LayerTypeId = Symbol.for(\n  LayerSymbolKey\n) as Layer.LayerTypeId\n\nconst layerVariance = {\n  /* c8 ignore next */\n  _RIn: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _ROut: (_: unknown) => _\n}\n\n/** @internal */\nexport const proto = {\n  [LayerTypeId]: layerVariance,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nconst MemoMapTypeIdKey = \"effect/Layer/MemoMap\"\n\n/** @internal */\nexport const MemoMapTypeId: Layer.MemoMapTypeId = Symbol.for(\n  MemoMapTypeIdKey\n) as Layer.MemoMapTypeId\n\n/** @internal */\nexport const CurrentMemoMap = Context.Reference<Layer.CurrentMemoMap>()(\"effect/Layer/CurrentMemoMap\", {\n  defaultValue: () => unsafeMakeMemoMap()\n})\n\n/** @internal */\nexport type Primitive =\n  | ExtendScope\n  | Fold\n  | Fresh\n  | FromEffect\n  | Scoped\n  | Suspend\n  | Locally\n  | ProvideTo\n  | ZipWith\n  | ZipWithPar\n\n/** @internal */\nexport type Op<Tag extends string, Body = {}> = Layer.Layer<unknown, unknown, unknown> & Body & {\n  readonly _op_layer: Tag\n}\n\n/** @internal */\nexport interface ExtendScope extends\n  Op<OpCodes.OP_EXTEND_SCOPE, {\n    readonly layer: Layer.Layer<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface Fold extends\n  Op<OpCodes.OP_FOLD, {\n    readonly layer: Layer.Layer<unknown>\n    failureK(cause: Cause.Cause<unknown>): Layer.Layer<unknown>\n    successK(context: Context.Context<unknown>): Layer.Layer<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface Fresh extends\n  Op<OpCodes.OP_FRESH, {\n    readonly layer: Layer.Layer<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface FromEffect extends\n  Op<OpCodes.OP_FROM_EFFECT, {\n    readonly effect: Effect.Effect<unknown, unknown, Context.Context<unknown>>\n  }>\n{}\n\n/** @internal */\nexport interface Scoped extends\n  Op<OpCodes.OP_SCOPED, {\n    readonly effect: Effect.Effect<unknown, unknown, Context.Context<unknown>>\n  }>\n{}\n\n/** @internal */\nexport interface Suspend extends\n  Op<OpCodes.OP_SUSPEND, {\n    evaluate(): Layer.Layer<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface Locally extends\n  Op<\"Locally\", {\n    readonly self: Layer.Layer<unknown>\n    f(_: Effect.Effect<any, any, any>): Effect.Effect<any, any, any>\n  }>\n{}\n\n/** @internal */\nexport interface ProvideTo extends\n  Op<OpCodes.OP_PROVIDE, {\n    readonly first: Layer.Layer<unknown>\n    readonly second: Layer.Layer<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface ZipWith extends\n  Op<OpCodes.OP_PROVIDE_MERGE, {\n    readonly first: Layer.Layer<unknown>\n    readonly second: Layer.Layer<unknown>\n    zipK(left: Context.Context<unknown>, right: Context.Context<unknown>): Context.Context<unknown>\n  }>\n{}\n\n/** @internal */\nexport interface ZipWithPar extends\n  Op<OpCodes.OP_ZIP_WITH, {\n    readonly first: Layer.Layer<unknown>\n    readonly second: Layer.Layer<unknown>\n    zipK(left: Context.Context<unknown>, right: Context.Context<unknown>): Context.Context<unknown>\n  }>\n{}\n\n/** @internal */\nexport const isLayer = (u: unknown): u is Layer.Layer<unknown, unknown, unknown> => hasProperty(u, LayerTypeId)\n\n/** @internal */\nexport const isFresh = <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>): boolean => {\n  return (self as Primitive)._op_layer === OpCodes.OP_FRESH\n}\n\n// -----------------------------------------------------------------------------\n// MemoMap\n// -----------------------------------------------------------------------------\n\n/** @internal */\nclass MemoMapImpl implements Layer.MemoMap {\n  readonly [MemoMapTypeId]: Layer.MemoMapTypeId\n  constructor(\n    readonly ref: Synchronized.SynchronizedRef<\n      Map<\n        Layer.Layer<any, any, any>,\n        readonly [Effect.Effect<any, any>, Scope.Scope.Finalizer]\n      >\n    >\n  ) {\n    this[MemoMapTypeId] = MemoMapTypeId\n  }\n\n  /**\n   * Checks the memo map to see if a layer exists. If it is, immediately\n   * returns it. Otherwise, obtains the layer, stores it in the memo map,\n   * and adds a finalizer to the `Scope`.\n   */\n  getOrElseMemoize<RIn, E, ROut>(\n    layer: Layer.Layer<ROut, E, RIn>,\n    scope: Scope.Scope\n  ): Effect.Effect<Context.Context<ROut>, E, RIn> {\n    return pipe(\n      synchronized.modifyEffect(this.ref, (map) => {\n        const inMap = map.get(layer)\n        if (inMap !== undefined) {\n          const [acquire, release] = inMap\n          const cached: Effect.Effect<Context.Context<ROut>, E> = pipe(\n            acquire as Effect.Effect<readonly [FiberRefsPatch.FiberRefsPatch, Context.Context<ROut>], E>,\n            core.flatMap(([patch, b]) => pipe(effect.patchFiberRefs(patch), core.as(b))),\n            core.onExit(core.exitMatch({\n              onFailure: () => core.void,\n              onSuccess: () => core.scopeAddFinalizerExit(scope, release)\n            }))\n          )\n          return core.succeed([cached, map] as const)\n        }\n        return pipe(\n          ref.make(0),\n          core.flatMap((observers) =>\n            pipe(\n              core.deferredMake<readonly [FiberRefsPatch.FiberRefsPatch, Context.Context<ROut>], E>(),\n              core.flatMap((deferred) =>\n                pipe(\n                  ref.make<Scope.Scope.Finalizer>(() => core.void),\n                  core.map((finalizerRef) => {\n                    const resource = core.uninterruptibleMask((restore) =>\n                      pipe(\n                        fiberRuntime.scopeMake(),\n                        core.flatMap((innerScope) =>\n                          pipe(\n                            restore(core.flatMap(\n                              makeBuilder(layer, innerScope, true),\n                              (f) => effect.diffFiberRefs(f(this))\n                            )),\n                            core.exit,\n                            core.flatMap((exit) => {\n                              switch (exit._tag) {\n                                case EffectOpCodes.OP_FAILURE: {\n                                  return pipe(\n                                    core.deferredFailCause(deferred, exit.effect_instruction_i0),\n                                    core.zipRight(core.scopeClose(innerScope, exit)),\n                                    core.zipRight(core.failCause(exit.effect_instruction_i0))\n                                  )\n                                }\n                                case EffectOpCodes.OP_SUCCESS: {\n                                  return pipe(\n                                    ref.set(finalizerRef, (exit) =>\n                                      pipe(\n                                        core.scopeClose(innerScope, exit),\n                                        core.whenEffect(\n                                          ref.modify(observers, (n) => [n === 1, n - 1] as const)\n                                        ),\n                                        core.asVoid\n                                      )),\n                                    core.zipRight(ref.update(observers, (n) => n + 1)),\n                                    core.zipRight(\n                                      core.scopeAddFinalizerExit(scope, (exit) =>\n                                        pipe(\n                                          core.sync(() => map.delete(layer)),\n                                          core.zipRight(ref.get(finalizerRef)),\n                                          core.flatMap((finalizer) => finalizer(exit))\n                                        ))\n                                    ),\n                                    core.zipRight(core.deferredSucceed(deferred, exit.effect_instruction_i0)),\n                                    core.as(exit.effect_instruction_i0[1])\n                                  )\n                                }\n                              }\n                            })\n                          )\n                        )\n                      )\n                    )\n                    const memoized = [\n                      pipe(\n                        core.deferredAwait(deferred),\n                        core.onExit(core.exitMatchEffect({\n                          onFailure: () => core.void,\n                          onSuccess: () => ref.update(observers, (n) => n + 1)\n                        }))\n                      ),\n                      (exit: Exit.Exit<unknown, unknown>) =>\n                        pipe(\n                          ref.get(finalizerRef),\n                          core.flatMap((finalizer) => finalizer(exit))\n                        )\n                    ] as const\n                    return [\n                      resource,\n                      isFresh(layer) ? map : map.set(layer, memoized)\n                    ] as const\n                  })\n                )\n              )\n            )\n          )\n        )\n      }),\n      core.flatten\n    )\n  }\n}\n\n/** @internal */\nexport const makeMemoMap: Effect.Effect<Layer.MemoMap> = core.suspend(() =>\n  core.map(\n    circular.makeSynchronized<\n      Map<\n        Layer.Layer<any, any, any>,\n        readonly [\n          Effect.Effect<any, any>,\n          Scope.Scope.Finalizer\n        ]\n      >\n    >(new Map()),\n    (ref) => new MemoMapImpl(ref)\n  )\n)\n\n/** @internal */\nexport const unsafeMakeMemoMap = (): Layer.MemoMap => new MemoMapImpl(circular.unsafeMakeSynchronized(new Map()))\n\n/** @internal */\nexport const build = <RIn, E, ROut>(\n  self: Layer.Layer<ROut, E, RIn>\n): Effect.Effect<Context.Context<ROut>, E, RIn | Scope.Scope> =>\n  fiberRuntime.scopeWith((scope) => buildWithScope(self, scope))\n\n/** @internal */\nexport const buildWithScope = dual<\n  (\n    scope: Scope.Scope\n  ) => <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>,\n  <RIn, E, ROut>(\n    self: Layer.Layer<ROut, E, RIn>,\n    scope: Scope.Scope\n  ) => Effect.Effect<Context.Context<ROut>, E, RIn>\n>(2, (self, scope) =>\n  core.flatMap(\n    makeMemoMap,\n    (memoMap) => buildWithMemoMap(self, memoMap, scope)\n  ))\n\n/** @internal */\nexport const buildWithMemoMap = dual<\n  (\n    memoMap: Layer.MemoMap,\n    scope: Scope.Scope\n  ) => <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>,\n  <RIn, E, ROut>(\n    self: Layer.Layer<ROut, E, RIn>,\n    memoMap: Layer.MemoMap,\n    scope: Scope.Scope\n  ) => Effect.Effect<Context.Context<ROut>, E, RIn>\n>(\n  3,\n  (self, memoMap, scope) =>\n    core.flatMap(\n      makeBuilder(self, scope),\n      (run) => effect.provideService(run(memoMap), CurrentMemoMap, memoMap)\n    )\n)\n\nconst makeBuilder = <RIn, E, ROut>(\n  self: Layer.Layer<ROut, E, RIn>,\n  scope: Scope.Scope,\n  inMemoMap = false\n): Effect.Effect<(memoMap: Layer.MemoMap) => Effect.Effect<Context.Context<ROut>, E, RIn>> => {\n  const op = self as Primitive\n  switch (op._op_layer) {\n    case \"Locally\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope)))\n    }\n    case \"ExtendScope\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) =>\n        fiberRuntime.scopeWith(\n          (scope) => memoMap.getOrElseMemoize(op.layer, scope)\n        ) as unknown as Effect.Effect<Context.Context<ROut>, E, RIn>\n      )\n    }\n    case \"Fold\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) =>\n        pipe(\n          memoMap.getOrElseMemoize(op.layer, scope),\n          core.matchCauseEffect({\n            onFailure: (cause) => memoMap.getOrElseMemoize(op.failureK(cause), scope),\n            onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope)\n          })\n        )\n      )\n    }\n    case \"Fresh\": {\n      return core.sync(() => (_: Layer.MemoMap) => pipe(op.layer, buildWithScope(scope)))\n    }\n    case \"FromEffect\": {\n      return inMemoMap\n        ? core.sync(() => (_: Layer.MemoMap) => op.effect as Effect.Effect<Context.Context<ROut>, E, RIn>)\n        : core.sync(() => (memoMap: Layer.MemoMap) => memoMap.getOrElseMemoize(self, scope))\n    }\n    case \"Provide\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) =>\n        pipe(\n          memoMap.getOrElseMemoize(op.first, scope),\n          core.flatMap((env) =>\n            pipe(\n              memoMap.getOrElseMemoize(op.second, scope),\n              core.provideContext(env)\n            )\n          )\n        )\n      )\n    }\n    case \"Scoped\": {\n      return inMemoMap\n        ? core.sync(() => (_: Layer.MemoMap) =>\n          fiberRuntime.scopeExtend(\n            op.effect as Effect.Effect<Context.Context<ROut>, E, RIn>,\n            scope\n          )\n        )\n        : core.sync(() => (memoMap: Layer.MemoMap) => memoMap.getOrElseMemoize(self, scope))\n    }\n    case \"Suspend\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) =>\n        memoMap.getOrElseMemoize(\n          op.evaluate(),\n          scope\n        )\n      )\n    }\n    case \"ProvideMerge\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) =>\n        pipe(\n          memoMap.getOrElseMemoize(op.first, scope),\n          core.zipWith(\n            memoMap.getOrElseMemoize(op.second, scope),\n            op.zipK\n          )\n        )\n      )\n    }\n    case \"ZipWith\": {\n      return core.sync(() => (memoMap: Layer.MemoMap) =>\n        pipe(\n          memoMap.getOrElseMemoize(op.first, scope),\n          fiberRuntime.zipWithOptions(\n            memoMap.getOrElseMemoize(op.second, scope),\n            op.zipK,\n            { concurrent: true }\n          )\n        )\n      )\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Layer\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const catchAll = dual<\n  <E, RIn2, E2, ROut2>(\n    onError: (error: E) => Layer.Layer<ROut2, E2, RIn2>\n  ) => <RIn, ROut>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut & ROut2, E2, RIn | RIn2>,\n  <RIn, E, ROut, RIn2, E2, ROut2>(\n    self: Layer.Layer<ROut, E, RIn>,\n    onError: (error: E) => Layer.Layer<ROut2, E2, RIn2>\n  ) => Layer.Layer<ROut & ROut2, E2, RIn | RIn2>\n>(2, (self, onFailure) => match(self, { onFailure, onSuccess: succeedContext }))\n\n/** @internal */\nexport const catchAllCause = dual<\n  <E, RIn2, E2, ROut2>(\n    onError: (cause: Cause.Cause<E>) => Layer.Layer<ROut2, E2, RIn2>\n  ) => <RIn, ROut>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut & ROut2, E2, RIn | RIn2>,\n  <RIn, E, ROut, RIn2, E2, ROut22>(\n    self: Layer.Layer<ROut, E, RIn>,\n    onError: (cause: Cause.Cause<E>) => Layer.Layer<ROut22, E2, RIn2>\n  ) => Layer.Layer<ROut & ROut22, E2, RIn | RIn2>\n>(2, (self, onFailure) => matchCause(self, { onFailure, onSuccess: succeedContext }))\n\n/** @internal */\nexport const die = (defect: unknown): Layer.Layer<unknown> => failCause(Cause.die(defect))\n\n/** @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Layer.Layer<unknown> => failCauseSync(() => Cause.die(evaluate()))\n\n/** @internal */\nexport const discard = <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>): Layer.Layer<never, E, RIn> =>\n  map(self, () => Context.empty())\n\n/** @internal */\nexport const context = <R>(): Layer.Layer<R, never, R> => fromEffectContext(core.context<R>())\n\n/** @internal */\nexport const extendScope = <RIn, E, ROut>(\n  self: Layer.Layer<ROut, E, RIn>\n): Layer.Layer<ROut, E, RIn | Scope.Scope> => {\n  const extendScope = Object.create(proto)\n  extendScope._op_layer = OpCodes.OP_EXTEND_SCOPE\n  extendScope.layer = self\n  return extendScope\n}\n\n/** @internal */\nexport const fail = <E>(error: E): Layer.Layer<unknown, E> => failCause(Cause.fail(error))\n\n/** @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Layer.Layer<unknown, E> =>\n  failCauseSync(() => Cause.fail(evaluate()))\n\n/** @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Layer.Layer<unknown, E> => fromEffectContext(core.failCause(cause))\n\n/** @internal */\nexport const failCauseSync = <E>(evaluate: LazyArg<Cause.Cause<E>>): Layer.Layer<unknown, E> =>\n  fromEffectContext(core.failCauseSync(evaluate))\n\n/** @internal */\nexport const flatMap = dual<\n  <A, A2, E2, R2>(\n    f: (context: Context.Context<A>) => Layer.Layer<A2, E2, R2>\n  ) => <E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Layer.Layer<A, E, R>,\n    f: (context: Context.Context<A>) => Layer.Layer<A2, E2, R2>\n  ) => Layer.Layer<A2, E | E2, R | R2>\n>(2, (self, f) => match(self, { onFailure: fail, onSuccess: f }))\n\n/** @internal */\nexport const flatten = dual<\n  <I, A, E2, R2>(\n    tag: Context.Tag<I, Layer.Layer<A, E2, R2>>\n  ) => <E, R>(\n    self: Layer.Layer<I, E, R>\n  ) => Layer.Layer<A, E | E2, R | R2>,\n  <I, E, R, A, E2, R2>(\n    self: Layer.Layer<I, E, R>,\n    tag: Context.Tag<I, Layer.Layer<A, E2, R2>>\n  ) => Layer.Layer<A, E | E2, R | R2>\n>(2, (self, tag) => flatMap(self, Context.get(tag as any) as any))\n\n/** @internal */\nexport const fresh = <A, E, R>(self: Layer.Layer<A, E, R>): Layer.Layer<A, E, R> => {\n  const fresh = Object.create(proto)\n  fresh._op_layer = OpCodes.OP_FRESH\n  fresh.layer = self\n  return fresh\n}\n\n/** @internal */\nexport const fromEffect = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>\n  ) => <E, R>(\n    effect: Effect.Effect<Types.NoInfer<S>, E, R>\n  ) => Layer.Layer<I, E, R>,\n  <I, S, E, R>(\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E, R>\n  ) => Layer.Layer<I, E, R>\n>(2, (a, b) => {\n  const tagFirst = Context.isTag(a)\n  const tag = (tagFirst ? a : b) as Context.Tag<unknown, unknown>\n  const effect = tagFirst ? b : a\n  return fromEffectContext(core.map(effect, (service) => Context.make(tag, service)))\n})\n\n/** @internal */\nexport const fromEffectDiscard = <X, E, R>(effect: Effect.Effect<X, E, R>) =>\n  fromEffectContext(core.map(effect, () => Context.empty()))\n\n/** @internal */\nexport function fromEffectContext<A, E, R>(\n  effect: Effect.Effect<Context.Context<A>, E, R>\n): Layer.Layer<A, E, R> {\n  const fromEffect = Object.create(proto)\n  fromEffect._op_layer = OpCodes.OP_FROM_EFFECT\n  fromEffect.effect = effect\n  return fromEffect\n}\n\n/** @internal */\nexport const fiberRefLocally = dual<\n  <X>(ref: FiberRef<X>, value: X) => <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>,\n  <A, E, R, X>(self: Layer.Layer<A, E, R>, ref: FiberRef<X>, value: X) => Layer.Layer<A, E, R>\n>(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocally(ref, value)))\n\n/** @internal */\nexport const locallyEffect = dual<\n  <RIn, E, ROut, RIn2, E2, ROut2>(\n    f: (_: Effect.Effect<RIn, E, Context.Context<ROut>>) => Effect.Effect<RIn2, E2, Context.Context<ROut2>>\n  ) => (self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut2, E2, RIn2>,\n  <RIn, E, ROut, RIn2, E2, ROut2>(\n    self: Layer.Layer<ROut, E, RIn>,\n    f: (_: Effect.Effect<RIn, E, Context.Context<ROut>>) => Effect.Effect<RIn2, E2, Context.Context<ROut2>>\n  ) => Layer.Layer<ROut2, E2, RIn2>\n>(2, (self, f) => {\n  const locally = Object.create(proto)\n  locally._op_layer = \"Locally\"\n  locally.self = self\n  locally.f = f\n  return locally\n})\n\n/** @internal */\nexport const fiberRefLocallyWith = dual<\n  <X>(ref: FiberRef<X>, value: (_: X) => X) => <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>,\n  <A, E, R, X>(self: Layer.Layer<A, E, R>, ref: FiberRef<X>, value: (_: X) => X) => Layer.Layer<A, E, R>\n>(3, (self, ref, value) => locallyEffect(self, core.fiberRefLocallyWith(ref, value)))\n\n/** @internal */\nexport const fiberRefLocallyScoped = <A>(self: FiberRef<A>, value: A): Layer.Layer<never> =>\n  scopedDiscard(fiberRuntime.fiberRefLocallyScoped(self, value))\n\n/** @internal */\nexport const fiberRefLocallyScopedWith = <A>(self: FiberRef<A>, value: (_: A) => A): Layer.Layer<never> =>\n  scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(self, value))\n\n/** @internal */\nexport const fromFunction = <I1, S1, I2, S2>(\n  tagA: Context.Tag<I1, S1>,\n  tagB: Context.Tag<I2, S2>,\n  f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>\n): Layer.Layer<I2, never, I1> => fromEffectContext(core.map(tagA, (a) => Context.make(tagB, f(a))))\n\n/** @internal */\nexport const launch = <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>): Effect.Effect<never, E, RIn> =>\n  fiberRuntime.scopedEffect(\n    core.zipRight(\n      fiberRuntime.scopeWith((scope) => pipe(self, buildWithScope(scope))),\n      core.never\n    )\n  )\n\n/** @internal */\nexport const mock: {\n  <I, S extends object>(tag: Context.Tag<I, S>): (service: Layer.PartialEffectful<S>) => Layer.Layer<I>\n  <I, S extends object>(tag: Context.Tag<I, S>, service: Layer.PartialEffectful<S>): Layer.Layer<I>\n} = function() {\n  if (arguments.length === 1) {\n    return (service: Layer.PartialEffectful<any>) => mockImpl(arguments[0], service)\n  }\n  return mockImpl(arguments[0], arguments[1])\n} as any\n\nconst mockImpl = <I, S extends object>(tag: Context.Tag<I, S>, service: Layer.PartialEffectful<S>): Layer.Layer<I> =>\n  succeed(\n    tag,\n    new Proxy({ ...service as object } as S, {\n      get(target, prop, _receiver) {\n        if (prop in target) {\n          return target[prop as keyof S]\n        }\n        const prevLimit = Error.stackTraceLimit\n        Error.stackTraceLimit = 2\n        const error = new Error(`${tag.key}: Unimplemented method \"${prop.toString()}\"`)\n        Error.stackTraceLimit = prevLimit\n        error.name = \"UnimplementedError\"\n        return makeUnimplemented(error)\n      },\n      has: constTrue\n    })\n  )\n\nconst makeUnimplemented = (error: Error) => {\n  const dead = core.die(error)\n  function unimplemented() {\n    return dead\n  }\n  // @effect-diagnostics-next-line floatingEffect:off\n  Object.assign(unimplemented, dead)\n  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead))\n  return unimplemented\n}\n\n/** @internal */\nexport const map = dual<\n  <A, B>(\n    f: (context: Context.Context<A>) => Context.Context<B>\n  ) => <E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<B, E, R>,\n  <A, E, R, B>(\n    self: Layer.Layer<A, E, R>,\n    f: (context: Context.Context<A>) => Context.Context<B>\n  ) => Layer.Layer<B, E, R>\n>(2, (self, f) => flatMap(self, (context) => succeedContext(f(context))))\n\n/** @internal */\nexport const mapError = dual<\n  <E, E2>(f: (error: E) => E2) => <A, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E2, R>,\n  <A, E, R, E2>(self: Layer.Layer<A, E, R>, f: (error: E) => E2) => Layer.Layer<A, E2, R>\n>(2, (self, f) => catchAll(self, (error) => failSync(() => f(error))))\n\n/** @internal */\nexport const matchCause = dual<\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Layer.Layer<A2, E2, R2>\n      readonly onSuccess: (context: Context.Context<A>) => Layer.Layer<A3, E3, R3>\n    }\n  ) => <R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A2 & A3, E2 | E3, R | R2 | R3>,\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Layer.Layer<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Layer.Layer<A2, E2, R2>\n      readonly onSuccess: (context: Context.Context<A>) => Layer.Layer<A3, E3, R3>\n    }\n  ) => Layer.Layer<A2 & A3, E2 | E3, R | R2 | R3>\n>(2, (self, { onFailure, onSuccess }) => {\n  const fold = Object.create(proto)\n  fold._op_layer = OpCodes.OP_FOLD\n  fold.layer = self\n  fold.failureK = onFailure\n  fold.successK = onSuccess\n  return fold\n})\n\n/** @internal */\nexport const match = dual<\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (error: E) => Layer.Layer<A2, E2, R2>\n      readonly onSuccess: (context: Context.Context<A>) => Layer.Layer<A3, E3, R3>\n    }\n  ) => <R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A2 & A3, E2 | E3, R | R2 | R3>,\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Layer.Layer<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => Layer.Layer<A2, E2, R2>\n      readonly onSuccess: (context: Context.Context<A>) => Layer.Layer<A3, E3, R3>\n    }\n  ) => Layer.Layer<A2 & A3, E2 | E3, R | R2 | R3>\n>(2, (self, { onFailure, onSuccess }) =>\n  matchCause(self, {\n    onFailure: (cause) => {\n      const failureOrCause = Cause.failureOrCause(cause)\n      switch (failureOrCause._tag) {\n        case \"Left\": {\n          return onFailure(failureOrCause.left)\n        }\n        case \"Right\": {\n          return failCause(failureOrCause.right)\n        }\n      }\n    },\n    onSuccess\n  }))\n\n/** @internal */\nexport const memoize = <RIn, E, ROut>(\n  self: Layer.Layer<ROut, E, RIn>\n): Effect.Effect<Layer.Layer<ROut, E, RIn>, never, Scope.Scope> =>\n  fiberRuntime.scopeWith((scope) =>\n    core.map(\n      effect.memoize(buildWithScope(self, scope)),\n      fromEffectContext\n    )\n  )\n\n/** @internal */\nexport const merge = dual<\n  <RIn2, E2, ROut2>(\n    that: Layer.Layer<ROut2, E2, RIn2>\n  ) => <RIn, E1, ROut>(self: Layer.Layer<ROut, E1, RIn>) => Layer.Layer<\n    ROut | ROut2,\n    E1 | E2,\n    RIn | RIn2\n  >,\n  <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer.Layer<ROut, E1, RIn>, that: Layer.Layer<ROut2, E2, RIn2>) => Layer.Layer<\n    ROut | ROut2,\n    E1 | E2,\n    RIn | RIn2\n  >\n>(2, (self, that) => zipWith(self, that, (a, b) => Context.merge(a, b)))\n\n/** @internal */\nexport const mergeAll = <\n  Layers extends readonly [Layer.Layer<never, any, any>, ...Array<Layer.Layer<never, any, any>>]\n>(\n  ...layers: Layers\n): Layer.Layer<\n  { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number],\n  { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n  { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n> => {\n  let final = layers[0]\n  for (let i = 1; i < layers.length; i++) {\n    final = merge(final, layers[i])\n  }\n  return final as any\n}\n\n/** @internal */\nexport const orDie = <A, E, R>(self: Layer.Layer<A, E, R>): Layer.Layer<A, never, R> =>\n  catchAll(self, (defect) => die(defect))\n\n/** @internal */\nexport const orElse = dual<\n  <A2, E2, R2>(\n    that: LazyArg<Layer.Layer<A2, E2, R2>>\n  ) => <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A & A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Layer.Layer<A, E, R>,\n    that: LazyArg<Layer.Layer<A2, E2, R2>>\n  ) => Layer.Layer<A & A2, E | E2, R | R2>\n>(2, (self, that) => catchAll(self, that))\n\n/** @internal */\nexport const passthrough = <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>): Layer.Layer<RIn | ROut, E, RIn> =>\n  merge(context<RIn>(), self)\n\n/** @internal */\nexport const project = dual<\n  <I1, S1, I2, S2>(\n    tagA: Context.Tag<I1, S1>,\n    tagB: Context.Tag<I2, S2>,\n    f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>\n  ) => <RIn, E>(self: Layer.Layer<I1, E, RIn>) => Layer.Layer<I2, E, RIn>,\n  <RIn, E, I1, S1, I2, S2>(\n    self: Layer.Layer<I1, E, RIn>,\n    tagA: Context.Tag<I1, S1>,\n    tagB: Context.Tag<I2, S2>,\n    f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>\n  ) => Layer.Layer<I2, E, RIn>\n>(4, (self, tagA, tagB, f) => map(self, (context) => Context.make(tagB, f(Context.unsafeGet(context, tagA)))))\n\n/** @internal */\nexport const retry = dual<\n  <X, E, RIn2>(\n    schedule: Schedule.Schedule<X, E, RIn2>\n  ) => <ROut, RIn>(\n    self: Layer.Layer<ROut, E, RIn>\n  ) => Layer.Layer<ROut, E, RIn | RIn2>,\n  <ROut, E, RIn, X, RIn2>(\n    self: Layer.Layer<ROut, E, RIn>,\n    schedule: Schedule.Schedule<X, E, RIn2>\n  ) => Layer.Layer<ROut, E, RIn | RIn2>\n>(2, (self, schedule) =>\n  suspend(() => {\n    const stateTag = Context.GenericTag<{ state: unknown }>(\"effect/Layer/retry/{ state: unknown }\")\n    return pipe(\n      succeed(stateTag, { state: schedule.initial }),\n      flatMap((env: Context.Context<{ state: unknown }>) =>\n        retryLoop(self, schedule, stateTag, pipe(env, Context.get(stateTag)).state)\n      )\n    )\n  }))\n\nconst retryLoop = <ROut, E, RIn, X, RIn2>(\n  self: Layer.Layer<ROut, E, RIn>,\n  schedule: Schedule.Schedule<X, E, RIn2>,\n  stateTag: Context.Tag<{ state: unknown }, { state: unknown }>,\n  state: unknown\n): Layer.Layer<ROut, E, RIn | RIn2> => {\n  return pipe(\n    self,\n    catchAll((error) =>\n      pipe(\n        retryUpdate(schedule, stateTag, error, state),\n        flatMap((env) => fresh(retryLoop(self, schedule, stateTag, pipe(env, Context.get(stateTag)).state)))\n      )\n    )\n  )\n}\n\nconst retryUpdate = <X, E, RIn>(\n  schedule: Schedule.Schedule<X, E, RIn>,\n  stateTag: Context.Tag<{ state: unknown }, { state: unknown }>,\n  error: E,\n  state: unknown\n): Layer.Layer<{ state: unknown }, E, RIn> => {\n  return fromEffect(\n    stateTag,\n    pipe(\n      Clock.currentTimeMillis,\n      core.flatMap((now) =>\n        pipe(\n          schedule.step(now, error, state),\n          core.flatMap(([state, _, decision]) =>\n            ScheduleDecision.isDone(decision) ?\n              core.fail(error) :\n              pipe(\n                Clock.sleep(Duration.millis(Intervals.start(decision.intervals) - now)),\n                core.as({ state })\n              )\n          )\n        )\n      )\n    )\n  )\n}\n\n/** @internal */\nexport const scoped = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>\n  ) => <E, R>(\n    effect: Effect.Effect<Types.NoInfer<S>, E, R>\n  ) => Layer.Layer<I, E, Exclude<R, Scope.Scope>>,\n  <I, S, E, R>(\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E, R>\n  ) => Layer.Layer<I, E, Exclude<R, Scope.Scope>>\n>(2, (a, b) => {\n  const tagFirst = Context.isTag(a)\n  const tag = (tagFirst ? a : b) as Context.Tag<unknown, unknown>\n  const effect = tagFirst ? b : a\n  return scopedContext(core.map(effect, (service) => Context.make(tag, service)))\n})\n\n/** @internal */\nexport const scopedDiscard = <X, E, R>(\n  effect: Effect.Effect<X, E, R>\n): Layer.Layer<never, E, Exclude<R, Scope.Scope>> => scopedContext(pipe(effect, core.as(Context.empty())))\n\n/** @internal */\nexport const scopedContext = <A, E, R>(\n  effect: Effect.Effect<Context.Context<A>, E, R>\n): Layer.Layer<A, E, Exclude<R, Scope.Scope>> => {\n  const scoped = Object.create(proto)\n  scoped._op_layer = OpCodes.OP_SCOPED\n  scoped.effect = effect\n  return scoped\n}\n\n/** @internal */\nexport const scope: Layer.Layer<Scope.Scope> = scopedContext(\n  core.map(\n    fiberRuntime.acquireRelease(\n      fiberRuntime.scopeMake(),\n      (scope, exit) => scope.close(exit)\n    ),\n    (scope) => Context.make(Scope.Scope, scope)\n  )\n)\n\n/** @internal */\nexport const service = <I, S>(\n  tag: Context.Tag<I, S>\n): Layer.Layer<I, never, I> => fromEffect(tag, tag)\n\n/** @internal */\nexport const succeed = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>\n  ) => (\n    resource: Types.NoInfer<S>\n  ) => Layer.Layer<I>,\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    resource: Types.NoInfer<S>\n  ) => Layer.Layer<I>\n>(2, (a, b) => {\n  const tagFirst = Context.isTag(a)\n  const tag = (tagFirst ? a : b) as Context.Tag<unknown, unknown>\n  const resource = tagFirst ? b : a\n  return fromEffectContext(core.succeed(Context.make(tag, resource)))\n})\n\n/** @internal */\nexport const succeedContext = <A>(\n  context: Context.Context<A>\n): Layer.Layer<A> => {\n  return fromEffectContext(core.succeed(context))\n}\n\n/** @internal */\nexport const empty = succeedContext(Context.empty())\n\n/** @internal */\nexport const suspend = <RIn, E, ROut>(\n  evaluate: LazyArg<Layer.Layer<ROut, E, RIn>>\n): Layer.Layer<ROut, E, RIn> => {\n  const suspend = Object.create(proto)\n  suspend._op_layer = OpCodes.OP_SUSPEND\n  suspend.evaluate = evaluate\n  return suspend\n}\n\n/** @internal */\nexport const sync = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>\n  ) => (\n    evaluate: LazyArg<Types.NoInfer<S>>\n  ) => Layer.Layer<I>,\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    evaluate: LazyArg<Types.NoInfer<S>>\n  ) => Layer.Layer<I>\n>(2, (a, b) => {\n  const tagFirst = Context.isTag(a)\n  const tag = (tagFirst ? a : b) as Context.Tag<unknown, unknown>\n  const evaluate = tagFirst ? b : a\n  return fromEffectContext(core.sync(() => Context.make(tag, evaluate())))\n})\n\n/** @internal */\nexport const syncContext = <A>(evaluate: LazyArg<Context.Context<A>>): Layer.Layer<A> => {\n  return fromEffectContext(core.sync(evaluate))\n}\n\n/** @internal */\nexport const tap = dual<\n  <ROut, XR extends ROut, RIn2, E2, X>(\n    f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>\n  ) => <RIn, E>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut, E | E2, RIn | RIn2>,\n  <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(\n    self: Layer.Layer<ROut, E, RIn>,\n    f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>\n  ) => Layer.Layer<ROut, E | E2, RIn | RIn2>\n>(2, (self, f) => flatMap(self, (context) => fromEffectContext(core.as(f(context), context))))\n\n/** @internal */\nexport const tapError = dual<\n  <E, XE extends E, RIn2, E2, X>(\n    f: (e: XE) => Effect.Effect<X, E2, RIn2>\n  ) => <RIn, ROut>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut, E | E2, RIn | RIn2>,\n  <RIn, E, XE extends E, ROut, RIn2, E2, X>(\n    self: Layer.Layer<ROut, E, RIn>,\n    f: (e: XE) => Effect.Effect<X, E2, RIn2>\n  ) => Layer.Layer<ROut, E | E2, RIn | RIn2>\n>(2, (self, f) =>\n  catchAll(\n    self,\n    (e) => fromEffectContext(core.flatMap(f(e as any), () => core.fail(e)))\n  ))\n\n/** @internal */\nexport const tapErrorCause = dual<\n  <E, XE extends E, RIn2, E2, X>(\n    f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>\n  ) => <RIn, ROut>(self: Layer.Layer<ROut, E, RIn>) => Layer.Layer<ROut, E | E2, RIn | RIn2>,\n  <RIn, E, XE extends E, ROut, RIn2, E2, X>(\n    self: Layer.Layer<ROut, E, RIn>,\n    f: (cause: Cause.Cause<XE>) => Effect.Effect<X, E2, RIn2>\n  ) => Layer.Layer<ROut, E | E2, RIn | RIn2>\n>(2, (self, f) =>\n  catchAllCause(\n    self,\n    (cause) => fromEffectContext(core.flatMap(f(cause as any), () => core.failCause(cause)))\n  ))\n\n/** @internal */\nexport const toRuntime = <RIn, E, ROut>(\n  self: Layer.Layer<ROut, E, RIn>\n): Effect.Effect<Runtime.Runtime<ROut>, E, RIn | Scope.Scope> =>\n  pipe(\n    fiberRuntime.scopeWith((scope) => buildWithScope(self, scope)),\n    core.flatMap((context) =>\n      pipe(\n        runtime.runtime<ROut>(),\n        core.provideContext(context)\n      )\n    )\n  )\n\n/** @internal */\nexport const toRuntimeWithMemoMap = dual<\n  (\n    memoMap: Layer.MemoMap\n  ) => <RIn, E, ROut>(self: Layer.Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, RIn | Scope.Scope>,\n  <RIn, E, ROut>(\n    self: Layer.Layer<ROut, E, RIn>,\n    memoMap: Layer.MemoMap\n  ) => Effect.Effect<Runtime.Runtime<ROut>, E, RIn | Scope.Scope>\n>(2, (self, memoMap) =>\n  core.flatMap(\n    fiberRuntime.scopeWith((scope) => buildWithMemoMap(self, memoMap, scope)),\n    (context) =>\n      pipe(\n        runtime.runtime<any>(),\n        core.provideContext(context)\n      )\n  ))\n\n/** @internal */\nexport const provide = dual<\n  {\n    <RIn, E, ROut>(\n      that: Layer.Layer<ROut, E, RIn>\n    ): <RIn2, E2, ROut2>(\n      self: Layer.Layer<ROut2, E2, RIn2>\n    ) => Layer.Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>\n    <const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(\n      that: Layers\n    ): <A, E, R>(\n      self: Layer.Layer<A, E, R>\n    ) => Layer.Layer<\n      A,\n      E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n      | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n      | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>\n    >\n  },\n  {\n    <RIn2, E2, ROut2, RIn, E, ROut>(\n      self: Layer.Layer<ROut2, E2, RIn2>,\n      that: Layer.Layer<ROut, E, RIn>\n    ): Layer.Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>\n    <A, E, R, const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(\n      self: Layer.Layer<A, E, R>,\n      that: Layers\n    ): Layer.Layer<\n      A,\n      E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n      | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n      | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>\n    >\n  }\n>(2, (\n  self: Layer.Layer.Any,\n  that: Layer.Layer.Any | ReadonlyArray<Layer.Layer.Any>\n) =>\n  suspend(() => {\n    const provideTo = Object.create(proto)\n    provideTo._op_layer = OpCodes.OP_PROVIDE\n    provideTo.first = Object.create(proto, {\n      _op_layer: { value: OpCodes.OP_PROVIDE_MERGE, enumerable: true },\n      first: { value: context(), enumerable: true },\n      second: { value: Array.isArray(that) ? mergeAll(...that as any) : that },\n      zipK: { value: (a: Context.Context<any>, b: Context.Context<any>) => pipe(a, Context.merge(b)) }\n    })\n    provideTo.second = self\n    return provideTo\n  }))\n\n/** @internal */\nexport const provideMerge = dual<\n  <RIn, E, ROut>(\n    self: Layer.Layer<ROut, E, RIn>\n  ) => <RIn2, E2, ROut2>(\n    that: Layer.Layer<ROut2, E2, RIn2>\n  ) => Layer.Layer<ROut | ROut2, E2 | E, RIn | Exclude<RIn2, ROut>>,\n  <RIn2, E2, ROut2, RIn, E, ROut>(\n    that: Layer.Layer<ROut2, E2, RIn2>,\n    self: Layer.Layer<ROut, E, RIn>\n  ) => Layer.Layer<ROut | ROut2, E2 | E, RIn | Exclude<RIn2, ROut>>\n>(2, <RIn2, E2, ROut2, RIn, E, ROut>(that: Layer.Layer<ROut2, E2, RIn2>, self: Layer.Layer<ROut, E, RIn>) => {\n  const zipWith = Object.create(proto)\n  zipWith._op_layer = OpCodes.OP_PROVIDE_MERGE\n  zipWith.first = self\n  zipWith.second = provide(that, self)\n  zipWith.zipK = (a: Context.Context<ROut>, b: Context.Context<ROut2>): Context.Context<ROut | ROut2> => {\n    return pipe(a, Context.merge(b))\n  }\n  return zipWith\n})\n\n/** @internal */\nexport const zipWith = dual<\n  <B, E2, R2, A, C>(\n    that: Layer.Layer<B, E2, R2>,\n    f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>\n  ) => <E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<C, E | E2, R | R2>,\n  <A, E, R, B, E2, R2, C>(\n    self: Layer.Layer<A, E, R>,\n    that: Layer.Layer<B, E2, R2>,\n    f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>\n  ) => Layer.Layer<C, E | E2, R | R2>\n>(3, (self, that, f) =>\n  suspend(() => {\n    const zipWith = Object.create(proto)\n    zipWith._op_layer = OpCodes.OP_ZIP_WITH\n    zipWith.first = self\n    zipWith.second = that\n    zipWith.zipK = f\n    return zipWith\n  }))\n\n/** @internal */\nexport const unwrapEffect = <A, E1, R1, E, R>(\n  self: Effect.Effect<Layer.Layer<A, E1, R1>, E, R>\n): Layer.Layer<A, E | E1, R | R1> => {\n  const tag = Context.GenericTag<Layer.Layer<A, E1, R1>>(\"effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>\")\n  return flatMap(fromEffect(tag, self), (context) => Context.get(context, tag))\n}\n\n/** @internal */\nexport const unwrapScoped = <A, E1, R1, E, R>(\n  self: Effect.Effect<Layer.Layer<A, E1, R1>, E, R>\n): Layer.Layer<A, E | E1, R1 | Exclude<R, Scope.Scope>> => {\n  const tag = Context.GenericTag<Layer.Layer<A, E1, R1>>(\"effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>\")\n  return flatMap(scoped(tag, self), (context) => Context.get(context, tag))\n}\n\n// -----------------------------------------------------------------------------\n// logging\n// -----------------------------------------------------------------------------\n\nexport const annotateLogs = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n  },\n  {\n    <A, E, R>(self: Layer.Layer<A, E, R>, key: string, value: unknown): Layer.Layer<A, E, R>\n    <A, E, R>(self: Layer.Layer<A, E, R>, values: Record<string, unknown>): Layer.Layer<A, E, R>\n  }\n>(\n  (args) => isLayer(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return fiberRefLocallyWith(\n      args[0] as Layer.Layer<A, E, R>,\n      core.currentLogAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n\nexport const annotateSpans = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n  },\n  {\n    <A, E, R>(self: Layer.Layer<A, E, R>, key: string, value: unknown): Layer.Layer<A, E, R>\n    <A, E, R>(self: Layer.Layer<A, E, R>, values: Record<string, unknown>): Layer.Layer<A, E, R>\n  }\n>(\n  (args) => isLayer(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return fiberRefLocallyWith(\n      args[0] as Layer.Layer<A, E, R>,\n      core.currentTracerSpanAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions & {\n      readonly onEnd?:\n        | ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>)\n        | undefined\n    }\n  ): <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, Exclude<R, Tracer.ParentSpan>>\n  <A, E, R>(\n    self: Layer.Layer<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions & {\n      readonly onEnd?:\n        | ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>)\n        | undefined\n    }\n  ): Layer.Layer<A, E, Exclude<R, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = tracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]) as Tracer.SpanOptions & {\n    readonly onEnd?:\n      | ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>)\n      | undefined\n  }\n  if (dataFirst) {\n    const self = arguments[0]\n    return unwrapScoped(\n      core.map(\n        options?.onEnd\n          ? core.tap(\n            fiberRuntime.makeSpanScoped(name, options),\n            (span) => fiberRuntime.addFinalizer((exit) => options.onEnd!(span, exit))\n          )\n          : fiberRuntime.makeSpanScoped(name, options),\n        (span) => withParentSpan(self, span)\n      )\n    )\n  }\n  return (self: Layer.Layer<any, any, any>) =>\n    unwrapScoped(\n      core.map(\n        options?.onEnd\n          ? core.tap(\n            fiberRuntime.makeSpanScoped(name, options),\n            (span) => fiberRuntime.addFinalizer((exit) => options.onEnd!(span, exit))\n          )\n          : fiberRuntime.makeSpanScoped(name, options),\n        (span) => withParentSpan(self, span)\n      )\n    )\n} as any\n\n/** @internal */\nexport const withParentSpan = dual<\n  (\n    span: Tracer.AnySpan\n  ) => <A, E, R>(self: Layer.Layer<A, E, R>) => Layer.Layer<A, E, Exclude<R, Tracer.ParentSpan>>,\n  <A, E, R>(self: Layer.Layer<A, E, R>, span: Tracer.AnySpan) => Layer.Layer<A, E, Exclude<R, Tracer.ParentSpan>>\n>(2, (self, span) => provide(self, succeedContext(Context.make(tracer.spanTag, span))))\n\n// circular with Effect\n\nconst provideSomeLayer = dual<\n  <A2, E2, R2>(\n    layer: Layer.Layer<A2, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R2 | Exclude<R, A2>>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    layer: Layer.Layer<A2, E2, R2>\n  ) => Effect.Effect<A, E | E2, R2 | Exclude<R, A2>>\n>(2, (self, layer) =>\n  fiberRuntime.scopedWith((scope) =>\n    core.flatMap(\n      buildWithScope(layer, scope),\n      (context) => core.provideSomeContext(self, context)\n    )\n  ))\n\nconst provideSomeRuntime = dual<\n  <R>(context: Runtime.Runtime<R>) => <A, E, R1>(self: Effect.Effect<A, E, R1>) => Effect.Effect<A, E, Exclude<R1, R>>,\n  <A, E, R1, R>(self: Effect.Effect<A, E, R1>, context: Runtime.Runtime<R>) => Effect.Effect<A, E, Exclude<R1, R>>\n>(2, (self, rt) => {\n  const patchRefs = FiberRefsPatch.diff(runtime.defaultRuntime.fiberRefs, rt.fiberRefs)\n  const patchFlags = runtimeFlags.diff(runtime.defaultRuntime.runtimeFlags, rt.runtimeFlags)\n  return core.uninterruptibleMask((restore) =>\n    core.withFiberRuntime((fiber) => {\n      const oldContext = fiber.getFiberRef(core.currentContext)\n      const oldRefs = fiber.getFiberRefs()\n      const newRefs = FiberRefsPatch.patch(fiber.id(), oldRefs)(patchRefs)\n      const oldFlags = fiber.currentRuntimeFlags\n      const newFlags = runtimeFlags.patch(patchFlags)(oldFlags)\n      const rollbackRefs = FiberRefsPatch.diff(newRefs, oldRefs)\n      const rollbackFlags = runtimeFlags.diff(newFlags, oldFlags)\n      fiber.setFiberRefs(newRefs)\n      fiber.currentRuntimeFlags = newFlags\n      return fiberRuntime.ensuring(\n        core.provideSomeContext(restore(self), Context.merge(oldContext, rt.context)),\n        core.withFiberRuntime((fiber) => {\n          fiber.setFiberRefs(FiberRefsPatch.patch(fiber.id(), fiber.getFiberRefs())(rollbackRefs))\n          fiber.currentRuntimeFlags = runtimeFlags.patch(rollbackFlags)(fiber.currentRuntimeFlags)\n          return core.void\n        })\n      )\n    })\n  )\n})\n\n/** @internal */\nexport const effect_provide = dual<\n  {\n    <const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(\n      layers: Layers\n    ): <A, E, R>(\n      self: Effect.Effect<A, E, R>\n    ) => Effect.Effect<\n      A,\n      E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n      | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n      | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>\n    >\n    <ROut, E2, RIn>(\n      layer: Layer.Layer<ROut, E2, RIn>\n    ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, RIn | Exclude<R, ROut>>\n    <R2>(\n      context: Context.Context<R2>\n    ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, R2>>\n    <R2>(\n      runtime: Runtime.Runtime<R2>\n    ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, R2>>\n    <E2, R2>(\n      managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>\n    ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, Exclude<R, R2>>\n  },\n  {\n    <A, E, R, const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(\n      self: Effect.Effect<A, E, R>,\n      layers: Layers\n    ): Effect.Effect<\n      A,\n      E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n      | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n      | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>\n    >\n    <A, E, R, ROut, E2, RIn>(\n      self: Effect.Effect<A, E, R>,\n      layer: Layer.Layer<ROut, E2, RIn>\n    ): Effect.Effect<A, E | E2, RIn | Exclude<R, ROut>>\n    <A, E, R, R2>(\n      self: Effect.Effect<A, E, R>,\n      context: Context.Context<R2>\n    ): Effect.Effect<A, E, Exclude<R, R2>>\n    <A, E, R, R2>(\n      self: Effect.Effect<A, E, R>,\n      runtime: Runtime.Runtime<R2>\n    ): Effect.Effect<A, E, Exclude<R, R2>>\n    <A, E, E2, R, R2>(\n      self: Effect.Effect<A, E, R>,\n      managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>\n    ): Effect.Effect<A, E | E2, Exclude<R, R2>>\n  }\n>(\n  2,\n  <A, E, R, ROut>(\n    self: Effect.Effect<A, E, R>,\n    source:\n      | Layer.Layer<ROut, any, any>\n      | Context.Context<ROut>\n      | Runtime.Runtime<ROut>\n      | ManagedRuntime.ManagedRuntime<ROut, any>\n      | Array<Layer.Layer.Any>\n  ): Effect.Effect<any, any, Exclude<R, ROut>> => {\n    if (Array.isArray(source)) {\n      // @ts-expect-error\n      return provideSomeLayer(self, mergeAll(...source))\n    } else if (isLayer(source)) {\n      return provideSomeLayer(self, source as Layer.Layer<ROut, any, any>)\n    } else if (Context.isContext(source)) {\n      return core.provideSomeContext(self, source)\n    } else if (circularManagedRuntime.TypeId in source) {\n      return core.flatMap(\n        (source as ManagedRuntime.ManagedRuntime<ROut, any>).runtimeEffect,\n        (rt) => provideSomeRuntime(self, rt)\n      )\n    } else {\n      return provideSomeRuntime(self, source as Runtime.Runtime<ROut>)\n    }\n  }\n)\n","import type * as Cause from \"../../Cause.js\"\nimport type * as Deferred from \"../../Deferred.js\"\nimport * as Duration from \"../../Duration.js\"\nimport type * as Effect from \"../../Effect.js\"\nimport * as Effectable from \"../../Effectable.js\"\nimport * as Equal from \"../../Equal.js\"\nimport type { Equivalence } from \"../../Equivalence.js\"\nimport * as Exit from \"../../Exit.js\"\nimport type * as Fiber from \"../../Fiber.js\"\nimport * as FiberId from \"../../FiberId.js\"\nimport type * as FiberRefsPatch from \"../../FiberRefsPatch.js\"\nimport type { LazyArg } from \"../../Function.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Hash from \"../../Hash.js\"\nimport * as MutableHashMap from \"../../MutableHashMap.js\"\nimport * as Option from \"../../Option.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport * as Predicate from \"../../Predicate.js\"\nimport * as Readable from \"../../Readable.js\"\nimport type * as Ref from \"../../Ref.js\"\nimport { currentScheduler } from \"../../Scheduler.js\"\nimport type * as Scope from \"../../Scope.js\"\nimport type * as Supervisor from \"../../Supervisor.js\"\nimport type * as Synchronized from \"../../SynchronizedRef.js\"\nimport type * as Types from \"../../Types.js\"\nimport * as internalCause from \"../cause.js\"\nimport * as effect from \"../core-effect.js\"\nimport * as core from \"../core.js\"\nimport * as internalFiber from \"../fiber.js\"\nimport * as fiberRuntime from \"../fiberRuntime.js\"\nimport { globalScope } from \"../fiberScope.js\"\nimport * as internalRef from \"../ref.js\"\nimport * as supervisor from \"../supervisor.js\"\n\n/** @internal */\nclass Semaphore {\n  public waiters = new Set<() => void>()\n  public taken = 0\n\n  constructor(public permits: number) {}\n\n  get free() {\n    return this.permits - this.taken\n  }\n\n  readonly take = (n: number): Effect.Effect<number> =>\n    core.asyncInterrupt<number>((resume) => {\n      if (this.free < n) {\n        const observer = () => {\n          if (this.free < n) {\n            return\n          }\n          this.waiters.delete(observer)\n          this.taken += n\n          resume(core.succeed(n))\n        }\n        this.waiters.add(observer)\n        return core.sync(() => {\n          this.waiters.delete(observer)\n        })\n      }\n      this.taken += n\n      return resume(core.succeed(n))\n    })\n\n  updateTakenUnsafe(fiber: Fiber.RuntimeFiber<any, any>, f: (n: number) => number): Effect.Effect<number> {\n    this.taken = f(this.taken)\n    if (this.waiters.size > 0) {\n      fiber.getFiberRef(currentScheduler).scheduleTask(() => {\n        const iter = this.waiters.values()\n        let item = iter.next()\n        while (item.done === false && this.free > 0) {\n          item.value()\n          item = iter.next()\n        }\n      }, fiber.getFiberRef(core.currentSchedulingPriority))\n    }\n    return core.succeed(this.free)\n  }\n\n  updateTaken(f: (n: number) => number): Effect.Effect<number> {\n    return core.withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f))\n  }\n\n  readonly resize = (permits: number) =>\n    core.asVoid(\n      core.withFiberRuntime((fiber) => {\n        this.permits = permits\n        if (this.free < 0) {\n          return core.void\n        }\n        return this.updateTakenUnsafe(fiber, (taken) => taken)\n      })\n    )\n\n  readonly release = (n: number): Effect.Effect<number> => this.updateTaken((taken) => taken - n)\n\n  readonly releaseAll: Effect.Effect<number> = this.updateTaken((_) => 0)\n\n  readonly withPermits = (n: number) => <A, E, R>(self: Effect.Effect<A, E, R>) =>\n    core.uninterruptibleMask((restore) =>\n      core.flatMap(\n        restore(this.take(n)),\n        (permits) => fiberRuntime.ensuring(restore(self), this.release(permits))\n      )\n    )\n\n  readonly withPermitsIfAvailable = (n: number) => <A, E, R>(self: Effect.Effect<A, E, R>) =>\n    core.uninterruptibleMask((restore) =>\n      core.suspend(() => {\n        if (this.free < n) {\n          return effect.succeedNone\n        }\n        this.taken += n\n        return fiberRuntime.ensuring(restore(effect.asSome(self)), this.release(n))\n      })\n    )\n}\n\n/** @internal */\nexport const unsafeMakeSemaphore = (permits: number): Effect.Semaphore => new Semaphore(permits)\n\n/** @internal */\nexport const makeSemaphore = (permits: number) => core.sync(() => unsafeMakeSemaphore(permits))\n\nclass Latch extends Effectable.Class<void> implements Effect.Latch {\n  waiters: Array<(_: Effect.Effect<void>) => void> = []\n  scheduled = false\n  constructor(private isOpen: boolean) {\n    super()\n  }\n\n  commit() {\n    return this.await\n  }\n\n  private unsafeSchedule(fiber: Fiber.RuntimeFiber<void>) {\n    if (this.scheduled || this.waiters.length === 0) {\n      return core.void\n    }\n    this.scheduled = true\n    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(core.currentSchedulingPriority))\n    return core.void\n  }\n  private flushWaiters = () => {\n    this.scheduled = false\n    const waiters = this.waiters\n    this.waiters = []\n    for (let i = 0; i < waiters.length; i++) {\n      waiters[i](core.exitVoid)\n    }\n  }\n\n  open = core.withFiberRuntime<void>((fiber) => {\n    if (this.isOpen) {\n      return core.void\n    }\n    this.isOpen = true\n    return this.unsafeSchedule(fiber)\n  })\n  unsafeOpen() {\n    if (this.isOpen) return\n    this.isOpen = true\n    this.flushWaiters()\n  }\n  release = core.withFiberRuntime<void>((fiber) => {\n    if (this.isOpen) {\n      return core.void\n    }\n    return this.unsafeSchedule(fiber)\n  })\n  await = core.asyncInterrupt<void>((resume) => {\n    if (this.isOpen) {\n      return resume(core.void)\n    }\n    this.waiters.push(resume)\n    return core.sync(() => {\n      const index = this.waiters.indexOf(resume)\n      if (index !== -1) {\n        this.waiters.splice(index, 1)\n      }\n    })\n  })\n  unsafeClose() {\n    this.isOpen = false\n  }\n  close = core.sync(() => {\n    this.isOpen = false\n  })\n  whenOpen = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> => {\n    return core.zipRight(this.await, self)\n  }\n}\n\n/** @internal */\nexport const unsafeMakeLatch = (open?: boolean | undefined): Effect.Latch => new Latch(open ?? false)\n\n/** @internal */\nexport const makeLatch = (open?: boolean | undefined) => core.sync(() => unsafeMakeLatch(open))\n\n/** @internal */\nexport const awaitAllChildren = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  ensuringChildren(self, fiberRuntime.fiberAwaitAll)\n\n/** @internal */\nexport const cached: {\n  (\n    timeToLive: Duration.DurationInput\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Effect.Effect<A, E>, never, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    timeToLive: Duration.DurationInput\n  ): Effect.Effect<Effect.Effect<A, E>, never, R>\n} = dual(\n  2,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    timeToLive: Duration.DurationInput\n  ): Effect.Effect<Effect.Effect<A, E>, never, R> =>\n    core.map(cachedInvalidateWithTTL(self, timeToLive), (tuple) => tuple[0])\n)\n\n/** @internal */\nexport const cachedInvalidateWithTTL: {\n  (timeToLive: Duration.DurationInput): <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<[Effect.Effect<A, E>, Effect.Effect<void>], never, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    timeToLive: Duration.DurationInput\n  ): Effect.Effect<[Effect.Effect<A, E>, Effect.Effect<void>], never, R>\n} = dual(\n  2,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    timeToLive: Duration.DurationInput\n  ): Effect.Effect<[Effect.Effect<A, E>, Effect.Effect<void>], never, R> => {\n    const duration = Duration.decode(timeToLive)\n    return core.flatMap(\n      core.context<R>(),\n      (env) =>\n        core.map(\n          makeSynchronized<Option.Option<readonly [number, Deferred.Deferred<A, E>]>>(Option.none()),\n          (cache) =>\n            [\n              core.provideContext(getCachedValue(self, duration, cache), env),\n              invalidateCache(cache)\n            ] as [Effect.Effect<A, E>, Effect.Effect<void>]\n        )\n    )\n  }\n)\n\n/** @internal */\nconst computeCachedValue = <A, E, R>(\n  self: Effect.Effect<A, E, R>,\n  timeToLive: Duration.DurationInput,\n  start: number\n): Effect.Effect<Option.Option<[number, Deferred.Deferred<A, E>]>, never, R> => {\n  const timeToLiveMillis = Duration.toMillis(Duration.decode(timeToLive))\n  return pipe(\n    core.deferredMake<A, E>(),\n    core.tap((deferred) => core.intoDeferred(self, deferred)),\n    core.map((deferred) => Option.some([start + timeToLiveMillis, deferred]))\n  )\n}\n\n/** @internal */\nconst getCachedValue = <A, E, R>(\n  self: Effect.Effect<A, E, R>,\n  timeToLive: Duration.DurationInput,\n  cache: Synchronized.SynchronizedRef<Option.Option<readonly [number, Deferred.Deferred<A, E>]>>\n): Effect.Effect<A, E, R> =>\n  core.uninterruptibleMask((restore) =>\n    pipe(\n      effect.clockWith((clock) => clock.currentTimeMillis),\n      core.flatMap((time) =>\n        updateSomeAndGetEffectSynchronized(cache, (option) => {\n          switch (option._tag) {\n            case \"None\": {\n              return Option.some(computeCachedValue(self, timeToLive, time))\n            }\n            case \"Some\": {\n              const [end] = option.value\n              return end - time <= 0\n                ? Option.some(computeCachedValue(self, timeToLive, time))\n                : Option.none()\n            }\n          }\n        })\n      ),\n      core.flatMap((option) =>\n        Option.isNone(option) ?\n          core.dieMessage(\n            \"BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues\"\n          ) :\n          restore(core.deferredAwait(option.value[1]))\n      )\n    )\n  )\n\n/** @internal */\nconst invalidateCache = <A, E>(\n  cache: Synchronized.SynchronizedRef<Option.Option<readonly [number, Deferred.Deferred<A, E>]>>\n): Effect.Effect<void> => internalRef.set(cache, Option.none())\n\n/** @internal */\nexport const ensuringChild = dual<\n  <X, R2>(\n    f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect.Effect<X, never, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A, E, R | R2>,\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect.Effect<X, never, R2>\n  ) => Effect.Effect<A, E, R | R2>\n>(2, (self, f) => ensuringChildren(self, (children) => f(fiberRuntime.fiberAll(children))))\n\n/** @internal */\nexport const ensuringChildren = dual<\n  <X, R2>(\n    children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect.Effect<X, never, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | R2>,\n  <A, E, R, X, R2>(\n    self: Effect.Effect<A, E, R>,\n    children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect.Effect<X, never, R2>\n  ) => Effect.Effect<A, E, R | R2>\n>(2, (self, children) =>\n  core.flatMap(supervisor.track, (supervisor) =>\n    pipe(\n      supervised(self, supervisor),\n      fiberRuntime.ensuring(core.flatMap(supervisor.value, children))\n    )))\n\n/** @internal */\nexport const forkAll: {\n  (\n    options?: {\n      readonly discard?: false | undefined\n    }\n  ): <Eff extends Effect.Effect<any, any, any>>(\n    effects: Iterable<Eff>\n  ) => Effect.Effect<\n    Fiber.Fiber<Array<Effect.Effect.Success<Eff>>, Effect.Effect.Error<Eff>>,\n    never,\n    Effect.Effect.Context<Eff>\n  >\n  (options: {\n    readonly discard: true\n  }): <Eff extends Effect.Effect<any, any, any>>(\n    effects: Iterable<Eff>\n  ) => Effect.Effect<void, never, Effect.Effect.Context<Eff>>\n  <Eff extends Effect.Effect<any, any, any>>(\n    effects: Iterable<Eff>,\n    options?: {\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<\n    Fiber.Fiber<Array<Effect.Effect.Success<Eff>>, Effect.Effect.Error<Eff>>,\n    never,\n    Effect.Effect.Context<Eff>\n  >\n  <Eff extends Effect.Effect<any, any, any>>(effects: Iterable<Eff>, options: {\n    readonly discard: true\n  }): Effect.Effect<void, never, Effect.Effect.Context<Eff>>\n} = dual((args) => Predicate.isIterable(args[0]), <A, E, R>(effects: Iterable<Effect.Effect<A, E, R>>, options: {\n  readonly discard: true\n}): Effect.Effect<void, never, R> =>\n  options?.discard ?\n    core.forEachSequentialDiscard(effects, fiberRuntime.fork) :\n    core.map(core.forEachSequential(effects, fiberRuntime.fork), fiberRuntime.fiberAll))\n\n/** @internal */\nexport const forkIn = dual<\n  (scope: Scope.Scope) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, scope: Scope.Scope) => Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R>\n>(\n  2,\n  (self, scope) =>\n    core.withFiberRuntime((parent, parentStatus) => {\n      const scopeImpl = scope as fiberRuntime.ScopeImpl\n      const fiber = fiberRuntime.unsafeFork(self, parent, parentStatus.runtimeFlags, globalScope)\n      if (scopeImpl.state._tag === \"Open\") {\n        const finalizer = () =>\n          core.fiberIdWith((fiberId) =>\n            Equal.equals(fiberId, fiber.id()) ?\n              core.void :\n              core.asVoid(core.interruptFiber(fiber))\n          )\n        const key = {}\n        scopeImpl.state.finalizers.set(key, finalizer)\n        fiber.addObserver(() => {\n          if (scopeImpl.state._tag === \"Closed\") return\n          scopeImpl.state.finalizers.delete(key)\n        })\n      } else {\n        fiber.unsafeInterruptAsFork(parent.id())\n      }\n      return core.succeed(fiber)\n    })\n)\n\n/** @internal */\nexport const forkScoped = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Fiber.RuntimeFiber<A, E>, never, R | Scope.Scope> =>\n  fiberRuntime.scopeWith((scope) => forkIn(self, scope))\n\n/** @internal */\nexport const fromFiber = <A, E>(fiber: Fiber.Fiber<A, E>): Effect.Effect<A, E> => internalFiber.join(fiber)\n\n/** @internal */\nexport const fromFiberEffect = <A, E, R>(fiber: Effect.Effect<Fiber.Fiber<A, E>, E, R>): Effect.Effect<A, E, R> =>\n  core.suspend(() => core.flatMap(fiber, internalFiber.join))\n\nconst memoKeySymbol = Symbol.for(\"effect/Effect/memoizeFunction.key\")\n\nclass Key<in out A> implements Equal.Equal {\n  [memoKeySymbol] = memoKeySymbol\n  constructor(readonly a: A, readonly eq?: Equivalence<A>) {}\n  [Equal.symbol](that: Equal.Equal) {\n    if (Predicate.hasProperty(that, memoKeySymbol)) {\n      if (this.eq) {\n        return this.eq(this.a, (that as unknown as Key<A>).a)\n      } else {\n        return Equal.equals(this.a, (that as unknown as Key<A>).a)\n      }\n    }\n    return false\n  }\n  [Hash.symbol]() {\n    return this.eq ? 0 : Hash.cached(this, Hash.hash(this.a))\n  }\n}\n\n/** @internal */\nexport const cachedFunction = <A, B, E, R>(\n  f: (a: A) => Effect.Effect<B, E, R>,\n  eq?: Equivalence<A>\n): Effect.Effect<(a: A) => Effect.Effect<B, E, R>> => {\n  return pipe(\n    core.sync(() => MutableHashMap.empty<Key<A>, Deferred.Deferred<readonly [FiberRefsPatch.FiberRefsPatch, B], E>>()),\n    core.flatMap(makeSynchronized),\n    core.map((ref) => (a: A) =>\n      pipe(\n        ref.modifyEffect((map) => {\n          const result = pipe(map, MutableHashMap.get(new Key(a, eq)))\n          if (Option.isNone(result)) {\n            return pipe(\n              core.deferredMake<readonly [FiberRefsPatch.FiberRefsPatch, B], E>(),\n              core.tap((deferred) =>\n                pipe(\n                  effect.diffFiberRefs(f(a)),\n                  core.intoDeferred(deferred),\n                  fiberRuntime.fork\n                )\n              ),\n              core.map((deferred) => [deferred, pipe(map, MutableHashMap.set(new Key(a, eq), deferred))] as const)\n            )\n          }\n          return core.succeed([result.value, map] as const)\n        }),\n        core.flatMap(core.deferredAwait),\n        core.flatMap(([patch, b]) => pipe(effect.patchFiberRefs(patch), core.as(b)))\n      )\n    )\n  )\n}\n\n/** @internal */\nexport const raceFirst = dual<\n  <A2, E2, R2>(\n    that: Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A2 | A, E2 | E, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    that: Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2 | A, E2 | E, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  that: Effect.Effect<A2, E2, R2>\n) =>\n  pipe(\n    core.exit(self),\n    fiberRuntime.race(core.exit(that)),\n    (effect: Effect.Effect<Exit.Exit<A | A2, E | E2>, never, R | R2>) => core.flatten(effect)\n  ))\n\n/** @internal */\nexport const supervised = dual<\n  <X>(supervisor: Supervisor.Supervisor<X>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R, X>(self: Effect.Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>) => Effect.Effect<A, E, R>\n>(2, (self, supervisor) => {\n  const supervise = core.fiberRefLocallyWith(fiberRuntime.currentSupervisor, (s) => s.zip(supervisor))\n  return supervise(self)\n})\n\n/** @internal */\nexport const timeout = dual<\n  (\n    duration: Duration.DurationInput\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | Cause.TimeoutException, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    duration: Duration.DurationInput\n  ) => Effect.Effect<A, E | Cause.TimeoutException, R>\n>(2, (self, duration) =>\n  timeoutFail(self, {\n    onTimeout: () => core.timeoutExceptionFromDuration(duration),\n    duration\n  }))\n\n/** @internal */\nexport const timeoutFail = dual<\n  <E1>(\n    options: {\n      readonly onTimeout: LazyArg<E1>\n      readonly duration: Duration.DurationInput\n    }\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R>,\n  <A, E, R, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onTimeout: LazyArg<E1>\n      readonly duration: Duration.DurationInput\n    }\n  ) => Effect.Effect<A, E | E1, R>\n>(2, (self, { duration, onTimeout }) =>\n  core.flatten(timeoutTo(self, {\n    onTimeout: () => core.failSync(onTimeout),\n    onSuccess: core.succeed,\n    duration\n  })))\n\n/** @internal */\nexport const timeoutFailCause = dual<\n  <E1>(\n    options: {\n      readonly onTimeout: LazyArg<Cause.Cause<E1>>\n      readonly duration: Duration.DurationInput\n    }\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R>,\n  <A, E, R, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onTimeout: LazyArg<Cause.Cause<E1>>\n      readonly duration: Duration.DurationInput\n    }\n  ) => Effect.Effect<A, E | E1, R>\n>(2, (self, { duration, onTimeout }) =>\n  core.flatten(timeoutTo(self, {\n    onTimeout: () => core.failCauseSync(onTimeout),\n    onSuccess: core.succeed,\n    duration\n  })))\n\n/** @internal */\nexport const timeoutOption = dual<\n  (\n    duration: Duration.DurationInput\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    duration: Duration.DurationInput\n  ) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, duration) =>\n  timeoutTo(self, {\n    duration,\n    onSuccess: Option.some,\n    onTimeout: Option.none\n  }))\n\n/** @internal */\nexport const timeoutTo = dual<\n  <A, B, B1>(\n    options: {\n      readonly onTimeout: LazyArg<B1>\n      readonly onSuccess: (a: A) => B\n      readonly duration: Duration.DurationInput\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B | B1, E, R>,\n  <A, E, R, B1, B>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onTimeout: LazyArg<B1>\n      readonly onSuccess: (a: A) => B\n      readonly duration: Duration.DurationInput\n    }\n  ) => Effect.Effect<B | B1, E, R>\n>(\n  2,\n  (self, { duration, onSuccess, onTimeout }) =>\n    core.fiberIdWith((parentFiberId) =>\n      core.uninterruptibleMask((restore) =>\n        fiberRuntime.raceFibersWith(\n          restore(self),\n          core.interruptible(effect.sleep(duration)),\n          {\n            onSelfWin: (winner, loser) =>\n              core.flatMap(\n                winner.await,\n                (exit) => {\n                  if (exit._tag === \"Success\") {\n                    return core.flatMap(\n                      winner.inheritAll,\n                      () =>\n                        core.as(\n                          core.interruptAsFiber(loser, parentFiberId),\n                          onSuccess(exit.value)\n                        )\n                    )\n                  } else {\n                    return core.flatMap(\n                      core.interruptAsFiber(loser, parentFiberId),\n                      () => core.exitFailCause(exit.cause)\n                    )\n                  }\n                }\n              ),\n            onOtherWin: (winner, loser) =>\n              core.flatMap(\n                winner.await,\n                (exit) => {\n                  if (exit._tag === \"Success\") {\n                    return core.flatMap(\n                      winner.inheritAll,\n                      () =>\n                        core.as(\n                          core.interruptAsFiber(loser, parentFiberId),\n                          onTimeout()\n                        )\n                    )\n                  } else {\n                    return core.flatMap(\n                      core.interruptAsFiber(loser, parentFiberId),\n                      () => core.exitFailCause(exit.cause)\n                    )\n                  }\n                }\n              ),\n            otherScope: globalScope\n          }\n        )\n      )\n    )\n)\n\n// circular with Synchronized\n\n/** @internal */\nconst SynchronizedSymbolKey = \"effect/Ref/SynchronizedRef\"\n\n/** @internal */\nexport const SynchronizedTypeId: Synchronized.SynchronizedRefTypeId = Symbol.for(\n  SynchronizedSymbolKey\n) as Synchronized.SynchronizedRefTypeId\n\n/** @internal */\nexport const synchronizedVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nclass SynchronizedImpl<in out A> extends Effectable.Class<A> implements Synchronized.SynchronizedRef<A> {\n  readonly [SynchronizedTypeId] = synchronizedVariance\n  readonly [internalRef.RefTypeId] = internalRef.refVariance\n  readonly [Readable.TypeId]: Readable.TypeId = Readable.TypeId\n  constructor(\n    readonly ref: Ref.Ref<A>,\n    readonly withLock: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  ) {\n    super()\n    this.get = internalRef.get(this.ref)\n  }\n  readonly get: Effect.Effect<A>\n  commit() {\n    return this.get\n  }\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B> {\n    return this.modifyEffect((a) => core.succeed(f(a)))\n  }\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R> {\n    return this.withLock(\n      pipe(\n        core.flatMap(internalRef.get(this.ref), f),\n        core.flatMap(([b, a]) => core.as(internalRef.set(this.ref, a), b))\n      )\n    )\n  }\n}\n\n/** @internal */\nexport const makeSynchronized = <A>(value: A): Effect.Effect<Synchronized.SynchronizedRef<A>> =>\n  core.sync(() => unsafeMakeSynchronized(value))\n\n/** @internal */\nexport const unsafeMakeSynchronized = <A>(value: A): Synchronized.SynchronizedRef<A> => {\n  const ref = internalRef.unsafeMake(value)\n  const sem = unsafeMakeSemaphore(1)\n  return new SynchronizedImpl(ref, sem.withPermits(1))\n}\n\n/** @internal */\nexport const updateSomeAndGetEffectSynchronized = dual<\n  <A, R, E>(\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<A, E, R>,\n  <A, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, pf) =>\n  self.modifyEffect((value) => {\n    const result = pf(value)\n    switch (result._tag) {\n      case \"None\": {\n        return core.succeed([value, value] as const)\n      }\n      case \"Some\": {\n        return core.map(result.value, (a) => [a, a] as const)\n      }\n    }\n  }))\n\n// circular with Fiber\n\n/** @internal */\nexport const zipFiber = dual<\n  <A2, E2>(that: Fiber.Fiber<A2, E2>) => <A, E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<[A, A2], E | E2>,\n  <A, E, A2, E2>(self: Fiber.Fiber<A, E>, that: Fiber.Fiber<A2, E2>) => Fiber.Fiber<[A, A2], E | E2>\n>(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]))\n\n/** @internal */\nexport const zipLeftFiber = dual<\n  <A2, E2>(that: Fiber.Fiber<A2, E2>) => <A, E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<A, E | E2>,\n  <A, E, A2, E2>(self: Fiber.Fiber<A, E>, that: Fiber.Fiber<A2, E2>) => Fiber.Fiber<A, E | E2>\n>(2, (self, that) => zipWithFiber(self, that, (a, _) => a))\n\n/** @internal */\nexport const zipRightFiber = dual<\n  <A2, E2>(that: Fiber.Fiber<A2, E2>) => <A, E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<A2, E | E2>,\n  <A, E, A2, E2>(self: Fiber.Fiber<A, E>, that: Fiber.Fiber<A2, E2>) => Fiber.Fiber<A2, E | E2>\n>(2, (self, that) => zipWithFiber(self, that, (_, b) => b))\n\n/** @internal */\nexport const zipWithFiber = dual<\n  <B, E2, A, C>(\n    that: Fiber.Fiber<B, E2>,\n    f: (a: A, b: B) => C\n  ) => <E>(self: Fiber.Fiber<A, E>) => Fiber.Fiber<C, E | E2>,\n  <A, E, B, E2, C>(\n    self: Fiber.Fiber<A, E>,\n    that: Fiber.Fiber<B, E2>,\n    f: (a: A, b: B) => C\n  ) => Fiber.Fiber<C, E | E2>\n>(3, (self, that, f) => ({\n  ...Effectable.CommitPrototype,\n  commit() {\n    return internalFiber.join(this)\n  },\n  [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n  id: () => pipe(self.id(), FiberId.getOrElse(that.id())),\n  await: pipe(\n    self.await,\n    core.flatten,\n    fiberRuntime.zipWithOptions(core.flatten(that.await), f, { concurrent: true }),\n    core.exit\n  ),\n  children: self.children,\n  inheritAll: core.zipRight(\n    that.inheritAll,\n    self.inheritAll\n  ),\n  poll: core.zipWith(\n    self.poll,\n    that.poll,\n    (optionA, optionB) =>\n      pipe(\n        optionA,\n        Option.flatMap((exitA) =>\n          pipe(\n            optionB,\n            Option.map((exitB) =>\n              Exit.zipWith(exitA, exitB, {\n                onSuccess: f,\n                onFailure: internalCause.parallel\n              })\n            )\n          )\n        )\n      )\n  ),\n  interruptAsFork: (id) =>\n    core.zipRight(\n      self.interruptAsFork(id),\n      that.interruptAsFork(id)\n    ),\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}))\n\n/* @internal */\nexport const bindAll: {\n  <\n    A extends object,\n    X extends Record<string, Effect.Effect<any, any, any>>,\n    O extends Types.NoExcessProperties<{\n      readonly concurrency?: Types.Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }, O>\n  >(\n    f: (a: A) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`,\n    options?: undefined | O\n  ): <E1, R1>(\n    self: Effect.Effect<A, E1, R1>\n  ) => [Effect.All.ReturnObject<X, false, Effect.All.ExtractMode<O>>] extends\n    [Effect.Effect<infer Success, infer Error, infer Context>] ? Effect.Effect<\n      {\n        [K in keyof A | keyof Success]: K extends keyof A ? A[K]\n          : K extends keyof Success ? Success[K]\n          : never\n      },\n      | E1\n      | Error,\n      R1 | Context\n    >\n    : never\n\n  <\n    A extends object,\n    X extends Record<string, Effect.Effect<any, any, any>>,\n    O extends Types.NoExcessProperties<{\n      readonly concurrency?: Types.Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }, O>,\n    E1,\n    R1\n  >(\n    self: Effect.Effect<A, E1, R1>,\n    f: (a: A) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`,\n    options?: undefined | {\n      readonly concurrency?: Types.Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): [Effect.All.ReturnObject<X, false, Effect.All.ExtractMode<O>>] extends\n    [Effect.Effect<infer Success, infer Error, infer Context>] ? Effect.Effect<\n      {\n        [K in keyof A | keyof Success]: K extends keyof A ? A[K]\n          : K extends keyof Success ? Success[K]\n          : never\n      },\n      | E1\n      | Error,\n      R1 | Context\n    >\n    : never\n} = dual((args) => core.isEffect(args[0]), <\n  A extends object,\n  X extends Record<string, Effect.Effect<any, any, any>>,\n  O extends Types.NoExcessProperties<{\n    readonly concurrency?: Types.Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }, O>,\n  E1,\n  R1\n>(\n  self: Effect.Effect<A, E1, R1>,\n  f: (a: A) => X,\n  options?: undefined | O\n) =>\n  core.flatMap(\n    self,\n    (a) =>\n      (fiberRuntime.all(f(a), options) as Effect.All.ReturnObject<\n        X,\n        Effect.All.IsDiscard<O>,\n        Effect.All.ExtractMode<O>\n      >)\n        .pipe(\n          core.map((record) => Object.assign({}, a, record))\n        )\n  ))\n","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type { Context } from \"./Context.js\"\nimport type { DefaultServices } from \"./DefaultServices.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type { FiberRef } from \"./FiberRef.js\"\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport type * as FiberStatus from \"./FiberStatus.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport * as core from \"./internal/core.js\"\nimport * as circular from \"./internal/effect/circular.js\"\nimport * as internal from \"./internal/fiber.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as order from \"./Order.js\"\nimport type * as RuntimeFlags from \"./RuntimeFlags.js\"\nimport type { Scheduler } from \"./Scheduler.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type { Supervisor } from \"./Supervisor.js\"\nimport type { AnySpan, Tracer } from \"./Tracer.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FiberTypeId: unique symbol = internal.FiberTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FiberTypeId = typeof FiberTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const RuntimeFiberTypeId: unique symbol = internal.RuntimeFiberTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type RuntimeFiberTypeId = typeof RuntimeFiberTypeId\n\n/**\n * A fiber is a lightweight thread of execution that never consumes more than a\n * whole thread (but may consume much less, depending on contention and\n * asynchronicity). Fibers are spawned by forking effects, which run\n * concurrently with the parent effect.\n *\n * Fibers can be joined, yielding their result to other fibers, or interrupted,\n * which terminates the fiber, safely releasing all resources.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Fiber<out A, out E = never> extends Effect.Effect<A, E>, Fiber.Variance<A, E> {\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.FiberId\n\n  /**\n   * Awaits the fiber, which suspends the awaiting fiber until the result of the\n   * fiber has been determined.\n   */\n  readonly await: Effect.Effect<Exit.Exit<A, E>>\n\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  readonly children: Effect.Effect<Array<Fiber.Runtime<any, any>>>\n\n  /**\n   * Inherits values from all `FiberRef` instances into current fiber. This\n   * will resume immediately.\n   */\n  readonly inheritAll: Effect.Effect<void>\n\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  readonly poll: Effect.Effect<Option.Option<Exit.Exit<A, E>>>\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: FiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: FiberUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface FiberUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Fiber?: () => A[Unify.typeSymbol] extends Fiber<infer A0, infer E0> | infer _ ? Fiber<A0, E0> : never\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface FiberUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * A runtime fiber that is executing an effect. Runtime fibers have an\n * identity and a trace.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface RuntimeFiber<out A, out E = never> extends Fiber<A, E>, Fiber.RuntimeVariance<A, E> {\n  /**\n   * Reads the current number of ops that have occurred since the last yield\n   */\n  get currentOpCount(): number\n\n  /**\n   * Reads the current value of a fiber ref\n   */\n  getFiberRef<X>(fiberRef: FiberRef<X>): X\n\n  /**\n   * The identity of the fiber.\n   */\n  id(): FiberId.Runtime\n\n  /**\n   * The status of the fiber.\n   */\n  readonly status: Effect.Effect<FiberStatus.FiberStatus>\n\n  /**\n   * Returns the current `RuntimeFlags` the fiber is running with.\n   */\n  readonly runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags>\n\n  /**\n   * Adds an observer to the list of observers.\n   */\n  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   */\n  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void\n\n  /**\n   * Retrieves all fiber refs of the fiber.\n   */\n  getFiberRefs(): FiberRefs.FiberRefs\n\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll(): Exit.Exit<A, E> | null\n\n  /**\n   * In the background, interrupts the fiber as if interrupted from the\n   * specified fiber. If the fiber has already exited, the returned effect will\n   * resume immediately. Otherwise, the effect will resume when the fiber exits.\n   */\n  unsafeInterruptAsFork(fiberId: FiberId.FiberId): void\n\n  /**\n   * Gets the current context\n   */\n  get currentContext(): Context<never>\n\n  /**\n   * Gets the current context\n   */\n  get currentDefaultServices(): Context<DefaultServices>\n\n  /**\n   * Gets the current scheduler\n   */\n  get currentScheduler(): Scheduler\n\n  /**\n   * Gets the current tracer\n   */\n  get currentTracer(): Tracer\n\n  /**\n   * Gets the current span\n   */\n  get currentSpan(): AnySpan | undefined\n\n  /**\n   * Gets the current supervisor\n   */\n  get currentSupervisor(): Supervisor<unknown>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: RuntimeFiberUnify<this>\n  readonly [Unify.ignoreSymbol]?: RuntimeFiberUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface RuntimeFiberUnify<A extends { [Unify.typeSymbol]?: any }> extends FiberUnify<A> {\n  RuntimeFiber?: () => A[Unify.typeSymbol] extends RuntimeFiber<infer A0, infer E0> | infer _ ? RuntimeFiber<A0, E0>\n    : never\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface RuntimeFiberUnifyIgnore extends FiberUnifyIgnore {\n  Fiber?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Fiber {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Runtime<A, E = never> = RuntimeFiber<A, E>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out A, out E> {\n    readonly [FiberTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  export interface RuntimeVariance<out A, out E> {\n    readonly [RuntimeFiberTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Dump {\n    /**\n     * The fiber's unique identifier.\n     */\n    readonly id: FiberId.Runtime\n    /**\n     * The status of the fiber.\n     */\n    readonly status: FiberStatus.FiberStatus\n  }\n\n  /**\n   * A record containing information about a `Fiber`.\n   *\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Descriptor {\n    /**\n     * The fiber's unique identifier.\n     */\n    readonly id: FiberId.FiberId\n    /**\n     * The status of the fiber.\n     */\n    readonly status: FiberStatus.FiberStatus\n    /**\n     * The set of fibers attempting to interrupt the fiber or its ancestors.\n     */\n    readonly interruptors: HashSet.HashSet<FiberId.FiberId>\n  }\n}\n\n/**\n * @since 2.0.0\n * @category instances\n */\nexport const Order: order.Order<RuntimeFiber<unknown, unknown>> = internal.Order\n\n/**\n * Returns `true` if the specified value is a `Fiber`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isFiber: (u: unknown) => u is Fiber<unknown, unknown> = internal.isFiber\n\n/**\n * Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E> = internal.isRuntimeFiber\n\n/**\n * The identity of the fiber.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId = internal.id\n\nconst _await: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>> = internal._await\n\nexport {\n  /**\n   * Awaits the fiber, which suspends the awaiting fiber until the result of the\n   * fiber has been determined.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  _await as await\n}\n\n/**\n * Awaits on all fibers to be completed, successfully or not.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const awaitAll: <const T extends Iterable<Fiber<any, any>>>(\n  fibers: T\n) => Effect.Effect<\n  [T] extends [ReadonlyArray<infer U>]\n    ? number extends T[\"length\"] ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never>\n    : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never }\n    : Array<T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>\n> = fiberRuntime.fiberAwaitAll\n\n/**\n * Retrieves the immediate children of the fiber.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>> = internal.children\n\n/**\n * Collects all fibers into a single fiber producing an in-order list of the\n * results.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E> = fiberRuntime.fiberAll\n\n/**\n * A fiber that is done with the specified `Exit` value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E> = internal.done\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nexport const dump: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<Fiber.Dump> = internal.dump\n\n/**\n * @since 2.0.0\n * @category destructors\n */\nexport const dumpAll: (\n  fibers: Iterable<RuntimeFiber<unknown, unknown>>\n) => Effect.Effect<Array<Fiber.Dump>> = internal.dumpAll\n\n/**\n * A fiber that has already failed with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fail: <E>(error: E) => Fiber<never, E> = internal.fail\n\n/**\n * Creates a `Fiber` that has already failed with the specified cause.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failCause: <E>(cause: Cause.Cause<E>) => Fiber<never, E> = internal.failCause\n\n/**\n * Lifts an `Effect` into a `Fiber`.\n *\n * @since 2.0.0\n * @category conversions\n */\nexport const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>> = internal.fromEffect\n\n/**\n * Gets the current fiber if one is running.\n *\n * @since 2.0.0\n * @category utilities\n */\nexport const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>> = internal.getCurrentFiber\n\n/**\n * Inherits values from all `FiberRef` instances into current fiber. This\n * will resume immediately.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const inheritAll: <A, E>(self: Fiber<A, E>) => Effect.Effect<void> = internal.inheritAll\n\n/**\n * Interrupts the fiber from whichever fiber is calling this method. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 2.0.0\n * @category interruption\n */\nexport const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>> = core.interruptFiber\n\n/**\n * Constructrs a `Fiber` that is already interrupted.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const interrupted: (fiberId: FiberId.FiberId) => Fiber<never> = internal.interrupted\n\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 2.0.0\n * @category interruption\n */\nexport const interruptAs: {\n  /**\n   * Interrupts the fiber as if interrupted from the specified fiber. If the\n   * fiber has already exited, the returned effect will resume immediately.\n   * Otherwise, the effect will resume when the fiber exits.\n   *\n   * @since 2.0.0\n   * @category interruption\n   */\n  (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>\n  /**\n   * Interrupts the fiber as if interrupted from the specified fiber. If the\n   * fiber has already exited, the returned effect will resume immediately.\n   * Otherwise, the effect will resume when the fiber exits.\n   *\n   * @since 2.0.0\n   * @category interruption\n   */\n  <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>\n} = core.interruptAsFiber\n\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 2.0.0\n * @category interruption\n */\nexport const interruptAsFork: {\n  /**\n   * Interrupts the fiber as if interrupted from the specified fiber. If the\n   * fiber has already exited, the returned effect will resume immediately.\n   * Otherwise, the effect will resume when the fiber exits.\n   *\n   * @since 2.0.0\n   * @category interruption\n   */\n  (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>\n  /**\n   * Interrupts the fiber as if interrupted from the specified fiber. If the\n   * fiber has already exited, the returned effect will resume immediately.\n   * Otherwise, the effect will resume when the fiber exits.\n   *\n   * @since 2.0.0\n   * @category interruption\n   */\n  <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>\n} = internal.interruptAsFork\n\n/**\n * Interrupts all fibers, awaiting their interruption.\n *\n * @since 2.0.0\n * @category interruption\n */\nexport const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void> = internal.interruptAll\n\n/**\n * Interrupts all fibers as by the specified fiber, awaiting their\n * interruption.\n *\n * @since 2.0.0\n * @category interruption\n */\nexport const interruptAllAs: {\n  /**\n   * Interrupts all fibers as by the specified fiber, awaiting their\n   * interruption.\n   *\n   * @since 2.0.0\n   * @category interruption\n   */\n  (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>\n  /**\n   * Interrupts all fibers as by the specified fiber, awaiting their\n   * interruption.\n   *\n   * @since 2.0.0\n   * @category interruption\n   */\n  (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>\n} = internal.interruptAllAs\n\n/**\n * Interrupts the fiber from whichever fiber is calling this method. The\n * interruption will happen in a separate daemon fiber, and the returned\n * effect will always resume immediately without waiting.\n *\n * @since 2.0.0\n * @category interruption\n */\nexport const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void> = fiberRuntime.fiberInterruptFork\n\n/**\n * Joins the fiber, which suspends the joining fiber until the result of the\n * fiber has been determined. Attempting to join a fiber that has erred will\n * result in a catchable error. Joining an interrupted fiber will result in an\n * \"inner interruption\" of this fiber, unlike interruption triggered by\n * another fiber, \"inner interruption\" can be caught and recovered.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E> = internal.join\n\n/**\n * Joins all fibers, awaiting their _successful_ completion. Attempting to\n * join a fiber that has erred will result in a catchable error, _if_ that\n * error does not result from interruption.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E> = fiberRuntime.fiberJoinAll\n\n/**\n * Maps over the value the Fiber computes.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Maps over the value the Fiber computes.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>\n  /**\n   * Maps over the value the Fiber computes.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>\n} = internal.map\n\n/**\n * Effectually maps over the value the fiber computes.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapEffect: {\n  /**\n   * Effectually maps over the value the fiber computes.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>\n  /**\n   * Effectually maps over the value the fiber computes.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>\n} = internal.mapEffect\n\n/**\n * Passes the success of this fiber to the specified callback, and continues\n * with the fiber that it returns.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapFiber: {\n  /**\n   * Passes the success of this fiber to the specified callback, and continues\n   * with the fiber that it returns.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>\n  /**\n   * Passes the success of this fiber to the specified callback, and continues\n   * with the fiber that it returns.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>\n} = internal.mapFiber\n\n/**\n * Folds over the `Fiber` or `RuntimeFiber`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds over the `Fiber` or `RuntimeFiber`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, E, Z>(\n   options: {\n     readonly onFiber: (fiber: Fiber<A, E>) => Z\n     readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z\n   }\n  ): (self: Fiber<A, E>) => Z\n  /**\n   * Folds over the `Fiber` or `RuntimeFiber`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, E, Z>(\n   self: Fiber<A, E>,\n   options: {\n     readonly onFiber: (fiber: Fiber<A, E>) => Z\n     readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z\n   }\n  ): Z\n} = internal.match\n\n/**\n * A fiber that never fails or succeeds.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const never: Fiber<never> = internal.never\n\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 2.0.0\n * @category alternatives\n */\nexport const orElse: {\n  /**\n   * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n   * when `this` one fails. Interrupting the returned fiber will interrupt both\n   * fibers, sequentially, from left to right.\n   *\n   * @since 2.0.0\n   * @category alternatives\n   */\n  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>\n  /**\n   * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n   * when `this` one fails. Interrupting the returned fiber will interrupt both\n   * fibers, sequentially, from left to right.\n   *\n   * @since 2.0.0\n   * @category alternatives\n   */\n  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>\n} = internal.orElse\n\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 2.0.0\n * @category alternatives\n */\nexport const orElseEither: {\n  /**\n   * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n   * when `this` one fails. Interrupting the returned fiber will interrupt both\n   * fibers, sequentially, from left to right.\n   *\n   * @since 2.0.0\n   * @category alternatives\n   */\n  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>\n  /**\n   * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n   * when `this` one fails. Interrupting the returned fiber will interrupt both\n   * fibers, sequentially, from left to right.\n   *\n   * @since 2.0.0\n   * @category alternatives\n   */\n  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>\n} = internal.orElseEither\n\n/**\n * Tentatively observes the fiber, but returns immediately if it is not\n * already done.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const poll: <A, E>(self: Fiber<A, E>) => Effect.Effect<Option.Option<Exit.Exit<A, E>>> = internal.poll\n\n/**\n * Pretty-prints a `RuntimeFiber`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string> = internal.pretty\n\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const roots: Effect.Effect<Array<RuntimeFiber<any, any>>> = internal.roots\n\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>> = internal.unsafeRoots\n\n/**\n * Converts this fiber into a scoped effect. The fiber is interrupted when the\n * scope is closed.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope> =\n  fiberRuntime.fiberScoped\n\n/**\n * Returns the `FiberStatus` of a `RuntimeFiber`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus> = internal.status\n\n/**\n * Returns a fiber that has already succeeded with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <A>(value: A) => Fiber<A> = internal.succeed\n\nconst void_: Fiber<void> = internal.void\nexport {\n  /**\n   * A fiber that has already succeeded with unit.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  void_ as void\n}\n\n/**\n * Zips this fiber and the specified fiber together, producing a tuple of\n * their output.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Zips this fiber and the specified fiber together, producing a tuple of\n   * their output.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>\n  /**\n   * Zips this fiber and the specified fiber together, producing a tuple of\n   * their output.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>\n} = circular.zipFiber\n\n/**\n * Same as `zip` but discards the output of that `Fiber`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft: {\n  /**\n   * Same as `zip` but discards the output of that `Fiber`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>\n  /**\n   * Same as `zip` but discards the output of that `Fiber`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>\n} = circular.zipLeftFiber\n\n/**\n * Same as `zip` but discards the output of this `Fiber`.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight: {\n  /**\n   * Same as `zip` but discards the output of this `Fiber`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>\n  /**\n   * Same as `zip` but discards the output of this `Fiber`.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>\n} = circular.zipRightFiber\n\n/**\n * Zips this fiber with the specified fiber, combining their results using the\n * specified combiner function. Both joins and interruptions are performed in\n * sequential order from left to right.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith: {\n  /**\n   * Zips this fiber with the specified fiber, combining their results using the\n   * specified combiner function. Both joins and interruptions are performed in\n   * sequential order from left to right.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>\n  /**\n   * Zips this fiber with the specified fiber, combining their results using the\n   * specified combiner function. Both joins and interruptions are performed in\n   * sequential order from left to right.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>\n} = circular.zipWithFiber\n","import type * as ReadonlyArray from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { equals } from \"../Equal.js\"\nimport * as Exit from \"../Exit.js\"\nimport * as Fiber from \"../Fiber.js\"\nimport * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport * as FiberRefs from \"../FiberRefs.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as Inspectable from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type * as Runtime from \"../Runtime.js\"\nimport type * as RuntimeFlags from \"../RuntimeFlags.js\"\nimport * as scheduler_ from \"../Scheduler.js\"\nimport * as scope_ from \"../Scope.js\"\nimport * as InternalCause from \"./cause.js\"\nimport * as core from \"./core.js\"\nimport * as executionStrategy from \"./executionStrategy.js\"\nimport * as FiberRuntime from \"./fiberRuntime.js\"\nimport * as fiberScope from \"./fiberScope.js\"\nimport * as OpCodes from \"./opCodes/effect.js\"\nimport * as runtimeFlags from \"./runtimeFlags.js\"\nimport * as supervisor_ from \"./supervisor.js\"\n\nconst makeDual = <Args extends Array<any>, Return>(\n  f: (runtime: Runtime.Runtime<never>, effect: Effect.Effect<any, any>, ...args: Args) => Return\n): {\n  <R>(runtime: Runtime.Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, ...args: Args) => Return\n  <R, A, E>(runtime: Runtime.Runtime<R>, effect: Effect.Effect<A, E, R>, ...args: Args): Return\n} =>\n  function(this: any) {\n    if (arguments.length === 1) {\n      const runtime = arguments[0]\n      return (effect: any, ...args: Args) => f(runtime, effect, ...args)\n    }\n    return f.apply(this, arguments as any)\n  } as any\n\n/** @internal */\nexport const unsafeFork: {\n  <R>(runtime: Runtime.Runtime<R>): <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunForkOptions | undefined\n  ) => Fiber.RuntimeFiber<A, E>\n  <R, A, E>(\n    runtime: Runtime.Runtime<R>,\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunForkOptions | undefined\n  ): Fiber.RuntimeFiber<A, E>\n} = makeDual(<R, A, E>(\n  runtime: Runtime.Runtime<R>,\n  self: Effect.Effect<A, E, R>,\n  options?: Runtime.RunForkOptions\n): Fiber.RuntimeFiber<A, E> => {\n  const fiberId = FiberId.unsafeMake()\n  const fiberRefUpdates: ReadonlyArray.NonEmptyArray<\n    readonly [FiberRef.FiberRef<any>, ReadonlyArray.NonEmptyReadonlyArray<readonly [FiberId.Runtime, any]>]\n  > = [[core.currentContext, [[fiberId, runtime.context]]]]\n\n  if (options?.scheduler) {\n    fiberRefUpdates.push([scheduler_.currentScheduler, [[fiberId, options.scheduler]]])\n  }\n\n  let fiberRefs = FiberRefs.updateManyAs(runtime.fiberRefs, {\n    entries: fiberRefUpdates,\n    forkAs: fiberId\n  })\n\n  if (options?.updateRefs) {\n    fiberRefs = options.updateRefs(fiberRefs, fiberId)\n  }\n\n  const fiberRuntime: FiberRuntime.FiberRuntime<A, E> = new FiberRuntime.FiberRuntime<A, E>(\n    fiberId,\n    fiberRefs,\n    runtime.runtimeFlags\n  )\n\n  let effect: Effect.Effect<A, E, R> = self\n\n  if (options?.scope) {\n    effect = core.flatMap(\n      scope_.fork(options.scope, executionStrategy.sequential),\n      (closeableScope) =>\n        core.zipRight(\n          core.scopeAddFinalizer(\n            closeableScope,\n            core.fiberIdWith((id) =>\n              equals(id, fiberRuntime.id()) ? core.void : core.interruptAsFiber(fiberRuntime, id)\n            )\n          ),\n          core.onExit(self, (exit) => scope_.close(closeableScope, exit))\n        )\n    )\n  }\n\n  const supervisor = fiberRuntime.currentSupervisor\n\n  // we can compare by reference here as _supervisor.none is wrapped with globalValue\n  if (supervisor !== supervisor_.none) {\n    supervisor.onStart(runtime.context, effect, Option.none(), fiberRuntime)\n\n    fiberRuntime.addObserver((exit) => supervisor.onEnd(exit, fiberRuntime))\n  }\n\n  fiberScope.globalScope.add(runtime.runtimeFlags, fiberRuntime)\n\n  // Only an explicit false will prevent immediate execution\n  if (options?.immediate === false) {\n    fiberRuntime.resume(effect)\n  } else {\n    fiberRuntime.start(effect)\n  }\n\n  return fiberRuntime\n})\n\n/** @internal */\nexport const unsafeRunCallback: {\n  <R>(runtime: Runtime.Runtime<R>): <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunCallbackOptions<A, E> | undefined\n  ) => (fiberId?: FiberId.FiberId, options?: Runtime.RunCallbackOptions<A, E> | undefined) => void\n  <R, A, E>(\n    runtime: Runtime.Runtime<R>,\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunCallbackOptions<A, E> | undefined\n  ): (fiberId?: FiberId.FiberId, options?: Runtime.RunCallbackOptions<A, E> | undefined) => void\n} = makeDual((\n  runtime,\n  effect,\n  options: Runtime.RunCallbackOptions<any, any> = {}\n): (fiberId?: FiberId.FiberId, options?: Runtime.RunCallbackOptions<any, any> | undefined) => void => {\n  const fiberRuntime = unsafeFork(runtime, effect, options)\n\n  if (options.onExit) {\n    fiberRuntime.addObserver((exit) => {\n      options.onExit!(exit)\n    })\n  }\n\n  return (id, cancelOptions) =>\n    unsafeRunCallback(runtime)(\n      pipe(fiberRuntime, Fiber.interruptAs(id ?? FiberId.none)),\n      {\n        ...cancelOptions,\n        onExit: cancelOptions?.onExit\n          ? (exit) => cancelOptions.onExit!(Exit.flatten(exit))\n          : undefined\n      }\n    )\n})\n\n/** @internal */\nexport const unsafeRunSync: {\n  <A, E, R>(runtime: Runtime.Runtime<R>, effect: Effect.Effect<A, E, R>): A\n  <R>(runtime: Runtime.Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => A\n} = makeDual((runtime, effect) => {\n  const result = unsafeRunSyncExit(runtime)(effect)\n  if (result._tag === \"Failure\") {\n    throw fiberFailure(result.effect_instruction_i0)\n  }\n  return result.effect_instruction_i0\n})\n\nclass AsyncFiberExceptionImpl<A, E = never> extends Error implements Runtime.AsyncFiberException<A, E> {\n  readonly _tag = \"AsyncFiberException\"\n  constructor(readonly fiber: Fiber.RuntimeFiber<A, E>) {\n    super(\n      `Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`\n    )\n    this.name = this._tag\n    this.stack = this.message\n  }\n}\n\nconst asyncFiberException = <A, E>(fiber: Fiber.RuntimeFiber<A, E>): Runtime.AsyncFiberException<A, E> => {\n  const limit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  const error = new AsyncFiberExceptionImpl(fiber)\n  Error.stackTraceLimit = limit\n  return error\n}\n\n/** @internal */\nexport const isAsyncFiberException = (u: unknown): u is Runtime.AsyncFiberException<unknown, unknown> =>\n  Predicate.isTagged(u, \"AsyncFiberException\") && \"fiber\" in u\n\n/** @internal */\nexport const FiberFailureId: Runtime.FiberFailureId = Symbol.for(\"effect/Runtime/FiberFailure\") as any\n/** @internal */\nexport const FiberFailureCauseId: Runtime.FiberFailureCauseId = Symbol.for(\n  \"effect/Runtime/FiberFailure/Cause\"\n) as any\n\nclass FiberFailureImpl extends Error implements Runtime.FiberFailure {\n  readonly [FiberFailureId]: Runtime.FiberFailureId\n  readonly [FiberFailureCauseId]: Cause.Cause<unknown>\n  constructor(cause: Cause.Cause<unknown>) {\n    const head = InternalCause.prettyErrors(cause)[0]\n\n    super(head?.message || \"An error has occurred\")\n    this[FiberFailureId] = FiberFailureId\n    this[FiberFailureCauseId] = cause\n\n    this.name = head ? `(FiberFailure) ${head.name}` : \"FiberFailure\"\n    if (head?.stack) {\n      this.stack = head.stack\n    }\n  }\n\n  toJSON(): unknown {\n    return {\n      _id: \"FiberFailure\",\n      cause: this[FiberFailureCauseId].toJSON()\n    }\n  }\n\n  toString(): string {\n    return \"(FiberFailure) \" + InternalCause.pretty(this[FiberFailureCauseId], { renderErrorCause: true })\n  }\n  [Inspectable.NodeInspectSymbol](): unknown {\n    return this.toString()\n  }\n}\n\n/** @internal */\nexport const fiberFailure = <E>(cause: Cause.Cause<E>): Runtime.FiberFailure => {\n  const limit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  const error = new FiberFailureImpl(cause)\n  Error.stackTraceLimit = limit\n  return error\n}\n\n/** @internal */\nexport const isFiberFailure = (u: unknown): u is Runtime.FiberFailure => Predicate.hasProperty(u, FiberFailureId)\n\nconst fastPath = <A, E, R>(effect: Effect.Effect<A, E, R>): Exit.Exit<A, E> | undefined => {\n  const op = effect as core.Primitive\n  switch (op._op) {\n    case \"Failure\":\n    case \"Success\": {\n      // @ts-expect-error\n      return op\n    }\n    case \"Left\": {\n      return core.exitFail(op.left)\n    }\n    case \"Right\": {\n      return core.exitSucceed(op.right)\n    }\n    case \"Some\": {\n      return core.exitSucceed(op.value)\n    }\n    case \"None\": {\n      // @ts-expect-error\n      return core.exitFail(core.NoSuchElementException())\n    }\n  }\n}\n\n/** @internal */\nexport const unsafeRunSyncExit: {\n  <A, E, R>(runtime: Runtime.Runtime<R>, effect: Effect.Effect<A, E, R>): Exit.Exit<A, E>\n  <R>(runtime: Runtime.Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>\n} = makeDual((runtime, effect) => {\n  const op = fastPath(effect)\n  if (op) {\n    return op\n  }\n  const scheduler = new scheduler_.SyncScheduler()\n  const fiberRuntime = unsafeFork(runtime)(effect, { scheduler })\n  scheduler.flush()\n  const result = fiberRuntime.unsafePoll()\n  if (result) {\n    return result\n  }\n  return core.exitDie(core.capture(asyncFiberException(fiberRuntime), core.currentSpanFromFiber(fiberRuntime)))\n})\n\n/** @internal */\nexport const unsafeRunPromise: {\n  <R>(runtime: Runtime.Runtime<R>): <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: {\n      readonly signal?: AbortSignal | undefined\n    } | undefined\n  ) => Promise<A>\n  <R, A, E>(\n    runtime: Runtime.Runtime<R>,\n    effect: Effect.Effect<A, E, R>,\n    options?: {\n      readonly signal?: AbortSignal | undefined\n    } | undefined\n  ): Promise<A>\n} = makeDual((\n  runtime,\n  effect,\n  options?: {\n    readonly signal?: AbortSignal | undefined\n  } | undefined\n) =>\n  unsafeRunPromiseExit(runtime, effect, options).then((result) => {\n    switch (result._tag) {\n      case OpCodes.OP_SUCCESS: {\n        return result.effect_instruction_i0\n      }\n      case OpCodes.OP_FAILURE: {\n        throw fiberFailure(result.effect_instruction_i0)\n      }\n    }\n  })\n)\n\n/** @internal */\nexport const unsafeRunPromiseExit: {\n  <R>(\n    runtime: Runtime.Runtime<R>\n  ): <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: { readonly signal?: AbortSignal | undefined } | undefined\n  ) => Promise<Exit.Exit<A, E>>\n  <R, A, E>(\n    runtime: Runtime.Runtime<R>,\n    effect: Effect.Effect<A, E, R>,\n    options?: { readonly signal?: AbortSignal | undefined } | undefined\n  ): Promise<Exit.Exit<A, E>>\n} = makeDual((\n  runtime,\n  effect,\n  options?: {\n    readonly signal?: AbortSignal | undefined\n  } | undefined\n) =>\n  new Promise<Exit.Exit<any, any>>((resolve) => {\n    const op = fastPath(effect)\n    if (op) {\n      resolve(op)\n    }\n    const fiber = unsafeFork(runtime)(effect)\n    fiber.addObserver((exit) => {\n      resolve(exit)\n    })\n    if (options?.signal !== undefined) {\n      if (options.signal.aborted) {\n        fiber.unsafeInterruptAsFork(fiber.id())\n      } else {\n        options.signal.addEventListener(\"abort\", () => {\n          fiber.unsafeInterruptAsFork(fiber.id())\n        }, { once: true })\n      }\n    }\n  })\n)\n\n/** @internal */\nexport class RuntimeImpl<in R> implements Runtime.Runtime<R> {\n  constructor(\n    readonly context: Context.Context<R>,\n    readonly runtimeFlags: RuntimeFlags.RuntimeFlags,\n    readonly fiberRefs: FiberRefs.FiberRefs\n  ) {}\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const make = <R>(\n  options: {\n    readonly context: Context.Context<R>\n    readonly runtimeFlags: RuntimeFlags.RuntimeFlags\n    readonly fiberRefs: FiberRefs.FiberRefs\n  }\n): Runtime.Runtime<R> => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs)\n\n/** @internal */\nexport const runtime = <R>(): Effect.Effect<Runtime.Runtime<R>, never, R> =>\n  core.withFiberRuntime((state, status) =>\n    core.succeed(\n      new RuntimeImpl<R>(\n        state.getFiberRef(core.currentContext as unknown as FiberRef.FiberRef<Context.Context<R>>),\n        status.runtimeFlags,\n        state.getFiberRefs()\n      )\n    )\n  )\n\n/** @internal */\nexport const defaultRuntimeFlags: RuntimeFlags.RuntimeFlags = runtimeFlags.make(\n  runtimeFlags.Interruption,\n  runtimeFlags.CooperativeYielding,\n  runtimeFlags.RuntimeMetrics\n)\n\n/** @internal */\nexport const defaultRuntime = make({\n  context: Context.empty(),\n  runtimeFlags: defaultRuntimeFlags,\n  fiberRefs: FiberRefs.empty()\n})\n\n/** @internal */\nexport const updateRuntimeFlags: {\n  (\n    f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags\n  ): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R>\n  <R>(self: Runtime.Runtime<R>, f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags): Runtime.Runtime<R>\n} = dual(\n  2,\n  <R>(self: Runtime.Runtime<R>, f: (flags: RuntimeFlags.RuntimeFlags) => RuntimeFlags.RuntimeFlags) =>\n    make({\n      context: self.context,\n      runtimeFlags: f(self.runtimeFlags),\n      fiberRefs: self.fiberRefs\n    })\n)\n\n/** @internal */\nexport const disableRuntimeFlag: {\n  (flag: RuntimeFlags.RuntimeFlag): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R>\n  <R>(self: Runtime.Runtime<R>, flag: RuntimeFlags.RuntimeFlag): Runtime.Runtime<R>\n} = dual(\n  2,\n  <R>(self: Runtime.Runtime<R>, flag: RuntimeFlags.RuntimeFlag) => updateRuntimeFlags(self, runtimeFlags.disable(flag))\n)\n\n/** @internal */\nexport const enableRuntimeFlag: {\n  (flag: RuntimeFlags.RuntimeFlag): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R>\n  <R>(self: Runtime.Runtime<R>, flag: RuntimeFlags.RuntimeFlag): Runtime.Runtime<R>\n} = dual(\n  2,\n  <R>(self: Runtime.Runtime<R>, flag: RuntimeFlags.RuntimeFlag) => updateRuntimeFlags(self, runtimeFlags.enable(flag))\n)\n\n/** @internal */\nexport const updateContext: {\n  <R, R2>(f: (context: Context.Context<R>) => Context.Context<R2>): (self: Runtime.Runtime<R>) => Runtime.Runtime<R2>\n  <R, R2>(self: Runtime.Runtime<R>, f: (context: Context.Context<R>) => Context.Context<R2>): Runtime.Runtime<R2>\n} = dual(\n  2,\n  <R, R2>(self: Runtime.Runtime<R>, f: (context: Context.Context<R>) => Context.Context<R2>) =>\n    make({\n      context: f(self.context),\n      runtimeFlags: self.runtimeFlags,\n      fiberRefs: self.fiberRefs\n    })\n)\n\n/** @internal */\nexport const provideService: {\n  <I, S>(tag: Context.Tag<I, S>, service: S): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R | I>\n  <R, I, S>(self: Runtime.Runtime<R>, tag: Context.Tag<I, S>, service: S): Runtime.Runtime<R | I>\n} = dual(\n  3,\n  <R, I, S>(self: Runtime.Runtime<R>, tag: Context.Tag<I, S>, service: S) =>\n    updateContext(self, Context.add(tag, service))\n)\n\n/** @internal */\nexport const updateFiberRefs: {\n  (f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R>\n  <R>(self: Runtime.Runtime<R>, f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): Runtime.Runtime<R>\n} = dual(\n  2,\n  <R>(self: Runtime.Runtime<R>, f: (fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs): Runtime.Runtime<R> =>\n    make({\n      context: self.context,\n      runtimeFlags: self.runtimeFlags,\n      fiberRefs: f(self.fiberRefs)\n    })\n)\n\n/** @internal */\nexport const setFiberRef: {\n  <A>(fiberRef: FiberRef.FiberRef<A>, value: A): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R>\n  <R, A>(self: Runtime.Runtime<R>, fiberRef: FiberRef.FiberRef<A>, value: A): Runtime.Runtime<R>\n} = dual(\n  3,\n  <R, A>(self: Runtime.Runtime<R>, fiberRef: FiberRef.FiberRef<A>, value: A): Runtime.Runtime<R> =>\n    updateFiberRefs(\n      self,\n      FiberRefs.updateAs({\n        fiberId: FiberId.none,\n        fiberRef,\n        value\n      })\n    )\n)\n\n/** @internal */\nexport const deleteFiberRef: {\n  <A>(fiberRef: FiberRef.FiberRef<A>): <R>(self: Runtime.Runtime<R>) => Runtime.Runtime<R>\n  <R, A>(self: Runtime.Runtime<R>, fiberRef: FiberRef.FiberRef<A>): Runtime.Runtime<R>\n} = dual(\n  2,\n  <R, A>(self: Runtime.Runtime<R>, fiberRef: FiberRef.FiberRef<A>): Runtime.Runtime<R> =>\n    updateFiberRefs(self, FiberRefs.delete(fiberRef))\n)\n\n/** @internal */\nexport const unsafeRunEffect = unsafeRunCallback(defaultRuntime)\n\n/** @internal */\nexport const unsafeForkEffect = unsafeFork(defaultRuntime)\n\n/** @internal */\nexport const unsafeRunPromiseEffect = unsafeRunPromise(defaultRuntime)\n\n/** @internal */\nexport const unsafeRunPromiseExitEffect = unsafeRunPromiseExit(defaultRuntime)\n\n/** @internal */\nexport const unsafeRunSyncEffect = unsafeRunSync(defaultRuntime)\n\n/** @internal */\nexport const unsafeRunSyncExitEffect = unsafeRunSyncExit(defaultRuntime)\n\n// circular with Effect\n\n/** @internal */\nexport const asyncEffect = <A, E, R, R3, E2, R2>(\n  register: (\n    callback: (_: Effect.Effect<A, E, R>) => void\n  ) => Effect.Effect<Effect.Effect<void, never, R3> | void, E2, R2>\n): Effect.Effect<A, E | E2, R | R2 | R3> =>\n  core.suspend(() => {\n    let cleanup: Effect.Effect<void, never, R3> | void = undefined\n    return core.flatMap(\n      core.deferredMake<A, E | E2>(),\n      (deferred) =>\n        core.flatMap(runtime<R | R2 | R3>(), (runtime) =>\n          core.uninterruptibleMask((restore) =>\n            core.zipRight(\n              FiberRuntime.fork(restore(\n                core.matchCauseEffect(\n                  register((cb) => unsafeRunCallback(runtime)(core.intoDeferred(cb, deferred))),\n                  {\n                    onFailure: (cause) => core.deferredFailCause(deferred, cause),\n                    onSuccess: (cleanup_) => {\n                      cleanup = cleanup_\n                      return core.void\n                    }\n                  }\n                )\n              )),\n              restore(core.onInterrupt(core.deferredAwait(deferred), () => cleanup ?? core.void))\n            )\n          ))\n    )\n  })\n","import type * as Effect from \"../Effect.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as Option from \"../Option.js\"\nimport type * as Synchronized from \"../SynchronizedRef.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nexport const getAndUpdateEffect = dual<\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<A, E, R>,\n  <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n>(2, (self, f) =>\n  self.modifyEffect(\n    (value) => core.map(f(value), (result) => [value, result] as const)\n  ))\n\n/** @internal */\nexport const getAndUpdateSomeEffect = dual<\n  <A, R, E>(\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<A, E, R>,\n  <A, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, pf) =>\n  self.modifyEffect((value) => {\n    const result = pf(value)\n    switch (result._tag) {\n      case \"None\": {\n        return core.succeed([value, value] as const)\n      }\n      case \"Some\": {\n        return core.map(result.value, (newValue) => [value, newValue] as const)\n      }\n    }\n  }))\n\n/** @internal */\nexport const modify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B>,\n  <A, B>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => readonly [B, A]) => Effect.Effect<B>\n>(2, (self, f) => self.modify(f))\n\n/** @internal */\nexport const modifyEffect = dual<\n  <A, B, E, R>(\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(\n    self: Synchronized.SynchronizedRef<A>,\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ) => Effect.Effect<B, E, R>\n>(2, (self, f) => self.modifyEffect(f))\n\n/** @internal */\nexport const modifySomeEffect = dual<\n  <A, B, R, E>(\n    fallback: B,\n    pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    fallback: B,\n    pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ) => Effect.Effect<B, E, R>\n>(3, (self, fallback, pf) =>\n  self.modifyEffect(\n    (value) => pipe(pf(value), Option.getOrElse(() => core.succeed([fallback, value] as const)))\n  ))\n\n/** @internal */\nexport const updateEffect = dual<\n  <A, R, E>(\n    f: (a: A) => Effect.Effect<A, E, R>\n  ) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>,\n  <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>\n>(2, (self, f) =>\n  self.modifyEffect((value) =>\n    core.map(\n      f(value),\n      (result) => [undefined as void, result] as const\n    )\n  ))\n\n/** @internal */\nexport const updateAndGetEffect = dual<\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<A, E, R>,\n  <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n>(2, (self, f) =>\n  self.modifyEffect(\n    (value) => core.map(f(value), (result) => [result, result] as const)\n  ))\n\n/** @internal */\nexport const updateSomeEffect = dual<\n  <A, R, E>(\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ) => (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>,\n  <A, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ) => Effect.Effect<void, E, R>\n>(2, (self, pf) =>\n  self.modifyEffect((value) => {\n    const result = pf(value)\n    switch (result._tag) {\n      case \"None\": {\n        return core.succeed([void 0, value] as const)\n      }\n      case \"Some\": {\n        return core.map(result.value, (a) => [void 0, a] as const)\n      }\n    }\n  }))\n","/** @internal */\nexport const OP_EXTEND_SCOPE = \"ExtendScope\" as const\n\n/** @internal */\nexport type OP_EXTEND_SCOPE = typeof OP_EXTEND_SCOPE\n\n/** @internal */\nexport const OP_FOLD = \"Fold\" as const\n\n/** @internal */\nexport type OP_FOLD = typeof OP_FOLD\n\n/** @internal */\nexport const OP_FRESH = \"Fresh\" as const\n\n/** @internal */\nexport type OP_FRESH = typeof OP_FRESH\n\n/** @internal */\nexport const OP_FROM_EFFECT = \"FromEffect\" as const\n\n/** @internal */\nexport type OP_FROM_EFFECT = typeof OP_FROM_EFFECT\n\n/** @internal */\nexport const OP_SCOPED = \"Scoped\" as const\n\n/** @internal */\nexport type OP_SCOPED = typeof OP_SCOPED\n\n/** @internal */\nexport const OP_SUSPEND = \"Suspend\" as const\n\n/** @internal */\nexport type OP_SUSPEND = typeof OP_SUSPEND\n\n/** @internal */\nexport const OP_PROVIDE = \"Provide\" as const\n\n/** @internal */\nexport type OP_PROVIDE = typeof OP_PROVIDE\n\n/** @internal */\nexport const OP_PROVIDE_MERGE = \"ProvideMerge\" as const\n\n/** @internal */\nexport type OP_PROVIDE_MERGE = typeof OP_PROVIDE_MERGE\n\n/** @internal */\nexport const OP_ZIP_WITH = \"ZipWith\" as const\n\n/** @internal */\nexport type OP_ZIP_WITH = typeof OP_ZIP_WITH\n","import type * as M from \"../../ManagedRuntime.js\"\n\n// circular with Layer\n\n/** @internal */\nexport const TypeId: M.TypeId = Symbol.for(\"effect/ManagedRuntime\") as M.TypeId\n","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport * as core from \"./internal/core.js\"\nimport * as internal from \"./internal/data.js\"\nimport { StructuralPrototype } from \"./internal/effectable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as Types from \"./Types.js\"\nimport type { Unify } from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Case {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Constructor<A, Tag extends keyof A = never> {\n    (\n      args: Types.Equals<Omit<A, Tag>, {}> extends true ? void\n        : { readonly [P in keyof A as P extends Tag ? never : P]: A[P] }\n    ): A\n  }\n}\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * const alice = Data.struct({ name: \"Alice\", age: 30 })\n *\n * const bob = Data.struct({ name: \"Bob\", age: 40 })\n *\n * assert.deepStrictEqual(Equal.equals(alice, alice), true)\n * assert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: \"Alice\", age: 30 })), true)\n *\n * assert.deepStrictEqual(Equal.equals(alice, { name: \"Alice\", age: 30 }), false)\n * assert.deepStrictEqual(Equal.equals(alice, bob), false)\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const struct: <A extends Record<string, any>>(a: A) => { readonly [P in keyof A]: A[P] } = internal.struct\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unsafeStruct = <A extends Record<string, any>>(as: A): { readonly [P in keyof A]: A[P] } =>\n  Object.setPrototypeOf(as, StructuralPrototype)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * const alice = Data.tuple(\"Alice\", 30)\n *\n * const bob = Data.tuple(\"Bob\", 40)\n *\n * assert.deepStrictEqual(Equal.equals(alice, alice), true)\n * assert.deepStrictEqual(Equal.equals(alice, Data.tuple(\"Alice\", 30)), true)\n *\n * assert.deepStrictEqual(Equal.equals(alice, [\"Alice\", 30]), false)\n * assert.deepStrictEqual(Equal.equals(alice, bob), false)\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const tuple = <As extends ReadonlyArray<any>>(...as: As): Readonly<As> => unsafeArray(as)\n\n/**\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * const alice = Data.struct({ name: \"Alice\", age: 30 })\n * const bob = Data.struct({ name: \"Bob\", age: 40 })\n *\n * const persons = Data.array([alice, bob])\n *\n * assert.deepStrictEqual(\n *   Equal.equals(\n *     persons,\n *     Data.array([\n *       Data.struct({ name: \"Alice\", age: 30 }),\n *       Data.struct({ name: \"Bob\", age: 40 })\n *     ])\n *   ),\n *   true\n * )\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const array = <As extends ReadonlyArray<any>>(as: As): Readonly<As> => unsafeArray(as.slice(0) as unknown as As)\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unsafeArray = <As extends ReadonlyArray<any>>(as: As): Readonly<As> =>\n  Object.setPrototypeOf(as, internal.ArrayProto)\n\nconst _case = <A>(): Case.Constructor<A> => (args) =>\n  (args === undefined ? Object.create(StructuralPrototype) : struct(args)) as any\n\nexport {\n  /**\n   * Provides a constructor for the specified `Case`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Data, Equal } from \"effect\"\n   *\n   * interface Person {\n   *   readonly name: string\n   * }\n   *\n   * // Creating a constructor for the specified Case\n   * const Person = Data.case<Person>()\n   *\n   * // Creating instances of Person\n   * const mike1 = Person({ name: \"Mike\" })\n   * const mike2 = Person({ name: \"Mike\" })\n   * const john = Person({ name: \"John\" })\n   *\n   * // Checking equality\n   * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)\n   * assert.deepStrictEqual(Equal.equals(mike1, john), false)\n   *\n   * ```\n   * @since 2.0.0\n   * @category constructors\n   */\n  _case as case\n}\n\n/**\n * Provides a tagged constructor for the specified `Case`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data } from \"effect\"\n *\n * interface Person {\n *   readonly _tag: \"Person\" // the tag\n *   readonly name: string\n * }\n *\n * const Person = Data.tagged<Person>(\"Person\")\n *\n * const mike = Person({ name: \"Mike\" })\n *\n * assert.deepEqual(mike, { _tag: \"Person\", name: \"Mike\" })\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const tagged = <A extends { readonly _tag: string }>(\n  tag: A[\"_tag\"]\n): Case.Constructor<A, \"_tag\"> =>\n(args) => {\n  const value = args === undefined ? Object.create(StructuralPrototype) : struct(args)\n  value._tag = tag\n  return value\n}\n\n/**\n * Provides a constructor for a Case Class.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * class Person extends Data.Class<{ readonly name: string }> {}\n *\n * // Creating instances of Person\n * const mike1 = new Person({ name: \"Mike\" })\n * const mike2 = new Person({ name: \"Mike\" })\n * const john = new Person({ name: \"John\" })\n *\n * // Checking equality\n * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)\n * assert.deepStrictEqual(Equal.equals(mike1, john), false)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Class: new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => Readonly<A> = internal.Structural as any\n\n/**\n * Provides a Tagged constructor for a Case Class.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data, Equal } from \"effect\"\n *\n * class Person extends Data.TaggedClass(\"Person\")<{ readonly name: string }> {}\n *\n * // Creating instances of Person\n * const mike1 = new Person({ name: \"Mike\" })\n * const mike2 = new Person({ name: \"Mike\" })\n * const john = new Person({ name: \"John\" })\n *\n * // Checking equality\n * assert.deepStrictEqual(Equal.equals(mike1, mike2), true)\n * assert.deepStrictEqual(Equal.equals(mike1, john), false)\n *\n * assert.deepStrictEqual(mike1._tag, \"Person\")\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const TaggedClass = <Tag extends string>(\n  tag: Tag\n): new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P] }\n) => Readonly<A> & { readonly _tag: Tag } => {\n  class Base extends Class<any> {\n    readonly _tag = tag\n  }\n  return Base as any\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Structural: new<A>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => {} = internal.Structural as any\n\n/**\n * Create a tagged enum data type, which is a union of `Data` structs.\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Data } from \"effect\"\n *\n * type HttpError = Data.TaggedEnum<{\n *   BadRequest: { readonly status: 400, readonly message: string }\n *   NotFound: { readonly status: 404, readonly message: string }\n * }>\n *\n * // Equivalent to:\n * type HttpErrorPlain =\n *   | {\n *     readonly _tag: \"BadRequest\"\n *     readonly status: 400\n *     readonly message: string\n *   }\n *   | {\n *     readonly _tag: \"NotFound\"\n *     readonly status: 404\n *     readonly message: string\n *   }\n * ```\n *\n * @since 2.0.0\n * @category models\n */\nexport type TaggedEnum<\n  A extends Record<string, Record<string, any>> & UntaggedChildren<A>\n> = keyof A extends infer Tag ?\n  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>\n  : never\n  : never\n\ntype ChildrenAreTagged<A> = keyof A extends infer K ? K extends keyof A ? \"_tag\" extends keyof A[K] ? true\n    : false\n  : never\n  : never\n\ntype UntaggedChildren<A> = true extends ChildrenAreTagged<A>\n  ? \"It looks like you're trying to create a tagged enum, but one or more of its members already has a `_tag` property.\"\n  : unknown\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TaggedEnum {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface WithGenerics<Count extends number> {\n    readonly taggedEnum: { readonly _tag: string }\n    readonly numberOfGenerics: Count\n\n    readonly A: unknown\n    readonly B: unknown\n    readonly C: unknown\n    readonly D: unknown\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Kind<\n    Z extends WithGenerics<number>,\n    A = unknown,\n    B = unknown,\n    C = unknown,\n    D = unknown\n  > = (Z & {\n    readonly A: A\n    readonly B: B\n    readonly C: C\n    readonly D: D\n  })[\"taggedEnum\"]\n\n  /**\n   * @since 2.0.0\n   */\n  export type Args<\n    A extends { readonly _tag: string },\n    K extends A[\"_tag\"],\n    E = Extract<A, { readonly _tag: K }>\n  > = { readonly [K in keyof E as K extends \"_tag\" ? never : K]: E[K] } extends infer T ? {} extends T ? void : T\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type Value<\n    A extends { readonly _tag: string },\n    K extends A[\"_tag\"]\n  > = Extract<A, { readonly _tag: K }>\n\n  /**\n   * @since 3.1.0\n   */\n  export type Constructor<A extends { readonly _tag: string }> = Types.Simplify<\n    & {\n      readonly [Tag in A[\"_tag\"]]: Case.Constructor<Extract<A, { readonly _tag: Tag }>, \"_tag\">\n    }\n    & {\n      readonly $is: <Tag extends A[\"_tag\"]>(tag: Tag) => (u: unknown) => u is Extract<A, { readonly _tag: Tag }>\n      readonly $match: {\n        <\n          const Cases extends {\n            readonly [Tag in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: Tag }>) => any\n          }\n        >(\n          cases: Cases & { [K in Exclude<keyof Cases, A[\"_tag\"]>]: never }\n        ): (value: A) => Unify<ReturnType<Cases[A[\"_tag\"]]>>\n        <\n          const Cases extends {\n            readonly [Tag in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: Tag }>) => any\n          }\n        >(\n          value: A,\n          cases: Cases & { [K in Exclude<keyof Cases, A[\"_tag\"]>]: never }\n        ): Unify<ReturnType<Cases[A[\"_tag\"]]>>\n      }\n    }\n  >\n\n  /**\n   * @since 3.2.0\n   */\n  export interface GenericMatchers<Z extends WithGenerics<number>> {\n    readonly $is: <Tag extends Z[\"taggedEnum\"][\"_tag\"]>(\n      tag: Tag\n    ) => {\n      <T extends TaggedEnum.Kind<Z, any, any, any, any>>(\n        u: T\n      ): u is T & { readonly _tag: Tag }\n      (u: unknown): u is Extract<TaggedEnum.Kind<Z>, { readonly _tag: Tag }>\n    }\n    readonly $match: {\n      <\n        A,\n        B,\n        C,\n        D,\n        Cases extends {\n          readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: (\n            args: Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n          ) => any\n        }\n      >(\n        cases: Cases & { [K in Exclude<keyof Cases, Z[\"taggedEnum\"][\"_tag\"]>]: never }\n      ): (self: TaggedEnum.Kind<Z, A, B, C, D>) => Unify<ReturnType<Cases[Z[\"taggedEnum\"][\"_tag\"]]>>\n      <\n        A,\n        B,\n        C,\n        D,\n        Cases extends {\n          readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: (\n            args: Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n          ) => any\n        }\n      >(\n        self: TaggedEnum.Kind<Z, A, B, C, D>,\n        cases: Cases & { [K in Exclude<keyof Cases, Z[\"taggedEnum\"][\"_tag\"]>]: never }\n      ): Unify<ReturnType<Cases[Z[\"taggedEnum\"][\"_tag\"]]>>\n    }\n  }\n}\n\n/**\n * Create a constructor for a tagged union of `Data` structs.\n *\n * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n * the constructor.\n *\n * @example\n * ```ts\n * import { Data } from \"effect\"\n *\n * const { BadRequest, NotFound } = Data.taggedEnum<\n *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n * >()\n *\n * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n * ```\n *\n * @example\n * import { Data } from \"effect\"\n *\n * type MyResult<E, A> = Data.TaggedEnum<{\n *   Failure: { readonly error: E }\n *   Success: { readonly value: A }\n * }>\n * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n * }\n * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n *\n * const success = Success({ value: 1 })\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const taggedEnum:\n  {\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A, B>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A, B, C>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<\n    {\n      readonly [Tag in Z[\"taggedEnum\"][\"_tag\"]]: <A, B, C, D>(\n        args: TaggedEnum.Args<\n          TaggedEnum.Kind<Z, A, B, C, D>,\n          Tag,\n          Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag }>\n        >\n      ) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>\n    } & TaggedEnum.GenericMatchers<Z>\n  >\n\n  /**\n   * Create a constructor for a tagged union of `Data` structs.\n   *\n   * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to\n   * the constructor.\n   *\n   * @example\n   * ```ts\n   * import { Data } from \"effect\"\n   *\n   * const { BadRequest, NotFound } = Data.taggedEnum<\n   *   | { readonly _tag: \"BadRequest\"; readonly status: 400; readonly message: string }\n   *   | { readonly _tag: \"NotFound\"; readonly status: 404; readonly message: string }\n   * >()\n   *\n   * const notFound = NotFound({ status: 404, message: \"Not Found\" })\n   * ```\n   *\n   * @example\n   * import { Data } from \"effect\"\n   *\n   * type MyResult<E, A> = Data.TaggedEnum<{\n   *   Failure: { readonly error: E }\n   *   Success: { readonly value: A }\n   * }>\n   * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {\n   *   readonly taggedEnum: MyResult<this[\"A\"], this[\"B\"]>\n   * }\n   * const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()\n   *\n   * const success = Success({ value: 1 })\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  <A extends { readonly _tag: string }>(): TaggedEnum.Constructor<A>\n} = () =>\n  new Proxy({}, {\n    get(_target, tag, _receiver) {\n      if (tag === \"$is\") {\n        return Predicate.isTagged\n      } else if (tag === \"$match\") {\n        return taggedMatch\n      }\n      return tagged(tag as string)\n    }\n  }) as any\n\nfunction taggedMatch<\n  A extends { readonly _tag: string },\n  Cases extends {\n    readonly [K in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: K }>) => any\n  }\n>(self: A, cases: Cases): ReturnType<Cases[A[\"_tag\"]]>\nfunction taggedMatch<\n  A extends { readonly _tag: string },\n  Cases extends {\n    readonly [K in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: K }>) => any\n  }\n>(cases: Cases): (value: A) => ReturnType<Cases[A[\"_tag\"]]>\nfunction taggedMatch<\n  A extends { readonly _tag: string },\n  Cases extends {\n    readonly [K in A[\"_tag\"]]: (args: Extract<A, { readonly _tag: K }>) => any\n  }\n>(): any {\n  if (arguments.length === 1) {\n    const cases = arguments[0] as Cases\n    return function(value: A): ReturnType<Cases[A[\"_tag\"]]> {\n      return cases[value._tag as A[\"_tag\"]](value as any)\n    }\n  }\n  const value = arguments[0] as A\n  const cases = arguments[1] as Cases\n  return cases[value._tag as A[\"_tag\"]](value as any)\n}\n\n/**\n * Provides a constructor for a Case Class.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Error: new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A]: A[P] }\n) => Cause.YieldableError & Readonly<A> = (function() {\n  const plainArgsSymbol = Symbol.for(\"effect/Data/Error/plainArgs\")\n  const O = {\n    BaseEffectError: class extends core.YieldableError {\n      constructor(args: any) {\n        super(args?.message, args?.cause ? { cause: args.cause } : undefined)\n        if (args) {\n          Object.assign(this, args)\n          // @effect-diagnostics-next-line floatingEffect:off\n          Object.defineProperty(this, plainArgsSymbol, { value: args, enumerable: false })\n        }\n      }\n      toJSON() {\n        return { ...(this as any)[plainArgsSymbol], ...this }\n      }\n    } as any\n  }\n  return O.BaseEffectError\n})()\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const TaggedError = <Tag extends string>(tag: Tag): new<A extends Record<string, any> = {}>(\n  args: Types.Equals<A, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" ? never : P]: A[P] }\n) => Cause.YieldableError & { readonly _tag: Tag } & Readonly<A> => {\n  const O = {\n    BaseEffectError: class extends Error<{}> {\n      readonly _tag = tag\n    }\n  }\n  ;(O.BaseEffectError.prototype as any).name = tag\n  return O.BaseEffectError as any\n}\n","import type * as Console from \"../Console.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { dual } from \"../Function.js\"\nimport type * as Layer from \"../Layer.js\"\nimport type * as Scope from \"../Scope.js\"\nimport * as core from \"./core.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport * as defaultConsole from \"./defaultServices/console.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as layer from \"./layer.js\"\n\n/** @internal */\nexport const console: Effect.Effect<Console.Console> = core.map(\n  core.fiberRefGet(defaultServices.currentServices),\n  Context.get(defaultConsole.consoleTag)\n)\n\n/** @internal */\nexport const consoleWith = <A, E, R>(f: (console: Console.Console) => Effect.Effect<A, E, R>) =>\n  core.fiberRefGetWith(\n    defaultServices.currentServices,\n    (services) => f(Context.get(services, defaultConsole.consoleTag))\n  )\n\n/** @internal */\nexport const withConsole = dual<\n  <C extends Console.Console>(console: C) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R, C extends Console.Console>(effect: Effect.Effect<A, E, R>, console: C) => Effect.Effect<A, E, R>\n>(2, (effect, value) =>\n  core.fiberRefLocallyWith(\n    effect,\n    defaultServices.currentServices,\n    Context.add(defaultConsole.consoleTag, value)\n  ))\n\n/** @internal */\nexport const withConsoleScoped = <A extends Console.Console>(console: A): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRuntime.fiberRefLocallyScopedWith(\n    defaultServices.currentServices,\n    Context.add(defaultConsole.consoleTag, console)\n  )\n\n/** @internal */\nexport const setConsole = <A extends Console.Console>(console: A): Layer.Layer<never> =>\n  layer.scopedDiscard(\n    fiberRuntime.fiberRefLocallyScopedWith(\n      defaultServices.currentServices,\n      Context.add(defaultConsole.consoleTag, console)\n    )\n  )\n\n/** @internal */\nexport const assert = (condition: boolean, ...args: ReadonlyArray<any>) =>\n  consoleWith((_) => _.assert(condition, ...args))\n\n/** @internal */\nexport const clear = consoleWith((_) => _.clear)\n\n/** @internal */\nexport const count = (label?: string) => consoleWith((_) => _.count(label))\n\n/** @internal */\nexport const countReset = (label?: string) => consoleWith((_) => _.countReset(label))\n\n/** @internal */\nexport const debug = (...args: ReadonlyArray<any>) => consoleWith((_) => _.debug(...args))\n\n/** @internal */\nexport const dir = (item: any, options?: any) => consoleWith((_) => _.dir(item, options))\n\n/** @internal */\nexport const dirxml = (...args: ReadonlyArray<any>) => consoleWith((_) => _.dirxml(...args))\n\n/** @internal */\nexport const error = (...args: ReadonlyArray<any>) => consoleWith((_) => _.error(...args))\n\n/** @internal */\nexport const group = (options?: {\n  label?: string | undefined\n  collapsed?: boolean | undefined\n}) =>\n  consoleWith((_) =>\n    fiberRuntime.acquireRelease(\n      _.group(options),\n      () => _.groupEnd\n    )\n  )\n\n/** @internal */\nexport const info = (...args: ReadonlyArray<any>) => consoleWith((_) => _.info(...args))\n\n/** @internal */\nexport const log = (...args: ReadonlyArray<any>) => consoleWith((_) => _.log(...args))\n\n/** @internal */\nexport const table = (tabularData: any, properties?: ReadonlyArray<string>) =>\n  consoleWith((_) => _.table(tabularData, properties))\n\n/** @internal */\nexport const time = (label?: string) =>\n  consoleWith((_) =>\n    fiberRuntime.acquireRelease(\n      _.time(label),\n      () => _.timeEnd(label)\n    )\n  )\n\n/** @internal */\nexport const timeLog = (label?: string, ...args: ReadonlyArray<any>) => consoleWith((_) => _.timeLog(label, ...args))\n\n/** @internal */\nexport const trace = (...args: ReadonlyArray<any>) => consoleWith((_) => _.trace(...args))\n\n/** @internal */\nexport const warn = (...args: ReadonlyArray<any>) => consoleWith((_) => _.warn(...args))\n\n/** @internal */\nexport const withGroup = dual<\n  (\n    options?: {\n      readonly label?: string | undefined\n      readonly collapsed?: boolean | undefined\n    }\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    options?: {\n      readonly label?: string | undefined\n      readonly collapsed?: boolean | undefined\n    }\n  ) => Effect.Effect<A, E, R>\n>((args) => core.isEffect(args[0]), (self, options) =>\n  consoleWith((_) =>\n    core.acquireUseRelease(\n      _.group(options),\n      () => self,\n      () => _.groupEnd\n    )\n  ))\n\n/** @internal */\nexport const withTime = dual<\n  (label?: string) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, label?: string) => Effect.Effect<A, E, R>\n>((args) => core.isEffect(args[0]), (self, label) =>\n  consoleWith((_) =>\n    core.acquireUseRelease(\n      _.time(label),\n      () => self,\n      () => _.timeEnd(label)\n    )\n  ))\n","/**\n * @since 2.0.0\n */\nimport type * as RA from \"./Array.js\"\nimport type * as Cause from \"./Cause.js\"\nimport type * as Chunk from \"./Chunk.js\"\nimport type * as Clock from \"./Clock.js\"\nimport type { ConfigProvider } from \"./ConfigProvider.js\"\nimport type { Console } from \"./Console.js\"\nimport type * as Context from \"./Context.js\"\nimport type * as Deferred from \"./Deferred.js\"\nimport type * as Duration from \"./Duration.js\"\nimport type * as Either from \"./Either.js\"\nimport type { Equivalence } from \"./Equivalence.js\"\nimport type { ExecutionPlan } from \"./ExecutionPlan.js\"\nimport type { ExecutionStrategy } from \"./ExecutionStrategy.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type * as FiberRef from \"./FiberRef.js\"\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport type * as FiberRefsPatch from \"./FiberRefsPatch.js\"\nimport type * as FiberStatus from \"./FiberStatus.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual } from \"./Function.js\"\nimport type * as HashMap from \"./HashMap.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as internalCause from \"./internal/cause.js\"\nimport * as console_ from \"./internal/console.js\"\nimport { TagProto } from \"./internal/context.js\"\nimport * as effect from \"./internal/core-effect.js\"\nimport * as core from \"./internal/core.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\nimport * as circular from \"./internal/effect/circular.js\"\nimport * as internalExecutionPlan from \"./internal/executionPlan.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as layer from \"./internal/layer.js\"\nimport * as option_ from \"./internal/option.js\"\nimport * as query from \"./internal/query.js\"\nimport * as runtime_ from \"./internal/runtime.js\"\nimport * as schedule_ from \"./internal/schedule.js\"\nimport * as internalTracer from \"./internal/tracer.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as LogLevel from \"./LogLevel.js\"\nimport type * as ManagedRuntime from \"./ManagedRuntime.js\"\nimport type * as Metric from \"./Metric.js\"\nimport type * as MetricLabel from \"./MetricLabel.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport * as Random from \"./Random.js\"\nimport type * as Ref from \"./Ref.js\"\nimport * as Request from \"./Request.js\"\nimport type { RequestBlock } from \"./RequestBlock.js\"\nimport type { RequestResolver } from \"./RequestResolver.js\"\nimport type * as Runtime from \"./Runtime.js\"\nimport type * as RuntimeFlags from \"./RuntimeFlags.js\"\nimport type * as RuntimeFlagsPatch from \"./RuntimeFlagsPatch.js\"\nimport type * as Schedule from \"./Schedule.js\"\nimport * as Scheduler from \"./Scheduler.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as Supervisor from \"./Supervisor.js\"\nimport type * as Tracer from \"./Tracer.js\"\nimport type {\n  Concurrency,\n  Contravariant,\n  Covariant,\n  EqualsWith,\n  NoExcessProperties,\n  NoInfer,\n  NotFunction\n} from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport { isGeneratorFunction, type YieldWrap } from \"./Utils.js\"\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport const EffectTypeId: unique symbol = core.EffectTypeId\n\n/**\n * @since 2.0.0\n * @category Symbols\n */\nexport type EffectTypeId = typeof EffectTypeId\n\n/**\n * The `Effect` interface defines a value that describes a workflow or job,\n * which can succeed or fail.\n *\n * **Details**\n *\n * The `Effect` interface represents a computation that can model a workflow\n * involving various types of operations, such as synchronous, asynchronous,\n * concurrent, and parallel interactions. It operates within a context of type\n * `R`, and the result can either be a success with a value of type `A` or a\n * failure with an error of type `E`. The `Effect` is designed to handle complex\n * interactions with external resources, offering advanced features such as\n * fiber-based concurrency, scheduling, interruption handling, and scalability.\n * This makes it suitable for tasks that require fine-grained control over\n * concurrency and error management.\n *\n * To execute an `Effect` value, you need a `Runtime`, which provides the\n * environment necessary to run and manage the computation.\n *\n * @since 2.0.0\n * @category Models\n */\nexport interface Effect<out A, out E = never, out R = never> extends Effect.Variance<A, E, R>, Pipeable {\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: EffectUnify<this>\n  readonly [Unify.ignoreSymbol]?: EffectUnifyIgnore\n  [Symbol.iterator](): EffectGenerator<Effect<A, E, R>>\n}\n\n/**\n * @since 3.0.0\n * @category Models\n */\nexport interface EffectGenerator<T extends Effect<any, any, any>> {\n  next(...args: ReadonlyArray<any>): IteratorResult<YieldWrap<T>, Effect.Success<T>>\n}\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport interface EffectUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Either.EitherUnify<A>, Option.OptionUnify<A>, Context.TagUnify<A>\n{\n  Effect?: () => A[Unify.typeSymbol] extends Effect<infer A0, infer E0, infer R0> | infer _ ? Effect<A0, E0, R0> : never\n}\n\n/**\n * @category Models\n * @since 2.0.0\n */\nexport interface EffectUnifyIgnore {\n  Tag?: true\n  Option?: true\n  Either?: true\n}\n\n/**\n * @category Type lambdas\n * @since 2.0.0\n */\nexport interface EffectTypeLambda extends TypeLambda {\n  readonly type: Effect<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport interface Blocked<out A, out E> extends Effect<A, E> {\n  readonly _op: \"Blocked\"\n  readonly effect_instruction_i0: RequestBlock\n  readonly effect_instruction_i1: Effect<A, E>\n}\n\n/**\n * @since 2.0.0\n * @category Models\n */\ndeclare module \"./Context.js\" {\n  interface Tag<Id, Value> extends Effect<Value, never, Id> {\n    [Symbol.iterator](): EffectGenerator<Tag<Id, Value>>\n  }\n  interface Reference<Id, Value> extends Effect<Value> {\n    [Symbol.iterator](): EffectGenerator<Reference<Id, Value>>\n  }\n  interface TagUnifyIgnore {\n    Effect?: true\n    Either?: true\n    Option?: true\n  }\n}\n\n/**\n * @since 2.0.0\n * @category Models\n */\ndeclare module \"./Either.js\" {\n  interface Left<E, A> extends Effect<A, E> {\n    readonly _tag: \"Left\"\n    [Symbol.iterator](): EffectGenerator<Left<E, A>>\n  }\n  interface Right<E, A> extends Effect<A, E> {\n    readonly _tag: \"Right\"\n    [Symbol.iterator](): EffectGenerator<Right<E, A>>\n  }\n  interface EitherUnifyIgnore {\n    Effect?: true\n    Tag?: true\n    Option?: true\n  }\n}\n\n/**\n * @since 2.0.0\n * @category Models\n */\ndeclare module \"./Option.js\" {\n  interface None<A> extends Effect<A, Cause.NoSuchElementException> {\n    readonly _tag: \"None\"\n    [Symbol.iterator](): EffectGenerator<None<A>>\n  }\n  interface Some<A> extends Effect<A, Cause.NoSuchElementException> {\n    readonly _tag: \"Some\"\n    [Symbol.iterator](): EffectGenerator<Some<A>>\n  }\n  interface OptionUnifyIgnore {\n    Effect?: true\n    Tag?: true\n    Either?: true\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Effect {\n  /**\n   * @since 2.0.0\n   * @category Models\n   */\n  export interface Variance<out A, out E, out R> {\n    readonly [EffectTypeId]: VarianceStruct<A, E, R>\n  }\n  /**\n   * @since 2.0.0\n   * @category Models\n   */\n  export interface VarianceStruct<out A, out E, out R> {\n    readonly _V: string\n    readonly _A: Covariant<A>\n    readonly _E: Covariant<E>\n    readonly _R: Covariant<R>\n  }\n  /**\n   * @since 2.0.0\n   * @category Effect Type Extractors\n   */\n  export type Context<T extends Effect<any, any, any>> = [T] extends [Effect<infer _A, infer _E, infer _R>] ? _R : never\n  /**\n   * @since 2.0.0\n   * @category Effect Type Extractors\n   */\n  export type Error<T extends Effect<any, any, any>> = [T] extends [Effect<infer _A, infer _E, infer _R>] ? _E : never\n  /**\n   * @since 2.0.0\n   * @category Effect Type Extractors\n   */\n  export type Success<T extends Effect<any, any, any>> = [T] extends [Effect<infer _A, infer _E, infer _R>] ? _A : never\n  /**\n   * @since 3.15.5\n   * @category Effect Type Extractors\n   */\n  export type AsEffect<T extends Effect<any, any, any>> = Effect<\n    T extends Effect<infer _A, infer _E, infer _R> ? _A : never,\n    T extends Effect<infer _A, infer _E, infer _R> ? _E : never,\n    T extends Effect<infer _A, infer _E, infer _R> ? _R : never\n  >\n}\n\n/**\n * Checks if a given value is an `Effect` value.\n *\n * **When to Use**\n *\n * This function can be useful for checking the type of a value before\n * attempting to operate on it as an `Effect` value. For example, you could use\n * `Effect.isEffect` to check the type of a value before using it as an argument\n * to a function that expects an `Effect` value.\n *\n * @since 2.0.0\n * @category Guards\n */\nexport const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown> = core.isEffect\n\n/**\n * Returns an effect that caches its result for a specified `Duration`,\n * known as \"timeToLive\" (TTL).\n *\n * **Details**\n *\n * This function is used to cache the result of an effect for a specified amount\n * of time. This means that the first time the effect is evaluated, its result\n * is computed and stored.\n *\n * If the effect is evaluated again within the specified `timeToLive`, the\n * cached result will be used, avoiding recomputation.\n *\n * After the specified duration has passed, the cache expires, and the effect\n * will be recomputed upon the next evaluation.\n *\n * **When to Use**\n *\n * Use this function when you have an effect that involves costly operations or\n * computations, and you want to avoid repeating them within a short time frame.\n *\n * It's ideal for scenarios where the result of an effect doesn't change\n * frequently and can be reused for a specified duration.\n *\n * By caching the result, you can improve efficiency and reduce unnecessary\n * computations, especially in performance-critical applications.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log(\"expensive task...\")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   const cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* Effect.sleep(\"100 millis\")\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // expensive task...\n * // result 1\n * // result 1\n * // expensive task...\n * // result 2\n * ```\n *\n * @see {@link cached} for a similar function that caches the result\n * indefinitely.\n * @see {@link cachedInvalidateWithTTL} for a similar function that includes an\n * additional effect for manually invalidating the cached value.\n *\n * @since 2.0.0\n * @category Caching\n */\nexport const cachedWithTTL: {\n  /**\n   * Returns an effect that caches its result for a specified `Duration`,\n   * known as \"timeToLive\" (TTL).\n   *\n   * **Details**\n   *\n   * This function is used to cache the result of an effect for a specified amount\n   * of time. This means that the first time the effect is evaluated, its result\n   * is computed and stored.\n   *\n   * If the effect is evaluated again within the specified `timeToLive`, the\n   * cached result will be used, avoiding recomputation.\n   *\n   * After the specified duration has passed, the cache expires, and the effect\n   * will be recomputed upon the next evaluation.\n   *\n   * **When to Use**\n   *\n   * Use this function when you have an effect that involves costly operations or\n   * computations, and you want to avoid repeating them within a short time frame.\n   *\n   * It's ideal for scenarios where the result of an effect doesn't change\n   * frequently and can be reused for a specified duration.\n   *\n   * By caching the result, you can improve efficiency and reduce unnecessary\n   * computations, especially in performance-critical applications.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * let i = 1\n   * const expensiveTask = Effect.promise<string>(() => {\n   *   console.log(\"expensive task...\")\n   *   return new Promise((resolve) => {\n   *     setTimeout(() => {\n   *       resolve(`result ${i++}`)\n   *     }, 100)\n   *   })\n   * })\n   *\n   * const program = Effect.gen(function* () {\n   *   const cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* Effect.sleep(\"100 millis\")\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // expensive task...\n   * // result 1\n   * // result 1\n   * // expensive task...\n   * // result 2\n   * ```\n   *\n   * @see {@link cached} for a similar function that caches the result\n   * indefinitely.\n   * @see {@link cachedInvalidateWithTTL} for a similar function that includes an\n   * additional effect for manually invalidating the cached value.\n   *\n   * @since 2.0.0\n   * @category Caching\n   */\n  (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>\n  /**\n   * Returns an effect that caches its result for a specified `Duration`,\n   * known as \"timeToLive\" (TTL).\n   *\n   * **Details**\n   *\n   * This function is used to cache the result of an effect for a specified amount\n   * of time. This means that the first time the effect is evaluated, its result\n   * is computed and stored.\n   *\n   * If the effect is evaluated again within the specified `timeToLive`, the\n   * cached result will be used, avoiding recomputation.\n   *\n   * After the specified duration has passed, the cache expires, and the effect\n   * will be recomputed upon the next evaluation.\n   *\n   * **When to Use**\n   *\n   * Use this function when you have an effect that involves costly operations or\n   * computations, and you want to avoid repeating them within a short time frame.\n   *\n   * It's ideal for scenarios where the result of an effect doesn't change\n   * frequently and can be reused for a specified duration.\n   *\n   * By caching the result, you can improve efficiency and reduce unnecessary\n   * computations, especially in performance-critical applications.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * let i = 1\n   * const expensiveTask = Effect.promise<string>(() => {\n   *   console.log(\"expensive task...\")\n   *   return new Promise((resolve) => {\n   *     setTimeout(() => {\n   *       resolve(`result ${i++}`)\n   *     }, 100)\n   *   })\n   * })\n   *\n   * const program = Effect.gen(function* () {\n   *   const cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* Effect.sleep(\"100 millis\")\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // expensive task...\n   * // result 1\n   * // result 1\n   * // expensive task...\n   * // result 2\n   * ```\n   *\n   * @see {@link cached} for a similar function that caches the result\n   * indefinitely.\n   * @see {@link cachedInvalidateWithTTL} for a similar function that includes an\n   * additional effect for manually invalidating the cached value.\n   *\n   * @since 2.0.0\n   * @category Caching\n   */\n  <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>\n} = circular.cached\n\n/**\n * Caches an effect's result for a specified duration and allows manual\n * invalidation before expiration.\n *\n * **Details**\n *\n * This function behaves similarly to {@link cachedWithTTL} by caching the\n * result of an effect for a specified period of time. However, it introduces an\n * additional feature: it provides an effect that allows you to manually\n * invalidate the cached result before it naturally expires.\n *\n * This gives you more control over the cache, allowing you to refresh the\n * result when needed, even if the original cache has not yet expired.\n *\n * Once the cache is invalidated, the next time the effect is evaluated, the\n * result will be recomputed, and the cache will be refreshed.\n *\n * **When to Use**\n *\n * Use this function when you have an effect whose result needs to be cached for\n * a certain period, but you also want the option to refresh the cache manually\n * before the expiration time.\n *\n * This is useful when you need to ensure that the cached data remains valid for\n * a certain period but still want to invalidate it if the underlying data\n * changes or if you want to force a recomputation.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log(\"expensive task...\")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n *     expensiveTask,\n *     \"1 hour\"\n *   )\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* invalidate\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // expensive task...\n * // result 1\n * // result 1\n * // expensive task...\n * // result 2\n * ```\n *\n * @see {@link cached} for a similar function that caches the result\n * indefinitely.\n * @see {@link cachedWithTTL} for a similar function that caches the result for\n * a specified duration but does not include an effect for manual invalidation.\n *\n * @since 2.0.0\n * @category Caching\n */\nexport const cachedInvalidateWithTTL: {\n  /**\n   * Caches an effect's result for a specified duration and allows manual\n   * invalidation before expiration.\n   *\n   * **Details**\n   *\n   * This function behaves similarly to {@link cachedWithTTL} by caching the\n   * result of an effect for a specified period of time. However, it introduces an\n   * additional feature: it provides an effect that allows you to manually\n   * invalidate the cached result before it naturally expires.\n   *\n   * This gives you more control over the cache, allowing you to refresh the\n   * result when needed, even if the original cache has not yet expired.\n   *\n   * Once the cache is invalidated, the next time the effect is evaluated, the\n   * result will be recomputed, and the cache will be refreshed.\n   *\n   * **When to Use**\n   *\n   * Use this function when you have an effect whose result needs to be cached for\n   * a certain period, but you also want the option to refresh the cache manually\n   * before the expiration time.\n   *\n   * This is useful when you need to ensure that the cached data remains valid for\n   * a certain period but still want to invalidate it if the underlying data\n   * changes or if you want to force a recomputation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * let i = 1\n   * const expensiveTask = Effect.promise<string>(() => {\n   *   console.log(\"expensive task...\")\n   *   return new Promise((resolve) => {\n   *     setTimeout(() => {\n   *       resolve(`result ${i++}`)\n   *     }, 100)\n   *   })\n   * })\n   *\n   * const program = Effect.gen(function* () {\n   *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n   *     expensiveTask,\n   *     \"1 hour\"\n   *   )\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* invalidate\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // expensive task...\n   * // result 1\n   * // result 1\n   * // expensive task...\n   * // result 2\n   * ```\n   *\n   * @see {@link cached} for a similar function that caches the result\n   * indefinitely.\n   * @see {@link cachedWithTTL} for a similar function that caches the result for\n   * a specified duration but does not include an effect for manual invalidation.\n   *\n   * @since 2.0.0\n   * @category Caching\n   */\n  (timeToLive: Duration.DurationInput): <A, E, R>(\n    self: Effect<A, E, R>\n  ) => Effect<[Effect<A, E>, Effect<void>], never, R>\n  /**\n   * Caches an effect's result for a specified duration and allows manual\n   * invalidation before expiration.\n   *\n   * **Details**\n   *\n   * This function behaves similarly to {@link cachedWithTTL} by caching the\n   * result of an effect for a specified period of time. However, it introduces an\n   * additional feature: it provides an effect that allows you to manually\n   * invalidate the cached result before it naturally expires.\n   *\n   * This gives you more control over the cache, allowing you to refresh the\n   * result when needed, even if the original cache has not yet expired.\n   *\n   * Once the cache is invalidated, the next time the effect is evaluated, the\n   * result will be recomputed, and the cache will be refreshed.\n   *\n   * **When to Use**\n   *\n   * Use this function when you have an effect whose result needs to be cached for\n   * a certain period, but you also want the option to refresh the cache manually\n   * before the expiration time.\n   *\n   * This is useful when you need to ensure that the cached data remains valid for\n   * a certain period but still want to invalidate it if the underlying data\n   * changes or if you want to force a recomputation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * let i = 1\n   * const expensiveTask = Effect.promise<string>(() => {\n   *   console.log(\"expensive task...\")\n   *   return new Promise((resolve) => {\n   *     setTimeout(() => {\n   *       resolve(`result ${i++}`)\n   *     }, 100)\n   *   })\n   * })\n   *\n   * const program = Effect.gen(function* () {\n   *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n   *     expensiveTask,\n   *     \"1 hour\"\n   *   )\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   *   yield* invalidate\n   *   yield* cached.pipe(Effect.andThen(Console.log))\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // expensive task...\n   * // result 1\n   * // result 1\n   * // expensive task...\n   * // result 2\n   * ```\n   *\n   * @see {@link cached} for a similar function that caches the result\n   * indefinitely.\n   * @see {@link cachedWithTTL} for a similar function that caches the result for\n   * a specified duration but does not include an effect for manual invalidation.\n   *\n   * @since 2.0.0\n   * @category Caching\n   */\n  <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<[Effect<A, E>, Effect<void>], never, R>\n} = circular.cachedInvalidateWithTTL\n\n/**\n * Returns an effect that lazily computes a result and caches it for subsequent\n * evaluations.\n *\n * **Details**\n *\n * This function wraps an effect and ensures that its result is computed only\n * once. Once the result is computed, it is cached, meaning that subsequent\n * evaluations of the same effect will return the cached result without\n * re-executing the logic.\n *\n * **When to Use**\n *\n * Use this function when you have an expensive or time-consuming operation that\n * you want to avoid repeating. The first evaluation will compute the result,\n * and all following evaluations will immediately return the cached value,\n * improving performance and reducing unnecessary work.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log(\"expensive task...\")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   console.log(\"non-cached version:\")\n *   yield* expensiveTask.pipe(Effect.andThen(Console.log))\n *   yield* expensiveTask.pipe(Effect.andThen(Console.log))\n *   console.log(\"cached version:\")\n *   const cached = yield* Effect.cached(expensiveTask)\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // non-cached version:\n * // expensive task...\n * // result 1\n * // expensive task...\n * // result 2\n * // cached version:\n * // expensive task...\n * // result 3\n * // result 3\n * ```\n *\n * @see {@link cachedWithTTL} for a similar function that includes a\n * time-to-live duration for the cached value.\n * @see {@link cachedInvalidateWithTTL} for a similar function that includes an\n * additional effect for manually invalidating the cached value.\n *\n * @since 2.0.0\n * @category Caching\n */\nexport const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>> = effect.memoize\n\n/**\n * Returns a memoized version of a function with effects, reusing results for\n * the same inputs.\n *\n * **Details**\n *\n * This function creates a memoized version of a given function that performs an\n * effect. Memoization ensures that once a result is computed for a specific\n * input, it is stored and reused for subsequent calls with the same input,\n * reducing the need to recompute the result.\n *\n * The function can optionally take an `Equivalence` parameter to\n * determine how inputs are compared for caching purposes.\n *\n * **When to Use**\n *\n * Use this function when you have a function that performs an effect and you\n * want to avoid recomputing the result for the same input multiple times.\n *\n * It's ideal for functions that produce deterministic results based on their\n * inputs, and you want to improve performance by caching the output.\n *\n * This is particularly useful in scenarios where the function involves\n * expensive calculations or operations that should be avoided after the first\n * execution with the same parameters.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * const program = Effect.gen(function* () {\n *   const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n *   console.log(\"non-memoized version:\")\n *   console.log(yield* randomNumber(10))\n *   console.log(yield* randomNumber(10))\n *\n *   console.log(\"memoized version:\")\n *   const memoized = yield* Effect.cachedFunction(randomNumber)\n *   console.log(yield* memoized(10))\n *   console.log(yield* memoized(10))\n * })\n *\n * Effect.runFork(program)\n * // Example Output:\n * // non-memoized version:\n * // 2\n * // 8\n * // memoized version:\n * // 5\n * // 5\n * ```\n *\n * @since 2.0.0\n * @category Caching\n */\nexport const cachedFunction: <A, B, E, R>(\n  f: (a: A) => Effect<B, E, R>,\n  eq?: Equivalence<A>\n) => Effect<(a: A) => Effect<B, E, R>> = circular.cachedFunction\n\n/**\n * Returns an effect that executes only once, regardless of how many times it's\n * called.\n *\n * **Details**\n *\n * This function ensures that a specific effect is executed only a single time,\n * no matter how many times it is invoked. The result of the effect will be\n * cached, and subsequent calls to the effect will immediately return the cached\n * result without re-executing the original logic.\n *\n * **When to Use**\n *\n * Use this function when you need to perform a task only once, regardless of\n * how many times the effect is triggered. It's particularly useful when you\n * have initialization tasks, logging, or other one-time actions that should not\n * be repeated. This can help optimize performance and avoid redundant actions.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const program = Effect.gen(function* () {\n *   const task1 = Console.log(\"task1\")\n *   yield* Effect.repeatN(task1, 2)\n *   const task2 = yield* Effect.once(Console.log(\"task2\"))\n *   yield* Effect.repeatN(task2, 2)\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // task1\n * // task1\n * // task1\n * // task2\n * ```\n *\n * @since 2.0.0\n * @category Caching\n */\nexport const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>> = effect.once\n\n/**\n * Combines multiple effects into one, returning results based on the input\n * structure.\n *\n * **Details**\n *\n * Use this function when you need to run multiple effects and combine their\n * results into a single output. It supports tuples, iterables, structs, and\n * records, making it flexible for different input types.\n *\n * For instance, if the input is a tuple:\n *\n * ```ts skip-type-checking\n * //          a tuple of effects\n * //         \n * Effect.all([effect1, effect2, ...])\n * ```\n *\n * the effects are executed sequentially, and the result is a new effect\n * containing the results as a tuple. The results in the tuple match the order\n * of the effects passed to `Effect.all`.\n *\n * **Concurrency**\n *\n * You can control the execution order (e.g., sequential vs. concurrent) using\n * the `concurrency` option.\n *\n * **Short-Circuiting Behavior**\n *\n * This function stops execution on the first error it encounters, this is\n * called \"short-circuiting\". If any effect in the collection fails, the\n * remaining effects will not run, and the error will be propagated. To change\n * this behavior, you can use the `mode` option, which allows all effects to run\n * and collect results as `Either` or `Option`.\n *\n * **The `mode` option**\n *\n * The `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\n * ensure all effects run, even if some fail. Instead of stopping on the first\n * failure, this mode collects both successes and failures, returning an array\n * of `Either` instances where each result is either a `Right` (success) or a\n * `Left` (failure).\n *\n * Similarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\n * success or failure. Each effect returns `None` for success and `Some` with\n * the error for failure.\n *\n * **Example** (Combining Effects in Tuples)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const tupleOfEffects = [\n *   Effect.succeed(42).pipe(Effect.tap(Console.log)),\n *   Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n * ] as const\n *\n * //       Effect<[number, string], never, never>\n * //      \n * const resultsAsTuple = Effect.all(tupleOfEffects)\n *\n * Effect.runPromise(resultsAsTuple).then(console.log)\n * // Output:\n * // 42\n * // Hello\n * // [ 42, 'Hello' ]\n * ```\n *\n * **Example** (Combining Effects in Iterables)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n *   (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n * )\n *\n * //       Effect<number[], never, never>\n * //      \n * const resultsAsArray = Effect.all(iterableOfEffects)\n *\n * Effect.runPromise(resultsAsArray).then(console.log)\n * // Output:\n * // 1\n * // 2\n * // 3\n * // [ 1, 2, 3 ]\n * ```\n *\n * **Example** (Combining Effects in Structs)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const structOfEffects = {\n *   a: Effect.succeed(42).pipe(Effect.tap(Console.log)),\n *   b: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n * }\n *\n * //       Effect<{ a: number; b: string; }, never, never>\n * //      \n * const resultsAsStruct = Effect.all(structOfEffects)\n *\n * Effect.runPromise(resultsAsStruct).then(console.log)\n * // Output:\n * // 42\n * // Hello\n * // { a: 42, b: 'Hello' }\n * ```\n *\n * **Example** (Combining Effects in Records)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const recordOfEffects: Record<string, Effect.Effect<number>> = {\n *   key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n *   key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n * }\n *\n * //       Effect<{ [x: string]: number; }, never, never>\n * //      \n * const resultsAsRecord = Effect.all(recordOfEffects)\n *\n * Effect.runPromise(resultsAsRecord).then(console.log)\n * // Output:\n * // 1\n * // 2\n * // { key1: 1, key2: 2 }\n * ```\n *\n * **Example** (Short-Circuiting Behavior)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const program = Effect.all([\n *   Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n *   Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n *   // Won't execute due to earlier failure\n *   Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n * ])\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Task1\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n * // }\n * ```\n *\n * **Example** (Collecting Results with `mode: \"either\"`)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const effects = [\n *   Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n *   Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n *   Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n * ]\n *\n * const program = Effect.all(effects, { mode: \"either\" })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Task1\n * // Task3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Success',\n * //   value: [\n * //     { _id: 'Either', _tag: 'Right', right: 'Task1' },\n * //     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n * //     { _id: 'Either', _tag: 'Right', right: 'Task3' }\n * //   ]\n * // }\n * ```\n *\n * **Example** (Collecting Results with `mode: \"validate\"`)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const effects = [\n *   Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n *   Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n *   Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n * ]\n *\n * const program = Effect.all(effects, { mode: \"validate\" })\n *\n * Effect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n * // Output:\n * // Task1\n * // Task3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: [\n * //       { _id: 'Option', _tag: 'None' },\n * //       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n * //       { _id: 'Option', _tag: 'None' }\n * //     ]\n * //   }\n * // }\n * ```\n *\n * @see {@link forEach} for iterating over elements and applying an effect.\n * @see {@link allWith} for a data-last version of this function.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const all: <\n  const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>,\n  O extends NoExcessProperties<{\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }, O>\n>(arg: Arg, options?: O) => All.Return<Arg, O> = fiberRuntime.all\n\n/**\n * A data-last version of {@link all}, designed for use in pipelines.\n *\n * **When to Use**\n *\n * This function enables you to combine multiple effects and customize execution\n * options such as concurrency levels. This version is useful in functional\n * pipelines where you first define your data and then apply operations to it.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, pipe } from \"effect\"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Effect.log(\"task1 done\"))\n * )\n *\n * const task2 = Effect.succeed(\"hello\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Effect.log(\"task2 done\"))\n * )\n *\n * const program = pipe(\n *   [task1, task2],\n *   // Run both effects concurrently using the concurrent option\n *   Effect.allWith({ concurrency: 2 })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message=\"task2 done\"\n * // timestamp=... level=INFO fiber=#2 message=\"task1 done\"\n * // [ 1, 'hello' ]\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const allWith: <\n  O extends NoExcessProperties<{\n    readonly concurrency?: Concurrency | undefined\n    readonly batching?: boolean | \"inherit\" | undefined\n    readonly discard?: boolean | undefined\n    readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n    readonly concurrentFinalizers?: boolean | undefined\n  }, O>\n>(\n  options?: O\n) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(\n  arg: Arg\n) => All.Return<Arg, O> = fiberRuntime.allWith\n\n/**\n * @since 2.0.0\n */\nexport declare namespace All {\n  /**\n   * @since 2.0.0\n   */\n  export type EffectAny = Effect<any, any, any>\n\n  /**\n   * @since 2.0.0\n   */\n  export type ReturnIterable<T extends Iterable<EffectAny>, Discard extends boolean, Mode> = [T] extends\n    [Iterable<Effect.Variance<infer R0, infer L0, infer R>>] ? Effect<\n      Discard extends true ? void : Mode extends \"either\" ? Array<Either.Either<R0, L0>> : Array<R0>,\n      Mode extends \"either\" ? never\n        : Mode extends \"validate\" ? Array<Option.Option<L0>>\n        : L0,\n      R\n    >\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type ReturnTuple<T extends ReadonlyArray<unknown>, Discard extends boolean, Mode> = Effect<\n    Discard extends true ? void\n      : T[number] extends never ? []\n      : Mode extends \"either\" ? {\n          -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ?\n            Either.Either<_A, _E>\n            : never\n        }\n      : { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? _A : never },\n    Mode extends \"either\" ? never\n      : T[number] extends never ? never\n      : Mode extends \"validate\" ? {\n          -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? Option.Option<_E>\n            : never\n        }\n      : [T[number]] extends [{ [EffectTypeId]: { _E: (_: never) => infer E } }] ? E\n      : never,\n    T[number] extends never ? never\n      : [T[number]] extends [{ [EffectTypeId]: { _R: (_: never) => infer R } }] ? R\n      : never\n  > extends infer X ? X : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type ReturnObject<T, Discard extends boolean, Mode> = [T] extends [{ [K: string]: EffectAny }] ? Effect<\n      Discard extends true ? void\n        : Mode extends \"either\" ? {\n            -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ?\n              Either.Either<_A, _E>\n              : never\n          }\n        : { -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? _A : never },\n      Mode extends \"either\" ? never\n        : keyof T extends never ? never\n        : Mode extends \"validate\" ? {\n            -readonly [K in keyof T]: [T[K]] extends [Effect.Variance<infer _A, infer _E, infer _R>] ? Option.Option<_E>\n              : never\n          }\n        : [T[keyof T]] extends [{ [EffectTypeId]: { _E: (_: never) => infer E } }] ? E\n        : never,\n      keyof T extends never ? never\n        : [T[keyof T]] extends [{ [EffectTypeId]: { _R: (_: never) => infer R } }] ? R\n        : never\n    >\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type IsDiscard<A> = [Extract<A, { readonly discard: true }>] extends [never] ? false : true\n\n  /**\n   * @since 2.0.0\n   */\n  export type ExtractMode<A> = [A] extends [{ mode: infer M }] ? M : \"default\"\n\n  /**\n   * @since 2.0.0\n   */\n  export type Return<\n    Arg extends Iterable<EffectAny> | Record<string, EffectAny>,\n    O extends NoExcessProperties<{\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: boolean | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }, O>\n  > = [Arg] extends [ReadonlyArray<EffectAny>] ? ReturnTuple<Arg, IsDiscard<O>, ExtractMode<O>>\n    : [Arg] extends [Iterable<EffectAny>] ? ReturnIterable<Arg, IsDiscard<O>, ExtractMode<O>>\n    : [Arg] extends [Record<string, EffectAny>] ? ReturnObject<Arg, IsDiscard<O>, ExtractMode<O>>\n    : never\n}\n\n/**\n * Evaluates and runs each effect in the iterable, collecting only the\n * successful results while discarding failures.\n *\n * **Details**\n *\n * This function function processes an iterable of effects and runs each one. If\n * an effect is successful, its result is collected; if it fails, the result is\n * discarded. This ensures that only successful outcomes are kept.\n *\n * **Options**\n *\n * The function also allows you to customize how the effects are handled by\n * specifying options such as concurrency, batching, and how finalizers behave.\n * These options provide flexibility in running the effects concurrently or\n * adjusting other execution details.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const tasks = [\n *   Effect.succeed(1),\n *   Effect.fail(\"Error 1\"),\n *   Effect.succeed(2),\n *   Effect.fail(\"Error 2\")\n * ]\n *\n * const program = Effect.gen(function*() {\n *   const successfulResults = yield* Effect.allSuccesses(tasks)\n *   console.log(successfulResults)\n * })\n *\n * Effect.runFork(program)\n * // Output: [1, 2]\n *\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const allSuccesses: <X extends Effect<any, any, any>>(\n  elements: Iterable<X>,\n  options?:\n    | {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n    | undefined\n) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>> = fiberRuntime.allSuccesses\n\n/**\n * Drops elements until the effectful predicate returns `true`.\n *\n * **Details**\n *\n * This function processes a collection of elements and uses an effectful\n * predicate to determine when to stop dropping elements. It drops elements from\n * the beginning of the collection until the predicate returns `true`.\n *\n * The predicate is a function that takes an element and its index in the\n * collection and returns an effect that evaluates to a boolean.\n *\n * Once the predicate returns `true`, the remaining elements of the collection\n * are returned.\n *\n * **Note**: The first element for which the predicate returns `true` is also\n * dropped.\n *\n * **When to Use**\n *\n * This function allows you to conditionally skip over a part of the collection\n * based on some criteria defined in the predicate.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5, 6]\n * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n *\n * const program = Effect.gen(function*() {\n *   const result = yield* Effect.dropUntil(numbers, predicate)\n *   console.log(result)\n * })\n *\n * Effect.runFork(program)\n * // Output: [5, 6]\n * ```\n *\n * @see {@link dropWhile} for a similar function that drops elements while the\n * predicate returns `true`.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const dropUntil: {\n  /**\n   * Drops elements until the effectful predicate returns `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses an effectful\n   * predicate to determine when to stop dropping elements. It drops elements from\n   * the beginning of the collection until the predicate returns `true`.\n   *\n   * The predicate is a function that takes an element and its index in the\n   * collection and returns an effect that evaluates to a boolean.\n   *\n   * Once the predicate returns `true`, the remaining elements of the collection\n   * are returned.\n   *\n   * **Note**: The first element for which the predicate returns `true` is also\n   * dropped.\n   *\n   * **When to Use**\n   *\n   * This function allows you to conditionally skip over a part of the collection\n   * based on some criteria defined in the predicate.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.dropUntil(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [5, 6]\n   * ```\n   *\n   * @see {@link dropWhile} for a similar function that drops elements while the\n   * predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>\n  /**\n   * Drops elements until the effectful predicate returns `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses an effectful\n   * predicate to determine when to stop dropping elements. It drops elements from\n   * the beginning of the collection until the predicate returns `true`.\n   *\n   * The predicate is a function that takes an element and its index in the\n   * collection and returns an effect that evaluates to a boolean.\n   *\n   * Once the predicate returns `true`, the remaining elements of the collection\n   * are returned.\n   *\n   * **Note**: The first element for which the predicate returns `true` is also\n   * dropped.\n   *\n   * **When to Use**\n   *\n   * This function allows you to conditionally skip over a part of the collection\n   * based on some criteria defined in the predicate.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.dropUntil(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [5, 6]\n   * ```\n   *\n   * @see {@link dropWhile} for a similar function that drops elements while the\n   * predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect<boolean, E, R>\n  ): Effect<Array<A>, E, R>\n} = effect.dropUntil\n\n/**\n * Drops elements as long as the predicate returns `true`.\n *\n * **Details**\n *\n * This function processes a collection of elements and uses a predicate to\n * decide whether to drop an element.\n *\n * The predicate is a function that takes an element and its index, and it\n * returns an effect that evaluates to a boolean.\n *\n * As long as the predicate returns `true`, elements will continue to be dropped\n * from the collection.\n *\n * Once the predicate returns `false`, the remaining elements are kept.\n *\n * **When to Use**\n *\n * This function allows you to discard elements from the start of a collection\n * based on a condition, and only keep the rest when the condition no longer\n * holds.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5, 6]\n * const predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n *\n * const program = Effect.gen(function*() {\n *   const result = yield* Effect.dropWhile(numbers, predicate)\n *   console.log(result)\n * })\n *\n * Effect.runFork(program)\n * // Output: [4, 5, 6]\n * ```\n *\n * @see {@link dropUntil} for a similar function that drops elements until the\n * predicate returns `true`.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const dropWhile: {\n  /**\n   * Drops elements as long as the predicate returns `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses a predicate to\n   * decide whether to drop an element.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * As long as the predicate returns `true`, elements will continue to be dropped\n   * from the collection.\n   *\n   * Once the predicate returns `false`, the remaining elements are kept.\n   *\n   * **When to Use**\n   *\n   * This function allows you to discard elements from the start of a collection\n   * based on a condition, and only keep the rest when the condition no longer\n   * holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.dropWhile(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [4, 5, 6]\n   * ```\n   *\n   * @see {@link dropUntil} for a similar function that drops elements until the\n   * predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>\n  /**\n   * Drops elements as long as the predicate returns `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses a predicate to\n   * decide whether to drop an element.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * As long as the predicate returns `true`, elements will continue to be dropped\n   * from the collection.\n   *\n   * Once the predicate returns `false`, the remaining elements are kept.\n   *\n   * **When to Use**\n   *\n   * This function allows you to discard elements from the start of a collection\n   * based on a condition, and only keep the rest when the condition no longer\n   * holds.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.dropWhile(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [4, 5, 6]\n   * ```\n   *\n   * @see {@link dropUntil} for a similar function that drops elements until the\n   * predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect<boolean, E, R>\n  ): Effect<Array<A>, E, R>\n} = effect.dropWhile\n\n/**\n * Takes elements from a collection until the effectful predicate returns\n * `true`.\n *\n * **Details**\n *\n * This function processes a collection of elements and uses an effectful\n * predicate to decide when to stop taking elements. The elements are taken from\n * the beginning of the collection until the predicate returns `true`.\n *\n * The predicate is a function that takes an element and its index in the\n * collection, and returns an effect that resolves to a boolean.\n *\n * Once the predicate returns `true`, the remaining elements of the collection\n * are discarded, and the function stops taking more elements.\n *\n * **Note**: The first element for which the predicate returns `true` is also\n * included in the result.\n *\n * **When to Use**\n *\n * Use this function when you want to conditionally take elements from a\n * collection based on a dynamic condition. For example, you may want to collect\n * numbers from a list until a certain threshold is reached, or gather items\n * until a specific condition is met.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5, 6]\n * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n *\n * const program = Effect.gen(function*() {\n *   const result = yield* Effect.takeUntil(numbers, predicate)\n *   console.log(result)\n * })\n *\n * Effect.runFork(program)\n * // Output: [ 1, 2, 3, 4 ]\n * ```\n *\n * @see {@link takeWhile} for a similar function that takes elements while the\n * predicate returns `true`.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const takeUntil: {\n  /**\n   * Takes elements from a collection until the effectful predicate returns\n   * `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses an effectful\n   * predicate to decide when to stop taking elements. The elements are taken from\n   * the beginning of the collection until the predicate returns `true`.\n   *\n   * The predicate is a function that takes an element and its index in the\n   * collection, and returns an effect that resolves to a boolean.\n   *\n   * Once the predicate returns `true`, the remaining elements of the collection\n   * are discarded, and the function stops taking more elements.\n   *\n   * **Note**: The first element for which the predicate returns `true` is also\n   * included in the result.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to conditionally take elements from a\n   * collection based on a dynamic condition. For example, you may want to collect\n   * numbers from a list until a certain threshold is reached, or gather items\n   * until a specific condition is met.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.takeUntil(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [ 1, 2, 3, 4 ]\n   * ```\n   *\n   * @see {@link takeWhile} for a similar function that takes elements while the\n   * predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>\n  /**\n   * Takes elements from a collection until the effectful predicate returns\n   * `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses an effectful\n   * predicate to decide when to stop taking elements. The elements are taken from\n   * the beginning of the collection until the predicate returns `true`.\n   *\n   * The predicate is a function that takes an element and its index in the\n   * collection, and returns an effect that resolves to a boolean.\n   *\n   * Once the predicate returns `true`, the remaining elements of the collection\n   * are discarded, and the function stops taking more elements.\n   *\n   * **Note**: The first element for which the predicate returns `true` is also\n   * included in the result.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to conditionally take elements from a\n   * collection based on a dynamic condition. For example, you may want to collect\n   * numbers from a list until a certain threshold is reached, or gather items\n   * until a specific condition is met.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.takeUntil(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [ 1, 2, 3, 4 ]\n   * ```\n   *\n   * @see {@link takeWhile} for a similar function that takes elements while the\n   * predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>\n  ): Effect<Array<A>, E, R>\n} = effect.takeUntil\n\n/**\n * Takes elements as long as the predicate returns `true`.\n *\n * **Details**\n *\n * This function processes a collection of elements and uses a predicate to\n * decide whether to take an element.\n *\n * The predicate is a function that takes an element and its index, and it\n * returns an effect that evaluates to a boolean.\n *\n * As long as the predicate returns `true`, elements will continue to be taken\n * from the collection.\n *\n * Once the predicate returns `false`, the remaining elements are discarded.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5, 6]\n * const predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n *\n * const program = Effect.gen(function*() {\n *   const result = yield* Effect.takeWhile(numbers, predicate)\n *   console.log(result)\n * })\n *\n * Effect.runFork(program)\n * // Output: [1, 2, 3]\n * ```\n *\n * @see {@link takeUntil} for a similar function that takes elements until the predicate returns `true`.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const takeWhile: {\n  /**\n   * Takes elements as long as the predicate returns `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses a predicate to\n   * decide whether to take an element.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * As long as the predicate returns `true`, elements will continue to be taken\n   * from the collection.\n   *\n   * Once the predicate returns `false`, the remaining elements are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.takeWhile(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [1, 2, 3]\n   * ```\n   *\n   * @see {@link takeUntil} for a similar function that takes elements until the predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>\n  /**\n   * Takes elements as long as the predicate returns `true`.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and uses a predicate to\n   * decide whether to take an element.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * As long as the predicate returns `true`, elements will continue to be taken\n   * from the collection.\n   *\n   * Once the predicate returns `false`, the remaining elements are discarded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5, 6]\n   * const predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.takeWhile(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [1, 2, 3]\n   * ```\n   *\n   * @see {@link takeUntil} for a similar function that takes elements until the predicate returns `true`.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>\n  ): Effect<Array<A>, E, R>\n} = effect.takeWhile\n\n/**\n * Determines whether all elements of the iterable satisfy the effectful\n * predicate.\n *\n * **Details**\n *\n * This function checks whether every element in a given collection (an\n * iterable) satisfies a condition defined by an effectful predicate.\n *\n * The predicate is a function that takes an element and its index, and it\n * returns an effect that evaluates to a boolean.\n *\n * The function will process each element and return `true` if all elements\n * satisfy the predicate; otherwise, it returns `false`.\n *\n * **When to Use**\n *\n * This function is useful when you need to verify that all items in a\n * collection meet certain criteria, even when the evaluation of each item\n * involves effects, such as asynchronous checks or complex computations.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [2, 4, 6, 8]\n * const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n *\n * const program = Effect.gen(function*() {\n *   const allEven = yield* Effect.every(numbers, predicate)\n *   console.log(allEven)\n * })\n *\n * Effect.runFork(program)\n * // Output: true\n * ```\n *\n * @see {@link exists} for a similar function that returns a boolean indicating\n * whether **any** element satisfies the predicate.\n *\n * @since 2.0.0\n * @category Condition Checking\n */\nexport const every: {\n  /**\n   * Determines whether all elements of the iterable satisfy the effectful\n   * predicate.\n   *\n   * **Details**\n   *\n   * This function checks whether every element in a given collection (an\n   * iterable) satisfies a condition defined by an effectful predicate.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * The function will process each element and return `true` if all elements\n   * satisfy the predicate; otherwise, it returns `false`.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you need to verify that all items in a\n   * collection meet certain criteria, even when the evaluation of each item\n   * involves effects, such as asynchronous checks or complex computations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [2, 4, 6, 8]\n   * const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n   *\n   * const program = Effect.gen(function*() {\n   *   const allEven = yield* Effect.every(numbers, predicate)\n   *   console.log(allEven)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: true\n   * ```\n   *\n   * @see {@link exists} for a similar function that returns a boolean indicating\n   * whether **any** element satisfies the predicate.\n   *\n   * @since 2.0.0\n   * @category Condition Checking\n   */\n  <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>\n  /**\n   * Determines whether all elements of the iterable satisfy the effectful\n   * predicate.\n   *\n   * **Details**\n   *\n   * This function checks whether every element in a given collection (an\n   * iterable) satisfies a condition defined by an effectful predicate.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * The function will process each element and return `true` if all elements\n   * satisfy the predicate; otherwise, it returns `false`.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you need to verify that all items in a\n   * collection meet certain criteria, even when the evaluation of each item\n   * involves effects, such as asynchronous checks or complex computations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [2, 4, 6, 8]\n   * const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n   *\n   * const program = Effect.gen(function*() {\n   *   const allEven = yield* Effect.every(numbers, predicate)\n   *   console.log(allEven)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: true\n   * ```\n   *\n   * @see {@link exists} for a similar function that returns a boolean indicating\n   * whether **any** element satisfies the predicate.\n   *\n   * @since 2.0.0\n   * @category Condition Checking\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect<boolean, E, R>\n  ): Effect<boolean, E, R>\n} = effect.every\n\n/**\n * Determines whether any element of the iterable satisfies the effectual\n * predicate.\n *\n * **Details**\n *\n * This function checks whether any element in a given collection (an iterable)\n * satisfies a condition defined by an effectful predicate.\n *\n * The predicate is a function that takes an element and its index, and it\n * returns an effect that evaluates to a boolean.\n *\n * The function will process each element, and if any element satisfies the\n * predicate (returns `true`), the function will immediately return `true`.\n *\n * If none of the elements satisfy the condition, it will return `false`.\n *\n * **When to Use**\n *\n * This function allows you to quickly check for a condition in a collection\n * without having to manually iterate over it.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4]\n * const predicate = (n: number, i: number) => Effect.succeed(n > 2)\n *\n * const program = Effect.gen(function*() {\n *   const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n *   console.log(hasLargeNumber)\n * })\n *\n * Effect.runFork(program)\n * // Output: true\n * ```\n *\n * @see {@link every} for a similar function that checks if **all** elements\n * satisfy the predicate.\n *\n * @since 2.0.0\n * @category Condition Checking\n */\nexport const exists: {\n  /**\n   * Determines whether any element of the iterable satisfies the effectual\n   * predicate.\n   *\n   * **Details**\n   *\n   * This function checks whether any element in a given collection (an iterable)\n   * satisfies a condition defined by an effectful predicate.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * The function will process each element, and if any element satisfies the\n   * predicate (returns `true`), the function will immediately return `true`.\n   *\n   * If none of the elements satisfy the condition, it will return `false`.\n   *\n   * **When to Use**\n   *\n   * This function allows you to quickly check for a condition in a collection\n   * without having to manually iterate over it.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 2)\n   *\n   * const program = Effect.gen(function*() {\n   *   const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n   *   console.log(hasLargeNumber)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: true\n   * ```\n   *\n   * @see {@link every} for a similar function that checks if **all** elements\n   * satisfy the predicate.\n   *\n   * @since 2.0.0\n   * @category Condition Checking\n   */\n  <A, E, R>(\n    predicate: (a: A, i: number) => Effect<boolean, E, R>,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): (elements: Iterable<A>) => Effect<boolean, E, R>\n  /**\n   * Determines whether any element of the iterable satisfies the effectual\n   * predicate.\n   *\n   * **Details**\n   *\n   * This function checks whether any element in a given collection (an iterable)\n   * satisfies a condition defined by an effectful predicate.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * The function will process each element, and if any element satisfies the\n   * predicate (returns `true`), the function will immediately return `true`.\n   *\n   * If none of the elements satisfy the condition, it will return `false`.\n   *\n   * **When to Use**\n   *\n   * This function allows you to quickly check for a condition in a collection\n   * without having to manually iterate over it.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 2)\n   *\n   * const program = Effect.gen(function*() {\n   *   const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n   *   console.log(hasLargeNumber)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: true\n   * ```\n   *\n   * @see {@link every} for a similar function that checks if **all** elements\n   * satisfy the predicate.\n   *\n   * @since 2.0.0\n   * @category Condition Checking\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect<boolean, E, R>,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<boolean, E, R>\n} = fiberRuntime.exists\n\n/**\n * Filters an iterable using the specified effectful predicate.\n *\n * **Details**\n *\n * This function filters a collection (an iterable) by applying an effectful\n * predicate.\n *\n * The predicate is a function that takes an element and its index, and it\n * returns an effect that evaluates to a boolean.\n *\n * The function processes each element in the collection and keeps only those\n * that satisfy the condition defined by the predicate.\n *\n * **Options**\n *\n * You can also adjust the behavior with options such as concurrency, batching,\n * or whether to negate the condition.\n *\n * **When to Use**\n *\n * This function allows you to selectively keep or remove elements based on a\n * condition that may involve asynchronous or side-effect-causing operations.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n *\n * const program = Effect.gen(function*() {\n *   const result = yield* Effect.filter(numbers, predicate)\n *   console.log(result)\n * })\n *\n * Effect.runFork(program)\n * // Output: [2, 4]\n * ```\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filter: {\n  /**\n   * Filters an iterable using the specified effectful predicate.\n   *\n   * **Details**\n   *\n   * This function filters a collection (an iterable) by applying an effectful\n   * predicate.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * The function processes each element in the collection and keeps only those\n   * that satisfy the condition defined by the predicate.\n   *\n   * **Options**\n   *\n   * You can also adjust the behavior with options such as concurrency, batching,\n   * or whether to negate the condition.\n   *\n   * **When to Use**\n   *\n   * This function allows you to selectively keep or remove elements based on a\n   * condition that may involve asynchronous or side-effect-causing operations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.filter(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [2, 4]\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R>(\n    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly negate?: boolean | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): (elements: Iterable<A>) => Effect<Array<A>, E, R>\n  /**\n   * Filters an iterable using the specified effectful predicate.\n   *\n   * **Details**\n   *\n   * This function filters a collection (an iterable) by applying an effectful\n   * predicate.\n   *\n   * The predicate is a function that takes an element and its index, and it\n   * returns an effect that evaluates to a boolean.\n   *\n   * The function processes each element in the collection and keeps only those\n   * that satisfy the condition defined by the predicate.\n   *\n   * **Options**\n   *\n   * You can also adjust the behavior with options such as concurrency, batching,\n   * or whether to negate the condition.\n   *\n   * **When to Use**\n   *\n   * This function allows you to selectively keep or remove elements based on a\n   * condition that may involve asynchronous or side-effect-causing operations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.filter(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: [2, 4]\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly negate?: boolean | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): Effect<Array<A>, E, R>\n} = fiberRuntime.filter\n\n/**\n * Filters and maps elements sequentially in one operation.\n *\n * This function processes each element one by one. It applies a function that\n * returns an `Option` to each element. If the function returns `Some`, the\n * element is kept; if it returns `None`, the element is removed. The operation\n * is done sequentially for each element.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect, Option } from \"effect\"\n *\n * const task = (n: number) =>\n *   Effect.succeed(n).pipe(\n *     Effect.delay(1000 - (n * 100)),\n *     Effect.tap(Console.log(`task${n} done`))\n *   )\n *\n * const program = Effect.filterMap(\n *   [task(1), task(2), task(3), task(4)],\n *   (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // task1 done\n * // task2 done\n * // task3 done\n * // task4 done\n * // [ 2, 4 ]\n * ```\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filterMap: {\n  /**\n   * Filters and maps elements sequentially in one operation.\n   *\n   * This function processes each element one by one. It applies a function that\n   * returns an `Option` to each element. If the function returns `Some`, the\n   * element is kept; if it returns `None`, the element is removed. The operation\n   * is done sequentially for each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect, Option } from \"effect\"\n   *\n   * const task = (n: number) =>\n   *   Effect.succeed(n).pipe(\n   *     Effect.delay(1000 - (n * 100)),\n   *     Effect.tap(Console.log(`task${n} done`))\n   *   )\n   *\n   * const program = Effect.filterMap(\n   *   [task(1), task(2), task(3), task(4)],\n   *   (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // task1 done\n   * // task2 done\n   * // task3 done\n   * // task4 done\n   * // [ 2, 4 ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option.Option<B>): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>\n  /**\n   * Filters and maps elements sequentially in one operation.\n   *\n   * This function processes each element one by one. It applies a function that\n   * returns an `Option` to each element. If the function returns `Some`, the\n   * element is kept; if it returns `None`, the element is removed. The operation\n   * is done sequentially for each element.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect, Option } from \"effect\"\n   *\n   * const task = (n: number) =>\n   *   Effect.succeed(n).pipe(\n   *     Effect.delay(1000 - (n * 100)),\n   *     Effect.tap(Console.log(`task${n} done`))\n   *   )\n   *\n   * const program = Effect.filterMap(\n   *   [task(1), task(2), task(3), task(4)],\n   *   (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // task1 done\n   * // task2 done\n   * // task3 done\n   * // task4 done\n   * // [ 2, 4 ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option.Option<B>): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>\n} = effect.filterMap\n\n/**\n * Returns the first element that satisfies the effectful predicate.\n *\n * **Details**\n *\n * This function processes a collection of elements and applies an effectful\n * predicate to each element.\n *\n * The predicate is a function that takes an element and its index in the\n * collection, and it returns an effect that evaluates to a boolean.\n *\n * The function stops as soon as it finds the first element for which the\n * predicate returns `true` and returns that element wrapped in an `Option`.\n *\n * If no element satisfies the predicate, the result will be `None`.\n *\n * **When to Use**\n *\n * This function allows you to efficiently find an element that meets a specific\n * condition, even when the evaluation involves effects like asynchronous\n * operations or side effects.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [1, 2, 3, 4, 5]\n * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n *\n * const program = Effect.gen(function*() {\n *   const result = yield* Effect.findFirst(numbers, predicate)\n *   console.log(result)\n * })\n *\n * Effect.runFork(program)\n * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const findFirst: {\n  /**\n   * Returns the first element that satisfies the effectful predicate.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and applies an effectful\n   * predicate to each element.\n   *\n   * The predicate is a function that takes an element and its index in the\n   * collection, and it returns an effect that evaluates to a boolean.\n   *\n   * The function stops as soon as it finds the first element for which the\n   * predicate returns `true` and returns that element wrapped in an `Option`.\n   *\n   * If no element satisfies the predicate, the result will be `None`.\n   *\n   * **When to Use**\n   *\n   * This function allows you to efficiently find an element that meets a specific\n   * condition, even when the evaluation involves effects like asynchronous\n   * operations or side effects.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.findFirst(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>\n  /**\n   * Returns the first element that satisfies the effectful predicate.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and applies an effectful\n   * predicate to each element.\n   *\n   * The predicate is a function that takes an element and its index in the\n   * collection, and it returns an effect that evaluates to a boolean.\n   *\n   * The function stops as soon as it finds the first element for which the\n   * predicate returns `true` and returns that element wrapped in an `Option`.\n   *\n   * If no element satisfies the predicate, the result will be `None`.\n   *\n   * **When to Use**\n   *\n   * This function allows you to efficiently find an element that meets a specific\n   * condition, even when the evaluation involves effects like asynchronous\n   * operations or side effects.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [1, 2, 3, 4, 5]\n   * const predicate = (n: number, i: number) => Effect.succeed(n > 3)\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.findFirst(numbers, predicate)\n   *   console.log(result)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: { _id: 'Option', _tag: 'Some', value: 4 }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>\n  ): Effect<Option.Option<A>, E, R>\n} = effect.findFirst\n\n/**\n * Executes an effectful operation for each element in an `Iterable`.\n *\n * **Details**\n *\n * This function applies a provided operation to each element in the iterable,\n * producing a new effect that returns an array of results.\n *\n * If any effect fails, the iteration stops immediately (short-circuiting), and\n * the error is propagated.\n *\n * **Concurrency**\n *\n * The `concurrency` option controls how many operations are performed\n * concurrently. By default, the operations are performed sequentially.\n *\n * **Discarding Results**\n *\n * If the `discard` option is set to `true`, the intermediate results are not\n * collected, and the final result of the operation is `void`.\n *\n * **Example** (Applying Effects to Iterable Elements)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n *   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n * )\n *\n * Effect.runPromise(result).then(console.log)\n * // Output:\n * // Currently at index 0\n * // Currently at index 1\n * // Currently at index 2\n * // Currently at index 3\n * // Currently at index 4\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n *\n * **Example** (Discarding Results)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * // Apply effects but discard the results\n * const result = Effect.forEach(\n *   [1, 2, 3, 4, 5],\n *   (n, index) =>\n *     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n *   { discard: true }\n * )\n *\n * Effect.runPromise(result).then(console.log)\n * // Output:\n * // Currently at index 0\n * // Currently at index 1\n * // Currently at index 2\n * // Currently at index 3\n * // Currently at index 4\n * // undefined\n * ```\n *\n * @see {@link all} for combining multiple effects into one.\n *\n * @since 2.0.0\n * @category Looping\n */\nexport const forEach: {\n  /**\n   * Executes an effectful operation for each element in an `Iterable`.\n   *\n   * **Details**\n   *\n   * This function applies a provided operation to each element in the iterable,\n   * producing a new effect that returns an array of results.\n   *\n   * If any effect fails, the iteration stops immediately (short-circuiting), and\n   * the error is propagated.\n   *\n   * **Concurrency**\n   *\n   * The `concurrency` option controls how many operations are performed\n   * concurrently. By default, the operations are performed sequentially.\n   *\n   * **Discarding Results**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * **Example** (Applying Effects to Iterable Elements)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n   *   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // [ 2, 4, 6, 8, 10 ]\n   * ```\n   *\n   * **Example** (Discarding Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Apply effects but discard the results\n   * const result = Effect.forEach(\n   *   [1, 2, 3, 4, 5],\n   *   (n, index) =>\n   *     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n   *   { discard: true }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // undefined\n   * ```\n   *\n   * @see {@link all} for combining multiple effects into one.\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <B, E, R, S extends Iterable<any>>(\n    f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): (\n    self: S\n  ) => Effect<RA.ReadonlyArray.With<S, B>, E, R>\n  /**\n   * Executes an effectful operation for each element in an `Iterable`.\n   *\n   * **Details**\n   *\n   * This function applies a provided operation to each element in the iterable,\n   * producing a new effect that returns an array of results.\n   *\n   * If any effect fails, the iteration stops immediately (short-circuiting), and\n   * the error is propagated.\n   *\n   * **Concurrency**\n   *\n   * The `concurrency` option controls how many operations are performed\n   * concurrently. By default, the operations are performed sequentially.\n   *\n   * **Discarding Results**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * **Example** (Applying Effects to Iterable Elements)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n   *   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // [ 2, 4, 6, 8, 10 ]\n   * ```\n   *\n   * **Example** (Discarding Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Apply effects but discard the results\n   * const result = Effect.forEach(\n   *   [1, 2, 3, 4, 5],\n   *   (n, index) =>\n   *     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n   *   { discard: true }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // undefined\n   * ```\n   *\n   * @see {@link all} for combining multiple effects into one.\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): (self: Iterable<A>) => Effect<void, E, R>\n  /**\n   * Executes an effectful operation for each element in an `Iterable`.\n   *\n   * **Details**\n   *\n   * This function applies a provided operation to each element in the iterable,\n   * producing a new effect that returns an array of results.\n   *\n   * If any effect fails, the iteration stops immediately (short-circuiting), and\n   * the error is propagated.\n   *\n   * **Concurrency**\n   *\n   * The `concurrency` option controls how many operations are performed\n   * concurrently. By default, the operations are performed sequentially.\n   *\n   * **Discarding Results**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * **Example** (Applying Effects to Iterable Elements)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n   *   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // [ 2, 4, 6, 8, 10 ]\n   * ```\n   *\n   * **Example** (Discarding Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Apply effects but discard the results\n   * const result = Effect.forEach(\n   *   [1, 2, 3, 4, 5],\n   *   (n, index) =>\n   *     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n   *   { discard: true }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // undefined\n   * ```\n   *\n   * @see {@link all} for combining multiple effects into one.\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <B, E, R, S extends Iterable<any>>(\n    self: S,\n    f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): Effect<RA.ReadonlyArray.With<S, B>, E, R>\n  /**\n   * Executes an effectful operation for each element in an `Iterable`.\n   *\n   * **Details**\n   *\n   * This function applies a provided operation to each element in the iterable,\n   * producing a new effect that returns an array of results.\n   *\n   * If any effect fails, the iteration stops immediately (short-circuiting), and\n   * the error is propagated.\n   *\n   * **Concurrency**\n   *\n   * The `concurrency` option controls how many operations are performed\n   * concurrently. By default, the operations are performed sequentially.\n   *\n   * **Discarding Results**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * **Example** (Applying Effects to Iterable Elements)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n   *   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // [ 2, 4, 6, 8, 10 ]\n   * ```\n   *\n   * **Example** (Discarding Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Apply effects but discard the results\n   * const result = Effect.forEach(\n   *   [1, 2, 3, 4, 5],\n   *   (n, index) =>\n   *     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n   *   { discard: true }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at index 0\n   * // Currently at index 1\n   * // Currently at index 2\n   * // Currently at index 3\n   * // Currently at index 4\n   * // undefined\n   * ```\n   *\n   * @see {@link all} for combining multiple effects into one.\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, B, E, R>(\n    self: Iterable<A>,\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect<void, E, R>\n} = fiberRuntime.forEach\n\n/**\n * Returns the first element of the iterable if the collection is non-empty, or\n * fails with the error `NoSuchElementException` if the collection is empty.\n *\n * **When to Use**\n *\n * This function is useful when you need to retrieve the first item from a\n * collection and want to handle the case where the collection might be empty\n * without causing an unhandled exception.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // Simulate an async operation\n * const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay(\"100 millis\"))\n *\n * const program = Effect.gen(function*() {\n *   const firstElement = yield* Effect.head(fetchNumbers)\n *   console.log(firstElement)\n * })\n *\n * Effect.runFork(program)\n * // Output: 1\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R> =\n  effect.head\n\n/**\n * Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n *\n * **Details**\n *\n * This function takes an iterable of effects and combines them into a single\n * effect. It does this by iterating over each effect in the collection and\n * applying a function that accumulates results into a \"zero\" value, which\n * starts with an initial value and is updated with each effect's success.\n *\n * The provided function `f` is called for each element in the iterable,\n * allowing you to specify how to combine the results.\n *\n * **Options**\n *\n * The function also allows you to customize how the effects are handled by\n * specifying options such as concurrency, batching, and how finalizers behave.\n * These options provide flexibility in running the effects concurrently or\n * adjusting other execution details.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\n * const add = (sum: number, value: number, i: number) => sum + value\n * const zero = 0\n *\n * const program = Effect.gen(function*() {\n *   const total = yield* Effect.mergeAll(numbers, zero, add)\n *   console.log(total)\n * })\n *\n * Effect.runFork(program)\n * // Output: 6\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const mergeAll: {\n  /**\n   * Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n   *\n   * **Details**\n   *\n   * This function takes an iterable of effects and combines them into a single\n   * effect. It does this by iterating over each effect in the collection and\n   * applying a function that accumulates results into a \"zero\" value, which\n   * starts with an initial value and is updated with each effect's success.\n   *\n   * The provided function `f` is called for each element in the iterable,\n   * allowing you to specify how to combine the results.\n   *\n   * **Options**\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\n   * const add = (sum: number, value: number, i: number) => sum + value\n   * const zero = 0\n   *\n   * const program = Effect.gen(function*() {\n   *   const total = yield* Effect.mergeAll(numbers, zero, add)\n   *   console.log(total)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: 6\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <Z, Eff extends Effect<any, any, any>>(\n    zero: Z,\n    f: (z: Z, a: Effect.Success<Eff>, i: number) => Z,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>\n  /**\n   * Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n   *\n   * **Details**\n   *\n   * This function takes an iterable of effects and combines them into a single\n   * effect. It does this by iterating over each effect in the collection and\n   * applying a function that accumulates results into a \"zero\" value, which\n   * starts with an initial value and is updated with each effect's success.\n   *\n   * The provided function `f` is called for each element in the iterable,\n   * allowing you to specify how to combine the results.\n   *\n   * **Options**\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\n   * const add = (sum: number, value: number, i: number) => sum + value\n   * const zero = 0\n   *\n   * const program = Effect.gen(function*() {\n   *   const total = yield* Effect.mergeAll(numbers, zero, add)\n   *   console.log(total)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: 6\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <Eff extends Effect<any, any, any>, Z>(\n    elements: Iterable<Eff>,\n    zero: Z,\n    f: (z: Z, a: Effect.Success<Eff>, i: number) => Z,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>\n} = fiberRuntime.mergeAll\n\n/**\n * Processes an iterable and applies an effectful function to each element,\n * categorizing the results into successes and failures.\n *\n * **Details**\n *\n * This function processes each element in the provided iterable by applying an\n * effectful function to it. The results are then categorized into two separate\n * lists: one for failures and another for successes. This separation allows you\n * to handle the two categories differently. Failures are collected in a list\n * without interrupting the processing of the remaining elements, so the\n * operation continues even if some elements fail. This is particularly useful\n * when you need to handle both successful and failed results separately,\n * without stopping the entire process on encountering a failure.\n *\n * **When to Use**\n *\n * Use this function when you want to process a collection of items and handle\n * errors or failures without interrupting the processing of other items. It's\n * useful when you need to distinguish between successful and failed results and\n * process them separately, for example, when logging errors while continuing to\n * work with valid data. The function ensures that failures are captured, while\n * successes are processed normally.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<[string[], number[]], never, never>\n * //      \n * const program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n *   if (n % 2 === 0) {\n *     return Effect.succeed(n)\n *   } else {\n *     return Effect.fail(`${n} is not even`)\n *   }\n * })\n *\n * Effect.runPromise(program).then(console.log, console.error)\n * // Output:\n * // [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n * ```\n *\n * @see {@link validateAll} for a function that either collects all failures or all successes.\n * @see {@link validateFirst} for a function that stops at the first success.\n *\n * @since 2.0.0\n * @category Error Accumulation\n */\nexport const partition: {\n  /**\n   * Processes an iterable and applies an effectful function to each element,\n   * categorizing the results into successes and failures.\n   *\n   * **Details**\n   *\n   * This function processes each element in the provided iterable by applying an\n   * effectful function to it. The results are then categorized into two separate\n   * lists: one for failures and another for successes. This separation allows you\n   * to handle the two categories differently. Failures are collected in a list\n   * without interrupting the processing of the remaining elements, so the\n   * operation continues even if some elements fail. This is particularly useful\n   * when you need to handle both successful and failed results separately,\n   * without stopping the entire process on encountering a failure.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to process a collection of items and handle\n   * errors or failures without interrupting the processing of other items. It's\n   * useful when you need to distinguish between successful and failed results and\n   * process them separately, for example, when logging errors while continuing to\n   * work with valid data. The function ensures that failures are captured, while\n   * successes are processed normally.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * //       Effect<[string[], number[]], never, never>\n   * //      \n   * const program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n   *   if (n % 2 === 0) {\n   *     return Effect.succeed(n)\n   *   } else {\n   *     return Effect.fail(`${n} is not even`)\n   *   }\n   * })\n   *\n   * Effect.runPromise(program).then(console.log, console.error)\n   * // Output:\n   * // [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n   * ```\n   *\n   * @see {@link validateAll} for a function that either collects all failures or all successes.\n   * @see {@link validateFirst} for a function that stops at the first success.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>\n  /**\n   * Processes an iterable and applies an effectful function to each element,\n   * categorizing the results into successes and failures.\n   *\n   * **Details**\n   *\n   * This function processes each element in the provided iterable by applying an\n   * effectful function to it. The results are then categorized into two separate\n   * lists: one for failures and another for successes. This separation allows you\n   * to handle the two categories differently. Failures are collected in a list\n   * without interrupting the processing of the remaining elements, so the\n   * operation continues even if some elements fail. This is particularly useful\n   * when you need to handle both successful and failed results separately,\n   * without stopping the entire process on encountering a failure.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to process a collection of items and handle\n   * errors or failures without interrupting the processing of other items. It's\n   * useful when you need to distinguish between successful and failed results and\n   * process them separately, for example, when logging errors while continuing to\n   * work with valid data. The function ensures that failures are captured, while\n   * successes are processed normally.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * //       Effect<[string[], number[]], never, never>\n   * //      \n   * const program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n   *   if (n % 2 === 0) {\n   *     return Effect.succeed(n)\n   *   } else {\n   *     return Effect.fail(`${n} is not even`)\n   *   }\n   * })\n   *\n   * Effect.runPromise(program).then(console.log, console.error)\n   * // Output:\n   * // [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n   * ```\n   *\n   * @see {@link validateAll} for a function that either collects all failures or all successes.\n   * @see {@link validateFirst} for a function that stops at the first success.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    elements: Iterable<A>,\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>\n} = fiberRuntime.partition\n\n/**\n * Reduces an `Iterable<A>` using an effectual function `f`, working\n * sequentially from left to right.\n *\n * **Details**\n *\n * This function takes an iterable and applies a function `f` to each element in\n * the iterable. The function works sequentially, starting with an initial value\n * `zero` and then combining it with each element in the collection. The\n * provided function `f` is called for each element in the iterable, allowing\n * you to accumulate a result based on the current value and the element being\n * processed.\n *\n * **When to Use**\n *\n * The function is often used for operations like summing a collection of\n * numbers or combining results from multiple tasks. It ensures that operations\n * are performed one after the other, maintaining the order of the elements.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const processOrder = (id: number) =>\n *   Effect.succeed({ id, price: 100 * id })\n *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n *\n * const program = Effect.reduce(\n *   [1, 2, 3, 4],\n *   0,\n *   (acc, id, i) =>\n *     processOrder(id)\n *       .pipe(Effect.map((order) => acc + order.price))\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Order 1 processed\n * // Order 2 processed\n * // Order 3 processed\n * // Order 4 processed\n * // 1000\n * ```\n *\n * @see {@link reduceWhile} for a similar function that stops the process based on a predicate.\n * @see {@link reduceRight} for a similar function that works from right to left.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const reduce: {\n  /**\n   * Reduces an `Iterable<A>` using an effectual function `f`, working\n   * sequentially from left to right.\n   *\n   * **Details**\n   *\n   * This function takes an iterable and applies a function `f` to each element in\n   * the iterable. The function works sequentially, starting with an initial value\n   * `zero` and then combining it with each element in the collection. The\n   * provided function `f` is called for each element in the iterable, allowing\n   * you to accumulate a result based on the current value and the element being\n   * processed.\n   *\n   * **When to Use**\n   *\n   * The function is often used for operations like summing a collection of\n   * numbers or combining results from multiple tasks. It ensures that operations\n   * are performed one after the other, maintaining the order of the elements.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduce(\n   *   [1, 2, 3, 4],\n   *   0,\n   *   (acc, id, i) =>\n   *     processOrder(id)\n   *       .pipe(Effect.map((order) => acc + order.price))\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 1 processed\n   * // Order 2 processed\n   * // Order 3 processed\n   * // Order 4 processed\n   * // 1000\n   * ```\n   *\n   * @see {@link reduceWhile} for a similar function that stops the process based on a predicate.\n   * @see {@link reduceRight} for a similar function that works from right to left.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>\n  /**\n   * Reduces an `Iterable<A>` using an effectual function `f`, working\n   * sequentially from left to right.\n   *\n   * **Details**\n   *\n   * This function takes an iterable and applies a function `f` to each element in\n   * the iterable. The function works sequentially, starting with an initial value\n   * `zero` and then combining it with each element in the collection. The\n   * provided function `f` is called for each element in the iterable, allowing\n   * you to accumulate a result based on the current value and the element being\n   * processed.\n   *\n   * **When to Use**\n   *\n   * The function is often used for operations like summing a collection of\n   * numbers or combining results from multiple tasks. It ensures that operations\n   * are performed one after the other, maintaining the order of the elements.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduce(\n   *   [1, 2, 3, 4],\n   *   0,\n   *   (acc, id, i) =>\n   *     processOrder(id)\n   *       .pipe(Effect.map((order) => acc + order.price))\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 1 processed\n   * // Order 2 processed\n   * // Order 3 processed\n   * // Order 4 processed\n   * // 1000\n   * ```\n   *\n   * @see {@link reduceWhile} for a similar function that stops the process based on a predicate.\n   * @see {@link reduceRight} for a similar function that works from right to left.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect<Z, E, R>\n  ): Effect<Z, E, R>\n} = effect.reduce\n\n/**\n * Reduces an `Iterable<A>` using an effectual function `body`, working\n * sequentially from left to right, stopping the process early when the\n * predicate `while` is not satisfied.\n *\n * **Details**\n *\n * This function processes a collection of elements, applying a function `body`\n * to reduce them to a single value, starting from the first element. It checks\n * the value of the accumulator against a predicate (`while`). If at any point\n * the predicate returns `false`, the reduction stops, and the accumulated\n * result is returned.\n *\n * **When to Use**\n *\n * Use this function when you need to reduce a collection of elements, but only\n * continue the process as long as a certain condition holds true. For example,\n * if you want to sum values in a list but stop as soon as the sum exceeds a\n * certain threshold, you can use this function.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const processOrder = (id: number) =>\n *   Effect.succeed({ id, price: 100 * id })\n *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n *\n * const program = Effect.reduceWhile(\n *   [1, 2, 3, 4],\n *   0,\n *   {\n *     body: (acc, id, i) =>\n *       processOrder(id)\n *         .pipe(Effect.map((order) => acc + order.price)),\n *     while: (acc) => acc < 500\n *   }\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Order 1 processed\n * // Order 2 processed\n * // Order 3 processed\n * // 600\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const reduceWhile: {\n  /**\n   * Reduces an `Iterable<A>` using an effectual function `body`, working\n   * sequentially from left to right, stopping the process early when the\n   * predicate `while` is not satisfied.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements, applying a function `body`\n   * to reduce them to a single value, starting from the first element. It checks\n   * the value of the accumulator against a predicate (`while`). If at any point\n   * the predicate returns `false`, the reduction stops, and the accumulated\n   * result is returned.\n   *\n   * **When to Use**\n   *\n   * Use this function when you need to reduce a collection of elements, but only\n   * continue the process as long as a certain condition holds true. For example,\n   * if you want to sum values in a list but stop as soon as the sum exceeds a\n   * certain threshold, you can use this function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduceWhile(\n   *   [1, 2, 3, 4],\n   *   0,\n   *   {\n   *     body: (acc, id, i) =>\n   *       processOrder(id)\n   *         .pipe(Effect.map((order) => acc + order.price)),\n   *     while: (acc) => acc < 500\n   *   }\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 1 processed\n   * // Order 2 processed\n   * // Order 3 processed\n   * // 600\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <Z, A, E, R>(\n    zero: Z,\n    options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R> }\n  ): (elements: Iterable<A>) => Effect<Z, E, R>\n  /**\n   * Reduces an `Iterable<A>` using an effectual function `body`, working\n   * sequentially from left to right, stopping the process early when the\n   * predicate `while` is not satisfied.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements, applying a function `body`\n   * to reduce them to a single value, starting from the first element. It checks\n   * the value of the accumulator against a predicate (`while`). If at any point\n   * the predicate returns `false`, the reduction stops, and the accumulated\n   * result is returned.\n   *\n   * **When to Use**\n   *\n   * Use this function when you need to reduce a collection of elements, but only\n   * continue the process as long as a certain condition holds true. For example,\n   * if you want to sum values in a list but stop as soon as the sum exceeds a\n   * certain threshold, you can use this function.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduceWhile(\n   *   [1, 2, 3, 4],\n   *   0,\n   *   {\n   *     body: (acc, id, i) =>\n   *       processOrder(id)\n   *         .pipe(Effect.map((order) => acc + order.price)),\n   *     while: (acc) => acc < 500\n   *   }\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 1 processed\n   * // Order 2 processed\n   * // Order 3 processed\n   * // 600\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R> }\n  ): Effect<Z, E, R>\n} = effect.reduceWhile\n\n/**\n * Reduces an `Iterable<A>` using an effectual function `f`, working\n * sequentially from right to left.\n *\n * **Details**\n *\n * This function takes an iterable and applies a function `f` to each element in\n * the iterable. The function works sequentially, starting with an initial value\n * `zero` and then combining it with each element in the collection. The\n * provided function `f` is called for each element in the iterable, allowing\n * you to accumulate a result based on the current value and the element being\n * processed.\n *\n * **When to Use**\n *\n * The function is often used for operations like summing a collection of\n * numbers or combining results from multiple tasks. It ensures that operations\n * are performed one after the other, maintaining the order of the elements.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const processOrder = (id: number) =>\n *   Effect.succeed({ id, price: 100 * id })\n *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n *\n * const program = Effect.reduceRight(\n *   [1, 2, 3, 4],\n *   0,\n *   (id, acc, i) =>\n *     processOrder(id)\n *       .pipe(Effect.map((order) => acc + order.price))\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Order 4 processed\n * // Order 3 processed\n * // Order 2 processed\n * // Order 1 processed\n * // 1000\n * ```\n *\n * @see {@link reduce} for a similar function that works from left to right.\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const reduceRight: {\n  /**\n   * Reduces an `Iterable<A>` using an effectual function `f`, working\n   * sequentially from right to left.\n   *\n   * **Details**\n   *\n   * This function takes an iterable and applies a function `f` to each element in\n   * the iterable. The function works sequentially, starting with an initial value\n   * `zero` and then combining it with each element in the collection. The\n   * provided function `f` is called for each element in the iterable, allowing\n   * you to accumulate a result based on the current value and the element being\n   * processed.\n   *\n   * **When to Use**\n   *\n   * The function is often used for operations like summing a collection of\n   * numbers or combining results from multiple tasks. It ensures that operations\n   * are performed one after the other, maintaining the order of the elements.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduceRight(\n   *   [1, 2, 3, 4],\n   *   0,\n   *   (id, acc, i) =>\n   *     processOrder(id)\n   *       .pipe(Effect.map((order) => acc + order.price))\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 4 processed\n   * // Order 3 processed\n   * // Order 2 processed\n   * // Order 1 processed\n   * // 1000\n   * ```\n   *\n   * @see {@link reduce} for a similar function that works from left to right.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>\n  /**\n   * Reduces an `Iterable<A>` using an effectual function `f`, working\n   * sequentially from right to left.\n   *\n   * **Details**\n   *\n   * This function takes an iterable and applies a function `f` to each element in\n   * the iterable. The function works sequentially, starting with an initial value\n   * `zero` and then combining it with each element in the collection. The\n   * provided function `f` is called for each element in the iterable, allowing\n   * you to accumulate a result based on the current value and the element being\n   * processed.\n   *\n   * **When to Use**\n   *\n   * The function is often used for operations like summing a collection of\n   * numbers or combining results from multiple tasks. It ensures that operations\n   * are performed one after the other, maintaining the order of the elements.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduceRight(\n   *   [1, 2, 3, 4],\n   *   0,\n   *   (id, acc, i) =>\n   *     processOrder(id)\n   *       .pipe(Effect.map((order) => acc + order.price))\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 4 processed\n   * // Order 3 processed\n   * // Order 2 processed\n   * // Order 1 processed\n   * // 1000\n   * ```\n   *\n   * @see {@link reduce} for a similar function that works from left to right.\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, Z, R, E>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect<Z, E, R>\n  ): Effect<Z, E, R>\n} = effect.reduceRight\n\n/**\n * Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n *\n * **Details**\n *\n * This function processes a collection of effects and combines them into one\n * single effect. It starts with an initial effect (`zero`) and applies a\n * function `f` to each element in the collection.\n *\n * **Options**\n *\n * The function also allows you to customize how the effects are handled by\n * specifying options such as concurrency, batching, and how finalizers behave.\n * These options provide flexibility in running the effects concurrently or\n * adjusting other execution details.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const processOrder = (id: number) =>\n *   Effect.succeed({ id, price: 100 * id })\n *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n *\n * const program = Effect.reduceEffect(\n *   [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n *   Effect.succeed(0),\n *   (acc, order, i) => acc + order.price\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Order 1 processed\n * // Order 2 processed\n * // Order 3 processed\n * // Order 4 processed\n * // 1000\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const reduceEffect: {\n  /**\n   * Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n   *\n   * **Details**\n   *\n   * This function processes a collection of effects and combines them into one\n   * single effect. It starts with an initial effect (`zero`) and applies a\n   * function `f` to each element in the collection.\n   *\n   * **Options**\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduceEffect(\n   *   [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n   *   Effect.succeed(0),\n   *   (acc, order, i) => acc + order.price\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 1 processed\n   * // Order 2 processed\n   * // Order 3 processed\n   * // Order 4 processed\n   * // 1000\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <Z, E, R, Eff extends Effect<any, any, any>>(\n    zero: Effect<Z, E, R>,\n    f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>\n  /**\n   * Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n   *\n   * **Details**\n   *\n   * This function processes a collection of effects and combines them into one\n   * single effect. It starts with an initial effect (`zero`) and applies a\n   * function `f` to each element in the collection.\n   *\n   * **Options**\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const processOrder = (id: number) =>\n   *   Effect.succeed({ id, price: 100 * id })\n   *     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n   *\n   * const program = Effect.reduceEffect(\n   *   [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n   *   Effect.succeed(0),\n   *   (acc, order, i) => acc + order.price\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Order 1 processed\n   * // Order 2 processed\n   * // Order 3 processed\n   * // Order 4 processed\n   * // 1000\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <Eff extends Effect<any, any, any>, Z, E, R>(\n    elements: Iterable<Eff>,\n    zero: Effect<Z, E, R>,\n    f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>\n} = fiberRuntime.reduceEffect\n\n/**\n * Replicates the given effect `n` times.\n *\n * **Details**\n *\n * This function takes an effect and replicates it a specified number of times\n * (`n`). The result is an array of `n` effects, each of which is identical to\n * the original effect.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const task = Effect.succeed(\"Hello, World!\").pipe(\n *   Effect.tap(Console.log)\n * )\n *\n * const program = Effect.gen(function*() {\n *   // Replicate the task 3 times\n *   const tasks = Effect.replicate(task, 3)\n *   for (const t of tasks) {\n *     // Run each task\n *     yield* t\n *   }\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // Hello, World!\n * // Hello, World!\n * // Hello, World!\n * ```\n *\n * @since 2.0.0\n */\nexport const replicate: {\n  /**\n   * Replicates the given effect `n` times.\n   *\n   * **Details**\n   *\n   * This function takes an effect and replicates it a specified number of times\n   * (`n`). The result is an array of `n` effects, each of which is identical to\n   * the original effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const task = Effect.succeed(\"Hello, World!\").pipe(\n   *   Effect.tap(Console.log)\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   // Replicate the task 3 times\n   *   const tasks = Effect.replicate(task, 3)\n   *   for (const t of tasks) {\n   *     // Run each task\n   *     yield* t\n   *   }\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Hello, World!\n   * // Hello, World!\n   * // Hello, World!\n   * ```\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>\n  /**\n   * Replicates the given effect `n` times.\n   *\n   * **Details**\n   *\n   * This function takes an effect and replicates it a specified number of times\n   * (`n`). The result is an array of `n` effects, each of which is identical to\n   * the original effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const task = Effect.succeed(\"Hello, World!\").pipe(\n   *   Effect.tap(Console.log)\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   // Replicate the task 3 times\n   *   const tasks = Effect.replicate(task, 3)\n   *   for (const t of tasks) {\n   *     // Run each task\n   *     yield* t\n   *   }\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Hello, World!\n   * // Hello, World!\n   * // Hello, World!\n   * ```\n   *\n   * @since 2.0.0\n   */\n  <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>\n} = fiberRuntime.replicate\n\n/**\n * Performs this effect the specified number of times and collects the results.\n *\n * **Details**\n *\n * This function repeats an effect multiple times and collects the results into\n * an array. You specify how many times to execute the effect, and it runs that\n * many times, either in sequence or concurrently depending on the provided\n * options.\n *\n * **Options**\n *\n * If the `discard` option is set to `true`, the intermediate results are not\n * collected, and the final result of the operation is `void`.\n *\n * The function also allows you to customize how the effects are handled by\n * specifying options such as concurrency, batching, and how finalizers behave.\n * These options provide flexibility in running the effects concurrently or\n * adjusting other execution details.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * let counter = 0\n *\n * const task = Effect.sync(() => ++counter).pipe(\n *   Effect.tap(() => Console.log(`Task completed`))\n * )\n *\n * const program = Effect.gen(function*() {\n *   // Replicate the task 3 times and collect the results\n *   const results = yield* Effect.replicateEffect(task, 3)\n *   yield* Console.log(`Results: ${results.join(\", \")}`)\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // Task completed\n * // Task completed\n * // Task completed\n * // Results: 1, 2, 3\n * ```\n *\n * @since 2.0.0\n * @category Collecting\n */\nexport const replicateEffect: {\n  /**\n   * Performs this effect the specified number of times and collects the results.\n   *\n   * **Details**\n   *\n   * This function repeats an effect multiple times and collects the results into\n   * an array. You specify how many times to execute the effect, and it runs that\n   * many times, either in sequence or concurrently depending on the provided\n   * options.\n   *\n   * **Options**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * let counter = 0\n   *\n   * const task = Effect.sync(() => ++counter).pipe(\n   *   Effect.tap(() => Console.log(`Task completed`))\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   // Replicate the task 3 times and collect the results\n   *   const results = yield* Effect.replicateEffect(task, 3)\n   *   yield* Console.log(`Results: ${results.join(\", \")}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Task completed\n   * // Task completed\n   * // Task completed\n   * // Results: 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  (\n    n: number,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>\n  /**\n   * Performs this effect the specified number of times and collects the results.\n   *\n   * **Details**\n   *\n   * This function repeats an effect multiple times and collects the results into\n   * an array. You specify how many times to execute the effect, and it runs that\n   * many times, either in sequence or concurrently depending on the provided\n   * options.\n   *\n   * **Options**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * let counter = 0\n   *\n   * const task = Effect.sync(() => ++counter).pipe(\n   *   Effect.tap(() => Console.log(`Task completed`))\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   // Replicate the task 3 times and collect the results\n   *   const results = yield* Effect.replicateEffect(task, 3)\n   *   yield* Console.log(`Results: ${results.join(\", \")}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Task completed\n   * // Task completed\n   * // Task completed\n   * // Results: 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  (\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>\n  /**\n   * Performs this effect the specified number of times and collects the results.\n   *\n   * **Details**\n   *\n   * This function repeats an effect multiple times and collects the results into\n   * an array. You specify how many times to execute the effect, and it runs that\n   * many times, either in sequence or concurrently depending on the provided\n   * options.\n   *\n   * **Options**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * let counter = 0\n   *\n   * const task = Effect.sync(() => ++counter).pipe(\n   *   Effect.tap(() => Console.log(`Task completed`))\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   // Replicate the task 3 times and collect the results\n   *   const results = yield* Effect.replicateEffect(task, 3)\n   *   yield* Console.log(`Results: ${results.join(\", \")}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Task completed\n   * // Task completed\n   * // Task completed\n   * // Results: 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    self: Effect<A, E, R>,\n    n: number,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect<Array<A>, E, R>\n  /**\n   * Performs this effect the specified number of times and collects the results.\n   *\n   * **Details**\n   *\n   * This function repeats an effect multiple times and collects the results into\n   * an array. You specify how many times to execute the effect, and it runs that\n   * many times, either in sequence or concurrently depending on the provided\n   * options.\n   *\n   * **Options**\n   *\n   * If the `discard` option is set to `true`, the intermediate results are not\n   * collected, and the final result of the operation is `void`.\n   *\n   * The function also allows you to customize how the effects are handled by\n   * specifying options such as concurrency, batching, and how finalizers behave.\n   * These options provide flexibility in running the effects concurrently or\n   * adjusting other execution details.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * let counter = 0\n   *\n   * const task = Effect.sync(() => ++counter).pipe(\n   *   Effect.tap(() => Console.log(`Task completed`))\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   // Replicate the task 3 times and collect the results\n   *   const results = yield* Effect.replicateEffect(task, 3)\n   *   yield* Console.log(`Results: ${results.join(\", \")}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Task completed\n   * // Task completed\n   * // Task completed\n   * // Results: 1, 2, 3\n   * ```\n   *\n   * @since 2.0.0\n   * @category Collecting\n   */\n  <A, E, R>(\n    self: Effect<A, E, R>,\n    n: number,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect<void, E, R>\n} = fiberRuntime.replicateEffect\n\n/**\n * Applies an effectful operation to each element in a collection while\n * collecting both successes and failures.\n *\n * **Details**\n *\n * This function allows you to apply an effectful operation to every item in a\n * collection.\n *\n * Unlike {@link forEach}, which would stop at the first error, this function\n * continues processing all elements, accumulating both successes and failures.\n *\n * **When to Use**\n *\n * Use this function when you want to process every item in a collection, even\n * if some items fail. This is particularly useful when you need to perform\n * operations on all elements without halting due to an error.\n *\n * Keep in mind that if there are any failures, **all successes will be lost**,\n * so this function is not suitable when you need to keep the successful results\n * in case of errors.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<number[], [string, ...string[]], never>\n * //      \n * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   } else {\n *     return Effect.fail(`${n} is not less that 4`)\n *   }\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // item 1\n * // item 2\n * // item 3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n * //   }\n * // }\n * ```\n *\n * @see {@link forEach} for a similar function that stops at the first error.\n * @see {@link partition} when you need to separate successes and failures\n * instead of losing successes with errors.\n *\n * @since 2.0.0\n * @category Error Accumulation\n */\nexport const validateAll: {\n  /**\n   * Applies an effectful operation to each element in a collection while\n   * collecting both successes and failures.\n   *\n   * **Details**\n   *\n   * This function allows you to apply an effectful operation to every item in a\n   * collection.\n   *\n   * Unlike {@link forEach}, which would stop at the first error, this function\n   * continues processing all elements, accumulating both successes and failures.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to process every item in a collection, even\n   * if some items fail. This is particularly useful when you need to perform\n   * operations on all elements without halting due to an error.\n   *\n   * Keep in mind that if there are any failures, **all successes will be lost**,\n   * so this function is not suitable when you need to keep the successful results\n   * in case of errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * //       Effect<number[], [string, ...string[]], never>\n   * //      \n   * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n   *   if (n < 4) {\n   *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n   *   } else {\n   *     return Effect.fail(`${n} is not less that 4`)\n   *   }\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // item 1\n   * // item 2\n   * // item 3\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link forEach} for a similar function that stops at the first error.\n   * @see {@link partition} when you need to separate successes and failures\n   * instead of losing successes with errors.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>\n  /**\n   * Applies an effectful operation to each element in a collection while\n   * collecting both successes and failures.\n   *\n   * **Details**\n   *\n   * This function allows you to apply an effectful operation to every item in a\n   * collection.\n   *\n   * Unlike {@link forEach}, which would stop at the first error, this function\n   * continues processing all elements, accumulating both successes and failures.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to process every item in a collection, even\n   * if some items fail. This is particularly useful when you need to perform\n   * operations on all elements without halting due to an error.\n   *\n   * Keep in mind that if there are any failures, **all successes will be lost**,\n   * so this function is not suitable when you need to keep the successful results\n   * in case of errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * //       Effect<number[], [string, ...string[]], never>\n   * //      \n   * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n   *   if (n < 4) {\n   *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n   *   } else {\n   *     return Effect.fail(`${n} is not less that 4`)\n   *   }\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // item 1\n   * // item 2\n   * // item 3\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link forEach} for a similar function that stops at the first error.\n   * @see {@link partition} when you need to separate successes and failures\n   * instead of losing successes with errors.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>\n  /**\n   * Applies an effectful operation to each element in a collection while\n   * collecting both successes and failures.\n   *\n   * **Details**\n   *\n   * This function allows you to apply an effectful operation to every item in a\n   * collection.\n   *\n   * Unlike {@link forEach}, which would stop at the first error, this function\n   * continues processing all elements, accumulating both successes and failures.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to process every item in a collection, even\n   * if some items fail. This is particularly useful when you need to perform\n   * operations on all elements without halting due to an error.\n   *\n   * Keep in mind that if there are any failures, **all successes will be lost**,\n   * so this function is not suitable when you need to keep the successful results\n   * in case of errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * //       Effect<number[], [string, ...string[]], never>\n   * //      \n   * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n   *   if (n < 4) {\n   *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n   *   } else {\n   *     return Effect.fail(`${n} is not less that 4`)\n   *   }\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // item 1\n   * // item 2\n   * // item 3\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link forEach} for a similar function that stops at the first error.\n   * @see {@link partition} when you need to separate successes and failures\n   * instead of losing successes with errors.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    elements: Iterable<A>,\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options?: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard?: false | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): Effect<Array<B>, RA.NonEmptyArray<E>, R>\n  /**\n   * Applies an effectful operation to each element in a collection while\n   * collecting both successes and failures.\n   *\n   * **Details**\n   *\n   * This function allows you to apply an effectful operation to every item in a\n   * collection.\n   *\n   * Unlike {@link forEach}, which would stop at the first error, this function\n   * continues processing all elements, accumulating both successes and failures.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to process every item in a collection, even\n   * if some items fail. This is particularly useful when you need to perform\n   * operations on all elements without halting due to an error.\n   *\n   * Keep in mind that if there are any failures, **all successes will be lost**,\n   * so this function is not suitable when you need to keep the successful results\n   * in case of errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * //       Effect<number[], [string, ...string[]], never>\n   * //      \n   * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n   *   if (n < 4) {\n   *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n   *   } else {\n   *     return Effect.fail(`${n} is not less that 4`)\n   *   }\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // item 1\n   * // item 2\n   * // item 3\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link forEach} for a similar function that stops at the first error.\n   * @see {@link partition} when you need to separate successes and failures\n   * instead of losing successes with errors.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    elements: Iterable<A>,\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options: {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly discard: true\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect<void, RA.NonEmptyArray<E>, R>\n} = fiberRuntime.validateAll\n\n/**\n * This function is similar to {@link validateAll} but with a key difference: it\n * returns the first successful result or all errors if none of the operations\n * succeed.\n *\n * **Details**\n *\n * This function processes a collection of elements and applies an effectful\n * operation to each. Unlike {@link validateAll}, which accumulates both\n * successes and failures, `Effect.validateFirst` stops and returns the first\n * success it encounters. If no success occurs, it returns all accumulated\n * errors. This can be useful when you are interested in the first successful\n * result and want to avoid processing further once a valid result is found.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<number, string[], never>\n * //      \n * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Effect.fail(`${n} is not less that 4`)\n *   } else {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   }\n * })\n *\n * Effect.runPromise(program).then(console.log, console.error)\n * // Output:\n * // item 4\n * // 4\n * ```\n *\n * @see {@link validateAll} for a similar function that accumulates all results.\n * @see {@link firstSuccessOf} for a similar function that processes multiple\n * effects and returns the first successful one or the last error.\n *\n * @since 2.0.0\n * @category Error Accumulation\n */\nexport const validateFirst: {\n  /**\n   * This function is similar to {@link validateAll} but with a key difference: it\n   * returns the first successful result or all errors if none of the operations\n   * succeed.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and applies an effectful\n   * operation to each. Unlike {@link validateAll}, which accumulates both\n   * successes and failures, `Effect.validateFirst` stops and returns the first\n   * success it encounters. If no success occurs, it returns all accumulated\n   * errors. This can be useful when you are interested in the first successful\n   * result and want to avoid processing further once a valid result is found.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * //       Effect<number, string[], never>\n   * //      \n   * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n   *   if (n < 4) {\n   *     return Effect.fail(`${n} is not less that 4`)\n   *   } else {\n   *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n   *   }\n   * })\n   *\n   * Effect.runPromise(program).then(console.log, console.error)\n   * // Output:\n   * // item 4\n   * // 4\n   * ```\n   *\n   * @see {@link validateAll} for a similar function that accumulates all results.\n   * @see {@link firstSuccessOf} for a similar function that processes multiple\n   * effects and returns the first successful one or the last error.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): (elements: Iterable<A>) => Effect<B, Array<E>, R>\n  /**\n   * This function is similar to {@link validateAll} but with a key difference: it\n   * returns the first successful result or all errors if none of the operations\n   * succeed.\n   *\n   * **Details**\n   *\n   * This function processes a collection of elements and applies an effectful\n   * operation to each. Unlike {@link validateAll}, which accumulates both\n   * successes and failures, `Effect.validateFirst` stops and returns the first\n   * success it encounters. If no success occurs, it returns all accumulated\n   * errors. This can be useful when you are interested in the first successful\n   * result and want to avoid processing further once a valid result is found.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * //       Effect<number, string[], never>\n   * //      \n   * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n   *   if (n < 4) {\n   *     return Effect.fail(`${n} is not less that 4`)\n   *   } else {\n   *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n   *   }\n   * })\n   *\n   * Effect.runPromise(program).then(console.log, console.error)\n   * // Output:\n   * // item 4\n   * // 4\n   * ```\n   *\n   * @see {@link validateAll} for a similar function that accumulates all results.\n   * @see {@link firstSuccessOf} for a similar function that processes multiple\n   * effects and returns the first successful one or the last error.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, B, E, R>(\n    elements: Iterable<A>,\n    f: (a: A, i: number) => Effect<B, E, R>,\n    options?:\n      | {\n        readonly concurrency?: Concurrency | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<B, Array<E>, R>\n} = fiberRuntime.validateFirst\n\n/**\n * Creates an `Effect` from a callback-based asynchronous function.\n *\n * **Details**\n *\n * The `resume` function:\n * - Must be called exactly once. Any additional calls will be ignored.\n * - Can return an optional `Effect` that will be run if the `Fiber` executing\n *   this `Effect` is interrupted. This can be useful in scenarios where you\n *   need to handle resource cleanup if the operation is interrupted.\n * - Can receive an `AbortSignal` to handle interruption if needed.\n *\n * The `FiberId` of the fiber that may complete the async callback may also be\n * specified using the `blockingOn` argument. This is called the \"blocking\n * fiber\" because it suspends the fiber executing the `async` effect (i.e.\n * semantically blocks the fiber from making progress). Specifying this fiber id\n * in cases where it is known will improve diagnostics, but not affect the\n * behavior of the returned effect.\n *\n * **When to Use**\n *\n * Use `Effect.async` when dealing with APIs that use callback-style instead of\n * `async/await` or `Promise`.\n *\n * **Example** (Wrapping a Callback API)\n *\n * ```ts\n * import { Effect } from \"effect\"\n * import * as NodeFS from \"node:fs\"\n *\n * const readFile = (filename: string) =>\n *   Effect.async<Buffer, Error>((resume) => {\n *     NodeFS.readFile(filename, (error, data) => {\n *       if (error) {\n *         // Resume with a failed Effect if an error occurs\n *         resume(Effect.fail(error))\n *       } else {\n *         // Resume with a succeeded Effect if successful\n *         resume(Effect.succeed(data))\n *       }\n *     })\n *   })\n *\n * //       Effect<Buffer, Error, never>\n * //      \n * const program = readFile(\"example.txt\")\n * ```\n *\n * **Example** (Handling Interruption with Cleanup)\n *\n * ```ts\n * import { Effect, Fiber } from \"effect\"\n * import * as NodeFS from \"node:fs\"\n *\n * // Simulates a long-running operation to write to a file\n * const writeFileWithCleanup = (filename: string, data: string) =>\n *   Effect.async<void, Error>((resume) => {\n *     const writeStream = NodeFS.createWriteStream(filename)\n *\n *     // Start writing data to the file\n *     writeStream.write(data)\n *\n *     // When the stream is finished, resume with success\n *     writeStream.on(\"finish\", () => resume(Effect.void))\n *\n *     // In case of an error during writing, resume with failure\n *     writeStream.on(\"error\", (err) => resume(Effect.fail(err)))\n *\n *     // Handle interruption by returning a cleanup effect\n *     return Effect.sync(() => {\n *       console.log(`Cleaning up ${filename}`)\n *       NodeFS.unlinkSync(filename)\n *     })\n *   })\n *\n * const program = Effect.gen(function* () {\n *   const fiber = yield* Effect.fork(\n *     writeFileWithCleanup(\"example.txt\", \"Some long data...\")\n *   )\n *   // Simulate interrupting the fiber after 1 second\n *   yield* Effect.sleep(\"1 second\")\n *   yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n * })\n *\n * // Run the program\n * Effect.runPromise(program)\n * // Output:\n * // Cleaning up example.txt\n * ```\n *\n * **Example** (Handling Interruption with AbortSignal)\n *\n * ```ts\n * import { Effect, Fiber } from \"effect\"\n *\n * // A task that supports interruption using AbortSignal\n * const interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n *   // Handle interruption\n *   signal.addEventListener(\"abort\", () => {\n *     console.log(\"Abort signal received\")\n *     clearTimeout(timeoutId)\n *   })\n *\n *   // Simulate a long-running task\n *   const timeoutId = setTimeout(() => {\n *     console.log(\"Operation completed\")\n *     resume(Effect.void)\n *   }, 2000)\n * })\n *\n * const program = Effect.gen(function* () {\n *   const fiber = yield* Effect.fork(interruptibleTask)\n *   // Simulate interrupting the fiber after 1 second\n *   yield* Effect.sleep(\"1 second\")\n *   yield* Fiber.interrupt(fiber)\n * })\n *\n * // Run the program\n * Effect.runPromise(program)\n * // Output:\n * // Abort signal received\n * ```\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const async: <A, E = never, R = never>(\n  resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>,\n  blockingOn?: FiberId.FiberId\n) => Effect<A, E, R> = core.async\n\n/**\n * A variant of {@link async} where the registration function may return an `Effect`.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const asyncEffect: <A, E, R, R3, E2, R2>(\n  register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>\n) => Effect<A, E | E2, R | R2 | R3> = runtime_.asyncEffect\n\n/**\n * Low level constructor that enables for custom stack tracing cutpoints.\n *\n * It is meant to be called with a bag of instructions that become available in\n * the \"this\" of the effect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const throwingFunction = () => { throw new Error() }\n * const blowUp = Effect.custom(throwingFunction, function() {\n *   return Effect.succeed(this.effect_instruction_i0())\n * })\n * ```\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const custom: {\n  /**\n   * Low level constructor that enables for custom stack tracing cutpoints.\n   *\n   * It is meant to be called with a bag of instructions that become available in\n   * the \"this\" of the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const throwingFunction = () => { throw new Error() }\n   * const blowUp = Effect.custom(throwingFunction, function() {\n   *   return Effect.succeed(this.effect_instruction_i0())\n   * })\n   * ```\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X }) => Effect<A, E, R>): Effect<A, E, R>\n  /**\n   * Low level constructor that enables for custom stack tracing cutpoints.\n   *\n   * It is meant to be called with a bag of instructions that become available in\n   * the \"this\" of the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const throwingFunction = () => { throw new Error() }\n   * const blowUp = Effect.custom(throwingFunction, function() {\n   *   return Effect.succeed(this.effect_instruction_i0())\n   * })\n   * ```\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <X, Y, A, E, R>(\n    i0: X,\n    i1: Y,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y }) => Effect<A, E, R>\n  ): Effect<A, E, R>\n  /**\n   * Low level constructor that enables for custom stack tracing cutpoints.\n   *\n   * It is meant to be called with a bag of instructions that become available in\n   * the \"this\" of the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const throwingFunction = () => { throw new Error() }\n   * const blowUp = Effect.custom(throwingFunction, function() {\n   *   return Effect.succeed(this.effect_instruction_i0())\n   * })\n   * ```\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <X, Y, Z, A, E, R>(\n    i0: X,\n    i1: Y,\n    i2: Z,\n    body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z }) => Effect<A, E, R>\n  ): Effect<A, E, R>\n} = core.custom\n\n/**\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const withFiberRuntime: <A, E = never, R = never>(\n  withRuntime: (\n    fiber: Fiber.RuntimeFiber<A, E>,\n    status: FiberStatus.Running\n  ) => Effect<A, E, R>\n) => Effect<A, E, R> = core.withFiberRuntime\n\n/**\n * Creates an `Effect` that represents a recoverable error.\n *\n * **When to Use**\n *\n * Use this function to explicitly signal an error in an `Effect`. The error\n * will keep propagating unless it is handled. You can handle the error with\n * functions like {@link catchAll} or {@link catchTag}.\n *\n * **Example** (Creating a Failed Effect)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<never, Error, never>\n * //      \n * const failure = Effect.fail(\n *   new Error(\"Operation failed due to network error\")\n * )\n * ```\n *\n * @see {@link succeed} to create an effect that represents a successful value.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const fail: <E>(error: E) => Effect<never, E> = core.fail\n\n/**\n * Creates an `Effect` that fails with the specified error, evaluated lazily.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E> = core.failSync\n\n/**\n * Creates an `Effect` that fails with the specified `Cause`.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E> = core.failCause\n\n/**\n * Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E> = core.failCauseSync\n\n/**\n * Creates an effect that terminates a fiber with a specified error.\n *\n * **Details**\n *\n * This function is used to signal a defect, which represents a critical and\n * unexpected error in the code. When invoked, it produces an effect that does\n * not handle the error and instead terminates the fiber.\n *\n * The error channel of the resulting effect is of type `never`, indicating that\n * it cannot recover from this failure.\n *\n * **When to Use**\n *\n * Use this function when encountering unexpected conditions in your code that\n * should not be handled as regular errors but instead represent unrecoverable\n * defects.\n *\n * **Example** (Terminating on Division by Zero with a Specified Error)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.die(new Error(\"Cannot divide by zero\"))\n *     : Effect.succeed(a / b)\n *\n * //       Effect<number, never, never>\n * //      \n * const program = divide(1, 0)\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: Cannot divide by zero\n * //   ...stack trace...\n * ```\n *\n * @see {@link dieSync} for a variant that throws a specified error, evaluated\n * lazily.\n * @see {@link dieMessage} for a variant that throws a `RuntimeException` with a\n * message.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const die: (defect: unknown) => Effect<never> = core.die\n\n/**\n * Creates an effect that terminates a fiber with a `RuntimeException`\n * containing the specified message.\n *\n * **Details**\n *\n * This function is used to signal a defect, representing a critical and\n * unexpected error in the code. When invoked, it produces an effect that\n * terminates the fiber with a `RuntimeException` carrying the given message.\n *\n * The resulting effect has an error channel of type `never`, indicating it does\n * not handle or recover from the error.\n *\n * **When to Use**\n *\n * Use this function when you want to terminate a fiber due to an unrecoverable\n * defect and include a clear explanation in the message.\n *\n * **Example** (Terminating on Division by Zero with a Specified Message)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.dieMessage(\"Cannot divide by zero\")\n *     : Effect.succeed(a / b)\n *\n * //       Effect<number, never, never>\n * //      \n * const program = divide(1, 0)\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) RuntimeException: Cannot divide by zero\n * //   ...stack trace...\n * ```\n *\n * @see {@link die} for a variant that throws a specified error.\n * @see {@link dieSync} for a variant that throws a specified error, evaluated\n * lazily.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const dieMessage: (message: string) => Effect<never> = core.dieMessage\n\n/**\n * Creates an effect that dies with the specified error, evaluated lazily.\n *\n * **Details**\n *\n * This function allows you to create an effect that will terminate with a fatal error.\n * The error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.\n *\n * @see {@link die} if you don't need to evaluate the error lazily.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const dieSync: (evaluate: LazyArg<unknown>) => Effect<never> = core.dieSync\n\n/**\n * Provides a way to write effectful code using generator functions, simplifying\n * control flow and error handling.\n *\n * **When to Use**\n *\n * `Effect.gen` allows you to write code that looks and behaves like synchronous\n * code, but it can handle asynchronous tasks, errors, and complex control flow\n * (like loops and conditions). It helps make asynchronous code more readable\n * and easier to manage.\n *\n * The generator functions work similarly to `async/await` but with more\n * explicit control over the execution of effects. You can `yield*` values from\n * effects and return the final result at the end.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const addServiceCharge = (amount: number) => amount + 1\n *\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n *\n * export const program = Effect.gen(function* () {\n *   const transactionAmount = yield* fetchTransactionAmount\n *   const discountRate = yield* fetchDiscountRate\n *   const discountedAmount = yield* applyDiscount(\n *     transactionAmount,\n *     discountRate\n *   )\n *   const finalAmount = addServiceCharge(discountedAmount)\n *   return `Final amount to charge: ${finalAmount}`\n * })\n * ```\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const gen: {\n  /**\n   * Provides a way to write effectful code using generator functions, simplifying\n   * control flow and error handling.\n   *\n   * **When to Use**\n   *\n   * `Effect.gen` allows you to write code that looks and behaves like synchronous\n   * code, but it can handle asynchronous tasks, errors, and complex control flow\n   * (like loops and conditions). It helps make asynchronous code more readable\n   * and easier to manage.\n   *\n   * The generator functions work similarly to `async/await` but with more\n   * explicit control over the execution of effects. You can `yield*` values from\n   * effects and return the final result at the end.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const addServiceCharge = (amount: number) => amount + 1\n   *\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n   *\n   * export const program = Effect.gen(function* () {\n   *   const transactionAmount = yield* fetchTransactionAmount\n   *   const discountRate = yield* fetchDiscountRate\n   *   const discountedAmount = yield* applyDiscount(\n   *     transactionAmount,\n   *     discountRate\n   *   )\n   *   const finalAmount = addServiceCharge(discountedAmount)\n   *   return `Final amount to charge: ${finalAmount}`\n   * })\n   * ```\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<\n    AEff,\n    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n  >\n  /**\n   * Provides a way to write effectful code using generator functions, simplifying\n   * control flow and error handling.\n   *\n   * **When to Use**\n   *\n   * `Effect.gen` allows you to write code that looks and behaves like synchronous\n   * code, but it can handle asynchronous tasks, errors, and complex control flow\n   * (like loops and conditions). It helps make asynchronous code more readable\n   * and easier to manage.\n   *\n   * The generator functions work similarly to `async/await` but with more\n   * explicit control over the execution of effects. You can `yield*` values from\n   * effects and return the final result at the end.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const addServiceCharge = (amount: number) => amount + 1\n   *\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n   *\n   * export const program = Effect.gen(function* () {\n   *   const transactionAmount = yield* fetchTransactionAmount\n   *   const discountRate = yield* fetchDiscountRate\n   *   const discountedAmount = yield* applyDiscount(\n   *     transactionAmount,\n   *     discountRate\n   *   )\n   *   const finalAmount = addServiceCharge(discountedAmount)\n   *   return `Final amount to charge: ${finalAmount}`\n   * })\n   * ```\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(\n    self: Self,\n    f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>\n  ): Effect<\n    AEff,\n    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n    [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n  >\n} = core.gen\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport interface Adapter {\n  <A, E, R>(self: Effect<A, E, R>): Effect<A, E, R>\n  <A, _A, _E, _R>(a: A, ab: (a: A) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, _A, _E, _R>(a: A, ab: (a: A) => B, bc: (b: B) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, C, _A, _E, _R>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => Effect<_A, _E, _R>): Effect<_A, _E, _R>\n  <A, B, C, D, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _A, _E, _R>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => Effect<_A, _E, _R>\n  ): Effect<_A, _E, _R>\n}\n\n/**\n * An effect that that runs indefinitely and never produces any result. The\n * moral equivalent of `while(true) {}`, only without the wasted CPU cycles.\n *\n * **When to Use**\n *\n * It could be useful for long-running background tasks or to simulate waiting\n * behavior without actually consuming resources. This effect is ideal for cases\n * where you want to keep the program alive or in a certain state without\n * performing any active work.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const never: Effect<never> = core.never\n\n/**\n * Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n * `NoSuchElementException`.\n *\n * **Details**\n *\n * This function checks if the provided `Option` is `None`. If it is, it returns\n * an effect that produces no result (i.e., `void`). If the `Option` is not\n * `None` (i.e., it contains a value), the function will raise a\n * `NoSuchElementException` error.\n *\n * **When to Use**\n *\n * This is useful when you want to ensure that a certain value is absent (i.e.,\n * `None`) before continuing execution, and to handle cases where the value is\n * unexpectedly present.\n *\n * @since 2.0.0\n */\nexport const none: <A, E, R>(\n  self: Effect<Option.Option<A>, E, R>\n) => Effect<void, E | Cause.NoSuchElementException, R> = effect.none\n\n/**\n * Creates an `Effect` that represents an asynchronous computation guaranteed to\n * succeed.\n *\n * **Details**\n *\n * The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error\n * will be treated as a \"defect\".\n *\n * This defect is not a standard error but indicates a flaw in the logic that\n * was expected to be error-free. You can think of it similar to an unexpected\n * crash in the program, which can be further managed or logged using tools like\n * {@link catchAllDefect}.\n *\n * **Interruptions**\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped `Promise` API.\n *\n * **When to Use**\n *\n * Use this function when you are sure the operation will not reject.\n *\n * **Example** (Delayed Message)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const delay = (message: string) =>\n *   Effect.promise<string>(\n *     () =>\n *       new Promise((resolve) => {\n *         setTimeout(() => {\n *           resolve(message)\n *         }, 2000)\n *       })\n *   )\n *\n * //       Effect<string, never, never>\n * //      \n * const program = delay(\"Async operation completed successfully!\")\n * ```\n *\n * @see {@link tryPromise} for a version that can handle failures.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const promise: <A>(\n  evaluate: (signal: AbortSignal) => PromiseLike<A>\n) => Effect<A> = effect.promise\n\n/**\n * Creates an `Effect` that always succeeds with a given value.\n *\n * **When to Use**\n *\n * Use this function when you need an effect that completes successfully with a\n * specific value without any errors or external dependencies.\n *\n * **Example** (Creating a Successful Effect)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // Creating an effect that represents a successful scenario\n * //\n * //       Effect<number, never, never>\n * //      \n * const success = Effect.succeed(42)\n * ```\n *\n * @see {@link fail} to create an effect that represents a failure.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const succeed: <A>(value: A) => Effect<A> = core.succeed\n\n/**\n * Returns an effect which succeeds with `None`.\n *\n * **When to Use**\n *\n * Use this function when you need to represent the absence of a value in your\n * code, especially when working with optional data. This can be helpful when\n * you want to indicate that no result is available without throwing an error or\n * performing additional logic.\n *\n * @see {@link succeedSome} to create an effect that succeeds with a `Some` value.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const succeedNone: Effect<Option.Option<never>> = effect.succeedNone\n\n/**\n * Returns an effect which succeeds with the value wrapped in a `Some`.\n *\n * @see {@link succeedNone} for a similar function that returns `None` when the value is absent.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const succeedSome: <A>(value: A) => Effect<Option.Option<A>> = effect.succeedSome\n\n/**\n * Delays the creation of an `Effect` until it is actually needed.\n *\n * **Details**\n *\n * The `Effect.suspend` function takes a thunk that represents the effect and\n * wraps it in a suspended effect. This means the effect will not be created\n * until it is explicitly needed, which is helpful in various scenarios:\n * - **Lazy Evaluation**: Helps optimize performance by deferring computations,\n *   especially when the effect might not be needed, or when its computation is\n *   expensive. This also ensures that any side effects or scoped captures are\n *   re-executed on each invocation.\n * - **Handling Circular Dependencies**: Useful in managing circular\n *   dependencies, such as recursive functions that need to avoid eager\n *   evaluation to prevent stack overflow.\n * - **Unifying Return Types**: Can help TypeScript unify return types in\n *   situations where multiple branches of logic return different effects,\n *   simplifying type inference.\n *\n * **When to Use**\n *\n * Use this function when you need to defer the evaluation of an effect until it\n * is required. This is particularly useful for optimizing expensive\n * computations, managing circular dependencies, or resolving type inference\n * issues.\n *\n * **Example** (Lazy Evaluation with Side Effects)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * let i = 0\n *\n * const bad = Effect.succeed(i++)\n *\n * const good = Effect.suspend(() => Effect.succeed(i++))\n *\n * console.log(Effect.runSync(bad)) // Output: 0\n * console.log(Effect.runSync(bad)) // Output: 0\n *\n * console.log(Effect.runSync(good)) // Output: 1\n * console.log(Effect.runSync(good)) // Output: 2\n * ```\n *\n * **Example** (Recursive Fibonacci)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const blowsUp = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(1)\n *     : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n *\n * console.log(Effect.runSync(blowsUp(32)))\n * // crash: JavaScript heap out of memory\n *\n * const allGood = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(1)\n *     : Effect.zipWith(\n *         Effect.suspend(() => allGood(n - 1)),\n *         Effect.suspend(() => allGood(n - 2)),\n *         (a, b) => a + b\n *       )\n *\n * console.log(Effect.runSync(allGood(32)))\n * // Output: 3524578\n * ```\n *\n * **Example** (Using Effect.suspend to Help TypeScript Infer Types)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //   Without suspend, TypeScript may struggle with type inference.\n * //   Inferred type:\n * //     (a: number, b: number) =>\n * //       Effect<never, Error, never> | Effect<number, never, never>\n * const withoutSuspend = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error(\"Cannot divide by zero\"))\n *     : Effect.succeed(a / b)\n *\n * //   Using suspend to unify return types.\n * //   Inferred type:\n * //     (a: number, b: number) => Effect<number, Error, never>\n * const withSuspend = (a: number, b: number) =>\n *   Effect.suspend(() =>\n *     b === 0\n *       ? Effect.fail(new Error(\"Cannot divide by zero\"))\n *       : Effect.succeed(a / b)\n *   )\n * ```\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R> = core.suspend\n\n/**\n * Creates an `Effect` that represents a synchronous side-effectful computation.\n *\n * **Details**\n *\n * The provided function (`thunk`) must not throw errors; if it does, the error\n * will be treated as a \"defect\".\n *\n * This defect is not a standard error but indicates a flaw in the logic that\n * was expected to be error-free. You can think of it similar to an unexpected\n * crash in the program, which can be further managed or logged using tools like\n * {@link catchAllDefect}.\n *\n * **When to Use**\n *\n * Use this function when you are sure the operation will not fail.\n *\n * **Example** (Logging a Message)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const log = (message: string) =>\n *   Effect.sync(() => {\n *     console.log(message) // side effect\n *   })\n *\n * //       Effect<void, never, never>\n * //      \n * const program = log(\"Hello, World!\")\n * ```\n *\n * @see {@link try_ | try} for a version that can handle failures.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const sync: <A>(thunk: LazyArg<A>) => Effect<A> = core.sync\n\nconst _void: Effect<void> = core.void\n\nexport {\n  /**\n   * Represents an effect that does nothing and produces no value.\n   *\n   * **When to Use**\n   *\n   * Use this effect when you need to represent an effect that does nothing.\n   * This is useful in scenarios where you need to satisfy an effect-based\n   * interface or control program flow without performing any operations. For\n   * example, it can be used in situations where you want to return an effect\n   * from a function but do not need to compute or return any result.\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  _void as void\n}\n\n/**\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const yieldNow: (options?: {\n  readonly priority?: number | undefined\n}) => Effect<void> = core.yieldNow\n\nconst _catch: {\n  <N extends keyof E, K extends E[N] & string, E, A1, E1, R1>(\n    discriminator: N,\n    options: { readonly failure: K; readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect<A1, E1, R1> }\n  ): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { [n in N]: K }>, R1 | R>\n  <A, E, R, N extends keyof E, K extends E[N] & string, A1, E1, R1>(\n    self: Effect<A, E, R>,\n    discriminator: N,\n    options: { readonly failure: K; readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect<A1, E1, R1> }\n  ): Effect<A | A1, E1 | Exclude<E, { [n in N]: K }>, R | R1>\n} = effect._catch\n\nexport {\n  /**\n   * Recovers from a specified error by catching it and handling it with a provided function.\n   *\n   * **Details**\n   *\n   * This function allows you to recover from specific errors that occur during\n   * the execution of an effect. It works by catching a specific type of error\n   * (identified by a discriminator) and then handling it using a provided\n   * handler function. The handler can return a new effect that helps recover\n   * from the error, allowing the program to continue. If the error doesn't\n   * match the specified type, the function allows the original effect to\n   * continue as it was.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * class NetworkError {\n   *   readonly _tag = \"NetworkError\"\n   * }\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * // Simulate an effect that may fail\n   * const task: Effect.Effect<never, NetworkError | ValidationError, never> = Effect.fail(new NetworkError())\n   *\n   * const program = Effect.gen(function*() {\n   *   const result = yield* Effect.catch(task, \"_tag\", {\n   *     failure: \"NetworkError\",\n   *     onFailure: (error) => Effect.succeed(`recovered from error: ${error._tag}`)\n   *   })\n   *   console.log(`Result: ${result}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output: Result: recovered from error: NetworkError\n   * ```\n   *\n   * @see {@link catchTag} for a version that can recover from errors based on a `_tag` discriminator.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  _catch as catch\n}\n\n/**\n * Handles all errors in an effect by providing a fallback effect.\n *\n * **Details**\n *\n * This function catches any errors that may occur during the execution of an\n * effect and allows you to handle them by specifying a fallback effect. This\n * ensures that the program continues without failing by recovering from errors\n * using the provided fallback logic.\n *\n * **Note**: This function only handles recoverable errors. It will not recover\n * from unrecoverable defects.\n *\n * **Example** (Providing Recovery Logic for Recoverable Errors)\n *\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * class HttpError {\n *   readonly _tag = \"HttpError\"\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n * }\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return \"some result\"\n * })\n *\n * //       Effect<string, never, never>\n * //      \n * const recovered = program.pipe(\n *   Effect.catchAll((error) =>\n *     Effect.succeed(`Recovering from ${error._tag}`)\n *   )\n * )\n * ```\n *\n * @see {@link catchAllCause} for a version that can recover from both\n * recoverable and unrecoverable errors.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchAll: {\n  /**\n   * Handles all errors in an effect by providing a fallback effect.\n   *\n   * **Details**\n   *\n   * This function catches any errors that may occur during the execution of an\n   * effect and allows you to handle them by specifying a fallback effect. This\n   * ensures that the program continues without failing by recovering from errors\n   * using the provided fallback logic.\n   *\n   * **Note**: This function only handles recoverable errors. It will not recover\n   * from unrecoverable defects.\n   *\n   * **Example** (Providing Recovery Logic for Recoverable Errors)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, never, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchAll((error) =>\n   *     Effect.succeed(`Recovering from ${error._tag}`)\n   *   )\n   * )\n   * ```\n   *\n   * @see {@link catchAllCause} for a version that can recover from both\n   * recoverable and unrecoverable errors.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>\n  /**\n   * Handles all errors in an effect by providing a fallback effect.\n   *\n   * **Details**\n   *\n   * This function catches any errors that may occur during the execution of an\n   * effect and allows you to handle them by specifying a fallback effect. This\n   * ensures that the program continues without failing by recovering from errors\n   * using the provided fallback logic.\n   *\n   * **Note**: This function only handles recoverable errors. It will not recover\n   * from unrecoverable defects.\n   *\n   * **Example** (Providing Recovery Logic for Recoverable Errors)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, never, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchAll((error) =>\n   *     Effect.succeed(`Recovering from ${error._tag}`)\n   *   )\n   * )\n   * ```\n   *\n   * @see {@link catchAllCause} for a version that can recover from both\n   * recoverable and unrecoverable errors.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>\n} = core.catchAll\n\n/**\n * Handles both recoverable and unrecoverable errors by providing a recovery\n * effect.\n *\n * **When to Use**\n *\n * The `catchAllCause` function allows you to handle all errors, including\n * unrecoverable defects, by providing a recovery effect. The recovery logic is\n * based on the `Cause` of the error, which provides detailed information about\n * the failure.\n *\n * **When to Recover from Defects**\n *\n * Defects are unexpected errors that typically shouldn't be recovered from, as\n * they often indicate serious issues. However, in some cases, such as\n * dynamically loaded plugins, controlled recovery might be needed.\n *\n * **Example** (Recovering from All Errors)\n *\n * ```ts\n * import { Cause, Effect } from \"effect\"\n *\n * // Define an effect that may fail with a recoverable or unrecoverable error\n * const program = Effect.fail(\"Something went wrong!\")\n *\n * // Recover from all errors by examining the cause\n * const recovered = program.pipe(\n *   Effect.catchAllCause((cause) =>\n *     Cause.isFailure(cause)\n *       ? Effect.succeed(\"Recovered from a regular error\")\n *       : Effect.succeed(\"Recovered from a defect\")\n *   )\n * )\n *\n * Effect.runPromise(recovered).then(console.log)\n * // Output: \"Recovered from a regular error\"\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchAllCause: {\n  /**\n   * Handles both recoverable and unrecoverable errors by providing a recovery\n   * effect.\n   *\n   * **When to Use**\n   *\n   * The `catchAllCause` function allows you to handle all errors, including\n   * unrecoverable defects, by providing a recovery effect. The recovery logic is\n   * based on the `Cause` of the error, which provides detailed information about\n   * the failure.\n   *\n   * **When to Recover from Defects**\n   *\n   * Defects are unexpected errors that typically shouldn't be recovered from, as\n   * they often indicate serious issues. However, in some cases, such as\n   * dynamically loaded plugins, controlled recovery might be needed.\n   *\n   * **Example** (Recovering from All Errors)\n   *\n   * ```ts\n   * import { Cause, Effect } from \"effect\"\n   *\n   * // Define an effect that may fail with a recoverable or unrecoverable error\n   * const program = Effect.fail(\"Something went wrong!\")\n   *\n   * // Recover from all errors by examining the cause\n   * const recovered = program.pipe(\n   *   Effect.catchAllCause((cause) =>\n   *     Cause.isFailure(cause)\n   *       ? Effect.succeed(\"Recovered from a regular error\")\n   *       : Effect.succeed(\"Recovered from a defect\")\n   *   )\n   * )\n   *\n   * Effect.runPromise(recovered).then(console.log)\n   * // Output: \"Recovered from a regular error\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, A2, E2, R2>(f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>\n  /**\n   * Handles both recoverable and unrecoverable errors by providing a recovery\n   * effect.\n   *\n   * **When to Use**\n   *\n   * The `catchAllCause` function allows you to handle all errors, including\n   * unrecoverable defects, by providing a recovery effect. The recovery logic is\n   * based on the `Cause` of the error, which provides detailed information about\n   * the failure.\n   *\n   * **When to Recover from Defects**\n   *\n   * Defects are unexpected errors that typically shouldn't be recovered from, as\n   * they often indicate serious issues. However, in some cases, such as\n   * dynamically loaded plugins, controlled recovery might be needed.\n   *\n   * **Example** (Recovering from All Errors)\n   *\n   * ```ts\n   * import { Cause, Effect } from \"effect\"\n   *\n   * // Define an effect that may fail with a recoverable or unrecoverable error\n   * const program = Effect.fail(\"Something went wrong!\")\n   *\n   * // Recover from all errors by examining the cause\n   * const recovered = program.pipe(\n   *   Effect.catchAllCause((cause) =>\n   *     Cause.isFailure(cause)\n   *       ? Effect.succeed(\"Recovered from a regular error\")\n   *       : Effect.succeed(\"Recovered from a defect\")\n   *   )\n   * )\n   *\n   * Effect.runPromise(recovered).then(console.log)\n   * // Output: \"Recovered from a regular error\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>\n} = core.catchAllCause\n\n/**\n * Recovers from all defects using a provided recovery function.\n *\n * **When to Use**\n *\n * There is no sensible way to recover from defects. This method should be used\n * only at the boundary between Effect and an external system, to transmit\n * information on a defect for diagnostic or explanatory purposes.\n *\n * **Details**\n *\n * `catchAllDefect` allows you to handle defects, which are unexpected errors\n * that usually cause the program to terminate. This function lets you recover\n * from these defects by providing a function that handles the error. However,\n * it does not handle expected errors (like those from {@link fail}) or\n * execution interruptions (like those from {@link interrupt}).\n *\n * **When to Recover from Defects**\n *\n * Defects are unexpected errors that typically shouldn't be recovered from, as\n * they often indicate serious issues. However, in some cases, such as\n * dynamically loaded plugins, controlled recovery might be needed.\n *\n * **Example** (Handling All Defects)\n *\n * ```ts\n * import { Effect, Cause, Console } from \"effect\"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage(\"Boom!\")\n *\n * const program = Effect.catchAllDefect(task, (defect) => {\n *   if (Cause.isRuntimeException(defect)) {\n *     return Console.log(\n *       `RuntimeException defect caught: ${defect.message}`\n *     )\n *   }\n *   return Console.log(\"Unknown defect caught.\")\n * })\n *\n * // We get an Exit.Success because we caught all defects\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: \"Exit\",\n * //   _tag: \"Success\",\n * //   value: undefined\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchAllDefect: {\n  /**\n   * Recovers from all defects using a provided recovery function.\n   *\n   * **When to Use**\n   *\n   * There is no sensible way to recover from defects. This method should be used\n   * only at the boundary between Effect and an external system, to transmit\n   * information on a defect for diagnostic or explanatory purposes.\n   *\n   * **Details**\n   *\n   * `catchAllDefect` allows you to handle defects, which are unexpected errors\n   * that usually cause the program to terminate. This function lets you recover\n   * from these defects by providing a function that handles the error. However,\n   * it does not handle expected errors (like those from {@link fail}) or\n   * execution interruptions (like those from {@link interrupt}).\n   *\n   * **When to Recover from Defects**\n   *\n   * Defects are unexpected errors that typically shouldn't be recovered from, as\n   * they often indicate serious issues. However, in some cases, such as\n   * dynamically loaded plugins, controlled recovery might be needed.\n   *\n   * **Example** (Handling All Defects)\n   *\n   * ```ts\n   * import { Effect, Cause, Console } from \"effect\"\n   *\n   * // Simulating a runtime error\n   * const task = Effect.dieMessage(\"Boom!\")\n   *\n   * const program = Effect.catchAllDefect(task, (defect) => {\n   *   if (Cause.isRuntimeException(defect)) {\n   *     return Console.log(\n   *       `RuntimeException defect caught: ${defect.message}`\n   *     )\n   *   }\n   *   return Console.log(\"Unknown defect caught.\")\n   * })\n   *\n   * // We get an Exit.Success because we caught all defects\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // RuntimeException defect caught: Boom!\n   * // {\n   * //   _id: \"Exit\",\n   * //   _tag: \"Success\",\n   * //   value: undefined\n   * // }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>\n  /**\n   * Recovers from all defects using a provided recovery function.\n   *\n   * **When to Use**\n   *\n   * There is no sensible way to recover from defects. This method should be used\n   * only at the boundary between Effect and an external system, to transmit\n   * information on a defect for diagnostic or explanatory purposes.\n   *\n   * **Details**\n   *\n   * `catchAllDefect` allows you to handle defects, which are unexpected errors\n   * that usually cause the program to terminate. This function lets you recover\n   * from these defects by providing a function that handles the error. However,\n   * it does not handle expected errors (like those from {@link fail}) or\n   * execution interruptions (like those from {@link interrupt}).\n   *\n   * **When to Recover from Defects**\n   *\n   * Defects are unexpected errors that typically shouldn't be recovered from, as\n   * they often indicate serious issues. However, in some cases, such as\n   * dynamically loaded plugins, controlled recovery might be needed.\n   *\n   * **Example** (Handling All Defects)\n   *\n   * ```ts\n   * import { Effect, Cause, Console } from \"effect\"\n   *\n   * // Simulating a runtime error\n   * const task = Effect.dieMessage(\"Boom!\")\n   *\n   * const program = Effect.catchAllDefect(task, (defect) => {\n   *   if (Cause.isRuntimeException(defect)) {\n   *     return Console.log(\n   *       `RuntimeException defect caught: ${defect.message}`\n   *     )\n   *   }\n   *   return Console.log(\"Unknown defect caught.\")\n   * })\n   *\n   * // We get an Exit.Success because we caught all defects\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // RuntimeException defect caught: Boom!\n   * // {\n   * //   _id: \"Exit\",\n   * //   _tag: \"Success\",\n   * //   value: undefined\n   * // }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>\n} = effect.catchAllDefect\n\n/**\n * Recovers from specific errors based on a predicate.\n *\n * **When to Use**\n *\n * `catchIf` works similarly to {@link catchSome}, but it allows you to\n * recover from errors by providing a predicate function. If the predicate\n * matches the error, the recovery effect is applied. This function doesn't\n * alter the error type, so the resulting effect still carries the original\n * error type unless a user-defined type guard is used to narrow the type.\n *\n * **Example** (Catching Specific Errors with a Predicate)\n *\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * class HttpError {\n *   readonly _tag = \"HttpError\"\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n * }\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return \"some result\"\n * })\n *\n * //       Effect<string, ValidationError, never>\n * //      \n * const recovered = program.pipe(\n *   Effect.catchIf(\n *     // Only handle HttpError errors\n *     (error) => error._tag === \"HttpError\",\n *     () => Effect.succeed(\"Recovering from HttpError\")\n *   )\n * )\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchIf: {\n  /**\n   * Recovers from specific errors based on a predicate.\n   *\n   * **When to Use**\n   *\n   * `catchIf` works similarly to {@link catchSome}, but it allows you to\n   * recover from errors by providing a predicate function. If the predicate\n   * matches the error, the recovery effect is applied. This function doesn't\n   * alter the error type, so the resulting effect still carries the original\n   * error type unless a user-defined type guard is used to narrow the type.\n   *\n   * **Example** (Catching Specific Errors with a Predicate)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchIf(\n   *     // Only handle HttpError errors\n   *     (error) => error._tag === \"HttpError\",\n   *     () => Effect.succeed(\"Recovering from HttpError\")\n   *   )\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>\n  /**\n   * Recovers from specific errors based on a predicate.\n   *\n   * **When to Use**\n   *\n   * `catchIf` works similarly to {@link catchSome}, but it allows you to\n   * recover from errors by providing a predicate function. If the predicate\n   * matches the error, the recovery effect is applied. This function doesn't\n   * alter the error type, so the resulting effect still carries the original\n   * error type unless a user-defined type guard is used to narrow the type.\n   *\n   * **Example** (Catching Specific Errors with a Predicate)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchIf(\n   *     // Only handle HttpError errors\n   *     (error) => error._tag === \"HttpError\",\n   *     () => Effect.succeed(\"Recovering from HttpError\")\n   *   )\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>\n  /**\n   * Recovers from specific errors based on a predicate.\n   *\n   * **When to Use**\n   *\n   * `catchIf` works similarly to {@link catchSome}, but it allows you to\n   * recover from errors by providing a predicate function. If the predicate\n   * matches the error, the recovery effect is applied. This function doesn't\n   * alter the error type, so the resulting effect still carries the original\n   * error type unless a user-defined type guard is used to narrow the type.\n   *\n   * **Example** (Catching Specific Errors with a Predicate)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchIf(\n   *     // Only handle HttpError errors\n   *     (error) => error._tag === \"HttpError\",\n   *     () => Effect.succeed(\"Recovering from HttpError\")\n   *   )\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, EB extends E, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    refinement: Refinement<E, EB>,\n    f: (e: EB) => Effect<A2, E2, R2>\n  ): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>\n  /**\n   * Recovers from specific errors based on a predicate.\n   *\n   * **When to Use**\n   *\n   * `catchIf` works similarly to {@link catchSome}, but it allows you to\n   * recover from errors by providing a predicate function. If the predicate\n   * matches the error, the recovery effect is applied. This function doesn't\n   * alter the error type, so the resulting effect still carries the original\n   * error type unless a user-defined type guard is used to narrow the type.\n   *\n   * **Example** (Catching Specific Errors with a Predicate)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchIf(\n   *     // Only handle HttpError errors\n   *     (error) => error._tag === \"HttpError\",\n   *     () => Effect.succeed(\"Recovering from HttpError\")\n   *   )\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    predicate: Predicate<E>,\n    f: (e: E) => Effect<A2, E2, R2>\n  ): Effect<A | A2, E | E2, R | R2>\n} = core.catchIf\n\n/**\n * Catches and recovers from specific types of errors, allowing you to attempt\n * recovery only for certain errors.\n *\n * **Details**\n *\n * `catchSome` lets you selectively catch and handle errors of certain\n * types by providing a recovery effect for specific errors. If the error\n * matches a condition, recovery is attempted; if not, it doesn't affect the\n * program. This function doesn't alter the error type, meaning the error type\n * remains the same as in the original effect.\n *\n * **Example** (Handling Specific Errors with Effect.catchSome)\n *\n * ```ts\n * import { Effect, Random, Option } from \"effect\"\n *\n * class HttpError {\n *   readonly _tag = \"HttpError\"\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n * }\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return \"some result\"\n * })\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const recovered = program.pipe(\n *   Effect.catchSome((error) => {\n *     // Only handle HttpError errors\n *     if (error._tag === \"HttpError\") {\n *       return Option.some(Effect.succeed(\"Recovering from HttpError\"))\n *     } else {\n *       return Option.none()\n *     }\n *   })\n * )\n * ```\n *\n * @see {@link catchIf} for a version that allows you to recover from errors based on a predicate.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchSome: {\n  /**\n   * Catches and recovers from specific types of errors, allowing you to attempt\n   * recovery only for certain errors.\n   *\n   * **Details**\n   *\n   * `catchSome` lets you selectively catch and handle errors of certain\n   * types by providing a recovery effect for specific errors. If the error\n   * matches a condition, recovery is attempted; if not, it doesn't affect the\n   * program. This function doesn't alter the error type, meaning the error type\n   * remains the same as in the original effect.\n   *\n   * **Example** (Handling Specific Errors with Effect.catchSome)\n   *\n   * ```ts\n   * import { Effect, Random, Option } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchSome((error) => {\n   *     // Only handle HttpError errors\n   *     if (error._tag === \"HttpError\") {\n   *       return Option.some(Effect.succeed(\"Recovering from HttpError\"))\n   *     } else {\n   *       return Option.none()\n   *     }\n   *   })\n   * )\n   * ```\n   *\n   * @see {@link catchIf} for a version that allows you to recover from errors based on a predicate.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>\n  /**\n   * Catches and recovers from specific types of errors, allowing you to attempt\n   * recovery only for certain errors.\n   *\n   * **Details**\n   *\n   * `catchSome` lets you selectively catch and handle errors of certain\n   * types by providing a recovery effect for specific errors. If the error\n   * matches a condition, recovery is attempted; if not, it doesn't affect the\n   * program. This function doesn't alter the error type, meaning the error type\n   * remains the same as in the original effect.\n   *\n   * **Example** (Handling Specific Errors with Effect.catchSome)\n   *\n   * ```ts\n   * import { Effect, Random, Option } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchSome((error) => {\n   *     // Only handle HttpError errors\n   *     if (error._tag === \"HttpError\") {\n   *       return Option.some(Effect.succeed(\"Recovering from HttpError\"))\n   *     } else {\n   *       return Option.none()\n   *     }\n   *   })\n   * )\n   * ```\n   *\n   * @see {@link catchIf} for a version that allows you to recover from errors based on a predicate.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    pf: (e: NoInfer<E>) => Option.Option<Effect<A2, E2, R2>>\n  ): Effect<A | A2, E | E2, R | R2>\n} = core.catchSome\n\n/**\n * Recovers from specific causes using a provided partial function.\n *\n * @see {@link catchSome} for a version that allows you to recover from errors.\n * @see {@link catchSomeDefect} for a version that allows you to recover from defects.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchSomeCause: {\n  /**\n   * Recovers from specific causes using a provided partial function.\n   *\n   * @see {@link catchSome} for a version that allows you to recover from errors.\n   * @see {@link catchSomeDefect} for a version that allows you to recover from defects.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, A2, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>\n  /**\n   * Recovers from specific causes using a provided partial function.\n   *\n   * @see {@link catchSome} for a version that allows you to recover from errors.\n   * @see {@link catchSomeDefect} for a version that allows you to recover from defects.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>\n  ): Effect<A2 | A, E | E2, R2 | R>\n} = effect.catchSomeCause\n\n/**\n * Recovers from specific defects using a provided partial function.\n *\n * **Details**\n *\n * `catchSomeDefect` allows you to handle specific defects, which are\n * unexpected errors that can cause the program to stop. It uses a partial\n * function to catch only certain defects and ignores others. The function does\n * not handle expected errors (such as those caused by {@link fail}) or\n * interruptions in execution (like those caused by {@link interrupt}).\n *\n * This function provides a way to handle certain types of defects while\n * allowing others to propagate and cause failure in the program.\n *\n * **Note**: There is no sensible way to recover from defects. This method\n * should be used only at the boundary between Effect and an external system, to\n * transmit information on a defect for diagnostic or explanatory purposes.\n *\n * **How the Partial Function Works**\n *\n * The function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n * - It receives the defect as an input.\n * - If the defect matches a specific condition (e.g., a certain error type), the function returns\n *   an `Option.some` containing the recovery logic.\n * - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.\n *\n * **Example** (Handling Specific Defects)\n *\n * ```ts\n * import { Effect, Cause, Option, Console } from \"effect\"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage(\"Boom!\")\n *\n * const program = Effect.catchSomeDefect(task, (defect) => {\n *   if (Cause.isIllegalArgumentException(defect)) {\n *     return Option.some(\n *       Console.log(\n *         `Caught an IllegalArgumentException defect: ${defect.message}`\n *       )\n *     )\n *   }\n *   return Option.none()\n * })\n *\n * // Since we are only catching IllegalArgumentException\n * // we will get an Exit.Failure because we simulated a runtime error.\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Die',\n * //     defect: { _tag: 'RuntimeException' }\n * //   }\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchSomeDefect: {\n  /**\n   * Recovers from specific defects using a provided partial function.\n   *\n   * **Details**\n   *\n   * `catchSomeDefect` allows you to handle specific defects, which are\n   * unexpected errors that can cause the program to stop. It uses a partial\n   * function to catch only certain defects and ignores others. The function does\n   * not handle expected errors (such as those caused by {@link fail}) or\n   * interruptions in execution (like those caused by {@link interrupt}).\n   *\n   * This function provides a way to handle certain types of defects while\n   * allowing others to propagate and cause failure in the program.\n   *\n   * **Note**: There is no sensible way to recover from defects. This method\n   * should be used only at the boundary between Effect and an external system, to\n   * transmit information on a defect for diagnostic or explanatory purposes.\n   *\n   * **How the Partial Function Works**\n   *\n   * The function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n   * - It receives the defect as an input.\n   * - If the defect matches a specific condition (e.g., a certain error type), the function returns\n   *   an `Option.some` containing the recovery logic.\n   * - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.\n   *\n   * **Example** (Handling Specific Defects)\n   *\n   * ```ts\n   * import { Effect, Cause, Option, Console } from \"effect\"\n   *\n   * // Simulating a runtime error\n   * const task = Effect.dieMessage(\"Boom!\")\n   *\n   * const program = Effect.catchSomeDefect(task, (defect) => {\n   *   if (Cause.isIllegalArgumentException(defect)) {\n   *     return Option.some(\n   *       Console.log(\n   *         `Caught an IllegalArgumentException defect: ${defect.message}`\n   *       )\n   *     )\n   *   }\n   *   return Option.none()\n   * })\n   *\n   * // Since we are only catching IllegalArgumentException\n   * // we will get an Exit.Failure because we simulated a runtime error.\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Die',\n   * //     defect: { _tag: 'RuntimeException' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A2, E2, R2>(pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>\n  /**\n   * Recovers from specific defects using a provided partial function.\n   *\n   * **Details**\n   *\n   * `catchSomeDefect` allows you to handle specific defects, which are\n   * unexpected errors that can cause the program to stop. It uses a partial\n   * function to catch only certain defects and ignores others. The function does\n   * not handle expected errors (such as those caused by {@link fail}) or\n   * interruptions in execution (like those caused by {@link interrupt}).\n   *\n   * This function provides a way to handle certain types of defects while\n   * allowing others to propagate and cause failure in the program.\n   *\n   * **Note**: There is no sensible way to recover from defects. This method\n   * should be used only at the boundary between Effect and an external system, to\n   * transmit information on a defect for diagnostic or explanatory purposes.\n   *\n   * **How the Partial Function Works**\n   *\n   * The function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n   * - It receives the defect as an input.\n   * - If the defect matches a specific condition (e.g., a certain error type), the function returns\n   *   an `Option.some` containing the recovery logic.\n   * - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.\n   *\n   * **Example** (Handling Specific Defects)\n   *\n   * ```ts\n   * import { Effect, Cause, Option, Console } from \"effect\"\n   *\n   * // Simulating a runtime error\n   * const task = Effect.dieMessage(\"Boom!\")\n   *\n   * const program = Effect.catchSomeDefect(task, (defect) => {\n   *   if (Cause.isIllegalArgumentException(defect)) {\n   *     return Option.some(\n   *       Console.log(\n   *         `Caught an IllegalArgumentException defect: ${defect.message}`\n   *       )\n   *     )\n   *   }\n   *   return Option.none()\n   * })\n   *\n   * // Since we are only catching IllegalArgumentException\n   * // we will get an Exit.Failure because we simulated a runtime error.\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Die',\n   * //     defect: { _tag: 'RuntimeException' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>\n  ): Effect<A | A2, E | E2, R | R2>\n} = effect.catchSomeDefect\n\n/**\n * Catches and handles specific errors by their `_tag` field, which is used as a\n * discriminator.\n *\n * **When to Use**\n *\n * `catchTag` is useful when your errors are tagged with a readonly `_tag` field\n * that identifies the error type. You can use this function to handle specific\n * error types by matching the `_tag` value. This allows for precise error\n * handling, ensuring that only specific errors are caught and handled.\n *\n * The error type must have a readonly `_tag` field to use `catchTag`. This\n * field is used to identify and match errors.\n *\n * **Example** (Handling Errors by Tag)\n *\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * class HttpError {\n *   readonly _tag = \"HttpError\"\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n * }\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return \"some result\"\n * })\n *\n * //       Effect<string, ValidationError, never>\n * //      \n * const recovered = program.pipe(\n *   // Only handle HttpError errors\n *   Effect.catchTag(\"HttpError\", (_HttpError) =>\n *     Effect.succeed(\"Recovering from HttpError\")\n *   )\n * )\n * ```\n *\n * @see {@link catchTags} for a version that allows you to handle multiple error\n * types at once.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchTag: {\n  /**\n   * Catches and handles specific errors by their `_tag` field, which is used as a\n   * discriminator.\n   *\n   * **When to Use**\n   *\n   * `catchTag` is useful when your errors are tagged with a readonly `_tag` field\n   * that identifies the error type. You can use this function to handle specific\n   * error types by matching the `_tag` value. This allows for precise error\n   * handling, ensuring that only specific errors are caught and handled.\n   *\n   * The error type must have a readonly `_tag` field to use `catchTag`. This\n   * field is used to identify and match errors.\n   *\n   * **Example** (Handling Errors by Tag)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   // Only handle HttpError errors\n   *   Effect.catchTag(\"HttpError\", (_HttpError) =>\n   *     Effect.succeed(\"Recovering from HttpError\")\n   *   )\n   * )\n   * ```\n   *\n   * @see {@link catchTags} for a version that allows you to handle multiple error\n   * types at once.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>, A1, E1, R1>(\n    ...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number] }>) => Effect<A1, E1, R1>]\n  ): <A, R>(self: Effect<A, E, R>) => Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1>\n  /**\n   * Catches and handles specific errors by their `_tag` field, which is used as a\n   * discriminator.\n   *\n   * **When to Use**\n   *\n   * `catchTag` is useful when your errors are tagged with a readonly `_tag` field\n   * that identifies the error type. You can use this function to handle specific\n   * error types by matching the `_tag` value. This allows for precise error\n   * handling, ensuring that only specific errors are caught and handled.\n   *\n   * The error type must have a readonly `_tag` field to use `catchTag`. This\n   * field is used to identify and match errors.\n   *\n   * **Example** (Handling Errors by Tag)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, ValidationError, never>\n   * //      \n   * const recovered = program.pipe(\n   *   // Only handle HttpError errors\n   *   Effect.catchTag(\"HttpError\", (_HttpError) =>\n   *     Effect.succeed(\"Recovering from HttpError\")\n   *   )\n   * )\n   * ```\n   *\n   * @see {@link catchTags} for a version that allows you to handle multiple error\n   * types at once.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>, A1, E1, R1>(\n    self: Effect<A, E, R>,\n    ...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number] }>) => Effect<A1, E1, R1>]\n  ): Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1>\n} = effect.catchTag\n\n/**\n * Handles multiple errors in a single block of code using their `_tag` field.\n *\n * **When to Use**\n *\n * `catchTags` is a convenient way to handle multiple error types at\n * once. Instead of using {@link catchTag} multiple times, you can pass an\n * object where each key is an error type's `_tag`, and the value is the handler\n * for that specific error. This allows you to catch and recover from multiple\n * error types in a single call.\n *\n * The error type must have a readonly `_tag` field to use `catchTag`. This\n * field is used to identify and match errors.\n *\n * **Example** (Handling Multiple Tagged Error Types at Once)\n *\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * class HttpError {\n *   readonly _tag = \"HttpError\"\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n * }\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return \"some result\"\n * })\n *\n * //       Effect<string, never, never>\n * //      \n * const recovered = program.pipe(\n *   Effect.catchTags({\n *     HttpError: (_HttpError) =>\n *       Effect.succeed(`Recovering from HttpError`),\n *     ValidationError: (_ValidationError) =>\n *       Effect.succeed(`Recovering from ValidationError`)\n *   })\n * )\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const catchTags: {\n  /**\n   * Handles multiple errors in a single block of code using their `_tag` field.\n   *\n   * **When to Use**\n   *\n   * `catchTags` is a convenient way to handle multiple error types at\n   * once. Instead of using {@link catchTag} multiple times, you can pass an\n   * object where each key is an error type's `_tag`, and the value is the handler\n   * for that specific error. This allows you to catch and recover from multiple\n   * error types in a single call.\n   *\n   * The error type must have a readonly `_tag` field to use `catchTag`. This\n   * field is used to identify and match errors.\n   *\n   * **Example** (Handling Multiple Tagged Error Types at Once)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, never, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchTags({\n   *     HttpError: (_HttpError) =>\n   *       Effect.succeed(`Recovering from HttpError`),\n   *     ValidationError: (_ValidationError) =>\n   *       Effect.succeed(`Recovering from ValidationError`)\n   *   })\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <\n    E,\n    Cases extends\n      & { [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K }>) => Effect<any, any, any>) }\n      & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>[\"_tag\"]>]: never })\n  >(cases: Cases): <A, R>(\n    self: Effect<A, E, R>\n  ) => Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never\n    }[keyof Cases]\n  >\n  /**\n   * Handles multiple errors in a single block of code using their `_tag` field.\n   *\n   * **When to Use**\n   *\n   * `catchTags` is a convenient way to handle multiple error types at\n   * once. Instead of using {@link catchTag} multiple times, you can pass an\n   * object where each key is an error type's `_tag`, and the value is the handler\n   * for that specific error. This allows you to catch and recover from multiple\n   * error types in a single call.\n   *\n   * The error type must have a readonly `_tag` field to use `catchTag`. This\n   * field is used to identify and match errors.\n   *\n   * **Example** (Handling Multiple Tagged Error Types at Once)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * class HttpError {\n   *   readonly _tag = \"HttpError\"\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   * }\n   *\n   * //       Effect<string, HttpError | ValidationError, never>\n   * //      \n   * const program = Effect.gen(function* () {\n   *   const n1 = yield* Random.next\n   *   const n2 = yield* Random.next\n   *   if (n1 < 0.5) {\n   *     yield* Effect.fail(new HttpError())\n   *   }\n   *   if (n2 < 0.5) {\n   *     yield* Effect.fail(new ValidationError())\n   *   }\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, never, never>\n   * //      \n   * const recovered = program.pipe(\n   *   Effect.catchTags({\n   *     HttpError: (_HttpError) =>\n   *       Effect.succeed(`Recovering from HttpError`),\n   *     ValidationError: (_ValidationError) =>\n   *       Effect.succeed(`Recovering from ValidationError`)\n   *   })\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <\n    R,\n    E,\n    A,\n    Cases extends\n      & { [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: ((error: Extract<E, { _tag: K }>) => Effect<any, any, any>) }\n      & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>[\"_tag\"]>]: never })\n  >(self: Effect<A, E, R>, cases: Cases): Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never\n    }[keyof Cases]\n  >\n} = effect.catchTags\n\n/**\n * Retrieves the cause of a failure in an effect.\n *\n * **Details**\n *\n * This function allows you to expose the detailed cause of an effect, which\n * includes a more precise representation of failures, such as error messages\n * and defects.\n *\n * **When to Use**\n *\n * This function is helpful when you need to inspect the cause of a failure in\n * an effect, giving you more information than just the error message. It can be\n * used to log, handle, or analyze failures in more detail, including\n * distinguishing between different types of defects (e.g., runtime exceptions,\n * interruptions, etc.).\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<number, string, never>\n * //      \n * const program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n *\n * //       Effect<void, never, never>\n * //      \n * const recovered = Effect.gen(function* () {\n *   const cause = yield* Effect.cause(program)\n *   yield* Console.log(cause)\n * })\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R> = effect.cause\n\n/**\n * Runs an effect repeatedly until it succeeds, ignoring errors.\n *\n * **Details**\n *\n * This function takes an effect and runs it repeatedly until the effect\n * successfully completes. If the effect fails, it will ignore the error and\n * retry the operation. This is useful when you need to perform a task that may\n * fail occasionally, but you want to keep trying until it eventually succeeds.\n * It works by repeatedly executing the effect until it no longer throws an\n * error.\n *\n * **When to Use**\n *\n * Use this function when you want to retry an operation multiple times until it\n * succeeds. It is helpful in cases where the operation may fail temporarily\n * (e.g., a network request), and you want to keep trying without handling or\n * worrying about the errors.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * let counter = 0\n *\n * const effect = Effect.try(() => {\n *   counter++\n *   if (counter < 3) {\n *     console.log(\"running effect\")\n *     throw new Error(\"error\")\n *   } else {\n *     console.log(\"effect done\")\n *     return \"some result\"\n *   }\n * })\n *\n * const program = Effect.eventually(effect)\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // running effect\n * // running effect\n * // effect done\n * // some result\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R> = effect.eventually\n\n/**\n * Discards both the success and failure values of an effect.\n *\n * **When to Use**\n *\n * `ignore` allows you to run an effect without caring about its result, whether\n * it succeeds or fails. This is useful when you only care about the side\n * effects of the effect and do not need to handle or process its outcome.\n *\n * **Example** (Using Effect.ignore to Discard Values)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, string, never>\n * //      \n * const task = Effect.fail(\"Uh oh!\").pipe(Effect.as(5))\n *\n * //       Effect<void, never, never>\n * //      \n * const program = Effect.ignore(task)\n * ```\n *\n * @see {@link ignoreLogged} to log failures while ignoring them.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R> = effect.ignore\n\n/**\n * Ignores the result of an effect but logs any failures.\n *\n * **Details**\n *\n * This function takes an effect and returns a new effect that ignores whether\n * the original effect succeeds or fails. However, if the effect fails, it will\n * log the failure at the Debug level, so you can keep track of any issues that\n * arise.\n *\n * **When to Use**\n *\n * This is useful in scenarios where you want to continue with your program\n * regardless of the result of the effect, but you still want to be aware of\n * potential failures that may need attention later.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R> = effect.ignoreLogged\n\n/**\n * Combines all errors from concurrent operations into a single error.\n *\n * **Details**\n *\n * This function is used when you have multiple operations running at the same\n * time, and you want to capture all the errors that occur across those\n * operations. Instead of handling each error separately, it combines all the\n * errors into one unified error.\n *\n * **When to Use**\n *\n * When using this function, any errors that occur in the concurrently running\n * operations will be grouped together into a single error. This helps simplify\n * error handling in cases where you don't need to differentiate between each\n * failure, but simply want to know that multiple failures occurred.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const fail1 = Effect.fail(\"Oh uh!\")\n * const fail2 = Effect.fail(\"Oh no!\")\n * const die = Effect.dieMessage(\"Boom!\")\n *\n * // Run all effects concurrently and capture all errors\n * const program = Effect.all([fail1, fail2, die], {\n *   concurrency: \"unbounded\"\n * }).pipe(Effect.asVoid, Effect.parallelErrors)\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R> = effect.parallelErrors\n\n/**\n * Transforms an effect to expose detailed error causes.\n *\n * **Details**\n *\n * This function enhances an effect by providing detailed information about any\n * error, defect, or interruption that may occur during its execution. It\n * modifies the error channel of the effect so that it includes a full cause of\n * the failure, wrapped in a `Cause<E>` type.\n *\n * After applying this function, you can use operators like {@link catchAll} and\n * {@link catchTags} to handle specific types of errors.\n *\n * If you no longer need the detailed cause information, you can revert the\n * changes using {@link unsandbox} to return to the original error-handling\n * behavior.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<string, Error, never>\n * //      \n * const task = Effect.fail(new Error(\"Oh uh!\")).pipe(\n *   Effect.as(\"primary result\")\n * )\n *\n * //       Effect<string, Cause<Error>, never>\n * //      \n * const sandboxed = Effect.sandbox(task)\n *\n * const program = Effect.catchTags(sandboxed, {\n *   Die: (cause) =>\n *     Console.log(`Caught a defect: ${cause.defect}`).pipe(\n *       Effect.as(\"fallback result on defect\")\n *     ),\n *   Interrupt: (cause) =>\n *     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n *       Effect.as(\"fallback result on fiber interruption\")\n *     ),\n *   Fail: (cause) =>\n *     Console.log(`Caught a defect: ${cause.error}`).pipe(\n *       Effect.as(\"fallback result on failure\")\n *     )\n * })\n *\n * // Restore the original error handling with unsandbox\n * const main = Effect.unsandbox(program)\n *\n * Effect.runPromise(main).then(console.log)\n * // Output:\n * // Caught a defect: Oh uh!\n * // fallback result on failure\n * ```\n *\n * @see {@link unsandbox} to restore the original error handling.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R> = effect.sandbox\n\n/**\n * @since 2.0.0\n * @category Error handling\n */\nexport declare namespace Retry {\n  /**\n   * @since 2.0.0\n   * @category Error handling\n   */\n  export type Return<R, E, A, O extends NoExcessProperties<Options<E>, O>> = Effect<\n    A,\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer _R> } ? E\n      : O extends { until: Refinement<E, infer E2> } ? E2\n      : E)\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never),\n    | R\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R> } ? R : never)\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n  > extends infer Z ? Z : never\n\n  /**\n   * @since 2.0.0\n   * @category Error handling\n   */\n  export interface Options<E> {\n    while?: ((error: E) => boolean | Effect<boolean, any, any>) | undefined\n    until?: ((error: E) => boolean | Effect<boolean, any, any>) | undefined\n    times?: number | undefined\n    schedule?: Schedule.Schedule<any, E, any> | undefined\n  }\n}\n\n/**\n * Retries a failing effect based on a defined retry policy.\n *\n * **Details**\n *\n * The `Effect.retry` function takes an effect and a {@link Schedule} policy,\n * and will automatically retry the effect if it fails, following the rules of\n * the policy.\n *\n * If the effect ultimately succeeds, the result will be returned.\n *\n * If the maximum retries are exhausted and the effect still fails, the failure\n * is propagated.\n *\n * **When to Use**\n *\n * This can be useful when dealing with intermittent failures, such as network\n * issues or temporary resource unavailability. By defining a retry policy, you\n * can control the number of retries, the delay between them, and when to stop\n * retrying.\n *\n * **Example** (Retrying with a Fixed Delay)\n *\n * ```ts\n * import { Effect, Schedule } from \"effect\"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log(\"failure\")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log(\"success\")\n *     resume(Effect.succeed(\"yay!\"))\n *   }\n * })\n *\n * // Define a repetition policy using a fixed delay between retries\n * const policy = Schedule.fixed(\"100 millis\")\n *\n * const repeated = Effect.retry(task, policy)\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * // yay!\n * ```\n *\n * **Example** (Retrying a Task up to 5 times)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log(\"failure\")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log(\"success\")\n *     resume(Effect.succeed(\"yay!\"))\n *   }\n * })\n *\n * // Retry the task up to 5 times\n * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * ```\n *\n * **Example** (Retrying Until a Specific Condition is Met)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * let count = 0\n *\n * // Define an effect that simulates varying error on each invocation\n * const action = Effect.failSync(() => {\n *   console.log(`Action called ${++count} time(s)`)\n *   return `Error ${count}`\n * })\n *\n * // Retry the action until a specific condition is met\n * const program = Effect.retry(action, {\n *   until: (err) => err === \"Error 3\"\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Action called 1 time(s)\n * // Action called 2 time(s)\n * // Action called 3 time(s)\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n * // }\n * ```\n *\n * @see {@link retryOrElse} for a version that allows you to run a fallback.\n * @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const retry: {\n  /**\n   * Retries a failing effect based on a defined retry policy.\n   *\n   * **Details**\n   *\n   * The `Effect.retry` function takes an effect and a {@link Schedule} policy,\n   * and will automatically retry the effect if it fails, following the rules of\n   * the policy.\n   *\n   * If the effect ultimately succeeds, the result will be returned.\n   *\n   * If the maximum retries are exhausted and the effect still fails, the failure\n   * is propagated.\n   *\n   * **When to Use**\n   *\n   * This can be useful when dealing with intermittent failures, such as network\n   * issues or temporary resource unavailability. By defining a retry policy, you\n   * can control the number of retries, the delay between them, and when to stop\n   * retrying.\n   *\n   * **Example** (Retrying with a Fixed Delay)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Define a repetition policy using a fixed delay between retries\n   * const policy = Schedule.fixed(\"100 millis\")\n   *\n   * const repeated = Effect.retry(task, policy)\n   *\n   * Effect.runPromise(repeated).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * // yay!\n   * ```\n   *\n   * **Example** (Retrying a Task up to 5 times)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Retry the task up to 5 times\n   * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * ```\n   *\n   * **Example** (Retrying Until a Specific Condition is Met)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an effect that simulates varying error on each invocation\n   * const action = Effect.failSync(() => {\n   *   console.log(`Action called ${++count} time(s)`)\n   *   return `Error ${count}`\n   * })\n   *\n   * // Retry the action until a specific condition is met\n   * const program = Effect.retry(action, {\n   *   until: (err) => err === \"Error 3\"\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Action called 1 time(s)\n   * // Action called 2 time(s)\n   * // Action called 3 time(s)\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n   * // }\n   * ```\n   *\n   * @see {@link retryOrElse} for a version that allows you to run a fallback.\n   * @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>\n  /**\n   * Retries a failing effect based on a defined retry policy.\n   *\n   * **Details**\n   *\n   * The `Effect.retry` function takes an effect and a {@link Schedule} policy,\n   * and will automatically retry the effect if it fails, following the rules of\n   * the policy.\n   *\n   * If the effect ultimately succeeds, the result will be returned.\n   *\n   * If the maximum retries are exhausted and the effect still fails, the failure\n   * is propagated.\n   *\n   * **When to Use**\n   *\n   * This can be useful when dealing with intermittent failures, such as network\n   * issues or temporary resource unavailability. By defining a retry policy, you\n   * can control the number of retries, the delay between them, and when to stop\n   * retrying.\n   *\n   * **Example** (Retrying with a Fixed Delay)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Define a repetition policy using a fixed delay between retries\n   * const policy = Schedule.fixed(\"100 millis\")\n   *\n   * const repeated = Effect.retry(task, policy)\n   *\n   * Effect.runPromise(repeated).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * // yay!\n   * ```\n   *\n   * **Example** (Retrying a Task up to 5 times)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Retry the task up to 5 times\n   * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * ```\n   *\n   * **Example** (Retrying Until a Specific Condition is Met)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an effect that simulates varying error on each invocation\n   * const action = Effect.failSync(() => {\n   *   console.log(`Action called ${++count} time(s)`)\n   *   return `Error ${count}`\n   * })\n   *\n   * // Retry the action until a specific condition is met\n   * const program = Effect.retry(action, {\n   *   until: (err) => err === \"Error 3\"\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Action called 1 time(s)\n   * // Action called 2 time(s)\n   * // Action called 3 time(s)\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n   * // }\n   * ```\n   *\n   * @see {@link retryOrElse} for a version that allows you to run a fallback.\n   * @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>\n  /**\n   * Retries a failing effect based on a defined retry policy.\n   *\n   * **Details**\n   *\n   * The `Effect.retry` function takes an effect and a {@link Schedule} policy,\n   * and will automatically retry the effect if it fails, following the rules of\n   * the policy.\n   *\n   * If the effect ultimately succeeds, the result will be returned.\n   *\n   * If the maximum retries are exhausted and the effect still fails, the failure\n   * is propagated.\n   *\n   * **When to Use**\n   *\n   * This can be useful when dealing with intermittent failures, such as network\n   * issues or temporary resource unavailability. By defining a retry policy, you\n   * can control the number of retries, the delay between them, and when to stop\n   * retrying.\n   *\n   * **Example** (Retrying with a Fixed Delay)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Define a repetition policy using a fixed delay between retries\n   * const policy = Schedule.fixed(\"100 millis\")\n   *\n   * const repeated = Effect.retry(task, policy)\n   *\n   * Effect.runPromise(repeated).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * // yay!\n   * ```\n   *\n   * **Example** (Retrying a Task up to 5 times)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Retry the task up to 5 times\n   * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * ```\n   *\n   * **Example** (Retrying Until a Specific Condition is Met)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an effect that simulates varying error on each invocation\n   * const action = Effect.failSync(() => {\n   *   console.log(`Action called ${++count} time(s)`)\n   *   return `Error ${count}`\n   * })\n   *\n   * // Retry the action until a specific condition is met\n   * const program = Effect.retry(action, {\n   *   until: (err) => err === \"Error 3\"\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Action called 1 time(s)\n   * // Action called 2 time(s)\n   * // Action called 3 time(s)\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n   * // }\n   * ```\n   *\n   * @see {@link retryOrElse} for a version that allows you to run a fallback.\n   * @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>\n  /**\n   * Retries a failing effect based on a defined retry policy.\n   *\n   * **Details**\n   *\n   * The `Effect.retry` function takes an effect and a {@link Schedule} policy,\n   * and will automatically retry the effect if it fails, following the rules of\n   * the policy.\n   *\n   * If the effect ultimately succeeds, the result will be returned.\n   *\n   * If the maximum retries are exhausted and the effect still fails, the failure\n   * is propagated.\n   *\n   * **When to Use**\n   *\n   * This can be useful when dealing with intermittent failures, such as network\n   * issues or temporary resource unavailability. By defining a retry policy, you\n   * can control the number of retries, the delay between them, and when to stop\n   * retrying.\n   *\n   * **Example** (Retrying with a Fixed Delay)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Define a repetition policy using a fixed delay between retries\n   * const policy = Schedule.fixed(\"100 millis\")\n   *\n   * const repeated = Effect.retry(task, policy)\n   *\n   * Effect.runPromise(repeated).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * // yay!\n   * ```\n   *\n   * **Example** (Retrying a Task up to 5 times)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Retry the task up to 5 times\n   * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // success\n   * ```\n   *\n   * **Example** (Retrying Until a Specific Condition is Met)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an effect that simulates varying error on each invocation\n   * const action = Effect.failSync(() => {\n   *   console.log(`Action called ${++count} time(s)`)\n   *   return `Error ${count}`\n   * })\n   *\n   * // Retry the action until a specific condition is met\n   * const program = Effect.retry(action, {\n   *   until: (err) => err === \"Error 3\"\n   * })\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Action called 1 time(s)\n   * // Action called 2 time(s)\n   * // Action called 3 time(s)\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n   * // }\n   * ```\n   *\n   * @see {@link retryOrElse} for a version that allows you to run a fallback.\n   * @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, NoInfer<E>, R1>): Effect<A, E, R1 | R>\n} = schedule_.retry_combined\n\n/**\n * Apply an `ExecutionPlan` to the effect, which allows you to fallback to\n * different resources in case of failure.\n *\n * @since 3.16.0\n * @category Error handling\n * @experimental\n */\nexport const withExecutionPlan: {\n  /**\n   * Apply an `ExecutionPlan` to the effect, which allows you to fallback to\n   * different resources in case of failure.\n   *\n   * @since 3.16.0\n   * @category Error handling\n   * @experimental\n   */\n  <Input, Provides, PlanE, PlanR>(\n    plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR }>\n  ): <A, E extends Input, R>(effect: Effect<A, E, R>) => Effect<A, E | PlanE, Exclude<R, Provides> | PlanR>\n  /**\n   * Apply an `ExecutionPlan` to the effect, which allows you to fallback to\n   * different resources in case of failure.\n   *\n   * @since 3.16.0\n   * @category Error handling\n   * @experimental\n   */\n  <A, E extends Input, R, Provides, Input, PlanE, PlanR>(\n    effect: Effect<A, E, R>,\n    plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR }>\n  ): Effect<A, E | PlanE, Exclude<R, Provides> | PlanR>\n} = internalExecutionPlan.withExecutionPlan\n\n/**\n * Retries a failing effect and runs a fallback effect if retries are exhausted.\n *\n * **Details**\n *\n * The `Effect.retryOrElse` function attempts to retry a failing effect multiple\n * times according to a defined {@link Schedule} policy.\n *\n * If the retries are exhausted and the effect still fails, it runs a fallback\n * effect instead.\n *\n * **When to Use**\n *\n * This function is useful when you want to handle failures gracefully by\n * specifying an alternative action after repeated failures.\n *\n * **Example** (Retrying with Fallback)\n *\n * ```ts\n * import { Effect, Schedule, Console } from \"effect\"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log(\"failure\")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log(\"success\")\n *     resume(Effect.succeed(\"yay!\"))\n *   }\n * })\n *\n * // Retry the task with a delay between retries and a maximum of 2 retries\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n *\n * // If all retries fail, run the fallback effect\n * const repeated = Effect.retryOrElse(\n *   task,\n *   policy,\n *   // fallback\n *   () => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n * )\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // orElse\n * // default value\n * ```\n *\n * @see {@link retry} for a version that does not run a fallback effect.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const retryOrElse: {\n  /**\n   * Retries a failing effect and runs a fallback effect if retries are exhausted.\n   *\n   * **Details**\n   *\n   * The `Effect.retryOrElse` function attempts to retry a failing effect multiple\n   * times according to a defined {@link Schedule} policy.\n   *\n   * If the retries are exhausted and the effect still fails, it runs a fallback\n   * effect instead.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you want to handle failures gracefully by\n   * specifying an alternative action after repeated failures.\n   *\n   * **Example** (Retrying with Fallback)\n   *\n   * ```ts\n   * import { Effect, Schedule, Console } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Retry the task with a delay between retries and a maximum of 2 retries\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   *\n   * // If all retries fail, run the fallback effect\n   * const repeated = Effect.retryOrElse(\n   *   task,\n   *   policy,\n   *   // fallback\n   *   () => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n   * )\n   *\n   * Effect.runPromise(repeated).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // orElse\n   * // default value\n   * ```\n   *\n   * @see {@link retry} for a version that does not run a fallback effect.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A1, E, R1, A2, E2, R2>(\n    policy: Schedule.Schedule<A1, NoInfer<E>, R1>,\n    orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>\n  ): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>\n  /**\n   * Retries a failing effect and runs a fallback effect if retries are exhausted.\n   *\n   * **Details**\n   *\n   * The `Effect.retryOrElse` function attempts to retry a failing effect multiple\n   * times according to a defined {@link Schedule} policy.\n   *\n   * If the retries are exhausted and the effect still fails, it runs a fallback\n   * effect instead.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you want to handle failures gracefully by\n   * specifying an alternative action after repeated failures.\n   *\n   * **Example** (Retrying with Fallback)\n   *\n   * ```ts\n   * import { Effect, Schedule, Console } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Simulates an effect with possible failures\n   * const task = Effect.async<string, Error>((resume) => {\n   *   if (count <= 2) {\n   *     count++\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(new Error()))\n   *   } else {\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * // Retry the task with a delay between retries and a maximum of 2 retries\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   *\n   * // If all retries fail, run the fallback effect\n   * const repeated = Effect.retryOrElse(\n   *   task,\n   *   policy,\n   *   // fallback\n   *   () => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n   * )\n   *\n   * Effect.runPromise(repeated).then(console.log)\n   * // Output:\n   * // failure\n   * // failure\n   * // failure\n   * // orElse\n   * // default value\n   * ```\n   *\n   * @see {@link retry} for a version that does not run a fallback effect.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, A1, R1, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    policy: Schedule.Schedule<A1, NoInfer<E>, R1>,\n    orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>\n  ): Effect<A | A2, E2, R | R1 | R2>\n} = schedule_.retryOrElse_Effect\n\nconst try_: {\n  <A, E>(options: { readonly try: LazyArg<A>; readonly catch: (error: unknown) => E }): Effect<A, E>\n  <A>(thunk: LazyArg<A>): Effect<A, Cause.UnknownException>\n} = effect.try_\n\nexport {\n  /**\n   * Creates an `Effect` that represents a synchronous computation that might\n   * fail.\n   *\n   * **When to Use**\n   *\n   * In situations where you need to perform synchronous operations that might\n   * fail, such as parsing JSON, you can use the `try` constructor. This\n   * constructor is designed to handle operations that could throw exceptions by\n   * capturing those exceptions and transforming them into manageable errors.\n   *\n   * **Error Handling**\n   *\n   * There are two ways to handle errors with `try`:\n   *\n   * 1. If you don't provide a `catch` function, the error is caught and the\n   *    effect fails with an `UnknownException`.\n   * 2. If you provide a `catch` function, the error is caught and the `catch`\n   *    function maps it to an error of type `E`.\n   *\n   * **Example** (Safe JSON Parsing)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const parse = (input: string) =>\n   *   // This might throw an error if input is not valid JSON\n   *   Effect.try(() => JSON.parse(input))\n   *\n   * //       Effect<any, UnknownException, never>\n   * //      \n   * const program = parse(\"\")\n   *\n   * ```\n   *\n   * **Example** (Custom Error Handling)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const parse = (input: string) =>\n   *   Effect.try({\n   *     // JSON.parse may throw for bad input\n   *     try: () => JSON.parse(input),\n   *     // remap the error\n   *     catch: (unknown) => new Error(`something went wrong ${unknown}`)\n   *   })\n   *\n   * //       Effect<any, Error, never>\n   * //      \n   * const program = parse(\"\")\n   * ```\n   *\n   * @see {@link sync} if the effectful computation is synchronous and does not\n   * throw errors.\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  try_ as try\n}\n\n/**\n * Returns an effect that maps its success using the specified side-effecting\n * `try` function, converting any errors into typed failed effects using the\n * `catch` function.\n *\n * @see {@link tryPromise} for a version that works with asynchronous computations.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const tryMap: {\n  /**\n   * Returns an effect that maps its success using the specified side-effecting\n   * `try` function, converting any errors into typed failed effects using the\n   * `catch` function.\n   *\n   * @see {@link tryPromise} for a version that works with asynchronous computations.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, B, E1>(\n    options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1 }\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>\n  /**\n   * Returns an effect that maps its success using the specified side-effecting\n   * `try` function, converting any errors into typed failed effects using the\n   * `catch` function.\n   *\n   * @see {@link tryPromise} for a version that works with asynchronous computations.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, B, E1>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ): Effect<B, E | E1, R>\n} = effect.tryMap\n\n/**\n * Returns an effect that maps its success using the specified side-effecting\n * `try` function, converting any promise rejections into typed failed effects\n * using the `catch` function.\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped `Promise` API.\n *\n * @see {@link tryMap} for a version that works with synchronous computations.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const tryMapPromise: {\n  /**\n   * Returns an effect that maps its success using the specified side-effecting\n   * `try` function, converting any promise rejections into typed failed effects\n   * using the `catch` function.\n   *\n   * An optional `AbortSignal` can be provided to allow for interruption of the\n   * wrapped `Promise` API.\n   *\n   * @see {@link tryMap} for a version that works with synchronous computations.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, B, E1>(\n    options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1 }\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>\n  /**\n   * Returns an effect that maps its success using the specified side-effecting\n   * `try` function, converting any promise rejections into typed failed effects\n   * using the `catch` function.\n   *\n   * An optional `AbortSignal` can be provided to allow for interruption of the\n   * wrapped `Promise` API.\n   *\n   * @see {@link tryMap} for a version that works with synchronous computations.\n   *\n   * @since 2.0.0\n   * @category Error handling\n   */\n  <A, E, R, B, E1>(\n    self: Effect<A, E, R>,\n    options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1 }\n  ): Effect<B, E | E1, R>\n} = effect.tryMapPromise\n\n/**\n * Creates an `Effect` that represents an asynchronous computation that might\n * fail.\n *\n * **When to Use**\n *\n * In situations where you need to perform asynchronous operations that might\n * fail, such as fetching data from an API, you can use the `tryPromise`\n * constructor. This constructor is designed to handle operations that could\n * throw exceptions by capturing those exceptions and transforming them into\n * manageable errors.\n *\n * **Error Handling**\n *\n * There are two ways to handle errors with `tryPromise`:\n *\n * 1. If you don't provide a `catch` function, the error is caught and the\n *    effect fails with an `UnknownException`.\n * 2. If you provide a `catch` function, the error is caught and the `catch`\n *    function maps it to an error of type `E`.\n *\n * **Interruptions**\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped `Promise` API.\n *\n * **Example** (Fetching a TODO Item)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const getTodo = (id: number) =>\n *   // Will catch any errors and propagate them as UnknownException\n *   Effect.tryPromise(() =>\n *     fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n *   )\n *\n * //       Effect<Response, UnknownException, never>\n * //      \n * const program = getTodo(1)\n * ```\n *\n * **Example** (Custom Error Handling)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const getTodo = (id: number) =>\n *   Effect.tryPromise({\n *     try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n *     // remap the error\n *     catch: (unknown) => new Error(`something went wrong ${unknown}`)\n *   })\n *\n * //       Effect<Response, Error, never>\n * //      \n * const program = getTodo(1)\n * ```\n *\n * @see {@link promise} if the effectful computation is asynchronous and does not throw errors.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const tryPromise: {\n  /**\n   * Creates an `Effect` that represents an asynchronous computation that might\n   * fail.\n   *\n   * **When to Use**\n   *\n   * In situations where you need to perform asynchronous operations that might\n   * fail, such as fetching data from an API, you can use the `tryPromise`\n   * constructor. This constructor is designed to handle operations that could\n   * throw exceptions by capturing those exceptions and transforming them into\n   * manageable errors.\n   *\n   * **Error Handling**\n   *\n   * There are two ways to handle errors with `tryPromise`:\n   *\n   * 1. If you don't provide a `catch` function, the error is caught and the\n   *    effect fails with an `UnknownException`.\n   * 2. If you provide a `catch` function, the error is caught and the `catch`\n   *    function maps it to an error of type `E`.\n   *\n   * **Interruptions**\n   *\n   * An optional `AbortSignal` can be provided to allow for interruption of the\n   * wrapped `Promise` API.\n   *\n   * **Example** (Fetching a TODO Item)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const getTodo = (id: number) =>\n   *   // Will catch any errors and propagate them as UnknownException\n   *   Effect.tryPromise(() =>\n   *     fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n   *   )\n   *\n   * //       Effect<Response, UnknownException, never>\n   * //      \n   * const program = getTodo(1)\n   * ```\n   *\n   * **Example** (Custom Error Handling)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const getTodo = (id: number) =>\n   *   Effect.tryPromise({\n   *     try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n   *     // remap the error\n   *     catch: (unknown) => new Error(`something went wrong ${unknown}`)\n   *   })\n   *\n   * //       Effect<Response, Error, never>\n   * //      \n   * const program = getTodo(1)\n   * ```\n   *\n   * @see {@link promise} if the effectful computation is asynchronous and does not throw errors.\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <A, E>(\n    options: {\n      readonly try: (signal: AbortSignal) => PromiseLike<A>\n      readonly catch: (error: unknown) => E\n    }\n  ): Effect<A, E>\n  /**\n   * Creates an `Effect` that represents an asynchronous computation that might\n   * fail.\n   *\n   * **When to Use**\n   *\n   * In situations where you need to perform asynchronous operations that might\n   * fail, such as fetching data from an API, you can use the `tryPromise`\n   * constructor. This constructor is designed to handle operations that could\n   * throw exceptions by capturing those exceptions and transforming them into\n   * manageable errors.\n   *\n   * **Error Handling**\n   *\n   * There are two ways to handle errors with `tryPromise`:\n   *\n   * 1. If you don't provide a `catch` function, the error is caught and the\n   *    effect fails with an `UnknownException`.\n   * 2. If you provide a `catch` function, the error is caught and the `catch`\n   *    function maps it to an error of type `E`.\n   *\n   * **Interruptions**\n   *\n   * An optional `AbortSignal` can be provided to allow for interruption of the\n   * wrapped `Promise` API.\n   *\n   * **Example** (Fetching a TODO Item)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const getTodo = (id: number) =>\n   *   // Will catch any errors and propagate them as UnknownException\n   *   Effect.tryPromise(() =>\n   *     fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n   *   )\n   *\n   * //       Effect<Response, UnknownException, never>\n   * //      \n   * const program = getTodo(1)\n   * ```\n   *\n   * **Example** (Custom Error Handling)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const getTodo = (id: number) =>\n   *   Effect.tryPromise({\n   *     try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n   *     // remap the error\n   *     catch: (unknown) => new Error(`something went wrong ${unknown}`)\n   *   })\n   *\n   * //       Effect<Response, Error, never>\n   * //      \n   * const program = getTodo(1)\n   * ```\n   *\n   * @see {@link promise} if the effectful computation is asynchronous and does not throw errors.\n   *\n   * @since 2.0.0\n   * @category Creating Effects\n   */\n  <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>\n} = effect.tryPromise\n\n/**\n * The `unsandbox` function is used to revert an effect that has been\n * sandboxed by {@link sandbox}. When you apply `unsandbox`, the\n * effect's error channel is restored to its original state, without the\n * detailed `Cause<E>` information. This means that any underlying causes of\n * errors, defects, or fiber interruptions are no longer exposed in the error\n * channel.\n *\n * This function is useful when you want to remove the detailed error tracking\n * provided by `sandbox` and return to the standard error handling for\n * your effect. Once unsandboxed, the effect behaves as if `sandbox` was\n * never applied.\n *\n * @see {@link sandbox} to expose the full cause of failures, defects, or interruptions.\n *\n * @since 2.0.0\n * @category Error handling\n */\nexport const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R> = effect.unsandbox\n\n/**\n * Allows interruption of the current fiber, even in uninterruptible regions.\n *\n * **Details**\n *\n * This effect checks whether any other fibers are attempting to interrupt the\n * current fiber. If so, it allows the current fiber to perform a\n * self-interruption.\n *\n * **When to Use**\n *\n * This is useful in situations where you want to allow interruption to happen\n * even in regions of the code that are normally uninterruptible.\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const allowInterrupt: Effect<void> = effect.allowInterrupt\n\n/**\n * Checks if interruption is allowed and executes a callback accordingly.\n *\n * **Details**\n *\n * This function checks the current interrupt status of the running fiber. It\n * then calls the provided callback, passing a boolean indicating whether\n * interruption is allowed.\n *\n * **When to Use**\n *\n * This is useful for handling specific logic based on whether the current\n * operation can be interrupted, such as when performing asynchronous operations\n * or handling cancellation.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.checkInterruptible((isInterruptible) => {\n *     if (isInterruptible) {\n *       return Console.log(\"You can interrupt this operation.\")\n *     } else {\n *       return Console.log(\"This operation cannot be interrupted.\")\n *     }\n *   })\n * })\n *\n * Effect.runPromise(program)\n * // Output: You can interrupt this operation.\n *\n * Effect.runPromise(program.pipe(Effect.uninterruptible))\n * // Output: This operation cannot be interrupted.\n *\n * ```\n *\n *  @since 2.0.0\n * @category Interruption\n */\nexport const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R> =\n  core.checkInterruptible\n\n/**\n * Provides a way to handle timeouts in uninterruptible effects, allowing them\n * to continue in the background while the main control flow proceeds with the\n * timeout error.\n *\n * **Details**\n *\n * The `disconnect` function allows an uninterruptible effect to continue\n * running in the background, while enabling the main control flow to\n * immediately recognize a timeout condition. This is useful when you want to\n * avoid blocking the program due to long-running tasks, especially when those\n * tasks do not need to affect the flow of the rest of the program.\n *\n * Without `disconnect`, an uninterruptible effect will ignore the\n * timeout and continue executing until it completes. The timeout error will\n * only be assessed after the effect finishes, which can cause delays in\n * recognizing a timeout.\n *\n * With `disconnect`, the uninterruptible effect proceeds in the\n * background while the main program flow can immediately handle the timeout\n * error or trigger alternative logic. This enables faster timeout handling\n * without waiting for the completion of the long-running task.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const longRunningTask = Effect.gen(function* () {\n *   console.log(\"Start heavy processing...\")\n *   yield* Effect.sleep(\"5 seconds\") // Simulate a long process\n *   console.log(\"Heavy processing done.\")\n *   return \"Data processed\"\n * })\n *\n * const timedEffect = longRunningTask.pipe(\n *   Effect.uninterruptible,\n *   // Allows the task to finish in the background if it times out\n *   Effect.disconnect,\n *   Effect.timeout(\"1 second\")\n * )\n *\n * Effect.runPromiseExit(timedEffect).then(console.log)\n * // Output:\n * // Start heavy processing...\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: { _tag: 'TimeoutException' }\n * //   }\n * // }\n * // Heavy processing done.\n * ```\n *\n * @see {@link timeout} for a version that interrupts the effect.\n * @see {@link uninterruptible} for creating an uninterruptible effect.\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> = fiberRuntime.disconnect\n\n/**\n * Represents an effect that interrupts the current fiber.\n *\n * **Details**\n *\n * This effect models the explicit interruption of the fiber in which it runs.\n * When executed, it causes the fiber to stop its operation immediately,\n * capturing the interruption details such as the fiber's ID and its start time.\n * The resulting interruption can be observed in the `Exit` type if the effect\n * is run with functions like {@link runPromiseExit}.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.gen(function* () {\n *   console.log(\"start\")\n *   yield* Effect.sleep(\"2 seconds\")\n *   yield* Effect.interrupt\n *   console.log(\"done\")\n *   return \"some result\"\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // start\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Interrupt',\n * //     fiberId: {\n * //       _id: 'FiberId',\n * //       _tag: 'Runtime',\n * //       id: 0,\n * //       startTimeMillis: ...\n * //     }\n * //   }\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const interrupt: Effect<never> = core.interrupt\n\n/**\n * @since 2.0.0\n * @category Interruption\n */\nexport const interruptWith: (fiberId: FiberId.FiberId) => Effect<never> = core.interruptWith\n\n/**\n * Marks an effect as interruptible.\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> = core.interruptible\n\n/**\n * This function behaves like {@link interruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const interruptibleMask: <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>\n) => Effect<A, E, R> = core.interruptibleMask\n\n/**\n * Registers a cleanup effect to run when an effect is interrupted.\n *\n * **Details**\n *\n * This function allows you to specify an effect to run when the fiber is\n * interrupted. This effect will be executed when the fiber is interrupted,\n * allowing you to perform cleanup or other actions.\n *\n * **Example** (Running a Cleanup Action on Interruption)\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * // This handler is executed when the fiber is interrupted\n * const handler = Effect.onInterrupt((_fibers) => Console.log(\"Cleanup completed\"))\n *\n * const success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n *\n * const failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n *\n * const interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed\n * ```\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const onInterrupt: {\n  /**\n   * Registers a cleanup effect to run when an effect is interrupted.\n   *\n   * **Details**\n   *\n   * This function allows you to specify an effect to run when the fiber is\n   * interrupted. This effect will be executed when the fiber is interrupted,\n   * allowing you to perform cleanup or other actions.\n   *\n   * **Example** (Running a Cleanup Action on Interruption)\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * // This handler is executed when the fiber is interrupted\n   * const handler = Effect.onInterrupt((_fibers) => Console.log(\"Cleanup completed\"))\n   *\n   * const success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   *\n   * const failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   *\n   * const interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed\n   * ```\n   *\n   * @since 2.0.0\n   * @category Interruption\n   */\n  <X, R2>(\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>\n  /**\n   * Registers a cleanup effect to run when an effect is interrupted.\n   *\n   * **Details**\n   *\n   * This function allows you to specify an effect to run when the fiber is\n   * interrupted. This effect will be executed when the fiber is interrupted,\n   * allowing you to perform cleanup or other actions.\n   *\n   * **Example** (Running a Cleanup Action on Interruption)\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * // This handler is executed when the fiber is interrupted\n   * const handler = Effect.onInterrupt((_fibers) => Console.log(\"Cleanup completed\"))\n   *\n   * const success = Console.log(\"Task completed\").pipe(Effect.as(\"some result\"), handler)\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   *\n   * const failure = Console.log(\"Task failed\").pipe(Effect.andThen(Effect.fail(\"some error\")), handler)\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   *\n   * const interruption = Console.log(\"Task interrupted\").pipe(Effect.andThen(Effect.interrupt), handler)\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed\n   * ```\n   *\n   * @since 2.0.0\n   * @category Interruption\n   */\n  <A, E, R, X, R2>(\n    self: Effect<A, E, R>,\n    cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>\n  ): Effect<A, E, R | R2>\n} = core.onInterrupt\n\n/**\n * Marks an effect as uninterruptible.\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> = core.uninterruptible\n\n/**\n * This function behaves like {@link uninterruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n * @since 2.0.0\n * @category Interruption\n */\nexport const uninterruptibleMask: <A, E, R>(\n  f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>\n) => Effect<A, E, R> = core.uninterruptibleMask\n\n/**\n * Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\n * or failing with specified error if the predicate fails\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * // succeeds with `1`\n * Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n *\n * // fails with `\"0 is not positive\"`\n * Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n * ```\n *\n * @category Condition Checking\n * @since 3.4.0\n */\nexport const liftPredicate: {\n  /**\n   * Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\n   * or failing with specified error if the predicate fails\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * // succeeds with `1`\n   * Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n   *\n   * // fails with `\"0 is not positive\"`\n   * Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n   * ```\n   *\n   * @category Condition Checking\n   * @since 3.4.0\n   */\n  <T extends A, E, B extends T = T, A = T>(\n    predicate: Refinement<T, B> | Predicate<T>,\n    orFailWith: (a: EqualsWith<T, B, A, Exclude<A, B>>) => E\n  ): (a: A) => Effect<EqualsWith<T, B, A, B>, E>\n  /**\n   * Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\n   * or failing with specified error if the predicate fails\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const isPositive = (n: number): boolean => n > 0\n   *\n   * // succeeds with `1`\n   * Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n   *\n   * // fails with `\"0 is not positive\"`\n   * Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n   * ```\n   *\n   * @category Condition Checking\n   * @since 3.4.0\n   */\n  <A, E, B extends A = A>(\n    self: A,\n    predicate: Refinement<A, B> | Predicate<A>,\n    orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E\n  ): Effect<B, E>\n} = effect.liftPredicate\n\n/**\n * Replaces the value inside an effect with a constant value.\n *\n * **Details**\n *\n * This function allows you to ignore the original value inside an effect and\n * replace it with a constant value.\n *\n * **When to Use**\n *\n * It is useful when you no longer need the value produced by an effect but want\n * to ensure that the effect completes successfully with a specific constant\n * result instead. For instance, you can replace the value produced by a\n * computation with a predefined value, ignoring what was calculated before.\n *\n * **Example** (Replacing a Value)\n *\n * ```ts\n * import { pipe, Effect } from \"effect\"\n *\n * // Replaces the value 5 with the constant \"new value\"\n * const program = pipe(Effect.succeed(5), Effect.as(\"new value\"))\n *\n * Effect.runPromise(program).then(console.log)\n * // Output: \"new value\"\n * ```\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const as: {\n  /**\n   * Replaces the value inside an effect with a constant value.\n   *\n   * **Details**\n   *\n   * This function allows you to ignore the original value inside an effect and\n   * replace it with a constant value.\n   *\n   * **When to Use**\n   *\n   * It is useful when you no longer need the value produced by an effect but want\n   * to ensure that the effect completes successfully with a specific constant\n   * result instead. For instance, you can replace the value produced by a\n   * computation with a predefined value, ignoring what was calculated before.\n   *\n   * **Example** (Replacing a Value)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Replaces the value 5 with the constant \"new value\"\n   * const program = pipe(Effect.succeed(5), Effect.as(\"new value\"))\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output: \"new value\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>\n  /**\n   * Replaces the value inside an effect with a constant value.\n   *\n   * **Details**\n   *\n   * This function allows you to ignore the original value inside an effect and\n   * replace it with a constant value.\n   *\n   * **When to Use**\n   *\n   * It is useful when you no longer need the value produced by an effect but want\n   * to ensure that the effect completes successfully with a specific constant\n   * result instead. For instance, you can replace the value produced by a\n   * computation with a predefined value, ignoring what was calculated before.\n   *\n   * **Example** (Replacing a Value)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Replaces the value 5 with the constant \"new value\"\n   * const program = pipe(Effect.succeed(5), Effect.as(\"new value\"))\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output: \"new value\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>\n} = core.as\n\n/**\n * This function maps the success value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value fails, the returned\n * `Effect` value will also fail.\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R> = effect.asSome\n\n/**\n * This function maps the error value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value succeeds, the returned\n * `Effect` value will also succeed.\n *\n * @category Mapping\n * @since 2.0.0\n */\nexport const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R> = effect.asSomeError\n\n/**\n * This function maps the success value of an `Effect` value to `void`. If the\n * original `Effect` value succeeds, the returned `Effect` value will also\n * succeed. If the original `Effect` value fails, the returned `Effect` value\n * will fail with the same error.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R> = core.asVoid\n\n/**\n * Swaps the success and error channels of an effect.\n *\n * **Details**\n *\n * This function reverses the flow of an effect by swapping its success and\n * error channels. The success value becomes an error, and the error value\n * becomes a success.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, string, never>\n * //      \n * const program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n *\n * //       Effect<string, number, never>\n * //      \n * const flipped = Effect.flip(program)\n * ```\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R> = core.flip\n\n/**\n * Swaps the error/value parameters, applies the function `f` and flips the\n * parameters back\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const flipWith: {\n  /**\n   * Swaps the error/value parameters, applies the function `f` and flips the\n   * parameters back\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>\n  /**\n   * Swaps the error/value parameters, applies the function `f` and flips the\n   * parameters back\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>\n} = effect.flipWith\n\n/**\n * Transforms the value inside an effect by applying a function to it.\n *\n * **Syntax**\n *\n * ```ts skip-type-checking\n * const mappedEffect = pipe(myEffect, Effect.map(transformation))\n * // or\n * const mappedEffect = Effect.map(myEffect, transformation)\n * // or\n * const mappedEffect = myEffect.pipe(Effect.map(transformation))\n * ```\n *\n * **Details**\n *\n * `map` takes a function and applies it to the value contained within an\n * effect, creating a new effect with the transformed value.\n *\n * It's important to note that effects are immutable, meaning that the original\n * effect is not modified. Instead, a new effect is returned with the updated\n * value.\n *\n * **Example** (Adding a Service Charge)\n *\n * ```ts\n * import { pipe, Effect } from \"effect\"\n *\n * const addServiceCharge = (amount: number) => amount + 1\n *\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * const finalAmount = pipe(\n *   fetchTransactionAmount,\n *   Effect.map(addServiceCharge)\n * )\n *\n * Effect.runPromise(finalAmount).then(console.log)\n * // Output: 101\n * ```\n *\n * @see {@link mapError} for a version that operates on the error channel.\n * @see {@link mapBoth} for a version that operates on both channels.\n * @see {@link flatMap} or {@link andThen} for a version that can return a new effect.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const map: {\n  /**\n   * Transforms the value inside an effect by applying a function to it.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const mappedEffect = pipe(myEffect, Effect.map(transformation))\n   * // or\n   * const mappedEffect = Effect.map(myEffect, transformation)\n   * // or\n   * const mappedEffect = myEffect.pipe(Effect.map(transformation))\n   * ```\n   *\n   * **Details**\n   *\n   * `map` takes a function and applies it to the value contained within an\n   * effect, creating a new effect with the transformed value.\n   *\n   * It's important to note that effects are immutable, meaning that the original\n   * effect is not modified. Instead, a new effect is returned with the updated\n   * value.\n   *\n   * **Example** (Adding a Service Charge)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * const addServiceCharge = (amount: number) => amount + 1\n   *\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.map(addServiceCharge)\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output: 101\n   * ```\n   *\n   * @see {@link mapError} for a version that operates on the error channel.\n   * @see {@link mapBoth} for a version that operates on both channels.\n   * @see {@link flatMap} or {@link andThen} for a version that can return a new effect.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>\n  /**\n   * Transforms the value inside an effect by applying a function to it.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const mappedEffect = pipe(myEffect, Effect.map(transformation))\n   * // or\n   * const mappedEffect = Effect.map(myEffect, transformation)\n   * // or\n   * const mappedEffect = myEffect.pipe(Effect.map(transformation))\n   * ```\n   *\n   * **Details**\n   *\n   * `map` takes a function and applies it to the value contained within an\n   * effect, creating a new effect with the transformed value.\n   *\n   * It's important to note that effects are immutable, meaning that the original\n   * effect is not modified. Instead, a new effect is returned with the updated\n   * value.\n   *\n   * **Example** (Adding a Service Charge)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * const addServiceCharge = (amount: number) => amount + 1\n   *\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.map(addServiceCharge)\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output: 101\n   * ```\n   *\n   * @see {@link mapError} for a version that operates on the error channel.\n   * @see {@link mapBoth} for a version that operates on both channels.\n   * @see {@link flatMap} or {@link andThen} for a version that can return a new effect.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>\n} = core.map\n\n/**\n * Applies a stateful transformation to each element of a collection, producing\n * new elements along with an updated state.\n *\n * **When to Use**\n *\n * Use `mapAccum` when you need to process each element of a collection while\n * keeping track of some state across iterations.\n *\n * **Details**\n *\n * `mapAccum` takes an initial state (`initial`) and a function (`f`) that is\n * applied to each element. This function returns a new state and a transformed\n * element. The final effect produces both the accumulated state and the\n * transformed collection.\n *\n * If the input collection is a non-empty array, the return type will match the\n * input collection type.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // Define an initial state and a transformation function\n * const initialState = 0\n *\n * const transformation = (state: number, element: string) =>\n *   Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n *\n * // Apply mapAccum to transform an array of strings\n * const program = Effect.mapAccum([\"a\", \"bb\", \"ccc\"], initialState, transformation)\n *\n * Effect.runPromise(program).then(([finalState, transformedCollection]) => {\n *   console.log(finalState)\n *   console.log(transformedCollection)\n * })\n * // Output:\n * // 6\n * // [ 'A', 'BB', 'CCC' ]\n * ```\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapAccum: {\n  /**\n   * Applies a stateful transformation to each element of a collection, producing\n   * new elements along with an updated state.\n   *\n   * **When to Use**\n   *\n   * Use `mapAccum` when you need to process each element of a collection while\n   * keeping track of some state across iterations.\n   *\n   * **Details**\n   *\n   * `mapAccum` takes an initial state (`initial`) and a function (`f`) that is\n   * applied to each element. This function returns a new state and a transformed\n   * element. The final effect produces both the accumulated state and the\n   * transformed collection.\n   *\n   * If the input collection is a non-empty array, the return type will match the\n   * input collection type.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // Define an initial state and a transformation function\n   * const initialState = 0\n   *\n   * const transformation = (state: number, element: string) =>\n   *   Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n   *\n   * // Apply mapAccum to transform an array of strings\n   * const program = Effect.mapAccum([\"a\", \"bb\", \"ccc\"], initialState, transformation)\n   *\n   * Effect.runPromise(program).then(([finalState, transformedCollection]) => {\n   *   console.log(finalState)\n   *   console.log(transformedCollection)\n   * })\n   * // Output:\n   * // 6\n   * // [ 'A', 'BB', 'CCC' ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    initial: S,\n    f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>\n  ): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>\n  /**\n   * Applies a stateful transformation to each element of a collection, producing\n   * new elements along with an updated state.\n   *\n   * **When to Use**\n   *\n   * Use `mapAccum` when you need to process each element of a collection while\n   * keeping track of some state across iterations.\n   *\n   * **Details**\n   *\n   * `mapAccum` takes an initial state (`initial`) and a function (`f`) that is\n   * applied to each element. This function returns a new state and a transformed\n   * element. The final effect produces both the accumulated state and the\n   * transformed collection.\n   *\n   * If the input collection is a non-empty array, the return type will match the\n   * input collection type.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // Define an initial state and a transformation function\n   * const initialState = 0\n   *\n   * const transformation = (state: number, element: string) =>\n   *   Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n   *\n   * // Apply mapAccum to transform an array of strings\n   * const program = Effect.mapAccum([\"a\", \"bb\", \"ccc\"], initialState, transformation)\n   *\n   * Effect.runPromise(program).then(([finalState, transformedCollection]) => {\n   *   console.log(finalState)\n   *   console.log(transformedCollection)\n   * })\n   * // Output:\n   * // 6\n   * // [ 'A', 'BB', 'CCC' ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    elements: I,\n    initial: S,\n    f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>\n  ): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>\n} = effect.mapAccum\n\n/**\n * Applies transformations to both the success and error channels of an effect.\n *\n * **Details**\n *\n * This function takes two map functions as arguments: one for the error channel\n * and one for the success channel. You can use it when you want to modify both\n * the error and the success values without altering the overall success or\n * failure status of the effect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, string, never>\n * //      \n * const simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n *\n * //       Effect<boolean, Error, never>\n * //      \n * const modified = Effect.mapBoth(simulatedTask, {\n *   onFailure: (message) => new Error(message),\n *   onSuccess: (n) => n > 0\n * })\n * ```\n *\n * @see {@link map} for a version that operates on the success channel.\n * @see {@link mapError} for a version that operates on the error channel.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapBoth: {\n  /**\n   * Applies transformations to both the success and error channels of an effect.\n   *\n   * **Details**\n   *\n   * This function takes two map functions as arguments: one for the error channel\n   * and one for the success channel. You can use it when you want to modify both\n   * the error and the success values without altering the overall success or\n   * failure status of the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * //       Effect<number, string, never>\n   * //      \n   * const simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n   *\n   * //       Effect<boolean, Error, never>\n   * //      \n   * const modified = Effect.mapBoth(simulatedTask, {\n   *   onFailure: (message) => new Error(message),\n   *   onSuccess: (n) => n > 0\n   * })\n   * ```\n   *\n   * @see {@link map} for a version that operates on the success channel.\n   * @see {@link mapError} for a version that operates on the error channel.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>\n  /**\n   * Applies transformations to both the success and error channels of an effect.\n   *\n   * **Details**\n   *\n   * This function takes two map functions as arguments: one for the error channel\n   * and one for the success channel. You can use it when you want to modify both\n   * the error and the success values without altering the overall success or\n   * failure status of the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * //       Effect<number, string, never>\n   * //      \n   * const simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n   *\n   * //       Effect<boolean, Error, never>\n   * //      \n   * const modified = Effect.mapBoth(simulatedTask, {\n   *   onFailure: (message) => new Error(message),\n   *   onSuccess: (n) => n > 0\n   * })\n   * ```\n   *\n   * @see {@link map} for a version that operates on the success channel.\n   * @see {@link mapError} for a version that operates on the error channel.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, E, R, E2, A2>(\n    self: Effect<A, E, R>,\n    options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2 }\n  ): Effect<A2, E2, R>\n} = core.mapBoth\n\n/**\n * Transforms or modifies the error produced by an effect without affecting its\n * success value.\n *\n * **When to Use**\n *\n * This function is helpful when you want to enhance the error with additional\n * information, change the error type, or apply custom error handling while\n * keeping the original behavior of the effect's success values intact. It only\n * operates on the error channel and leaves the success channel unchanged.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, string, never>\n * //      \n * const simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n *\n * //       Effect<number, Error, never>\n * //      \n * const mapped = Effect.mapError(\n *   simulatedTask,\n *   (message) => new Error(message)\n * )\n * ```\n *\n * @see {@link map} for a version that operates on the success channel.\n * @see {@link mapBoth} for a version that operates on both channels.\n * @see {@link orElseFail} if you want to replace the error with a new one.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapError: {\n  /**\n   * Transforms or modifies the error produced by an effect without affecting its\n   * success value.\n   *\n   * **When to Use**\n   *\n   * This function is helpful when you want to enhance the error with additional\n   * information, change the error type, or apply custom error handling while\n   * keeping the original behavior of the effect's success values intact. It only\n   * operates on the error channel and leaves the success channel unchanged.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * //       Effect<number, string, never>\n   * //      \n   * const simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n   *\n   * //       Effect<number, Error, never>\n   * //      \n   * const mapped = Effect.mapError(\n   *   simulatedTask,\n   *   (message) => new Error(message)\n   * )\n   * ```\n   *\n   * @see {@link map} for a version that operates on the success channel.\n   * @see {@link mapBoth} for a version that operates on both channels.\n   * @see {@link orElseFail} if you want to replace the error with a new one.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>\n  /**\n   * Transforms or modifies the error produced by an effect without affecting its\n   * success value.\n   *\n   * **When to Use**\n   *\n   * This function is helpful when you want to enhance the error with additional\n   * information, change the error type, or apply custom error handling while\n   * keeping the original behavior of the effect's success values intact. It only\n   * operates on the error channel and leaves the success channel unchanged.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * //       Effect<number, string, never>\n   * //      \n   * const simulatedTask = Effect.fail(\"Oh no!\").pipe(Effect.as(1))\n   *\n   * //       Effect<number, Error, never>\n   * //      \n   * const mapped = Effect.mapError(\n   *   simulatedTask,\n   *   (message) => new Error(message)\n   * )\n   * ```\n   *\n   * @see {@link map} for a version that operates on the success channel.\n   * @see {@link mapBoth} for a version that operates on both channels.\n   * @see {@link orElseFail} if you want to replace the error with a new one.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>\n} = core.mapError\n\n/**\n * Maps the cause of failure of an effect using a specified function.\n *\n * @see {@link sandbox} for a version that exposes the full cause of failures, defects, or interruptions.\n * @see {@link catchAllCause} for a version that can recover from all types of defects.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const mapErrorCause: {\n  /**\n   * Maps the cause of failure of an effect using a specified function.\n   *\n   * @see {@link sandbox} for a version that exposes the full cause of failures, defects, or interruptions.\n   * @see {@link catchAllCause} for a version that can recover from all types of defects.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>\n  /**\n   * Maps the cause of failure of an effect using a specified function.\n   *\n   * @see {@link sandbox} for a version that exposes the full cause of failures, defects, or interruptions.\n   * @see {@link catchAllCause} for a version that can recover from all types of defects.\n   *\n   * @since 2.0.0\n   * @category Mapping\n   */\n  <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>\n} = effect.mapErrorCause\n\n/**\n * Combines both success and error channels of an effect into a single outcome.\n *\n * **Details**\n *\n * This function transforms an effect that may fail into one that always returns\n * a value, where both success and failure outcomes are handled as values in the\n * success channel.\n *\n * **When to Use**\n *\n * This can be useful when you want to continue execution regardless of the\n * error type and still capture both successful results and errors as part of\n * the outcome.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, string, never>\n * //      \n * const program = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n *\n * //       Effect<number | string, never, never>\n * //      \n * const recovered = Effect.merge(program)\n * ```\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R> = effect.merge\n\n/**\n * Returns a new effect with the boolean value of this effect negated.\n *\n * @since 2.0.0\n * @category Mapping\n */\nexport const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R> = effect.negate\n\n/**\n * Creates a scoped resource using an `acquire` and `release` effect.\n *\n * **Details**\n *\n * This function helps manage resources by combining two `Effect` values: one\n * for acquiring the resource and one for releasing it.\n *\n * `acquireRelease` does the following:\n *\n *   1. Ensures that the effect that acquires the resource will not be\n *      interrupted. Note that acquisition may still fail due to internal\n *      reasons (such as an uncaught exception).\n *   2. Ensures that the `release` effect will not be interrupted, and will be\n *      executed as long as the acquisition effect successfully acquires the\n *      resource.\n *\n * If the `acquire` function succeeds, the `release` function is added to the\n * list of finalizers for the scope. This ensures that the release will happen\n * automatically when the scope is closed.\n *\n * Both `acquire` and `release` run uninterruptibly, meaning they cannot be\n * interrupted while they are executing.\n *\n * Additionally, the `release` function can be influenced by the exit value when\n * the scope closes, allowing for custom handling of how the resource is\n * released based on the execution outcome.\n *\n * **When to Use**\n *\n * This function is used to ensure that an effect that represents the\n * acquisition of a resource (for example, opening a file, launching a thread,\n * etc.) will not be interrupted, and that the resource will always be released\n * when the `Effect` completes execution.\n *\n * **Example** (Defining a Simple Resource)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // Define an interface for a resource\n * interface MyResource {\n *   readonly contents: string\n *   readonly close: () => Promise<void>\n * }\n *\n * // Simulate resource acquisition\n * const getMyResource = (): Promise<MyResource> =>\n *   Promise.resolve({\n *     contents: \"lorem ipsum\",\n *     close: () =>\n *       new Promise((resolve) => {\n *         console.log(\"Resource released\")\n *         resolve()\n *       })\n *   })\n *\n * // Define how the resource is acquired\n * const acquire = Effect.tryPromise({\n *   try: () =>\n *     getMyResource().then((res) => {\n *       console.log(\"Resource acquired\")\n *       return res\n *     }),\n *   catch: () => new Error(\"getMyResourceError\")\n * })\n *\n * // Define how the resource is released\n * const release = (res: MyResource) => Effect.promise(() => res.close())\n *\n * // Create the resource management workflow\n * //\n * //       Effect<MyResource, Error, Scope>\n * //      \n * const resource = Effect.acquireRelease(acquire, release)\n * ```\n *\n * @see {@link acquireUseRelease} for a version that automatically handles the scoping of resources.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const acquireRelease: {\n  /**\n   * Creates a scoped resource using an `acquire` and `release` effect.\n   *\n   * **Details**\n   *\n   * This function helps manage resources by combining two `Effect` values: one\n   * for acquiring the resource and one for releasing it.\n   *\n   * `acquireRelease` does the following:\n   *\n   *   1. Ensures that the effect that acquires the resource will not be\n   *      interrupted. Note that acquisition may still fail due to internal\n   *      reasons (such as an uncaught exception).\n   *   2. Ensures that the `release` effect will not be interrupted, and will be\n   *      executed as long as the acquisition effect successfully acquires the\n   *      resource.\n   *\n   * If the `acquire` function succeeds, the `release` function is added to the\n   * list of finalizers for the scope. This ensures that the release will happen\n   * automatically when the scope is closed.\n   *\n   * Both `acquire` and `release` run uninterruptibly, meaning they cannot be\n   * interrupted while they are executing.\n   *\n   * Additionally, the `release` function can be influenced by the exit value when\n   * the scope closes, allowing for custom handling of how the resource is\n   * released based on the execution outcome.\n   *\n   * **When to Use**\n   *\n   * This function is used to ensure that an effect that represents the\n   * acquisition of a resource (for example, opening a file, launching a thread,\n   * etc.) will not be interrupted, and that the resource will always be released\n   * when the `Effect` completes execution.\n   *\n   * **Example** (Defining a Simple Resource)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // Define an interface for a resource\n   * interface MyResource {\n   *   readonly contents: string\n   *   readonly close: () => Promise<void>\n   * }\n   *\n   * // Simulate resource acquisition\n   * const getMyResource = (): Promise<MyResource> =>\n   *   Promise.resolve({\n   *     contents: \"lorem ipsum\",\n   *     close: () =>\n   *       new Promise((resolve) => {\n   *         console.log(\"Resource released\")\n   *         resolve()\n   *       })\n   *   })\n   *\n   * // Define how the resource is acquired\n   * const acquire = Effect.tryPromise({\n   *   try: () =>\n   *     getMyResource().then((res) => {\n   *       console.log(\"Resource acquired\")\n   *       return res\n   *     }),\n   *   catch: () => new Error(\"getMyResourceError\")\n   * })\n   *\n   * // Define how the resource is released\n   * const release = (res: MyResource) => Effect.promise(() => res.close())\n   *\n   * // Create the resource management workflow\n   * //\n   * //       Effect<MyResource, Error, Scope>\n   * //      \n   * const resource = Effect.acquireRelease(acquire, release)\n   * ```\n   *\n   * @see {@link acquireUseRelease} for a version that automatically handles the scoping of resources.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, X, R2>(release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>\n  /**\n   * Creates a scoped resource using an `acquire` and `release` effect.\n   *\n   * **Details**\n   *\n   * This function helps manage resources by combining two `Effect` values: one\n   * for acquiring the resource and one for releasing it.\n   *\n   * `acquireRelease` does the following:\n   *\n   *   1. Ensures that the effect that acquires the resource will not be\n   *      interrupted. Note that acquisition may still fail due to internal\n   *      reasons (such as an uncaught exception).\n   *   2. Ensures that the `release` effect will not be interrupted, and will be\n   *      executed as long as the acquisition effect successfully acquires the\n   *      resource.\n   *\n   * If the `acquire` function succeeds, the `release` function is added to the\n   * list of finalizers for the scope. This ensures that the release will happen\n   * automatically when the scope is closed.\n   *\n   * Both `acquire` and `release` run uninterruptibly, meaning they cannot be\n   * interrupted while they are executing.\n   *\n   * Additionally, the `release` function can be influenced by the exit value when\n   * the scope closes, allowing for custom handling of how the resource is\n   * released based on the execution outcome.\n   *\n   * **When to Use**\n   *\n   * This function is used to ensure that an effect that represents the\n   * acquisition of a resource (for example, opening a file, launching a thread,\n   * etc.) will not be interrupted, and that the resource will always be released\n   * when the `Effect` completes execution.\n   *\n   * **Example** (Defining a Simple Resource)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // Define an interface for a resource\n   * interface MyResource {\n   *   readonly contents: string\n   *   readonly close: () => Promise<void>\n   * }\n   *\n   * // Simulate resource acquisition\n   * const getMyResource = (): Promise<MyResource> =>\n   *   Promise.resolve({\n   *     contents: \"lorem ipsum\",\n   *     close: () =>\n   *       new Promise((resolve) => {\n   *         console.log(\"Resource released\")\n   *         resolve()\n   *       })\n   *   })\n   *\n   * // Define how the resource is acquired\n   * const acquire = Effect.tryPromise({\n   *   try: () =>\n   *     getMyResource().then((res) => {\n   *       console.log(\"Resource acquired\")\n   *       return res\n   *     }),\n   *   catch: () => new Error(\"getMyResourceError\")\n   * })\n   *\n   * // Define how the resource is released\n   * const release = (res: MyResource) => Effect.promise(() => res.close())\n   *\n   * // Create the resource management workflow\n   * //\n   * //       Effect<MyResource, Error, Scope>\n   * //      \n   * const resource = Effect.acquireRelease(acquire, release)\n   * ```\n   *\n   * @see {@link acquireUseRelease} for a version that automatically handles the scoping of resources.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, X, R2>(\n    acquire: Effect<A, E, R>,\n    release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>\n  ): Effect<A, E, Scope.Scope | R | R2>\n} = fiberRuntime.acquireRelease\n\n/**\n * Creates a scoped resource with an interruptible acquire action.\n *\n * **Details**\n *\n * This function is similar to {@link acquireRelease}, but it allows the\n * acquisition of the resource to be interrupted. The `acquire` effect, which\n * represents the process of obtaining the resource, can be interrupted if\n * necessary.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const acquireReleaseInterruptible: {\n  /**\n   * Creates a scoped resource with an interruptible acquire action.\n   *\n   * **Details**\n   *\n   * This function is similar to {@link acquireRelease}, but it allows the\n   * acquisition of the resource to be interrupted. The `acquire` effect, which\n   * represents the process of obtaining the resource, can be interrupted if\n   * necessary.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <X, R2>(release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>\n  /**\n   * Creates a scoped resource with an interruptible acquire action.\n   *\n   * **Details**\n   *\n   * This function is similar to {@link acquireRelease}, but it allows the\n   * acquisition of the resource to be interrupted. The `acquire` effect, which\n   * represents the process of obtaining the resource, can be interrupted if\n   * necessary.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, X, R2>(\n    acquire: Effect<A, E, R>,\n    release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>\n  ): Effect<A, E, Scope.Scope | R | R2>\n} = fiberRuntime.acquireReleaseInterruptible\n\n/**\n * Many real-world operations involve working with resources that must be released when no longer needed, such as:\n *\n * - Database connections\n * - File handles\n * - Network requests\n *\n * This function ensures that a resource is:\n *\n * 1. **Acquired** properly.\n * 2. **Used** for its intended purpose.\n * 3. **Released** even if an error occurs.\n *\n * **Example** (Automatically Managing Resource Lifetime)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * // Define an interface for a resource\n * interface MyResource {\n *   readonly contents: string\n *   readonly close: () => Promise<void>\n * }\n *\n * // Simulate resource acquisition\n * const getMyResource = (): Promise<MyResource> =>\n *   Promise.resolve({\n *     contents: \"lorem ipsum\",\n *     close: () =>\n *       new Promise((resolve) => {\n *         console.log(\"Resource released\")\n *         resolve()\n *       })\n *   })\n *\n * // Define how the resource is acquired\n * const acquire = Effect.tryPromise({\n *   try: () =>\n *     getMyResource().then((res) => {\n *       console.log(\"Resource acquired\")\n *       return res\n *     }),\n *   catch: () => new Error(\"getMyResourceError\")\n * })\n *\n * // Define how the resource is released\n * const release = (res: MyResource) => Effect.promise(() => res.close())\n *\n * const use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n *\n * //       Effect<void, Error, never>\n * //      \n * const program = Effect.acquireUseRelease(acquire, use, release)\n *\n * Effect.runPromise(program)\n * // Output:\n * // Resource acquired\n * // content is lorem ipsum\n * // Resource released\n * ```\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const acquireUseRelease: {\n  /**\n   * Many real-world operations involve working with resources that must be released when no longer needed, such as:\n   *\n   * - Database connections\n   * - File handles\n   * - Network requests\n   *\n   * This function ensures that a resource is:\n   *\n   * 1. **Acquired** properly.\n   * 2. **Used** for its intended purpose.\n   * 3. **Released** even if an error occurs.\n   *\n   * **Example** (Automatically Managing Resource Lifetime)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Define an interface for a resource\n   * interface MyResource {\n   *   readonly contents: string\n   *   readonly close: () => Promise<void>\n   * }\n   *\n   * // Simulate resource acquisition\n   * const getMyResource = (): Promise<MyResource> =>\n   *   Promise.resolve({\n   *     contents: \"lorem ipsum\",\n   *     close: () =>\n   *       new Promise((resolve) => {\n   *         console.log(\"Resource released\")\n   *         resolve()\n   *       })\n   *   })\n   *\n   * // Define how the resource is acquired\n   * const acquire = Effect.tryPromise({\n   *   try: () =>\n   *     getMyResource().then((res) => {\n   *       console.log(\"Resource acquired\")\n   *       return res\n   *     }),\n   *   catch: () => new Error(\"getMyResourceError\")\n   * })\n   *\n   * // Define how the resource is released\n   * const release = (res: MyResource) => Effect.promise(() => res.close())\n   *\n   * const use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n   *\n   * //       Effect<void, Error, never>\n   * //      \n   * const program = Effect.acquireUseRelease(acquire, use, release)\n   *\n   * Effect.runPromise(program)\n   * // Output:\n   * // Resource acquired\n   * // content is lorem ipsum\n   * // Resource released\n   * ```\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A2, E2, R2, A, X, R3>(\n    use: (a: A) => Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>\n  ): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>\n  /**\n   * Many real-world operations involve working with resources that must be released when no longer needed, such as:\n   *\n   * - Database connections\n   * - File handles\n   * - Network requests\n   *\n   * This function ensures that a resource is:\n   *\n   * 1. **Acquired** properly.\n   * 2. **Used** for its intended purpose.\n   * 3. **Released** even if an error occurs.\n   *\n   * **Example** (Automatically Managing Resource Lifetime)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Define an interface for a resource\n   * interface MyResource {\n   *   readonly contents: string\n   *   readonly close: () => Promise<void>\n   * }\n   *\n   * // Simulate resource acquisition\n   * const getMyResource = (): Promise<MyResource> =>\n   *   Promise.resolve({\n   *     contents: \"lorem ipsum\",\n   *     close: () =>\n   *       new Promise((resolve) => {\n   *         console.log(\"Resource released\")\n   *         resolve()\n   *       })\n   *   })\n   *\n   * // Define how the resource is acquired\n   * const acquire = Effect.tryPromise({\n   *   try: () =>\n   *     getMyResource().then((res) => {\n   *       console.log(\"Resource acquired\")\n   *       return res\n   *     }),\n   *   catch: () => new Error(\"getMyResourceError\")\n   * })\n   *\n   * // Define how the resource is released\n   * const release = (res: MyResource) => Effect.promise(() => res.close())\n   *\n   * const use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n   *\n   * //       Effect<void, Error, never>\n   * //      \n   * const program = Effect.acquireUseRelease(acquire, use, release)\n   *\n   * Effect.runPromise(program)\n   * // Output:\n   * // Resource acquired\n   * // content is lorem ipsum\n   * // Resource released\n   * ```\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, A2, E2, R2, X, R3>(\n    acquire: Effect<A, E, R>,\n    use: (a: A) => Effect<A2, E2, R2>,\n    release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>\n  ): Effect<A2, E | E2, R | R2 | R3>\n} = core.acquireUseRelease\n\n/**\n * Ensures a finalizer is added to the scope of the calling effect, guaranteeing\n * it runs when the scope is closed.\n *\n * **Details**\n *\n * This function adds a finalizer that will execute whenever the scope of the\n * effect is closed, regardless of whether the effect succeeds, fails, or is\n * interrupted. The finalizer receives the `Exit` value of the effect's scope,\n * allowing it to react differently depending on how the effect concludes.\n *\n * Finalizers are a reliable way to manage resource cleanup, ensuring that\n * resources such as file handles, network connections, or database transactions\n * are properly closed even in the event of an unexpected interruption or error.\n *\n * Finalizers operate in conjunction with Effect's scoped resources. If an\n * effect with a finalizer is wrapped in a scope, the finalizer will execute\n * automatically when the scope ends.\n *\n * **Example** (Adding a Finalizer on Success)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<string, never, Scope>\n * //      \n * const program = Effect.gen(function* () {\n *   yield* Effect.addFinalizer((exit) =>\n *     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n *   )\n *   return \"some result\"\n * })\n *\n * // Wrapping the effect in a scope\n * //\n * //       Effect<string, never, never>\n * //      \n * const runnable = Effect.scoped(program)\n *\n * Effect.runPromiseExit(runnable).then(console.log)\n * // Output:\n * // Finalizer executed. Exit status: Success\n * // { _id: 'Exit', _tag: 'Success', value: 'some result' }\n * ```\n *\n * **Example** (Adding a Finalizer on Failure)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<never, string, Scope>\n * //      \n * const program = Effect.gen(function* () {\n *   yield* Effect.addFinalizer((exit) =>\n *     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n *   )\n *   return yield* Effect.fail(\"Uh oh!\")\n * })\n *\n * // Wrapping the effect in a scope\n * //\n * //       Effect<never, string, never>\n * //      \n * const runnable = Effect.scoped(program)\n *\n * Effect.runPromiseExit(runnable).then(console.log)\n * // Output:\n * // Finalizer executed. Exit status: Failure\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n * // }\n * ```\n *\n * **Example** (Adding a Finalizer on Interruption)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //       Effect<never, never, Scope>\n * //      \n * const program = Effect.gen(function* () {\n *   yield* Effect.addFinalizer((exit) =>\n *     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n *   )\n *   return yield* Effect.interrupt\n * })\n *\n * // Wrapping the effect in a scope\n * //\n * //       Effect<never, never, never>\n * //      \n * const runnable = Effect.scoped(program)\n *\n * Effect.runPromiseExit(runnable).then(console.log)\n * // Output:\n * // Finalizer executed. Exit status: Failure\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Interrupt',\n * //     fiberId: {\n * //       _id: 'FiberId',\n * //       _tag: 'Runtime',\n * //       id: 0,\n * //       startTimeMillis: ...\n * //     }\n * //   }\n * // }\n * ```\n *\n * @see {@link onExit} for attaching a finalizer directly to an effect.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const addFinalizer: <X, R>(\n  finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>\n) => Effect<void, never, Scope.Scope | R> = fiberRuntime.addFinalizer\n\n/**\n * Guarantees the execution of a finalizer when an effect starts execution.\n *\n * **Details**\n *\n * This function allows you to specify a `finalizer` effect that will always be\n * run once the effect starts execution, regardless of whether the effect\n * succeeds, fails, or is interrupted.\n *\n * **When to Use**\n *\n * This is useful when you need to ensure that certain cleanup or final steps\n * are executed in all cases, such as releasing resources or performing\n * necessary logging.\n *\n * While this function provides strong guarantees about executing the finalizer,\n * it is considered a low-level tool, which may not be ideal for more complex\n * resource management. For higher-level resource management with automatic\n * acquisition and release, see the {@link acquireRelease} family of functions.\n * For use cases where you need access to the result of an effect, consider\n * using {@link onExit}.\n *\n * **Example** (Running a Finalizer in All Outcomes)\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * // Define a cleanup effect\n * const handler = Effect.ensuring(Console.log(\"Cleanup completed\"))\n *\n * // Define a successful effect\n * const success = Console.log(\"Task completed\").pipe(\n *   Effect.as(\"some result\"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n * // Cleanup completed\n *\n * // Define a failing effect\n * const failure = Console.log(\"Task failed\").pipe(\n *   Effect.andThen(Effect.fail(\"some error\")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed\n *\n * // Define an interrupted effect\n * const interruption = Console.log(\"Task interrupted\").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed\n * ```\n *\n * @see {@link onExit} for a version that provides access to the result of an\n * effect.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const ensuring: {\n  /**\n   * Guarantees the execution of a finalizer when an effect starts execution.\n   *\n   * **Details**\n   *\n   * This function allows you to specify a `finalizer` effect that will always be\n   * run once the effect starts execution, regardless of whether the effect\n   * succeeds, fails, or is interrupted.\n   *\n   * **When to Use**\n   *\n   * This is useful when you need to ensure that certain cleanup or final steps\n   * are executed in all cases, such as releasing resources or performing\n   * necessary logging.\n   *\n   * While this function provides strong guarantees about executing the finalizer,\n   * it is considered a low-level tool, which may not be ideal for more complex\n   * resource management. For higher-level resource management with automatic\n   * acquisition and release, see the {@link acquireRelease} family of functions.\n   * For use cases where you need access to the result of an effect, consider\n   * using {@link onExit}.\n   *\n   * **Example** (Running a Finalizer in All Outcomes)\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * // Define a cleanup effect\n   * const handler = Effect.ensuring(Console.log(\"Cleanup completed\"))\n   *\n   * // Define a successful effect\n   * const success = Console.log(\"Task completed\").pipe(\n   *   Effect.as(\"some result\"),\n   *   handler\n   * )\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   * // Cleanup completed\n   *\n   * // Define a failing effect\n   * const failure = Console.log(\"Task failed\").pipe(\n   *   Effect.andThen(Effect.fail(\"some error\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   * // Cleanup completed\n   *\n   * // Define an interrupted effect\n   * const interruption = Console.log(\"Task interrupted\").pipe(\n   *   Effect.andThen(Effect.interrupt),\n   *   handler\n   * )\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed\n   * ```\n   *\n   * @see {@link onExit} for a version that provides access to the result of an\n   * effect.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>\n  /**\n   * Guarantees the execution of a finalizer when an effect starts execution.\n   *\n   * **Details**\n   *\n   * This function allows you to specify a `finalizer` effect that will always be\n   * run once the effect starts execution, regardless of whether the effect\n   * succeeds, fails, or is interrupted.\n   *\n   * **When to Use**\n   *\n   * This is useful when you need to ensure that certain cleanup or final steps\n   * are executed in all cases, such as releasing resources or performing\n   * necessary logging.\n   *\n   * While this function provides strong guarantees about executing the finalizer,\n   * it is considered a low-level tool, which may not be ideal for more complex\n   * resource management. For higher-level resource management with automatic\n   * acquisition and release, see the {@link acquireRelease} family of functions.\n   * For use cases where you need access to the result of an effect, consider\n   * using {@link onExit}.\n   *\n   * **Example** (Running a Finalizer in All Outcomes)\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * // Define a cleanup effect\n   * const handler = Effect.ensuring(Console.log(\"Cleanup completed\"))\n   *\n   * // Define a successful effect\n   * const success = Console.log(\"Task completed\").pipe(\n   *   Effect.as(\"some result\"),\n   *   handler\n   * )\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   * // Cleanup completed\n   *\n   * // Define a failing effect\n   * const failure = Console.log(\"Task failed\").pipe(\n   *   Effect.andThen(Effect.fail(\"some error\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   * // Cleanup completed\n   *\n   * // Define an interrupted effect\n   * const interruption = Console.log(\"Task interrupted\").pipe(\n   *   Effect.andThen(Effect.interrupt),\n   *   handler\n   * )\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed\n   * ```\n   *\n   * @see {@link onExit} for a version that provides access to the result of an\n   * effect.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>\n} = fiberRuntime.ensuring\n\n/**\n * Ensures a cleanup effect runs whenever the calling effect fails, providing\n * the failure cause to the cleanup effect.\n *\n * **Details**\n *\n * This function allows you to attach a cleanup effect that runs whenever the\n * calling effect fails. The cleanup effect receives the cause of the failure,\n * allowing you to perform actions such as logging, releasing resources, or\n * executing additional recovery logic based on the error. The cleanup effect\n * will execute even if the failure is due to interruption.\n *\n * Importantly, the cleanup effect itself is uninterruptible, ensuring that it\n * completes regardless of external interruptions.\n *\n * **Example** (Running Cleanup Only on Failure)\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * // This handler logs the failure cause when the effect fails\n * const handler = Effect.onError((cause) =>\n *   Console.log(`Cleanup completed: ${cause}`)\n * )\n *\n * // Define a successful effect\n * const success = Console.log(\"Task completed\").pipe(\n *   Effect.as(\"some result\"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n *\n * // Define a failing effect\n * const failure = Console.log(\"Task failed\").pipe(\n *   Effect.andThen(Effect.fail(\"some error\")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed: Error: some error\n *\n * // Define a failing effect\n * const defect = Console.log(\"Task failed with defect\").pipe(\n *   Effect.andThen(Effect.die(\"Boom!\")),\n *   handler\n * )\n *\n * Effect.runFork(defect)\n * // Output:\n * // Task failed with defect\n * // Cleanup completed: Error: Boom!\n *\n * // Define an interrupted effect\n * const interruption = Console.log(\"Task interrupted\").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed: All fibers interrupted without errors.\n * ```\n *\n * @see {@link ensuring} for attaching a cleanup effect that runs on both success and failure.\n * @see {@link onExit} for attaching a cleanup effect that runs on all possible exits.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const onError: {\n  /**\n   * Ensures a cleanup effect runs whenever the calling effect fails, providing\n   * the failure cause to the cleanup effect.\n   *\n   * **Details**\n   *\n   * This function allows you to attach a cleanup effect that runs whenever the\n   * calling effect fails. The cleanup effect receives the cause of the failure,\n   * allowing you to perform actions such as logging, releasing resources, or\n   * executing additional recovery logic based on the error. The cleanup effect\n   * will execute even if the failure is due to interruption.\n   *\n   * Importantly, the cleanup effect itself is uninterruptible, ensuring that it\n   * completes regardless of external interruptions.\n   *\n   * **Example** (Running Cleanup Only on Failure)\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * // This handler logs the failure cause when the effect fails\n   * const handler = Effect.onError((cause) =>\n   *   Console.log(`Cleanup completed: ${cause}`)\n   * )\n   *\n   * // Define a successful effect\n   * const success = Console.log(\"Task completed\").pipe(\n   *   Effect.as(\"some result\"),\n   *   handler\n   * )\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   *\n   * // Define a failing effect\n   * const failure = Console.log(\"Task failed\").pipe(\n   *   Effect.andThen(Effect.fail(\"some error\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   * // Cleanup completed: Error: some error\n   *\n   * // Define a failing effect\n   * const defect = Console.log(\"Task failed with defect\").pipe(\n   *   Effect.andThen(Effect.die(\"Boom!\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(defect)\n   * // Output:\n   * // Task failed with defect\n   * // Cleanup completed: Error: Boom!\n   *\n   * // Define an interrupted effect\n   * const interruption = Console.log(\"Task interrupted\").pipe(\n   *   Effect.andThen(Effect.interrupt),\n   *   handler\n   * )\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed: All fibers interrupted without errors.\n   * ```\n   *\n   * @see {@link ensuring} for attaching a cleanup effect that runs on both success and failure.\n   * @see {@link onExit} for attaching a cleanup effect that runs on all possible exits.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>\n  /**\n   * Ensures a cleanup effect runs whenever the calling effect fails, providing\n   * the failure cause to the cleanup effect.\n   *\n   * **Details**\n   *\n   * This function allows you to attach a cleanup effect that runs whenever the\n   * calling effect fails. The cleanup effect receives the cause of the failure,\n   * allowing you to perform actions such as logging, releasing resources, or\n   * executing additional recovery logic based on the error. The cleanup effect\n   * will execute even if the failure is due to interruption.\n   *\n   * Importantly, the cleanup effect itself is uninterruptible, ensuring that it\n   * completes regardless of external interruptions.\n   *\n   * **Example** (Running Cleanup Only on Failure)\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * // This handler logs the failure cause when the effect fails\n   * const handler = Effect.onError((cause) =>\n   *   Console.log(`Cleanup completed: ${cause}`)\n   * )\n   *\n   * // Define a successful effect\n   * const success = Console.log(\"Task completed\").pipe(\n   *   Effect.as(\"some result\"),\n   *   handler\n   * )\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   *\n   * // Define a failing effect\n   * const failure = Console.log(\"Task failed\").pipe(\n   *   Effect.andThen(Effect.fail(\"some error\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   * // Cleanup completed: Error: some error\n   *\n   * // Define a failing effect\n   * const defect = Console.log(\"Task failed with defect\").pipe(\n   *   Effect.andThen(Effect.die(\"Boom!\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(defect)\n   * // Output:\n   * // Task failed with defect\n   * // Cleanup completed: Error: Boom!\n   *\n   * // Define an interrupted effect\n   * const interruption = Console.log(\"Task interrupted\").pipe(\n   *   Effect.andThen(Effect.interrupt),\n   *   handler\n   * )\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed: All fibers interrupted without errors.\n   * ```\n   *\n   * @see {@link ensuring} for attaching a cleanup effect that runs on both success and failure.\n   * @see {@link onExit} for attaching a cleanup effect that runs on all possible exits.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, X, R2>(\n    self: Effect<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>\n  ): Effect<A, E, R2 | R>\n} = core.onError\n\n/**\n * Guarantees that a cleanup function runs regardless of whether the effect\n * succeeds, fails, or is interrupted.\n *\n * **Details**\n *\n * This function ensures that a provided cleanup function is executed after the\n * effect completes, regardless of the outcome. The cleanup function is given\n * the `Exit` value of the effect, which provides detailed information about the\n * result:\n * - If the effect succeeds, the `Exit` contains the success value.\n * - If the effect fails, the `Exit` contains the error or failure cause.\n * - If the effect is interrupted, the `Exit` reflects the interruption.\n *\n * The cleanup function is guaranteed to run uninterruptibly, ensuring reliable\n * resource management even in complex or high-concurrency scenarios.\n *\n * **Example** (Running a Cleanup Function with the Effects Result)\n *\n * ```ts\n * import { Console, Effect, Exit } from \"effect\"\n *\n * // Define a cleanup effect that logs the result\n * const handler = Effect.onExit((exit) =>\n *   Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n * )\n *\n * // Define a successful effect\n * const success = Console.log(\"Task completed\").pipe(\n *   Effect.as(\"some result\"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n * // Cleanup completed: some result\n *\n * // Define a failing effect\n * const failure = Console.log(\"Task failed\").pipe(\n *   Effect.andThen(Effect.fail(\"some error\")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed: Error: some error\n *\n * // Define an interrupted effect\n * const interruption = Console.log(\"Task interrupted\").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed: All fibers interrupted without errors.\n * ```\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const onExit: {\n  /**\n   * Guarantees that a cleanup function runs regardless of whether the effect\n   * succeeds, fails, or is interrupted.\n   *\n   * **Details**\n   *\n   * This function ensures that a provided cleanup function is executed after the\n   * effect completes, regardless of the outcome. The cleanup function is given\n   * the `Exit` value of the effect, which provides detailed information about the\n   * result:\n   * - If the effect succeeds, the `Exit` contains the success value.\n   * - If the effect fails, the `Exit` contains the error or failure cause.\n   * - If the effect is interrupted, the `Exit` reflects the interruption.\n   *\n   * The cleanup function is guaranteed to run uninterruptibly, ensuring reliable\n   * resource management even in complex or high-concurrency scenarios.\n   *\n   * **Example** (Running a Cleanup Function with the Effects Result)\n   *\n   * ```ts\n   * import { Console, Effect, Exit } from \"effect\"\n   *\n   * // Define a cleanup effect that logs the result\n   * const handler = Effect.onExit((exit) =>\n   *   Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n   * )\n   *\n   * // Define a successful effect\n   * const success = Console.log(\"Task completed\").pipe(\n   *   Effect.as(\"some result\"),\n   *   handler\n   * )\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   * // Cleanup completed: some result\n   *\n   * // Define a failing effect\n   * const failure = Console.log(\"Task failed\").pipe(\n   *   Effect.andThen(Effect.fail(\"some error\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   * // Cleanup completed: Error: some error\n   *\n   * // Define an interrupted effect\n   * const interruption = Console.log(\"Task interrupted\").pipe(\n   *   Effect.andThen(Effect.interrupt),\n   *   handler\n   * )\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed: All fibers interrupted without errors.\n   * ```\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, X, R2>(cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>\n  /**\n   * Guarantees that a cleanup function runs regardless of whether the effect\n   * succeeds, fails, or is interrupted.\n   *\n   * **Details**\n   *\n   * This function ensures that a provided cleanup function is executed after the\n   * effect completes, regardless of the outcome. The cleanup function is given\n   * the `Exit` value of the effect, which provides detailed information about the\n   * result:\n   * - If the effect succeeds, the `Exit` contains the success value.\n   * - If the effect fails, the `Exit` contains the error or failure cause.\n   * - If the effect is interrupted, the `Exit` reflects the interruption.\n   *\n   * The cleanup function is guaranteed to run uninterruptibly, ensuring reliable\n   * resource management even in complex or high-concurrency scenarios.\n   *\n   * **Example** (Running a Cleanup Function with the Effects Result)\n   *\n   * ```ts\n   * import { Console, Effect, Exit } from \"effect\"\n   *\n   * // Define a cleanup effect that logs the result\n   * const handler = Effect.onExit((exit) =>\n   *   Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n   * )\n   *\n   * // Define a successful effect\n   * const success = Console.log(\"Task completed\").pipe(\n   *   Effect.as(\"some result\"),\n   *   handler\n   * )\n   *\n   * Effect.runFork(success)\n   * // Output:\n   * // Task completed\n   * // Cleanup completed: some result\n   *\n   * // Define a failing effect\n   * const failure = Console.log(\"Task failed\").pipe(\n   *   Effect.andThen(Effect.fail(\"some error\")),\n   *   handler\n   * )\n   *\n   * Effect.runFork(failure)\n   * // Output:\n   * // Task failed\n   * // Cleanup completed: Error: some error\n   *\n   * // Define an interrupted effect\n   * const interruption = Console.log(\"Task interrupted\").pipe(\n   *   Effect.andThen(Effect.interrupt),\n   *   handler\n   * )\n   *\n   * Effect.runFork(interruption)\n   * // Output:\n   * // Task interrupted\n   * // Cleanup completed: All fibers interrupted without errors.\n   * ```\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, X, R2>(\n    self: Effect<A, E, R>,\n    cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>\n  ): Effect<A, E, R | R2>\n} = core.onExit\n\n/**\n * Ensures that finalizers are run concurrently when the scope of an effect is\n * closed.\n *\n * **Details**\n *\n * This function modifies the behavior of finalizers within a scoped workflow to\n * allow them to run concurrently when the scope is closed.\n *\n * By default, finalizers are executed sequentially in reverse order of their\n * addition, but this function changes that behavior to execute all finalizers\n * concurrently.\n *\n * **When to Use**\n *\n * Running finalizers concurrently can improve performance when multiple\n * independent cleanup tasks need to be performed. However, it requires that\n * these tasks do not depend on the order of execution or introduce race\n * conditions.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * // Define a program that adds multiple finalizers\n * const program = Effect.gen(function*() {\n *   yield* Effect.addFinalizer(() => Console.log(\"Finalizer 1 executed\").pipe(Effect.delay(\"300 millis\")))\n *   yield* Effect.addFinalizer(() => Console.log(\"Finalizer 2 executed\").pipe(Effect.delay(\"100 millis\")))\n *   yield* Effect.addFinalizer(() => Console.log(\"Finalizer 3 executed\").pipe(Effect.delay(\"200 millis\")))\n *   return \"some result\"\n * })\n *\n * // Modify the program to ensure finalizers run in parallel\n * const modified = program.pipe(Effect.parallelFinalizers)\n *\n * const runnable = Effect.scoped(modified)\n *\n * Effect.runFork(runnable)\n * // Output:\n * // Finalizer 2 executed\n * // Finalizer 3 executed\n * // Finalizer 1 executed\n * ```\n *\n * @see {@link sequentialFinalizers} for a version that ensures finalizers are run sequentially.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> = fiberRuntime.parallelFinalizers\n\n/**\n * Ensures that finalizers are run sequentially in reverse order of their\n * addition.\n *\n * **Details**\n *\n * This function modifies the behavior of finalizers within a scoped workflow to\n * ensure they are run sequentially in reverse order when the scope is closed.\n *\n * By default, finalizers are executed sequentially, so this only changes the\n * behavior if the scope is configured to run finalizers concurrently.\n *\n * @see {@link parallelFinalizers} for a version that ensures finalizers are run concurrently.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> =\n  fiberRuntime.sequentialFinalizers\n\n/**\n * Applies a custom execution strategy to finalizers within a scoped workflow.\n *\n * **Details**\n *\n * This function allows you to control how finalizers are executed in a scope by\n * applying a specified `ExecutionStrategy`. The `strategy` can dictate whether\n * finalizers run (e.g., sequentially or in parallel).\n *\n * Additionally, the function provides a `restore` operation, which ensures that\n * the effect passed to it is executed under the default execution strategy.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const finalizersMask: (\n  strategy: ExecutionStrategy\n) => <A, E, R>(\n  self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>\n) => Effect<A, E, R> = fiberRuntime.finalizersMask\n\n/**\n * Provides access to the current scope in a scoped workflow.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const scope: Effect<Scope.Scope, never, Scope.Scope> = fiberRuntime.scope\n\n/**\n * Accesses the current scope and uses it to perform the specified effect.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope> =\n  fiberRuntime.scopeWith\n\n/**\n * Creates a `Scope`, passes it to the specified effectful function, and closes\n * the scope when the effect completes (whether through success, failure, or\n * interruption).\n *\n * @since 3.11.0\n * @category Scoping, Resources & Finalization\n */\nexport const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R> =\n  fiberRuntime.scopedWith\n\n/**\n * Scopes all resources used in an effect to the lifetime of the effect.\n *\n * **Details**\n *\n * This function ensures that all resources used within an effect are tied to\n * its lifetime. Finalizers for these resources are executed automatically when\n * the effect completes, whether through success, failure, or interruption. This\n * guarantees proper resource cleanup without requiring explicit management.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>> =\n  fiberRuntime.scopedEffect\n\n/**\n * Scopes all resources acquired by one effect to the lifetime of another\n * effect.\n *\n * **Details**\n *\n * This function allows you to scope the resources acquired by one effect\n * (`self`) to the lifetime of another effect (`use`). This ensures that the\n * resources are cleaned up as soon as the `use` effect completes, regardless of\n * how the `use` effect ends (success, failure, or interruption).\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const acquire = Console.log(\"Acquiring resource\").pipe(\n *   Effect.as(1),\n *   Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n * )\n * const use = (resource: number) => Console.log(`Using resource: ${resource}`)\n *\n * const program = acquire.pipe(Effect.using(use))\n *\n * Effect.runFork(program)\n * // Output:\n * // Acquiring resource\n * // Using resource: 1\n * // Releasing resource\n * ```\n *\n * @see {@link scopedWith} Manage scoped operations with a temporary scope.\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const using: {\n  /**\n   * Scopes all resources acquired by one effect to the lifetime of another\n   * effect.\n   *\n   * **Details**\n   *\n   * This function allows you to scope the resources acquired by one effect\n   * (`self`) to the lifetime of another effect (`use`). This ensures that the\n   * resources are cleaned up as soon as the `use` effect completes, regardless of\n   * how the `use` effect ends (success, failure, or interruption).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const acquire = Console.log(\"Acquiring resource\").pipe(\n   *   Effect.as(1),\n   *   Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n   * )\n   * const use = (resource: number) => Console.log(`Using resource: ${resource}`)\n   *\n   * const program = acquire.pipe(Effect.using(use))\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Acquiring resource\n   * // Using resource: 1\n   * // Releasing resource\n   * ```\n   *\n   * @see {@link scopedWith} Manage scoped operations with a temporary scope.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>\n  /**\n   * Scopes all resources acquired by one effect to the lifetime of another\n   * effect.\n   *\n   * **Details**\n   *\n   * This function allows you to scope the resources acquired by one effect\n   * (`self`) to the lifetime of another effect (`use`). This ensures that the\n   * resources are cleaned up as soon as the `use` effect completes, regardless of\n   * how the `use` effect ends (success, failure, or interruption).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const acquire = Console.log(\"Acquiring resource\").pipe(\n   *   Effect.as(1),\n   *   Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n   * )\n   * const use = (resource: number) => Console.log(`Using resource: ${resource}`)\n   *\n   * const program = acquire.pipe(Effect.using(use))\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // Acquiring resource\n   * // Using resource: 1\n   * // Releasing resource\n   * ```\n   *\n   * @see {@link scopedWith} Manage scoped operations with a temporary scope.\n   *\n   * @since 2.0.0\n   * @category Scoping, Resources & Finalization\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>\n} = fiberRuntime.using\n\n/**\n * Returns the result of the effect and a finalizer to close its scope.\n *\n * **Details**\n *\n * This function allows you to retrieve both the result of an effect and a\n * finalizer that can be used to manually close its scope. This is useful for\n * workflows where you need early access to the result while retaining control\n * over the resource cleanup process.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const acquire = Console.log(\"Acquiring resource\").pipe(\n *   Effect.as(1),\n *   Effect.tap(Effect.addFinalizer(() => Console.log(\"Releasing resource\")))\n * )\n * const program = Effect.gen(function*() {\n *   const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n *   console.log(`Using resource: ${resource}`)\n *   yield* Effect.sleep(\"1 second\")\n *   yield* finalizer\n * })\n *\n * Effect.runFork(program.pipe(Effect.scoped))\n * // Output:\n * // Acquiring resource\n * // Using resource: 1\n * // Releasing resource\n * ```\n *\n * @since 2.0.0\n * @category Scoping, Resources & Finalization\n */\nexport const withEarlyRelease: <A, E, R>(\n  self: Effect<A, E, R>\n) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope> = fiberRuntime.withEarlyRelease\n\n/**\n * Returns a new effect that will not succeed with its value before first\n * waiting for the end of all child fibers forked by the effect.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> = circular.awaitAllChildren\n\n/**\n * Returns a new workflow that will not supervise any fibers forked by this\n * workflow.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R> = fiberRuntime.daemonChildren\n\n/**\n * Constructs an effect with information about the current `Fiber`.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const descriptor: Effect<Fiber.Fiber.Descriptor> = effect.descriptor\n\n/**\n * Constructs an effect based on information about the current `Fiber`.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const descriptorWith: <A, E, R>(f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R> =\n  effect.descriptorWith\n\n/**\n * Returns a new workflow that executes this one and captures the changes in\n * `FiberRef` values.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const diffFiberRefs: <A, E, R>(\n  self: Effect<A, E, R>\n) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R> = effect.diffFiberRefs\n\n/**\n * Acts on the children of this fiber (collected into a single fiber),\n * guaranteeing the specified callback will be invoked, whether or not this\n * effect succeeds.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const ensuringChild: {\n  /**\n   * Acts on the children of this fiber (collected into a single fiber),\n   * guaranteeing the specified callback will be invoked, whether or not this\n   * effect succeeds.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <X, R2>(\n    f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>\n  /**\n   * Acts on the children of this fiber (collected into a single fiber),\n   * guaranteeing the specified callback will be invoked, whether or not this\n   * effect succeeds.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <A, E, R, X, R2>(\n    self: Effect<A, E, R>,\n    f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>\n  ): Effect<A, E, R | R2>\n} = circular.ensuringChild\n\n/**\n * Acts on the children of this fiber, guaranteeing the specified callback\n * will be invoked, whether or not this effect succeeds.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const ensuringChildren: {\n  /**\n   * Acts on the children of this fiber, guaranteeing the specified callback\n   * will be invoked, whether or not this effect succeeds.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <X, R2>(\n    children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>\n  /**\n   * Acts on the children of this fiber, guaranteeing the specified callback\n   * will be invoked, whether or not this effect succeeds.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <A, E, R, X, R2>(\n    self: Effect<A, E, R>,\n    children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>\n  ): Effect<A, E, R | R2>\n} = circular.ensuringChildren\n\n/**\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const fiberId: Effect<FiberId.FiberId> = core.fiberId\n\n/**\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const fiberIdWith: <A, E, R>(f: (descriptor: FiberId.Runtime) => Effect<A, E, R>) => Effect<A, E, R> =\n  core.fiberIdWith\n\n/**\n * Creates a new fiber to run an effect concurrently.\n *\n * **Details**\n *\n * This function takes an effect and forks it into a separate fiber, allowing it\n * to run concurrently without blocking the original effect. The new fiber\n * starts execution immediately after being created, and the fiber object is\n * returned immediately without waiting for the effect to begin. This is useful\n * when you want to run tasks concurrently while continuing other tasks in the\n * parent fiber.\n *\n * The forked fiber is attached to the parent fiber's scope. This means that\n * when the parent fiber terminates, the child fiber will also be terminated\n * automatically. This feature, known as \"auto supervision,\" ensures that no\n * fibers are left running unintentionally. If you prefer not to have this auto\n * supervision behavior, you can use {@link forkDaemon} or {@link forkIn}.\n *\n * **When to Use**\n *\n * Use this function when you need to run an effect concurrently without\n * blocking the current execution flow. For example, you might use it to launch\n * background tasks or concurrent computations. However, working with fibers can\n * be complex, so before using this function directly, you might want to explore\n * higher-level functions like {@link raceWith}, {@link zip}, or others that can\n * manage concurrency for you.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const fib = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(n)\n *     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n *\n * //       Effect<RuntimeFiber<number, never>, never, never>\n * //      \n * const fib10Fiber = Effect.fork(fib(10))\n * ```\n *\n * @see {@link forkWithErrorHandler} for a version that allows you to handle errors.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R> = fiberRuntime.fork\n\n/**\n * Creates a long-running background fiber that is independent of its parent.\n *\n * **Details**\n *\n * This function creates a \"daemon\" fiber that runs in the background and is not\n * tied to the lifecycle of its parent fiber. Unlike normal fibers that stop\n * when the parent fiber terminates, a daemon fiber will continue running until\n * the global scope closes or the fiber completes naturally. This makes it\n * useful for tasks that need to run in the background independently, such as\n * periodic logging, monitoring, or background data processing.\n *\n * **Example** (Creating a Daemon Fiber)\n *\n * ```ts\n * import { Effect, Console, Schedule } from \"effect\"\n *\n * // Daemon fiber that logs a message repeatedly every second\n * const daemon = Effect.repeat(\n *   Console.log(\"daemon: still running!\"),\n *   Schedule.fixed(\"1 second\")\n * )\n *\n * const parent = Effect.gen(function* () {\n *   console.log(\"parent: started!\")\n *   // Daemon fiber running independently\n *   yield* Effect.forkDaemon(daemon)\n *   yield* Effect.sleep(\"3 seconds\")\n *   console.log(\"parent: finished!\")\n * })\n *\n * Effect.runFork(parent)\n * // Output:\n * // parent: started!\n * // daemon: still running!\n * // daemon: still running!\n * // daemon: still running!\n * // parent: finished!\n * // daemon: still running!\n * // daemon: still running!\n * // daemon: still running!\n * // daemon: still running!\n * // daemon: still running!\n * // ...etc...\n * ```\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R> =\n  fiberRuntime.forkDaemon\n\n/**\n * Returns an effect that forks all of the specified values, and returns a\n * composite fiber that produces a list of their results, in order.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const forkAll: {\n  /**\n   * Returns an effect that forks all of the specified values, and returns a\n   * composite fiber that produces a list of their results, in order.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  (options?: { readonly discard?: false | undefined } | undefined): <Eff extends Effect<any, any, any>>(\n    effects: Iterable<Eff>\n  ) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>\n  /**\n   * Returns an effect that forks all of the specified values, and returns a\n   * composite fiber that produces a list of their results, in order.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  (options: { readonly discard: true }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>\n  /**\n   * Returns an effect that forks all of the specified values, and returns a\n   * composite fiber that produces a list of their results, in order.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <Eff extends Effect<any, any, any>>(\n    effects: Iterable<Eff>,\n    options?: { readonly discard?: false | undefined } | undefined\n  ): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>\n  /**\n   * Returns an effect that forks all of the specified values, and returns a\n   * composite fiber that produces a list of their results, in order.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true }): Effect<void, never, Effect.Context<Eff>>\n} = circular.forkAll\n\n/**\n * Forks an effect in a specific scope, allowing finer control over its\n * execution.\n *\n * **Details**\n *\n * There are some cases where we need more fine-grained control, so we want to\n * fork a fiber in a specific scope. We can use the `Effect.forkIn` operator\n * which takes the target scope as an argument.\n *\n * The fiber will be interrupted when the scope is closed.\n *\n * **Example** (Forking a Fiber in a Specific Scope)\n *\n * In this example, the child fiber is forked into the outerScope,\n * allowing it to outlive the inner scope but still be terminated\n * when the outerScope is closed.\n *\n * ```ts\n * import { Console, Effect, Schedule } from \"effect\"\n *\n * // Child fiber that logs a message repeatedly every second\n * const child = Effect.repeat(\n *   Console.log(\"child: still running!\"),\n *   Schedule.fixed(\"1 second\")\n * )\n *\n * const program = Effect.scoped(\n *   Effect.gen(function* () {\n *     yield* Effect.addFinalizer(() =>\n *       Console.log(\"The outer scope is about to be closed!\")\n *     )\n *\n *     // Capture the outer scope\n *     const outerScope = yield* Effect.scope\n *\n *     // Create an inner scope\n *     yield* Effect.scoped(\n *       Effect.gen(function* () {\n *         yield* Effect.addFinalizer(() =>\n *           Console.log(\"The inner scope is about to be closed!\")\n *         )\n *         // Fork the child fiber in the outer scope\n *         yield* Effect.forkIn(child, outerScope)\n *         yield* Effect.sleep(\"3 seconds\")\n *       })\n *     )\n *\n *     yield* Effect.sleep(\"5 seconds\")\n *   })\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // The inner scope is about to be closed!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // The outer scope is about to be closed!\n * ```\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const forkIn: {\n  /**\n   * Forks an effect in a specific scope, allowing finer control over its\n   * execution.\n   *\n   * **Details**\n   *\n   * There are some cases where we need more fine-grained control, so we want to\n   * fork a fiber in a specific scope. We can use the `Effect.forkIn` operator\n   * which takes the target scope as an argument.\n   *\n   * The fiber will be interrupted when the scope is closed.\n   *\n   * **Example** (Forking a Fiber in a Specific Scope)\n   *\n   * In this example, the child fiber is forked into the outerScope,\n   * allowing it to outlive the inner scope but still be terminated\n   * when the outerScope is closed.\n   *\n   * ```ts\n   * import { Console, Effect, Schedule } from \"effect\"\n   *\n   * // Child fiber that logs a message repeatedly every second\n   * const child = Effect.repeat(\n   *   Console.log(\"child: still running!\"),\n   *   Schedule.fixed(\"1 second\")\n   * )\n   *\n   * const program = Effect.scoped(\n   *   Effect.gen(function* () {\n   *     yield* Effect.addFinalizer(() =>\n   *       Console.log(\"The outer scope is about to be closed!\")\n   *     )\n   *\n   *     // Capture the outer scope\n   *     const outerScope = yield* Effect.scope\n   *\n   *     // Create an inner scope\n   *     yield* Effect.scoped(\n   *       Effect.gen(function* () {\n   *         yield* Effect.addFinalizer(() =>\n   *           Console.log(\"The inner scope is about to be closed!\")\n   *         )\n   *         // Fork the child fiber in the outer scope\n   *         yield* Effect.forkIn(child, outerScope)\n   *         yield* Effect.sleep(\"3 seconds\")\n   *       })\n   *     )\n   *\n   *     yield* Effect.sleep(\"5 seconds\")\n   *   })\n   * )\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // The inner scope is about to be closed!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // The outer scope is about to be closed!\n   * ```\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  (scope: Scope.Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>\n  /**\n   * Forks an effect in a specific scope, allowing finer control over its\n   * execution.\n   *\n   * **Details**\n   *\n   * There are some cases where we need more fine-grained control, so we want to\n   * fork a fiber in a specific scope. We can use the `Effect.forkIn` operator\n   * which takes the target scope as an argument.\n   *\n   * The fiber will be interrupted when the scope is closed.\n   *\n   * **Example** (Forking a Fiber in a Specific Scope)\n   *\n   * In this example, the child fiber is forked into the outerScope,\n   * allowing it to outlive the inner scope but still be terminated\n   * when the outerScope is closed.\n   *\n   * ```ts\n   * import { Console, Effect, Schedule } from \"effect\"\n   *\n   * // Child fiber that logs a message repeatedly every second\n   * const child = Effect.repeat(\n   *   Console.log(\"child: still running!\"),\n   *   Schedule.fixed(\"1 second\")\n   * )\n   *\n   * const program = Effect.scoped(\n   *   Effect.gen(function* () {\n   *     yield* Effect.addFinalizer(() =>\n   *       Console.log(\"The outer scope is about to be closed!\")\n   *     )\n   *\n   *     // Capture the outer scope\n   *     const outerScope = yield* Effect.scope\n   *\n   *     // Create an inner scope\n   *     yield* Effect.scoped(\n   *       Effect.gen(function* () {\n   *         yield* Effect.addFinalizer(() =>\n   *           Console.log(\"The inner scope is about to be closed!\")\n   *         )\n   *         // Fork the child fiber in the outer scope\n   *         yield* Effect.forkIn(child, outerScope)\n   *         yield* Effect.sleep(\"3 seconds\")\n   *       })\n   *     )\n   *\n   *     yield* Effect.sleep(\"5 seconds\")\n   *   })\n   * )\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // The inner scope is about to be closed!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // child: still running!\n   * // The outer scope is about to be closed!\n   * ```\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <A, E, R>(self: Effect<A, E, R>, scope: Scope.Scope): Effect<Fiber.RuntimeFiber<A, E>, never, R>\n} = circular.forkIn\n\n/**\n * Forks a fiber in a local scope, ensuring it outlives its parent.\n *\n * **Details**\n *\n * This function is used to create fibers that are tied to a local scope,\n * meaning they are not dependent on their parent fiber's lifecycle. Instead,\n * they will continue running until the scope they were created in is closed.\n * This is particularly useful when you need a fiber to run independently of the\n * parent fiber, but still want it to be terminated when the scope ends.\n *\n * Fibers created with this function are isolated from the parent fibers\n * termination, so they can run for a longer period. This behavior is different\n * from fibers created with {@link fork}, which are terminated when the parent fiber\n * terminates. With `forkScoped`, the child fiber will keep running until the\n * local scope ends, regardless of the state of the parent fiber.\n *\n * **Example** (Forking a Fiber in a Local Scope)\n *\n * In this example, the child fiber continues to run beyond the lifetime of the parent fiber.\n * The child fiber is tied to the local scope and will be terminated only when the scope ends.\n *\n * ```ts\n * import { Effect, Console, Schedule } from \"effect\"\n *\n * // Child fiber that logs a message repeatedly every second\n * const child = Effect.repeat(\n *   Console.log(\"child: still running!\"),\n *   Schedule.fixed(\"1 second\")\n * )\n *\n * //       Effect<void, never, Scope>\n * //      \n * const parent = Effect.gen(function* () {\n *   console.log(\"parent: started!\")\n *   // Child fiber attached to local scope\n *   yield* Effect.forkScoped(child)\n *   yield* Effect.sleep(\"3 seconds\")\n *   console.log(\"parent: finished!\")\n * })\n *\n * // Program runs within a local scope\n * const program = Effect.scoped(\n *   Effect.gen(function* () {\n *     console.log(\"Local scope started!\")\n *     yield* Effect.fork(parent)\n *     // Scope lasts for 5 seconds\n *     yield* Effect.sleep(\"5 seconds\")\n *     console.log(\"Leaving the local scope!\")\n *   })\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // Local scope started!\n * // parent: started!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // parent: finished!\n * // child: still running!\n * // child: still running!\n * // Leaving the local scope!\n * ```\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const forkScoped: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R> =\n  circular.forkScoped\n\n/**\n * Like {@link fork} but handles an error with the provided handler.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const forkWithErrorHandler: {\n  /**\n   * Like {@link fork} but handles an error with the provided handler.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>\n  /**\n   * Like {@link fork} but handles an error with the provided handler.\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>\n} = fiberRuntime.forkWithErrorHandler\n\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @see {@link fromFiberEffect} for creating an effect from a fiber obtained from an effect.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E> = circular.fromFiber\n\n/**\n * Creates an `Effect` value that represents the exit value of a fiber obtained\n * from an effect.\n *\n * @see {@link fromFiber} for creating an effect from a fiber.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R> =\n  circular.fromFiberEffect\n\n/**\n * Supervises child fibers by reporting them to a specified supervisor.\n *\n * **Details**\n *\n * This function takes a supervisor as an argument and returns an effect where\n * all child fibers forked within it are supervised by the provided supervisor.\n * This enables you to capture detailed information about these child fibers,\n * such as their status, through the supervisor.\n *\n * **Example** (Monitoring Fiber Count)\n *\n * ```ts\n * import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n *\n * // Main program that monitors fibers while calculating a Fibonacci number\n * const program = Effect.gen(function* () {\n *   // Create a supervisor to track child fibers\n *   const supervisor = yield* Supervisor.track\n *\n *   // Start a Fibonacci calculation, supervised by the supervisor\n *   const fibFiber = yield* fib(20).pipe(\n *     Effect.supervised(supervisor),\n *     // Fork the Fibonacci effect into a fiber\n *     Effect.fork\n *   )\n *\n *   // Define a schedule to periodically monitor the fiber count every 500ms\n *   const policy = Schedule.spaced(\"500 millis\").pipe(\n *     Schedule.whileInputEffect((_) =>\n *       Fiber.status(fibFiber).pipe(\n *         // Continue while the Fibonacci fiber is not done\n *         Effect.andThen((status) => status !== FiberStatus.done)\n *       )\n *     )\n *   )\n *\n *   // Start monitoring the fibers, using the supervisor to track the count\n *   const monitorFiber = yield* monitorFibers(supervisor).pipe(\n *     // Repeat the monitoring according to the schedule\n *     Effect.repeat(policy),\n *     // Fork the monitoring into its own fiber\n *     Effect.fork\n *   )\n *\n *   // Join the monitor and Fibonacci fibers to ensure they complete\n *   yield* Fiber.join(monitorFiber)\n *   const result = yield* Fiber.join(fibFiber)\n *\n *   console.log(`fibonacci result: ${result}`)\n * })\n *\n * // Function to monitor and log the number of active fibers\n * const monitorFibers = (\n *   supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n * ): Effect.Effect<void> =>\n *   Effect.gen(function* () {\n *     const fibers = yield* supervisor.value // Get the current set of fibers\n *     console.log(`number of fibers: ${fibers.length}`)\n *   })\n *\n * // Recursive Fibonacci calculation, spawning fibers for each recursive step\n * const fib = (n: number): Effect.Effect<number> =>\n *   Effect.gen(function* () {\n *     if (n <= 1) {\n *       return 1\n *     }\n *     yield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n *\n *     // Fork two fibers for the recursive Fibonacci calls\n *     const fiber1 = yield* Effect.fork(fib(n - 2))\n *     const fiber2 = yield* Effect.fork(fib(n - 1))\n *\n *     // Join the fibers to retrieve their results\n *     const v1 = yield* Fiber.join(fiber1)\n *     const v2 = yield* Fiber.join(fiber2)\n *\n *     return v1 + v2 // Combine the results\n *   })\n *\n * Effect.runPromise(program)\n * // Output:\n * // number of fibers: 0\n * // number of fibers: 2\n * // number of fibers: 6\n * // number of fibers: 14\n * // number of fibers: 30\n * // number of fibers: 62\n * // number of fibers: 126\n * // number of fibers: 254\n * // number of fibers: 510\n * // number of fibers: 1022\n * // number of fibers: 2034\n * // number of fibers: 3795\n * // number of fibers: 5810\n * // number of fibers: 6474\n * // number of fibers: 4942\n * // number of fibers: 2515\n * // number of fibers: 832\n * // number of fibers: 170\n * // number of fibers: 18\n * // number of fibers: 0\n * // fibonacci result: 10946\n * ```\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const supervised: {\n  /**\n   * Supervises child fibers by reporting them to a specified supervisor.\n   *\n   * **Details**\n   *\n   * This function takes a supervisor as an argument and returns an effect where\n   * all child fibers forked within it are supervised by the provided supervisor.\n   * This enables you to capture detailed information about these child fibers,\n   * such as their status, through the supervisor.\n   *\n   * **Example** (Monitoring Fiber Count)\n   *\n   * ```ts\n   * import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n   *\n   * // Main program that monitors fibers while calculating a Fibonacci number\n   * const program = Effect.gen(function* () {\n   *   // Create a supervisor to track child fibers\n   *   const supervisor = yield* Supervisor.track\n   *\n   *   // Start a Fibonacci calculation, supervised by the supervisor\n   *   const fibFiber = yield* fib(20).pipe(\n   *     Effect.supervised(supervisor),\n   *     // Fork the Fibonacci effect into a fiber\n   *     Effect.fork\n   *   )\n   *\n   *   // Define a schedule to periodically monitor the fiber count every 500ms\n   *   const policy = Schedule.spaced(\"500 millis\").pipe(\n   *     Schedule.whileInputEffect((_) =>\n   *       Fiber.status(fibFiber).pipe(\n   *         // Continue while the Fibonacci fiber is not done\n   *         Effect.andThen((status) => status !== FiberStatus.done)\n   *       )\n   *     )\n   *   )\n   *\n   *   // Start monitoring the fibers, using the supervisor to track the count\n   *   const monitorFiber = yield* monitorFibers(supervisor).pipe(\n   *     // Repeat the monitoring according to the schedule\n   *     Effect.repeat(policy),\n   *     // Fork the monitoring into its own fiber\n   *     Effect.fork\n   *   )\n   *\n   *   // Join the monitor and Fibonacci fibers to ensure they complete\n   *   yield* Fiber.join(monitorFiber)\n   *   const result = yield* Fiber.join(fibFiber)\n   *\n   *   console.log(`fibonacci result: ${result}`)\n   * })\n   *\n   * // Function to monitor and log the number of active fibers\n   * const monitorFibers = (\n   *   supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n   * ): Effect.Effect<void> =>\n   *   Effect.gen(function* () {\n   *     const fibers = yield* supervisor.value // Get the current set of fibers\n   *     console.log(`number of fibers: ${fibers.length}`)\n   *   })\n   *\n   * // Recursive Fibonacci calculation, spawning fibers for each recursive step\n   * const fib = (n: number): Effect.Effect<number> =>\n   *   Effect.gen(function* () {\n   *     if (n <= 1) {\n   *       return 1\n   *     }\n   *     yield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n   *\n   *     // Fork two fibers for the recursive Fibonacci calls\n   *     const fiber1 = yield* Effect.fork(fib(n - 2))\n   *     const fiber2 = yield* Effect.fork(fib(n - 1))\n   *\n   *     // Join the fibers to retrieve their results\n   *     const v1 = yield* Fiber.join(fiber1)\n   *     const v2 = yield* Fiber.join(fiber2)\n   *\n   *     return v1 + v2 // Combine the results\n   *   })\n   *\n   * Effect.runPromise(program)\n   * // Output:\n   * // number of fibers: 0\n   * // number of fibers: 2\n   * // number of fibers: 6\n   * // number of fibers: 14\n   * // number of fibers: 30\n   * // number of fibers: 62\n   * // number of fibers: 126\n   * // number of fibers: 254\n   * // number of fibers: 510\n   * // number of fibers: 1022\n   * // number of fibers: 2034\n   * // number of fibers: 3795\n   * // number of fibers: 5810\n   * // number of fibers: 6474\n   * // number of fibers: 4942\n   * // number of fibers: 2515\n   * // number of fibers: 832\n   * // number of fibers: 170\n   * // number of fibers: 18\n   * // number of fibers: 0\n   * // fibonacci result: 10946\n   * ```\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Supervises child fibers by reporting them to a specified supervisor.\n   *\n   * **Details**\n   *\n   * This function takes a supervisor as an argument and returns an effect where\n   * all child fibers forked within it are supervised by the provided supervisor.\n   * This enables you to capture detailed information about these child fibers,\n   * such as their status, through the supervisor.\n   *\n   * **Example** (Monitoring Fiber Count)\n   *\n   * ```ts\n   * import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n   *\n   * // Main program that monitors fibers while calculating a Fibonacci number\n   * const program = Effect.gen(function* () {\n   *   // Create a supervisor to track child fibers\n   *   const supervisor = yield* Supervisor.track\n   *\n   *   // Start a Fibonacci calculation, supervised by the supervisor\n   *   const fibFiber = yield* fib(20).pipe(\n   *     Effect.supervised(supervisor),\n   *     // Fork the Fibonacci effect into a fiber\n   *     Effect.fork\n   *   )\n   *\n   *   // Define a schedule to periodically monitor the fiber count every 500ms\n   *   const policy = Schedule.spaced(\"500 millis\").pipe(\n   *     Schedule.whileInputEffect((_) =>\n   *       Fiber.status(fibFiber).pipe(\n   *         // Continue while the Fibonacci fiber is not done\n   *         Effect.andThen((status) => status !== FiberStatus.done)\n   *       )\n   *     )\n   *   )\n   *\n   *   // Start monitoring the fibers, using the supervisor to track the count\n   *   const monitorFiber = yield* monitorFibers(supervisor).pipe(\n   *     // Repeat the monitoring according to the schedule\n   *     Effect.repeat(policy),\n   *     // Fork the monitoring into its own fiber\n   *     Effect.fork\n   *   )\n   *\n   *   // Join the monitor and Fibonacci fibers to ensure they complete\n   *   yield* Fiber.join(monitorFiber)\n   *   const result = yield* Fiber.join(fibFiber)\n   *\n   *   console.log(`fibonacci result: ${result}`)\n   * })\n   *\n   * // Function to monitor and log the number of active fibers\n   * const monitorFibers = (\n   *   supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n   * ): Effect.Effect<void> =>\n   *   Effect.gen(function* () {\n   *     const fibers = yield* supervisor.value // Get the current set of fibers\n   *     console.log(`number of fibers: ${fibers.length}`)\n   *   })\n   *\n   * // Recursive Fibonacci calculation, spawning fibers for each recursive step\n   * const fib = (n: number): Effect.Effect<number> =>\n   *   Effect.gen(function* () {\n   *     if (n <= 1) {\n   *       return 1\n   *     }\n   *     yield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n   *\n   *     // Fork two fibers for the recursive Fibonacci calls\n   *     const fiber1 = yield* Effect.fork(fib(n - 2))\n   *     const fiber2 = yield* Effect.fork(fib(n - 1))\n   *\n   *     // Join the fibers to retrieve their results\n   *     const v1 = yield* Fiber.join(fiber1)\n   *     const v2 = yield* Fiber.join(fiber2)\n   *\n   *     return v1 + v2 // Combine the results\n   *   })\n   *\n   * Effect.runPromise(program)\n   * // Output:\n   * // number of fibers: 0\n   * // number of fibers: 2\n   * // number of fibers: 6\n   * // number of fibers: 14\n   * // number of fibers: 30\n   * // number of fibers: 62\n   * // number of fibers: 126\n   * // number of fibers: 254\n   * // number of fibers: 510\n   * // number of fibers: 1022\n   * // number of fibers: 2034\n   * // number of fibers: 3795\n   * // number of fibers: 5810\n   * // number of fibers: 6474\n   * // number of fibers: 4942\n   * // number of fibers: 2515\n   * // number of fibers: 832\n   * // number of fibers: 170\n   * // number of fibers: 18\n   * // number of fibers: 0\n   * // fibonacci result: 10946\n   * ```\n   *\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>\n} = circular.supervised\n\n/**\n * Transplants specified effects so that when those effects fork other\n * effects, the forked effects will be governed by the scope of the fiber that\n * executes this effect.\n *\n * This can be used to \"graft\" deep grandchildren onto a higher-level scope,\n * effectively extending their lifespans into the parent scope.\n *\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const transplant: <A, E, R>(\n  f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>\n) => Effect<A, E, R> = core.transplant\n\n/**\n * @since 2.0.0\n * @category Supervision & Fibers\n */\nexport const withConcurrency: {\n  /**\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  (concurrency: number | \"unbounded\"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Supervision & Fibers\n   */\n  <A, E, R>(self: Effect<A, E, R>, concurrency: number | \"unbounded\"): Effect<A, E, R>\n} = core.withConcurrency\n\n/**\n * Sets the provided scheduler for usage in the wrapped effect\n *\n * @since 2.0.0\n * @category Scheduler\n */\nexport const withScheduler: {\n  /**\n   * Sets the provided scheduler for usage in the wrapped effect\n   *\n   * @since 2.0.0\n   * @category Scheduler\n   */\n  (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Sets the provided scheduler for usage in the wrapped effect\n   *\n   * @since 2.0.0\n   * @category Scheduler\n   */\n  <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>\n} = Scheduler.withScheduler\n\n/**\n * Sets the scheduling priority used when yielding\n *\n * @since 2.0.0\n * @category Scheduler\n */\nexport const withSchedulingPriority: {\n  /**\n   * Sets the scheduling priority used when yielding\n   *\n   * @since 2.0.0\n   * @category Scheduler\n   */\n  (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Sets the scheduling priority used when yielding\n   *\n   * @since 2.0.0\n   * @category Scheduler\n   */\n  <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>\n} = core.withSchedulingPriority\n\n/**\n * Sets the maximum number of operations before yield by the default schedulers\n *\n * @since 2.0.0\n * @category Scheduler\n */\nexport const withMaxOpsBeforeYield: {\n  /**\n   * Sets the maximum number of operations before yield by the default schedulers\n   *\n   * @since 2.0.0\n   * @category Scheduler\n   */\n  (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Sets the maximum number of operations before yield by the default schedulers\n   *\n   * @since 2.0.0\n   * @category Scheduler\n   */\n  <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>\n} = core.withMaxOpsBeforeYield\n\n/**\n * Retrieves the `Clock` service from the context.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   const clock = yield* Effect.clock\n *   const currentTime = yield* clock.currentTimeMillis\n *   console.log(`Current time in milliseconds: ${currentTime}`)\n * })\n *\n * Effect.runFork(program)\n * // Example Output:\n * // Current time in milliseconds: 1735484796134\n * ```\n *\n * @since 2.0.0\n * @category Clock\n */\nexport const clock: Effect<Clock.Clock> = effect.clock\n\n/**\n * Retrieves the `Clock` service from the context and provides it to the\n * specified effectful function.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const program = Effect.clockWith((clock) =>\n *   clock.currentTimeMillis.pipe(\n *     Effect.map((currentTime) => `Current time is: ${currentTime}`),\n *     Effect.tap(Console.log)\n *   )\n * )\n *\n * Effect.runFork(program)\n * // Example Output:\n * // Current time is: 1735484929744\n * ```\n *\n * @since 2.0.0\n * @category Clock\n */\nexport const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R> = effect.clockWith\n\n/**\n * Sets the implementation of the `Clock` service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n * @category Clock\n */\nexport const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope> =\n  fiberRuntime.withClockScoped\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * `Clock` service.\n *\n * @since 2.0.0\n * @category Clock\n */\nexport const withClock: {\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * `Clock` service.\n   *\n   * @since 2.0.0\n   * @category Clock\n   */\n  <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * `Clock` service.\n   *\n   * @since 2.0.0\n   * @category Clock\n   */\n  <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>\n} = defaultServices.withClock\n\n/**\n * Retreives the `Console` service from the context\n *\n * @since 2.0.0\n * @category Console\n */\nexport const console: Effect<Console> = console_.console\n\n/**\n * Retreives the `Console` service from the context and provides it to the\n * specified effectful function.\n *\n * @since 2.0.0\n * @category Console\n */\nexport const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R> = console_.consoleWith\n\n/**\n * Sets the implementation of the console service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n * @category Creating Effects\n */\nexport const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope> =\n  console_.withConsoleScoped\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * console service.\n *\n * @since 2.0.0\n * @category Console\n */\nexport const withConsole: {\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * console service.\n   *\n   * @since 2.0.0\n   * @category Console\n   */\n  <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * console service.\n   *\n   * @since 2.0.0\n   * @category Console\n   */\n  <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>\n} = console_.withConsole\n\n/**\n * Delays the execution of an effect by a specified `Duration`.\n *\n * **Details\n *\n * This function postpones the execution of the provided effect by the specified\n * duration. The duration can be provided in various formats supported by the\n * `Duration` module.\n *\n * Internally, this function does not block the thread; instead, it uses an\n * efficient, non-blocking mechanism to introduce the delay.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const task = Console.log(\"Task executed\")\n *\n * const program = Console.log(\"start\").pipe(\n *   Effect.andThen(\n *     // Delays the log message by 2 seconds\n *     task.pipe(Effect.delay(\"2 seconds\"))\n *   )\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // start\n * // Task executed\n * ```\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const delay: {\n  /**\n   * Delays the execution of an effect by a specified `Duration`.\n   *\n   * **Details\n   *\n   * This function postpones the execution of the provided effect by the specified\n   * duration. The duration can be provided in various formats supported by the\n   * `Duration` module.\n   *\n   * Internally, this function does not block the thread; instead, it uses an\n   * efficient, non-blocking mechanism to introduce the delay.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const task = Console.log(\"Task executed\")\n   *\n   * const program = Console.log(\"start\").pipe(\n   *   Effect.andThen(\n   *     // Delays the log message by 2 seconds\n   *     task.pipe(Effect.delay(\"2 seconds\"))\n   *   )\n   * )\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // start\n   * // Task executed\n   * ```\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Delays the execution of an effect by a specified `Duration`.\n   *\n   * **Details\n   *\n   * This function postpones the execution of the provided effect by the specified\n   * duration. The duration can be provided in various formats supported by the\n   * `Duration` module.\n   *\n   * Internally, this function does not block the thread; instead, it uses an\n   * efficient, non-blocking mechanism to introduce the delay.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Console, Effect } from \"effect\"\n   *\n   * const task = Console.log(\"Task executed\")\n   *\n   * const program = Console.log(\"start\").pipe(\n   *   Effect.andThen(\n   *     // Delays the log message by 2 seconds\n   *     task.pipe(Effect.delay(\"2 seconds\"))\n   *   )\n   * )\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // start\n   * // Task executed\n   * ```\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>\n} = effect.delay\n\n/**\n * Suspends the execution of an effect for a specified `Duration`.\n *\n * **Details**\n *\n * This function pauses the execution of an effect for a given duration. It is\n * asynchronous, meaning that it does not block the fiber executing the effect.\n * Instead, the fiber is suspended during the delay period and can resume once\n * the specified time has passed.\n *\n * The duration can be specified using various formats supported by the\n * `Duration` module, such as a string (`\"2 seconds\"`) or numeric value\n * representing milliseconds.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   console.log(\"Starting task...\")\n *   yield* Effect.sleep(\"3 seconds\") // Waits for 3 seconds\n *   console.log(\"Task completed!\")\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // Starting task...\n * // Task completed!\n * ```\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const sleep: (duration: Duration.DurationInput) => Effect<void> = effect.sleep\n\n/**\n * Executes an effect and measures the time it takes to complete.\n *\n * **Details**\n *\n * This function wraps the provided effect and returns a new effect that, when\n * executed, performs the original effect and calculates its execution duration.\n *\n * The result of the new effect includes both the execution time (as a\n * `Duration`) and the original effect's result. This is useful for monitoring\n * performance or gaining insights into the time taken by specific operations.\n *\n * The original effect's behavior (success, failure, or interruption) remains\n * unchanged, and the timing information is provided alongside the result in a\n * tuple.\n *\n * **Example**\n *\n * ```ts\n * import { Duration, Effect } from \"effect\"\n *\n * const task = Effect.gen(function*() {\n *   yield* Effect.sleep(\"2 seconds\") // Simulates some work\n *   return \"some result\"\n * })\n *\n * const timedTask = task.pipe(Effect.timed)\n *\n * const program = Effect.gen(function*() {\n *   const [duration, result] = yield* timedTask\n *   console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n * })\n *\n * Effect.runFork(program)\n * // Output: Task completed in 2003.749125 ms with result: some result\n * ```\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R> =\n  effect.timed\n\n/**\n * Executes an effect and measures its execution time using a custom clock.\n *\n * **Details**\n *\n * This function extends the functionality of {@link timed} by allowing you to\n * specify a custom clock for measuring the execution duration. The provided\n * effect (`nanoseconds`) represents the clock and should return the current\n * time in nanoseconds. The timing information is computed using this custom\n * clock instead of the default system clock.\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const timedWith: {\n  /**\n   * Executes an effect and measures its execution time using a custom clock.\n   *\n   * **Details**\n   *\n   * This function extends the functionality of {@link timed} by allowing you to\n   * specify a custom clock for measuring the execution duration. The provided\n   * effect (`nanoseconds`) represents the clock and should return the current\n   * time in nanoseconds. The timing information is computed using this custom\n   * clock instead of the default system clock.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>\n  /**\n   * Executes an effect and measures its execution time using a custom clock.\n   *\n   * **Details**\n   *\n   * This function extends the functionality of {@link timed} by allowing you to\n   * specify a custom clock for measuring the execution duration. The provided\n   * effect (`nanoseconds`) represents the clock and should return the current\n   * time in nanoseconds. The timing information is computed using this custom\n   * clock instead of the default system clock.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration.Duration, A], E | E1, R | R1>\n} = effect.timedWith\n\n/**\n * Adds a time limit to an effect, triggering a timeout if the effect exceeds\n * the duration.\n *\n * **Details**\n *\n * This function allows you to enforce a time limit on the execution of an\n * effect. If the effect does not complete within the given duration, it fails\n * with a `TimeoutException`. This is useful for preventing tasks from hanging\n * indefinitely, especially in scenarios where responsiveness or resource limits\n * are critical.\n *\n * The returned effect will either:\n * - Succeed with the original effect's result if it completes within the\n *   specified duration.\n * - Fail with a `TimeoutException` if the time limit is exceeded.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task = Effect.gen(function* () {\n *   console.log(\"Start processing...\")\n *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n *   console.log(\"Processing complete.\")\n *   return \"Result\"\n * })\n *\n * // Output will show a TimeoutException as the task takes longer\n * // than the specified timeout duration\n * const timedEffect = task.pipe(Effect.timeout(\"1 second\"))\n *\n * Effect.runPromiseExit(timedEffect).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: { _tag: 'TimeoutException' }\n * //   }\n * // }\n * ```\n *\n * @see {@link timeoutFail} for a version that raises a custom error.\n * @see {@link timeoutFailCause} for a version that raises a custom defect.\n * @see {@link timeoutTo} for a version that allows specifying both success and\n * timeout handlers.\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const timeout: {\n  /**\n   * Adds a time limit to an effect, triggering a timeout if the effect exceeds\n   * the duration.\n   *\n   * **Details**\n   *\n   * This function allows you to enforce a time limit on the execution of an\n   * effect. If the effect does not complete within the given duration, it fails\n   * with a `TimeoutException`. This is useful for preventing tasks from hanging\n   * indefinitely, especially in scenarios where responsiveness or resource limits\n   * are critical.\n   *\n   * The returned effect will either:\n   * - Succeed with the original effect's result if it completes within the\n   *   specified duration.\n   * - Fail with a `TimeoutException` if the time limit is exceeded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * // Output will show a TimeoutException as the task takes longer\n   * // than the specified timeout duration\n   * const timedEffect = task.pipe(Effect.timeout(\"1 second\"))\n   *\n   * Effect.runPromiseExit(timedEffect).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: { _tag: 'TimeoutException' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>\n  /**\n   * Adds a time limit to an effect, triggering a timeout if the effect exceeds\n   * the duration.\n   *\n   * **Details**\n   *\n   * This function allows you to enforce a time limit on the execution of an\n   * effect. If the effect does not complete within the given duration, it fails\n   * with a `TimeoutException`. This is useful for preventing tasks from hanging\n   * indefinitely, especially in scenarios where responsiveness or resource limits\n   * are critical.\n   *\n   * The returned effect will either:\n   * - Succeed with the original effect's result if it completes within the\n   *   specified duration.\n   * - Fail with a `TimeoutException` if the time limit is exceeded.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * // Output will show a TimeoutException as the task takes longer\n   * // than the specified timeout duration\n   * const timedEffect = task.pipe(Effect.timeout(\"1 second\"))\n   *\n   * Effect.runPromiseExit(timedEffect).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: { _tag: 'TimeoutException' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>\n} = circular.timeout\n\n/**\n * Gracefully handles timeouts by returning an `Option` that represents either\n * the result or a timeout.\n *\n * **Details**\n *\n * This function wraps the outcome of an effect in an `Option` type. If the\n * effect completes within the specified duration, it returns a `Some`\n * containing the result. If the effect times out, it returns a `None`. Unlike\n * other timeout methods, this approach does not raise errors or exceptions;\n * instead, it allows you to treat timeouts as a regular outcome, simplifying\n * the logic for handling delays.\n *\n * **When to Use**\n *\n * This is useful when you want to handle timeouts without causing the program\n * to fail, making it easier to manage situations where you expect tasks might\n * take too long but want to continue executing other tasks.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task = Effect.gen(function* () {\n *   console.log(\"Start processing...\")\n *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n *   console.log(\"Processing complete.\")\n *   return \"Result\"\n * })\n *\n * const timedOutEffect = Effect.all([\n *   task.pipe(Effect.timeoutOption(\"3 seconds\")),\n *   task.pipe(Effect.timeoutOption(\"1 second\"))\n * ])\n *\n * Effect.runPromise(timedOutEffect).then(console.log)\n * // Output:\n * // Start processing...\n * // Processing complete.\n * // Start processing...\n * // [\n * //   { _id: 'Option', _tag: 'Some', value: 'Result' },\n * //   { _id: 'Option', _tag: 'None' }\n * // ]\n * ```\n *\n * @see {@link timeout} for a version that raises a `TimeoutException`.\n * @see {@link timeoutFail} for a version that raises a custom error.\n * @see {@link timeoutFailCause} for a version that raises a custom defect.\n * @see {@link timeoutTo} for a version that allows specifying both success and\n * timeout handlers.\n *\n * @since 3.1.0\n * @category Delays & Timeouts\n */\nexport const timeoutOption: {\n  /**\n   * Gracefully handles timeouts by returning an `Option` that represents either\n   * the result or a timeout.\n   *\n   * **Details**\n   *\n   * This function wraps the outcome of an effect in an `Option` type. If the\n   * effect completes within the specified duration, it returns a `Some`\n   * containing the result. If the effect times out, it returns a `None`. Unlike\n   * other timeout methods, this approach does not raise errors or exceptions;\n   * instead, it allows you to treat timeouts as a regular outcome, simplifying\n   * the logic for handling delays.\n   *\n   * **When to Use**\n   *\n   * This is useful when you want to handle timeouts without causing the program\n   * to fail, making it easier to manage situations where you expect tasks might\n   * take too long but want to continue executing other tasks.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * const timedOutEffect = Effect.all([\n   *   task.pipe(Effect.timeoutOption(\"3 seconds\")),\n   *   task.pipe(Effect.timeoutOption(\"1 second\"))\n   * ])\n   *\n   * Effect.runPromise(timedOutEffect).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // Processing complete.\n   * // Start processing...\n   * // [\n   * //   { _id: 'Option', _tag: 'Some', value: 'Result' },\n   * //   { _id: 'Option', _tag: 'None' }\n   * // ]\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 3.1.0\n   * @category Delays & Timeouts\n   */\n  (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n  /**\n   * Gracefully handles timeouts by returning an `Option` that represents either\n   * the result or a timeout.\n   *\n   * **Details**\n   *\n   * This function wraps the outcome of an effect in an `Option` type. If the\n   * effect completes within the specified duration, it returns a `Some`\n   * containing the result. If the effect times out, it returns a `None`. Unlike\n   * other timeout methods, this approach does not raise errors or exceptions;\n   * instead, it allows you to treat timeouts as a regular outcome, simplifying\n   * the logic for handling delays.\n   *\n   * **When to Use**\n   *\n   * This is useful when you want to handle timeouts without causing the program\n   * to fail, making it easier to manage situations where you expect tasks might\n   * take too long but want to continue executing other tasks.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * const timedOutEffect = Effect.all([\n   *   task.pipe(Effect.timeoutOption(\"3 seconds\")),\n   *   task.pipe(Effect.timeoutOption(\"1 second\"))\n   * ])\n   *\n   * Effect.runPromise(timedOutEffect).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // Processing complete.\n   * // Start processing...\n   * // [\n   * //   { _id: 'Option', _tag: 'Some', value: 'Result' },\n   * //   { _id: 'Option', _tag: 'None' }\n   * // ]\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 3.1.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>\n} = circular.timeoutOption\n\n/**\n * Specifies a custom error to be produced when a timeout occurs.\n *\n * **Details**\n *\n * This function allows you to handle timeouts in a customized way by defining a\n * specific error to be raised when an effect exceeds the given duration. Unlike\n * default timeout behaviors that use generic exceptions, this function gives\n * you the flexibility to specify a meaningful error type that aligns with your\n * application's needs.\n *\n * When you apply this function, you provide:\n * - A `duration`: The time limit for the effect.\n * - An `onTimeout` function: A lazy evaluation function that generates the\n *   custom error if the timeout occurs.\n *\n * If the effect completes within the time limit, its result is returned\n * normally. Otherwise, the `onTimeout` function is triggered, and its output is\n * used as the error for the effect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task = Effect.gen(function* () {\n *   console.log(\"Start processing...\")\n *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n *   console.log(\"Processing complete.\")\n *   return \"Result\"\n * })\n *\n * class MyTimeoutError {\n *   readonly _tag = \"MyTimeoutError\"\n * }\n *\n * const program = task.pipe(\n *   Effect.timeoutFail({\n *     duration: \"1 second\",\n *     onTimeout: () => new MyTimeoutError() // Custom timeout error\n *   })\n * )\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: MyTimeoutError { _tag: 'MyTimeoutError' }\n * //   }\n * // }\n * ```\n *\n * @see {@link timeout} for a version that raises a `TimeoutException`.\n * @see {@link timeoutFailCause} for a version that raises a custom defect.\n * @see {@link timeoutTo} for a version that allows specifying both success and\n * timeout handlers.\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const timeoutFail: {\n  /**\n   * Specifies a custom error to be produced when a timeout occurs.\n   *\n   * **Details**\n   *\n   * This function allows you to handle timeouts in a customized way by defining a\n   * specific error to be raised when an effect exceeds the given duration. Unlike\n   * default timeout behaviors that use generic exceptions, this function gives\n   * you the flexibility to specify a meaningful error type that aligns with your\n   * application's needs.\n   *\n   * When you apply this function, you provide:\n   * - A `duration`: The time limit for the effect.\n   * - An `onTimeout` function: A lazy evaluation function that generates the\n   *   custom error if the timeout occurs.\n   *\n   * If the effect completes within the time limit, its result is returned\n   * normally. Otherwise, the `onTimeout` function is triggered, and its output is\n   * used as the error for the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * class MyTimeoutError {\n   *   readonly _tag = \"MyTimeoutError\"\n   * }\n   *\n   * const program = task.pipe(\n   *   Effect.timeoutFail({\n   *     duration: \"1 second\",\n   *     onTimeout: () => new MyTimeoutError() // Custom timeout error\n   *   })\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: MyTimeoutError { _tag: 'MyTimeoutError' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <E1>(\n    options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput }\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>\n  /**\n   * Specifies a custom error to be produced when a timeout occurs.\n   *\n   * **Details**\n   *\n   * This function allows you to handle timeouts in a customized way by defining a\n   * specific error to be raised when an effect exceeds the given duration. Unlike\n   * default timeout behaviors that use generic exceptions, this function gives\n   * you the flexibility to specify a meaningful error type that aligns with your\n   * application's needs.\n   *\n   * When you apply this function, you provide:\n   * - A `duration`: The time limit for the effect.\n   * - An `onTimeout` function: A lazy evaluation function that generates the\n   *   custom error if the timeout occurs.\n   *\n   * If the effect completes within the time limit, its result is returned\n   * normally. Otherwise, the `onTimeout` function is triggered, and its output is\n   * used as the error for the effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * class MyTimeoutError {\n   *   readonly _tag = \"MyTimeoutError\"\n   * }\n   *\n   * const program = task.pipe(\n   *   Effect.timeoutFail({\n   *     duration: \"1 second\",\n   *     onTimeout: () => new MyTimeoutError() // Custom timeout error\n   *   })\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Fail',\n   * //     failure: MyTimeoutError { _tag: 'MyTimeoutError' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R, E1>(\n    self: Effect<A, E, R>,\n    options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput }\n  ): Effect<A, E | E1, R>\n} = circular.timeoutFail\n\n/**\n * Specifies a custom defect to be thrown when a timeout occurs.\n *\n * **Details**\n *\n * This function allows you to handle timeouts as exceptional cases by\n * generating a custom defect when an effect exceeds the specified duration. You\n * provide:\n * - A `duration`: The time limit for the effect.\n * - An `onTimeout` function: A lazy evaluation function that generates the\n *   custom defect (typically created using `Cause.die`).\n *\n * If the effect completes within the time limit, its result is returned\n * normally. Otherwise, the custom defect is triggered, and the effect fails\n * with that defect.\n *\n * **When to Use**\n *\n * This is especially useful when you need to treat timeouts as critical\n * failures in your application and wish to include meaningful information in\n * the defect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Cause } from \"effect\"\n *\n * const task = Effect.gen(function* () {\n *   console.log(\"Start processing...\")\n *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n *   console.log(\"Processing complete.\")\n *   return \"Result\"\n * })\n *\n * const program = task.pipe(\n *   Effect.timeoutFailCause({\n *     duration: \"1 second\",\n *     onTimeout: () => Cause.die(\"Timed out!\") // Custom defect for timeout\n *   })\n * )\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }\n * // }\n * ```\n *\n * @see {@link timeout} for a version that raises a `TimeoutException`.\n * @see {@link timeoutFail} for a version that raises a custom error.\n * @see {@link timeoutTo} for a version that allows specifying both success and\n * timeout handlers.\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const timeoutFailCause: {\n  /**\n   * Specifies a custom defect to be thrown when a timeout occurs.\n   *\n   * **Details**\n   *\n   * This function allows you to handle timeouts as exceptional cases by\n   * generating a custom defect when an effect exceeds the specified duration. You\n   * provide:\n   * - A `duration`: The time limit for the effect.\n   * - An `onTimeout` function: A lazy evaluation function that generates the\n   *   custom defect (typically created using `Cause.die`).\n   *\n   * If the effect completes within the time limit, its result is returned\n   * normally. Otherwise, the custom defect is triggered, and the effect fails\n   * with that defect.\n   *\n   * **When to Use**\n   *\n   * This is especially useful when you need to treat timeouts as critical\n   * failures in your application and wish to include meaningful information in\n   * the defect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Cause } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * const program = task.pipe(\n   *   Effect.timeoutFailCause({\n   *     duration: \"1 second\",\n   *     onTimeout: () => Cause.die(\"Timed out!\") // Custom defect for timeout\n   *   })\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }\n   * // }\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <E1>(\n    options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput }\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>\n  /**\n   * Specifies a custom defect to be thrown when a timeout occurs.\n   *\n   * **Details**\n   *\n   * This function allows you to handle timeouts as exceptional cases by\n   * generating a custom defect when an effect exceeds the specified duration. You\n   * provide:\n   * - A `duration`: The time limit for the effect.\n   * - An `onTimeout` function: A lazy evaluation function that generates the\n   *   custom defect (typically created using `Cause.die`).\n   *\n   * If the effect completes within the time limit, its result is returned\n   * normally. Otherwise, the custom defect is triggered, and the effect fails\n   * with that defect.\n   *\n   * **When to Use**\n   *\n   * This is especially useful when you need to treat timeouts as critical\n   * failures in your application and wish to include meaningful information in\n   * the defect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Cause } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * const program = task.pipe(\n   *   Effect.timeoutFailCause({\n   *     duration: \"1 second\",\n   *     onTimeout: () => Cause.die(\"Timed out!\") // Custom defect for timeout\n   *   })\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }\n   * // }\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutTo} for a version that allows specifying both success and\n   * timeout handlers.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R, E1>(\n    self: Effect<A, E, R>,\n    options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput }\n  ): Effect<A, E | E1, R>\n} = circular.timeoutFailCause\n\n/**\n * Provides custom behavior for successful and timed-out operations.\n *\n * **Details**\n *\n * This function allows you to define distinct outcomes for an effect depending\n * on whether it completes within a specified time frame or exceeds the timeout\n * duration. You can provide:\n * - `onSuccess`: A handler for processing the result of the effect if it\n *   completes successfully within the time limit.\n * - `onTimeout`: A handler for generating a result when the effect times out.\n * - `duration`: The maximum allowed time for the effect to complete.\n *\n * **When to Use**\n *\n * Unlike {@link timeout}, which raises an exception for timeouts, this function\n * gives you full control over the behavior for both success and timeout\n * scenarios. It is particularly useful when you want to encapsulate timeouts\n * and successes into a specific data structure, like an `Either` type, to\n * represent these outcomes in a meaningful way.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Either } from \"effect\"\n *\n * const task = Effect.gen(function* () {\n *   console.log(\"Start processing...\")\n *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n *   console.log(\"Processing complete.\")\n *   return \"Result\"\n * })\n *\n * const program = task.pipe(\n *   Effect.timeoutTo({\n *     duration: \"1 second\",\n *     onSuccess: (result): Either.Either<string, string> =>\n *       Either.right(result),\n *     onTimeout: (): Either.Either<string, string> =>\n *       Either.left(\"Timed out!\")\n *   })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: \"Either\",\n * //   _tag: \"Left\",\n * //   left: \"Timed out!\"\n * // }\n * ```\n *\n * @see {@link timeout} for a version that raises a `TimeoutException`.\n * @see {@link timeoutFail} for a version that raises a custom error.\n * @see {@link timeoutFailCause} for a version that raises a custom defect.\n *\n * @since 2.0.0\n * @category Delays & Timeouts\n */\nexport const timeoutTo: {\n  /**\n   * Provides custom behavior for successful and timed-out operations.\n   *\n   * **Details**\n   *\n   * This function allows you to define distinct outcomes for an effect depending\n   * on whether it completes within a specified time frame or exceeds the timeout\n   * duration. You can provide:\n   * - `onSuccess`: A handler for processing the result of the effect if it\n   *   completes successfully within the time limit.\n   * - `onTimeout`: A handler for generating a result when the effect times out.\n   * - `duration`: The maximum allowed time for the effect to complete.\n   *\n   * **When to Use**\n   *\n   * Unlike {@link timeout}, which raises an exception for timeouts, this function\n   * gives you full control over the behavior for both success and timeout\n   * scenarios. It is particularly useful when you want to encapsulate timeouts\n   * and successes into a specific data structure, like an `Either` type, to\n   * represent these outcomes in a meaningful way.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Either } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * const program = task.pipe(\n   *   Effect.timeoutTo({\n   *     duration: \"1 second\",\n   *     onSuccess: (result): Either.Either<string, string> =>\n   *       Either.right(result),\n   *     onTimeout: (): Either.Either<string, string> =>\n   *       Either.left(\"Timed out!\")\n   *   })\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: \"Either\",\n   * //   _tag: \"Left\",\n   * //   left: \"Timed out!\"\n   * // }\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, B, B1>(\n    options: {\n      readonly onTimeout: LazyArg<B1>\n      readonly onSuccess: (a: A) => B\n      readonly duration: Duration.DurationInput\n    }\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>\n  /**\n   * Provides custom behavior for successful and timed-out operations.\n   *\n   * **Details**\n   *\n   * This function allows you to define distinct outcomes for an effect depending\n   * on whether it completes within a specified time frame or exceeds the timeout\n   * duration. You can provide:\n   * - `onSuccess`: A handler for processing the result of the effect if it\n   *   completes successfully within the time limit.\n   * - `onTimeout`: A handler for generating a result when the effect times out.\n   * - `duration`: The maximum allowed time for the effect to complete.\n   *\n   * **When to Use**\n   *\n   * Unlike {@link timeout}, which raises an exception for timeouts, this function\n   * gives you full control over the behavior for both success and timeout\n   * scenarios. It is particularly useful when you want to encapsulate timeouts\n   * and successes into a specific data structure, like an `Either` type, to\n   * represent these outcomes in a meaningful way.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Either } from \"effect\"\n   *\n   * const task = Effect.gen(function* () {\n   *   console.log(\"Start processing...\")\n   *   yield* Effect.sleep(\"2 seconds\") // Simulates a delay in processing\n   *   console.log(\"Processing complete.\")\n   *   return \"Result\"\n   * })\n   *\n   * const program = task.pipe(\n   *   Effect.timeoutTo({\n   *     duration: \"1 second\",\n   *     onSuccess: (result): Either.Either<string, string> =>\n   *       Either.right(result),\n   *     onTimeout: (): Either.Either<string, string> =>\n   *       Either.left(\"Timed out!\")\n   *   })\n   * )\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // Start processing...\n   * // {\n   * //   _id: \"Either\",\n   * //   _tag: \"Left\",\n   * //   left: \"Timed out!\"\n   * // }\n   * ```\n   *\n   * @see {@link timeout} for a version that raises a `TimeoutException`.\n   * @see {@link timeoutFail} for a version that raises a custom error.\n   * @see {@link timeoutFailCause} for a version that raises a custom defect.\n   *\n   * @since 2.0.0\n   * @category Delays & Timeouts\n   */\n  <A, E, R, B1, B>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly onTimeout: LazyArg<B1>\n      readonly onSuccess: (a: A) => B\n      readonly duration: Duration.DurationInput\n    }\n  ): Effect<B1 | B, E, R>\n} = circular.timeoutTo\n\n/**\n * Allows working with the default configuration provider.\n *\n * **Details**\n *\n * This function retrieves the default configuration provider and passes it to\n * the provided function, which can use it to perform computations or retrieve\n * configuration values. The function can return an effect that leverages the\n * configuration provider for its operations.\n *\n * @since 2.0.0\n * @category Config\n */\nexport const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R> =\n  defaultServices.configProviderWith\n\n/**\n * Executes an effect using a specific configuration provider.\n *\n * **Details**\n *\n * This function lets you run an effect with a specified configuration provider.\n * The custom provider will override the default configuration provider for the\n * duration of the effect's execution.\n *\n * **When to Use**\n *\n * This is particularly useful when you need to use a different set of\n * configuration values or sources for specific parts of your application.\n *\n * **Example**\n *\n * ```ts\n * import { Config, ConfigProvider, Effect } from \"effect\"\n *\n * const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n *   new Map([[\"custom-key\", \"custom-value\"]])\n * )\n *\n * const program = Effect.withConfigProvider(customProvider)(\n *   Effect.gen(function*() {\n *     const value = yield* Config.string(\"custom-key\")\n *     console.log(`Config value: ${value}`)\n *   })\n * )\n *\n * Effect.runPromise(program)\n * // Output:\n * // Config value: custom-value\n * ```\n *\n * @since 2.0.0\n * @category Config\n */\nexport const withConfigProvider: {\n  /**\n   * Executes an effect using a specific configuration provider.\n   *\n   * **Details**\n   *\n   * This function lets you run an effect with a specified configuration provider.\n   * The custom provider will override the default configuration provider for the\n   * duration of the effect's execution.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful when you need to use a different set of\n   * configuration values or sources for specific parts of your application.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Config, ConfigProvider, Effect } from \"effect\"\n   *\n   * const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n   *   new Map([[\"custom-key\", \"custom-value\"]])\n   * )\n   *\n   * const program = Effect.withConfigProvider(customProvider)(\n   *   Effect.gen(function*() {\n   *     const value = yield* Config.string(\"custom-key\")\n   *     console.log(`Config value: ${value}`)\n   *   })\n   * )\n   *\n   * Effect.runPromise(program)\n   * // Output:\n   * // Config value: custom-value\n   * ```\n   *\n   * @since 2.0.0\n   * @category Config\n   */\n  (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Executes an effect using a specific configuration provider.\n   *\n   * **Details**\n   *\n   * This function lets you run an effect with a specified configuration provider.\n   * The custom provider will override the default configuration provider for the\n   * duration of the effect's execution.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful when you need to use a different set of\n   * configuration values or sources for specific parts of your application.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Config, ConfigProvider, Effect } from \"effect\"\n   *\n   * const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n   *   new Map([[\"custom-key\", \"custom-value\"]])\n   * )\n   *\n   * const program = Effect.withConfigProvider(customProvider)(\n   *   Effect.gen(function*() {\n   *     const value = yield* Config.string(\"custom-key\")\n   *     console.log(`Config value: ${value}`)\n   *   })\n   * )\n   *\n   * Effect.runPromise(program)\n   * // Output:\n   * // Config value: custom-value\n   * ```\n   *\n   * @since 2.0.0\n   * @category Config\n   */\n  <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>\n} = defaultServices.withConfigProvider\n\n/**\n * Sets a configuration provider within a scope.\n *\n * **Details**\n *\n * This function sets the configuration provider to a specified value and\n * ensures that it is restored to its original value when the scope is closed.\n *\n * @since 2.0.0\n * @category Config\n */\nexport const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope> =\n  fiberRuntime.withConfigProviderScoped\n\n/**\n * Accesses the full context of the effect.\n *\n * **Details**\n *\n * This function provides the ability to access the entire context required by\n * an effect. The context is a container that holds dependencies or environment\n * values needed by an effect to run. By using this function, you can retrieve\n * and work with the context directly within an effect.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const context: <R>() => Effect<Context.Context<R>, never, R> = core.context\n\n/**\n * Accesses the context and applies a transformation function.\n *\n * **Details**\n *\n * This function retrieves the context of the effect and applies a pure\n * transformation function to it. The result of the transformation is then\n * returned within the effect.\n *\n * @see {@link contextWithEffect} for a version that allows effectful transformations.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R> = effect.contextWith\n\n/**\n * Accesses the context and performs an effectful transformation.\n *\n * **Details**\n *\n * This function retrieves the context and allows you to transform it\n * effectually using another effect. It is useful when the transformation\n * involves asynchronous or effectful operations.\n *\n * @see {@link contextWith} for a version that allows pure transformations.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const contextWithEffect: <R2, A, E, R>(\n  f: (context: Context.Context<R2>) => Effect<A, E, R>\n) => Effect<A, E, R | R2> = core.contextWithEffect\n\n/**\n * Provides part of the required context while leaving the rest unchanged.\n *\n * **Details**\n *\n * This function allows you to transform the context required by an effect,\n * providing part of the context and leaving the rest to be fulfilled later.\n *\n * **Example**\n *\n * ```ts\n * import { Context, Effect } from \"effect\"\n *\n * class Service1 extends Context.Tag(\"Service1\")<Service1, { readonly port: number }>() {}\n * class Service2 extends Context.Tag(\"Service2\")<Service2, { readonly connection: string }>() {}\n *\n * const program = Effect.gen(function*() {\n *   const service1 = yield* Service1\n *   console.log(service1.port)\n *   const service2 = yield* Service2\n *   console.log(service2.connection)\n *   return \"some result\"\n * })\n *\n * //       Effect<string, never, Service2>\n * //      \n * const programWithService1 = Effect.mapInputContext(\n *   program,\n *   (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n * )\n *\n * const runnable = programWithService1.pipe(\n *   Effect.provideService(Service2, { connection: \"localhost\" }),\n *   Effect.provideService(Service1, { port: 3001 })\n * )\n *\n * Effect.runPromise(runnable)\n * // Output:\n * // 3000\n * // localhost\n * ```\n *\n * @since 2.0.0\n * @category Context\n */\nexport const mapInputContext: {\n  /**\n   * Provides part of the required context while leaving the rest unchanged.\n   *\n   * **Details**\n   *\n   * This function allows you to transform the context required by an effect,\n   * providing part of the context and leaving the rest to be fulfilled later.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect } from \"effect\"\n   *\n   * class Service1 extends Context.Tag(\"Service1\")<Service1, { readonly port: number }>() {}\n   * class Service2 extends Context.Tag(\"Service2\")<Service2, { readonly connection: string }>() {}\n   *\n   * const program = Effect.gen(function*() {\n   *   const service1 = yield* Service1\n   *   console.log(service1.port)\n   *   const service2 = yield* Service2\n   *   console.log(service2.connection)\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, never, Service2>\n   * //      \n   * const programWithService1 = Effect.mapInputContext(\n   *   program,\n   *   (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n   * )\n   *\n   * const runnable = programWithService1.pipe(\n   *   Effect.provideService(Service2, { connection: \"localhost\" }),\n   *   Effect.provideService(Service1, { port: 3001 })\n   * )\n   *\n   * Effect.runPromise(runnable)\n   * // Output:\n   * // 3000\n   * // localhost\n   * ```\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>\n  /**\n   * Provides part of the required context while leaving the rest unchanged.\n   *\n   * **Details**\n   *\n   * This function allows you to transform the context required by an effect,\n   * providing part of the context and leaving the rest to be fulfilled later.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect } from \"effect\"\n   *\n   * class Service1 extends Context.Tag(\"Service1\")<Service1, { readonly port: number }>() {}\n   * class Service2 extends Context.Tag(\"Service2\")<Service2, { readonly connection: string }>() {}\n   *\n   * const program = Effect.gen(function*() {\n   *   const service1 = yield* Service1\n   *   console.log(service1.port)\n   *   const service2 = yield* Service2\n   *   console.log(service2.connection)\n   *   return \"some result\"\n   * })\n   *\n   * //       Effect<string, never, Service2>\n   * //      \n   * const programWithService1 = Effect.mapInputContext(\n   *   program,\n   *   (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n   * )\n   *\n   * const runnable = programWithService1.pipe(\n   *   Effect.provideService(Service2, { connection: \"localhost\" }),\n   *   Effect.provideService(Service1, { port: 3001 })\n   * )\n   *\n   * Effect.runPromise(runnable)\n   * // Output:\n   * // 3000\n   * // localhost\n   * ```\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, R2>(\n    self: Effect<A, E, R>,\n    f: (context: Context.Context<R2>) => Context.Context<R>\n  ): Effect<A, E, R2>\n} = core.mapInputContext\n\n/**\n * Provides necessary dependencies to an effect, removing its environmental\n * requirements.\n *\n * **Details**\n *\n * This function allows you to supply the required environment for an effect.\n * The environment can be provided in the form of one or more `Layer`s, a\n * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n * provided, the effect can run without requiring external dependencies.\n *\n * You can compose layers to create a modular and reusable way of setting up the\n * environment for effects. For example, layers can be used to configure\n * databases, logging services, or any other required dependencies.\n *\n * **Example**\n *\n * ```ts\n * import { Context, Effect, Layer } from \"effect\"\n *\n * class Database extends Context.Tag(\"Database\")<\n *   Database,\n *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n * >() {}\n *\n * const DatabaseLive = Layer.succeed(\n *   Database,\n *   {\n *     // Simulate a database query\n *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n *   }\n * )\n *\n * //       Effect<unknown[], never, Database>\n * //      \n * const program = Effect.gen(function*() {\n *   const database = yield* Database\n *   const result = yield* database.query(\"SELECT * FROM users\")\n *   return result\n * })\n *\n * //       Effect<unknown[], never, never>\n * //      \n * const runnable = Effect.provide(program, DatabaseLive)\n *\n * Effect.runPromise(runnable).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n * // []\n * ```\n *\n * @see {@link provideService} for providing a service to an effect.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provide: {\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(\n    self: Effect<A, E, R>\n  ) => Effect<\n    A,\n    E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n    | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n    | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>\n  >\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <E2, R2>(managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<\n    A,\n    E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]> }[number],\n    | { [k in keyof Layers]: Layer.Layer.Context<Layers[k]> }[number]\n    | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]> }[number]>\n  >\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>\n  /**\n   * Provides necessary dependencies to an effect, removing its environmental\n   * requirements.\n   *\n   * **Details**\n   *\n   * This function allows you to supply the required environment for an effect.\n   * The environment can be provided in the form of one or more `Layer`s, a\n   * `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\n   * provided, the effect can run without requiring external dependencies.\n   *\n   * You can compose layers to create a modular and reusable way of setting up the\n   * environment for effects. For example, layers can be used to configure\n   * databases, logging services, or any other required dependencies.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Context, Effect, Layer } from \"effect\"\n   *\n   * class Database extends Context.Tag(\"Database\")<\n   *   Database,\n   *   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n   * >() {}\n   *\n   * const DatabaseLive = Layer.succeed(\n   *   Database,\n   *   {\n   *     // Simulate a database query\n   *     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n   *   }\n   * )\n   *\n   * //       Effect<unknown[], never, Database>\n   * //      \n   * const program = Effect.gen(function*() {\n   *   const database = yield* Database\n   *   const result = yield* database.query(\"SELECT * FROM users\")\n   *   return result\n   * })\n   *\n   * //       Effect<unknown[], never, never>\n   * //      \n   * const runnable = Effect.provide(program, DatabaseLive)\n   *\n   * Effect.runPromise(runnable).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"Executing query: SELECT * FROM users\"\n   * // []\n   * ```\n   *\n   * @see {@link provideService} for providing a service to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime.ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>\n} = layer.effect_provide\n\n/**\n * Provides an implementation for a service in the context of an effect.\n *\n * **Details**\n *\n * This function allows you to supply a specific implementation for a service\n * required by an effect. Services are typically defined using `Context.Tag`,\n * which acts as a unique identifier for the service. By using this function,\n * you link the service to its concrete implementation, enabling the effect to\n * execute successfully without additional requirements.\n *\n * For example, you can use this function to provide a random number generator,\n * a logger, or any other service your effect depends on. Once the service is\n * provided, all parts of the effect that rely on the service will automatically\n * use the implementation you supplied.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Context } from \"effect\"\n *\n * // Declaring a tag for a service that generates random numbers\n * class Random extends Context.Tag(\"MyRandomService\")<\n *   Random,\n *   { readonly next: Effect.Effect<number> }\n * >() {}\n *\n * // Using the service\n * const program = Effect.gen(function* () {\n *   const random = yield* Random\n *   const randomNumber = yield* random.next\n *   console.log(`random number: ${randomNumber}`)\n * })\n *\n * // Providing the implementation\n * //\n * //       Effect<void, never, never>\n * //      \n * const runnable = Effect.provideService(program, Random, {\n *   next: Effect.sync(() => Math.random())\n * })\n *\n * // Run successfully\n * Effect.runPromise(runnable)\n * // Example Output:\n * // random number: 0.8241872233134417\n * ```\n *\n * @see {@link provide} for providing multiple layers to an effect.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provideService: {\n  /**\n   * Provides an implementation for a service in the context of an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to supply a specific implementation for a service\n   * required by an effect. Services are typically defined using `Context.Tag`,\n   * which acts as a unique identifier for the service. By using this function,\n   * you link the service to its concrete implementation, enabling the effect to\n   * execute successfully without additional requirements.\n   *\n   * For example, you can use this function to provide a random number generator,\n   * a logger, or any other service your effect depends on. Once the service is\n   * provided, all parts of the effect that rely on the service will automatically\n   * use the implementation you supplied.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Context } from \"effect\"\n   *\n   * // Declaring a tag for a service that generates random numbers\n   * class Random extends Context.Tag(\"MyRandomService\")<\n   *   Random,\n   *   { readonly next: Effect.Effect<number> }\n   * >() {}\n   *\n   * // Using the service\n   * const program = Effect.gen(function* () {\n   *   const random = yield* Random\n   *   const randomNumber = yield* random.next\n   *   console.log(`random number: ${randomNumber}`)\n   * })\n   *\n   * // Providing the implementation\n   * //\n   * //       Effect<void, never, never>\n   * //      \n   * const runnable = Effect.provideService(program, Random, {\n   *   next: Effect.sync(() => Math.random())\n   * })\n   *\n   * // Run successfully\n   * Effect.runPromise(runnable)\n   * // Example Output:\n   * // random number: 0.8241872233134417\n   * ```\n   *\n   * @see {@link provide} for providing multiple layers to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>\n  /**\n   * Provides an implementation for a service in the context of an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to supply a specific implementation for a service\n   * required by an effect. Services are typically defined using `Context.Tag`,\n   * which acts as a unique identifier for the service. By using this function,\n   * you link the service to its concrete implementation, enabling the effect to\n   * execute successfully without additional requirements.\n   *\n   * For example, you can use this function to provide a random number generator,\n   * a logger, or any other service your effect depends on. Once the service is\n   * provided, all parts of the effect that rely on the service will automatically\n   * use the implementation you supplied.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Context } from \"effect\"\n   *\n   * // Declaring a tag for a service that generates random numbers\n   * class Random extends Context.Tag(\"MyRandomService\")<\n   *   Random,\n   *   { readonly next: Effect.Effect<number> }\n   * >() {}\n   *\n   * // Using the service\n   * const program = Effect.gen(function* () {\n   *   const random = yield* Random\n   *   const randomNumber = yield* random.next\n   *   console.log(`random number: ${randomNumber}`)\n   * })\n   *\n   * // Providing the implementation\n   * //\n   * //       Effect<void, never, never>\n   * //      \n   * const runnable = Effect.provideService(program, Random, {\n   *   next: Effect.sync(() => Math.random())\n   * })\n   *\n   * // Run successfully\n   * Effect.runPromise(runnable)\n   * // Example Output:\n   * // random number: 0.8241872233134417\n   * ```\n   *\n   * @see {@link provide} for providing multiple layers to an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>\n} = effect.provideService\n\n/**\n * Dynamically provides an implementation for a service using an effect.\n *\n * **Details**\n *\n * This function allows you to provide an implementation for a service\n * dynamically by using another effect. The provided effect is executed to\n * produce the service implementation, which is then made available to the\n * consuming effect. This is particularly useful when the service implementation\n * itself requires asynchronous or resource-intensive initialization.\n *\n * For example, you can use this function to lazily initialize a database\n * connection or fetch configuration values from an external source before\n * making the service available to your effect.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const provideServiceEffect: {\n  /**\n   * Dynamically provides an implementation for a service using an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to provide an implementation for a service\n   * dynamically by using another effect. The provided effect is executed to\n   * produce the service implementation, which is then made available to the\n   * consuming effect. This is particularly useful when the service implementation\n   * itself requires asynchronous or resource-intensive initialization.\n   *\n   * For example, you can use this function to lazily initialize a database\n   * connection or fetch configuration values from an external source before\n   * making the service available to your effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <I, S, E1, R1>(tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>\n  /**\n   * Dynamically provides an implementation for a service using an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to provide an implementation for a service\n   * dynamically by using another effect. The provided effect is executed to\n   * produce the service implementation, which is then made available to the\n   * consuming effect. This is particularly useful when the service implementation\n   * itself requires asynchronous or resource-intensive initialization.\n   *\n   * For example, you can use this function to lazily initialize a database\n   * connection or fetch configuration values from an external source before\n   * making the service available to your effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, I, S, E1, R1>(\n    self: Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    effect: Effect<NoInfer<S>, E1, R1>\n  ): Effect<A, E | E1, R1 | Exclude<R, I>>\n} = effect.provideServiceEffect\n\n/**\n * Creates a function that uses a service from the context to produce a value.\n *\n * @see {@link serviceFunctionEffect} for a version that returns an effect.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(\n  getService: T,\n  f: (_: Effect.Success<T>) => (...args: Args) => A\n) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>> = effect.serviceFunction\n\n/**\n * Creates a function that uses a service from the context to produce an effect.\n *\n * @see {@link serviceFunction} for a version that returns a value.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(\n  getService: T,\n  f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>\n) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>> = effect.serviceFunctionEffect\n\n/**\n * @since 2.0.0\n * @category Context\n */\nexport const serviceFunctions: <S, SE, SR>(\n  getService: Effect<S, SE, SR>\n) => {\n  [k in keyof S as S[k] extends (...args: Array<any>) => Effect<any, any, any> ? k : never]: S[k] extends\n    (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R>\n    : never\n} = effect.serviceFunctions as any\n\n/**\n * @since 2.0.0\n * @category Context\n */\nexport const serviceConstants: <S, SE, SR>(\n  getService: Effect<S, SE, SR>\n) => {\n  [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R>\n    : Effect<S[k], SE, SR>\n} = effect.serviceConstants\n\n/**\n * @since 2.0.0\n * @category Context\n */\nexport const serviceMembers: <S, SE, SR>(\n  getService: Effect<S, SE, SR>\n) => {\n  functions: {\n    [k in keyof S as S[k] extends (...args: Array<any>) => Effect<any, any, any> ? k : never]: S[k] extends\n      (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R>\n      : never\n  }\n  constants: {\n    [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R>\n      : Effect<S[k], SE, SR>\n  }\n} = effect.serviceMembers as any\n\n/**\n * Retrieves an optional service from the context as an `Option`.\n *\n * **Details**\n *\n * This function retrieves a service from the context and wraps it in an\n * `Option`. If the service is available, it returns a `Some` containing the\n * service. If the service is not found, it returns a `None`. This approach is\n * useful when you want to handle the absence of a service gracefully without\n * causing an error.\n *\n * **When to Use**\n *\n * Use this function when:\n * - You need to access a service that may or may not be present in the context.\n * - You want to handle the absence of a service using the `Option` type instead\n *   of throwing an error.\n *\n * @see {@link serviceOptional} for a version that throws an error if the service is missing.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>> = effect.serviceOption\n\n/**\n * Retrieves a service from the context, throwing an error if it is missing.\n *\n * **Details**\n *\n * This function retrieves a required service from the context. If the service\n * is available, it returns the service. If the service is missing, it throws a\n * `NoSuchElementException`, which can be handled using Effect's error-handling\n * mechanisms. This is useful for services that are critical to the execution of\n * your effect.\n *\n * @see {@link serviceOption} for a version that returns an `Option` instead of throwing an error.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException> =\n  effect.serviceOptional\n\n/**\n * Updates a service in the context with a new implementation.\n *\n * **Details**\n *\n * This function modifies the existing implementation of a service in the\n * context. It retrieves the current service, applies the provided\n * transformation function `f`, and replaces the old service with the\n * transformed one.\n *\n * **When to Use**\n *\n * This is useful for adapting or extending a service's behavior during the\n * execution of an effect.\n *\n * @since 2.0.0\n * @category Context\n */\nexport const updateService: {\n  /**\n   * Updates a service in the context with a new implementation.\n   *\n   * **Details**\n   *\n   * This function modifies the existing implementation of a service in the\n   * context. It retrieves the current service, applies the provided\n   * transformation function `f`, and replaces the old service with the\n   * transformed one.\n   *\n   * **When to Use**\n   *\n   * This is useful for adapting or extending a service's behavior during the\n   * execution of an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>\n  /**\n   * Updates a service in the context with a new implementation.\n   *\n   * **Details**\n   *\n   * This function modifies the existing implementation of a service in the\n   * context. It retrieves the current service, applies the provided\n   * transformation function `f`, and replaces the old service with the\n   * transformed one.\n   *\n   * **When to Use**\n   *\n   * This is useful for adapting or extending a service's behavior during the\n   * execution of an effect.\n   *\n   * @since 2.0.0\n   * @category Context\n   */\n  <A, E, R, I, S>(\n    self: Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    f: (service: NoInfer<S>) => NoInfer<S>\n  ): Effect<A, E, R | I>\n} = effect.updateService\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Effect.Do,\n *   Effect.bind(\"x\", () => Effect.succeed(2)),\n *   Effect.bind(\"y\", () => Effect.succeed(3)),\n *   Effect.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n * ```\n *\n * @see {@link bind}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const Do: Effect<{}> = effect.Do\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Effect.Do,\n *   Effect.bind(\"x\", () => Effect.succeed(2)),\n *   Effect.bind(\"y\", () => Effect.succeed(3)),\n *   Effect.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n * ```\n *\n * @see {@link Do}\n * @see {@link bindTo}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bind: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bind(\"y\", () => Effect.succeed(3)),\n   *   Effect.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E2 | E1, R2 | R1>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bind(\"y\", () => Effect.succeed(3)),\n   *   Effect.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bindTo}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <A extends object, N extends string, E1, R1, B, E2, R2>(\n    self: Effect<A, E1, R1>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => Effect<B, E2, R2>\n  ): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E1 | E2, R1 | R2>\n} = effect.bind\n\n/**\n * `bindAll` combines `all` with `bind`. It is useful\n * when you want to concurrently run multiple effects and then combine their\n * results in a Do notation pipeline.\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, Either, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Effect.Do,\n *   Effect.bind(\"x\", () => Effect.succeed(2)),\n *   Effect.bindAll(({ x }) => ({\n *     a: Effect.succeed(x),\n *     b: Effect.fail(\"oops\"),\n *   }), { concurrency: 2, mode: \"either\" })\n * )\n * assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left(\"oops\") })\n * ```\n *\n * @category Do notation\n * @since 3.7.0\n */\nexport const bindAll: {\n  /**\n   * `bindAll` combines `all` with `bind`. It is useful\n   * when you want to concurrently run multiple effects and then combine their\n   * results in a Do notation pipeline.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bindAll(({ x }) => ({\n   *     a: Effect.succeed(x),\n   *     b: Effect.fail(\"oops\"),\n   *   }), { concurrency: 2, mode: \"either\" })\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left(\"oops\") })\n   * ```\n   *\n   * @category Do notation\n   * @since 3.7.0\n   */\n  <\n    A extends object,\n    X extends Record<string, Effect<any, any, any>>,\n    O extends NoExcessProperties<{\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }, O>\n  >(\n    f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`,\n    options?: undefined | O\n  ): <E1, R1>(\n    self: Effect<A, E1, R1>\n  ) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>]\n    ? Effect<\n      { [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never },\n      E1 | Error,\n      R1 | Context\n    >\n    : never\n  /**\n   * `bindAll` combines `all` with `bind`. It is useful\n   * when you want to concurrently run multiple effects and then combine their\n   * results in a Do notation pipeline.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, Either, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bindAll(({ x }) => ({\n   *     a: Effect.succeed(x),\n   *     b: Effect.fail(\"oops\"),\n   *   }), { concurrency: 2, mode: \"either\" })\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left(\"oops\") })\n   * ```\n   *\n   * @category Do notation\n   * @since 3.7.0\n   */\n  <\n    A extends object,\n    X extends Record<string, Effect<any, any, any>>,\n    O extends NoExcessProperties<{\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }, O>,\n    E1,\n    R1\n  >(\n    self: Effect<A, E1, R1>,\n    f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`,\n    options?: undefined | {\n      readonly concurrency?: Concurrency | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly mode?: \"default\" | \"validate\" | \"either\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>]\n    ? Effect<\n      { [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never },\n      E1 | Error,\n      R1 | Context\n    >\n    : never\n} = circular.bindAll\n\n/**\n * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n *\n * Here's how the do simulation works:\n *\n * 1. Start the do simulation using the `Do` value\n * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, pipe } from \"effect\"\n *\n * const result = pipe(\n *   Effect.Do,\n *   Effect.bind(\"x\", () => Effect.succeed(2)),\n *   Effect.bind(\"y\", () => Effect.succeed(3)),\n *   Effect.let(\"sum\", ({ x, y }) => x + y)\n * )\n * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n * ```\n *\n * @see {@link Do}\n * @see {@link bind}\n * @see {@link let_ let}\n *\n * @category Do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bind(\"y\", () => Effect.succeed(3)),\n   *   Effect.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A }, E, R>\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bind(\"y\", () => Effect.succeed(3)),\n   *   Effect.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link let_ let}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A }, E, R>\n} = effect.bindTo\n\nconst let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): <E, R>(self: Effect<A, E, R>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n  <A extends object, N extends string, E, R, B>(\n    self: Effect<A, E, R>,\n    name: Exclude<N, keyof A>,\n    f: (a: NoInfer<A>) => B\n  ): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n} = effect.let_\n\nexport {\n  /**\n   * The \"do simulation\" in Effect allows you to write code in a more declarative style, similar to the \"do notation\" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n   *\n   * Here's how the do simulation works:\n   *\n   * 1. Start the do simulation using the `Do` value\n   * 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n   * 3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n   * 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n   *\n   * **Example**\n   *\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Effect, pipe } from \"effect\"\n   *\n   * const result = pipe(\n   *   Effect.Do,\n   *   Effect.bind(\"x\", () => Effect.succeed(2)),\n   *   Effect.bind(\"y\", () => Effect.succeed(3)),\n   *   Effect.let(\"sum\", ({ x, y }) => x + y)\n   * )\n   * assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n   *\n   * ```\n   *\n   * @see {@link Do}\n   * @see {@link bind}\n   * @see {@link bindTo}\n   *\n   * @category Do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * Encapsulates the result of an effect in an `Option`.\n *\n * **Details**\n *\n * This function wraps the outcome of an effect in an `Option` type. If the\n * original effect succeeds, the success value is wrapped in `Option.some`. If\n * the effect fails, the failure is converted to `Option.none`.\n *\n * This is particularly useful for scenarios where you want to represent the\n * absence of a value explicitly, without causing the resulting effect to fail.\n * The resulting effect has an error type of `never`, meaning it cannot fail\n * directly. However, unrecoverable errors, also referred to as defects, are\n * not captured and will still result in failure.\n *\n * **Example** (Using Effect.option to Handle Errors)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const maybe1 = Effect.option(Effect.succeed(1))\n *\n * Effect.runPromiseExit(maybe1).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Success',\n * //   value: { _id: 'Option', _tag: 'Some', value: 1 }\n * // }\n *\n * const maybe2 = Effect.option(Effect.fail(\"Uh oh!\"))\n *\n * Effect.runPromiseExit(maybe2).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Success',\n * //   value: { _id: 'Option', _tag: 'None' }\n * // }\n *\n * const maybe3 = Effect.option(Effect.die(\"Boom!\"))\n *\n * Effect.runPromiseExit(maybe3).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }\n * // }\n * ```\n *\n * @see {@link either} for a version that uses `Either` instead.\n * @see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.\n *\n * @since 2.0.0\n * @category Outcome Encapsulation\n */\nexport const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R> = effect.option\n\n/**\n * Encapsulates both success and failure of an `Effect` into an `Either` type.\n *\n * **Details**\n *\n * This function converts an effect that may fail into an effect that always\n * succeeds, wrapping the outcome in an `Either` type. The result will be\n * `Either.Left` if the effect fails, containing the recoverable error, or\n * `Either.Right` if it succeeds, containing the result.\n *\n * Using this function, you can handle recoverable errors explicitly without\n * causing the effect to fail. This is particularly useful in scenarios where\n * you want to chain effects and manage both success and failure in the same\n * logical flow.\n *\n * It's important to note that unrecoverable errors, often referred to as\n * \"defects,\" are still thrown and not captured within the `Either` type. Only\n * failures that are explicitly represented as recoverable errors in the effect\n * are encapsulated.\n *\n * The resulting effect cannot fail directly because all recoverable failures\n * are represented inside the `Either` type.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Either, Random } from \"effect\"\n *\n * class HttpError {\n *   readonly _tag = \"HttpError\"\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n * }\n *\n * //       Effect<string, HttpError | ValidationError, never>\n * //      \n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return \"some result\"\n * })\n *\n * //       Effect<string, never, never>\n * //      \n * const recovered = Effect.gen(function* () {\n *   //       Either<string, HttpError | ValidationError>\n *   //      \n *   const failureOrSuccess = yield* Effect.either(program)\n *   return Either.match(failureOrSuccess, {\n *     onLeft: (error) => `Recovering from ${error._tag}`,\n *     onRight: (value) => value // Do nothing in case of success\n *   })\n * })\n * ```\n *\n * @see {@link option} for a version that uses `Option` instead.\n * @see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.\n *\n * @since 2.0.0\n * @category Outcome Encapsulation\n */\nexport const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R> = core.either\n\n/**\n * Encapsulates both success and failure of an `Effect` using the `Exit` type.\n *\n * **Details**\n *\n * This function converts an effect into one that always succeeds, wrapping its\n * outcome in the `Exit` type. The `Exit` type provides explicit handling of\n * both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including\n * defects (unrecoverable errors).\n *\n * Unlike {@link either} or {@link option}, this function also encapsulates\n * defects, which are typically unrecoverable and would otherwise terminate the\n * effect. With the `Exit` type, defects are represented in `Exit.Failure`,\n * allowing for detailed introspection and structured error handling.\n *\n * This makes the resulting effect robust and incapable of direct failure (its\n * error type is `never`). It is particularly useful for workflows where all\n * outcomes, including unexpected defects, must be managed and analyzed.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Cause, Console, Exit } from \"effect\"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage(\"Boom!\")\n *\n * const program = Effect.gen(function* () {\n *   const exit = yield* Effect.exit(task)\n *   if (Exit.isFailure(exit)) {\n *     const cause = exit.cause\n *     if (\n *       Cause.isDieType(cause) &&\n *       Cause.isRuntimeException(cause.defect)\n *     ) {\n *       yield* Console.log(\n *         `RuntimeException defect caught: ${cause.defect.message}`\n *       )\n *     } else {\n *       yield* Console.log(\"Unknown failure caught.\")\n *     }\n *   }\n * })\n *\n * // We get an Exit.Success because we caught all failures\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: \"Exit\",\n * //   _tag: \"Success\",\n * //   value: undefined\n * // }\n * ```\n *\n * @see {@link option} for a version that uses `Option` instead.\n * @see {@link either} for a version that uses `Either` instead.\n *\n * @since 2.0.0\n * @category Outcome Encapsulation\n */\nexport const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R> = core.exit\n\n/**\n * Converts an `Effect` into an operation that completes a `Deferred` with its result.\n *\n * **Details**\n *\n * The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\n * is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\n * completed with the success value. If the effect fails, the `Deferred` is completed with the\n * failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.\n *\n * **Example**\n *\n * ```ts\n * import { Deferred, Effect } from \"effect\"\n *\n * // Define an effect that succeeds\n * const successEffect = Effect.succeed(42)\n *\n * const program = Effect.gen(function*() {\n *   // Create a deferred\n *   const deferred = yield* Deferred.make<number, string>()\n *\n *   // Complete the deferred using the successEffect\n *   const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n *\n *   // Access the value of the deferred\n *   const value = yield* Deferred.await(deferred)\n *   console.log(value)\n *\n *   return isCompleted\n * })\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // 42\n * // true\n * ```\n *\n * @since 2.0.0\n * @category Synchronization Utilities\n */\nexport const intoDeferred: {\n  /**\n   * Converts an `Effect` into an operation that completes a `Deferred` with its result.\n   *\n   * **Details**\n   *\n   * The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\n   * is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\n   * completed with the success value. If the effect fails, the `Deferred` is completed with the\n   * failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Deferred, Effect } from \"effect\"\n   *\n   * // Define an effect that succeeds\n   * const successEffect = Effect.succeed(42)\n   *\n   * const program = Effect.gen(function*() {\n   *   // Create a deferred\n   *   const deferred = yield* Deferred.make<number, string>()\n   *\n   *   // Complete the deferred using the successEffect\n   *   const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n   *\n   *   // Access the value of the deferred\n   *   const value = yield* Deferred.await(deferred)\n   *   console.log(value)\n   *\n   *   return isCompleted\n   * })\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // 42\n   * // true\n   * ```\n   *\n   * @since 2.0.0\n   * @category Synchronization Utilities\n   */\n  <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>\n  /**\n   * Converts an `Effect` into an operation that completes a `Deferred` with its result.\n   *\n   * **Details**\n   *\n   * The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\n   * is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\n   * completed with the success value. If the effect fails, the `Deferred` is completed with the\n   * failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Deferred, Effect } from \"effect\"\n   *\n   * // Define an effect that succeeds\n   * const successEffect = Effect.succeed(42)\n   *\n   * const program = Effect.gen(function*() {\n   *   // Create a deferred\n   *   const deferred = yield* Deferred.make<number, string>()\n   *\n   *   // Complete the deferred using the successEffect\n   *   const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n   *\n   *   // Access the value of the deferred\n   *   const value = yield* Deferred.await(deferred)\n   *   console.log(value)\n   *\n   *   return isCompleted\n   * })\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // 42\n   * // true\n   * ```\n   *\n   * @since 2.0.0\n   * @category Synchronization Utilities\n   */\n  <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>\n} = core.intoDeferred\n\nconst if_: {\n  <A1, E1, R1, A2, E2, R2>(\n    options: { readonly onTrue: LazyArg<Effect<A1, E1, R1>>; readonly onFalse: LazyArg<Effect<A2, E2, R2>> }\n  ): <E = never, R = never>(self: boolean | Effect<boolean, E, R>) => Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n  <A1, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: boolean | Effect<boolean, E, R>,\n    options: { readonly onTrue: LazyArg<Effect<A1, E1, R1>>; readonly onFalse: LazyArg<Effect<A2, E2, R2>> }\n  ): Effect<A1 | A2, E1 | E2 | E, R1 | R2 | R>\n} = core.if_\n\nexport {\n  /**\n   * Executes one of two effects based on a condition evaluated by an effectful predicate.\n   *\n   * Use `if` to run one of two effects depending on whether the predicate effect\n   * evaluates to `true` or `false`. If the predicate is `true`, the `onTrue` effect\n   * is executed. If it is `false`, the `onFalse` effect is executed instead.\n   *\n   * **Example** (Simulating a Coin Flip)\n   *\n   * ```ts\n   * import { Effect, Random, Console } from \"effect\"\n   *\n   * const flipTheCoin = Effect.if(Random.nextBoolean, {\n   *   onTrue: () => Console.log(\"Head\"), // Runs if the predicate is true\n   *   onFalse: () => Console.log(\"Tail\") // Runs if the predicate is false\n   * })\n   *\n   * Effect.runFork(flipTheCoin)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  if_ as if\n}\n\n/**\n * Filters an effect, dying with a custom defect if the predicate fails.\n *\n * **Details**\n *\n * This function applies a predicate to the result of an effect. If the\n * predicate evaluates to `false`, the effect dies with a custom defect\n * generated by the `orDieWith` function.\n *\n * **When to Use**\n *\n * This is useful for enforcing constraints on values and treating violations as\n * fatal program errors.\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filterOrDie: {\n  /**\n   * Filters an effect, dying with a custom defect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect dies with a custom defect\n   * generated by the `orDieWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints on values and treating violations as\n   * fatal program errors.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>\n  /**\n   * Filters an effect, dying with a custom defect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect dies with a custom defect\n   * generated by the `orDieWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints on values and treating violations as\n   * fatal program errors.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Filters an effect, dying with a custom defect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect dies with a custom defect\n   * generated by the `orDieWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints on values and treating violations as\n   * fatal program errors.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, B extends A>(\n    self: Effect<A, E, R>,\n    refinement: Refinement<A, B>,\n    orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown\n  ): Effect<B, E, R>\n  /**\n   * Filters an effect, dying with a custom defect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect dies with a custom defect\n   * generated by the `orDieWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints on values and treating violations as\n   * fatal program errors.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R>(\n    self: Effect<A, E, R>,\n    predicate: Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect<A, E, R>\n} = effect.filterOrDie\n\n/**\n * Filters an effect, dying with a custom message if the predicate fails.\n *\n * **Details**\n *\n * This function works like {@link filterOrDie} but allows you to specify a\n * custom error message to describe the reason for the failure. The message is\n * included in the defect when the predicate evaluates to `false`.\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filterOrDieMessage: {\n  /**\n   * Filters an effect, dying with a custom message if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function works like {@link filterOrDie} but allows you to specify a\n   * custom error message to describe the reason for the failure. The message is\n   * included in the defect when the predicate evaluates to `false`.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>\n  /**\n   * Filters an effect, dying with a custom message if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function works like {@link filterOrDie} but allows you to specify a\n   * custom error message to describe the reason for the failure. The message is\n   * included in the defect when the predicate evaluates to `false`.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Filters an effect, dying with a custom message if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function works like {@link filterOrDie} but allows you to specify a\n   * custom error message to describe the reason for the failure. The message is\n   * included in the defect when the predicate evaluates to `false`.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>\n  /**\n   * Filters an effect, dying with a custom message if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function works like {@link filterOrDie} but allows you to specify a\n   * custom error message to describe the reason for the failure. The message is\n   * included in the defect when the predicate evaluates to `false`.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>\n} = effect.filterOrDieMessage\n\n/**\n * Filters an effect, providing an alternative effect if the predicate fails.\n *\n * **Details**\n *\n * This function applies a predicate to the result of an effect. If the\n * predicate evaluates to `false`, it executes the `orElse` effect instead. The\n * `orElse` effect can produce an alternative value or perform additional\n * computations.\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filterOrElse: {\n  /**\n   * Filters an effect, providing an alternative effect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, it executes the `orElse` effect instead. The\n   * `orElse` effect can produce an alternative value or perform additional\n   * computations.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, C, E2, R2, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orElse: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => Effect<C, E2, R2>\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>\n  /**\n   * Filters an effect, providing an alternative effect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, it executes the `orElse` effect instead. The\n   * `orElse` effect can produce an alternative value or perform additional\n   * computations.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, C, E2, R2>(\n    predicate: Predicate<NoInfer<A>>,\n    orElse: (a: NoInfer<A>) => Effect<C, E2, R2>\n  ): <E, R>(self: Effect<A, E, R>) => Effect<A | C, E2 | E, R2 | R>\n  /**\n   * Filters an effect, providing an alternative effect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, it executes the `orElse` effect instead. The\n   * `orElse` effect can produce an alternative value or perform additional\n   * computations.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, C, E2, R2, B extends A>(\n    self: Effect<A, E, R>,\n    refinement: Refinement<A, B>,\n    orElse: (a: EqualsWith<A, B, A, Exclude<A, B>>) => Effect<C, E2, R2>\n  ): Effect<B | C, E | E2, R | R2>\n  /**\n   * Filters an effect, providing an alternative effect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, it executes the `orElse` effect instead. The\n   * `orElse` effect can produce an alternative value or perform additional\n   * computations.\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, C, E2, R2>(\n    self: Effect<A, E, R>,\n    predicate: Predicate<A>,\n    orElse: (a: A) => Effect<C, E2, R2>\n  ): Effect<A | C, E | E2, R | R2>\n} = effect.filterOrElse\n\n/**\n * Filters an effect, failing with a custom error if the predicate fails.\n *\n * **Details**\n *\n * This function applies a predicate to the result of an effect. If the\n * predicate evaluates to `false`, the effect fails with a custom error\n * generated by the `orFailWith` function.\n *\n * **When to Use**\n *\n * This is useful for enforcing constraints and treating violations as\n * recoverable errors.\n *\n * **Providing a Guard**\n *\n * In addition to the filtering capabilities discussed earlier, you have the\n * option to further refine and narrow down the type of the success channel by\n * providing a [user-defined type\n * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n * Let's explore this concept through an example:\n *\n * **Example**\n *\n * ```ts\n * import { Effect, pipe } from \"effect\"\n *\n * // Define a user interface\n * interface User {\n *   readonly name: string\n * }\n *\n * // Simulate an asynchronous authentication function\n * declare const auth: () => Promise<User | null>\n *\n * const program = pipe(\n *   Effect.promise(() => auth()),\n *   // Use filterOrFail with a custom type guard to ensure user is not null\n *   Effect.filterOrFail(\n *     (user): user is User => user !== null, // Type guard\n *     () => new Error(\"Unauthorized\")\n *   ),\n *   // 'user' now has the type `User` (not `User | null`)\n *   Effect.andThen((user) => user.name)\n * )\n * ```\n *\n * @since 2.0.0\n * @category Filtering\n */\nexport const filterOrFail: {\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E2, B extends A>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orFailWith: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => E2\n  ): <E, R>(self: Effect<A, E, R>) => Effect<NoInfer<B>, E2 | E, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, E2, B extends A>(\n    self: Effect<A, E, R>,\n    refinement: Refinement<A, B>,\n    orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E2\n  ): Effect<NoInfer<B>, E2 | E, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E2 | E, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<NoInfer<B>, Cause.NoSuchElementException | E, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<NoInfer<B>, E | Cause.NoSuchElementException, R>\n  /**\n   * Filters an effect, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Providing a Guard**\n   *\n   * In addition to the filtering capabilities discussed earlier, you have the\n   * option to further refine and narrow down the type of the success channel by\n   * providing a [user-defined type\n   * guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\n   * Let's explore this concept through an example:\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterOrFail with a custom type guard to ensure user is not null\n   *   Effect.filterOrFail(\n   *     (user): user is User => user !== null, // Type guard\n   *     () => new Error(\"Unauthorized\")\n   *   ),\n   *   // 'user' now has the type `User` (not `User | null`)\n   *   Effect.andThen((user) => user.name)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Filtering\n   */\n  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>\n} = effect.filterOrFail\n\n/**\n * Filters an effect with an effectful predicate, falling back to an alternative\n * effect if the predicate fails.\n *\n * **Details**\n *\n * This function applies a predicate to the result of an effect. If the\n * predicate evaluates to `false`, the effect falls back to the `orElse`\n * effect. The `orElse` effect can produce an alternative value or perform\n * additional computations.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, pipe } from \"effect\"\n *\n * // Define a user interface\n * interface User {\n *   readonly name: string\n * }\n *\n * // Simulate an asynchronous authentication function\n * declare const auth: () => Promise<User | null>\n *\n * const program = pipe(\n *   Effect.promise(() => auth()),\n *   // Use filterEffectOrElse with an effectful predicate\n *   Effect.filterEffectOrElse({\n *     predicate: (user) => Effect.succeed(user !== null),\n *     orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n *   }),\n * )\n * ```\n *\n * @since 3.13.0\n * @category Filtering\n */\nexport const filterEffectOrElse: {\n  /**\n   * Filters an effect with an effectful predicate, falling back to an alternative\n   * effect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect falls back to the `orElse`\n   * effect. The `orElse` effect can produce an alternative value or perform\n   * additional computations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterEffectOrElse with an effectful predicate\n   *   Effect.filterEffectOrElse({\n   *     predicate: (user) => Effect.succeed(user !== null),\n   *     orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n   *   }),\n   * )\n   * ```\n   *\n   * @since 3.13.0\n   * @category Filtering\n   */\n  <A, E2, R2, A2, E3, R3>(\n    options: {\n      readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>\n      readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>\n    }\n  ): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E | E2 | E3, R | R2 | R3>\n  /**\n   * Filters an effect with an effectful predicate, falling back to an alternative\n   * effect if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect falls back to the `orElse`\n   * effect. The `orElse` effect can produce an alternative value or perform\n   * additional computations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterEffectOrElse with an effectful predicate\n   *   Effect.filterEffectOrElse({\n   *     predicate: (user) => Effect.succeed(user !== null),\n   *     orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n   *   }),\n   * )\n   * ```\n   *\n   * @since 3.13.0\n   * @category Filtering\n   */\n  <A, E, R, E2, R2, A2, E3, R3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly predicate: (a: A) => Effect<boolean, E2, R2>\n      readonly orElse: (a: A) => Effect<A2, E3, R3>\n    }\n  ): Effect<A | A2, E | E2 | E3, R | R2 | R3>\n} = core.filterEffectOrElse\n\n/**\n * Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n *\n * **Details**\n *\n * This function applies a predicate to the result of an effect. If the\n * predicate evaluates to `false`, the effect fails with a custom error\n * generated by the `orFailWith` function.\n *\n * **When to Use**\n *\n * This is useful for enforcing constraints and treating violations as\n * recoverable errors.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, pipe } from \"effect\"\n *\n * // Define a user interface\n * interface User {\n *   readonly name: string\n * }\n *\n * // Simulate an asynchronous authentication function\n * declare const auth: () => Promise<User | null>\n *\n * const program = pipe(\n *   Effect.promise(() => auth()),\n *   // Use filterEffectOrFail with an effectful predicate\n *   Effect.filterEffectOrFail({\n *     predicate: (user) => Effect.succeed(user !== null),\n *     orFailWith: () => new Error(\"Unauthorized\")\n *   }),\n * )\n * ```\n *\n * @since 3.13.0\n * @category Filtering\n */\nexport const filterEffectOrFail: {\n  /**\n   * Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterEffectOrFail with an effectful predicate\n   *   Effect.filterEffectOrFail({\n   *     predicate: (user) => Effect.succeed(user !== null),\n   *     orFailWith: () => new Error(\"Unauthorized\")\n   *   }),\n   * )\n   * ```\n   *\n   * @since 3.13.0\n   * @category Filtering\n   */\n  <A, E2, R2, E3>(\n    options: {\n      readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>\n      readonly orFailWith: (a: NoInfer<A>) => E3\n    }\n  ): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>\n  /**\n   * Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n   *\n   * **Details**\n   *\n   * This function applies a predicate to the result of an effect. If the\n   * predicate evaluates to `false`, the effect fails with a custom error\n   * generated by the `orFailWith` function.\n   *\n   * **When to Use**\n   *\n   * This is useful for enforcing constraints and treating violations as\n   * recoverable errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, pipe } from \"effect\"\n   *\n   * // Define a user interface\n   * interface User {\n   *   readonly name: string\n   * }\n   *\n   * // Simulate an asynchronous authentication function\n   * declare const auth: () => Promise<User | null>\n   *\n   * const program = pipe(\n   *   Effect.promise(() => auth()),\n   *   // Use filterEffectOrFail with an effectful predicate\n   *   Effect.filterEffectOrFail({\n   *     predicate: (user) => Effect.succeed(user !== null),\n   *     orFailWith: () => new Error(\"Unauthorized\")\n   *   }),\n   * )\n   * ```\n   *\n   * @since 3.13.0\n   * @category Filtering\n   */\n  <A, E, R, E2, R2, E3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly predicate: (a: A) => Effect<boolean, E2, R2>\n      readonly orFailWith: (a: A) => E3\n    }\n  ): Effect<A, E | E2 | E3, R | R2>\n} = core.filterEffectOrFail\n\n/**\n * Executes an effect only if the condition is `false`.\n *\n * @see {@link unlessEffect} for a version that allows the condition to be an effect.\n * @see {@link when} for a version that executes the effect when the condition is `true`.\n *\n * @since 2.0.0\n * @category Conditional Operators\n */\nexport const unless: {\n  /**\n   * Executes an effect only if the condition is `false`.\n   *\n   * @see {@link unlessEffect} for a version that allows the condition to be an effect.\n   * @see {@link when} for a version that executes the effect when the condition is `true`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n  /**\n   * Executes an effect only if the condition is `false`.\n   *\n   * @see {@link unlessEffect} for a version that allows the condition to be an effect.\n   * @see {@link when} for a version that executes the effect when the condition is `true`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>\n} = effect.unless\n\n/**\n * Conditionally execute an effect based on the result of another effect.\n *\n * @see {@link unless} for a version that allows the condition to be a boolean.\n * @see {@link whenEffect} for a version that executes the effect when the condition is `true`.\n *\n * @since 2.0.0\n * @category Conditional Operators\n */\nexport const unlessEffect: {\n  /**\n   * Conditionally execute an effect based on the result of another effect.\n   *\n   * @see {@link unless} for a version that allows the condition to be a boolean.\n   * @see {@link whenEffect} for a version that executes the effect when the condition is `true`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>\n  /**\n   * Conditionally execute an effect based on the result of another effect.\n   *\n   * @see {@link unless} for a version that allows the condition to be a boolean.\n   * @see {@link whenEffect} for a version that executes the effect when the condition is `true`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>\n} = effect.unlessEffect\n\n/**\n * Conditionally executes an effect based on a boolean condition.\n *\n * **Details**\n *\n * This function allows you to run an effect only if a given condition evaluates\n * to `true`. If the condition is `true`, the effect is executed, and its result\n * is wrapped in an `Option.some`. If the condition is `false`, the effect is\n * skipped, and the result is `Option.none`.\n *\n * **When to Use**\n *\n * This function is useful for scenarios where you need to dynamically decide\n * whether to execute an effect based on runtime logic, while also representing\n * the skipped case explicitly.\n *\n * **Example** (Conditional Effect Execution)\n *\n * ```ts\n * import { Effect, Option } from \"effect\"\n *\n * const validateWeightOption = (\n *   weight: number\n * ): Effect.Effect<Option.Option<number>> =>\n *   // Conditionally execute the effect if the weight is non-negative\n *   Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n *\n * // Run with a valid weight\n * Effect.runPromise(validateWeightOption(100)).then(console.log)\n * // Output:\n * // {\n * //   _id: \"Option\",\n * //   _tag: \"Some\",\n * //   value: 100\n * // }\n *\n * // Run with an invalid weight\n * Effect.runPromise(validateWeightOption(-5)).then(console.log)\n * // Output:\n * // {\n * //   _id: \"Option\",\n * //   _tag: \"None\"\n * // }\n * ```\n *\n * @see {@link whenEffect} for a version that allows the condition to be an effect.\n * @see {@link unless} for a version that executes the effect when the condition is `false`.\n *\n * @since 2.0.0\n * @category Conditional Operators\n */\nexport const when: {\n  /**\n   * Conditionally executes an effect based on a boolean condition.\n   *\n   * **Details**\n   *\n   * This function allows you to run an effect only if a given condition evaluates\n   * to `true`. If the condition is `true`, the effect is executed, and its result\n   * is wrapped in an `Option.some`. If the condition is `false`, the effect is\n   * skipped, and the result is `Option.none`.\n   *\n   * **When to Use**\n   *\n   * This function is useful for scenarios where you need to dynamically decide\n   * whether to execute an effect based on runtime logic, while also representing\n   * the skipped case explicitly.\n   *\n   * **Example** (Conditional Effect Execution)\n   *\n   * ```ts\n   * import { Effect, Option } from \"effect\"\n   *\n   * const validateWeightOption = (\n   *   weight: number\n   * ): Effect.Effect<Option.Option<number>> =>\n   *   // Conditionally execute the effect if the weight is non-negative\n   *   Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n   *\n   * // Run with a valid weight\n   * Effect.runPromise(validateWeightOption(100)).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: \"Option\",\n   * //   _tag: \"Some\",\n   * //   value: 100\n   * // }\n   *\n   * // Run with an invalid weight\n   * Effect.runPromise(validateWeightOption(-5)).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: \"Option\",\n   * //   _tag: \"None\"\n   * // }\n   * ```\n   *\n   * @see {@link whenEffect} for a version that allows the condition to be an effect.\n   * @see {@link unless} for a version that executes the effect when the condition is `false`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n  /**\n   * Conditionally executes an effect based on a boolean condition.\n   *\n   * **Details**\n   *\n   * This function allows you to run an effect only if a given condition evaluates\n   * to `true`. If the condition is `true`, the effect is executed, and its result\n   * is wrapped in an `Option.some`. If the condition is `false`, the effect is\n   * skipped, and the result is `Option.none`.\n   *\n   * **When to Use**\n   *\n   * This function is useful for scenarios where you need to dynamically decide\n   * whether to execute an effect based on runtime logic, while also representing\n   * the skipped case explicitly.\n   *\n   * **Example** (Conditional Effect Execution)\n   *\n   * ```ts\n   * import { Effect, Option } from \"effect\"\n   *\n   * const validateWeightOption = (\n   *   weight: number\n   * ): Effect.Effect<Option.Option<number>> =>\n   *   // Conditionally execute the effect if the weight is non-negative\n   *   Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n   *\n   * // Run with a valid weight\n   * Effect.runPromise(validateWeightOption(100)).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: \"Option\",\n   * //   _tag: \"Some\",\n   * //   value: 100\n   * // }\n   *\n   * // Run with an invalid weight\n   * Effect.runPromise(validateWeightOption(-5)).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: \"Option\",\n   * //   _tag: \"None\"\n   * // }\n   * ```\n   *\n   * @see {@link whenEffect} for a version that allows the condition to be an effect.\n   * @see {@link unless} for a version that executes the effect when the condition is `false`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>\n} = effect.when\n\n/**\n * Conditionally executes an effect based on the result of another effect.\n *\n * **Details**\n *\n * This function allows you to run an effect only if a conditional effect\n * evaluating to a boolean resolves to `true`. If the conditional effect\n * evaluates to `true`, the specified effect is executed, and its result is\n * wrapped in `Option.some`. If the conditional effect evaluates to `false`, the\n * effect is skipped, and the result is `Option.none`.\n *\n * **When to Use**\n *\n * This function is particularly useful when the decision to execute an effect\n * depends on the result of another effect, such as a random value, a\n * user-provided input, or a network request result.\n *\n * **Example** (Using an Effect as a Condition)\n *\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * const randomIntOption = Random.nextInt.pipe(\n *   Effect.whenEffect(Random.nextBoolean)\n * )\n *\n * console.log(Effect.runSync(randomIntOption))\n * // Example Output:\n * // { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n * ```\n *\n * @see {@link when} for a version that allows the condition to be a boolean.\n * @see {@link unlessEffect} for a version that executes the effect when the condition is `false`.\n *\n * @since 2.0.0\n * @category Conditional Operators\n */\nexport const whenEffect: {\n  /**\n   * Conditionally executes an effect based on the result of another effect.\n   *\n   * **Details**\n   *\n   * This function allows you to run an effect only if a conditional effect\n   * evaluating to a boolean resolves to `true`. If the conditional effect\n   * evaluates to `true`, the specified effect is executed, and its result is\n   * wrapped in `Option.some`. If the conditional effect evaluates to `false`, the\n   * effect is skipped, and the result is `Option.none`.\n   *\n   * **When to Use**\n   *\n   * This function is particularly useful when the decision to execute an effect\n   * depends on the result of another effect, such as a random value, a\n   * user-provided input, or a network request result.\n   *\n   * **Example** (Using an Effect as a Condition)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * const randomIntOption = Random.nextInt.pipe(\n   *   Effect.whenEffect(Random.nextBoolean)\n   * )\n   *\n   * console.log(Effect.runSync(randomIntOption))\n   * // Example Output:\n   * // { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n   * ```\n   *\n   * @see {@link when} for a version that allows the condition to be a boolean.\n   * @see {@link unlessEffect} for a version that executes the effect when the condition is `false`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>\n  /**\n   * Conditionally executes an effect based on the result of another effect.\n   *\n   * **Details**\n   *\n   * This function allows you to run an effect only if a conditional effect\n   * evaluating to a boolean resolves to `true`. If the conditional effect\n   * evaluates to `true`, the specified effect is executed, and its result is\n   * wrapped in `Option.some`. If the conditional effect evaluates to `false`, the\n   * effect is skipped, and the result is `Option.none`.\n   *\n   * **When to Use**\n   *\n   * This function is particularly useful when the decision to execute an effect\n   * depends on the result of another effect, such as a random value, a\n   * user-provided input, or a network request result.\n   *\n   * **Example** (Using an Effect as a Condition)\n   *\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * const randomIntOption = Random.nextInt.pipe(\n   *   Effect.whenEffect(Random.nextBoolean)\n   * )\n   *\n   * console.log(Effect.runSync(randomIntOption))\n   * // Example Output:\n   * // { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n   * ```\n   *\n   * @see {@link when} for a version that allows the condition to be a boolean.\n   * @see {@link unlessEffect} for a version that executes the effect when the condition is `false`.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>\n} = core.whenEffect\n\n/**\n * Executes an effect conditionally based on the value of a `FiberRef` that\n * satisfies a predicate.\n *\n * **Details**\n *\n * This function enables you to execute an effect only when the value of a\n * specified `FiberRef` meets a certain condition defined by a predicate. If the\n * value satisfies the predicate, the effect is executed, and the result is\n * wrapped in an `Option.some`. If the predicate is not satisfied, the effect is\n * skipped, and the result is `Option.none`. In both cases, the current value of\n * the `FiberRef` is included in the result.\n *\n * @since 2.0.0\n * @category Conditional Operators\n */\nexport const whenFiberRef: {\n  /**\n   * Executes an effect conditionally based on the value of a `FiberRef` that\n   * satisfies a predicate.\n   *\n   * **Details**\n   *\n   * This function enables you to execute an effect only when the value of a\n   * specified `FiberRef` meets a certain condition defined by a predicate. If the\n   * value satisfies the predicate, the effect is executed, and the result is\n   * wrapped in an `Option.some`. If the predicate is not satisfied, the effect is\n   * skipped, and the result is `Option.none`. In both cases, the current value of\n   * the `FiberRef` is included in the result.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <S>(fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>\n  /**\n   * Executes an effect conditionally based on the value of a `FiberRef` that\n   * satisfies a predicate.\n   *\n   * **Details**\n   *\n   * This function enables you to execute an effect only when the value of a\n   * specified `FiberRef` meets a certain condition defined by a predicate. If the\n   * value satisfies the predicate, the effect is executed, and the result is\n   * wrapped in an `Option.some`. If the predicate is not satisfied, the effect is\n   * skipped, and the result is `Option.none`. In both cases, the current value of\n   * the `FiberRef` is included in the result.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <A, E, R, S>(\n    self: Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate<S>\n  ): Effect<[S, Option.Option<A>], E, R>\n} = effect.whenFiberRef\n\n/**\n * Executes an effect conditionally based on the value of a `Ref` that satisfies\n * a predicate.\n *\n * **Details**\n *\n * This function allows you to execute an effect only when the value of a\n * specified `Ref` meets a condition defined by a predicate. If the value\n * satisfies the predicate, the effect is executed, and the result is wrapped in\n * an `Option.some`. If the predicate is not satisfied, the effect is skipped,\n * and the result is `Option.none`. In both cases, the current value of the\n * `Ref` is included in the result.\n *\n * @since 2.0.0\n * @category Conditional Operators\n */\nexport const whenRef: {\n  /**\n   * Executes an effect conditionally based on the value of a `Ref` that satisfies\n   * a predicate.\n   *\n   * **Details**\n   *\n   * This function allows you to execute an effect only when the value of a\n   * specified `Ref` meets a condition defined by a predicate. If the value\n   * satisfies the predicate, the effect is executed, and the result is wrapped in\n   * an `Option.some`. If the predicate is not satisfied, the effect is skipped,\n   * and the result is `Option.none`. In both cases, the current value of the\n   * `Ref` is included in the result.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>\n  /**\n   * Executes an effect conditionally based on the value of a `Ref` that satisfies\n   * a predicate.\n   *\n   * **Details**\n   *\n   * This function allows you to execute an effect only when the value of a\n   * specified `Ref` meets a condition defined by a predicate. If the value\n   * satisfies the predicate, the effect is executed, and the result is wrapped in\n   * an `Option.some`. If the predicate is not satisfied, the effect is skipped,\n   * and the result is `Option.none`. In both cases, the current value of the\n   * `Ref` is included in the result.\n   *\n   * @since 2.0.0\n   * @category Conditional Operators\n   */\n  <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>\n} = effect.whenRef\n\n/**\n * Chains effects to produce new `Effect` instances, useful for combining\n * operations that depend on previous results.\n *\n * **Syntax**\n *\n * ```ts skip-type-checking\n * const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n * // or\n * const flatMappedEffect = Effect.flatMap(myEffect, transformation)\n * // or\n * const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n * ```\n *\n * **Details**\n *\n * `flatMap` lets you sequence effects so that the result of one effect can be\n * used in the next step. It is similar to `flatMap` used with arrays but works\n * specifically with `Effect` instances, allowing you to avoid deeply nested\n * effect structures.\n *\n * Since effects are immutable, `flatMap` always returns a new effect instead of\n * changing the original one.\n *\n * **When to Use**\n *\n * Use `flatMap` when you need to chain multiple effects, ensuring that each\n * step produces a new `Effect` while flattening any nested effects that may\n * occur.\n *\n * **Example**\n *\n * ```ts\n * import { pipe, Effect } from \"effect\"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * // Chaining the fetch and discount application using `flatMap`\n * const finalAmount = pipe(\n *   fetchTransactionAmount,\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(finalAmount).then(console.log)\n * // Output: 95\n * ```\n *\n * @see {@link tap} for a version that ignores the result of the effect.\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const flatMap: {\n  /**\n   * Chains effects to produce new `Effect` instances, useful for combining\n   * operations that depend on previous results.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n   * // or\n   * const flatMappedEffect = Effect.flatMap(myEffect, transformation)\n   * // or\n   * const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n   * ```\n   *\n   * **Details**\n   *\n   * `flatMap` lets you sequence effects so that the result of one effect can be\n   * used in the next step. It is similar to `flatMap` used with arrays but works\n   * specifically with `Effect` instances, allowing you to avoid deeply nested\n   * effect structures.\n   *\n   * Since effects are immutable, `flatMap` always returns a new effect instead of\n   * changing the original one.\n   *\n   * **When to Use**\n   *\n   * Use `flatMap` when you need to chain multiple effects, ensuring that each\n   * step produces a new `Effect` while flattening any nested effects that may\n   * occur.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * // Chaining the fetch and discount application using `flatMap`\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output: 95\n   * ```\n   *\n   * @see {@link tap} for a version that ignores the result of the effect.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>\n  /**\n   * Chains effects to produce new `Effect` instances, useful for combining\n   * operations that depend on previous results.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n   * // or\n   * const flatMappedEffect = Effect.flatMap(myEffect, transformation)\n   * // or\n   * const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n   * ```\n   *\n   * **Details**\n   *\n   * `flatMap` lets you sequence effects so that the result of one effect can be\n   * used in the next step. It is similar to `flatMap` used with arrays but works\n   * specifically with `Effect` instances, allowing you to avoid deeply nested\n   * effect structures.\n   *\n   * Since effects are immutable, `flatMap` always returns a new effect instead of\n   * changing the original one.\n   *\n   * **When to Use**\n   *\n   * Use `flatMap` when you need to chain multiple effects, ensuring that each\n   * step produces a new `Effect` while flattening any nested effects that may\n   * occur.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * // Chaining the fetch and discount application using `flatMap`\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output: 95\n   * ```\n   *\n   * @see {@link tap} for a version that ignores the result of the effect.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>\n} = core.flatMap\n\n/**\n * Chains two actions, where the second action can depend on the result of the\n * first.\n *\n * **Syntax**\n *\n * ```ts skip-type-checking\n * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n * // or\n * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n * // or\n * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n * ```\n *\n * **When to Use**\n *\n * Use `andThen` when you need to run multiple actions in sequence, with the\n * second action depending on the result of the first. This is useful for\n * combining effects or handling computations that must happen in order.\n *\n * **Details**\n *\n * The second action can be:\n *\n * - A constant value (similar to {@link as})\n * - A function returning a value (similar to {@link map})\n * - A `Promise`\n * - A function returning a `Promise`\n * - An `Effect`\n * - A function returning an `Effect` (similar to {@link flatMap})\n *\n * **Note:** `andThen` works well with both `Option` and `Either` types,\n * treating them as effects.\n *\n * **Example** (Applying a Discount Based on Fetched Amount)\n *\n * ```ts\n * import { pipe, Effect } from \"effect\"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * // Using Effect.map and Effect.flatMap\n * const result1 = pipe(\n *   fetchTransactionAmount,\n *   Effect.map((amount) => amount * 2),\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result1).then(console.log)\n * // Output: 190\n *\n * // Using Effect.andThen\n * const result2 = pipe(\n *   fetchTransactionAmount,\n *   Effect.andThen((amount) => amount * 2),\n *   Effect.andThen((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result2).then(console.log)\n * // Output: 190\n * ```\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const andThen: {\n  /**\n   * Chains two actions, where the second action can depend on the result of the\n   * first.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n   * // or\n   * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n   * // or\n   * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n   * ```\n   *\n   * **When to Use**\n   *\n   * Use `andThen` when you need to run multiple actions in sequence, with the\n   * second action depending on the result of the first. This is useful for\n   * combining effects or handling computations that must happen in order.\n   *\n   * **Details**\n   *\n   * The second action can be:\n   *\n   * - A constant value (similar to {@link as})\n   * - A function returning a value (similar to {@link map})\n   * - A `Promise`\n   * - A function returning a `Promise`\n   * - An `Effect`\n   * - A function returning an `Effect` (similar to {@link flatMap})\n   *\n   * **Note:** `andThen` works well with both `Option` and `Either` types,\n   * treating them as effects.\n   *\n   * **Example** (Applying a Discount Based on Fetched Amount)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * // Using Effect.map and Effect.flatMap\n   * const result1 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.map((amount) => amount * 2),\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result1).then(console.log)\n   * // Output: 190\n   *\n   * // Using Effect.andThen\n   * const result2 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.andThen((amount) => amount * 2),\n   *   Effect.andThen((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result2).then(console.log)\n   * // Output: 190\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, X>(f: (a: NoInfer<A>) => X): <E, R>(\n    self: Effect<A, E, R>\n  ) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R>\n    : Effect<X, E, R>\n  /**\n   * Chains two actions, where the second action can depend on the result of the\n   * first.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n   * // or\n   * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n   * // or\n   * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n   * ```\n   *\n   * **When to Use**\n   *\n   * Use `andThen` when you need to run multiple actions in sequence, with the\n   * second action depending on the result of the first. This is useful for\n   * combining effects or handling computations that must happen in order.\n   *\n   * **Details**\n   *\n   * The second action can be:\n   *\n   * - A constant value (similar to {@link as})\n   * - A function returning a value (similar to {@link map})\n   * - A `Promise`\n   * - A function returning a `Promise`\n   * - An `Effect`\n   * - A function returning an `Effect` (similar to {@link flatMap})\n   *\n   * **Note:** `andThen` works well with both `Option` and `Either` types,\n   * treating them as effects.\n   *\n   * **Example** (Applying a Discount Based on Fetched Amount)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * // Using Effect.map and Effect.flatMap\n   * const result1 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.map((amount) => amount * 2),\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result1).then(console.log)\n   * // Output: 190\n   *\n   * // Using Effect.andThen\n   * const result2 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.andThen((amount) => amount * 2),\n   *   Effect.andThen((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result2).then(console.log)\n   * // Output: 190\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <X>(f: NotFunction<X>): <A, E, R>(\n    self: Effect<A, E, R>\n  ) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R>\n    : Effect<X, E, R>\n  /**\n   * Chains two actions, where the second action can depend on the result of the\n   * first.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n   * // or\n   * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n   * // or\n   * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n   * ```\n   *\n   * **When to Use**\n   *\n   * Use `andThen` when you need to run multiple actions in sequence, with the\n   * second action depending on the result of the first. This is useful for\n   * combining effects or handling computations that must happen in order.\n   *\n   * **Details**\n   *\n   * The second action can be:\n   *\n   * - A constant value (similar to {@link as})\n   * - A function returning a value (similar to {@link map})\n   * - A `Promise`\n   * - A function returning a `Promise`\n   * - An `Effect`\n   * - A function returning an `Effect` (similar to {@link flatMap})\n   *\n   * **Note:** `andThen` works well with both `Option` and `Either` types,\n   * treating them as effects.\n   *\n   * **Example** (Applying a Discount Based on Fetched Amount)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * // Using Effect.map and Effect.flatMap\n   * const result1 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.map((amount) => amount * 2),\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result1).then(console.log)\n   * // Output: 190\n   *\n   * // Using Effect.andThen\n   * const result2 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.andThen((amount) => amount * 2),\n   *   Effect.andThen((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result2).then(console.log)\n   * // Output: 190\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R>\n    : Effect<X, E, R>\n  /**\n   * Chains two actions, where the second action can depend on the result of the\n   * first.\n   *\n   * **Syntax**\n   *\n   * ```ts skip-type-checking\n   * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n   * // or\n   * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n   * // or\n   * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n   * ```\n   *\n   * **When to Use**\n   *\n   * Use `andThen` when you need to run multiple actions in sequence, with the\n   * second action depending on the result of the first. This is useful for\n   * combining effects or handling computations that must happen in order.\n   *\n   * **Details**\n   *\n   * The second action can be:\n   *\n   * - A constant value (similar to {@link as})\n   * - A function returning a value (similar to {@link map})\n   * - A `Promise`\n   * - A function returning a `Promise`\n   * - An `Effect`\n   * - A function returning an `Effect` (similar to {@link flatMap})\n   *\n   * **Note:** `andThen` works well with both `Option` and `Either` types,\n   * treating them as effects.\n   *\n   * **Example** (Applying a Discount Based on Fetched Amount)\n   *\n   * ```ts\n   * import { pipe, Effect } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * // Using Effect.map and Effect.flatMap\n   * const result1 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.map((amount) => amount * 2),\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result1).then(console.log)\n   * // Output: 190\n   *\n   * // Using Effect.andThen\n   * const result2 = pipe(\n   *   fetchTransactionAmount,\n   *   Effect.andThen((amount) => amount * 2),\n   *   Effect.andThen((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(result2).then(console.log)\n   * // Output: 190\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R>\n    : Effect<X, E, R>\n} = core.andThen\n\n/**\n * @since 2.0.0\n * @category Sequencing\n */\nexport const flatten: <A, E1, R1, E, R>(self: Effect<Effect<A, E1, R1>, E, R>) => Effect<A, E | E1, R | R1> =\n  core.flatten\n\n/**\n * Races two effects and returns the result of the first successful one.\n *\n * **Details**\n *\n * This function takes two effects and runs them concurrently. The first effect\n * that successfully completes will determine the result of the race, and the\n * other effect will be interrupted.\n *\n * If neither effect succeeds, the function will fail with a `Cause`\n * containing all the errors.\n *\n * **When to Use**\n *\n * This is useful when you want to run two effects concurrently, but only care\n * about the first one to succeed. It is commonly used in cases like timeouts,\n * retries, or when you want to optimize for the faster response without\n * worrying about the other effect.\n *\n * **Handling Success or Failure with Either**\n *\n * If you want to handle the result of whichever task completes first, whether\n * it succeeds or fails, you can use the `Effect.either` function. This function\n * wraps the result in an `Either` type, allowing you to see if the result\n * was a success (`Right`) or a failure (`Left`).\n *\n * **Example** (Both Tasks Succeed)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.succeed(\"task1\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * const program = Effect.race(task1, task2)\n *\n * Effect.runFork(program)\n * // Output:\n * // task1 done\n * // task2 interrupted\n * ```\n *\n * **Example** (One Task Fails, One Succeeds)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.fail(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * const program = Effect.race(task1, task2)\n *\n * Effect.runFork(program)\n * // Output:\n * // task2 done\n * ```\n *\n * **Example** (Both Tasks Fail)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.fail(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.fail(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * const program = Effect.race(task1, task2)\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Parallel',\n * //     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n * //     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n * //   }\n * // }\n * ```\n *\n * **Example** (Handling Success or Failure with Either)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.fail(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * // Run both tasks concurrently, wrapping the result\n * // in Either to capture success or failure\n * const program = Effect.race(Effect.either(task1), Effect.either(task2))\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // task2 interrupted\n * // { _id: 'Either', _tag: 'Left', left: 'task1' }\n * ```\n *\n * @see {@link raceAll} for a version that handles multiple effects.\n * @see {@link raceFirst} for a version that returns the result of the first effect to complete.\n *\n * @since 2.0.0\n * @category Racing\n */\nexport const race: {\n  /**\n   * Races two effects and returns the result of the first successful one.\n   *\n   * **Details**\n   *\n   * This function takes two effects and runs them concurrently. The first effect\n   * that successfully completes will determine the result of the race, and the\n   * other effect will be interrupted.\n   *\n   * If neither effect succeeds, the function will fail with a `Cause`\n   * containing all the errors.\n   *\n   * **When to Use**\n   *\n   * This is useful when you want to run two effects concurrently, but only care\n   * about the first one to succeed. It is commonly used in cases like timeouts,\n   * retries, or when you want to optimize for the faster response without\n   * worrying about the other effect.\n   *\n   * **Handling Success or Failure with Either**\n   *\n   * If you want to handle the result of whichever task completes first, whether\n   * it succeeds or fails, you can use the `Effect.either` function. This function\n   * wraps the result in an `Either` type, allowing you to see if the result\n   * was a success (`Right`) or a failure (`Left`).\n   *\n   * **Example** (Both Tasks Succeed)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * const program = Effect.race(task1, task2)\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // task1 done\n   * // task2 interrupted\n   * ```\n   *\n   * **Example** (One Task Fails, One Succeeds)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * const program = Effect.race(task1, task2)\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // task2 done\n   * ```\n   *\n   * **Example** (Both Tasks Fail)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.fail(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * const program = Effect.race(task1, task2)\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Parallel',\n   * //     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n   * //     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n   * //   }\n   * // }\n   * ```\n   *\n   * **Example** (Handling Success or Failure with Either)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * // Run both tasks concurrently, wrapping the result\n   * // in Either to capture success or failure\n   * const program = Effect.race(Effect.either(task1), Effect.either(task2))\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // task2 interrupted\n   * // { _id: 'Either', _tag: 'Left', left: 'task1' }\n   * ```\n   *\n   * @see {@link raceAll} for a version that handles multiple effects.\n   * @see {@link raceFirst} for a version that returns the result of the first effect to complete.\n   *\n   * @since 2.0.0\n   * @category Racing\n   */\n  <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>\n  /**\n   * Races two effects and returns the result of the first successful one.\n   *\n   * **Details**\n   *\n   * This function takes two effects and runs them concurrently. The first effect\n   * that successfully completes will determine the result of the race, and the\n   * other effect will be interrupted.\n   *\n   * If neither effect succeeds, the function will fail with a `Cause`\n   * containing all the errors.\n   *\n   * **When to Use**\n   *\n   * This is useful when you want to run two effects concurrently, but only care\n   * about the first one to succeed. It is commonly used in cases like timeouts,\n   * retries, or when you want to optimize for the faster response without\n   * worrying about the other effect.\n   *\n   * **Handling Success or Failure with Either**\n   *\n   * If you want to handle the result of whichever task completes first, whether\n   * it succeeds or fails, you can use the `Effect.either` function. This function\n   * wraps the result in an `Either` type, allowing you to see if the result\n   * was a success (`Right`) or a failure (`Left`).\n   *\n   * **Example** (Both Tasks Succeed)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * const program = Effect.race(task1, task2)\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // task1 done\n   * // task2 interrupted\n   * ```\n   *\n   * **Example** (One Task Fails, One Succeeds)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * const program = Effect.race(task1, task2)\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // task2 done\n   * ```\n   *\n   * **Example** (Both Tasks Fail)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.fail(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * const program = Effect.race(task1, task2)\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Parallel',\n   * //     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n   * //     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n   * //   }\n   * // }\n   * ```\n   *\n   * **Example** (Handling Success or Failure with Either)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n   * )\n   *\n   * // Run both tasks concurrently, wrapping the result\n   * // in Either to capture success or failure\n   * const program = Effect.race(Effect.either(task1), Effect.either(task2))\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // task2 interrupted\n   * // { _id: 'Either', _tag: 'Left', left: 'task1' }\n   * ```\n   *\n   * @see {@link raceAll} for a version that handles multiple effects.\n   * @see {@link raceFirst} for a version that returns the result of the first effect to complete.\n   *\n   * @since 2.0.0\n   * @category Racing\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>\n} = fiberRuntime.race\n\n/**\n * Races multiple effects and returns the first successful result.\n *\n * **Details**\n *\n * This function runs multiple effects concurrently and returns the result of\n * the first one to succeed. If one effect succeeds, the others will be\n * interrupted.\n *\n * If none of the effects succeed, the function will fail with the last error\n * encountered.\n *\n * **When to Use**\n *\n * This is useful when you want to race multiple effects, but only care about\n * the first one to succeed. It is commonly used in cases like timeouts,\n * retries, or when you want to optimize for the faster response without\n * worrying about the other effects.\n *\n * **Example** (All Tasks Succeed)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.succeed(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * const task3 = Effect.succeed(\"task3\").pipe(\n *   Effect.delay(\"150 millis\"),\n *   Effect.tap(Console.log(\"task3 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n * )\n *\n * const program = Effect.raceAll([task1, task2, task3])\n *\n * Effect.runFork(program)\n * // Output:\n * // task1 done\n * // task2 interrupted\n * // task3 interrupted\n * ```\n *\n * **Example** (One Task Fails, Two Tasks Succeed)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.fail(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * const task3 = Effect.succeed(\"task3\").pipe(\n *   Effect.delay(\"150 millis\"),\n *   Effect.tap(Console.log(\"task3 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n * )\n *\n * const program = Effect.raceAll([task1, task2, task3])\n *\n * Effect.runFork(program)\n * // Output:\n * // task3 done\n * // task2 interrupted\n * ```\n *\n * **Example** (All Tasks Fail)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.fail(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n * )\n * const task2 = Effect.fail(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n * )\n *\n * const task3 = Effect.fail(\"task3\").pipe(\n *   Effect.delay(\"150 millis\"),\n *   Effect.tap(Console.log(\"task3 done\")),\n *   Effect.onInterrupt(() => Console.log(\"task3 interrupted\"))\n * )\n *\n * const program = Effect.raceAll([task1, task2, task3])\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n * // }\n * ```\n *\n * @see {@link race} for a version that handles only two effects.\n *\n * @since 2.0.0\n * @category Racing\n */\nexport const raceAll: <Eff extends Effect<any, any, any>>(\n  all: Iterable<Eff>\n) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>> = fiberRuntime.raceAll\n\n/**\n * Races two effects and returns the result of the first one to complete.\n *\n * **Details**\n *\n * This function takes two effects and runs them concurrently, returning the\n * result of the first one that completes, regardless of whether it succeeds or\n * fails.\n *\n * **When to Use**\n *\n * This function is useful when you want to race two operations, and you want to\n * proceed with whichever one finishes first, regardless of whether it succeeds\n * or fails.\n *\n * **Disconnecting Effects**\n *\n * The `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.\n *\n * If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n *\n * ```ts skip-type-checking\n * Effect.raceFirst(task1, task2)\n * ```\n *\n * You can use:\n *\n * ```ts skip-type-checking\n * Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n * ```\n *\n * This allows both effects to complete independently while still terminating the losing effect in the background.\n *\n * **Example** (Both Tasks Succeed)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.succeed(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n *\n * const program = Effect.raceFirst(task1, task2).pipe(\n *   Effect.tap(Console.log(\"more work...\"))\n * )\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // task1 done\n * // task2 interrupted\n * // more work...\n * // { _id: 'Exit', _tag: 'Success', value: 'task1' }\n * ```\n *\n * **Example** (One Task Fails, One Succeeds)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.fail(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n *\n * const program = Effect.raceFirst(task1, task2).pipe(\n *   Effect.tap(Console.log(\"more work...\"))\n * )\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // task2 interrupted\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n * // }\n * ```\n *\n * **Example** (Using Effect.disconnect for Quicker Return)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.succeed(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n *\n * // Race the two tasks with disconnect to allow quicker return\n * const program = Effect.raceFirst(\n *   Effect.disconnect(task1),\n *   Effect.disconnect(task2)\n * ).pipe(Effect.tap(Console.log(\"more work...\")))\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // task1 done\n * // more work...\n * // { _id: 'Exit', _tag: 'Success', value: 'task1' }\n * // task2 interrupted\n * ```\n *\n * @since 2.0.0\n * @category Racing\n */\nexport const raceFirst: {\n  /**\n   * Races two effects and returns the result of the first one to complete.\n   *\n   * **Details**\n   *\n   * This function takes two effects and runs them concurrently, returning the\n   * result of the first one that completes, regardless of whether it succeeds or\n   * fails.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you want to race two operations, and you want to\n   * proceed with whichever one finishes first, regardless of whether it succeeds\n   * or fails.\n   *\n   * **Disconnecting Effects**\n   *\n   * The `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.\n   *\n   * If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n   *\n   * ```ts skip-type-checking\n   * Effect.raceFirst(task1, task2)\n   * ```\n   *\n   * You can use:\n   *\n   * ```ts skip-type-checking\n   * Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n   * ```\n   *\n   * This allows both effects to complete independently while still terminating the losing effect in the background.\n   *\n   * **Example** (Both Tasks Succeed)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * const program = Effect.raceFirst(task1, task2).pipe(\n   *   Effect.tap(Console.log(\"more work...\"))\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task1 done\n   * // task2 interrupted\n   * // more work...\n   * // { _id: 'Exit', _tag: 'Success', value: 'task1' }\n   * ```\n   *\n   * **Example** (One Task Fails, One Succeeds)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * const program = Effect.raceFirst(task1, task2).pipe(\n   *   Effect.tap(Console.log(\"more work...\"))\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task2 interrupted\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n   * // }\n   * ```\n   *\n   * **Example** (Using Effect.disconnect for Quicker Return)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * // Race the two tasks with disconnect to allow quicker return\n   * const program = Effect.raceFirst(\n   *   Effect.disconnect(task1),\n   *   Effect.disconnect(task2)\n   * ).pipe(Effect.tap(Console.log(\"more work...\")))\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task1 done\n   * // more work...\n   * // { _id: 'Exit', _tag: 'Success', value: 'task1' }\n   * // task2 interrupted\n   * ```\n   *\n   * @since 2.0.0\n   * @category Racing\n   */\n  <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>\n  /**\n   * Races two effects and returns the result of the first one to complete.\n   *\n   * **Details**\n   *\n   * This function takes two effects and runs them concurrently, returning the\n   * result of the first one that completes, regardless of whether it succeeds or\n   * fails.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you want to race two operations, and you want to\n   * proceed with whichever one finishes first, regardless of whether it succeeds\n   * or fails.\n   *\n   * **Disconnecting Effects**\n   *\n   * The `Effect.raceFirst` function safely interrupts the loser effect once the other completes, but it will not resume until the loser is cleanly terminated.\n   *\n   * If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n   *\n   * ```ts skip-type-checking\n   * Effect.raceFirst(task1, task2)\n   * ```\n   *\n   * You can use:\n   *\n   * ```ts skip-type-checking\n   * Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n   * ```\n   *\n   * This allows both effects to complete independently while still terminating the losing effect in the background.\n   *\n   * **Example** (Both Tasks Succeed)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * const program = Effect.raceFirst(task1, task2).pipe(\n   *   Effect.tap(Console.log(\"more work...\"))\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task1 done\n   * // task2 interrupted\n   * // more work...\n   * // { _id: 'Exit', _tag: 'Success', value: 'task1' }\n   * ```\n   *\n   * **Example** (One Task Fails, One Succeeds)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.fail(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * const program = Effect.raceFirst(task1, task2).pipe(\n   *   Effect.tap(Console.log(\"more work...\"))\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task2 interrupted\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n   * // }\n   * ```\n   *\n   * **Example** (Using Effect.disconnect for Quicker Return)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * // Race the two tasks with disconnect to allow quicker return\n   * const program = Effect.raceFirst(\n   *   Effect.disconnect(task1),\n   *   Effect.disconnect(task2)\n   * ).pipe(Effect.tap(Console.log(\"more work...\")))\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task1 done\n   * // more work...\n   * // { _id: 'Exit', _tag: 'Success', value: 'task1' }\n   * // task2 interrupted\n   * ```\n   *\n   * @since 2.0.0\n   * @category Racing\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>\n} = circular.raceFirst\n\n/**\n * Races two effects and calls a finisher when the first one completes.\n *\n * **Details**\n *\n * This function runs two effects concurrently and calls a specified finisher\n * function once one of the effects completes, regardless of whether it succeeds\n * or fails.\n *\n * The finisher functions for each effect allow you to handle the results of\n * each effect as soon as they complete.\n *\n * The function takes two finisher callbacks, one for each effect, and allows\n * you to specify how to handle the result of the race.\n *\n * **When to Use**\n *\n * This function is useful when you need to react to the completion of either\n * effect without waiting for both to finish. It can be used whenever you want\n * to take action based on the first available result.\n *\n * **Example** (Handling Results of Concurrent Tasks)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Effect.succeed(\"task1\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Console.log(\"task1 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n * const task2 = Effect.succeed(\"task2\").pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Console.log(\"task2 done\")),\n *   Effect.onInterrupt(() =>\n *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n *   )\n * )\n *\n * const program = Effect.raceWith(task1, task2, {\n *   onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n *   onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // task1 done\n * // task1 exited with {\n * //   \"_id\": \"Exit\",\n * //   \"_tag\": \"Success\",\n * //   \"value\": \"task1\"\n * // }\n * // task2 interrupted\n * ```\n *\n * @since 2.0.0\n * @category Racing\n */\nexport const raceWith: {\n  /**\n   * Races two effects and calls a finisher when the first one completes.\n   *\n   * **Details**\n   *\n   * This function runs two effects concurrently and calls a specified finisher\n   * function once one of the effects completes, regardless of whether it succeeds\n   * or fails.\n   *\n   * The finisher functions for each effect allow you to handle the results of\n   * each effect as soon as they complete.\n   *\n   * The function takes two finisher callbacks, one for each effect, and allows\n   * you to specify how to handle the result of the race.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you need to react to the completion of either\n   * effect without waiting for both to finish. It can be used whenever you want\n   * to take action based on the first available result.\n   *\n   * **Example** (Handling Results of Concurrent Tasks)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * const program = Effect.raceWith(task1, task2, {\n   *   onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n   *   onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // task1 done\n   * // task1 exited with {\n   * //   \"_id\": \"Exit\",\n   * //   \"_tag\": \"Success\",\n   * //   \"value\": \"task1\"\n   * // }\n   * // task2 interrupted\n   * ```\n   *\n   * @since 2.0.0\n   * @category Racing\n   */\n  <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(\n    other: Effect<A1, E1, R1>,\n    options: {\n      readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>\n      readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>\n  /**\n   * Races two effects and calls a finisher when the first one completes.\n   *\n   * **Details**\n   *\n   * This function runs two effects concurrently and calls a specified finisher\n   * function once one of the effects completes, regardless of whether it succeeds\n   * or fails.\n   *\n   * The finisher functions for each effect allow you to handle the results of\n   * each effect as soon as they complete.\n   *\n   * The function takes two finisher callbacks, one for each effect, and allows\n   * you to specify how to handle the result of the race.\n   *\n   * **When to Use**\n   *\n   * This function is useful when you need to react to the completion of either\n   * effect without waiting for both to finish. It can be used whenever you want\n   * to take action based on the first available result.\n   *\n   * **Example** (Handling Results of Concurrent Tasks)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Effect.succeed(\"task1\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Console.log(\"task1 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   * const task2 = Effect.succeed(\"task2\").pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Console.log(\"task2 done\")),\n   *   Effect.onInterrupt(() =>\n   *     Console.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n   *   )\n   * )\n   *\n   * const program = Effect.raceWith(task1, task2, {\n   *   onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n   *   onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n   * })\n   *\n   * Effect.runFork(program)\n   * // Output:\n   * // task1 done\n   * // task1 exited with {\n   * //   \"_id\": \"Exit\",\n   * //   \"_tag\": \"Success\",\n   * //   \"value\": \"task1\"\n   * // }\n   * // task2 interrupted\n   * ```\n   *\n   * @since 2.0.0\n   * @category Racing\n   */\n  <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(\n    self: Effect<A, E, R>,\n    other: Effect<A1, E1, R1>,\n    options: {\n      readonly onSelfDone: (exit: Exit.Exit<A, E>, fiber: Fiber.Fiber<A1, E1>) => Effect<A2, E2, R2>\n      readonly onOtherDone: (exit: Exit.Exit<A1, E1>, fiber: Fiber.Fiber<A, E>) => Effect<A3, E3, R3>\n    }\n  ): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>\n} = fiberRuntime.raceWith\n\n/**\n * Summarizes a effect by computing some value before and after execution, and\n * then combining the values to produce a summary, together with the result of\n * execution.\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const summarized: {\n  /**\n   * Summarizes a effect by computing some value before and after execution, and\n   * then combining the values to produce a summary, together with the result of\n   * execution.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>\n  /**\n   * Summarizes a effect by computing some value before and after execution, and\n   * then combining the values to produce a summary, together with the result of\n   * execution.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, B, E2, R2, C>(\n    self: Effect<A, E, R>,\n    summary: Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect<[C, A], E2 | E, R2 | R>\n} = effect.summarized\n\n/**\n * Runs a side effect with the result of an effect without changing the original\n * value.\n *\n * **Details**\n *\n * This function works similarly to `flatMap`, but it ignores the result of the\n * function passed to it. The value from the previous effect remains available\n * for the next part of the chain. Note that if the side effect fails, the\n * entire chain will fail too.\n *\n * **When to Use**\n *\n * Use this function when you want to perform a side effect, like logging or\n * tracking, without modifying the main value. This is useful when you need to\n * observe or record an action but want the original value to be passed to the\n * next step.\n *\n * **Example** (Logging a step in a pipeline)\n *\n * ```ts\n * import { Console, Effect, pipe } from \"effect\"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * const finalAmount = pipe(\n *   fetchTransactionAmount,\n *   // Log the fetched transaction amount\n *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n *   // `amount` is still available!\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(finalAmount).then(console.log)\n * // Output:\n * // Apply a discount to: 100\n * // 95\n * ```\n *\n * @see {@link flatMap} for a version that allows you to change the value.\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const tap: {\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, X>(f: (a: NoInfer<A>) => X): <E, R>(\n    self: Effect<A, E, R>\n  ) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R>\n    : Effect<A, E, R>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true }): <E, R>(\n    self: Effect<A, E, R>\n  ) => Effect<A, E | E1, R | R1>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <X>(f: NotFunction<X>): <A, E, R>(\n    self: Effect<A, E, R>\n  ) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R>\n    : Effect<A, E, R>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true }): <A, E, R>(\n    self: Effect<A, E, R>\n  ) => Effect<A, E | E1, R | R1>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R>\n    : Effect<A, E, R>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X, E1, R1>(\n    self: Effect<A, E, R>,\n    f: (a: NoInfer<A>) => Effect<X, E1, R1>,\n    options: { onlyEffect: true }\n  ): Effect<A, E | E1, R | R1>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1>\n    : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R>\n    : Effect<A, E, R>\n  /**\n   * Runs a side effect with the result of an effect without changing the original\n   * value.\n   *\n   * **Details**\n   *\n   * This function works similarly to `flatMap`, but it ignores the result of the\n   * function passed to it. The value from the previous effect remains available\n   * for the next part of the chain. Note that if the side effect fails, the\n   * entire chain will fail too.\n   *\n   * **When to Use**\n   *\n   * Use this function when you want to perform a side effect, like logging or\n   * tracking, without modifying the main value. This is useful when you need to\n   * observe or record an action but want the original value to be passed to the\n   * next step.\n   *\n   * **Example** (Logging a step in a pipeline)\n   *\n   * ```ts\n   * import { Console, Effect, pipe } from \"effect\"\n   *\n   * // Function to apply a discount safely to a transaction amount\n   * const applyDiscount = (\n   *   total: number,\n   *   discountRate: number\n   * ): Effect.Effect<number, Error> =>\n   *   discountRate === 0\n   *     ? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n   *     : Effect.succeed(total - (total * discountRate) / 100)\n   *\n   * // Simulated asynchronous task to fetch a transaction amount from database\n   * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n   *\n   * const finalAmount = pipe(\n   *   fetchTransactionAmount,\n   *   // Log the fetched transaction amount\n   *   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n   *   // `amount` is still available!\n   *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n   * )\n   *\n   * Effect.runPromise(finalAmount).then(console.log)\n   * // Output:\n   * // Apply a discount to: 100\n   * // 95\n   * ```\n   *\n   * @see {@link flatMap} for a version that allows you to change the value.\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true }): Effect<A, E | E1, R | R1>\n} = core.tap\n\n/**\n * Allows you to inspect both success and failure outcomes of an effect and\n * perform side effects for each.\n *\n * **Details**\n *\n * This function enables you to handle both success and failure cases\n * separately, without modifying the main effect's result. It is particularly\n * useful for scenarios where you need to log, monitor, or perform additional\n * actions depending on whether the effect succeeded or failed.\n *\n * When the effect succeeds, the `onSuccess` handler is executed with the\n * success value. When the effect fails, the `onFailure` handler is executed\n * with the failure value. Both handlers can include side effects such as\n * logging or analytics, and neither modifies the original effect's output.\n *\n * If either the success or failure handler fails, the overall effect will also\n * fail.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Random, Console } from \"effect\"\n *\n * // Simulate a task that might fail\n * const task = Effect.filterOrFail(\n *   Random.nextRange(-1, 1),\n *   (n) => n >= 0,\n *   () => \"random number is negative\"\n * )\n *\n * // Use tapBoth to log both success and failure outcomes\n * const tapping = Effect.tapBoth(task, {\n *   onFailure: (error) => Console.log(`failure: ${error}`),\n *   onSuccess: (randomNumber) =>\n *     Console.log(`random number: ${randomNumber}`)\n * })\n *\n * Effect.runFork(tapping)\n * // Example Output:\n * // failure: random number is negative\n * ```\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const tapBoth: {\n  /**\n   * Allows you to inspect both success and failure outcomes of an effect and\n   * perform side effects for each.\n   *\n   * **Details**\n   *\n   * This function enables you to handle both success and failure cases\n   * separately, without modifying the main effect's result. It is particularly\n   * useful for scenarios where you need to log, monitor, or perform additional\n   * actions depending on whether the effect succeeded or failed.\n   *\n   * When the effect succeeds, the `onSuccess` handler is executed with the\n   * success value. When the effect fails, the `onFailure` handler is executed\n   * with the failure value. Both handlers can include side effects such as\n   * logging or analytics, and neither modifies the original effect's output.\n   *\n   * If either the success or failure handler fails, the overall effect will also\n   * fail.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Random, Console } from \"effect\"\n   *\n   * // Simulate a task that might fail\n   * const task = Effect.filterOrFail(\n   *   Random.nextRange(-1, 1),\n   *   (n) => n >= 0,\n   *   () => \"random number is negative\"\n   * )\n   *\n   * // Use tapBoth to log both success and failure outcomes\n   * const tapping = Effect.tapBoth(task, {\n   *   onFailure: (error) => Console.log(`failure: ${error}`),\n   *   onSuccess: (randomNumber) =>\n   *     Console.log(`random number: ${randomNumber}`)\n   * })\n   *\n   * Effect.runFork(tapping)\n   * // Example Output:\n   * // failure: random number is negative\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, X, E2, R2, A, X1, E3, R3>(\n    options: {\n      readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>\n      readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>\n    }\n  ): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>\n  /**\n   * Allows you to inspect both success and failure outcomes of an effect and\n   * perform side effects for each.\n   *\n   * **Details**\n   *\n   * This function enables you to handle both success and failure cases\n   * separately, without modifying the main effect's result. It is particularly\n   * useful for scenarios where you need to log, monitor, or perform additional\n   * actions depending on whether the effect succeeded or failed.\n   *\n   * When the effect succeeds, the `onSuccess` handler is executed with the\n   * success value. When the effect fails, the `onFailure` handler is executed\n   * with the failure value. Both handlers can include side effects such as\n   * logging or analytics, and neither modifies the original effect's output.\n   *\n   * If either the success or failure handler fails, the overall effect will also\n   * fail.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Random, Console } from \"effect\"\n   *\n   * // Simulate a task that might fail\n   * const task = Effect.filterOrFail(\n   *   Random.nextRange(-1, 1),\n   *   (n) => n >= 0,\n   *   () => \"random number is negative\"\n   * )\n   *\n   * // Use tapBoth to log both success and failure outcomes\n   * const tapping = Effect.tapBoth(task, {\n   *   onFailure: (error) => Console.log(`failure: ${error}`),\n   *   onSuccess: (randomNumber) =>\n   *     Console.log(`random number: ${randomNumber}`)\n   * })\n   *\n   * Effect.runFork(tapping)\n   * // Example Output:\n   * // failure: random number is negative\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X, E2, R2, X1, E3, R3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect<X, E2, R2>\n      readonly onSuccess: (a: A) => Effect<X1, E3, R3>\n    }\n  ): Effect<A, E | E2 | E3, R | R2 | R3>\n} = effect.tapBoth\n\n/**\n * Inspect severe errors or defects (non-recoverable failures) in an effect.\n *\n * **Details**\n *\n * This function is specifically designed to handle and inspect defects, which\n * are critical failures in your program, such as unexpected runtime exceptions\n * or system-level errors. Unlike normal recoverable errors, defects typically\n * indicate serious issues that cannot be addressed through standard error\n * handling.\n *\n * When a defect occurs in an effect, the function you provide to this function\n * will be executed, allowing you to log, monitor, or handle the defect in some\n * way. Importantly, this does not alter the main result of the effect. If no\n * defect occurs, the effect behaves as if this function was not used.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * // Simulate a task that fails with a recoverable error\n * const task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n *\n * // tapDefect won't log anything because NetworkError is not a defect\n * const tapping1 = Effect.tapDefect(task1, (cause) =>\n *   Console.log(`defect: ${cause}`)\n * )\n *\n * Effect.runFork(tapping1)\n * // No Output\n *\n * // Simulate a severe failure in the system\n * const task2: Effect.Effect<number, string> = Effect.dieMessage(\n *   \"Something went wrong\"\n * )\n *\n * // Log the defect using tapDefect\n * const tapping2 = Effect.tapDefect(task2, (cause) =>\n *   Console.log(`defect: ${cause}`)\n * )\n *\n * Effect.runFork(tapping2)\n * // Output:\n * // defect: RuntimeException: Something went wrong\n * //   ... stack trace ...\n * ```\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const tapDefect: {\n  /**\n   * Inspect severe errors or defects (non-recoverable failures) in an effect.\n   *\n   * **Details**\n   *\n   * This function is specifically designed to handle and inspect defects, which\n   * are critical failures in your program, such as unexpected runtime exceptions\n   * or system-level errors. Unlike normal recoverable errors, defects typically\n   * indicate serious issues that cannot be addressed through standard error\n   * handling.\n   *\n   * When a defect occurs in an effect, the function you provide to this function\n   * will be executed, allowing you to log, monitor, or handle the defect in some\n   * way. Importantly, this does not alter the main result of the effect. If no\n   * defect occurs, the effect behaves as if this function was not used.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Simulate a task that fails with a recoverable error\n   * const task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n   *\n   * // tapDefect won't log anything because NetworkError is not a defect\n   * const tapping1 = Effect.tapDefect(task1, (cause) =>\n   *   Console.log(`defect: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping1)\n   * // No Output\n   *\n   * // Simulate a severe failure in the system\n   * const task2: Effect.Effect<number, string> = Effect.dieMessage(\n   *   \"Something went wrong\"\n   * )\n   *\n   * // Log the defect using tapDefect\n   * const tapping2 = Effect.tapDefect(task2, (cause) =>\n   *   Console.log(`defect: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping2)\n   * // Output:\n   * // defect: RuntimeException: Something went wrong\n   * //   ... stack trace ...\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <X, E2, R2>(f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>\n  /**\n   * Inspect severe errors or defects (non-recoverable failures) in an effect.\n   *\n   * **Details**\n   *\n   * This function is specifically designed to handle and inspect defects, which\n   * are critical failures in your program, such as unexpected runtime exceptions\n   * or system-level errors. Unlike normal recoverable errors, defects typically\n   * indicate serious issues that cannot be addressed through standard error\n   * handling.\n   *\n   * When a defect occurs in an effect, the function you provide to this function\n   * will be executed, allowing you to log, monitor, or handle the defect in some\n   * way. Importantly, this does not alter the main result of the effect. If no\n   * defect occurs, the effect behaves as if this function was not used.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Simulate a task that fails with a recoverable error\n   * const task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n   *\n   * // tapDefect won't log anything because NetworkError is not a defect\n   * const tapping1 = Effect.tapDefect(task1, (cause) =>\n   *   Console.log(`defect: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping1)\n   * // No Output\n   *\n   * // Simulate a severe failure in the system\n   * const task2: Effect.Effect<number, string> = Effect.dieMessage(\n   *   \"Something went wrong\"\n   * )\n   *\n   * // Log the defect using tapDefect\n   * const tapping2 = Effect.tapDefect(task2, (cause) =>\n   *   Console.log(`defect: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping2)\n   * // Output:\n   * // defect: RuntimeException: Something went wrong\n   * //   ... stack trace ...\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>\n} = effect.tapDefect\n\n/**\n * Execute a side effect on failure without modifying the original effect.\n *\n * **Details**\n *\n * This function allows you to inspect and react to the failure of an effect by\n * executing an additional effect. The failure value is passed to the provided\n * function, enabling you to log it, track it, or perform any other operation.\n * Importantly, the original failure remains intact and is re-propagated, so the\n * effect's behavior is unchanged.\n *\n * The side effect you provide is only executed when the effect fails. If the\n * effect succeeds, the function is ignored, and the success value is propagated\n * as usual.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * // Simulate a task that fails with an error\n * const task: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n *\n * // Use tapError to log the error message when the task fails\n * const tapping = Effect.tapError(task, (error) =>\n *   Console.log(`expected error: ${error}`)\n * )\n *\n * Effect.runFork(tapping)\n * // Output:\n * // expected error: NetworkError\n * ```\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const tapError: {\n  /**\n   * Execute a side effect on failure without modifying the original effect.\n   *\n   * **Details**\n   *\n   * This function allows you to inspect and react to the failure of an effect by\n   * executing an additional effect. The failure value is passed to the provided\n   * function, enabling you to log it, track it, or perform any other operation.\n   * Importantly, the original failure remains intact and is re-propagated, so the\n   * effect's behavior is unchanged.\n   *\n   * The side effect you provide is only executed when the effect fails. If the\n   * effect succeeds, the function is ignored, and the success value is propagated\n   * as usual.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Simulate a task that fails with an error\n   * const task: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n   *\n   * // Use tapError to log the error message when the task fails\n   * const tapping = Effect.tapError(task, (error) =>\n   *   Console.log(`expected error: ${error}`)\n   * )\n   *\n   * Effect.runFork(tapping)\n   * // Output:\n   * // expected error: NetworkError\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>\n  /**\n   * Execute a side effect on failure without modifying the original effect.\n   *\n   * **Details**\n   *\n   * This function allows you to inspect and react to the failure of an effect by\n   * executing an additional effect. The failure value is passed to the provided\n   * function, enabling you to log it, track it, or perform any other operation.\n   * Importantly, the original failure remains intact and is re-propagated, so the\n   * effect's behavior is unchanged.\n   *\n   * The side effect you provide is only executed when the effect fails. If the\n   * effect succeeds, the function is ignored, and the success value is propagated\n   * as usual.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Simulate a task that fails with an error\n   * const task: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n   *\n   * // Use tapError to log the error message when the task fails\n   * const tapping = Effect.tapError(task, (error) =>\n   *   Console.log(`expected error: ${error}`)\n   * )\n   *\n   * Effect.runFork(tapping)\n   * // Output:\n   * // expected error: NetworkError\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>\n} = effect.tapError\n\n/**\n * Inspect errors matching a specific tag without altering the original effect.\n *\n * **Details**\n *\n * This function allows you to inspect and handle specific error types based on\n * their `_tag` property. It is particularly useful in applications where errors\n * are modeled with tagged types (e.g., union types with discriminating tags).\n * By targeting errors with a specific `_tag`, you can log or perform actions on\n * them while leaving the error channel and overall effect unchanged.\n *\n * If the error doesn't match the specified tag, this function does nothing, and\n * the effect proceeds as usual.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * class NetworkError {\n *   readonly _tag = \"NetworkError\"\n *   constructor(readonly statusCode: number) {}\n * }\n *\n * class ValidationError {\n *   readonly _tag = \"ValidationError\"\n *   constructor(readonly field: string) {}\n * }\n *\n * // Create a task that fails with a NetworkError\n * const task: Effect.Effect<number, NetworkError | ValidationError> =\n *   Effect.fail(new NetworkError(504))\n *\n * // Use tapErrorTag to inspect only NetworkError types and log the status code\n * const tapping = Effect.tapErrorTag(task, \"NetworkError\", (error) =>\n *   Console.log(`expected error: ${error.statusCode}`)\n * )\n *\n * Effect.runFork(tapping)\n * // Output:\n * // expected error: 504\n * ```\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const tapErrorTag: {\n  /**\n   * Inspect errors matching a specific tag without altering the original effect.\n   *\n   * **Details**\n   *\n   * This function allows you to inspect and handle specific error types based on\n   * their `_tag` property. It is particularly useful in applications where errors\n   * are modeled with tagged types (e.g., union types with discriminating tags).\n   * By targeting errors with a specific `_tag`, you can log or perform actions on\n   * them while leaving the error channel and overall effect unchanged.\n   *\n   * If the error doesn't match the specified tag, this function does nothing, and\n   * the effect proceeds as usual.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * class NetworkError {\n   *   readonly _tag = \"NetworkError\"\n   *   constructor(readonly statusCode: number) {}\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   *   constructor(readonly field: string) {}\n   * }\n   *\n   * // Create a task that fails with a NetworkError\n   * const task: Effect.Effect<number, NetworkError | ValidationError> =\n   *   Effect.fail(new NetworkError(504))\n   *\n   * // Use tapErrorTag to inspect only NetworkError types and log the status code\n   * const tapping = Effect.tapErrorTag(task, \"NetworkError\", (error) =>\n   *   Console.log(`expected error: ${error.statusCode}`)\n   * )\n   *\n   * Effect.runFork(tapping)\n   * // Output:\n   * // expected error: 504\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>\n  /**\n   * Inspect errors matching a specific tag without altering the original effect.\n   *\n   * **Details**\n   *\n   * This function allows you to inspect and handle specific error types based on\n   * their `_tag` property. It is particularly useful in applications where errors\n   * are modeled with tagged types (e.g., union types with discriminating tags).\n   * By targeting errors with a specific `_tag`, you can log or perform actions on\n   * them while leaving the error channel and overall effect unchanged.\n   *\n   * If the error doesn't match the specified tag, this function does nothing, and\n   * the effect proceeds as usual.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * class NetworkError {\n   *   readonly _tag = \"NetworkError\"\n   *   constructor(readonly statusCode: number) {}\n   * }\n   *\n   * class ValidationError {\n   *   readonly _tag = \"ValidationError\"\n   *   constructor(readonly field: string) {}\n   * }\n   *\n   * // Create a task that fails with a NetworkError\n   * const task: Effect.Effect<number, NetworkError | ValidationError> =\n   *   Effect.fail(new NetworkError(504))\n   *\n   * // Use tapErrorTag to inspect only NetworkError types and log the status code\n   * const tapping = Effect.tapErrorTag(task, \"NetworkError\", (error) =>\n   *   Console.log(`expected error: ${error.statusCode}`)\n   * )\n   *\n   * Effect.runFork(tapping)\n   * // Output:\n   * // expected error: 504\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, K extends E extends { _tag: string } ? E[\"_tag\"] : never, A1, E1, R1>(\n    self: Effect<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect<A1, E1, R1>\n  ): Effect<A, E | E1, R | R1>\n} = effect.tapErrorTag\n\n/**\n * Inspect the complete cause of an error, including failures and defects.\n *\n * **Details**\n *\n * This function provides access to the full cause of an error, including both\n * recoverable failures and irrecoverable defects. It allows you to handle, log,\n * or monitor specific error causes without modifying the result of the effect.\n * The full `Cause` object encapsulates the error and its contextual\n * information, making it useful for debugging and understanding failure\n * scenarios in complex workflows.\n *\n * The effect itself is not modified, and any errors or defects remain in the\n * error channel of the original effect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * // Create a task that fails with a NetworkError\n * const task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n *\n * const tapping1 = Effect.tapErrorCause(task1, (cause) =>\n *   Console.log(`error cause: ${cause}`)\n * )\n *\n * Effect.runFork(tapping1)\n * // Output:\n * // error cause: Error: NetworkError\n *\n * // Simulate a severe failure in the system\n * const task2: Effect.Effect<number, string> = Effect.dieMessage(\n *   \"Something went wrong\"\n * )\n *\n * const tapping2 = Effect.tapErrorCause(task2, (cause) =>\n *   Console.log(`error cause: ${cause}`)\n * )\n *\n * Effect.runFork(tapping2)\n * // Output:\n * // error cause: RuntimeException: Something went wrong\n * //   ... stack trace ...\n * ```\n *\n * @since 2.0.0\n * @category Sequencing\n */\nexport const tapErrorCause: {\n  /**\n   * Inspect the complete cause of an error, including failures and defects.\n   *\n   * **Details**\n   *\n   * This function provides access to the full cause of an error, including both\n   * recoverable failures and irrecoverable defects. It allows you to handle, log,\n   * or monitor specific error causes without modifying the result of the effect.\n   * The full `Cause` object encapsulates the error and its contextual\n   * information, making it useful for debugging and understanding failure\n   * scenarios in complex workflows.\n   *\n   * The effect itself is not modified, and any errors or defects remain in the\n   * error channel of the original effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Create a task that fails with a NetworkError\n   * const task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n   *\n   * const tapping1 = Effect.tapErrorCause(task1, (cause) =>\n   *   Console.log(`error cause: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping1)\n   * // Output:\n   * // error cause: Error: NetworkError\n   *\n   * // Simulate a severe failure in the system\n   * const task2: Effect.Effect<number, string> = Effect.dieMessage(\n   *   \"Something went wrong\"\n   * )\n   *\n   * const tapping2 = Effect.tapErrorCause(task2, (cause) =>\n   *   Console.log(`error cause: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping2)\n   * // Output:\n   * // error cause: RuntimeException: Something went wrong\n   * //   ... stack trace ...\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>\n  /**\n   * Inspect the complete cause of an error, including failures and defects.\n   *\n   * **Details**\n   *\n   * This function provides access to the full cause of an error, including both\n   * recoverable failures and irrecoverable defects. It allows you to handle, log,\n   * or monitor specific error causes without modifying the result of the effect.\n   * The full `Cause` object encapsulates the error and its contextual\n   * information, making it useful for debugging and understanding failure\n   * scenarios in complex workflows.\n   *\n   * The effect itself is not modified, and any errors or defects remain in the\n   * error channel of the original effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * // Create a task that fails with a NetworkError\n   * const task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n   *\n   * const tapping1 = Effect.tapErrorCause(task1, (cause) =>\n   *   Console.log(`error cause: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping1)\n   * // Output:\n   * // error cause: Error: NetworkError\n   *\n   * // Simulate a severe failure in the system\n   * const task2: Effect.Effect<number, string> = Effect.dieMessage(\n   *   \"Something went wrong\"\n   * )\n   *\n   * const tapping2 = Effect.tapErrorCause(task2, (cause) =>\n   *   Console.log(`error cause: ${cause}`)\n   * )\n   *\n   * Effect.runFork(tapping2)\n   * // Output:\n   * // error cause: RuntimeException: Something went wrong\n   * //   ... stack trace ...\n   * ```\n   *\n   * @since 2.0.0\n   * @category Sequencing\n   */\n  <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>\n} = effect.tapErrorCause\n\n/**\n * Repeats an effect indefinitely until an error occurs.\n *\n * **Details**\n *\n * This function executes an effect repeatedly in an infinite loop. Each\n * iteration is executed sequentially, and the loop continues until the first\n * error occurs. If the effect succeeds, it starts over from the beginning. If\n * the effect fails, the error is propagated, and the loop stops.\n *\n * Be cautious when using this function, as it will run indefinitely unless an\n * error interrupts it. This makes it suitable for long-running processes or\n * continuous polling tasks, but you should ensure proper error handling or\n * combine it with other operators like `timeout` or `schedule` to prevent\n * unintentional infinite loops.\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R> = effect.forever\n\n/**\n * Repeatedly updates a state through an effectful operation until a condition\n * is no longer met.\n *\n * **Details**\n *\n * This function provides a way to implement effectful loops, similar to a\n * `while` loop in JavaScript.\n *\n * ```ts skip-type-checking\n * let result = initial\n *\n * while (options.while(result)) {\n *   result = options.body(result)\n * }\n *\n * return result\n * ```\n *\n * It starts with an initial state, checks a\n * condition (`while`), and executes a body operation to update the state if the\n * condition evaluates to `true`. The process repeats until the condition\n * returns `false`.\n *\n * The state is passed between iterations, allowing the body operation to modify\n * it dynamically. The final state after the loop ends is returned as the result\n * of the effect.\n *\n * **When to Use**\n *\n * This is particularly useful for scenarios where looping logic involves\n * asynchronous or side-effectful operations, such as polling or iterative\n * computations that depend on external factors.\n *\n * **Example** (Effectful Iteration)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const result = Effect.iterate(\n *   // Initial result\n *   1,\n *   {\n *     // Condition to continue iterating\n *     while: (result) => result <= 5,\n *     // Operation to change the result\n *     body: (result) => Effect.succeed(result + 1)\n *   }\n * )\n *\n * Effect.runPromise(result).then(console.log)\n * // Output: 6\n * ```\n *\n * @since 2.0.0\n * @category Looping\n */\nexport const iterate: {\n  /**\n   * Repeatedly updates a state through an effectful operation until a condition\n   * is no longer met.\n   *\n   * **Details**\n   *\n   * This function provides a way to implement effectful loops, similar to a\n   * `while` loop in JavaScript.\n   *\n   * ```ts skip-type-checking\n   * let result = initial\n   *\n   * while (options.while(result)) {\n   *   result = options.body(result)\n   * }\n   *\n   * return result\n   * ```\n   *\n   * It starts with an initial state, checks a\n   * condition (`while`), and executes a body operation to update the state if the\n   * condition evaluates to `true`. The process repeats until the condition\n   * returns `false`.\n   *\n   * The state is passed between iterations, allowing the body operation to modify\n   * it dynamically. The final state after the loop ends is returned as the result\n   * of the effect.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful for scenarios where looping logic involves\n   * asynchronous or side-effectful operations, such as polling or iterative\n   * computations that depend on external factors.\n   *\n   * **Example** (Effectful Iteration)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const result = Effect.iterate(\n   *   // Initial result\n   *   1,\n   *   {\n   *     // Condition to continue iterating\n   *     while: (result) => result <= 5,\n   *     // Operation to change the result\n   *     body: (result) => Effect.succeed(result + 1)\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output: 6\n   * ```\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, B extends A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Refinement<A, B>\n      readonly body: (b: B) => Effect<A, E, R>\n    }\n  ): Effect<A, E, R>\n  /**\n   * Repeatedly updates a state through an effectful operation until a condition\n   * is no longer met.\n   *\n   * **Details**\n   *\n   * This function provides a way to implement effectful loops, similar to a\n   * `while` loop in JavaScript.\n   *\n   * ```ts skip-type-checking\n   * let result = initial\n   *\n   * while (options.while(result)) {\n   *   result = options.body(result)\n   * }\n   *\n   * return result\n   * ```\n   *\n   * It starts with an initial state, checks a\n   * condition (`while`), and executes a body operation to update the state if the\n   * condition evaluates to `true`. The process repeats until the condition\n   * returns `false`.\n   *\n   * The state is passed between iterations, allowing the body operation to modify\n   * it dynamically. The final state after the loop ends is returned as the result\n   * of the effect.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful for scenarios where looping logic involves\n   * asynchronous or side-effectful operations, such as polling or iterative\n   * computations that depend on external factors.\n   *\n   * **Example** (Effectful Iteration)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const result = Effect.iterate(\n   *   // Initial result\n   *   1,\n   *   {\n   *     // Condition to continue iterating\n   *     while: (result) => result <= 5,\n   *     // Operation to change the result\n   *     body: (result) => Effect.succeed(result + 1)\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output: 6\n   * ```\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate<A>\n      readonly body: (a: A) => Effect<A, E, R>\n    }\n  ): Effect<A, E, R>\n} = effect.iterate\n\n/**\n * Repeatedly executes a loop with a state, collecting results or discarding\n * them based on configuration.\n *\n * **Details**\n *\n * This function performs an effectful loop, starting with an initial state and\n * iterating as long as the `while` condition evaluates to `true`, similar to a\n * `while` loop in JavaScript.\n *\n * ```ts skip-type-checking\n * let state = initial\n * const result = []\n *\n * while (options.while(state)) {\n *   result.push(options.body(state)) // Perform the effectful operation\n *   state = options.step(state) // Update the state\n * }\n *\n * return result\n * ```\n *\n * During each iteration, the `step` function updates the state, and the `body`\n * effect is executed.\n *\n * The results of the body effect can be collected in an array or discarded\n * based on the `discard` option.\n *\n * **Discarding Intermediate Results**\n *\n * - If `discard` is `false` or not provided, the intermediate results are\n *   collected into an array and returned as the final result.\n * - If `discard` is `true`, the intermediate results are ignored, and the\n *   effect returns `void`.\n *\n * **When to Use**\n *\n * This is useful for implementing loops where you need to perform effectful\n * computations repeatedly, such as processing items in a list, generating\n * values, or performing iterative updates.\n *\n * **Example** (Looping with Collected Results)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // A loop that runs 5 times, collecting each iteration's result\n * const result = Effect.loop(\n *   // Initial state\n *   1,\n *   {\n *     // Condition to continue looping\n *     while: (state) => state <= 5,\n *     // State update function\n *     step: (state) => state + 1,\n *     // Effect to be performed on each iteration\n *     body: (state) => Effect.succeed(state)\n *   }\n * )\n *\n * Effect.runPromise(result).then(console.log)\n * // Output: [1, 2, 3, 4, 5]\n * ```\n *\n * **Example** (Loop with Discarded Results)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const result = Effect.loop(\n *   // Initial state\n *   1,\n *   {\n *     // Condition to continue looping\n *     while: (state) => state <= 5,\n *     // State update function\n *     step: (state) => state + 1,\n *     // Effect to be performed on each iteration\n *     body: (state) => Console.log(`Currently at state ${state}`),\n *     // Discard intermediate results\n *     discard: true\n *   }\n * )\n *\n * Effect.runPromise(result).then(console.log)\n * // Output:\n * // Currently at state 1\n * // Currently at state 2\n * // Currently at state 3\n * // Currently at state 4\n * // Currently at state 5\n * // undefined\n * ```\n *\n * @since 2.0.0\n * @category Looping\n */\nexport const loop: {\n  /**\n   * Repeatedly executes a loop with a state, collecting results or discarding\n   * them based on configuration.\n   *\n   * **Details**\n   *\n   * This function performs an effectful loop, starting with an initial state and\n   * iterating as long as the `while` condition evaluates to `true`, similar to a\n   * `while` loop in JavaScript.\n   *\n   * ```ts skip-type-checking\n   * let state = initial\n   * const result = []\n   *\n   * while (options.while(state)) {\n   *   result.push(options.body(state)) // Perform the effectful operation\n   *   state = options.step(state) // Update the state\n   * }\n   *\n   * return result\n   * ```\n   *\n   * During each iteration, the `step` function updates the state, and the `body`\n   * effect is executed.\n   *\n   * The results of the body effect can be collected in an array or discarded\n   * based on the `discard` option.\n   *\n   * **Discarding Intermediate Results**\n   *\n   * - If `discard` is `false` or not provided, the intermediate results are\n   *   collected into an array and returned as the final result.\n   * - If `discard` is `true`, the intermediate results are ignored, and the\n   *   effect returns `void`.\n   *\n   * **When to Use**\n   *\n   * This is useful for implementing loops where you need to perform effectful\n   * computations repeatedly, such as processing items in a list, generating\n   * values, or performing iterative updates.\n   *\n   * **Example** (Looping with Collected Results)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // A loop that runs 5 times, collecting each iteration's result\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Effect.succeed(state)\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output: [1, 2, 3, 4, 5]\n   * ```\n   *\n   * **Example** (Loop with Discarded Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Console.log(`Currently at state ${state}`),\n   *     // Discard intermediate results\n   *     discard: true\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at state 1\n   * // Currently at state 2\n   * // Currently at state 3\n   * // Currently at state 4\n   * // Currently at state 5\n   * // undefined\n   * ```\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect<Array<C>, E, R>\n  /**\n   * Repeatedly executes a loop with a state, collecting results or discarding\n   * them based on configuration.\n   *\n   * **Details**\n   *\n   * This function performs an effectful loop, starting with an initial state and\n   * iterating as long as the `while` condition evaluates to `true`, similar to a\n   * `while` loop in JavaScript.\n   *\n   * ```ts skip-type-checking\n   * let state = initial\n   * const result = []\n   *\n   * while (options.while(state)) {\n   *   result.push(options.body(state)) // Perform the effectful operation\n   *   state = options.step(state) // Update the state\n   * }\n   *\n   * return result\n   * ```\n   *\n   * During each iteration, the `step` function updates the state, and the `body`\n   * effect is executed.\n   *\n   * The results of the body effect can be collected in an array or discarded\n   * based on the `discard` option.\n   *\n   * **Discarding Intermediate Results**\n   *\n   * - If `discard` is `false` or not provided, the intermediate results are\n   *   collected into an array and returned as the final result.\n   * - If `discard` is `true`, the intermediate results are ignored, and the\n   *   effect returns `void`.\n   *\n   * **When to Use**\n   *\n   * This is useful for implementing loops where you need to perform effectful\n   * computations repeatedly, such as processing items in a list, generating\n   * values, or performing iterative updates.\n   *\n   * **Example** (Looping with Collected Results)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // A loop that runs 5 times, collecting each iteration's result\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Effect.succeed(state)\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output: [1, 2, 3, 4, 5]\n   * ```\n   *\n   * **Example** (Loop with Discarded Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Console.log(`Currently at state ${state}`),\n   *     // Discard intermediate results\n   *     discard: true\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at state 1\n   * // Currently at state 2\n   * // Currently at state 3\n   * // Currently at state 4\n   * // Currently at state 5\n   * // undefined\n   * ```\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect<Array<C>, E, R>\n  /**\n   * Repeatedly executes a loop with a state, collecting results or discarding\n   * them based on configuration.\n   *\n   * **Details**\n   *\n   * This function performs an effectful loop, starting with an initial state and\n   * iterating as long as the `while` condition evaluates to `true`, similar to a\n   * `while` loop in JavaScript.\n   *\n   * ```ts skip-type-checking\n   * let state = initial\n   * const result = []\n   *\n   * while (options.while(state)) {\n   *   result.push(options.body(state)) // Perform the effectful operation\n   *   state = options.step(state) // Update the state\n   * }\n   *\n   * return result\n   * ```\n   *\n   * During each iteration, the `step` function updates the state, and the `body`\n   * effect is executed.\n   *\n   * The results of the body effect can be collected in an array or discarded\n   * based on the `discard` option.\n   *\n   * **Discarding Intermediate Results**\n   *\n   * - If `discard` is `false` or not provided, the intermediate results are\n   *   collected into an array and returned as the final result.\n   * - If `discard` is `true`, the intermediate results are ignored, and the\n   *   effect returns `void`.\n   *\n   * **When to Use**\n   *\n   * This is useful for implementing loops where you need to perform effectful\n   * computations repeatedly, such as processing items in a list, generating\n   * values, or performing iterative updates.\n   *\n   * **Example** (Looping with Collected Results)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // A loop that runs 5 times, collecting each iteration's result\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Effect.succeed(state)\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output: [1, 2, 3, 4, 5]\n   * ```\n   *\n   * **Example** (Loop with Discarded Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Console.log(`Currently at state ${state}`),\n   *     // Discard intermediate results\n   *     discard: true\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at state 1\n   * // Currently at state 2\n   * // Currently at state 3\n   * // Currently at state 4\n   * // Currently at state 5\n   * // undefined\n   * ```\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect<C, E, R>\n      readonly discard: true\n    }\n  ): Effect<void, E, R>\n  /**\n   * Repeatedly executes a loop with a state, collecting results or discarding\n   * them based on configuration.\n   *\n   * **Details**\n   *\n   * This function performs an effectful loop, starting with an initial state and\n   * iterating as long as the `while` condition evaluates to `true`, similar to a\n   * `while` loop in JavaScript.\n   *\n   * ```ts skip-type-checking\n   * let state = initial\n   * const result = []\n   *\n   * while (options.while(state)) {\n   *   result.push(options.body(state)) // Perform the effectful operation\n   *   state = options.step(state) // Update the state\n   * }\n   *\n   * return result\n   * ```\n   *\n   * During each iteration, the `step` function updates the state, and the `body`\n   * effect is executed.\n   *\n   * The results of the body effect can be collected in an array or discarded\n   * based on the `discard` option.\n   *\n   * **Discarding Intermediate Results**\n   *\n   * - If `discard` is `false` or not provided, the intermediate results are\n   *   collected into an array and returned as the final result.\n   * - If `discard` is `true`, the intermediate results are ignored, and the\n   *   effect returns `void`.\n   *\n   * **When to Use**\n   *\n   * This is useful for implementing loops where you need to perform effectful\n   * computations repeatedly, such as processing items in a list, generating\n   * values, or performing iterative updates.\n   *\n   * **Example** (Looping with Collected Results)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * // A loop that runs 5 times, collecting each iteration's result\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Effect.succeed(state)\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output: [1, 2, 3, 4, 5]\n   * ```\n   *\n   * **Example** (Loop with Discarded Results)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const result = Effect.loop(\n   *   // Initial state\n   *   1,\n   *   {\n   *     // Condition to continue looping\n   *     while: (state) => state <= 5,\n   *     // State update function\n   *     step: (state) => state + 1,\n   *     // Effect to be performed on each iteration\n   *     body: (state) => Console.log(`Currently at state ${state}`),\n   *     // Discard intermediate results\n   *     discard: true\n   *   }\n   * )\n   *\n   * Effect.runPromise(result).then(console.log)\n   * // Output:\n   * // Currently at state 1\n   * // Currently at state 2\n   * // Currently at state 3\n   * // Currently at state 4\n   * // Currently at state 5\n   * // undefined\n   * ```\n   *\n   * @since 2.0.0\n   * @category Looping\n   */\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect<C, E, R>\n      readonly discard: true\n    }\n  ): Effect<void, E, R>\n} = effect.loop\n\n/**\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport declare namespace Repeat {\n  /**\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  export type Return<R, E, A, O extends NoExcessProperties<Options<A>, O>> = Effect<\n    (O extends { schedule: Schedule.Schedule<infer Out, infer _I, infer _R> } ? Out\n      : O extends { until: Refinement<A, infer B> } ? B\n      : A),\n    | E\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer E, infer _R> } ? E : never),\n    | R\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R> } ? R : never)\n    | (O extends { while: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n    | (O extends { until: (...args: Array<any>) => Effect<infer _A, infer _E, infer R> } ? R : never)\n  > extends infer Z ? Z : never\n\n  /**\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  export interface Options<A> {\n    while?: ((_: A) => boolean | Effect<boolean, any, any>) | undefined\n    until?: ((_: A) => boolean | Effect<boolean, any, any>) | undefined\n    times?: number | undefined\n    schedule?: Schedule.Schedule<any, A, any> | undefined\n  }\n}\n\n/**\n * Repeats an effect based on a specified schedule or until the first failure.\n *\n * **Details**\n *\n * This function executes an effect repeatedly according to the given schedule.\n * Each repetition occurs after the initial execution of the effect, meaning\n * that the schedule determines the number of additional repetitions. For\n * example, using `Schedule.once` will result in the effect being executed twice\n * (once initially and once as part of the repetition).\n *\n * If the effect succeeds, it is repeated according to the schedule. If it\n * fails, the repetition stops immediately, and the failure is returned.\n *\n * The schedule can also specify delays between repetitions, making it useful\n * for tasks like retrying operations with backoff, periodic execution, or\n * performing a series of dependent actions.\n *\n * You can combine schedules for more advanced repetition logic, such as adding\n * delays, limiting recursions, or dynamically adjusting based on the outcome of\n * each execution.\n *\n * **Example** (Success Example)\n *\n * ```ts\n * import { Effect, Schedule, Console } from \"effect\"\n *\n * const action = Console.log(\"success\")\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n * const program = Effect.repeat(action, policy)\n *\n * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n * ```\n *\n * **Example** (Failure Example)\n *\n * ```ts\n * import { Effect, Schedule } from \"effect\"\n *\n * let count = 0\n *\n * // Define an async effect that simulates an action with possible failures\n * const action = Effect.async<string, string>((resume) => {\n *   if (count > 1) {\n *     console.log(\"failure\")\n *     resume(Effect.fail(\"Uh oh!\"))\n *   } else {\n *     count++\n *     console.log(\"success\")\n *     resume(Effect.succeed(\"yay!\"))\n *   }\n * })\n *\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n * const program = Effect.repeat(action, policy)\n *\n * Effect.runPromiseExit(program).then(console.log)\n * ```\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const repeat: {\n  /**\n   * Repeats an effect based on a specified schedule or until the first failure.\n   *\n   * **Details**\n   *\n   * This function executes an effect repeatedly according to the given schedule.\n   * Each repetition occurs after the initial execution of the effect, meaning\n   * that the schedule determines the number of additional repetitions. For\n   * example, using `Schedule.once` will result in the effect being executed twice\n   * (once initially and once as part of the repetition).\n   *\n   * If the effect succeeds, it is repeated according to the schedule. If it\n   * fails, the repetition stops immediately, and the failure is returned.\n   *\n   * The schedule can also specify delays between repetitions, making it useful\n   * for tasks like retrying operations with backoff, periodic execution, or\n   * performing a series of dependent actions.\n   *\n   * You can combine schedules for more advanced repetition logic, such as adding\n   * delays, limiting recursions, or dynamically adjusting based on the outcome of\n   * each execution.\n   *\n   * **Example** (Success Example)\n   *\n   * ```ts\n   * import { Effect, Schedule, Console } from \"effect\"\n   *\n   * const action = Console.log(\"success\")\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n   * ```\n   *\n   * **Example** (Failure Example)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an async effect that simulates an action with possible failures\n   * const action = Effect.async<string, string>((resume) => {\n   *   if (count > 1) {\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(\"Uh oh!\"))\n   *   } else {\n   *     count++\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(\n    self: Effect<A, E, R>\n  ) => Repeat.Return<R, E, A, O>\n  /**\n   * Repeats an effect based on a specified schedule or until the first failure.\n   *\n   * **Details**\n   *\n   * This function executes an effect repeatedly according to the given schedule.\n   * Each repetition occurs after the initial execution of the effect, meaning\n   * that the schedule determines the number of additional repetitions. For\n   * example, using `Schedule.once` will result in the effect being executed twice\n   * (once initially and once as part of the repetition).\n   *\n   * If the effect succeeds, it is repeated according to the schedule. If it\n   * fails, the repetition stops immediately, and the failure is returned.\n   *\n   * The schedule can also specify delays between repetitions, making it useful\n   * for tasks like retrying operations with backoff, periodic execution, or\n   * performing a series of dependent actions.\n   *\n   * You can combine schedules for more advanced repetition logic, such as adding\n   * delays, limiting recursions, or dynamically adjusting based on the outcome of\n   * each execution.\n   *\n   * **Example** (Success Example)\n   *\n   * ```ts\n   * import { Effect, Schedule, Console } from \"effect\"\n   *\n   * const action = Console.log(\"success\")\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n   * ```\n   *\n   * **Example** (Failure Example)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an async effect that simulates an action with possible failures\n   * const action = Effect.async<string, string>((resume) => {\n   *   if (count > 1) {\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(\"Uh oh!\"))\n   *   } else {\n   *     count++\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>\n  /**\n   * Repeats an effect based on a specified schedule or until the first failure.\n   *\n   * **Details**\n   *\n   * This function executes an effect repeatedly according to the given schedule.\n   * Each repetition occurs after the initial execution of the effect, meaning\n   * that the schedule determines the number of additional repetitions. For\n   * example, using `Schedule.once` will result in the effect being executed twice\n   * (once initially and once as part of the repetition).\n   *\n   * If the effect succeeds, it is repeated according to the schedule. If it\n   * fails, the repetition stops immediately, and the failure is returned.\n   *\n   * The schedule can also specify delays between repetitions, making it useful\n   * for tasks like retrying operations with backoff, periodic execution, or\n   * performing a series of dependent actions.\n   *\n   * You can combine schedules for more advanced repetition logic, such as adding\n   * delays, limiting recursions, or dynamically adjusting based on the outcome of\n   * each execution.\n   *\n   * **Example** (Success Example)\n   *\n   * ```ts\n   * import { Effect, Schedule, Console } from \"effect\"\n   *\n   * const action = Console.log(\"success\")\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n   * ```\n   *\n   * **Example** (Failure Example)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an async effect that simulates an action with possible failures\n   * const action = Effect.async<string, string>((resume) => {\n   *   if (count > 1) {\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(\"Uh oh!\"))\n   *   } else {\n   *     count++\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>\n  /**\n   * Repeats an effect based on a specified schedule or until the first failure.\n   *\n   * **Details**\n   *\n   * This function executes an effect repeatedly according to the given schedule.\n   * Each repetition occurs after the initial execution of the effect, meaning\n   * that the schedule determines the number of additional repetitions. For\n   * example, using `Schedule.once` will result in the effect being executed twice\n   * (once initially and once as part of the repetition).\n   *\n   * If the effect succeeds, it is repeated according to the schedule. If it\n   * fails, the repetition stops immediately, and the failure is returned.\n   *\n   * The schedule can also specify delays between repetitions, making it useful\n   * for tasks like retrying operations with backoff, periodic execution, or\n   * performing a series of dependent actions.\n   *\n   * You can combine schedules for more advanced repetition logic, such as adding\n   * delays, limiting recursions, or dynamically adjusting based on the outcome of\n   * each execution.\n   *\n   * **Example** (Success Example)\n   *\n   * ```ts\n   * import { Effect, Schedule, Console } from \"effect\"\n   *\n   * const action = Console.log(\"success\")\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n   * ```\n   *\n   * **Example** (Failure Example)\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an async effect that simulates an action with possible failures\n   * const action = Effect.async<string, string>((resume) => {\n   *   if (count > 1) {\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(\"Uh oh!\"))\n   *   } else {\n   *     count++\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * const policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n   * const program = Effect.repeat(action, policy)\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>\n} = schedule_.repeat_combined\n\n/**\n * Repeats an effect a specified number of times or until the first failure.\n *\n * **Details**\n *\n * This function executes an effect initially and then repeats it the specified\n * number of times, as long as it succeeds. For example, calling\n * `repeatN(action, 2)` will execute `action` once initially and then repeat it\n * two additional times if there are no failures.\n *\n * If the effect fails during any repetition, the failure is returned, and no\n * further repetitions are attempted.\n *\n * **When to Use**\n *\n * This function is useful for tasks that need to be retried a fixed number of\n * times or for performing repeated actions without requiring a schedule.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const action = Console.log(\"success\")\n * const program = Effect.repeatN(action, 2)\n *\n * Effect.runPromise(program)\n * ```\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const repeatN: {\n  /**\n   * Repeats an effect a specified number of times or until the first failure.\n   *\n   * **Details**\n   *\n   * This function executes an effect initially and then repeats it the specified\n   * number of times, as long as it succeeds. For example, calling\n   * `repeatN(action, 2)` will execute `action` once initially and then repeat it\n   * two additional times if there are no failures.\n   *\n   * If the effect fails during any repetition, the failure is returned, and no\n   * further repetitions are attempted.\n   *\n   * **When to Use**\n   *\n   * This function is useful for tasks that need to be retried a fixed number of\n   * times or for performing repeated actions without requiring a schedule.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const action = Console.log(\"success\")\n   * const program = Effect.repeatN(action, 2)\n   *\n   * Effect.runPromise(program)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Repeats an effect a specified number of times or until the first failure.\n   *\n   * **Details**\n   *\n   * This function executes an effect initially and then repeats it the specified\n   * number of times, as long as it succeeds. For example, calling\n   * `repeatN(action, 2)` will execute `action` once initially and then repeat it\n   * two additional times if there are no failures.\n   *\n   * If the effect fails during any repetition, the failure is returned, and no\n   * further repetitions are attempted.\n   *\n   * **When to Use**\n   *\n   * This function is useful for tasks that need to be retried a fixed number of\n   * times or for performing repeated actions without requiring a schedule.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const action = Console.log(\"success\")\n   * const program = Effect.repeatN(action, 2)\n   *\n   * Effect.runPromise(program)\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>\n} = effect.repeatN\n\n/**\n * Repeats an effect with a schedule, handling failures using a custom handler.\n *\n * **Details**\n *\n * This function allows you to execute an effect repeatedly based on a specified\n * schedule. If the effect fails at any point, a custom failure handler is\n * invoked. The handler is provided with both the failure value and the output\n * of the schedule at the time of failure. This enables advanced error recovery\n * or alternative fallback logic while maintaining flexibility in how\n * repetitions are handled.\n *\n * For example, using a schedule with `recurs(2)` will allow for two additional\n * repetitions after the initial execution, provided the effect succeeds. If a\n * failure occurs during any iteration, the failure handler is invoked to handle\n * the situation.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Schedule } from \"effect\"\n *\n * let count = 0\n *\n * // Define an async effect that simulates an action with possible failures\n * const action = Effect.async<string, string>((resume) => {\n *   if (count > 1) {\n *     console.log(\"failure\")\n *     resume(Effect.fail(\"Uh oh!\"))\n *   } else {\n *     count++\n *     console.log(\"success\")\n *     resume(Effect.succeed(\"yay!\"))\n *   }\n * })\n *\n * const policy = Schedule.addDelay(\n *   Schedule.recurs(2), // Repeat for a maximum of 2 times\n *   () => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n * )\n *\n * const program = Effect.repeatOrElse(action, policy, () =>\n *   Effect.sync(() => {\n *     console.log(\"orElse\")\n *     return count - 1\n *   })\n * )\n *\n * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n * ```\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const repeatOrElse: {\n  /**\n   * Repeats an effect with a schedule, handling failures using a custom handler.\n   *\n   * **Details**\n   *\n   * This function allows you to execute an effect repeatedly based on a specified\n   * schedule. If the effect fails at any point, a custom failure handler is\n   * invoked. The handler is provided with both the failure value and the output\n   * of the schedule at the time of failure. This enables advanced error recovery\n   * or alternative fallback logic while maintaining flexibility in how\n   * repetitions are handled.\n   *\n   * For example, using a schedule with `recurs(2)` will allow for two additional\n   * repetitions after the initial execution, provided the effect succeeds. If a\n   * failure occurs during any iteration, the failure handler is invoked to handle\n   * the situation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an async effect that simulates an action with possible failures\n   * const action = Effect.async<string, string>((resume) => {\n   *   if (count > 1) {\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(\"Uh oh!\"))\n   *   } else {\n   *     count++\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * const policy = Schedule.addDelay(\n   *   Schedule.recurs(2), // Repeat for a maximum of 2 times\n   *   () => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n   * )\n   *\n   * const program = Effect.repeatOrElse(action, policy, () =>\n   *   Effect.sync(() => {\n   *     console.log(\"orElse\")\n   *     return count - 1\n   *   })\n   * )\n   *\n   * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <R2, A, B, E, E2, R3>(\n    schedule: Schedule.Schedule<B, A, R2>,\n    orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>\n  ): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>\n  /**\n   * Repeats an effect with a schedule, handling failures using a custom handler.\n   *\n   * **Details**\n   *\n   * This function allows you to execute an effect repeatedly based on a specified\n   * schedule. If the effect fails at any point, a custom failure handler is\n   * invoked. The handler is provided with both the failure value and the output\n   * of the schedule at the time of failure. This enables advanced error recovery\n   * or alternative fallback logic while maintaining flexibility in how\n   * repetitions are handled.\n   *\n   * For example, using a schedule with `recurs(2)` will allow for two additional\n   * repetitions after the initial execution, provided the effect succeeds. If a\n   * failure occurs during any iteration, the failure handler is invoked to handle\n   * the situation.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Schedule } from \"effect\"\n   *\n   * let count = 0\n   *\n   * // Define an async effect that simulates an action with possible failures\n   * const action = Effect.async<string, string>((resume) => {\n   *   if (count > 1) {\n   *     console.log(\"failure\")\n   *     resume(Effect.fail(\"Uh oh!\"))\n   *   } else {\n   *     count++\n   *     console.log(\"success\")\n   *     resume(Effect.succeed(\"yay!\"))\n   *   }\n   * })\n   *\n   * const policy = Schedule.addDelay(\n   *   Schedule.recurs(2), // Repeat for a maximum of 2 times\n   *   () => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n   * )\n   *\n   * const program = Effect.repeatOrElse(action, policy, () =>\n   *   Effect.sync(() => {\n   *     console.log(\"orElse\")\n   *     return count - 1\n   *   })\n   * )\n   *\n   * Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n   * ```\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, E, R, R2, B, E2, R3>(\n    self: Effect<A, E, R>,\n    schedule: Schedule.Schedule<B, A, R2>,\n    orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>\n  ): Effect<B, E2, R | R2 | R3>\n} = schedule_.repeatOrElse_Effect\n\n/**\n * Repeats an effect based on a specified schedule.\n *\n * **Details**\n *\n * This function allows you to execute an effect repeatedly according to a given\n * schedule. The schedule determines the timing and number of repetitions. Each\n * repetition can also depend on the decision of the schedule, providing\n * flexibility for complex workflows. This function does not modify the effect's\n * success or failure; it only controls its repetition.\n *\n * For example, you can use a schedule that recurs a specific number of times,\n * adds delays between repetitions, or customizes repetition behavior based on\n * external inputs. The effect runs initially and is repeated according to the\n * schedule.\n *\n * @see {@link scheduleFrom} for a variant that allows the schedule's decision\n * to depend on the result of this effect.\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const schedule: {\n  /**\n   * Repeats an effect based on a specified schedule.\n   *\n   * **Details**\n   *\n   * This function allows you to execute an effect repeatedly according to a given\n   * schedule. The schedule determines the timing and number of repetitions. Each\n   * repetition can also depend on the decision of the schedule, providing\n   * flexibility for complex workflows. This function does not modify the effect's\n   * success or failure; it only controls its repetition.\n   *\n   * For example, you can use a schedule that recurs a specific number of times,\n   * adds delays between repetitions, or customizes repetition behavior based on\n   * external inputs. The effect runs initially and is repeated according to the\n   * schedule.\n   *\n   * @see {@link scheduleFrom} for a variant that allows the schedule's decision\n   * to depend on the result of this effect.\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, R2, Out>(schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>\n  /**\n   * Repeats an effect based on a specified schedule.\n   *\n   * **Details**\n   *\n   * This function allows you to execute an effect repeatedly according to a given\n   * schedule. The schedule determines the timing and number of repetitions. Each\n   * repetition can also depend on the decision of the schedule, providing\n   * flexibility for complex workflows. This function does not modify the effect's\n   * success or failure; it only controls its repetition.\n   *\n   * For example, you can use a schedule that recurs a specific number of times,\n   * adds delays between repetitions, or customizes repetition behavior based on\n   * external inputs. The effect runs initially and is repeated according to the\n   * schedule.\n   *\n   * @see {@link scheduleFrom} for a variant that allows the schedule's decision\n   * to depend on the result of this effect.\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>\n} = schedule_.schedule_Effect\n\n/**\n * Runs an effect repeatedly on a new fiber according to a given schedule.\n *\n * **Details**\n *\n * This function starts the provided effect on a new fiber and runs it\n * repeatedly based on the specified schedule. The repetitions are managed by\n * the schedule's rules, which define the timing and number of iterations. The\n * fiber is attached to the current scope, meaning it is automatically managed\n * and cleaned up when the scope is closed.\n *\n * The function returns a `RuntimeFiber` that allows you to monitor or interact\n * with the running fiber.\n *\n * **When to Use**\n *\n * This is particularly useful for concurrent execution of scheduled tasks or\n * when you want to continue processing without waiting for the repetitions to\n * complete.\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const scheduleForked: {\n  /**\n   * Runs an effect repeatedly on a new fiber according to a given schedule.\n   *\n   * **Details**\n   *\n   * This function starts the provided effect on a new fiber and runs it\n   * repeatedly based on the specified schedule. The repetitions are managed by\n   * the schedule's rules, which define the timing and number of iterations. The\n   * fiber is attached to the current scope, meaning it is automatically managed\n   * and cleaned up when the scope is closed.\n   *\n   * The function returns a `RuntimeFiber` that allows you to monitor or interact\n   * with the running fiber.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful for concurrent execution of scheduled tasks or\n   * when you want to continue processing without waiting for the repetitions to\n   * complete.\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <Out, R2>(schedule: Schedule.Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>\n  /**\n   * Runs an effect repeatedly on a new fiber according to a given schedule.\n   *\n   * **Details**\n   *\n   * This function starts the provided effect on a new fiber and runs it\n   * repeatedly based on the specified schedule. The repetitions are managed by\n   * the schedule's rules, which define the timing and number of iterations. The\n   * fiber is attached to the current scope, meaning it is automatically managed\n   * and cleaned up when the scope is closed.\n   *\n   * The function returns a `RuntimeFiber` that allows you to monitor or interact\n   * with the running fiber.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful for concurrent execution of scheduled tasks or\n   * when you want to continue processing without waiting for the repetitions to\n   * complete.\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, unknown, R2>): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>\n} = schedule_.scheduleForked\n\n/**\n * Runs an effect repeatedly according to a schedule, starting from a specified\n * input value.\n *\n * **Details**\n *\n * This function allows you to repeatedly execute an effect based on a schedule.\n * The schedule starts with the given `initial` input value, which is passed to\n * the first execution. Subsequent executions of the effect are controlled by\n * the schedule's rules, using the output of the previous iteration as the input\n * for the next one.\n *\n * The returned effect will complete when the schedule ends or the effect fails,\n * propagating the error.\n *\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const scheduleFrom: {\n  /**\n   * Runs an effect repeatedly according to a schedule, starting from a specified\n   * input value.\n   *\n   * **Details**\n   *\n   * This function allows you to repeatedly execute an effect based on a schedule.\n   * The schedule starts with the given `initial` input value, which is passed to\n   * the first execution. Subsequent executions of the effect are controlled by\n   * the schedule's rules, using the output of the previous iteration as the input\n   * for the next one.\n   *\n   * The returned effect will complete when the schedule ends or the effect fails,\n   * propagating the error.\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <R2, In, Out>(initial: In, schedule: Schedule.Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>\n  /**\n   * Runs an effect repeatedly according to a schedule, starting from a specified\n   * input value.\n   *\n   * **Details**\n   *\n   * This function allows you to repeatedly execute an effect based on a schedule.\n   * The schedule starts with the given `initial` input value, which is passed to\n   * the first execution. Subsequent executions of the effect are controlled by\n   * the schedule's rules, using the output of the previous iteration as the input\n   * for the next one.\n   *\n   * The returned effect will complete when the schedule ends or the effect fails,\n   * propagating the error.\n   *\n   * @since 2.0.0\n   * @category Repetition / Recursion\n   */\n  <In, E, R, R2, Out>(\n    self: Effect<In, E, R>,\n    initial: In,\n    schedule: Schedule.Schedule<Out, In, R2>\n  ): Effect<Out, E, R | R2>\n} = schedule_.scheduleFrom_Effect\n\n/**\n * @since 2.0.0\n * @category Repetition / Recursion\n */\nexport const whileLoop: <A, E, R>(\n  options: {\n    readonly while: LazyArg<boolean>\n    readonly body: LazyArg<Effect<A, E, R>>\n    readonly step: (a: A) => void\n  }\n) => Effect<void, E, R> = core.whileLoop\n\n/**\n * Returns a collection of all `FiberRef` values for the fiber running this\n * effect.\n *\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const getFiberRefs: Effect<FiberRefs.FiberRefs> = effect.fiberRefs\n\n/**\n * Inherits values from all `FiberRef` instances into current fiber.\n *\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void> = effect.inheritFiberRefs\n\n/**\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const locally: {\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <A>(self: FiberRef.FiberRef<A>, value: A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef.FiberRef<A>, value: A): Effect<B, E, R>\n} = core.fiberRefLocally\n\n/**\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const locallyWith: {\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef.FiberRef<A>, f: (a: A) => A): Effect<B, E, R>\n} = core.fiberRefLocallyWith\n\n/**\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const locallyScoped: {\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <A>(value: A): (self: FiberRef.FiberRef<A>) => Effect<void, never, Scope.Scope>\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <A>(self: FiberRef.FiberRef<A>, value: A): Effect<void, never, Scope.Scope>\n} = fiberRuntime.fiberRefLocallyScoped\n\n/**\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const locallyScopedWith: {\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <A>(f: (a: A) => A): (self: FiberRef.FiberRef<A>) => Effect<void, never, Scope.Scope>\n  /**\n   * @since 2.0.0\n   * @category Fiber Refs\n   */\n  <A>(self: FiberRef.FiberRef<A>, f: (a: A) => A): Effect<void, never, Scope.Scope>\n} = fiberRuntime.fiberRefLocallyScopedWith\n\n/**\n * Applies the specified changes to the `FiberRef` values for the fiber\n * running this workflow.\n *\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void> = effect.patchFiberRefs\n\n/**\n * Sets the `FiberRef` values for the fiber running this effect to the values\n * in the specified collection of `FiberRef` values.\n *\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void> = effect.setFiberRefs\n\n/**\n * Updates the `FiberRef` values for the fiber running this effect using the\n * specified function.\n *\n * @since 2.0.0\n * @category Fiber Refs\n */\nexport const updateFiberRefs: (\n  f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs\n) => Effect<void> = effect.updateFiberRefs\n\n/**\n * Checks if an effect has failed.\n *\n * **Details**\n *\n * This function evaluates whether an effect has resulted in a failure. It\n * returns a boolean value wrapped in an effect, with `true` indicating the\n * effect failed and `false` otherwise.\n *\n * The resulting effect cannot fail (`never` in the error channel) but retains\n * the context of the original effect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const failure = Effect.fail(\"Uh oh!\")\n *\n * console.log(Effect.runSync(Effect.isFailure(failure)))\n * // Output: true\n *\n * const defect = Effect.dieMessage(\"BOOM!\")\n *\n * Effect.runSync(Effect.isFailure(defect))\n * // throws: BOOM!\n * ```\n *\n * @since 2.0.0\n * @category Condition Checking\n */\nexport const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R> = effect.isFailure\n\n/**\n * Checks if an effect has succeeded.\n *\n * **Details**\n *\n * This function evaluates whether an effect has resulted in a success. It\n * returns a boolean value wrapped in an effect, with `true` indicating the\n * effect succeeded and `false` otherwise.\n *\n * The resulting effect cannot fail (`never` in the error channel) but retains\n * the context of the original effect.\n *\n * @since 2.0.0\n * @category Condition Checking\n */\nexport const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R> = effect.isSuccess\n\n/**\n * Handles both success and failure cases of an effect without performing side\n * effects.\n *\n * **Details**\n *\n * `match` lets you define custom handlers for both success and failure\n * scenarios. You provide separate functions to handle each case, allowing you\n * to process the result if the effect succeeds, or handle the error if the\n * effect fails.\n *\n * **When to Use**\n *\n * This is useful for structuring your code to respond differently to success or\n * failure without triggering side effects.\n *\n * **Example** (Handling Both Success and Failure Cases)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n *\n * const program1 = Effect.match(success, {\n *   onFailure: (error) => `failure: ${error.message}`,\n *   onSuccess: (value) => `success: ${value}`\n * })\n *\n * // Run and log the result of the successful effect\n * Effect.runPromise(program1).then(console.log)\n * // Output: \"success: 42\"\n *\n * const failure: Effect.Effect<number, Error> = Effect.fail(\n *   new Error(\"Uh oh!\")\n * )\n *\n * const program2 = Effect.match(failure, {\n *   onFailure: (error) => `failure: ${error.message}`,\n *   onSuccess: (value) => `success: ${value}`\n * })\n *\n * // Run and log the result of the failed effect\n * Effect.runPromise(program2).then(console.log)\n * // Output: \"failure: Uh oh!\"\n * ```\n *\n * @see {@link matchEffect} if you need to perform side effects in the handlers.\n *\n * @since 2.0.0\n * @category Matching\n */\nexport const match: {\n  /**\n   * Handles both success and failure cases of an effect without performing side\n   * effects.\n   *\n   * **Details**\n   *\n   * `match` lets you define custom handlers for both success and failure\n   * scenarios. You provide separate functions to handle each case, allowing you\n   * to process the result if the effect succeeds, or handle the error if the\n   * effect fails.\n   *\n   * **When to Use**\n   *\n   * This is useful for structuring your code to respond differently to success or\n   * failure without triggering side effects.\n   *\n   * **Example** (Handling Both Success and Failure Cases)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n   *\n   * const program1 = Effect.match(success, {\n   *   onFailure: (error) => `failure: ${error.message}`,\n   *   onSuccess: (value) => `success: ${value}`\n   * })\n   *\n   * // Run and log the result of the successful effect\n   * Effect.runPromise(program1).then(console.log)\n   * // Output: \"success: 42\"\n   *\n   * const failure: Effect.Effect<number, Error> = Effect.fail(\n   *   new Error(\"Uh oh!\")\n   * )\n   *\n   * const program2 = Effect.match(failure, {\n   *   onFailure: (error) => `failure: ${error.message}`,\n   *   onSuccess: (value) => `success: ${value}`\n   * })\n   *\n   * // Run and log the result of the failed effect\n   * Effect.runPromise(program2).then(console.log)\n   * // Output: \"failure: Uh oh!\"\n   * ```\n   *\n   * @see {@link matchEffect} if you need to perform side effects in the handlers.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>\n  /**\n   * Handles both success and failure cases of an effect without performing side\n   * effects.\n   *\n   * **Details**\n   *\n   * `match` lets you define custom handlers for both success and failure\n   * scenarios. You provide separate functions to handle each case, allowing you\n   * to process the result if the effect succeeds, or handle the error if the\n   * effect fails.\n   *\n   * **When to Use**\n   *\n   * This is useful for structuring your code to respond differently to success or\n   * failure without triggering side effects.\n   *\n   * **Example** (Handling Both Success and Failure Cases)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n   *\n   * const program1 = Effect.match(success, {\n   *   onFailure: (error) => `failure: ${error.message}`,\n   *   onSuccess: (value) => `success: ${value}`\n   * })\n   *\n   * // Run and log the result of the successful effect\n   * Effect.runPromise(program1).then(console.log)\n   * // Output: \"success: 42\"\n   *\n   * const failure: Effect.Effect<number, Error> = Effect.fail(\n   *   new Error(\"Uh oh!\")\n   * )\n   *\n   * const program2 = Effect.match(failure, {\n   *   onFailure: (error) => `failure: ${error.message}`,\n   *   onSuccess: (value) => `success: ${value}`\n   * })\n   *\n   * // Run and log the result of the failed effect\n   * Effect.runPromise(program2).then(console.log)\n   * // Output: \"failure: Uh oh!\"\n   * ```\n   *\n   * @see {@link matchEffect} if you need to perform side effects in the handlers.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <A, E, R, A2, A3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): Effect<A2 | A3, never, R>\n} = effect.match\n\n/**\n * Handles failures by matching the cause of failure.\n *\n * **Details**\n *\n * The `matchCause` function allows you to handle failures with access to the\n * full cause of the failure within a fiber.\n *\n * **When to Use**\n *\n * This is useful for differentiating between different types of errors, such as\n * regular failures, defects, or interruptions. You can provide specific\n * handling logic for each failure type based on the cause.\n *\n * **Example** (Handling Different Failure Causes)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n *\n * const program = Effect.matchCause(task, {\n *   onFailure: (cause) => {\n *     switch (cause._tag) {\n *       case \"Fail\":\n *         // Handle standard failure\n *         return `Fail: ${cause.error.message}`\n *       case \"Die\":\n *         // Handle defects (unexpected errors)\n *         return `Die: ${cause.defect}`\n *       case \"Interrupt\":\n *         // Handle interruption\n *         return `${cause.fiberId} interrupted!`\n *     }\n *     // Fallback for other causes\n *     return \"failed due to other causes\"\n *   },\n *   onSuccess: (value) =>\n *     // task completes successfully\n *     `succeeded with ${value} value`\n * })\n *\n * Effect.runPromise(program).then(console.log)\n * // Output: \"Die: Uh oh!\"\n * ```\n *\n * @see {@link matchCauseEffect} if you need to perform side effects in the\n * handlers.\n * @see {@link match} if you don't need to handle the cause of the failure.\n *\n * @since 2.0.0\n * @category Matching\n */\nexport const matchCause: {\n  /**\n   * Handles failures by matching the cause of failure.\n   *\n   * **Details**\n   *\n   * The `matchCause` function allows you to handle failures with access to the\n   * full cause of the failure within a fiber.\n   *\n   * **When to Use**\n   *\n   * This is useful for differentiating between different types of errors, such as\n   * regular failures, defects, or interruptions. You can provide specific\n   * handling logic for each failure type based on the cause.\n   *\n   * **Example** (Handling Different Failure Causes)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n   *\n   * const program = Effect.matchCause(task, {\n   *   onFailure: (cause) => {\n   *     switch (cause._tag) {\n   *       case \"Fail\":\n   *         // Handle standard failure\n   *         return `Fail: ${cause.error.message}`\n   *       case \"Die\":\n   *         // Handle defects (unexpected errors)\n   *         return `Die: ${cause.defect}`\n   *       case \"Interrupt\":\n   *         // Handle interruption\n   *         return `${cause.fiberId} interrupted!`\n   *     }\n   *     // Fallback for other causes\n   *     return \"failed due to other causes\"\n   *   },\n   *   onSuccess: (value) =>\n   *     // task completes successfully\n   *     `succeeded with ${value} value`\n   * })\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output: \"Die: Uh oh!\"\n   * ```\n   *\n   * @see {@link matchCauseEffect} if you need to perform side effects in the\n   * handlers.\n   * @see {@link match} if you don't need to handle the cause of the failure.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>\n  /**\n   * Handles failures by matching the cause of failure.\n   *\n   * **Details**\n   *\n   * The `matchCause` function allows you to handle failures with access to the\n   * full cause of the failure within a fiber.\n   *\n   * **When to Use**\n   *\n   * This is useful for differentiating between different types of errors, such as\n   * regular failures, defects, or interruptions. You can provide specific\n   * handling logic for each failure type based on the cause.\n   *\n   * **Example** (Handling Different Failure Causes)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n   *\n   * const program = Effect.matchCause(task, {\n   *   onFailure: (cause) => {\n   *     switch (cause._tag) {\n   *       case \"Fail\":\n   *         // Handle standard failure\n   *         return `Fail: ${cause.error.message}`\n   *       case \"Die\":\n   *         // Handle defects (unexpected errors)\n   *         return `Die: ${cause.defect}`\n   *       case \"Interrupt\":\n   *         // Handle interruption\n   *         return `${cause.fiberId} interrupted!`\n   *     }\n   *     // Fallback for other causes\n   *     return \"failed due to other causes\"\n   *   },\n   *   onSuccess: (value) =>\n   *     // task completes successfully\n   *     `succeeded with ${value} value`\n   * })\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output: \"Die: Uh oh!\"\n   * ```\n   *\n   * @see {@link matchCauseEffect} if you need to perform side effects in the\n   * handlers.\n   * @see {@link match} if you don't need to handle the cause of the failure.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <A, E, R, A2, A3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => A2\n      readonly onSuccess: (a: A) => A3\n    }\n  ): Effect<A2 | A3, never, R>\n} = core.matchCause\n\n/**\n * Handles failures with access to the cause and allows performing side effects.\n *\n * **Details**\n *\n * The `matchCauseEffect` function works similarly to {@link matchCause}, but it\n * also allows you to perform additional side effects based on the failure\n * cause. This function provides access to the complete cause of the failure,\n * making it possible to differentiate between various failure types, and allows\n * you to respond accordingly while performing side effects (like logging or\n * other operations).\n *\n * **Example** (Handling Different Failure Causes with Side Effects)\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n *\n * const program = Effect.matchCauseEffect(task, {\n *   onFailure: (cause) => {\n *     switch (cause._tag) {\n *       case \"Fail\":\n *         // Handle standard failure with a logged message\n *         return Console.log(`Fail: ${cause.error.message}`)\n *       case \"Die\":\n *         // Handle defects (unexpected errors) by logging the defect\n *         return Console.log(`Die: ${cause.defect}`)\n *       case \"Interrupt\":\n *         // Handle interruption and log the fiberId that was interrupted\n *         return Console.log(`${cause.fiberId} interrupted!`)\n *     }\n *     // Fallback for other causes\n *     return Console.log(\"failed due to other causes\")\n *   },\n *   onSuccess: (value) =>\n *     // Log success if the task completes successfully\n *     Console.log(`succeeded with ${value} value`)\n * })\n *\n * Effect.runPromise(program)\n * // Output: \"Die: Uh oh!\"\n * ```\n *\n * @see {@link matchCause} if you don't need side effects and only want to handle the result or failure.\n * @see {@link matchEffect} if you don't need to handle the cause of the failure.\n *\n * @since 2.0.0\n * @category Matching\n */\nexport const matchCauseEffect: {\n  /**\n   * Handles failures with access to the cause and allows performing side effects.\n   *\n   * **Details**\n   *\n   * The `matchCauseEffect` function works similarly to {@link matchCause}, but it\n   * also allows you to perform additional side effects based on the failure\n   * cause. This function provides access to the complete cause of the failure,\n   * making it possible to differentiate between various failure types, and allows\n   * you to respond accordingly while performing side effects (like logging or\n   * other operations).\n   *\n   * **Example** (Handling Different Failure Causes with Side Effects)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n   *\n   * const program = Effect.matchCauseEffect(task, {\n   *   onFailure: (cause) => {\n   *     switch (cause._tag) {\n   *       case \"Fail\":\n   *         // Handle standard failure with a logged message\n   *         return Console.log(`Fail: ${cause.error.message}`)\n   *       case \"Die\":\n   *         // Handle defects (unexpected errors) by logging the defect\n   *         return Console.log(`Die: ${cause.defect}`)\n   *       case \"Interrupt\":\n   *         // Handle interruption and log the fiberId that was interrupted\n   *         return Console.log(`${cause.fiberId} interrupted!`)\n   *     }\n   *     // Fallback for other causes\n   *     return Console.log(\"failed due to other causes\")\n   *   },\n   *   onSuccess: (value) =>\n   *     // Log success if the task completes successfully\n   *     Console.log(`succeeded with ${value} value`)\n   * })\n   *\n   * Effect.runPromise(program)\n   * // Output: \"Die: Uh oh!\"\n   * ```\n   *\n   * @see {@link matchCause} if you don't need side effects and only want to handle the result or failure.\n   * @see {@link matchEffect} if you don't need to handle the cause of the failure.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  /**\n   * Handles failures with access to the cause and allows performing side effects.\n   *\n   * **Details**\n   *\n   * The `matchCauseEffect` function works similarly to {@link matchCause}, but it\n   * also allows you to perform additional side effects based on the failure\n   * cause. This function provides access to the complete cause of the failure,\n   * making it possible to differentiate between various failure types, and allows\n   * you to respond accordingly while performing side effects (like logging or\n   * other operations).\n   *\n   * **Example** (Handling Different Failure Causes with Side Effects)\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task: Effect.Effect<number, Error> = Effect.die(\"Uh oh!\")\n   *\n   * const program = Effect.matchCauseEffect(task, {\n   *   onFailure: (cause) => {\n   *     switch (cause._tag) {\n   *       case \"Fail\":\n   *         // Handle standard failure with a logged message\n   *         return Console.log(`Fail: ${cause.error.message}`)\n   *       case \"Die\":\n   *         // Handle defects (unexpected errors) by logging the defect\n   *         return Console.log(`Die: ${cause.defect}`)\n   *       case \"Interrupt\":\n   *         // Handle interruption and log the fiberId that was interrupted\n   *         return Console.log(`${cause.fiberId} interrupted!`)\n   *     }\n   *     // Fallback for other causes\n   *     return Console.log(\"failed due to other causes\")\n   *   },\n   *   onSuccess: (value) =>\n   *     // Log success if the task completes successfully\n   *     Console.log(`succeeded with ${value} value`)\n   * })\n   *\n   * Effect.runPromise(program)\n   * // Output: \"Die: Uh oh!\"\n   * ```\n   *\n   * @see {@link matchCause} if you don't need side effects and only want to handle the result or failure.\n   * @see {@link matchEffect} if you don't need to handle the cause of the failure.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect<A3, E3, R3>\n    }\n  ): Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = core.matchCauseEffect\n\n/**\n * Handles both success and failure cases of an effect, allowing for additional\n * side effects.\n *\n * **Details**\n *\n * The `matchEffect` function is similar to {@link match}, but it enables you to\n * perform side effects in the handlers for both success and failure outcomes.\n *\n * **When to Use**\n *\n * This is useful when you need to execute additional actions, like logging or\n * notifying users, based on whether an effect succeeds or fails.\n *\n * **Example** (Handling Both Success and Failure Cases with Side Effects)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n * const failure: Effect.Effect<number, Error> = Effect.fail(\n *   new Error(\"Uh oh!\")\n * )\n *\n * const program1 = Effect.matchEffect(success, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program1))\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=\"success: 42\"\n * // success: 42\n *\n * const program2 = Effect.matchEffect(failure, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program2))\n * // Output:\n * // timestamp=... level=INFO fiber=#1 message=\"failure: Uh oh!\"\n * // failure: Uh oh!\n * ```\n *\n * @see {@link match} if you don't need side effects and only want to handle the\n * result or failure.\n *\n * @since 2.0.0\n * @category Matching\n */\nexport const matchEffect: {\n  /**\n   * Handles both success and failure cases of an effect, allowing for additional\n   * side effects.\n   *\n   * **Details**\n   *\n   * The `matchEffect` function is similar to {@link match}, but it enables you to\n   * perform side effects in the handlers for both success and failure outcomes.\n   *\n   * **When to Use**\n   *\n   * This is useful when you need to execute additional actions, like logging or\n   * notifying users, based on whether an effect succeeds or fails.\n   *\n   * **Example** (Handling Both Success and Failure Cases with Side Effects)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n   * const failure: Effect.Effect<number, Error> = Effect.fail(\n   *   new Error(\"Uh oh!\")\n   * )\n   *\n   * const program1 = Effect.matchEffect(success, {\n   *   onFailure: (error) =>\n   *     Effect.succeed(`failure: ${error.message}`).pipe(\n   *       Effect.tap(Effect.log)\n   *     ),\n   *   onSuccess: (value) =>\n   *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n   * })\n   *\n   * console.log(Effect.runSync(program1))\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"success: 42\"\n   * // success: 42\n   *\n   * const program2 = Effect.matchEffect(failure, {\n   *   onFailure: (error) =>\n   *     Effect.succeed(`failure: ${error.message}`).pipe(\n   *       Effect.tap(Effect.log)\n   *     ),\n   *   onSuccess: (value) =>\n   *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n   * })\n   *\n   * console.log(Effect.runSync(program2))\n   * // Output:\n   * // timestamp=... level=INFO fiber=#1 message=\"failure: Uh oh!\"\n   * // failure: Uh oh!\n   * ```\n   *\n   * @see {@link match} if you don't need side effects and only want to handle the\n   * result or failure.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <E, A2, E2, R2, A, A3, E3, R3>(\n    options: {\n      readonly onFailure: (e: E) => Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect<A3, E3, R3>\n    }\n  ): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n  /**\n   * Handles both success and failure cases of an effect, allowing for additional\n   * side effects.\n   *\n   * **Details**\n   *\n   * The `matchEffect` function is similar to {@link match}, but it enables you to\n   * perform side effects in the handlers for both success and failure outcomes.\n   *\n   * **When to Use**\n   *\n   * This is useful when you need to execute additional actions, like logging or\n   * notifying users, based on whether an effect succeeds or fails.\n   *\n   * **Example** (Handling Both Success and Failure Cases with Side Effects)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n   * const failure: Effect.Effect<number, Error> = Effect.fail(\n   *   new Error(\"Uh oh!\")\n   * )\n   *\n   * const program1 = Effect.matchEffect(success, {\n   *   onFailure: (error) =>\n   *     Effect.succeed(`failure: ${error.message}`).pipe(\n   *       Effect.tap(Effect.log)\n   *     ),\n   *   onSuccess: (value) =>\n   *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n   * })\n   *\n   * console.log(Effect.runSync(program1))\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"success: 42\"\n   * // success: 42\n   *\n   * const program2 = Effect.matchEffect(failure, {\n   *   onFailure: (error) =>\n   *     Effect.succeed(`failure: ${error.message}`).pipe(\n   *       Effect.tap(Effect.log)\n   *     ),\n   *   onSuccess: (value) =>\n   *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n   * })\n   *\n   * console.log(Effect.runSync(program2))\n   * // Output:\n   * // timestamp=... level=INFO fiber=#1 message=\"failure: Uh oh!\"\n   * // failure: Uh oh!\n   * ```\n   *\n   * @see {@link match} if you don't need side effects and only want to handle the\n   * result or failure.\n   *\n   * @since 2.0.0\n   * @category Matching\n   */\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    self: Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect<A2, E2, R2>\n      readonly onSuccess: (a: A) => Effect<A3, E3, R3>\n    }\n  ): Effect<A2 | A3, E2 | E3, R2 | R3 | R>\n} = core.matchEffect\n\n/**\n * Logs one or more messages or error causes at the current log level.\n *\n * **Details**\n *\n * This function provides a simple way to log messages or error causes during\n * the execution of your effects. By default, logs are recorded at the `INFO`\n * level, but this can be adjusted using other logging utilities\n * (`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,\n * can be logged in a single call. When logging `Cause` instances, detailed\n * error information is included in the log output.\n *\n * The log output includes useful metadata like the current timestamp, log\n * level, and fiber ID, making it suitable for debugging and tracking purposes.\n * This function does not interrupt or alter the effect's execution flow.\n *\n * **Example**\n *\n * ```ts\n * import { Cause, Effect } from \"effect\"\n *\n * const program = Effect.log(\n *   \"message1\",\n *   \"message2\",\n *   Cause.die(\"Oh no!\"),\n *   Cause.die(\"Oh uh!\")\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause=\"Error: Oh no!\n * // Error: Oh uh!\"\n * ```\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const log: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.log\n\n/**\n * Logs messages or error causes at a specified log level.\n *\n * **Details**\n *\n * This function allows you to log one or more messages or error causes while\n * specifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides\n * flexibility in categorizing logs based on their importance or severity,\n * making it easier to filter logs during debugging or production monitoring.\n *\n * **Example**\n *\n * ```ts\n * import { Cause, Effect, LogLevel } from \"effect\"\n *\n * const program = Effect.logWithLevel(\n *   LogLevel.Error,\n *   \"Critical error encountered\",\n *   Cause.die(\"System failure!\")\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause=\"Error: System failure!\"\n * ```\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logWithLevel = (\n  level: LogLevel.LogLevel,\n  ...message: ReadonlyArray<any>\n): Effect<void> => effect.logWithLevel(level)(...message)\n\n/**\n * Logs messages at the TRACE log level.\n *\n * **Details**\n *\n * This function logs the specified messages at the TRACE level. TRACE logs are\n * typically used for very detailed diagnostic information. These messages are\n * not displayed by default. To view them, you must adjust the logging\n * configuration by setting the minimum log level to `LogLevel.Trace` using\n * `Logger.withMinimumLogLevel`.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.logTrace(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n *\n * Effect.runFork(program)\n * // timestamp=... level=TRACE fiber=#0 message=message1\n * ```\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.logTrace\n\n/**\n * Logs messages at the DEBUG log level.\n *\n * **Details**\n *\n * This function logs messages at the DEBUG level, which is typically used for\n * diagnosing application behavior during development. DEBUG messages provide\n * less detailed information than TRACE logs but are still not shown by default.\n * To view these logs, adjust the log level using `Logger.withMinimumLogLevel`.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n *\n * Effect.runFork(program)\n * // timestamp=... level=DEBUG fiber=#0 message=message1\n * ```\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.logDebug\n\n/**\n * Logs messages at the INFO log level.\n *\n * **Details**\n *\n * This function logs messages at the INFO level, suitable for general\n * application events or operational messages. INFO logs are shown by default\n * and are commonly used for highlighting normal, non-error operations.\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.logInfo\n\n/**\n * Logs messages at the WARNING log level.\n *\n * **Details**\n *\n * This function logs messages at the WARNING level, suitable for highlighting\n * potential issues that are not errors but may require attention. These\n * messages indicate that something unexpected occurred or might lead to errors\n * in the future.\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.logWarning\n\n/**\n * Logs messages at the ERROR log level.\n *\n * **Details**\n *\n * This function logs messages at the ERROR level, suitable for reporting\n * application errors or failures. These logs are typically used for unexpected\n * issues that need immediate attention.\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.logError\n\n/**\n * Logs messages at the FATAL log level.\n *\n * **Details**\n *\n * This function logs messages at the FATAL level, suitable for reporting\n * critical errors that cause the application to terminate or stop functioning.\n * These logs are typically used for unrecoverable errors that require immediate\n * attention.\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logFatal: (...message: ReadonlyArray<any>) => Effect<void, never, never> = effect.logFatal\n\n/**\n * Adds a log span to an effect for tracking and logging its execution duration.\n *\n * **Details**\n *\n * This function wraps an effect with a log span, providing performance\n * monitoring and debugging capabilities. The log span tracks the duration of\n * the wrapped effect and logs it with the specified label. This is particularly\n * useful when analyzing time-sensitive operations or understanding the\n * execution time of specific tasks in your application.\n *\n * The logged output will include the label and the total time taken for the\n * operation. The span information is included in the log metadata, making it\n * easy to trace performance metrics in logs.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.sleep(\"1 second\")\n *   yield* Effect.log(\"The job is finished!\")\n * }).pipe(Effect.withLogSpan(\"myspan\"))\n *\n * Effect.runFork(program)\n * // timestamp=... level=INFO fiber=#0 message=\"The job is finished!\" myspan=1011ms\n * ```\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const withLogSpan: {\n  /**\n   * Adds a log span to an effect for tracking and logging its execution duration.\n   *\n   * **Details**\n   *\n   * This function wraps an effect with a log span, providing performance\n   * monitoring and debugging capabilities. The log span tracks the duration of\n   * the wrapped effect and logs it with the specified label. This is particularly\n   * useful when analyzing time-sensitive operations or understanding the\n   * execution time of specific tasks in your application.\n   *\n   * The logged output will include the label and the total time taken for the\n   * operation. The span information is included in the log metadata, making it\n   * easy to trace performance metrics in logs.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.sleep(\"1 second\")\n   *   yield* Effect.log(\"The job is finished!\")\n   * }).pipe(Effect.withLogSpan(\"myspan\"))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=\"The job is finished!\" myspan=1011ms\n   * ```\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Adds a log span to an effect for tracking and logging its execution duration.\n   *\n   * **Details**\n   *\n   * This function wraps an effect with a log span, providing performance\n   * monitoring and debugging capabilities. The log span tracks the duration of\n   * the wrapped effect and logs it with the specified label. This is particularly\n   * useful when analyzing time-sensitive operations or understanding the\n   * execution time of specific tasks in your application.\n   *\n   * The logged output will include the label and the total time taken for the\n   * operation. The span information is included in the log metadata, making it\n   * easy to trace performance metrics in logs.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.sleep(\"1 second\")\n   *   yield* Effect.log(\"The job is finished!\")\n   * }).pipe(Effect.withLogSpan(\"myspan\"))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=\"The job is finished!\" myspan=1011ms\n   * ```\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>\n} = effect.withLogSpan\n\n/**\n * Adds custom annotations to log entries generated within an effect.\n *\n * **Details**\n *\n * This function allows you to enhance log messages by appending additional\n * context in the form of key-value pairs. These annotations are included in\n * every log message created during the execution of the effect, making the logs\n * more informative and easier to trace.\n *\n * The annotations can be specified as a single key-value pair or as a record of\n * multiple key-value pairs. This is particularly useful for tracking\n * operations, debugging, or associating specific metadata with logs for better\n * observability.\n *\n * The annotated key-value pairs will appear alongside the log message in the\n * output.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"message1\")\n *   yield* Effect.log(\"message2\")\n * }).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n *\n * Effect.runFork(program)\n * // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n * // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n * ```\n *\n * @see {@link annotateLogsScoped} to add log annotations with a limited scope.\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const annotateLogs: {\n  /**\n   * Adds custom annotations to log entries generated within an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to enhance log messages by appending additional\n   * context in the form of key-value pairs. These annotations are included in\n   * every log message created during the execution of the effect, making the logs\n   * more informative and easier to trace.\n   *\n   * The annotations can be specified as a single key-value pair or as a record of\n   * multiple key-value pairs. This is particularly useful for tracking\n   * operations, debugging, or associating specific metadata with logs for better\n   * observability.\n   *\n   * The annotated key-value pairs will appear alongside the log message in the\n   * output.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"message1\")\n   *   yield* Effect.log(\"message2\")\n   * }).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n   * // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n   * ```\n   *\n   * @see {@link annotateLogsScoped} to add log annotations with a limited scope.\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Adds custom annotations to log entries generated within an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to enhance log messages by appending additional\n   * context in the form of key-value pairs. These annotations are included in\n   * every log message created during the execution of the effect, making the logs\n   * more informative and easier to trace.\n   *\n   * The annotations can be specified as a single key-value pair or as a record of\n   * multiple key-value pairs. This is particularly useful for tracking\n   * operations, debugging, or associating specific metadata with logs for better\n   * observability.\n   *\n   * The annotated key-value pairs will appear alongside the log message in the\n   * output.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"message1\")\n   *   yield* Effect.log(\"message2\")\n   * }).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n   * // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n   * ```\n   *\n   * @see {@link annotateLogsScoped} to add log annotations with a limited scope.\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Adds custom annotations to log entries generated within an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to enhance log messages by appending additional\n   * context in the form of key-value pairs. These annotations are included in\n   * every log message created during the execution of the effect, making the logs\n   * more informative and easier to trace.\n   *\n   * The annotations can be specified as a single key-value pair or as a record of\n   * multiple key-value pairs. This is particularly useful for tracking\n   * operations, debugging, or associating specific metadata with logs for better\n   * observability.\n   *\n   * The annotated key-value pairs will appear alongside the log message in the\n   * output.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"message1\")\n   *   yield* Effect.log(\"message2\")\n   * }).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n   * // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n   * ```\n   *\n   * @see {@link annotateLogsScoped} to add log annotations with a limited scope.\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>\n  /**\n   * Adds custom annotations to log entries generated within an effect.\n   *\n   * **Details**\n   *\n   * This function allows you to enhance log messages by appending additional\n   * context in the form of key-value pairs. These annotations are included in\n   * every log message created during the execution of the effect, making the logs\n   * more informative and easier to trace.\n   *\n   * The annotations can be specified as a single key-value pair or as a record of\n   * multiple key-value pairs. This is particularly useful for tracking\n   * operations, debugging, or associating specific metadata with logs for better\n   * observability.\n   *\n   * The annotated key-value pairs will appear alongside the log message in the\n   * output.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"message1\")\n   *   yield* Effect.log(\"message2\")\n   * }).pipe(Effect.annotateLogs(\"taskId\", \"1234\")) // Annotation as key/value pair\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n   * // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n   * ```\n   *\n   * @see {@link annotateLogsScoped} to add log annotations with a limited scope.\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>\n} = effect.annotateLogs\n\n/**\n * Adds log annotations with a limited scope to enhance contextual logging.\n *\n * **Details**\n *\n * This function allows you to apply key-value annotations to log entries\n * generated within a specific scope of your effect computations. The\n * annotations are restricted to the defined `Scope`, ensuring that they are\n * only applied to logs produced during that scope. Once the scope ends, the\n * annotations are automatically removed, making it easier to manage\n * context-specific logging without affecting other parts of your application.\n *\n * The annotations can be provided as a single key-value pair or as a record of\n * multiple key-value pairs. This flexibility enables fine-grained control over\n * the additional metadata included in logs for specific tasks or operations.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"no annotations\")\n *   yield* Effect.annotateLogsScoped({ key: \"value\" })\n *   yield* Effect.log(\"message1\") // Annotation is applied to this log\n *   yield* Effect.log(\"message2\") // Annotation is applied to this log\n * }).pipe(Effect.scoped, Effect.andThen(Effect.log(\"no annotations again\")))\n *\n * Effect.runFork(program)\n * // timestamp=... level=INFO fiber=#0 message=\"no annotations\"\n * // timestamp=... level=INFO fiber=#0 message=message1 key=value\n * // timestamp=... level=INFO fiber=#0 message=message2 key=value\n * // timestamp=... level=INFO fiber=#0 message=\"no annotations again\"\n * ```\n *\n * @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.\n *\n * @since 3.1.0\n * @category Logging\n */\nexport const annotateLogsScoped: {\n  /**\n   * Adds log annotations with a limited scope to enhance contextual logging.\n   *\n   * **Details**\n   *\n   * This function allows you to apply key-value annotations to log entries\n   * generated within a specific scope of your effect computations. The\n   * annotations are restricted to the defined `Scope`, ensuring that they are\n   * only applied to logs produced during that scope. Once the scope ends, the\n   * annotations are automatically removed, making it easier to manage\n   * context-specific logging without affecting other parts of your application.\n   *\n   * The annotations can be provided as a single key-value pair or as a record of\n   * multiple key-value pairs. This flexibility enables fine-grained control over\n   * the additional metadata included in logs for specific tasks or operations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"no annotations\")\n   *   yield* Effect.annotateLogsScoped({ key: \"value\" })\n   *   yield* Effect.log(\"message1\") // Annotation is applied to this log\n   *   yield* Effect.log(\"message2\") // Annotation is applied to this log\n   * }).pipe(Effect.scoped, Effect.andThen(Effect.log(\"no annotations again\")))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=\"no annotations\"\n   * // timestamp=... level=INFO fiber=#0 message=message1 key=value\n   * // timestamp=... level=INFO fiber=#0 message=message2 key=value\n   * // timestamp=... level=INFO fiber=#0 message=\"no annotations again\"\n   * ```\n   *\n   * @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.\n   *\n   * @since 3.1.0\n   * @category Logging\n   */\n  (key: string, value: unknown): Effect<void, never, Scope.Scope>\n  /**\n   * Adds log annotations with a limited scope to enhance contextual logging.\n   *\n   * **Details**\n   *\n   * This function allows you to apply key-value annotations to log entries\n   * generated within a specific scope of your effect computations. The\n   * annotations are restricted to the defined `Scope`, ensuring that they are\n   * only applied to logs produced during that scope. Once the scope ends, the\n   * annotations are automatically removed, making it easier to manage\n   * context-specific logging without affecting other parts of your application.\n   *\n   * The annotations can be provided as a single key-value pair or as a record of\n   * multiple key-value pairs. This flexibility enables fine-grained control over\n   * the additional metadata included in logs for specific tasks or operations.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"no annotations\")\n   *   yield* Effect.annotateLogsScoped({ key: \"value\" })\n   *   yield* Effect.log(\"message1\") // Annotation is applied to this log\n   *   yield* Effect.log(\"message2\") // Annotation is applied to this log\n   * }).pipe(Effect.scoped, Effect.andThen(Effect.log(\"no annotations again\")))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=INFO fiber=#0 message=\"no annotations\"\n   * // timestamp=... level=INFO fiber=#0 message=message1 key=value\n   * // timestamp=... level=INFO fiber=#0 message=message2 key=value\n   * // timestamp=... level=INFO fiber=#0 message=\"no annotations again\"\n   * ```\n   *\n   * @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.\n   *\n   * @since 3.1.0\n   * @category Logging\n   */\n  (values: Record<string, unknown>): Effect<void, never, Scope.Scope>\n} = fiberRuntime.annotateLogsScoped\n\n/**\n * Retrieves the current log annotations for the current scope.\n *\n * **Details**\n *\n * This function provides access to the log annotations associated with the\n * current scope. Log annotations are key-value pairs that provide additional\n * context to log entries. They are often used to add metadata such as tags,\n * identifiers, or extra debugging information to logs.\n *\n * By using this function, you can inspect or utilize the annotations applied to\n * the current scope, making it easier to trace and debug specific sections of\n * your application.\n *\n * @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.\n * @see {@link annotateLogsScoped} to add log annotations with a limited scope.\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const logAnnotations: Effect<HashMap.HashMap<string, unknown>> = effect.logAnnotations\n\n/**\n * Configures whether child fibers will log unhandled errors and at what log\n * level.\n *\n * **Details**\n *\n * This function allows you to control whether unhandled errors from child\n * fibers are logged and to specify the log level for these errors. By default,\n * unhandled errors are reported via the logger. However, using this function,\n * you can choose to suppress these logs by passing `Option.none` or adjust the\n * log level to a specific severity, such as `Error`, `Warning`, or `Info`.\n *\n * This configuration is scoped to the effect it is applied to, meaning the\n * changes only apply to the child fibers created within that effect's context.\n * It is especially useful when you want to reduce noise in logs or prioritize\n * certain types of errors.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Fiber, LogLevel, Option } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   const fiber = yield* Effect.fork(Effect.fail(\"Unhandled error!\"))\n *   yield* Fiber.join(fiber)\n * })\n *\n * Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n * // Output:\n * // timestamp=... level=ERROR fiber=#1 message=\"Fiber terminated with an unhandled error\" cause=\"Error: Unhandled error!\"\n * ```\n *\n * @since 2.0.0\n * @category Logging\n */\nexport const withUnhandledErrorLogLevel: {\n  /**\n   * Configures whether child fibers will log unhandled errors and at what log\n   * level.\n   *\n   * **Details**\n   *\n   * This function allows you to control whether unhandled errors from child\n   * fibers are logged and to specify the log level for these errors. By default,\n   * unhandled errors are reported via the logger. However, using this function,\n   * you can choose to suppress these logs by passing `Option.none` or adjust the\n   * log level to a specific severity, such as `Error`, `Warning`, or `Info`.\n   *\n   * This configuration is scoped to the effect it is applied to, meaning the\n   * changes only apply to the child fibers created within that effect's context.\n   * It is especially useful when you want to reduce noise in logs or prioritize\n   * certain types of errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Fiber, LogLevel, Option } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   const fiber = yield* Effect.fork(Effect.fail(\"Unhandled error!\"))\n   *   yield* Fiber.join(fiber)\n   * })\n   *\n   * Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n   * // Output:\n   * // timestamp=... level=ERROR fiber=#1 message=\"Fiber terminated with an unhandled error\" cause=\"Error: Unhandled error!\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Configures whether child fibers will log unhandled errors and at what log\n   * level.\n   *\n   * **Details**\n   *\n   * This function allows you to control whether unhandled errors from child\n   * fibers are logged and to specify the log level for these errors. By default,\n   * unhandled errors are reported via the logger. However, using this function,\n   * you can choose to suppress these logs by passing `Option.none` or adjust the\n   * log level to a specific severity, such as `Error`, `Warning`, or `Info`.\n   *\n   * This configuration is scoped to the effect it is applied to, meaning the\n   * changes only apply to the child fibers created within that effect's context.\n   * It is especially useful when you want to reduce noise in logs or prioritize\n   * certain types of errors.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Fiber, LogLevel, Option } from \"effect\"\n   *\n   * const program = Effect.gen(function*() {\n   *   const fiber = yield* Effect.fork(Effect.fail(\"Unhandled error!\"))\n   *   yield* Fiber.join(fiber)\n   * })\n   *\n   * Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n   * // Output:\n   * // timestamp=... level=ERROR fiber=#1 message=\"Fiber terminated with an unhandled error\" cause=\"Error: Unhandled error!\"\n   * ```\n   *\n   * @since 2.0.0\n   * @category Logging\n   */\n  <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>\n} = core.withUnhandledErrorLogLevel\n\n/**\n * Conditionally executes an effect based on the specified log level and currently enabled log level.\n *\n * **Details**\n *\n * This function runs the provided effect only if the specified log level is\n * enabled. If the log level is enabled, the effect is executed and its result\n * is wrapped in `Some`. If the log level is not enabled, the effect is not\n * executed and `None` is returned.\n *\n * This function is useful for conditionally executing logging-related effects\n * or other operations that depend on the current log level configuration.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.gen(function* () {\n *   yield* Effect.whenLogLevel(Effect.logTrace(\"message1\"), LogLevel.Trace); // returns `None`\n *   yield* Effect.whenLogLevel(Effect.logDebug(\"message2\"), LogLevel.Debug); // returns `Some`\n * }).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n *\n * Effect.runFork(program)\n * // timestamp=... level=DEBUG fiber=#0 message=message2\n * ```\n *\n * @see {@link FiberRef.currentMinimumLogLevel} to retrieve the current minimum log level.\n *\n * @since 3.13.0\n * @category Logging\n */\nexport const whenLogLevel: {\n  /**\n   * Conditionally executes an effect based on the specified log level and currently enabled log level.\n   *\n   * **Details**\n   *\n   * This function runs the provided effect only if the specified log level is\n   * enabled. If the log level is enabled, the effect is executed and its result\n   * is wrapped in `Some`. If the log level is not enabled, the effect is not\n   * executed and `None` is returned.\n   *\n   * This function is useful for conditionally executing logging-related effects\n   * or other operations that depend on the current log level configuration.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Logger, LogLevel } from \"effect\"\n   *\n   * const program = Effect.gen(function* () {\n   *   yield* Effect.whenLogLevel(Effect.logTrace(\"message1\"), LogLevel.Trace); // returns `None`\n   *   yield* Effect.whenLogLevel(Effect.logDebug(\"message2\"), LogLevel.Debug); // returns `Some`\n   * }).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=DEBUG fiber=#0 message=message2\n   * ```\n   *\n   * @see {@link FiberRef.currentMinimumLogLevel} to retrieve the current minimum log level.\n   *\n   * @since 3.13.0\n   * @category Logging\n   */\n  (level: LogLevel.LogLevel | LogLevel.Literal): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n  /**\n   * Conditionally executes an effect based on the specified log level and currently enabled log level.\n   *\n   * **Details**\n   *\n   * This function runs the provided effect only if the specified log level is\n   * enabled. If the log level is enabled, the effect is executed and its result\n   * is wrapped in `Some`. If the log level is not enabled, the effect is not\n   * executed and `None` is returned.\n   *\n   * This function is useful for conditionally executing logging-related effects\n   * or other operations that depend on the current log level configuration.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Logger, LogLevel } from \"effect\"\n   *\n   * const program = Effect.gen(function* () {\n   *   yield* Effect.whenLogLevel(Effect.logTrace(\"message1\"), LogLevel.Trace); // returns `None`\n   *   yield* Effect.whenLogLevel(Effect.logDebug(\"message2\"), LogLevel.Debug); // returns `Some`\n   * }).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=DEBUG fiber=#0 message=message2\n   * ```\n   *\n   * @see {@link FiberRef.currentMinimumLogLevel} to retrieve the current minimum log level.\n   *\n   * @since 3.13.0\n   * @category Logging\n   */\n  <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel | LogLevel.Literal): Effect<Option.Option<A>, E, R>\n} = fiberRuntime.whenLogLevel\n\n/**\n * Converts an effect's failure into a fiber termination, removing the error\n * from the effect's type.\n *\n * **Details**\n *\n * The `orDie` function is used when you encounter errors that you do not want\n * to handle or recover from. It removes the error type from the effect and\n * ensures that any failure will terminate the fiber. This is useful for\n * propagating failures as defects, signaling that they should not be handled\n * within the effect.\n *\n * **When to Use*\n *\n * Use `orDie` when failures should be treated as unrecoverable defects and no\n * error handling is required.\n *\n * **Example** (Propagating an Error as a Defect)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error(\"Cannot divide by zero\"))\n *     : Effect.succeed(a / b)\n *\n * //       Effect<number, never, never>\n * //      \n * const program = Effect.orDie(divide(1, 0))\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: Cannot divide by zero\n * //   ...stack trace...\n * ```\n *\n * @see {@link orDieWith} if you need to customize the error.\n *\n * @since 2.0.0\n * @category Converting Failures to Defects\n */\nexport const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R> = core.orDie\n\n/**\n * Converts an effect's failure into a fiber termination with a custom error.\n *\n * **Details**\n *\n * The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\n * function to transform the error before terminating the fiber. This is useful for cases where\n * you want to include a more detailed or user-friendly error when the failure is propagated\n * as a defect.\n *\n * **When to Use**\n *\n * Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize\n * the error for clarity or debugging purposes.\n *\n * **Example** (Customizing Defect)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error(\"Cannot divide by zero\"))\n *     : Effect.succeed(a / b)\n *\n * //       Effect<number, never, never>\n * //      \n * const program = Effect.orDieWith(\n *   divide(1, 0),\n *   (error) => new Error(`defect: ${error.message}`)\n * )\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: defect: Cannot divide by zero\n * //   ...stack trace...\n * ```\n *\n * @see {@link orDie} if you don't need to customize the error.\n *\n * @since 2.0.0\n * @category Converting Failures to Defects\n */\nexport const orDieWith: {\n  /**\n   * Converts an effect's failure into a fiber termination with a custom error.\n   *\n   * **Details**\n   *\n   * The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\n   * function to transform the error before terminating the fiber. This is useful for cases where\n   * you want to include a more detailed or user-friendly error when the failure is propagated\n   * as a defect.\n   *\n   * **When to Use**\n   *\n   * Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize\n   * the error for clarity or debugging purposes.\n   *\n   * **Example** (Customizing Defect)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const divide = (a: number, b: number) =>\n   *   b === 0\n   *     ? Effect.fail(new Error(\"Cannot divide by zero\"))\n   *     : Effect.succeed(a / b)\n   *\n   * //       Effect<number, never, never>\n   * //      \n   * const program = Effect.orDieWith(\n   *   divide(1, 0),\n   *   (error) => new Error(`defect: ${error.message}`)\n   * )\n   *\n   * Effect.runPromise(program).catch(console.error)\n   * // Output:\n   * // (FiberFailure) Error: defect: Cannot divide by zero\n   * //   ...stack trace...\n   * ```\n   *\n   * @see {@link orDie} if you don't need to customize the error.\n   *\n   * @since 2.0.0\n   * @category Converting Failures to Defects\n   */\n  <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>\n  /**\n   * Converts an effect's failure into a fiber termination with a custom error.\n   *\n   * **Details**\n   *\n   * The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\n   * function to transform the error before terminating the fiber. This is useful for cases where\n   * you want to include a more detailed or user-friendly error when the failure is propagated\n   * as a defect.\n   *\n   * **When to Use**\n   *\n   * Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize\n   * the error for clarity or debugging purposes.\n   *\n   * **Example** (Customizing Defect)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const divide = (a: number, b: number) =>\n   *   b === 0\n   *     ? Effect.fail(new Error(\"Cannot divide by zero\"))\n   *     : Effect.succeed(a / b)\n   *\n   * //       Effect<number, never, never>\n   * //      \n   * const program = Effect.orDieWith(\n   *   divide(1, 0),\n   *   (error) => new Error(`defect: ${error.message}`)\n   * )\n   *\n   * Effect.runPromise(program).catch(console.error)\n   * // Output:\n   * // (FiberFailure) Error: defect: Cannot divide by zero\n   * //   ...stack trace...\n   * ```\n   *\n   * @see {@link orDie} if you don't need to customize the error.\n   *\n   * @since 2.0.0\n   * @category Converting Failures to Defects\n   */\n  <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>\n} = core.orDieWith\n\n/**\n * Attempts one effect, and if it fails, falls back to another effect.\n *\n * **Details**\n *\n * This function allows you to try executing an effect, and if it fails\n * (produces an error), a fallback effect is executed instead. The fallback\n * effect is defined as a lazy argument, meaning it will only be evaluated if\n * the first effect fails. This provides a way to recover from errors by\n * specifying an alternative path of execution.\n *\n * The error type of the resulting effect will be that of the fallback effect,\n * as the first effect's error is replaced when the fallback is executed.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const success = Effect.succeed(\"success\")\n * const failure = Effect.fail(\"failure\")\n * const fallback = Effect.succeed(\"fallback\")\n *\n * // Try the success effect first, fallback is not used\n * const program1 = Effect.orElse(success, () => fallback)\n * console.log(Effect.runSync(program1))\n * // Output: \"success\"\n *\n * // Try the failure effect first, fallback is used\n * const program2 = Effect.orElse(failure, () => fallback)\n * console.log(Effect.runSync(program2))\n * // Output: \"fallback\"\n * ```\n *\n * @see {@link catchAll} if you need to access the error in the fallback effect.\n *\n * @since 2.0.0\n * @category Fallback\n */\nexport const orElse: {\n  /**\n   * Attempts one effect, and if it fails, falls back to another effect.\n   *\n   * **Details**\n   *\n   * This function allows you to try executing an effect, and if it fails\n   * (produces an error), a fallback effect is executed instead. The fallback\n   * effect is defined as a lazy argument, meaning it will only be evaluated if\n   * the first effect fails. This provides a way to recover from errors by\n   * specifying an alternative path of execution.\n   *\n   * The error type of the resulting effect will be that of the fallback effect,\n   * as the first effect's error is replaced when the fallback is executed.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const success = Effect.succeed(\"success\")\n   * const failure = Effect.fail(\"failure\")\n   * const fallback = Effect.succeed(\"fallback\")\n   *\n   * // Try the success effect first, fallback is not used\n   * const program1 = Effect.orElse(success, () => fallback)\n   * console.log(Effect.runSync(program1))\n   * // Output: \"success\"\n   *\n   * // Try the failure effect first, fallback is used\n   * const program2 = Effect.orElse(failure, () => fallback)\n   * console.log(Effect.runSync(program2))\n   * // Output: \"fallback\"\n   * ```\n   *\n   * @see {@link catchAll} if you need to access the error in the fallback effect.\n   *\n   * @since 2.0.0\n   * @category Fallback\n   */\n  <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>\n  /**\n   * Attempts one effect, and if it fails, falls back to another effect.\n   *\n   * **Details**\n   *\n   * This function allows you to try executing an effect, and if it fails\n   * (produces an error), a fallback effect is executed instead. The fallback\n   * effect is defined as a lazy argument, meaning it will only be evaluated if\n   * the first effect fails. This provides a way to recover from errors by\n   * specifying an alternative path of execution.\n   *\n   * The error type of the resulting effect will be that of the fallback effect,\n   * as the first effect's error is replaced when the fallback is executed.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const success = Effect.succeed(\"success\")\n   * const failure = Effect.fail(\"failure\")\n   * const fallback = Effect.succeed(\"fallback\")\n   *\n   * // Try the success effect first, fallback is not used\n   * const program1 = Effect.orElse(success, () => fallback)\n   * console.log(Effect.runSync(program1))\n   * // Output: \"success\"\n   *\n   * // Try the failure effect first, fallback is used\n   * const program2 = Effect.orElse(failure, () => fallback)\n   * console.log(Effect.runSync(program2))\n   * // Output: \"fallback\"\n   * ```\n   *\n   * @see {@link catchAll} if you need to access the error in the fallback effect.\n   *\n   * @since 2.0.0\n   * @category Fallback\n   */\n  <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>\n} = core.orElse\n\n/**\n * Replaces the failure of an effect with a custom failure value.\n *\n * **Details**\n *\n * This function allows you to handle the failure of an effect by replacing it\n * with a predefined failure value. If the effect fails, the new failure value\n * provided by the `evaluate` function will be returned instead of the original\n * failure. If the effect succeeds, the original success value is returned\n * unchanged.\n *\n * **When to Use**\n *\n * This is particularly useful when you want to standardize error handling or\n * provide a consistent failure value for specific operations. It simplifies\n * error management by ensuring that all failures are replaced with a controlled\n * alternative.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const validate = (age: number): Effect.Effect<number, string> => {\n *   if (age < 0) {\n *     return Effect.fail(\"NegativeAgeError\")\n *   } else if (age < 18) {\n *     return Effect.fail(\"IllegalAgeError\")\n *   } else {\n *     return Effect.succeed(age)\n *   }\n * }\n *\n * const program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n *\n * console.log(Effect.runSyncExit(program))\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n * // }\n * ```\n *\n * @see {@link mapError} if you need to access the error to transform it.\n *\n * @since 2.0.0\n * @category Fallback\n */\nexport const orElseFail: {\n  /**\n   * Replaces the failure of an effect with a custom failure value.\n   *\n   * **Details**\n   *\n   * This function allows you to handle the failure of an effect by replacing it\n   * with a predefined failure value. If the effect fails, the new failure value\n   * provided by the `evaluate` function will be returned instead of the original\n   * failure. If the effect succeeds, the original success value is returned\n   * unchanged.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful when you want to standardize error handling or\n   * provide a consistent failure value for specific operations. It simplifies\n   * error management by ensuring that all failures are replaced with a controlled\n   * alternative.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const validate = (age: number): Effect.Effect<number, string> => {\n   *   if (age < 0) {\n   *     return Effect.fail(\"NegativeAgeError\")\n   *   } else if (age < 18) {\n   *     return Effect.fail(\"IllegalAgeError\")\n   *   } else {\n   *     return Effect.succeed(age)\n   *   }\n   * }\n   *\n   * const program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n   *\n   * console.log(Effect.runSyncExit(program))\n   * // Output:\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n   * // }\n   * ```\n   *\n   * @see {@link mapError} if you need to access the error to transform it.\n   *\n   * @since 2.0.0\n   * @category Fallback\n   */\n  <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>\n  /**\n   * Replaces the failure of an effect with a custom failure value.\n   *\n   * **Details**\n   *\n   * This function allows you to handle the failure of an effect by replacing it\n   * with a predefined failure value. If the effect fails, the new failure value\n   * provided by the `evaluate` function will be returned instead of the original\n   * failure. If the effect succeeds, the original success value is returned\n   * unchanged.\n   *\n   * **When to Use**\n   *\n   * This is particularly useful when you want to standardize error handling or\n   * provide a consistent failure value for specific operations. It simplifies\n   * error management by ensuring that all failures are replaced with a controlled\n   * alternative.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const validate = (age: number): Effect.Effect<number, string> => {\n   *   if (age < 0) {\n   *     return Effect.fail(\"NegativeAgeError\")\n   *   } else if (age < 18) {\n   *     return Effect.fail(\"IllegalAgeError\")\n   *   } else {\n   *     return Effect.succeed(age)\n   *   }\n   * }\n   *\n   * const program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n   *\n   * console.log(Effect.runSyncExit(program))\n   * // Output:\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n   * // }\n   * ```\n   *\n   * @see {@link mapError} if you need to access the error to transform it.\n   *\n   * @since 2.0.0\n   * @category Fallback\n   */\n  <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>\n} = effect.orElseFail\n\n/**\n * Ensures the effect always succeeds by replacing failures with a default\n * success value.\n *\n * **Details**\n *\n * This function transforms an effect that may fail into one that cannot fail by\n * replacing any failure with a provided success value. If the original effect\n * fails, the failure is \"swallowed,\" and the specified success value is\n * returned instead. If the original effect succeeds, its value remains\n * unchanged.\n *\n * **When to Use**\n *\n * This is especially useful for providing default values in case of failure,\n * ensuring that an effect always completes successfully. By using this\n * function, you can avoid the need for complex error handling and guarantee a\n * fallback result.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const validate = (age: number): Effect.Effect<number, string> => {\n *   if (age < 0) {\n *     return Effect.fail(\"NegativeAgeError\")\n *   } else if (age < 18) {\n *     return Effect.fail(\"IllegalAgeError\")\n *   } else {\n *     return Effect.succeed(age)\n *   }\n * }\n *\n * const program = Effect.orElseSucceed(validate(-1), () => 18)\n *\n * console.log(Effect.runSyncExit(program))\n * // Output:\n * // { _id: 'Exit', _tag: 'Success', value: 18 }\n * ```\n *\n * @since 2.0.0\n * @category Fallback\n */\nexport const orElseSucceed: {\n  /**\n   * Ensures the effect always succeeds by replacing failures with a default\n   * success value.\n   *\n   * **Details**\n   *\n   * This function transforms an effect that may fail into one that cannot fail by\n   * replacing any failure with a provided success value. If the original effect\n   * fails, the failure is \"swallowed,\" and the specified success value is\n   * returned instead. If the original effect succeeds, its value remains\n   * unchanged.\n   *\n   * **When to Use**\n   *\n   * This is especially useful for providing default values in case of failure,\n   * ensuring that an effect always completes successfully. By using this\n   * function, you can avoid the need for complex error handling and guarantee a\n   * fallback result.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const validate = (age: number): Effect.Effect<number, string> => {\n   *   if (age < 0) {\n   *     return Effect.fail(\"NegativeAgeError\")\n   *   } else if (age < 18) {\n   *     return Effect.fail(\"IllegalAgeError\")\n   *   } else {\n   *     return Effect.succeed(age)\n   *   }\n   * }\n   *\n   * const program = Effect.orElseSucceed(validate(-1), () => 18)\n   *\n   * console.log(Effect.runSyncExit(program))\n   * // Output:\n   * // { _id: 'Exit', _tag: 'Success', value: 18 }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Fallback\n   */\n  <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>\n  /**\n   * Ensures the effect always succeeds by replacing failures with a default\n   * success value.\n   *\n   * **Details**\n   *\n   * This function transforms an effect that may fail into one that cannot fail by\n   * replacing any failure with a provided success value. If the original effect\n   * fails, the failure is \"swallowed,\" and the specified success value is\n   * returned instead. If the original effect succeeds, its value remains\n   * unchanged.\n   *\n   * **When to Use**\n   *\n   * This is especially useful for providing default values in case of failure,\n   * ensuring that an effect always completes successfully. By using this\n   * function, you can avoid the need for complex error handling and guarantee a\n   * fallback result.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const validate = (age: number): Effect.Effect<number, string> => {\n   *   if (age < 0) {\n   *     return Effect.fail(\"NegativeAgeError\")\n   *   } else if (age < 18) {\n   *     return Effect.fail(\"IllegalAgeError\")\n   *   } else {\n   *     return Effect.succeed(age)\n   *   }\n   * }\n   *\n   * const program = Effect.orElseSucceed(validate(-1), () => 18)\n   *\n   * console.log(Effect.runSyncExit(program))\n   * // Output:\n   * // { _id: 'Exit', _tag: 'Success', value: 18 }\n   * ```\n   *\n   * @since 2.0.0\n   * @category Fallback\n   */\n  <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>\n} = effect.orElseSucceed\n\n/**\n * Runs a sequence of effects and returns the result of the first successful\n * one.\n *\n * **Details**\n *\n * This function allows you to execute a collection of effects in sequence,\n * stopping at the first success. If an effect succeeds, its result is\n * immediately returned, and no further effects in the sequence are executed.\n * However, if all the effects fail, the function will return the error of the\n * last effect.\n *\n * The execution is sequential, meaning that effects are evaluated one at a time\n * in the order they are provided. This ensures predictable behavior and avoids\n * unnecessary computations.\n *\n * If the collection of effects is empty, an `IllegalArgumentException` is\n * thrown, indicating that the operation is invalid without any effects to try.\n *\n * **When to Use**\n *\n * This is particularly useful when you have multiple fallback strategies or\n * alternative sources to obtain a result, such as attempting multiple APIs,\n * retrieving configurations, or accessing resources in a prioritized manner.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * interface Config {\n *   host: string\n *   port: number\n *   apiKey: string\n * }\n *\n * // Create a configuration object with sample values\n * const makeConfig = (name: string): Config => ({\n *   host: `${name}.example.com`,\n *   port: 8080,\n *   apiKey: \"12345-abcde\"\n * })\n *\n * // Simulate retrieving configuration from a remote node\n * const remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n *   Effect.gen(function* () {\n *     // Simulate node3 being the only one with available config\n *     if (name === \"node3\") {\n *       yield* Console.log(`Config for ${name} found`)\n *       return makeConfig(name)\n *     } else {\n *       yield* Console.log(`Unavailable config for ${name}`)\n *       return yield* Effect.fail(new Error(`Config not found for ${name}`))\n *     }\n *   })\n *\n * // Define the master configuration and potential fallback nodes\n * const masterConfig = remoteConfig(\"master\")\n * const nodeConfigs = [\"node1\", \"node2\", \"node3\", \"node4\"].map(remoteConfig)\n *\n * // Attempt to find a working configuration,\n * // starting with the master and then falling back to other nodes\n * const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n *\n * // Run the effect to retrieve the configuration\n * const result = Effect.runSync(config)\n *\n * console.log(result)\n * // Output:\n * // Unavailable config for master\n * // Unavailable config for node1\n * // Unavailable config for node2\n * // Config for node3 found\n * // { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }\n * ```\n *\n * @since 2.0.0\n * @category Fallback\n */\nexport const firstSuccessOf: <Eff extends Effect<any, any, any>>(\n  effects: Iterable<Eff>\n) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>> = effect.firstSuccessOf\n\n/**\n * Retrieves the `Random` service from the context.\n *\n * @since 2.0.0\n * @category Random\n */\nexport const random: Effect<Random.Random> = effect.random\n\n/**\n * Retrieves the `Random` service from the context and uses it to run the\n * specified effect.\n *\n * @since 2.0.0\n * @category Random\n */\nexport const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R> =\n  defaultServices.randomWith\n\n/**\n * Executes the specified effect with the specified implementation of the\n * `Random` service.\n *\n * @since 2.0.0\n * @category Random\n */\nexport const withRandom: {\n  /**\n   * Executes the specified effect with the specified implementation of the\n   * `Random` service.\n   *\n   * @since 2.0.0\n   * @category Random\n   */\n  <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Executes the specified effect with the specified implementation of the\n   * `Random` service.\n   *\n   * @since 2.0.0\n   * @category Random\n   */\n  <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>\n} = defaultServices.withRandom\n\n/**\n * Executes the specified effect with a `Random` service that cycles through\n * a provided array of values.\n *\n * @example\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * Effect.gen(function*() {\n *   console.log(yield* Random.next) // 0.2\n *   console.log(yield* Random.next) // 0.5\n *   console.log(yield* Random.next) // 0.8\n * }).pipe(Effect.withRandomFixed([0.2, 0.5, 0.8]))\n * ```\n *\n * @since 3.11.0\n * @category Random\n */\nexport const withRandomFixed: {\n  /**\n   * Executes the specified effect with a `Random` service that cycles through\n   * a provided array of values.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * Effect.gen(function*() {\n   *   console.log(yield* Random.next) // 0.2\n   *   console.log(yield* Random.next) // 0.5\n   *   console.log(yield* Random.next) // 0.8\n   * }).pipe(Effect.withRandomFixed([0.2, 0.5, 0.8]))\n   * ```\n   *\n   * @since 3.11.0\n   * @category Random\n   */\n  <T extends RA.NonEmptyArray<any>>(values: T): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Executes the specified effect with a `Random` service that cycles through\n   * a provided array of values.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Random } from \"effect\"\n   *\n   * Effect.gen(function*() {\n   *   console.log(yield* Random.next) // 0.2\n   *   console.log(yield* Random.next) // 0.5\n   *   console.log(yield* Random.next) // 0.8\n   * }).pipe(Effect.withRandomFixed([0.2, 0.5, 0.8]))\n   * ```\n   *\n   * @since 3.11.0\n   * @category Random\n   */\n  <T extends RA.NonEmptyArray<any>, A, E, R>(effect: Effect<A, E, R>, values: T): Effect<A, E, R>\n} = dual(\n  2,\n  <T extends RA.NonEmptyArray<any>, A, E, R>(effect: Effect<A, E, R>, values: T): Effect<A, E, R> =>\n    withRandom(effect, Random.fixed(values))\n)\n\n/**\n * Sets the implementation of the `Random` service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n * @category Random\n */\nexport const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope> =\n  fiberRuntime.withRandomScoped\n\n/**\n * Returns an effect that accesses the runtime, which can be used to (unsafely)\n * execute tasks.\n *\n * **When to Use**\n *\n * This is useful for integration with legacy code that must call back into\n * Effect code.\n *\n * @since 2.0.0\n * @category Runtime\n */\nexport const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R> = runtime_.runtime\n\n/**\n * Retrieves an effect that succeeds with the current runtime flags, which\n * govern behavior and features of the runtime system.\n *\n * @since 2.0.0\n * @category Runtime\n */\nexport const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags> = core.runtimeFlags\n\n/**\n * @since 2.0.0\n * @category Runtime\n */\nexport const patchRuntimeFlags: (patch: RuntimeFlagsPatch.RuntimeFlagsPatch) => Effect<void> = core.updateRuntimeFlags\n\n/**\n * @since 2.0.0\n * @category Runtime\n */\nexport const withRuntimeFlagsPatch: {\n  /**\n   * @since 2.0.0\n   * @category Runtime\n   */\n  (update: RuntimeFlagsPatch.RuntimeFlagsPatch): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Runtime\n   */\n  <A, E, R>(self: Effect<A, E, R>, update: RuntimeFlagsPatch.RuntimeFlagsPatch): Effect<A, E, R>\n} = core.withRuntimeFlags\n\n/**\n * @since 2.0.0\n * @category Runtime\n */\nexport const withRuntimeFlagsPatchScoped: (\n  update: RuntimeFlagsPatch.RuntimeFlagsPatch\n) => Effect<void, never, Scope.Scope> = fiberRuntime.withRuntimeFlagsScoped\n\n/**\n * Tags each metric in an effect with specific key-value pairs.\n *\n * **Details**\n *\n * This function allows you to tag all metrics in an effect with a set of\n * key-value pairs or a single key-value pair. Tags help you add metadata to\n * metrics, making it easier to filter and categorize them in monitoring\n * systems. The provided tags will apply to all metrics generated within the\n * effect's scope.\n *\n * @since 2.0.0\n * @category Metrics\n */\nexport const tagMetrics: {\n  /**\n   * Tags each metric in an effect with specific key-value pairs.\n   *\n   * **Details**\n   *\n   * This function allows you to tag all metrics in an effect with a set of\n   * key-value pairs or a single key-value pair. Tags help you add metadata to\n   * metrics, making it easier to filter and categorize them in monitoring\n   * systems. The provided tags will apply to all metrics generated within the\n   * effect's scope.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Tags each metric in an effect with specific key-value pairs.\n   *\n   * **Details**\n   *\n   * This function allows you to tag all metrics in an effect with a set of\n   * key-value pairs or a single key-value pair. Tags help you add metadata to\n   * metrics, making it easier to filter and categorize them in monitoring\n   * systems. The provided tags will apply to all metrics generated within the\n   * effect's scope.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Tags each metric in an effect with specific key-value pairs.\n   *\n   * **Details**\n   *\n   * This function allows you to tag all metrics in an effect with a set of\n   * key-value pairs or a single key-value pair. Tags help you add metadata to\n   * metrics, making it easier to filter and categorize them in monitoring\n   * systems. The provided tags will apply to all metrics generated within the\n   * effect's scope.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>\n  /**\n   * Tags each metric in an effect with specific key-value pairs.\n   *\n   * **Details**\n   *\n   * This function allows you to tag all metrics in an effect with a set of\n   * key-value pairs or a single key-value pair. Tags help you add metadata to\n   * metrics, making it easier to filter and categorize them in monitoring\n   * systems. The provided tags will apply to all metrics generated within the\n   * effect's scope.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>\n} = effect.tagMetrics\n\n/**\n * Adds labels to metrics within an effect using `MetricLabel` objects.\n *\n * **Details**\n *\n * This function allows you to label metrics using `MetricLabel` objects. Labels\n * help add structured metadata to metrics for categorization and filtering in\n * monitoring systems. The provided labels will apply to all metrics within the\n * effect's execution.\n *\n * @since 2.0.0\n * @category Metrics\n */\nexport const labelMetrics: {\n  /**\n   * Adds labels to metrics within an effect using `MetricLabel` objects.\n   *\n   * **Details**\n   *\n   * This function allows you to label metrics using `MetricLabel` objects. Labels\n   * help add structured metadata to metrics for categorization and filtering in\n   * monitoring systems. The provided labels will apply to all metrics within the\n   * effect's execution.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Adds labels to metrics within an effect using `MetricLabel` objects.\n   *\n   * **Details**\n   *\n   * This function allows you to label metrics using `MetricLabel` objects. Labels\n   * help add structured metadata to metrics for categorization and filtering in\n   * monitoring systems. The provided labels will apply to all metrics within the\n   * effect's execution.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>\n} = effect.labelMetrics\n\n/**\n * Tags metrics within a scope with a specific key-value pair.\n *\n * **Details**\n *\n * This function tags all metrics within a scope with the provided key-value\n * pair. Once the scope is closed, the tag is automatically removed. This is\n * useful for applying temporary context-specific tags to metrics during scoped\n * operations.\n *\n * @since 2.0.0\n * @category Metrics\n */\nexport const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope> =\n  fiberRuntime.tagMetricsScoped\n\n/**\n * Adds labels to metrics within a scope using `MetricLabel` objects.\n *\n * **Details**\n *\n * This function allows you to apply labels to all metrics generated within a\n * specific scope using an array of `MetricLabel` objects. These labels provide\n * additional metadata to metrics, which can be used for categorization,\n * filtering, or monitoring purposes. The labels are scoped and will be removed\n * automatically once the scope is closed, ensuring they are only applied\n * temporarily within the defined context.\n *\n * @since 2.0.0\n * @category Metrics\n */\nexport const labelMetricsScoped: (\n  labels: ReadonlyArray<MetricLabel.MetricLabel>\n) => Effect<void, never, Scope.Scope> = fiberRuntime.labelMetricsScoped\n\n/**\n * Retrieves the metric labels associated with the current scope.\n *\n * @since 2.0.0\n * @category Metrics\n */\nexport const metricLabels: Effect<ReadonlyArray<MetricLabel.MetricLabel>> = core.metricLabels\n\n/**\n * Associates a metric with the current effect, updating it as the effect progresses.\n *\n * @since 2.0.0\n * @category Metrics\n */\nexport const withMetric: {\n  /**\n   * Associates a metric with the current effect, updating it as the effect progresses.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Associates a metric with the current effect, updating it as the effect progresses.\n   *\n   * @since 2.0.0\n   * @category Metrics\n   */\n  <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>\n} = effect.withMetric\n\n/**\n * @category Semaphore\n * @since 2.0.0\n */\nexport interface Permit {\n  readonly index: number\n}\n\n/**\n * A semaphore is a synchronization mechanism used to manage access to a shared\n * resource. In Effect, semaphores help control resource access or coordinate\n * tasks within asynchronous, concurrent operations.\n *\n * A semaphore acts as a generalized mutex, allowing a set number of permits to\n * be held and released concurrently. Permits act like tickets, giving tasks or\n * fibers controlled access to a shared resource. When no permits are available,\n * tasks trying to acquire one will wait until a permit is released.\n *\n * @category Semaphore\n * @since 2.0.0\n */\nexport interface Semaphore {\n  /**\n   * Adjusts the number of permits available in the semaphore.\n   */\n  resize(permits: number): Effect<void>\n\n  /**\n   * Runs an effect with the given number of permits and releases the permits\n   * when the effect completes.\n   *\n   * **Details**\n   *\n   * This function acquires the specified number of permits before executing\n   * the provided effect. Once the effect finishes, the permits are released.\n   * If insufficient permits are available, the function will wait until they\n   * are released by other tasks.\n   */\n  withPermits(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  /**\n   * Runs an effect only if the specified number of permits are immediately\n   * available.\n   *\n   * **Details**\n   *\n   * This function attempts to acquire the specified number of permits. If they\n   * are available, it runs the effect and releases the permits after the effect\n   * completes. If permits are not available, the effect does not execute, and\n   * the result is `Option.none`.\n   */\n  withPermitsIfAvailable(permits: number): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>\n\n  /**\n   * Acquires the specified number of permits and returns the resulting\n   * available permits, suspending the task if they are not yet available.\n   * Concurrent pending `take` calls are processed in a first-in, first-out manner.\n   */\n  take(permits: number): Effect<number>\n\n  /**\n   * Releases the specified number of permits and returns the resulting\n   * available permits.\n   */\n  release(permits: number): Effect<number>\n\n  /**\n   * Releases all permits held by this semaphore and returns the resulting available permits.\n   */\n  releaseAll: Effect<number>\n}\n\n/**\n * Unsafely creates a new Semaphore.\n *\n * @since 2.0.0\n * @category Semaphore\n */\nexport const unsafeMakeSemaphore: (permits: number) => Semaphore = circular.unsafeMakeSemaphore\n\n/**\n * Creates a new semaphore with the specified number of permits.\n *\n * **Details**\n *\n * This function initializes a semaphore that controls concurrent access to a\n * shared resource. The number of permits determines how many tasks can access\n * the resource concurrently.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // Create a semaphore with 3 permits\n * const mutex = Effect.makeSemaphore(3)\n * ```\n *\n * @since 2.0.0\n * @category Semaphore\n */\nexport const makeSemaphore: (permits: number) => Effect<Semaphore> = circular.makeSemaphore\n\n/**\n * A `Latch` is a synchronization primitive that allows you to control the\n * execution of fibers based on an open or closed state. It acts as a gate,\n * where fibers can wait for the latch to open before proceeding.\n *\n * **Details**\n *\n * A `Latch` can be in one of two states: open or closed. Fibers can:\n * - Wait for the latch to open using `await`.\n * - Proceed only when the latch is open using `whenOpen`.\n * - Open the latch to release all waiting fibers using `open`.\n * - Close the latch to block fibers using `close`.\n *\n * Additionally, fibers can be released without changing the state of the latch\n * using `release`.\n *\n * @category Latch\n * @since 3.8.0\n */\nexport interface Latch extends Effect<void> {\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly open: Effect<void>\n\n  /**\n   * Opens the latch, releasing all fibers waiting on it.\n   *\n   * **Details**\n   *\n   * Once the latch is opened, it remains open. Any fibers waiting on `await`\n   * will be released and can continue execution.\n   */\n  readonly unsafeOpen: () => void\n\n  /**\n   * Releases all fibers waiting on the latch without opening it.\n   *\n   * **Details**\n   *\n   * This function lets waiting fibers proceed without permanently changing the\n   * state of the latch.\n   */\n  readonly release: Effect<void>\n\n  /**\n   * Waits for the latch to be opened.\n   *\n   * **Details**\n   *\n   * If the latch is already open, this effect completes immediately. Otherwise,\n   * it suspends the fiber until the latch is opened.\n   */\n  readonly await: Effect<void>\n\n  /**\n   * Closes the latch, blocking fibers from proceeding.\n   *\n   * **Details**\n   *\n   * This operation puts the latch into a closed state, requiring it to be\n   * reopened before waiting fibers can proceed.\n   */\n  readonly close: Effect<void>\n\n  /**\n   * Unsafely closes the latch, blocking fibers without effect guarantees.\n   *\n   * **Details**\n   *\n   * Use this operation cautiously, as it does not run within an effect context\n   * and bypasses runtime guarantees.\n   */\n  readonly unsafeClose: () => void\n\n  /**\n   * Runs the given effect only when the latch is open.\n   *\n   * **Details**\n   *\n   * This function ensures that the provided effect executes only if the latch\n   * is open. If the latch is closed, the fiber will wait until it opens.\n   */\n  readonly whenOpen: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: LatchUnify<this>\n  readonly [Unify.ignoreSymbol]?: LatchUnifyIgnore\n}\n\n/**\n * @category Models\n * @since 3.8.0\n */\nexport interface LatchUnify<A extends { [Unify.typeSymbol]?: any }> extends EffectUnify<A> {\n  Latch?: () => Latch\n}\n\n/**\n * @category Models\n * @since 3.8.0\n */\nexport interface LatchUnifyIgnore extends EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @category Latch\n * @since 3.8.0\n */\nexport const unsafeMakeLatch: (open?: boolean | undefined) => Latch = circular.unsafeMakeLatch\n\n/**\n * Creates a new `Latch`, starting in the specified state.\n *\n * **Details**\n *\n * This function initializes a `Latch` safely, ensuring proper runtime\n * guarantees. By default, the latch starts in the closed state.\n *\n * **Example**\n *\n * ```ts\n * import { Console, Effect } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   // Create a latch, starting in the closed state\n *   const latch = yield* Effect.makeLatch(false)\n *\n *   // Fork a fiber that logs \"open sesame\" when the latch is opened\n *   const fiber = yield* Console.log(\"open sesame\").pipe(\n *     latch.whenOpen,\n *     Effect.fork\n *   )\n *\n *   yield* Effect.sleep(\"1 second\")\n *\n *   // Open the latch\n *   yield* latch.open\n *   yield* fiber.await\n * })\n *\n * Effect.runFork(program)\n * // Output: open sesame (after 1 second)\n * ```\n *\n * @category Latch\n * @since 3.8.0\n */\nexport const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never> = circular.makeLatch\n\n/**\n * Runs an effect in the background, returning a fiber that can be observed or\n * interrupted.\n *\n * Unless you specifically need a `Promise` or synchronous operation, `runFork`\n * is a good default choice.\n *\n * **Details**\n *\n * This function is the foundational way to execute an effect in the background.\n * It creates a \"fiber,\" a lightweight, cooperative thread of execution that can\n * be observed (to access its result), interrupted, or joined. Fibers are useful\n * for concurrent programming and allow effects to run independently of the main\n * program flow.\n *\n * Once the effect is running in a fiber, you can monitor its progress, cancel\n * it if necessary, or retrieve its result when it completes. If the effect\n * fails, the fiber will propagate the failure, which you can observe and\n * handle.\n *\n * **When to Use**\n *\n * Use this function when you need to run an effect in the background,\n * especially if the effect is long-running or performs periodic tasks. It's\n * suitable for tasks that need to run independently but might still need\n * observation or management, like logging, monitoring, or scheduled tasks.\n *\n * This function is ideal if you don't need the result immediately or if the\n * effect is part of a larger concurrent workflow.\n *\n * **Example** (Running an Effect in the Background)\n *\n * ```ts\n * import { Effect, Console, Schedule, Fiber } from \"effect\"\n *\n * //       Effect<number, never, never>\n * //      \n * const program = Effect.repeat(\n *   Console.log(\"running...\"),\n *   Schedule.spaced(\"200 millis\")\n * )\n *\n * //       RuntimeFiber<number, never>\n * //      \n * const fiber = Effect.runFork(program)\n *\n * setTimeout(() => {\n *   Effect.runFork(Fiber.interrupt(fiber))\n * }, 500)\n * ```\n *\n * @since 2.0.0\n * @category Running Effects\n */\nexport const runFork: <A, E>(\n  effect: Effect<A, E>,\n  options?: Runtime.RunForkOptions\n) => Fiber.RuntimeFiber<A, E> = runtime_.unsafeForkEffect\n\n/**\n * Executes an effect asynchronously and handles the result using a callback.\n *\n * **Details**\n *\n * This function runs an effect asynchronously and passes the result (`Exit`) to\n * a specified callback. The callback is invoked with the outcome of the effect:\n * - On success, the callback receives the successful result.\n * - On failure, the callback receives the failure information.\n *\n * **When to Use**\n *\n * This function is effectful and should only be invoked at the edges of your\n * program.\n *\n * @since 2.0.0\n * @category Running Effects\n */\nexport const runCallback: <A, E>(\n  effect: Effect<A, E>,\n  options?: Runtime.RunCallbackOptions<A, E> | undefined\n) => Runtime.Cancel<A, E> = runtime_.unsafeRunEffect\n\n/**\n * Executes an effect and returns the result as a `Promise`.\n *\n * **Details**\n *\n * This function runs an effect and converts its result into a `Promise`. If the\n * effect succeeds, the `Promise` will resolve with the successful result. If\n * the effect fails, the `Promise` will reject with an error, which includes the\n * failure details of the effect.\n *\n * The optional `options` parameter allows you to pass an `AbortSignal` for\n * cancellation, enabling more fine-grained control over asynchronous tasks.\n *\n * **When to Use**\n *\n * Use this function when you need to execute an effect and work with its result\n * in a promise-based system, such as when integrating with third-party\n * libraries that expect `Promise` results.\n *\n * **Example** (Running a Successful Effect as a Promise)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * Effect.runPromise(Effect.succeed(1)).then(console.log)\n * // Output: 1\n * ```\n *\n * **Example** (Handling a Failing Effect as a Rejected Promise)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * Effect.runPromise(Effect.fail(\"my error\")).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: my error\n * ```\n *\n * @see {@link runPromiseExit} for a version that returns an `Exit` type instead\n * of rejecting.\n *\n * @since 2.0.0\n * @category Running Effects\n */\nexport const runPromise: <A, E>(\n  effect: Effect<A, E, never>,\n  options?: { readonly signal?: AbortSignal | undefined } | undefined\n) => Promise<A> = runtime_.unsafeRunPromiseEffect\n\n/**\n * Runs an effect and returns a `Promise` that resolves to an `Exit`,\n * representing the outcome.\n *\n * **Details**\n *\n * This function executes an effect and resolves to an `Exit` object. The `Exit`\n * type provides detailed information about the result of the effect:\n * - If the effect succeeds, the `Exit` will be of type `Success` and include\n *   the value produced by the effect.\n * - If the effect fails, the `Exit` will be of type `Failure` and contain a\n *   `Cause` object, detailing the failure.\n *\n * Using this function allows you to examine both successful results and failure\n * cases in a unified way, while still leveraging `Promise` for handling the\n * asynchronous behavior of the effect.\n *\n * **When to Use**\n *\n * Use this function when you need to understand the outcome of an effect,\n * whether it succeeded or failed, and want to work with this result using\n * `Promise` syntax. This is particularly useful when integrating with systems\n * that rely on promises but need more detailed error handling than a simple\n * rejection.\n *\n * **Example** (Handling Results as Exit)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * // Execute a successful effect and get the Exit result as a Promise\n * Effect.runPromiseExit(Effect.succeed(1)).then(console.log)\n * // Output:\n * // {\n * //   _id: \"Exit\",\n * //   _tag: \"Success\",\n * //   value: 1\n * // }\n *\n * // Execute a failing effect and get the Exit result as a Promise\n * Effect.runPromiseExit(Effect.fail(\"my error\")).then(console.log)\n * // Output:\n * // {\n * //   _id: \"Exit\",\n * //   _tag: \"Failure\",\n * //   cause: {\n * //     _id: \"Cause\",\n * //     _tag: \"Fail\",\n * //     failure: \"my error\"\n * //   }\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Running Effects\n */\nexport const runPromiseExit: <A, E>(\n  effect: Effect<A, E, never>,\n  options?: { readonly signal?: AbortSignal } | undefined\n) => Promise<Exit.Exit<A, E>> = runtime_.unsafeRunPromiseExitEffect\n\n/**\n * Executes an effect synchronously, running it immediately and returning the\n * result.\n *\n * **Details**\n *\n * This function evaluates the provided effect synchronously, returning its\n * result directly. It is ideal for effects that do not fail or include\n * asynchronous operations. If the effect does fail or involves async tasks, it\n * will throw an error. Execution stops at the point of failure or asynchronous\n * operation, making it unsuitable for effects that require asynchronous\n * handling.\n *\n * **Important**: Attempting to run effects that involve asynchronous operations\n * or failures will result in exceptions being thrown, so use this function with\n * care for purely synchronous and error-free effects.\n *\n * **When to Use**\n *\n * Use this function when:\n * - You are sure that the effect will not fail or involve asynchronous\n *   operations.\n * - You need a direct, synchronous result from the effect.\n * - You are working within a context where asynchronous effects are not\n *   allowed.\n *\n * Avoid using this function for effects that can fail or require asynchronous\n * handling. For such cases, consider using {@link runPromise} or\n * {@link runSyncExit}.\n *\n * **Example** (Synchronous Logging)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const program = Effect.sync(() => {\n *   console.log(\"Hello, World!\")\n *   return 1\n * })\n *\n * const result = Effect.runSync(program)\n * // Output: Hello, World!\n *\n * console.log(result)\n * // Output: 1\n * ```\n *\n * **Example** (Incorrect Usage with Failing or Async Effects)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * try {\n *   // Attempt to run an effect that fails\n *   Effect.runSync(Effect.fail(\"my error\"))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) Error: my error\n *\n * try {\n *   // Attempt to run an effect that involves async work\n *   Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n * ```\n *\n * @see {@link runSyncExit} for a version that returns an `Exit` type instead of\n * throwing an error.\n *\n * @since 2.0.0\n * @category Running Effects\n */\nexport const runSync: <A, E>(effect: Effect<A, E>) => A = runtime_.unsafeRunSyncEffect\n\n/**\n * Runs an effect synchronously and returns the result as an `Exit` type.\n *\n * **Details**\n *\n * This function executes the provided effect synchronously and returns an `Exit`\n * type that encapsulates the outcome of the effect:\n * - If the effect succeeds, the result is wrapped in a `Success`.\n * - If the effect fails, it returns a `Failure` containing a `Cause` that explains\n *   the failure.\n *\n * If the effect involves asynchronous operations, this function will return a `Failure`\n * with a `Die` cause, indicating that it cannot resolve the effect synchronously.\n * This makes the function suitable for use only with effects that are synchronous\n * in nature.\n *\n * **When to Use**\n *\n * Use this function when:\n * - You want to handle both success and failure outcomes in a structured way using the `Exit` type.\n * - You are working with effects that are purely synchronous and do not involve asynchronous operations.\n * - You need to debug or inspect failures, including their causes, in a detailed manner.\n *\n * Avoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.\n *\n * **Example** (Handling Results as Exit)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * console.log(Effect.runSyncExit(Effect.succeed(1)))\n * // Output:\n * // {\n * //   _id: \"Exit\",\n * //   _tag: \"Success\",\n * //   value: 1\n * // }\n *\n * console.log(Effect.runSyncExit(Effect.fail(\"my error\")))\n * // Output:\n * // {\n * //   _id: \"Exit\",\n * //   _tag: \"Failure\",\n * //   cause: {\n * //     _id: \"Cause\",\n * //     _tag: \"Fail\",\n * //     failure: \"my error\"\n * //   }\n * // }\n * ```\n *\n * **Example** (Asynchronous Operation Resulting in Die)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Die',\n * //     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {\n * //       fiber: [FiberRuntime],\n * //       _tag: 'AsyncFiberException',\n * //       name: 'AsyncFiberException'\n * //     }\n * //   }\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Running Effects\n */\nexport const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E> = runtime_.unsafeRunSyncExitEffect\n\n/**\n * Combines multiple effects and accumulates both successes and failures.\n *\n * **Details**\n *\n * This function allows you to combine multiple effects, continuing through all\n * effects even if some of them fail. Unlike other functions that stop execution\n * upon encountering an error, this function collects all errors into a `Cause`.\n * The final result includes all successes and the accumulated failures.\n *\n * By default, effects are executed sequentially, but you can control\n * concurrency and batching behavior using the `options` parameter. This\n * provides flexibility in scenarios where you want to maximize performance or\n * ensure specific ordering.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * const task1 = Console.log(\"task1\").pipe(Effect.as(1))\n * const task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n * const task3 = Console.log(\"task2\").pipe(Effect.as(3))\n * const task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n *\n * const program = task1.pipe(\n *   Effect.validate(task2),\n *   Effect.validate(task3),\n *   Effect.validate(task4)\n * )\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // task1\n * // task2\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Sequential',\n * //     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n * //     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n * //   }\n * // }\n * ```\n *\n * @see {@link zip} for a version that stops at the first error.\n *\n * @since 2.0.0\n * @category Error Accumulation\n */\nexport const validate: {\n  /**\n   * Combines multiple effects and accumulates both successes and failures.\n   *\n   * **Details**\n   *\n   * This function allows you to combine multiple effects, continuing through all\n   * effects even if some of them fail. Unlike other functions that stop execution\n   * upon encountering an error, this function collects all errors into a `Cause`.\n   * The final result includes all successes and the accumulated failures.\n   *\n   * By default, effects are executed sequentially, but you can control\n   * concurrency and batching behavior using the `options` parameter. This\n   * provides flexibility in scenarios where you want to maximize performance or\n   * ensure specific ordering.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Console.log(\"task1\").pipe(Effect.as(1))\n   * const task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n   * const task3 = Console.log(\"task2\").pipe(Effect.as(3))\n   * const task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n   *\n   * const program = task1.pipe(\n   *   Effect.validate(task2),\n   *   Effect.validate(task3),\n   *   Effect.validate(task4)\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task1\n   * // task2\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Sequential',\n   * //     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n   * //     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link zip} for a version that stops at the first error.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <B, E1, R1>(\n    that: Effect<B, E1, R1>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    } | undefined\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>\n  /**\n   * Combines multiple effects and accumulates both successes and failures.\n   *\n   * **Details**\n   *\n   * This function allows you to combine multiple effects, continuing through all\n   * effects even if some of them fail. Unlike other functions that stop execution\n   * upon encountering an error, this function collects all errors into a `Cause`.\n   * The final result includes all successes and the accumulated failures.\n   *\n   * By default, effects are executed sequentially, but you can control\n   * concurrency and batching behavior using the `options` parameter. This\n   * provides flexibility in scenarios where you want to maximize performance or\n   * ensure specific ordering.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect, Console } from \"effect\"\n   *\n   * const task1 = Console.log(\"task1\").pipe(Effect.as(1))\n   * const task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\n   * const task3 = Console.log(\"task2\").pipe(Effect.as(3))\n   * const task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n   *\n   * const program = task1.pipe(\n   *   Effect.validate(task2),\n   *   Effect.validate(task3),\n   *   Effect.validate(task4)\n   * )\n   *\n   * Effect.runPromiseExit(program).then(console.log)\n   * // Output:\n   * // task1\n   * // task2\n   * // {\n   * //   _id: 'Exit',\n   * //   _tag: 'Failure',\n   * //   cause: {\n   * //     _id: 'Cause',\n   * //     _tag: 'Sequential',\n   * //     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n   * //     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n   * //   }\n   * // }\n   * ```\n   *\n   * @see {@link zip} for a version that stops at the first error.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, E, R, B, E1, R1>(\n    self: Effect<A, E, R>,\n    that: Effect<B, E1, R1>,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<[A, B], E | E1, R | R1>\n} = fiberRuntime.validate\n\n/**\n * Sequentially combines two effects using a specified combiner function while\n * accumulating errors.\n *\n * **Details**\n *\n * This function combines two effects, `self` and `that`, into a single effect\n * by applying the provided combiner function to their results. If both effects\n * succeed, the combiner function is applied to their results to produce the\n * final value. If either effect fails, the failures are accumulated into a\n * combined `Cause`.\n *\n * By default, effects are executed sequentially. However, the execution mode\n * can be controlled using the `options` parameter to enable concurrency,\n * batching, or customized finalizer behavior.\n *\n * @since 2.0.0\n * @category Error Accumulation\n */\nexport const validateWith: {\n  /**\n   * Sequentially combines two effects using a specified combiner function while\n   * accumulating errors.\n   *\n   * **Details**\n   *\n   * This function combines two effects, `self` and `that`, into a single effect\n   * by applying the provided combiner function to their results. If both effects\n   * succeed, the combiner function is applied to their results to produce the\n   * final value. If either effect fails, the failures are accumulated into a\n   * combined `Cause`.\n   *\n   * By default, effects are executed sequentially. However, the execution mode\n   * can be controlled using the `options` parameter to enable concurrency,\n   * batching, or customized finalizer behavior.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <B, E1, R1, A, C>(\n    that: Effect<B, E1, R1>,\n    f: (a: A, b: B) => C,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>\n  /**\n   * Sequentially combines two effects using a specified combiner function while\n   * accumulating errors.\n   *\n   * **Details**\n   *\n   * This function combines two effects, `self` and `that`, into a single effect\n   * by applying the provided combiner function to their results. If both effects\n   * succeed, the combiner function is applied to their results to produce the\n   * final value. If either effect fails, the failures are accumulated into a\n   * combined `Cause`.\n   *\n   * By default, effects are executed sequentially. However, the execution mode\n   * can be controlled using the `options` parameter to enable concurrency,\n   * batching, or customized finalizer behavior.\n   *\n   * @since 2.0.0\n   * @category Error Accumulation\n   */\n  <A, E, R, B, E1, R1, C>(\n    self: Effect<A, E, R>,\n    that: Effect<B, E1, R1>,\n    f: (a: A, b: B) => C,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<C, E | E1, R | R1>\n} = fiberRuntime.validateWith\n\n/**\n * Combines two effects into a single effect, producing a tuple of their\n * results.\n *\n * **Details**\n *\n * This function combines two effects, `self` and `that`, into one. It executes\n * the first effect (`self`) and then the second effect (`that`), collecting\n * their results into a tuple. Both effects must succeed for the resulting\n * effect to succeed. If either effect fails, the entire operation fails.\n *\n * By default, the effects are executed sequentially. If the `concurrent` option\n * is set to `true`, the effects will run concurrently, potentially improving\n * performance for independent operations.\n *\n * **Example** (Combining Two Effects Sequentially)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Effect.log(\"task1 done\"))\n * )\n * const task2 = Effect.succeed(\"hello\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Effect.log(\"task2 done\"))\n * )\n *\n * // Combine the two effects together\n * //\n * //       Effect<[number, string], never, never>\n * //      \n * const program = Effect.zip(task1, task2)\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n * // [ 1, 'hello' ]\n * ```\n *\n * **Example** (Combining Two Effects Concurrently)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Effect.log(\"task1 done\"))\n * )\n * const task2 = Effect.succeed(\"hello\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Effect.log(\"task2 done\"))\n * )\n *\n * // Run both effects concurrently using the concurrent option\n * const program = Effect.zip(task1, task2, { concurrent: true })\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n * // [ 1, 'hello' ]\n * ```\n *\n * @see {@link zipWith} for a version that combines the results with a custom\n * function.\n * @see {@link validate} for a version that accumulates errors.\n *\n * @since 2.0.0\n * @category Zipping\n */\nexport const zip: {\n  /**\n   * Combines two effects into a single effect, producing a tuple of their\n   * results.\n   *\n   * **Details**\n   *\n   * This function combines two effects, `self` and `that`, into one. It executes\n   * the first effect (`self`) and then the second effect (`that`), collecting\n   * their results into a tuple. Both effects must succeed for the resulting\n   * effect to succeed. If either effect fails, the entire operation fails.\n   *\n   * By default, the effects are executed sequentially. If the `concurrent` option\n   * is set to `true`, the effects will run concurrently, potentially improving\n   * performance for independent operations.\n   *\n   * **Example** (Combining Two Effects Sequentially)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * // Combine the two effects together\n   * //\n   * //       Effect<[number, string], never, never>\n   * //      \n   * const program = Effect.zip(task1, task2)\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // [ 1, 'hello' ]\n   * ```\n   *\n   * **Example** (Combining Two Effects Concurrently)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * // Run both effects concurrently using the concurrent option\n   * const program = Effect.zip(task1, task2, { concurrent: true })\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // [ 1, 'hello' ]\n   * ```\n   *\n   * @see {@link zipWith} for a version that combines the results with a custom\n   * function.\n   * @see {@link validate} for a version that accumulates errors.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A2, E2, R2>(\n    that: Effect<A2, E2, R2>,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>\n  /**\n   * Combines two effects into a single effect, producing a tuple of their\n   * results.\n   *\n   * **Details**\n   *\n   * This function combines two effects, `self` and `that`, into one. It executes\n   * the first effect (`self`) and then the second effect (`that`), collecting\n   * their results into a tuple. Both effects must succeed for the resulting\n   * effect to succeed. If either effect fails, the entire operation fails.\n   *\n   * By default, the effects are executed sequentially. If the `concurrent` option\n   * is set to `true`, the effects will run concurrently, potentially improving\n   * performance for independent operations.\n   *\n   * **Example** (Combining Two Effects Sequentially)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * // Combine the two effects together\n   * //\n   * //       Effect<[number, string], never, never>\n   * //      \n   * const program = Effect.zip(task1, task2)\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // [ 1, 'hello' ]\n   * ```\n   *\n   * **Example** (Combining Two Effects Concurrently)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * // Run both effects concurrently using the concurrent option\n   * const program = Effect.zip(task1, task2, { concurrent: true })\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // [ 1, 'hello' ]\n   * ```\n   *\n   * @see {@link zipWith} for a version that combines the results with a custom\n   * function.\n   * @see {@link validate} for a version that accumulates errors.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    that: Effect<A2, E2, R2>,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<[A, A2], E | E2, R | R2>\n} = fiberRuntime.zipOptions\n\n/**\n * Executes two effects sequentially, returning the result of the first effect\n * and ignoring the result of the second.\n *\n * **Details**\n *\n * This function allows you to run two effects in sequence, where the result of\n * the first effect is preserved, and the result of the second effect is\n * discarded. By default, the two effects are executed sequentially. If you need\n * them to run concurrently, you can pass the `{ concurrent: true }` option.\n *\n * The second effect will always be executed, even though its result is ignored.\n * This makes it useful for cases where you want to execute an effect for its\n * side effects while keeping the result of another effect.\n *\n * **When to Use**\n *\n * Use this function when you are only interested in the result of the first\n * effect but still need to run the second effect for its side effects, such as\n * logging or performing a cleanup action.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Effect.log(\"task1 done\"))\n * )\n * const task2 = Effect.succeed(\"hello\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Effect.log(\"task2 done\"))\n * )\n *\n * const program = Effect.zipLeft(task1, task2)\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n * // 1\n * ```\n *\n * @see {@link zipRight} for a version that returns the result of the second\n * effect.\n *\n * @since 2.0.0\n * @category Zipping\n */\nexport const zipLeft: {\n  /**\n   * Executes two effects sequentially, returning the result of the first effect\n   * and ignoring the result of the second.\n   *\n   * **Details**\n   *\n   * This function allows you to run two effects in sequence, where the result of\n   * the first effect is preserved, and the result of the second effect is\n   * discarded. By default, the two effects are executed sequentially. If you need\n   * them to run concurrently, you can pass the `{ concurrent: true }` option.\n   *\n   * The second effect will always be executed, even though its result is ignored.\n   * This makes it useful for cases where you want to execute an effect for its\n   * side effects while keeping the result of another effect.\n   *\n   * **When to Use**\n   *\n   * Use this function when you are only interested in the result of the first\n   * effect but still need to run the second effect for its side effects, such as\n   * logging or performing a cleanup action.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * const program = Effect.zipLeft(task1, task2)\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // 1\n   * ```\n   *\n   * @see {@link zipRight} for a version that returns the result of the second\n   * effect.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A2, E2, R2>(\n    that: Effect<A2, E2, R2>,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>\n  /**\n   * Executes two effects sequentially, returning the result of the first effect\n   * and ignoring the result of the second.\n   *\n   * **Details**\n   *\n   * This function allows you to run two effects in sequence, where the result of\n   * the first effect is preserved, and the result of the second effect is\n   * discarded. By default, the two effects are executed sequentially. If you need\n   * them to run concurrently, you can pass the `{ concurrent: true }` option.\n   *\n   * The second effect will always be executed, even though its result is ignored.\n   * This makes it useful for cases where you want to execute an effect for its\n   * side effects while keeping the result of another effect.\n   *\n   * **When to Use**\n   *\n   * Use this function when you are only interested in the result of the first\n   * effect but still need to run the second effect for its side effects, such as\n   * logging or performing a cleanup action.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * const program = Effect.zipLeft(task1, task2)\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // 1\n   * ```\n   *\n   * @see {@link zipRight} for a version that returns the result of the second\n   * effect.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    that: Effect<A2, E2, R2>,\n    options?:\n      | {\n        readonly concurrent?: boolean | undefined\n        readonly batching?: boolean | \"inherit\" | undefined\n        readonly concurrentFinalizers?: boolean | undefined\n      }\n      | undefined\n  ): Effect<A, E | E2, R | R2>\n} = fiberRuntime.zipLeftOptions\n\n/**\n * Executes two effects sequentially, returning the result of the second effect\n * while ignoring the result of the first.\n *\n * **Details**\n *\n * This function allows you to run two effects in sequence, keeping the result\n * of the second effect and discarding the result of the first. By default, the\n * two effects are executed sequentially. If you need them to run concurrently,\n * you can pass the `{ concurrent: true }` option.\n *\n * The first effect will always be executed, even though its result is ignored.\n * This makes it useful for scenarios where the first effect is needed for its\n * side effects, but only the result of the second effect is important.\n *\n * **When to Use**\n *\n * Use this function when you are only interested in the result of the second\n * effect but still need to run the first effect for its side effects, such as\n * initialization or setup tasks.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Effect.log(\"task1 done\"))\n * )\n * const task2 = Effect.succeed(\"hello\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Effect.log(\"task2 done\"))\n * )\n *\n * const program = Effect.zipRight(task1, task2)\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n * // hello\n * ```\n *\n * @see {@link zipLeft} for a version that returns the result of the first\n * effect.\n *\n * @since 2.0.0\n * @category Zipping\n */\nexport const zipRight: {\n  /**\n   * Executes two effects sequentially, returning the result of the second effect\n   * while ignoring the result of the first.\n   *\n   * **Details**\n   *\n   * This function allows you to run two effects in sequence, keeping the result\n   * of the second effect and discarding the result of the first. By default, the\n   * two effects are executed sequentially. If you need them to run concurrently,\n   * you can pass the `{ concurrent: true }` option.\n   *\n   * The first effect will always be executed, even though its result is ignored.\n   * This makes it useful for scenarios where the first effect is needed for its\n   * side effects, but only the result of the second effect is important.\n   *\n   * **When to Use**\n   *\n   * Use this function when you are only interested in the result of the second\n   * effect but still need to run the first effect for its side effects, such as\n   * initialization or setup tasks.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * const program = Effect.zipRight(task1, task2)\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // hello\n   * ```\n   *\n   * @see {@link zipLeft} for a version that returns the result of the first\n   * effect.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A2, E2, R2>(\n    that: Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>\n  /**\n   * Executes two effects sequentially, returning the result of the second effect\n   * while ignoring the result of the first.\n   *\n   * **Details**\n   *\n   * This function allows you to run two effects in sequence, keeping the result\n   * of the second effect and discarding the result of the first. By default, the\n   * two effects are executed sequentially. If you need them to run concurrently,\n   * you can pass the `{ concurrent: true }` option.\n   *\n   * The first effect will always be executed, even though its result is ignored.\n   * This makes it useful for scenarios where the first effect is needed for its\n   * side effects, but only the result of the second effect is important.\n   *\n   * **When to Use**\n   *\n   * Use this function when you are only interested in the result of the second\n   * effect but still need to run the first effect for its side effects, such as\n   * initialization or setup tasks.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * const program = Effect.zipRight(task1, task2)\n   *\n   * Effect.runPromise(program).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n   * // hello\n   * ```\n   *\n   * @see {@link zipLeft} for a version that returns the result of the first\n   * effect.\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect<A, E, R>,\n    that: Effect<A2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect<A2, E2 | E, R2 | R>\n} = fiberRuntime.zipRightOptions\n\n/**\n * Combines two effects sequentially and applies a function to their results to\n * produce a single value.\n *\n * **Details**\n *\n * This function runs two effects in sequence (or concurrently, if the `{\n * concurrent: true }` option is provided) and combines their results using a\n * provided function. Unlike {@link zip}, which returns a tuple of the results,\n * this function processes the results with a custom function to produce a\n * single output.\n *\n * **Example** (Combining Effects with a Custom Function)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay(\"200 millis\"),\n *   Effect.tap(Effect.log(\"task1 done\"))\n * )\n * const task2 = Effect.succeed(\"hello\").pipe(\n *   Effect.delay(\"100 millis\"),\n *   Effect.tap(Effect.log(\"task2 done\"))\n * )\n *\n * const task3 = Effect.zipWith(\n *   task1,\n *   task2,\n *   // Combines results into a single value\n *   (number, string) => number + string.length\n * )\n *\n * Effect.runPromise(task3).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message=\"task1 done\"\n * // timestamp=... level=INFO fiber=#2 message=\"task2 done\"\n * // 6\n * ```\n *\n * @since 2.0.0\n * @category Zipping\n */\nexport const zipWith: {\n  /**\n   * Combines two effects sequentially and applies a function to their results to\n   * produce a single value.\n   *\n   * **Details**\n   *\n   * This function runs two effects in sequence (or concurrently, if the `{\n   * concurrent: true }` option is provided) and combines their results using a\n   * provided function. Unlike {@link zip}, which returns a tuple of the results,\n   * this function processes the results with a custom function to produce a\n   * single output.\n   *\n   * **Example** (Combining Effects with a Custom Function)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * const task3 = Effect.zipWith(\n   *   task1,\n   *   task2,\n   *   // Combines results into a single value\n   *   (number, string) => number + string.length\n   * )\n   *\n   * Effect.runPromise(task3).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#3 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#2 message=\"task2 done\"\n   * // 6\n   * ```\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A2, E2, R2, A, B>(\n    that: Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>\n  /**\n   * Combines two effects sequentially and applies a function to their results to\n   * produce a single value.\n   *\n   * **Details**\n   *\n   * This function runs two effects in sequence (or concurrently, if the `{\n   * concurrent: true }` option is provided) and combines their results using a\n   * provided function. Unlike {@link zip}, which returns a tuple of the results,\n   * this function processes the results with a custom function to produce a\n   * single output.\n   *\n   * **Example** (Combining Effects with a Custom Function)\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * const task1 = Effect.succeed(1).pipe(\n   *   Effect.delay(\"200 millis\"),\n   *   Effect.tap(Effect.log(\"task1 done\"))\n   * )\n   * const task2 = Effect.succeed(\"hello\").pipe(\n   *   Effect.delay(\"100 millis\"),\n   *   Effect.tap(Effect.log(\"task2 done\"))\n   * )\n   *\n   * const task3 = Effect.zipWith(\n   *   task1,\n   *   task2,\n   *   // Combines results into a single value\n   *   (number, string) => number + string.length\n   * )\n   *\n   * Effect.runPromise(task3).then(console.log)\n   * // Output:\n   * // timestamp=... level=INFO fiber=#3 message=\"task1 done\"\n   * // timestamp=... level=INFO fiber=#2 message=\"task2 done\"\n   * // 6\n   * ```\n   *\n   * @since 2.0.0\n   * @category Zipping\n   */\n  <A, E, R, A2, E2, R2, B>(\n    self: Effect<A, E, R>,\n    that: Effect<A2, E2, R2>,\n    f: (a: A, b: A2) => B,\n    options?: {\n      readonly concurrent?: boolean | undefined\n      readonly batching?: boolean | \"inherit\" | undefined\n      readonly concurrentFinalizers?: boolean | undefined\n    }\n  ): Effect<B, E2 | E, R2 | R>\n} = fiberRuntime.zipWithOptions\n\n/**\n * Applies the function produced by one effect to the value produced by another effect.\n *\n * **Details**\n *\n * This function combines two effects:\n * - The first effect produces a function of type `(a: A) => B`.\n * - The second effect produces a value of type `A`.\n *\n * Once both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.\n *\n * @since 2.0.0\n */\nexport const ap: {\n  /**\n   * Applies the function produced by one effect to the value produced by another effect.\n   *\n   * **Details**\n   *\n   * This function combines two effects:\n   * - The first effect produces a function of type `(a: A) => B`.\n   * - The second effect produces a value of type `A`.\n   *\n   * Once both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.\n   *\n   * @since 2.0.0\n   */\n  <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>\n  /**\n   * Applies the function produced by one effect to the value produced by another effect.\n   *\n   * **Details**\n   *\n   * This function combines two effects:\n   * - The first effect produces a function of type `(a: A) => B`.\n   * - The second effect produces a value of type `A`.\n   *\n   * Once both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.\n   *\n   * @since 2.0.0\n   */\n  <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>\n} = dual(\n  2,\n  <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2> =>\n    zipWith(self, that, (f, a) => f(a))\n)\n\n/**\n * @category Requests & Batching\n * @since 2.0.0\n */\nexport const blocked: <A, E>(blockedRequests: RequestBlock, _continue: Effect<A, E>) => Blocked<A, E> = core.blocked\n\n/**\n * @category Requests & Batching\n * @since 2.0.0\n */\nexport const runRequestBlock: (blockedRequests: RequestBlock) => Effect<void> = core.runRequestBlock\n\n/**\n * @category Requests & Batching\n * @since 2.0.0\n */\nexport const step: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E> | Blocked<A, E>, never, R> = core.step\n\n/**\n * @since 2.0.0\n * @category Requests & Batching\n */\nexport const request: {\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  <A extends Request.Request<any, any>, Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>>(dataSource: Ds): (\n    self: A\n  ) => Effect<\n    Request.Request.Success<A>,\n    Request.Request.Error<A>,\n    [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never\n  >\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  <\n    Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>,\n    A extends Request.Request<any, any>\n  >(self: A, dataSource: Ds): Effect<\n    Request.Request.Success<A>,\n    Request.Request.Error<A>,\n    [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never\n  >\n} = dual((args) => Request.isRequest(args[0]), query.fromRequest)\n\n/**\n * @since 2.0.0\n * @category Requests & Batching\n */\nexport const cacheRequestResult: <A extends Request.Request<any, any>>(\n  request: A,\n  result: Request.Request.Result<A>\n) => Effect<void> = query.cacheRequest\n\n/**\n * @since 2.0.0\n * @category Requests & Batching\n */\nexport const withRequestBatching: {\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  (requestBatching: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  <A, E, R>(self: Effect<A, E, R>, requestBatching: boolean): Effect<A, E, R>\n} = core.withRequestBatching\n\n/**\n * @since 2.0.0\n * @category Requests & Batching\n */\nexport const withRequestCaching: {\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  (strategy: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  <A, E, R>(self: Effect<A, E, R>, strategy: boolean): Effect<A, E, R>\n} = query.withRequestCaching\n\n/**\n * @since 2.0.0\n * @category Requests & Batching\n */\nexport const withRequestCache: {\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  (cache: Request.Cache): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Requests & Batching\n   */\n  <A, E, R>(self: Effect<A, E, R>, cache: Request.Cache): Effect<A, E, R>\n} = query.withRequestCache\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const tracer: Effect<Tracer.Tracer> = effect.tracer\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const tracerWith: <A, E, R>(f: (tracer: Tracer.Tracer) => Effect<A, E, R>) => Effect<A, E, R> =\n  defaultServices.tracerWith\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const withTracer: {\n  /**\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (value: Tracer.Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(effect: Effect<A, E, R>, value: Tracer.Tracer): Effect<A, E, R>\n} = defaultServices.withTracer\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const withTracerScoped: (value: Tracer.Tracer) => Effect<void, never, Scope.Scope> =\n  fiberRuntime.withTracerScoped\n\n/**\n * Disable the tracer for the given Effect.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * Effect.succeed(42).pipe(\n *   Effect.withSpan(\"my-span\"),\n *   // the span will not be registered with the tracer\n *   Effect.withTracerEnabled(false)\n * )\n * ```\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const withTracerEnabled: {\n  /**\n   * Disable the tracer for the given Effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * Effect.succeed(42).pipe(\n   *   Effect.withSpan(\"my-span\"),\n   *   // the span will not be registered with the tracer\n   *   Effect.withTracerEnabled(false)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Disable the tracer for the given Effect.\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { Effect } from \"effect\"\n   *\n   * Effect.succeed(42).pipe(\n   *   Effect.withSpan(\"my-span\"),\n   *   // the span will not be registered with the tracer\n   *   Effect.withTracerEnabled(false)\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>\n} = core.withTracerEnabled\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const withTracerTiming: {\n  /**\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>\n} = core.withTracerTiming\n\n/**\n * Adds annotations to each span in the effect for enhanced traceability.\n *\n * **Details**\n *\n * This function lets you attach key-value annotations to all spans generated\n * during the execution of an effect. Annotations provide additional context,\n * such as metadata or labels, which can help you understand and debug\n * asynchronous workflows more effectively.\n *\n * You can either pass a single key-value pair or a record of key-value pairs to\n * annotate the spans. These annotations can then be visualized in tracing tools\n * that support span annotations.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const annotateSpans: {\n  /**\n   * Adds annotations to each span in the effect for enhanced traceability.\n   *\n   * **Details**\n   *\n   * This function lets you attach key-value annotations to all spans generated\n   * during the execution of an effect. Annotations provide additional context,\n   * such as metadata or labels, which can help you understand and debug\n   * asynchronous workflows more effectively.\n   *\n   * You can either pass a single key-value pair or a record of key-value pairs to\n   * annotate the spans. These annotations can then be visualized in tracing tools\n   * that support span annotations.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Adds annotations to each span in the effect for enhanced traceability.\n   *\n   * **Details**\n   *\n   * This function lets you attach key-value annotations to all spans generated\n   * during the execution of an effect. Annotations provide additional context,\n   * such as metadata or labels, which can help you understand and debug\n   * asynchronous workflows more effectively.\n   *\n   * You can either pass a single key-value pair or a record of key-value pairs to\n   * annotate the spans. These annotations can then be visualized in tracing tools\n   * that support span annotations.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Adds annotations to each span in the effect for enhanced traceability.\n   *\n   * **Details**\n   *\n   * This function lets you attach key-value annotations to all spans generated\n   * during the execution of an effect. Annotations provide additional context,\n   * such as metadata or labels, which can help you understand and debug\n   * asynchronous workflows more effectively.\n   *\n   * You can either pass a single key-value pair or a record of key-value pairs to\n   * annotate the spans. These annotations can then be visualized in tracing tools\n   * that support span annotations.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>\n  /**\n   * Adds annotations to each span in the effect for enhanced traceability.\n   *\n   * **Details**\n   *\n   * This function lets you attach key-value annotations to all spans generated\n   * during the execution of an effect. Annotations provide additional context,\n   * such as metadata or labels, which can help you understand and debug\n   * asynchronous workflows more effectively.\n   *\n   * You can either pass a single key-value pair or a record of key-value pairs to\n   * annotate the spans. These annotations can then be visualized in tracing tools\n   * that support span annotations.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>\n} = effect.annotateSpans\n\n/**\n * Adds annotations to the currently active span for traceability.\n *\n * **Details**\n *\n * This function adds key-value annotations to the currently active span in the\n * effect's trace. These annotations help provide more context about the\n * operation being executed at a specific point in time. Unlike\n * {@link annotateSpans}, which applies to all spans in an effect, this function\n * focuses solely on the active span.\n *\n * You can either pass a single key-value pair or a record of key-value pairs to\n * annotate the span. These annotations are useful for adding metadata to\n * operations, especially in systems with detailed observability requirements.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const annotateCurrentSpan: {\n  /**\n   * Adds annotations to the currently active span for traceability.\n   *\n   * **Details**\n   *\n   * This function adds key-value annotations to the currently active span in the\n   * effect's trace. These annotations help provide more context about the\n   * operation being executed at a specific point in time. Unlike\n   * {@link annotateSpans}, which applies to all spans in an effect, this function\n   * focuses solely on the active span.\n   *\n   * You can either pass a single key-value pair or a record of key-value pairs to\n   * annotate the span. These annotations are useful for adding metadata to\n   * operations, especially in systems with detailed observability requirements.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (key: string, value: unknown): Effect<void>\n  /**\n   * Adds annotations to the currently active span for traceability.\n   *\n   * **Details**\n   *\n   * This function adds key-value annotations to the currently active span in the\n   * effect's trace. These annotations help provide more context about the\n   * operation being executed at a specific point in time. Unlike\n   * {@link annotateSpans}, which applies to all spans in an effect, this function\n   * focuses solely on the active span.\n   *\n   * You can either pass a single key-value pair or a record of key-value pairs to\n   * annotate the span. These annotations are useful for adding metadata to\n   * operations, especially in systems with detailed observability requirements.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (values: Record<string, unknown>): Effect<void>\n} = effect.annotateCurrentSpan\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const currentSpan: Effect<Tracer.Span, Cause.NoSuchElementException> = effect.currentSpan\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const currentParentSpan: Effect<Tracer.AnySpan, Cause.NoSuchElementException> = effect.currentParentSpan\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const spanAnnotations: Effect<HashMap.HashMap<string, unknown>> = effect.spanAnnotations\n\n/**\n * @since 2.0.0\n * @category Tracing\n */\nexport const spanLinks: Effect<Chunk.Chunk<Tracer.SpanLink>> = effect.spanLinks\n\n/**\n * For all spans in this effect, add a link with the provided span.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const linkSpans: {\n  /**\n   * For all spans in this effect, add a link with the provided span.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * For all spans in this effect, add a link with the provided span.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(\n    self: Effect<A, E, R>,\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ): Effect<A, E, R>\n} = effect.linkSpans\n\n/**\n * Add span links to the current span.\n *\n * @since 3.14.0\n * @category Tracing\n */\nexport const linkSpanCurrent: {\n  /**\n   * Add span links to the current span.\n   *\n   * @since 3.14.0\n   * @category Tracing\n   */\n  (\n    span: Tracer.AnySpan,\n    attributes?: Readonly<Record<string, unknown>> | undefined\n  ): Effect<void>\n  /**\n   * Add span links to the current span.\n   *\n   * @since 3.14.0\n   * @category Tracing\n   */\n  (links: ReadonlyArray<Tracer.SpanLink>): Effect<void>\n} = effect.linkSpanCurrent\n\n/**\n * Create a new span for tracing.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const makeSpan: (\n  name: string,\n  options?: Tracer.SpanOptions\n) => Effect<Tracer.Span> = effect.makeSpan\n\n/**\n * Create a new span for tracing, and automatically close it when the Scope\n * finalizes.\n *\n * The span is not added to the current span stack, so no child spans will be\n * created for it.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const makeSpanScoped: (\n  name: string,\n  options?: Tracer.SpanOptions | undefined\n) => Effect<Tracer.Span, never, Scope.Scope> = fiberRuntime.makeSpanScoped\n\n/**\n * Create a new span for tracing, and automatically close it when the effect\n * completes.\n *\n * The span is not added to the current span stack, so no child spans will be\n * created for it.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const useSpan: {\n  /**\n   * Create a new span for tracing, and automatically close it when the effect\n   * completes.\n   *\n   * The span is not added to the current span stack, so no child spans will be\n   * created for it.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>\n  /**\n   * Create a new span for tracing, and automatically close it when the effect\n   * completes.\n   *\n   * The span is not added to the current span stack, so no child spans will be\n   * created for it.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(\n    name: string,\n    options: Tracer.SpanOptions,\n    evaluate: (span: Tracer.Span) => Effect<A, E, R>\n  ): Effect<A, E, R>\n} = effect.useSpan\n\n/**\n * Wraps the effect with a new span for tracing.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const withSpan: {\n  /**\n   * Wraps the effect with a new span for tracing.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n  /**\n   * Wraps the effect with a new span for tracing.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(\n    self: Effect<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n} = effect.withSpan\n\n/**\n * Wraps a function that returns an effect with a new span for tracing.\n *\n * @since 3.2.0\n * @category Models\n */\nexport interface FunctionWithSpanOptions {\n  readonly name: string\n  readonly attributes?: Record<string, unknown> | undefined\n  readonly links?: ReadonlyArray<Tracer.SpanLink> | undefined\n  readonly parent?: Tracer.AnySpan | undefined\n  readonly root?: boolean | undefined\n  readonly context?: Context.Context<never> | undefined\n  readonly kind?: Tracer.SpanKind | undefined\n}\n\n/**\n * Wraps a function that returns an effect with a new span for tracing.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const getTodo = Effect.functionWithSpan({\n *   body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n *   options: (id) => ({\n *     name: `getTodo-${id}`,\n *     attributes: { id }\n *   })\n * })\n * ```\n *\n * @since 3.2.0\n * @category Tracing\n */\nexport const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(\n  options: {\n    readonly body: (...args: Args) => Ret\n    readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions)\n    readonly captureStackTrace?: boolean | undefined\n  }\n) => (...args: Args) => Unify.Unify<Ret> = effect.functionWithSpan\n\n/**\n * Wraps the effect with a new span for tracing.\n *\n * The span is ended when the Scope is finalized.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const withSpanScoped: {\n  /**\n   * Wraps the effect with a new span for tracing.\n   *\n   * The span is ended when the Scope is finalized.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (name: string, options?: Tracer.SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>\n  /**\n   * Wraps the effect with a new span for tracing.\n   *\n   * The span is ended when the Scope is finalized.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions): Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>\n} = fiberRuntime.withSpanScoped\n\n/**\n * Adds the provided span to the current span stack.\n *\n * @since 2.0.0\n * @category Tracing\n */\nexport const withParentSpan: {\n  /**\n   * Adds the provided span to the current span stack.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n  /**\n   * Adds the provided span to the current span stack.\n   *\n   * @since 2.0.0\n   * @category Tracing\n   */\n  <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n} = effect.withParentSpan\n\n/**\n * Safely handles nullable values by creating an effect that fails for `null` or\n * `undefined`.\n *\n * **Details**\n *\n * This function ensures that an input value is non-null and non-undefined\n * before processing it. If the value is valid, the effect succeeds with the\n * value. If the value is `null` or `undefined`, the effect fails with a\n * `NoSuchElementException`. This is particularly useful for avoiding\n * null-related errors by clearly separating valid values from invalid ones in\n * effectful computations.\n *\n * The failure with `NoSuchElementException` allows you to explicitly handle\n * cases where a value is expected but not provided, leading to safer and more\n * predictable code.\n *\n * **When to Use**\n *\n * Use this function when working with values that may be `null` or `undefined`\n * and you want to ensure that only non-null values are processed. It helps\n * enforce null-safety and makes error handling more explicit.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, NoSuchElementException, never>\n * //      \n * const maybe1 = Effect.fromNullable(1)\n *\n * Effect.runPromiseExit(maybe1).then(console.log)\n * // Output:\n * // { _id: 'Exit', _tag: 'Success', value: 1 }\n *\n * //       Effect<number, NoSuchElementException, never>\n * //      \n * const maybe2 = Effect.fromNullable(null as number | null)\n *\n * Effect.runPromiseExit(maybe2).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: { _tag: 'NoSuchElementException' }\n * //   }\n * // }\n * ```\n *\n * @since 2.0.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException> = effect.fromNullable\n\n/**\n * Converts an effect that may fail with a `NoSuchElementException` into an\n * effect that succeeds with an `Option`.\n *\n * **Details**\n *\n * This function transforms an effect that might fail with\n * `Cause.NoSuchElementException` into an effect that succeeds with an `Option`\n * type. If the original effect succeeds, its value is wrapped in `Option.some`.\n * If it fails specifically due to a `NoSuchElementException`, the failure is\n * mapped to `Option.none`. Other types of failures remain unchanged and are\n * passed through as they are.\n *\n * This is useful when working with effects where you want to gracefully handle\n * the absence of a value while preserving other potential failures.\n *\n * **When to Use**\n *\n * Use this function when you need to handle missing values as `Option.none`\n * rather than throwing or propagating errors like `NoSuchElementException`.\n * Its ideal for scenarios where you want to explicitly represent optionality\n * in a type-safe way while retaining other failure information.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * //       Effect<number, NoSuchElementException, never>\n * //      \n * const maybe1 = Effect.fromNullable(1)\n *\n * //       Effect<Option<number>, never, never>\n * //      \n * const option1 = Effect.optionFromOptional(maybe1)\n *\n * Effect.runPromise(option1).then(console.log)\n * // Output: { _id: 'Option', _tag: 'Some', value: 1 }\n *\n * //       Effect<number, NoSuchElementException, never>\n * //      \n * const maybe2 = Effect.fromNullable(null as number | null)\n *\n * //       Effect<Option<number>, never, never>\n * //      \n * const option2 = Effect.optionFromOptional(maybe2)\n *\n * Effect.runPromise(option2).then(console.log)\n * // Output: { _tag: 'None' }\n * ```\n *\n * @since 2.0.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const optionFromOptional: <A, E, R>(\n  self: Effect<A, E, R>\n) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R> = effect.optionFromOptional\n\n/**\n * Converts an `Option` of an `Effect` into an `Effect` of an `Option`.\n *\n * **Details**\n *\n * This function transforms an `Option<Effect<A, E, R>>` into an\n * `Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`\n * will immediately succeed with a `None` value. If the `Option` is `Some`, the\n * inner `Effect` will be executed, and its result wrapped in a `Some`.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Option } from \"effect\"\n *\n * //       Option<Effect<number, never, never>>\n * //      \n * const maybe = Option.some(Effect.succeed(42))\n *\n * //       Effect<Option<number>, never, never>\n * //      \n * const result = Effect.transposeOption(maybe)\n *\n * console.log(Effect.runSync(result))\n * // Output: { _id: 'Option', _tag: 'Some', value: 42 }\n * ```\n *\n * @since 3.13.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const transposeOption = <A = never, E = never, R = never>(\n  self: Option.Option<Effect<A, E, R>>\n): Effect<Option.Option<A>, E, R> => {\n  return option_.isNone(self) ? succeedNone : map(self.value, option_.some)\n}\n\n/**\n * Applies an `Effect` on an `Option` and transposes the result.\n *\n * **Details**\n *\n * If the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.\n * If the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.\n *\n * @example\n * ```ts\n * import { Effect, Option, pipe } from \"effect\"\n *\n * //           Effect<Option<number>, never, never>>\n * //          \n * const noneResult = pipe(\n *   Option.none(),\n *   Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed\n * )\n * console.log(Effect.runSync(noneResult))\n * // Output: { _id: 'Option', _tag: 'None' }\n *\n * //           Effect<Option<number>, never, never>>\n * //          \n * const someSuccessResult = pipe(\n *   Option.some(42),\n *   Effect.transposeMapOption((value) => Effect.succeed(value * 2))\n * )\n * console.log(Effect.runSync(someSuccessResult))\n * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n * ```\n *\n * @since 3.14.0\n * @category Optional Wrapping & Unwrapping\n */\nexport const transposeMapOption = dual<\n  /**\n   * Applies an `Effect` on an `Option` and transposes the result.\n   *\n   * **Details**\n   *\n   * If the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.\n   * If the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Option, pipe } from \"effect\"\n   *\n   * //           Effect<Option<number>, never, never>>\n   * //          \n   * const noneResult = pipe(\n   *   Option.none(),\n   *   Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed\n   * )\n   * console.log(Effect.runSync(noneResult))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * //           Effect<Option<number>, never, never>>\n   * //          \n   * const someSuccessResult = pipe(\n   *   Option.some(42),\n   *   Effect.transposeMapOption((value) => Effect.succeed(value * 2))\n   * )\n   * console.log(Effect.runSync(someSuccessResult))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n   * ```\n   *\n   * @since 3.14.0\n   * @category Optional Wrapping & Unwrapping\n   */\n  <A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option.Option<A>) => Effect<Option.Option<B>, E, R>,\n  /**\n   * Applies an `Effect` on an `Option` and transposes the result.\n   *\n   * **Details**\n   *\n   * If the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.\n   * If the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Option, pipe } from \"effect\"\n   *\n   * //           Effect<Option<number>, never, never>>\n   * //          \n   * const noneResult = pipe(\n   *   Option.none(),\n   *   Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed\n   * )\n   * console.log(Effect.runSync(noneResult))\n   * // Output: { _id: 'Option', _tag: 'None' }\n   *\n   * //           Effect<Option<number>, never, never>>\n   * //          \n   * const someSuccessResult = pipe(\n   *   Option.some(42),\n   *   Effect.transposeMapOption((value) => Effect.succeed(value * 2))\n   * )\n   * console.log(Effect.runSync(someSuccessResult))\n   * // Output: { _id: 'Option', _tag: 'Some', value: 84 }\n   * ```\n   *\n   * @since 3.14.0\n   * @category Optional Wrapping & Unwrapping\n   */\n  <A, B, E = never, R = never>(self: Option.Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option.Option<B>, E, R>\n>(2, (self, f) => option_.isNone(self) ? succeedNone : map(f(self.value), option_.some))\n\n/**\n * @since 2.0.0\n * @category Models\n */\nexport declare namespace Tag {\n  /**\n   * @since 2.0.0\n   * @category Models\n   */\n  export interface ProhibitedType {\n    Service?: `property \"Service\" is forbidden`\n    Identifier?: `property \"Identifier\" is forbidden`\n    _op?: `property \"_op\" is forbidden`\n    of?: `property \"of\" is forbidden`\n    context?: `property \"context\" is forbidden`\n    key?: `property \"key\" is forbidden`\n    stack?: `property \"stack\" is forbidden`\n    name?: `property \"name\" is forbidden`\n    pipe?: `property \"pipe\" is forbidden`\n    use?: `property \"use\" is forbidden`\n  }\n\n  /**\n   * @since 2.0.0\n   * @category Models\n   */\n  export type AllowedType = (Record<PropertyKey, any> & ProhibitedType) | string | number | symbol\n\n  /**\n   * @since 3.9.0\n   * @category Models\n   */\n  export type Proxy<Self, Type> = {\n    [\n      k in keyof Type as Type[k] extends ((...args: infer Args extends ReadonlyArray<any>) => infer Ret) ?\n        ((...args: Readonly<Args>) => Ret) extends Type[k] ? k : never\n        : k\n    ]: Type[k] extends (...args: infer Args extends ReadonlyArray<any>) => Effect<infer A, infer E, infer R> ?\n      (...args: Readonly<Args>) => Effect<A, E, Self | R>\n      : Type[k] extends (...args: infer Args extends ReadonlyArray<any>) => Promise<infer A> ?\n        (...args: Readonly<Args>) => Effect<A, Cause.UnknownException, Self>\n      : Type[k] extends (...args: infer Args extends ReadonlyArray<any>) => infer A ?\n        (...args: Readonly<Args>) => Effect<A, never, Self>\n      : Type[k] extends Effect<infer A, infer E, infer R> ? Effect<A, E, Self | R>\n      : Effect<Type[k], never, Self>\n  }\n}\n\nconst makeTagProxy = (TagClass: Context.Tag<any, any> & Record<PropertyKey, any>) => {\n  const cache = new Map()\n  return new Proxy(TagClass, {\n    get(target: any, prop: any, receiver) {\n      if (prop in target) {\n        return Reflect.get(target, prop, receiver)\n      }\n      if (cache.has(prop)) {\n        return cache.get(prop)\n      }\n      const fn = (...args: Array<any>) =>\n        core.andThen(target, (s: any) => {\n          if (typeof s[prop] === \"function\") {\n            cache.set(prop, (...args: Array<any>) => core.andThen(target, (s: any) => s[prop](...args)))\n            return s[prop](...args)\n          }\n          cache.set(prop, core.andThen(target, (s: any) => s[prop]))\n          return s[prop]\n        })\n      const cn = core.andThen(target, (s: any) => s[prop])\n      // @effect-diagnostics-next-line floatingEffect:off\n      Object.assign(fn, cn)\n      const apply = fn.apply\n      const bind = fn.bind\n      const call = fn.call\n      const proto = Object.setPrototypeOf({}, Object.getPrototypeOf(cn))\n      proto.apply = apply\n      proto.bind = bind\n      proto.call = call\n      Object.setPrototypeOf(fn, proto)\n      cache.set(prop, fn)\n      return fn\n    }\n  })\n}\n\n/**\n * Creates a unique tag for a dependency, embedding the service's methods as\n * static properties.\n *\n * **Details**\n *\n * This function allows you to define a `Tag` for a service or dependency in\n * your application. The `Tag` not only acts as an identifier but also provides\n * direct access to the service's methods via static properties. This makes it\n * easier to access and use the service in your code without manually managing\n * contexts.\n *\n * In the example below, the fields of the service (in this case, the `notify`\n * method) are turned into static properties of the Notifications class, making\n * it easier to access them.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * class Notifications extends Effect.Tag(\"Notifications\")<\n *   Notifications,\n *   { readonly notify: (message: string) => Effect.Effect<void> }\n * >() {}\n *\n * // Create an effect that depends on the Notifications service\n * const action = Notifications.notify(\"Hello, world!\")\n * ```\n *\n * @since 2.0.0\n * @category Context\n */\nexport const Tag: <const Id extends string>(id: Id) => <\n  Self,\n  Type extends Tag.AllowedType\n>() =>\n  & Context.TagClass<Self, Id, Type>\n  & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {})\n  & {\n    use: <X>(\n      body: (_: Type) => X\n    ) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self>\n      : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self>\n      : Effect<X, never, Self>\n  } = (id) => () => {\n    const limit = Error.stackTraceLimit\n    Error.stackTraceLimit = 2\n    const creationError = new Error()\n    Error.stackTraceLimit = limit\n    function TagClass() {}\n    Object.setPrototypeOf(TagClass, TagProto)\n    TagClass.key = id\n    Object.defineProperty(TagClass, \"use\", {\n      get() {\n        return (body: (_: any) => any) => core.andThen(this, body)\n      }\n    })\n    Object.defineProperty(TagClass, \"stack\", {\n      get() {\n        return creationError.stack\n      }\n    })\n    return makeTagProxy(TagClass as any)\n  }\n\ntype MissingSelfGeneric = `Missing \\`Self\\` generic - use \\`class Self extends Effect.Service<Self>()...\\``\n\n/**\n * Simplifies the creation and management of services in Effect by defining both\n * a `Tag` and a `Layer`.\n *\n * **Details**\n *\n * This function allows you to streamline the creation of services by combining\n * the definition of a `Context.Tag` and a `Layer` in a single step. It supports\n * various ways of providing the service implementation:\n * - Using an `effect` to define the service dynamically.\n * - Using `sync` or `succeed` to define the service statically.\n * - Using `scoped` to create services with lifecycle management.\n *\n * It also allows you to specify dependencies for the service, which will be\n * provided automatically when the service is used. Accessors can be optionally\n * generated for the service, making it more convenient to use.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from 'effect';\n *\n * class Prefix extends Effect.Service<Prefix>()(\"Prefix\", {\n *  sync: () => ({ prefix: \"PRE\" })\n * }) {}\n *\n * class Logger extends Effect.Service<Logger>()(\"Logger\", {\n *  accessors: true,\n *  effect: Effect.gen(function* () {\n *    const { prefix } = yield* Prefix\n *    return {\n *      info: (message: string) =>\n *        Effect.sync(() => {\n *          console.log(`[${prefix}][${message}]`)\n *        })\n *    }\n *  }),\n *  dependencies: [Prefix.Default]\n * }) {}\n * ```\n *\n * @since 3.9.0\n * @category Context\n * @experimental might be up for breaking changes\n */\nexport const Service: <Self = never>() => [Self] extends [never] ? MissingSelfGeneric : {\n  <\n    const Key extends string,\n    const Make extends\n      | {\n        readonly scoped:\n          | Effect<Service.AllowedType<Key, Make>, any, any>\n          | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>)\n        readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n        readonly accessors?: boolean\n        /** @deprecated */\n        readonly _: never\n      }\n      | {\n        readonly effect:\n          | Effect<Service.AllowedType<Key, Make>, any, any>\n          | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>)\n        readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n        readonly accessors?: boolean\n        /** @deprecated */\n        readonly _: never\n      }\n      | {\n        readonly sync: LazyArg<Service.AllowedType<Key, Make>>\n        readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n        readonly accessors?: boolean\n        /** @deprecated */\n        readonly _: never\n      }\n      | {\n        readonly succeed: Service.AllowedType<Key, Make>\n        readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n        readonly accessors?: boolean\n        /** @deprecated */\n        readonly _: never\n      }\n  >(\n    key: Key,\n    make: Make\n  ): Service.Class<Self, Key, Make>\n  <\n    const Key extends string,\n    const Make extends NoExcessProperties<{\n      readonly scoped:\n        | Effect<Service.AllowedType<Key, Make>, any, any>\n        | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>)\n      readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n      readonly accessors?: boolean\n    }, Make>\n  >(\n    key: Key,\n    make: Make\n  ): Service.Class<Self, Key, Make>\n  <\n    const Key extends string,\n    const Make extends NoExcessProperties<{\n      readonly effect:\n        | Effect<Service.AllowedType<Key, Make>, any, any>\n        | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>)\n      readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n      readonly accessors?: boolean\n    }, Make>\n  >(\n    key: Key,\n    make: Make\n  ): Service.Class<Self, Key, Make>\n  <\n    const Key extends string,\n    const Make extends NoExcessProperties<{\n      readonly sync: LazyArg<Service.AllowedType<Key, Make>>\n      readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n      readonly accessors?: boolean\n    }, Make>\n  >(\n    key: Key,\n    make: Make\n  ): Service.Class<Self, Key, Make>\n  <\n    const Key extends string,\n    const Make extends NoExcessProperties<{\n      readonly succeed: Service.AllowedType<Key, Make>\n      readonly dependencies?: ReadonlyArray<Layer.Layer.Any>\n      readonly accessors?: boolean\n    }, Make>\n  >(\n    key: Key,\n    make: Make\n  ): Service.Class<Self, Key, Make>\n} = function() {\n  return function() {\n    const [id, maker] = arguments\n    const proxy = \"accessors\" in maker ? maker[\"accessors\"] : false\n    const limit = Error.stackTraceLimit\n    Error.stackTraceLimit = 2\n    const creationError = new Error()\n    Error.stackTraceLimit = limit\n\n    let patchState: \"unchecked\" | \"plain\" | \"patched\" = \"unchecked\"\n    const TagClass: any = function(this: any, service: any) {\n      if (patchState === \"unchecked\") {\n        const proto = Object.getPrototypeOf(service)\n        if (proto === Object.prototype || proto === null) {\n          patchState = \"plain\"\n        } else {\n          const selfProto = Object.getPrototypeOf(this)\n          Object.setPrototypeOf(selfProto, proto)\n          patchState = \"patched\"\n        }\n      }\n      if (patchState === \"plain\") {\n        Object.assign(this, service)\n      } else if (patchState === \"patched\") {\n        Object.setPrototypeOf(service, Object.getPrototypeOf(this))\n        return service\n      }\n    }\n\n    TagClass.prototype._tag = id\n    Object.defineProperty(TagClass, \"make\", {\n      get() {\n        return (service: any) => new this(service)\n      }\n    })\n    Object.defineProperty(TagClass, \"use\", {\n      get() {\n        return (body: any) => core.andThen(this, body)\n      }\n    })\n    TagClass.key = id\n\n    Object.assign(TagClass, TagProto)\n\n    Object.defineProperty(TagClass, \"stack\", {\n      get() {\n        return creationError.stack\n      }\n    })\n\n    const hasDeps = \"dependencies\" in maker && maker.dependencies.length > 0\n    const layerName = hasDeps ? \"DefaultWithoutDependencies\" : \"Default\"\n    let layerCache: Layer.Layer.Any | undefined\n    let isFunction = false\n    if (\"effect\" in maker) {\n      isFunction = typeof maker.effect === \"function\"\n      Object.defineProperty(TagClass, layerName, {\n        get(this: any) {\n          if (isFunction) {\n            return function(this: typeof TagClass) {\n              return layer.fromEffect(TagClass, map(maker.effect.apply(null, arguments), (_) => new this(_)))\n            }.bind(this)\n          }\n          return layerCache ??= layer.fromEffect(TagClass, map(maker.effect, (_) => new this(_)))\n        }\n      })\n    } else if (\"scoped\" in maker) {\n      isFunction = typeof maker.scoped === \"function\"\n      Object.defineProperty(TagClass, layerName, {\n        get(this: any) {\n          if (isFunction) {\n            return function(this: typeof TagClass) {\n              return layer.scoped(TagClass, map(maker.scoped.apply(null, arguments), (_) => new this(_)))\n            }.bind(this)\n          }\n          return layerCache ??= layer.scoped(TagClass, map(maker.scoped, (_) => new this(_)))\n        }\n      })\n    } else if (\"sync\" in maker) {\n      Object.defineProperty(TagClass, layerName, {\n        get(this: any) {\n          return layerCache ??= layer.sync(TagClass, () => new this(maker.sync()))\n        }\n      })\n    } else {\n      Object.defineProperty(TagClass, layerName, {\n        get(this: any) {\n          return layerCache ??= layer.succeed(TagClass, new this(maker.succeed))\n        }\n      })\n    }\n\n    if (hasDeps) {\n      let layerWithDepsCache: Layer.Layer.Any | undefined\n      Object.defineProperty(TagClass, \"Default\", {\n        get(this: any) {\n          if (isFunction) {\n            return function(this: typeof TagClass) {\n              return layer.provide(\n                this.DefaultWithoutDependencies.apply(null, arguments),\n                maker.dependencies\n              )\n            }\n          }\n          return layerWithDepsCache ??= layer.provide(\n            this.DefaultWithoutDependencies,\n            maker.dependencies\n          )\n        }\n      })\n    }\n\n    return proxy === true ? makeTagProxy(TagClass) : TagClass\n  }\n} as any\n\n/**\n * @since 3.9.0\n * @category Context\n */\nexport declare namespace Service {\n  /**\n   * @since 3.9.0\n   */\n  export interface ProhibitedType {\n    Service?: `property \"Service\" is forbidden`\n    Identifier?: `property \"Identifier\" is forbidden`\n    Default?: `property \"Default\" is forbidden`\n    DefaultWithoutDependencies?: `property \"DefaultWithoutDependencies\" is forbidden`\n    _op_layer?: `property \"_op_layer\" is forbidden`\n    _op?: `property \"_op\" is forbidden`\n    of?: `property \"of\" is forbidden`\n    make?: `property \"make\" is forbidden`\n    context?: `property \"context\" is forbidden`\n    key?: `property \"key\" is forbidden`\n    stack?: `property \"stack\" is forbidden`\n    name?: `property \"name\" is forbidden`\n    pipe?: `property \"pipe\" is forbidden`\n    use?: `property \"use\" is forbidden`\n    _tag?: `property \"_tag\" is forbidden`\n  }\n\n  /**\n   * @since 3.9.0\n   */\n  export type AllowedType<Key extends string, Make> = MakeAccessors<Make> extends true ?\n      & Record<PropertyKey, any>\n      & {\n        readonly [K in Extract<keyof MakeService<Make>, keyof ProhibitedType>]: K extends \"_tag\" ? Key\n          : ProhibitedType[K]\n      }\n    : Record<PropertyKey, any> & { readonly _tag?: Key }\n\n  /**\n   * @since 3.9.0\n   */\n  export type Class<\n    Self,\n    Key extends string,\n    Make\n  > =\n    & {\n      new(_: MakeService<Make>): MakeService<Make> & {\n        readonly _tag: Key\n      }\n      readonly use: <X>(\n        body: (_: Self) => X\n      ) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self>\n        : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self>\n        : Effect<X, never, Self>\n      readonly make: (_: MakeService<Make>) => Self\n    }\n    & Context.Tag<Self, Self>\n    & { key: Key }\n    & (MakeAccessors<Make> extends true ? Tag.Proxy<Self, MakeService<Make>> : {})\n    & (MakeDeps<Make> extends never ? {\n        readonly Default: HasArguments<Make> extends true ?\n          (...args: MakeArguments<Make>) => Layer.Layer<Self, MakeError<Make>, MakeContext<Make>>\n          : Layer.Layer<Self, MakeError<Make>, MakeContext<Make>>\n      } :\n      {\n        readonly DefaultWithoutDependencies: HasArguments<Make> extends true\n          ? (...args: MakeArguments<Make>) => Layer.Layer<Self, MakeError<Make>, MakeContext<Make>>\n          : Layer.Layer<Self, MakeError<Make>, MakeContext<Make>>\n\n        readonly Default: HasArguments<Make> extends true ? (...args: MakeArguments<Make>) => Layer.Layer<\n            Self,\n            MakeError<Make> | MakeDepsE<Make>,\n            | Exclude<MakeContext<Make>, MakeDepsOut<Make>>\n            | MakeDepsIn<Make>\n          > :\n          Layer.Layer<\n            Self,\n            MakeError<Make> | MakeDepsE<Make>,\n            | Exclude<MakeContext<Make>, MakeDepsOut<Make>>\n            | MakeDepsIn<Make>\n          >\n      })\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeService<Make> = Make extends { readonly effect: Effect<infer _A, infer _E, infer _R> } ? _A\n    : Make extends { readonly scoped: Effect<infer _A, infer _E, infer _R> } ? _A\n    : Make extends { readonly effect: (...args: infer _Args) => Effect<infer _A, infer _E, infer _R> } ? _A\n    : Make extends { readonly scoped: (...args: infer _Args) => Effect<infer _A, infer _E, infer _R> } ? _A\n    : Make extends { readonly sync: LazyArg<infer A> } ? A\n    : Make extends { readonly succeed: infer A } ? A\n    : never\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeError<Make> = Make extends { readonly effect: Effect<infer _A, infer _E, infer _R> } ? _E\n    : Make extends { readonly scoped: Effect<infer _A, infer _E, infer _R> } ? _E\n    : Make extends { readonly effect: (...args: infer _Args) => Effect<infer _A, infer _E, infer _R> } ? _E\n    : Make extends { readonly scoped: (...args: infer _Args) => Effect<infer _A, infer _E, infer _R> } ? _E\n    : never\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeContext<Make> = Make extends { readonly effect: Effect<infer _A, infer _E, infer _R> } ? _R\n    : Make extends { readonly scoped: Effect<infer _A, infer _E, infer _R> } ? Exclude<_R, Scope.Scope>\n    : Make extends { readonly effect: (...args: infer _Args) => Effect<infer _A, infer _E, infer _R> } ? _R\n    : Make extends { readonly scoped: (...args: infer _Args) => Effect<infer _A, infer _E, infer _R> } ?\n      Exclude<_R, Scope.Scope>\n    : never\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeDeps<Make> = Make extends { readonly dependencies: ReadonlyArray<Layer.Layer.Any> }\n    ? Make[\"dependencies\"][number]\n    : never\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeDepsOut<Make> = Contravariant.Type<MakeDeps<Make>[Layer.LayerTypeId][\"_ROut\"]>\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeDepsE<Make> = Covariant.Type<MakeDeps<Make>[Layer.LayerTypeId][\"_E\"]>\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeDepsIn<Make> = Covariant.Type<MakeDeps<Make>[Layer.LayerTypeId][\"_RIn\"]>\n\n  /**\n   * @since 3.9.0\n   */\n  export type MakeAccessors<Make> = Make extends { readonly accessors: true } ? true\n    : false\n\n  /**\n   * @since 3.16.0\n   */\n  export type MakeArguments<Make> = Make extends\n    { readonly effect: (...args: infer Args) => Effect<infer _A, infer _E, infer _R> } ? Args\n    : Make extends { readonly scoped: (...args: infer Args) => Effect<infer _A, infer _E, infer _R> } ? Args\n    : never\n\n  /**\n   * @since 3.16.0\n   */\n  export type HasArguments<Make> = Make extends {\n    readonly scoped: (...args: ReadonlyArray<any>) => Effect<infer _A, infer _E, infer _R>\n  } ? true :\n    Make extends {\n      readonly effect: (...args: ReadonlyArray<any>) => Effect<infer _A, infer _E, infer _R>\n    } ? true :\n    false\n}\n\n/**\n * @since 3.11.0\n * @category Models\n */\nexport namespace fn {\n  /**\n   * @since 3.11.0\n   * @category Models\n   */\n  export type Gen = {\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>>(\n      body: (...args: Args) => Generator<Eff, AEff, never>\n    ): (...args: Args) => Effect<\n      AEff,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n    >\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A\n    ): (...args: Args) => Effect.AsEffect<A>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B\n    ): (...args: Args) => Effect.AsEffect<B>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C\n    ): (...args: Args) => Effect.AsEffect<C>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D\n    ): (...args: Args) => Effect.AsEffect<D>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E\n    ): (...args: Args) => Effect.AsEffect<E>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F\n    ): (...args: Args) => Effect.AsEffect<F>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F,\n      g: (_: F, ...args: NoInfer<Args>) => G\n    ): (...args: Args) => Effect.AsEffect<G>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F,\n      g: (_: F, ...args: NoInfer<Args>) => G,\n      h: (_: G, ...args: NoInfer<Args>) => H\n    ): (...args: Args) => Effect.AsEffect<H>\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H,\n      I extends Effect<any, any, any>\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F,\n      g: (_: F, ...args: NoInfer<Args>) => G,\n      h: (_: G, ...args: NoInfer<Args>) => H,\n      i: (_: H, ...args: NoInfer<Args>) => I\n    ): (...args: Args) => Effect.AsEffect<I>\n  }\n\n  /**\n   * @since 3.11.0\n   * @category Models\n   */\n  export type NonGen = {\n    <Eff extends Effect<any, any, any>, Args extends Array<any>>(\n      body: (...args: Args) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, D, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => D,\n      d: (_: D, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => D,\n      d: (_: D, ...args: NoInfer<Args>) => E,\n      e: (_: E, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => D,\n      d: (_: D, ...args: NoInfer<Args>) => E,\n      e: (_: E, ...args: NoInfer<Args>) => F,\n      f: (_: F, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, G, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => D,\n      d: (_: D, ...args: NoInfer<Args>) => E,\n      e: (_: E, ...args: NoInfer<Args>) => F,\n      f: (_: F, ...args: NoInfer<Args>) => G,\n      g: (_: G, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, G, H, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => D,\n      d: (_: D, ...args: NoInfer<Args>) => E,\n      e: (_: E, ...args: NoInfer<Args>) => F,\n      f: (_: F, ...args: NoInfer<Args>) => G,\n      g: (_: G, ...args: NoInfer<Args>) => H,\n      h: (_: H, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n    <Eff extends Effect<any, any, any>, A, B, C, D, E, F, G, H, I, Args extends Array<any>>(\n      body: (...args: Args) => A,\n      a: (_: A, ...args: NoInfer<Args>) => B,\n      b: (_: B, ...args: NoInfer<Args>) => C,\n      c: (_: C, ...args: NoInfer<Args>) => D,\n      d: (_: D, ...args: NoInfer<Args>) => E,\n      e: (_: E, ...args: NoInfer<Args>) => F,\n      f: (_: F, ...args: NoInfer<Args>) => G,\n      g: (_: G, ...args: NoInfer<Args>) => H,\n      h: (_: H, ...args: NoInfer<Args>) => I,\n      i: (_: H, ...args: NoInfer<Args>) => Eff\n    ): (...args: Args) => Effect.AsEffect<Eff>\n  }\n\n  /**\n   * @since 3.11.0\n   * @category Models\n   */\n  export type Untraced = {\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>>(\n      body: (...args: Args) => Generator<Eff, AEff, never>\n    ): (...args: Args) => Effect<\n      AEff,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n      [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n    >\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>, A>(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A\n    ): (...args: Args) => A\n    <Eff extends YieldWrap<Effect<any, any, any>>, AEff, Args extends Array<any>, A, B>(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B\n    ): (...args: Args) => B\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C\n    ): (...args: Args) => C\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D\n    ): (...args: Args) => D\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E\n    ): (...args: Args) => E\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F\n    ): (...args: Args) => F\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F,\n      g: (_: F, ...args: NoInfer<Args>) => G\n    ): (...args: Args) => G\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F,\n      g: (_: F, ...args: NoInfer<Args>) => G,\n      h: (_: G, ...args: NoInfer<Args>) => H\n    ): (...args: Args) => H\n    <\n      Eff extends YieldWrap<Effect<any, any, any>>,\n      AEff,\n      Args extends Array<any>,\n      A,\n      B,\n      C,\n      D,\n      E,\n      F,\n      G,\n      H,\n      I\n    >(\n      body: (...args: Args) => Generator<Eff, AEff, never>,\n      a: (\n        _: Effect<\n          AEff,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never,\n          [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never\n        >,\n        ...args: NoInfer<Args>\n      ) => A,\n      b: (_: A, ...args: NoInfer<Args>) => B,\n      c: (_: B, ...args: NoInfer<Args>) => C,\n      d: (_: C, ...args: NoInfer<Args>) => D,\n      e: (_: D, ...args: NoInfer<Args>) => E,\n      f: (_: E, ...args: NoInfer<Args>) => F,\n      g: (_: F, ...args: NoInfer<Args>) => G,\n      h: (_: G, ...args: NoInfer<Args>) => H,\n      i: (_: H, ...args: NoInfer<Args>) => I\n    ): (...args: Args) => I\n  }\n}\n\n/**\n * The `Effect.fn` function allows you to create traced functions that return an\n * effect. It provides two key features:\n *\n * - **Stack traces with location details** if an error occurs.\n * - **Automatic span creation** for tracing when a span name is provided.\n *\n * If a span name is passed as the first argument, the function's execution is\n * tracked using that name. If no name is provided, stack tracing still works,\n * but spans are not created.\n *\n * A function can be defined using either:\n *\n * - A generator function, allowing the use of `yield*` for effect composition.\n * - A regular function that returns an `Effect`.\n *\n * **Example** (Creating a Traced Function with a Span Name)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n *   yield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\n *   console.log(`got: ${n}`)\n *   yield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n * })\n *\n * Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n * // Output:\n * // got: 100\n * // timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n * //     at <anonymous> (/.../index.ts:6:22) <= Raise location\n * //     at myspan (/.../index.ts:3:23)  <= Definition location\n * //     at myspan (/.../index.ts:9:16)\" <= Call location\n * ```\n *\n * `Effect.fn` automatically creates spans. The spans capture information about\n * the function execution, including metadata and error details.\n *\n * **Example** (Exporting Spans to the Console)\n *\n * ```ts skip-type-checking\n * import { Effect } from \"effect\"\n * import { NodeSdk } from \"@effect/opentelemetry\"\n * import {\n *   ConsoleSpanExporter,\n *   BatchSpanProcessor\n * } from \"@opentelemetry/sdk-trace-base\"\n *\n * const myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n *   yield* Effect.annotateCurrentSpan(\"n\", n)\n *   console.log(`got: ${n}`)\n *   yield* Effect.fail(new Error(\"Boom!\"))\n * })\n *\n * const program = myfunc(100)\n *\n * const NodeSdkLive = NodeSdk.layer(() => ({\n *   resource: { serviceName: \"example\" },\n *   // Export span data to the console\n *   spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())\n * }))\n *\n * Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))\n * // Output:\n * // got: 100\n * // {\n * //   resource: {\n * //     attributes: {\n * //       'service.name': 'example',\n * //       'telemetry.sdk.language': 'nodejs',\n * //       'telemetry.sdk.name': '@effect/opentelemetry',\n * //       'telemetry.sdk.version': '1.30.1'\n * //     }\n * //   },\n * //   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },\n * //   traceId: '22801570119e57a6e2aacda3dec9665b',\n * //   parentId: undefined,\n * //   traceState: undefined,\n * //   name: 'myspan',\n * //   id: '7af530c1e01bc0cb',\n * //   kind: 0,\n * //   timestamp: 1741182277518402.2,\n * //   duration: 4300.416,\n * //   attributes: {\n * //     n: 100,\n * //     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +\n * //       'at <anonymous> (/.../index.ts:14:17)'\n * //   },\n * //   status: { code: 2, message: 'Boom!' },\n * //   events: [\n * //     {\n * //       name: 'exception',\n * //       attributes: {\n * //         'exception.type': 'Error',\n * //         'exception.message': 'Boom!',\n * //         'exception.stacktrace': 'Error: Boom!\\n' +\n * //           '    at <anonymous> (/.../index.ts:11:22)\\n' +\n * //           '    at myspan (/.../index.ts:8:23)\\n' +\n * //           '    at myspan (/.../index.ts:14:17)'\n * //       },\n * //       time: [ 1741182277, 522702583 ],\n * //       droppedAttributesCount: 0\n * //     }\n * //   ],\n * //   links: []\n * // }\n * ```\n *\n * `Effect.fn` also acts as a pipe function, allowing you to create a pipeline\n * after the function definition using the effect returned by the generator\n * function as the starting value of the pipeline.\n *\n * **Example** (Creating a Traced Function with a Delay)\n *\n * ```ts\n * import { Effect } from \"effect\"\n *\n * const myfunc = Effect.fn(\n *   function* (n: number) {\n *     console.log(`got: ${n}`)\n *     yield* Effect.fail(new Error(\"Boom!\"))\n *   },\n *   // You can access both the created effect and the original arguments\n *   (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n * )\n *\n * Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n * // Output:\n * // got: 100\n * // timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)\n * ```\n *\n * @see {@link fnUntraced} for a version of this function that doesn't add a span.\n *\n * @since 3.11.0\n * @category Tracing\n */\nexport const fn:\n  & fn.Gen\n  & fn.NonGen\n  & ((\n    name: string,\n    options?: Tracer.SpanOptions\n  ) => fn.Gen & fn.NonGen) = function(nameOrBody: Function | string, ...pipeables: Array<any>) {\n    const limit = Error.stackTraceLimit\n    Error.stackTraceLimit = 2\n    const errorDef = new Error()\n    Error.stackTraceLimit = limit\n    if (typeof nameOrBody !== \"string\") {\n      return defineLength(nameOrBody.length, function(this: any, ...args: Array<any>) {\n        const limit = Error.stackTraceLimit\n        Error.stackTraceLimit = 2\n        const errorCall = new Error()\n        Error.stackTraceLimit = limit\n        return fnApply({\n          self: this,\n          body: nameOrBody,\n          args,\n          pipeables,\n          spanName: \"<anonymous>\",\n          spanOptions: {\n            context: internalTracer.DisablePropagation.context(true)\n          },\n          errorDef,\n          errorCall\n        })\n      }) as any\n    }\n    const name = nameOrBody\n    const options = pipeables[0]\n    return (body: Function, ...pipeables: Array<any>) =>\n      defineLength(\n        body.length,\n        ({\n          [name](this: any, ...args: Array<any>) {\n            const limit = Error.stackTraceLimit\n            Error.stackTraceLimit = 2\n            const errorCall = new Error()\n            Error.stackTraceLimit = limit\n            return fnApply({\n              self: this,\n              body,\n              args,\n              pipeables,\n              spanName: name,\n              spanOptions: options,\n              errorDef,\n              errorCall\n            })\n          }\n        })[name]\n      )\n  }\n\nfunction defineLength<F extends Function>(length: number, fn: F) {\n  return Object.defineProperty(fn, \"length\", {\n    value: length,\n    configurable: true\n  })\n}\n\nfunction fnApply(options: {\n  readonly self: any\n  readonly body: Function\n  readonly args: Array<any>\n  readonly pipeables: Array<any>\n  readonly spanName: string\n  readonly spanOptions: Tracer.SpanOptions\n  readonly errorDef: Error\n  readonly errorCall: Error\n}) {\n  let effect: Effect<any, any, any>\n  let fnError: any = undefined\n  if (isGeneratorFunction(options.body)) {\n    effect = core.fromIterator(() => options.body.apply(options.self, options.args))\n  } else {\n    try {\n      effect = options.body.apply(options.self, options.args)\n    } catch (error) {\n      fnError = error\n      effect = die(error)\n    }\n  }\n  if (options.pipeables.length > 0) {\n    try {\n      for (const x of options.pipeables) {\n        effect = x(effect, ...options.args)\n      }\n    } catch (error) {\n      effect = fnError\n        ? failCause(internalCause.sequential(\n          internalCause.die(fnError),\n          internalCause.die(error)\n        ))\n        : die(error)\n    }\n  }\n\n  let cache: false | string = false\n  const captureStackTrace = () => {\n    if (cache !== false) {\n      return cache\n    }\n    if (options.errorCall.stack) {\n      const stackDef = options.errorDef.stack!.trim().split(\"\\n\")\n      const stackCall = options.errorCall.stack.trim().split(\"\\n\")\n      let endStackDef = stackDef.slice(2).join(\"\\n\").trim()\n      if (!endStackDef.includes(`(`)) {\n        endStackDef = endStackDef.replace(/at (.*)/, \"at ($1)\")\n      }\n      let endStackCall = stackCall.slice(2).join(\"\\n\").trim()\n      if (!endStackCall.includes(`(`)) {\n        endStackCall = endStackCall.replace(/at (.*)/, \"at ($1)\")\n      }\n      cache = `${endStackDef}\\n${endStackCall}`\n      return cache\n    }\n  }\n  const opts: any = (options.spanOptions && \"captureStackTrace\" in options.spanOptions)\n    ? options.spanOptions\n    : { captureStackTrace, ...options.spanOptions }\n  return withSpan(effect, options.spanName, opts)\n}\n\n/**\n * Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.\n *\n * @see {@link fn} for a version that includes tracing.\n *\n * @since 3.12.0\n * @category Tracing\n */\nexport const fnUntraced: fn.Untraced = core.fnUntraced\n\n// -----------------------------------------------------------------------------\n// Type constraints\n// -----------------------------------------------------------------------------\n\n/**\n * A no-op type constraint that enforces the success channel of an Effect conforms to\n * the specified success type `A`.\n *\n * @example\n * import { Effect } from \"effect\"\n *\n * // Ensure that the program does not expose any unhandled errors.\n * const program = Effect.succeed(42).pipe(Effect.ensureSuccessType<number>())\n *\n * @since 3.17.0\n * @category Type constraints\n */\nexport const ensureSuccessType = <A>() => <A2 extends A, E, R>(effect: Effect<A2, E, R>): Effect<A2, E, R> => effect\n\n/**\n * A no-op type constraint that enforces the error channel of an Effect conforms to\n * the specified error type `E`.\n *\n * @example\n * import { Effect } from \"effect\"\n *\n * // Ensure that the program does not expose any unhandled errors.\n * const program = Effect.succeed(42).pipe(Effect.ensureErrorType<never>())\n *\n * @since 3.17.0\n * @category Type constraints\n */\nexport const ensureErrorType = <E>() => <A, E2 extends E, R>(effect: Effect<A, E2, R>): Effect<A, E2, R> => effect\n\n/**\n * A no-op type constraint that enforces the requirements channel of an Effect conforms to\n * the specified requirements type `R`.\n *\n * @example\n * import { Effect } from \"effect\"\n *\n * // Ensure that the program does not have any requirements.\n * const program = Effect.succeed(42).pipe(Effect.ensureRequirementsType<never>())\n *\n * @since 3.17.0\n * @category Type constraints\n */\nexport const ensureRequirementsType = <R>() => <A, E, R2 extends R>(effect: Effect<A, E, R2>): Effect<A, E, R2> =>\n  effect\n","/**\n * @since 2.0.0\n */\nimport * as Arr from \"./Array.js\"\nimport * as Data from \"./Data.js\"\nimport type * as DateTime from \"./DateTime.js\"\nimport * as Either from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as equivalence from \"./Equivalence.js\"\nimport { constVoid, dual, identity, pipe } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport { format, type Inspectable, NodeInspectSymbol } from \"./Inspectable.js\"\nimport * as dateTime from \"./internal/dateTime.js\"\nimport * as N from \"./Number.js\"\nimport * as Option from \"./Option.js\"\nimport { type Pipeable, pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport * as String from \"./String.js\"\nimport type { Mutable } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Cron\")\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Cron extends Pipeable, Equal.Equal, Inspectable {\n  readonly [TypeId]: TypeId\n  readonly tz: Option.Option<DateTime.TimeZone>\n  readonly seconds: ReadonlySet<number>\n  readonly minutes: ReadonlySet<number>\n  readonly hours: ReadonlySet<number>\n  readonly days: ReadonlySet<number>\n  readonly months: ReadonlySet<number>\n  readonly weekdays: ReadonlySet<number>\n  /** @internal */\n  readonly first: {\n    readonly second: number\n    readonly minute: number\n    readonly hour: number\n    readonly day: number\n    readonly month: number\n    readonly weekday: number\n  }\n  /** @internal */\n  readonly next: {\n    readonly second: ReadonlyArray<number | undefined>\n    readonly minute: ReadonlyArray<number | undefined>\n    readonly hour: ReadonlyArray<number | undefined>\n    readonly day: ReadonlyArray<number | undefined>\n    readonly month: ReadonlyArray<number | undefined>\n    readonly weekday: ReadonlyArray<number | undefined>\n  }\n}\n\nconst CronProto = {\n  [TypeId]: TypeId,\n  [Equal.symbol](this: Cron, that: unknown) {\n    return isCron(that) && equals(this, that)\n  },\n  [Hash.symbol](this: Cron): number {\n    return pipe(\n      Hash.hash(this.tz),\n      Hash.combine(Hash.array(Arr.fromIterable(this.seconds))),\n      Hash.combine(Hash.array(Arr.fromIterable(this.minutes))),\n      Hash.combine(Hash.array(Arr.fromIterable(this.hours))),\n      Hash.combine(Hash.array(Arr.fromIterable(this.days))),\n      Hash.combine(Hash.array(Arr.fromIterable(this.months))),\n      Hash.combine(Hash.array(Arr.fromIterable(this.weekdays))),\n      Hash.cached(this)\n    )\n  },\n  toString(this: Cron) {\n    return format(this.toJSON())\n  },\n  toJSON(this: Cron) {\n    return {\n      _id: \"Cron\",\n      tz: this.tz,\n      seconds: Arr.fromIterable(this.seconds),\n      minutes: Arr.fromIterable(this.minutes),\n      hours: Arr.fromIterable(this.hours),\n      days: Arr.fromIterable(this.days),\n      months: Arr.fromIterable(this.months),\n      weekdays: Arr.fromIterable(this.weekdays)\n    }\n  },\n  [NodeInspectSymbol](this: Cron) {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * Checks if a given value is a `Cron` instance.\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isCron = (u: unknown): u is Cron => hasProperty(u, TypeId)\n\n/**\n * Creates a `Cron` instance.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = (values: {\n  readonly seconds?: Iterable<number> | undefined\n  readonly minutes: Iterable<number>\n  readonly hours: Iterable<number>\n  readonly days: Iterable<number>\n  readonly months: Iterable<number>\n  readonly weekdays: Iterable<number>\n  readonly tz?: DateTime.TimeZone | undefined\n}): Cron => {\n  const o: Mutable<Cron> = Object.create(CronProto)\n  o.seconds = new Set(Arr.sort(values.seconds ?? [0], N.Order))\n  o.minutes = new Set(Arr.sort(values.minutes, N.Order))\n  o.hours = new Set(Arr.sort(values.hours, N.Order))\n  o.days = new Set(Arr.sort(values.days, N.Order))\n  o.months = new Set(Arr.sort(values.months, N.Order))\n  o.weekdays = new Set(Arr.sort(values.weekdays, N.Order))\n  o.tz = Option.fromNullable(values.tz)\n\n  const seconds = Array.from(o.seconds)\n  const minutes = Array.from(o.minutes)\n  const hours = Array.from(o.hours)\n  const days = Array.from(o.days)\n  const months = Array.from(o.months)\n  const weekdays = Array.from(o.weekdays)\n\n  o.first = {\n    second: seconds[0] ?? 0,\n    minute: minutes[0] ?? 0,\n    hour: hours[0] ?? 0,\n    day: days[0] ?? 1,\n    month: (months[0] ?? 1) - 1,\n    weekday: weekdays[0] ?? 0\n  }\n\n  o.next = {\n    second: nextLookupTable(seconds, 60),\n    minute: nextLookupTable(minutes, 60),\n    hour: nextLookupTable(hours, 24),\n    day: nextLookupTable(days, 32),\n    month: nextLookupTable(months, 13),\n    weekday: nextLookupTable(weekdays, 7)\n  }\n\n  return o\n}\n\nconst nextLookupTable = (values: ReadonlyArray<number>, size: number): Array<number | undefined> => {\n  const result = new Array(size).fill(undefined)\n  if (values.length === 0) {\n    return result\n  }\n\n  let current: number | undefined = undefined\n  let index = values.length - 1\n  for (let i = size - 1; i >= 0; i--) {\n    while (index >= 0 && values[index] >= i) {\n      current = values[index--]\n    }\n    result[i] = current\n  }\n\n  return result\n}\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const ParseErrorTypeId: unique symbol = Symbol.for(\"effect/Cron/errors/ParseError\")\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ParseErrorTypeId = typeof ParseErrorTypeId\n\n/**\n * Represents a checked exception which occurs when decoding fails.\n *\n * @since 2.0.0\n * @category models\n */\nexport class ParseError extends Data.TaggedError(\"CronParseError\")<{\n  readonly message: string\n  readonly input?: string\n}> {\n  /**\n   * @since 2.0.0\n   */\n  readonly [ParseErrorTypeId] = ParseErrorTypeId\n}\n\n/**\n * Returns `true` if the specified value is an `ParseError`, `false` otherwise.\n *\n * @since 2.0.0\n * @category guards\n */\nexport const isParseError = (u: unknown): u is ParseError => hasProperty(u, ParseErrorTypeId)\n\n/**\n * Parses a cron expression into a `Cron` instance.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Cron, Either } from \"effect\"\n *\n * // At 04:00 on every day-of-month from 8 through 14.\n * assert.deepStrictEqual(Cron.parse(\"0 0 4 8-14 * *\"), Either.right(Cron.make({\n *   seconds: [0],\n *   minutes: [0],\n *   hours: [4],\n *   days: [8, 9, 10, 11, 12, 13, 14],\n *   months: [],\n *   weekdays: []\n * })))\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const parse = (cron: string, tz?: DateTime.TimeZone | string): Either.Either<Cron, ParseError> => {\n  const segments = cron.split(\" \").filter(String.isNonEmpty)\n  if (segments.length !== 5 && segments.length !== 6) {\n    return Either.left(\n      new ParseError({\n        message: `Invalid number of segments in cron expression`,\n        input: cron\n      })\n    )\n  }\n\n  if (segments.length === 5) {\n    segments.unshift(\"0\")\n  }\n\n  const [seconds, minutes, hours, days, months, weekdays] = segments\n  const zone = tz === undefined || dateTime.isTimeZone(tz) ?\n    Either.right(tz) :\n    Either.fromOption(dateTime.zoneFromString(tz), () =>\n      new ParseError({\n        message: `Invalid time zone in cron expression`,\n        input: tz\n      }))\n\n  return Either.all({\n    tz: zone,\n    seconds: parseSegment(seconds, secondOptions),\n    minutes: parseSegment(minutes, minuteOptions),\n    hours: parseSegment(hours, hourOptions),\n    days: parseSegment(days, dayOptions),\n    months: parseSegment(months, monthOptions),\n    weekdays: parseSegment(weekdays, weekdayOptions)\n  }).pipe(Either.map(make))\n}\n\n/**\n * Parses a cron expression into a `Cron` instance.\n *\n * **Details**\n *\n * This function takes a cron expression as a string and attempts to parse it\n * into a `Cron` instance. If the expression is valid, the resulting `Cron`\n * instance will represent the schedule defined by the cron expression.\n *\n * If the expression is invalid, the function throws a `ParseError`.\n *\n * You can optionally provide a time zone (`tz`) to interpret the cron\n * expression in a specific time zone. If no time zone is provided, the cron\n * expression will use the default time zone.\n *\n * @example\n * ```ts\n * import { Cron } from \"effect\"\n *\n * // At 04:00 on every day-of-month from 8 through 14.\n * console.log(Cron.unsafeParse(\"0 4 8-14 * *\"))\n * // Output:\n * // {\n * //   _id: 'Cron',\n * //   tz: { _id: 'Option', _tag: 'None' },\n * //   seconds: [ 0 ],\n * //   minutes: [ 0 ],\n * //   hours: [ 4 ],\n * //   days: [\n * //      8,  9, 10, 11,\n * //     12, 13, 14\n * //   ],\n * //   months: [],\n * //   weekdays: []\n * // }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unsafeParse = (cron: string, tz?: DateTime.TimeZone | string): Cron =>\n  Either.getOrThrowWith(parse(cron, tz), identity)\n\n/**\n * Checks if a given `Date` falls within an active `Cron` time window.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Cron, Either } from \"effect\"\n *\n * const cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\n * assert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 04:00:00\")), true)\n * assert.deepStrictEqual(Cron.match(cron, new Date(\"2021-01-08 05:00:00\")), false)\n * ```\n *\n * @throws `IllegalArgumentException` if the given `DateTime.Input` is invalid.\n *\n * @since 2.0.0\n */\nexport const match = (cron: Cron, date: DateTime.DateTime.Input): boolean => {\n  const parts = dateTime.unsafeMakeZoned(date, {\n    timeZone: Option.getOrUndefined(cron.tz)\n  }).pipe(dateTime.toParts)\n\n  if (cron.seconds.size !== 0 && !cron.seconds.has(parts.seconds)) {\n    return false\n  }\n\n  if (cron.minutes.size !== 0 && !cron.minutes.has(parts.minutes)) {\n    return false\n  }\n\n  if (cron.hours.size !== 0 && !cron.hours.has(parts.hours)) {\n    return false\n  }\n\n  if (cron.months.size !== 0 && !cron.months.has(parts.month)) {\n    return false\n  }\n\n  if (cron.days.size === 0 && cron.weekdays.size === 0) {\n    return true\n  }\n\n  if (cron.weekdays.size === 0) {\n    return cron.days.has(parts.day)\n  }\n\n  if (cron.days.size === 0) {\n    return cron.weekdays.has(parts.weekDay)\n  }\n\n  return cron.days.has(parts.day) || cron.weekdays.has(parts.weekDay)\n}\n\nconst daysInMonth = (date: Date): number =>\n  new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0)).getUTCDate()\n\n/**\n * Returns the next run `Date` for the given `Cron` instance.\n *\n * Uses the current time as a starting point if no value is provided for `now`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Cron, Either } from \"effect\"\n *\n * const after = new Date(\"2021-01-01 00:00:00\")\n * const cron = Either.getOrThrow(Cron.parse(\"0 4 8-14 * *\"))\n * assert.deepStrictEqual(Cron.next(cron, after), new Date(\"2021-01-08 04:00:00\"))\n * ```\n *\n * @throws `IllegalArgumentException` if the given `DateTime.Input` is invalid.\n * @throws `Error` if the next run date cannot be found within 10,000 iterations.\n *\n * @since 2.0.0\n */\nexport const next = (cron: Cron, startFrom?: DateTime.DateTime.Input): Date => {\n  const tz = Option.getOrUndefined(cron.tz)\n  const zoned = dateTime.unsafeMakeZoned(startFrom ?? new Date(), {\n    timeZone: tz\n  })\n\n  const utc = tz !== undefined && dateTime.isTimeZoneNamed(tz) && tz.id === \"UTC\"\n  const adjustDst = utc ? constVoid : (current: Date) => {\n    const adjusted = dateTime.unsafeMakeZoned(current, {\n      timeZone: zoned.zone,\n      adjustForTimeZone: true\n    }).pipe(dateTime.toDate)\n\n    // TODO: This implementation currently only skips forward when transitioning into daylight savings time.\n    const drift = current.getTime() - adjusted.getTime()\n    if (drift > 0) {\n      current.setTime(current.getTime() + drift)\n    }\n  }\n\n  const result = dateTime.mutate(zoned, (current) => {\n    current.setUTCSeconds(current.getUTCSeconds() + 1, 0)\n\n    for (let i = 0; i < 10_000; i++) {\n      if (cron.seconds.size !== 0) {\n        const currentSecond = current.getUTCSeconds()\n        const nextSecond = cron.next.second[currentSecond]\n        if (nextSecond === undefined) {\n          current.setUTCMinutes(current.getUTCMinutes() + 1, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n        if (nextSecond > currentSecond) {\n          current.setUTCSeconds(nextSecond)\n          adjustDst(current)\n          continue\n        }\n      }\n\n      if (cron.minutes.size !== 0) {\n        const currentMinute = current.getUTCMinutes()\n        const nextMinute = cron.next.minute[currentMinute]\n        if (nextMinute === undefined) {\n          current.setUTCHours(current.getUTCHours() + 1, cron.first.minute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n        if (nextMinute > currentMinute) {\n          current.setUTCMinutes(nextMinute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n      }\n\n      if (cron.hours.size !== 0) {\n        const currentHour = current.getUTCHours()\n        const nextHour = cron.next.hour[currentHour]\n        if (nextHour === undefined) {\n          current.setUTCDate(current.getUTCDate() + 1)\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n        if (nextHour > currentHour) {\n          current.setUTCHours(nextHour, cron.first.minute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n      }\n\n      if (cron.weekdays.size !== 0 || cron.days.size !== 0) {\n        let a: number = Infinity\n        let b: number = Infinity\n\n        if (cron.weekdays.size !== 0) {\n          const currentWeekday = current.getUTCDay()\n          const nextWeekday = cron.next.weekday[currentWeekday]\n          a = nextWeekday === undefined ? 7 - currentWeekday + cron.first.weekday : nextWeekday - currentWeekday\n        }\n\n        if (cron.days.size !== 0 && a !== 0) {\n          const currentDay = current.getUTCDate()\n          const nextDay = cron.next.day[currentDay]\n          b = nextDay === undefined ? daysInMonth(current) - currentDay + cron.first.day : nextDay - currentDay\n        }\n\n        const addDays = Math.min(a, b)\n        if (addDays !== 0) {\n          current.setUTCDate(current.getUTCDate() + addDays)\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n      }\n\n      if (cron.months.size !== 0) {\n        const currentMonth = current.getUTCMonth() + 1\n        const nextMonth = cron.next.month[currentMonth]\n        if (nextMonth === undefined) {\n          current.setUTCFullYear(current.getUTCFullYear() + 1)\n          current.setUTCMonth(cron.first.month, cron.first.day)\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n        if (nextMonth > currentMonth) {\n          current.setUTCMonth(nextMonth - 1, cron.first.day)\n          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second)\n          adjustDst(current)\n          continue\n        }\n      }\n\n      return\n    }\n\n    throw new Error(\"Unable to find next cron date\")\n  })\n\n  return dateTime.toDateUtc(result)\n}\n\n/**\n * Returns an `IterableIterator` which yields the sequence of `Date`s that match the `Cron` instance.\n *\n * @since 2.0.0\n */\nexport const sequence = function*(cron: Cron, startFrom?: DateTime.DateTime.Input): IterableIterator<Date> {\n  while (true) {\n    yield startFrom = next(cron, startFrom)\n  }\n}\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence: equivalence.Equivalence<Cron> = equivalence.make((self, that) =>\n  restrictionsEquals(self.seconds, that.seconds) &&\n  restrictionsEquals(self.minutes, that.minutes) &&\n  restrictionsEquals(self.hours, that.hours) &&\n  restrictionsEquals(self.days, that.days) &&\n  restrictionsEquals(self.months, that.months) &&\n  restrictionsEquals(self.weekdays, that.weekdays)\n)\n\nconst restrictionsArrayEquals = equivalence.array(equivalence.number)\nconst restrictionsEquals = (self: ReadonlySet<number>, that: ReadonlySet<number>): boolean =>\n  restrictionsArrayEquals(Arr.fromIterable(self), Arr.fromIterable(that))\n\n/**\n * Checks if two `Cron`s are equal.\n *\n * @since 2.0.0\n * @category predicates\n */\nexport const equals: {\n  /**\n   * Checks if two `Cron`s are equal.\n   *\n   * @since 2.0.0\n   * @category predicates\n   */\n  (that: Cron): (self: Cron) => boolean\n  /**\n   * Checks if two `Cron`s are equal.\n   *\n   * @since 2.0.0\n   * @category predicates\n   */\n  (self: Cron, that: Cron): boolean\n} = dual(2, (self: Cron, that: Cron): boolean => Equivalence(self, that))\n\ninterface SegmentOptions {\n  min: number\n  max: number\n  aliases?: Record<string, number> | undefined\n}\n\nconst secondOptions: SegmentOptions = {\n  min: 0,\n  max: 59\n}\n\nconst minuteOptions: SegmentOptions = {\n  min: 0,\n  max: 59\n}\n\nconst hourOptions: SegmentOptions = {\n  min: 0,\n  max: 23\n}\n\nconst dayOptions: SegmentOptions = {\n  min: 1,\n  max: 31\n}\n\nconst monthOptions: SegmentOptions = {\n  min: 1,\n  max: 12,\n  aliases: {\n    jan: 1,\n    feb: 2,\n    mar: 3,\n    apr: 4,\n    may: 5,\n    jun: 6,\n    jul: 7,\n    aug: 8,\n    sep: 9,\n    oct: 10,\n    nov: 11,\n    dec: 12\n  }\n}\n\nconst weekdayOptions: SegmentOptions = {\n  min: 0,\n  max: 6,\n  aliases: {\n    sun: 0,\n    mon: 1,\n    tue: 2,\n    wed: 3,\n    thu: 4,\n    fri: 5,\n    sat: 6\n  }\n}\n\nconst parseSegment = (\n  input: string,\n  options: SegmentOptions\n): Either.Either<ReadonlySet<number>, ParseError> => {\n  const capacity = options.max - options.min + 1\n  const values = new Set<number>()\n  const fields = input.split(\",\")\n\n  for (const field of fields) {\n    const [raw, step] = splitStep(field)\n    if (raw === \"*\" && step === undefined) {\n      return Either.right(new Set())\n    }\n\n    if (step !== undefined) {\n      if (!Number.isInteger(step)) {\n        return Either.left(new ParseError({ message: `Expected step value to be a positive integer`, input }))\n      }\n      if (step < 1) {\n        return Either.left(new ParseError({ message: `Expected step value to be greater than 0`, input }))\n      }\n      if (step > options.max) {\n        return Either.left(new ParseError({ message: `Expected step value to be less than ${options.max}`, input }))\n      }\n    }\n\n    if (raw === \"*\") {\n      for (let i = options.min; i <= options.max; i += step ?? 1) {\n        values.add(i)\n      }\n    } else {\n      const [left, right] = splitRange(raw, options.aliases)\n      if (!Number.isInteger(left)) {\n        return Either.left(new ParseError({ message: `Expected a positive integer`, input }))\n      }\n      if (left < options.min || left > options.max) {\n        return Either.left(\n          new ParseError({ message: `Expected a value between ${options.min} and ${options.max}`, input })\n        )\n      }\n\n      if (right === undefined) {\n        values.add(left)\n      } else {\n        if (!Number.isInteger(right)) {\n          return Either.left(new ParseError({ message: `Expected a positive integer`, input }))\n        }\n        if (right < options.min || right > options.max) {\n          return Either.left(\n            new ParseError({ message: `Expected a value between ${options.min} and ${options.max}`, input })\n          )\n        }\n        if (left > right) {\n          return Either.left(new ParseError({ message: `Invalid value range`, input }))\n        }\n\n        for (let i = left; i <= right; i += step ?? 1) {\n          values.add(i)\n        }\n      }\n    }\n\n    if (values.size >= capacity) {\n      return Either.right(new Set())\n    }\n  }\n\n  return Either.right(values)\n}\n\nconst splitStep = (input: string): [string, number | undefined] => {\n  const seperator = input.indexOf(\"/\")\n  if (seperator !== -1) {\n    return [input.slice(0, seperator), Number(input.slice(seperator + 1))]\n  }\n\n  return [input, undefined]\n}\n\nconst splitRange = (input: string, aliases?: Record<string, number>): [number, number | undefined] => {\n  const seperator = input.indexOf(\"-\")\n  if (seperator !== -1) {\n    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)]\n  }\n\n  return [aliasOrValue(input, aliases), undefined]\n}\n\nfunction aliasOrValue(field: string, aliases?: Record<string, number>): number {\n  return aliases?.[field.toLocaleLowerCase()] ?? Number(field)\n}\n","/**\n * @since 2.0.0\n */\nimport * as Chunk from \"./Chunk.js\"\nimport * as Dual from \"./Function.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport * as MutableList from \"./MutableList.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/MutableQueue\") as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport const EmptyMutableQueue = Symbol.for(\"effect/mutable/MutableQueue/Empty\")\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface MutableQueue<out A> extends Iterable<A>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  queue: MutableList.MutableList<A>\n  /** @internal */\n  capacity: number | undefined\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MutableQueue {\n  /**\n   * @since 2.0.0\n   */\n  export type Empty = typeof EmptyMutableQueue\n}\n\nconst MutableQueueProto: Omit<MutableQueue<unknown>, \"queue\" | \"capacity\"> = {\n  [TypeId]: TypeId,\n  [Symbol.iterator]<A>(this: MutableQueue<A>): Iterator<A> {\n    return Array.from(this.queue)[Symbol.iterator]()\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"MutableQueue\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst make = <A>(capacity: number | undefined): MutableQueue<A> => {\n  const queue = Object.create(MutableQueueProto)\n  queue.queue = MutableList.empty()\n  queue.capacity = capacity\n  return queue\n}\n\n/**\n * Creates a new bounded `MutableQueue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const bounded = <A>(capacity: number): MutableQueue<A> => make(capacity)\n\n/**\n * Creates a new unbounded `MutableQueue`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const unbounded = <A>(): MutableQueue<A> => make(undefined)\n\n/**\n * Returns the current number of elements in the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const length = <A>(self: MutableQueue<A>): number => MutableList.length(self.queue)\n\n/**\n * Returns `true` if the queue is empty, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = <A>(self: MutableQueue<A>): boolean => MutableList.isEmpty(self.queue)\n\n/**\n * Returns `true` if the queue is full, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFull = <A>(self: MutableQueue<A>): boolean =>\n  self.capacity === undefined ? false : MutableList.length(self.queue) === self.capacity\n\n/**\n * The **maximum** number of elements that a queue can hold.\n *\n * **Note**: unbounded queues can still implement this interface with\n * `capacity = Infinity`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const capacity = <A>(self: MutableQueue<A>): number => self.capacity === undefined ? Infinity : self.capacity\n\n/**\n * Offers an element to the queue.\n *\n * Returns whether the enqueue was successful or not.\n *\n * @since 2.0.0\n */\nexport const offer: {\n  /**\n   * Offers an element to the queue.\n   *\n   * Returns whether the enqueue was successful or not.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: MutableQueue<A>, value: A): boolean\n  /**\n   * Offers an element to the queue.\n   *\n   * Returns whether the enqueue was successful or not.\n   *\n   * @since 2.0.0\n   */\n  <A>(value: A): (self: MutableQueue<A>) => boolean\n} = Dual.dual<\n  <A>(value: A) => (self: MutableQueue<A>) => boolean,\n  <A>(self: MutableQueue<A>, value: A) => boolean\n>(2, <A>(self: MutableQueue<A>, value: A) => {\n  const queueLength = MutableList.length(self.queue)\n  if (self.capacity !== undefined && queueLength === self.capacity) {\n    return false\n  }\n  MutableList.append(value)(self.queue)\n  return true\n})\n\n/**\n * Enqueues a collection of values into the queue.\n *\n * Returns a `Chunk` of the values that were **not** able to be enqueued.\n *\n * @since 2.0.0\n */\nexport const offerAll: {\n  /**\n   * Enqueues a collection of values into the queue.\n   *\n   * Returns a `Chunk` of the values that were **not** able to be enqueued.\n   *\n   * @since 2.0.0\n   */\n  <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>\n  /**\n   * Enqueues a collection of values into the queue.\n   *\n   * Returns a `Chunk` of the values that were **not** able to be enqueued.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>\n} = Dual.dual<\n  <A>(values: Iterable<A>) => (self: MutableQueue<A>) => Chunk.Chunk<A>,\n  <A>(self: MutableQueue<A>, values: Iterable<A>) => Chunk.Chunk<A>\n>(2, <A>(self: MutableQueue<A>, values: Iterable<A>) => {\n  const iterator = values[Symbol.iterator]()\n  let next: IteratorResult<A> | undefined\n  let remainder = Chunk.empty<A>()\n  let offering = true\n  while (offering && (next = iterator.next()) && !next.done) {\n    offering = offer(next.value)(self)\n  }\n  while (next != null && !next.done) {\n    remainder = Chunk.prepend<A>(next.value)(remainder)\n    next = iterator.next()\n  }\n  return Chunk.reverse(remainder)\n})\n\n/**\n * Dequeues an element from the queue.\n *\n * Returns either an element from the queue, or the `def` param.\n *\n * **Note**: if there is no meaningful default for your type, you can always\n * use `poll(MutableQueue.EmptyMutableQueue)`.\n *\n * @since 2.0.0\n */\nexport const poll: {\n  /**\n   * Dequeues an element from the queue.\n   *\n   * Returns either an element from the queue, or the `def` param.\n   *\n   * **Note**: if there is no meaningful default for your type, you can always\n   * use `poll(MutableQueue.EmptyMutableQueue)`.\n   *\n   * @since 2.0.0\n   */\n  <D>(def: D): <A>(self: MutableQueue<A>) => D | A\n  /**\n   * Dequeues an element from the queue.\n   *\n   * Returns either an element from the queue, or the `def` param.\n   *\n   * **Note**: if there is no meaningful default for your type, you can always\n   * use `poll(MutableQueue.EmptyMutableQueue)`.\n   *\n   * @since 2.0.0\n   */\n  <A, D>(self: MutableQueue<A>, def: D): A | D\n} = Dual.dual<\n  <D>(def: D) => <A>(self: MutableQueue<A>) => A | D,\n  <A, D>(self: MutableQueue<A>, def: D) => A | D\n>(2, (self, def) => {\n  if (MutableList.isEmpty(self.queue)) {\n    return def\n  }\n  return MutableList.shift(self.queue)!\n})\n\n/**\n * Dequeues up to `n` elements from the queue.\n *\n * Returns a `List` of up to `n` elements.\n *\n * @since 2.0.0\n */\nexport const pollUpTo: {\n  /**\n   * Dequeues up to `n` elements from the queue.\n   *\n   * Returns a `List` of up to `n` elements.\n   *\n   * @since 2.0.0\n   */\n  (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>\n  /**\n   * Dequeues up to `n` elements from the queue.\n   *\n   * Returns a `List` of up to `n` elements.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>\n} = Dual.dual<\n  (n: number) => <A>(self: MutableQueue<A>) => Chunk.Chunk<A>,\n  <A>(self: MutableQueue<A>, n: number) => Chunk.Chunk<A>\n>(2, <A>(self: MutableQueue<A>, n: number) => {\n  let result = Chunk.empty<A>()\n  let count = 0\n  while (count < n) {\n    const element = poll(EmptyMutableQueue)(self)\n    if (element === EmptyMutableQueue) {\n      break\n    }\n    result = Chunk.prepend(element)(result)\n    count += 1\n  }\n  return Chunk.reverse(result)\n})\n","import type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Cron from \"../Cron.js\"\nimport type * as DateTime from \"../DateTime.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constVoid, dual, pipe } from \"../Function.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, type Predicate } from \"../Predicate.js\"\nimport * as Random from \"../Random.js\"\nimport type * as Ref from \"../Ref.js\"\nimport type * as Schedule from \"../Schedule.js\"\nimport * as ScheduleDecision from \"../ScheduleDecision.js\"\nimport * as Interval from \"../ScheduleInterval.js\"\nimport * as Intervals from \"../ScheduleIntervals.js\"\nimport type { Scope } from \"../Scope.js\"\nimport type * as Types from \"../Types.js\"\nimport * as internalCause from \"./cause.js\"\nimport * as effect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport { forkScoped } from \"./effect/circular.js\"\nimport * as ref from \"./ref.js\"\n\n/** @internal */\nconst ScheduleSymbolKey = \"effect/Schedule\"\n\n/** @internal */\nexport const ScheduleTypeId: Schedule.ScheduleTypeId = Symbol.for(\n  ScheduleSymbolKey\n) as Schedule.ScheduleTypeId\n\n/** @internal */\nexport const isSchedule = (u: unknown): u is Schedule.Schedule<unknown, never, unknown> =>\n  hasProperty(u, ScheduleTypeId)\n\n/** @internal */\nconst ScheduleDriverSymbolKey = \"effect/ScheduleDriver\"\n\n/** @internal */\nexport const ScheduleDriverTypeId: Schedule.ScheduleDriverTypeId = Symbol.for(\n  ScheduleDriverSymbolKey\n) as Schedule.ScheduleDriverTypeId\n\n/** @internal */\nconst defaultIterationMetadata: Schedule.IterationMetadata = {\n  start: 0,\n  now: 0,\n  input: undefined,\n  output: undefined,\n  elapsed: Duration.zero,\n  elapsedSincePrevious: Duration.zero,\n  recurrence: 0\n}\n\n/** @internal */\nexport const CurrentIterationMetadata = Context.Reference<Schedule.CurrentIterationMetadata>()(\n  \"effect/Schedule/CurrentIterationMetadata\",\n  { defaultValue: () => defaultIterationMetadata }\n)\n\nconst scheduleVariance = {\n  /* c8 ignore next */\n  _Out: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\nconst scheduleDriverVariance = {\n  /* c8 ignore next */\n  _Out: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nclass ScheduleImpl<S, Out, In, R> implements Schedule.Schedule<Out, In, R> {\n  [ScheduleTypeId] = scheduleVariance\n  constructor(\n    readonly initial: S,\n    readonly step: (\n      now: number,\n      input: In,\n      state: S\n    ) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>\n  ) {\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nconst updateInfo = (\n  iterationMetaRef: Ref.Ref<Schedule.IterationMetadata>,\n  now: number,\n  input: unknown,\n  output: unknown\n) =>\n  ref.update(iterationMetaRef, (prev) =>\n    (prev.recurrence === 0) ?\n      {\n        now,\n        input,\n        output,\n        recurrence: prev.recurrence + 1,\n        elapsed: Duration.zero,\n        elapsedSincePrevious: Duration.zero,\n        start: now\n      } :\n      {\n        now,\n        input,\n        output,\n        recurrence: prev.recurrence + 1,\n        elapsed: Duration.millis(now - prev.start),\n        elapsedSincePrevious: Duration.millis(now - prev.now),\n        start: prev.start\n      })\n\n/** @internal */\nclass ScheduleDriverImpl<Out, In, R> implements Schedule.ScheduleDriver<Out, In, R> {\n  [ScheduleDriverTypeId] = scheduleDriverVariance\n\n  constructor(\n    readonly schedule: Schedule.Schedule<Out, In, R>,\n    readonly ref: Ref.Ref<readonly [Option.Option<Out>, any]>\n  ) {}\n\n  get state(): Effect.Effect<unknown> {\n    return core.map(ref.get(this.ref), (tuple) => tuple[1])\n  }\n\n  get last(): Effect.Effect<Out, Cause.NoSuchElementException> {\n    return core.flatMap(ref.get(this.ref), ([element, _]) => {\n      switch (element._tag) {\n        case \"None\": {\n          return core.failSync(() => new core.NoSuchElementException())\n        }\n        case \"Some\": {\n          return core.succeed(element.value)\n        }\n      }\n    })\n  }\n\n  iterationMeta = ref.unsafeMake(defaultIterationMetadata)\n\n  get reset(): Effect.Effect<void> {\n    return ref.set(this.ref, [Option.none(), this.schedule.initial]).pipe(\n      core.zipLeft(ref.set(this.iterationMeta, defaultIterationMetadata))\n    )\n  }\n\n  next(input: In): Effect.Effect<Out, Option.Option<never>, R> {\n    return pipe(\n      core.map(ref.get(this.ref), (tuple) => tuple[1]),\n      core.flatMap((state) =>\n        pipe(\n          Clock.currentTimeMillis,\n          core.flatMap((now) =>\n            pipe(\n              core.suspend(() => this.schedule.step(now, input, state)),\n              core.flatMap(([state, out, decision]) => {\n                const setState = ref.set(this.ref, [Option.some(out), state] as const)\n                if (ScheduleDecision.isDone(decision)) {\n                  return setState.pipe(\n                    core.zipRight(core.fail(Option.none()))\n                  )\n                }\n                const millis = Intervals.start(decision.intervals) - now\n                if (millis <= 0) {\n                  return setState.pipe(\n                    core.zipRight(updateInfo(this.iterationMeta, now, input, out)),\n                    core.as(out)\n                  )\n                }\n                const duration = Duration.millis(millis)\n                return pipe(\n                  setState,\n                  core.zipRight(updateInfo(this.iterationMeta, now, input, out)),\n                  core.zipRight(effect.sleep(duration)),\n                  core.as(out)\n                )\n              })\n            )\n          )\n        )\n      )\n    )\n  }\n}\n\n/** @internal */\nexport const makeWithState = <S, In, Out, R = never>(\n  initial: S,\n  step: (\n    now: number,\n    input: In,\n    state: S\n  ) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>\n): Schedule.Schedule<Out, In, R> => new ScheduleImpl(initial, step)\n\n/** @internal */\nexport const addDelay = dual<\n  <Out>(\n    f: (out: Out) => Duration.DurationInput\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Duration.DurationInput\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => addDelayEffect(self, (out) => core.sync(() => f(out))))\n\n/** @internal */\nexport const addDelayEffect = dual<\n  <Out, R2>(\n    f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) =>\n  modifyDelayEffect(self, (out, duration) =>\n    core.map(\n      f(out),\n      (delay) => Duration.sum(duration, Duration.decode(delay))\n    )))\n\n/** @internal */\nexport const andThen = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<\n    Out | Out2,\n    In & In2,\n    R | R2\n  >,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<\n    Out | Out2,\n    In & In2,\n    R | R2\n  >\n>(2, (self, that) => map(andThenEither(self, that), Either.merge))\n\n/** @internal */\nexport const andThenEither = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>\n  ) => Schedule.Schedule<Either.Either<Out2, Out>, In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<Either.Either<Out2, Out>, In & In2, R | R2>\n>(2, <Out, In, R, Out2, In2, R2>(\n  self: Schedule.Schedule<Out, In, R>,\n  that: Schedule.Schedule<Out2, In2, R2>\n): Schedule.Schedule<Either.Either<Out2, Out>, In & In2, R | R2> =>\n  makeWithState(\n    [self.initial, that.initial, true as boolean] as const,\n    (now, input, state) =>\n      state[2] ?\n        core.flatMap(self.step(now, input, state[0]), ([lState, out, decision]) => {\n          if (ScheduleDecision.isDone(decision)) {\n            return core.map(that.step(now, input, state[1]), ([rState, out, decision]) =>\n              [\n                [lState, rState, false as boolean] as const,\n                Either.right(out) as Either.Either<Out2, Out>,\n                decision as ScheduleDecision.ScheduleDecision\n              ] as const)\n          }\n          return core.succeed(\n            [\n              [lState, state[1], true as boolean] as const,\n              Either.left(out),\n              decision\n            ] as const\n          )\n        }) :\n        core.map(that.step(now, input, state[1]), ([rState, out, decision]) =>\n          [\n            [state[0], rState, false as boolean] as const,\n            Either.right(out) as Either.Either<Out2, Out>,\n            decision\n          ] as const)\n  ))\n\n/** @internal */\nexport const as = dual<\n  <Out2>(out: Out2) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In, R>,\n  <Out, In, R, Out2>(self: Schedule.Schedule<Out, In, R>, out: Out2) => Schedule.Schedule<Out2, In, R>\n>(2, (self, out) => map(self, () => out))\n\n/** @internal */\nexport const asVoid = <Out, In, R>(\n  self: Schedule.Schedule<Out, In, R>\n): Schedule.Schedule<void, In, R> => map(self, constVoid)\n\n/** @internal */\nexport const bothInOut = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>\n  ) => Schedule.Schedule<[Out, Out2], readonly [In, In2], R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<[Out, Out2], readonly [In, In2], R | R2>\n>(2, (self, that) =>\n  makeWithState([self.initial, that.initial], (now, [in1, in2], state) =>\n    core.zipWith(\n      self.step(now, in1, state[0]),\n      that.step(now, in2, state[1]),\n      ([lState, out, lDecision], [rState, out2, rDecision]) => {\n        if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n          const interval = pipe(lDecision.intervals, Intervals.union(rDecision.intervals))\n          return [\n            [lState, rState],\n            [out, out2],\n            ScheduleDecision.continue(interval)\n          ]\n        }\n        return [[lState, rState], [out, out2], ScheduleDecision.done]\n      }\n    )))\n\n/** @internal */\nexport const check = dual<\n  <In, Out>(\n    test: (input: In, output: Out) => boolean\n  ) => <R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    test: (input: In, output: Out) => boolean\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, test) => checkEffect(self, (input, out) => core.sync(() => test(input, out))))\n\n/** @internal */\nexport const checkEffect = dual<\n  <In, Out, R2>(\n    test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>\n  ) => <R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, test) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) =>\n      core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n        if (ScheduleDecision.isDone(decision)) {\n          return core.succeed([state, out, ScheduleDecision.done] as const)\n        }\n        return core.map(test(input, out), (cont) =>\n          cont ?\n            [state, out, decision] as const :\n            [state, out, ScheduleDecision.done] as const)\n      })\n  ))\n/** @internal */\nexport const collectAllInputs = <A>(): Schedule.Schedule<Chunk.Chunk<A>, A> => collectAllOutputs(identity<A>())\n\n/** @internal */\nexport const collectAllOutputs = <Out, In, R>(\n  self: Schedule.Schedule<Out, In, R>\n): Schedule.Schedule<Chunk.Chunk<Out>, In, R> =>\n  reduce(self, Chunk.empty<Out>(), (outs, out) => pipe(outs, Chunk.append(out)))\n\n/** @internal */\nexport const collectUntil = <A>(f: Predicate<A>): Schedule.Schedule<Chunk.Chunk<A>, A> =>\n  collectAllOutputs(recurUntil(f))\n\n/** @internal */\nexport const collectUntilEffect = <A, R>(\n  f: (a: A) => Effect.Effect<boolean, never, R>\n): Schedule.Schedule<Chunk.Chunk<A>, A, R> => collectAllOutputs(recurUntilEffect(f))\n\n/** @internal */\nexport const collectWhile = <A>(f: Predicate<A>): Schedule.Schedule<Chunk.Chunk<A>, A> =>\n  collectAllOutputs(recurWhile(f))\n\n/** @internal */\nexport const collectWhileEffect = <A, R>(\n  f: (a: A) => Effect.Effect<boolean, never, R>\n): Schedule.Schedule<Chunk.Chunk<A>, A, R> => collectAllOutputs(recurWhileEffect(f))\n\n/** @internal */\nexport const compose = dual<\n  <Out2, Out, R2>(\n    that: Schedule.Schedule<Out2, Out, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In, R | R2>,\n  <Out, In, R, Out2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, Out, R2>\n  ) => Schedule.Schedule<Out2, In, R | R2>\n>(2, (self, that) =>\n  makeWithState(\n    [self.initial, that.initial] as const,\n    (now, input, state) =>\n      core.flatMap(\n        self.step(now, input, state[0]),\n        ([lState, out, lDecision]) =>\n          core.map(that.step(now, out, state[1]), ([rState, out2, rDecision]) =>\n            ScheduleDecision.isDone(lDecision)\n              ? [[lState, rState] as const, out2, ScheduleDecision.done] as const\n              : ScheduleDecision.isDone(rDecision)\n              ? [[lState, rState] as const, out2, ScheduleDecision.done] as const\n              : [\n                [lState, rState] as const,\n                out2,\n                ScheduleDecision.continue(pipe(lDecision.intervals, Intervals.max(rDecision.intervals)))\n              ] as const)\n      )\n  ))\n\n/** @internal */\nexport const mapInput = dual<\n  <In, In2>(\n    f: (in2: In2) => In\n  ) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In2, R>,\n  <Out, In, R, In2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (in2: In2) => In\n  ) => Schedule.Schedule<Out, In2, R>\n>(2, (self, f) => mapInputEffect(self, (input2) => core.sync(() => f(input2))))\n\n/** @internal */\nexport const mapInputContext = dual<\n  <R0, R>(\n    f: (env0: Context.Context<R0>) => Context.Context<R>\n  ) => <Out, In>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R0>,\n  <Out, In, R, R0>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (env0: Context.Context<R0>) => Context.Context<R>\n  ) => Schedule.Schedule<Out, In, R0>\n>(2, (self, f) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) => core.mapInputContext(self.step(now, input, state), f)\n  ))\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <In2, In, R2>(\n    f: (in2: In2) => Effect.Effect<In, never, R2>\n  ) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In2, R | R2>,\n  <Out, In, R, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (in2: In2) => Effect.Effect<In, never, R2>\n  ) => Schedule.Schedule<Out, In2, R | R2>\n>(2, (self, f) =>\n  makeWithState(self.initial, (now, input2, state) =>\n    core.flatMap(\n      f(input2),\n      (input) => self.step(now, input, state)\n    )))\n\n/** @internal */\nexport const cron: {\n  (expression: Cron.Cron): Schedule.Schedule<[number, number]>\n  (expression: string, tz?: DateTime.TimeZone | string): Schedule.Schedule<[number, number]>\n} = (expression: string | Cron.Cron, tz?: DateTime.TimeZone | string): Schedule.Schedule<[number, number]> => {\n  const parsed = Cron.isCron(expression) ? Either.right(expression) : Cron.parse(expression, tz)\n  return makeWithState<[boolean, [number, number, number]], unknown, [number, number]>(\n    [true, [Number.MIN_SAFE_INTEGER, 0, 0]],\n    (now, _, [initial, previous]) => {\n      if (now < previous[0]) {\n        return core.succeed([\n          [false, previous],\n          [previous[1], previous[2]],\n          ScheduleDecision.continueWith(Interval.make(previous[1], previous[2]))\n        ])\n      }\n\n      if (Either.isLeft(parsed)) {\n        return core.die(parsed.left)\n      }\n\n      const cron = parsed.right\n      const date = new Date(now)\n\n      let next: number\n      if (initial && Cron.match(cron, date)) {\n        next = now\n      }\n\n      next = Cron.next(cron, date).getTime()\n      const start = beginningOfSecond(next)\n      const end = endOfSecond(next)\n      return core.succeed([\n        [false, [next, start, end]],\n        [start, end],\n        ScheduleDecision.continueWith(Interval.make(start, end))\n      ])\n    }\n  )\n}\n\n/** @internal */\nexport const dayOfMonth = (day: number): Schedule.Schedule<number> => {\n  return makeWithState<[number, number], unknown, number>(\n    [Number.NEGATIVE_INFINITY, 0],\n    (now, _, state) => {\n      if (!Number.isInteger(day) || day < 1 || 31 < day) {\n        return core.dieSync(() =>\n          new core.IllegalArgumentException(\n            `Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`\n          )\n        )\n      }\n      const n = state[1]\n      const initial = n === 0\n      const day0 = nextDayOfMonth(now, day, initial)\n      const start = beginningOfDay(day0)\n      const end = endOfDay(day0)\n      const interval = Interval.make(start, end)\n      return core.succeed(\n        [\n          [end, n + 1],\n          n,\n          ScheduleDecision.continueWith(interval)\n        ]\n      )\n    }\n  )\n}\n\n/** @internal */\nexport const dayOfWeek = (day: number): Schedule.Schedule<number> => {\n  return makeWithState<[number, number], unknown, number>(\n    [Number.MIN_SAFE_INTEGER, 0],\n    (now, _, state) => {\n      if (!Number.isInteger(day) || day < 1 || 7 < day) {\n        return core.dieSync(() =>\n          new core.IllegalArgumentException(\n            `Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`\n          )\n        )\n      }\n      const n = state[1]\n      const initial = n === 0\n      const day0 = nextDay(now, day, initial)\n      const start = beginningOfDay(day0)\n      const end = endOfDay(day0)\n      const interval = Interval.make(start, end)\n      return core.succeed(\n        [\n          [end, n + 1],\n          n,\n          ScheduleDecision.continueWith(interval)\n        ]\n      )\n    }\n  )\n}\n\n/** @internal */\nexport const delayed = dual<\n  (\n    f: (duration: Duration.Duration) => Duration.DurationInput\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (duration: Duration.Duration) => Duration.DurationInput\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => delayedEffect(self, (duration) => core.sync(() => f(duration))))\n\n/** @internal */\nexport const delayedEffect = dual<\n  <R2>(\n    f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) => modifyDelayEffect(self, (_, delay) => f(delay)))\n\n/** @internal */\nexport const delayedSchedule = <In, R>(\n  schedule: Schedule.Schedule<Duration.Duration, In, R>\n): Schedule.Schedule<Duration.Duration, In, R> => addDelay(schedule, (x) => x)\n\n/** @internal */\nexport const delays = <Out, In, R>(\n  self: Schedule.Schedule<Out, In, R>\n): Schedule.Schedule<Duration.Duration, In, R> =>\n  makeWithState(self.initial, (now, input, state) =>\n    pipe(\n      self.step(now, input, state),\n      core.flatMap((\n        [state, _, decision]\n      ): Effect.Effect<[any, Duration.Duration, ScheduleDecision.ScheduleDecision]> => {\n        if (ScheduleDecision.isDone(decision)) {\n          return core.succeed([state, Duration.zero, decision])\n        }\n        return core.succeed(\n          [\n            state,\n            Duration.millis(Intervals.start(decision.intervals) - now),\n            decision\n          ]\n        )\n      })\n    ))\n\n/** @internal */\nexport const mapBoth = dual<\n  <In2, In, Out, Out2>(\n    options: {\n      readonly onInput: (in2: In2) => In\n      readonly onOutput: (out: Out) => Out2\n    }\n  ) => <R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In2, R>,\n  <Out, In, R, In2, Out2>(\n    self: Schedule.Schedule<Out, In, R>,\n    options: {\n      readonly onInput: (in2: In2) => In\n      readonly onOutput: (out: Out) => Out2\n    }\n  ) => Schedule.Schedule<Out2, In2, R>\n>(2, (self, { onInput, onOutput }) => map(mapInput(self, onInput), onOutput))\n\n/** @internal */\nexport const mapBothEffect = dual<\n  <In2, In, R2, Out, R3, Out2>(\n    options: {\n      readonly onInput: (input: In2) => Effect.Effect<In, never, R2>\n      readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>\n    }\n  ) => <R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In2, R | R2 | R3>,\n  <Out, In, R, In2, R2, Out2, R3>(\n    self: Schedule.Schedule<Out, In, R>,\n    options: {\n      readonly onInput: (input: In2) => Effect.Effect<In, never, R2>\n      readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>\n    }\n  ) => Schedule.Schedule<Out2, In2, R | R2 | R3>\n>(2, (self, { onInput, onOutput }) => mapEffect(mapInputEffect(self, onInput), onOutput))\n\n/** @internal */\nexport const driver = <Out, In, R>(\n  self: Schedule.Schedule<Out, In, R>\n): Effect.Effect<Schedule.ScheduleDriver<Out, In, R>> =>\n  pipe(\n    ref.make<readonly [Option.Option<Out>, any]>([Option.none(), self.initial]),\n    core.map((ref) => new ScheduleDriverImpl(self, ref))\n  )\n\n/** @internal */\nexport const duration = (\n  durationInput: Duration.DurationInput\n): Schedule.Schedule<Duration.Duration> => {\n  const duration = Duration.decode(durationInput)\n  const durationMillis = Duration.toMillis(duration)\n  return makeWithState(true as boolean, (now, _, state) =>\n    core.succeed(\n      state\n        ? [\n          false,\n          duration,\n          ScheduleDecision.continueWith(Interval.after(now + durationMillis))\n        ] as const\n        : [false, Duration.zero, ScheduleDecision.done] as const\n    ))\n}\n\n/** @internal */\nexport const either = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>\n>(2, (self, that) => union(self, that))\n\n/** @internal */\nexport const eitherWith = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>\n>(3, (self, that, f) => unionWith(self, that, f))\n\n/** @internal */\nexport const ensuring = dual<\n  <X>(\n    finalizer: Effect.Effect<X>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R, X>(\n    self: Schedule.Schedule<Out, In, R>,\n    finalizer: Effect.Effect<X>\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, finalizer) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) =>\n      core.flatMap(self.step(now, input, state), ([state, out, decision]) =>\n        ScheduleDecision.isDone(decision)\n          ? core.as(finalizer, [state, out, decision as ScheduleDecision.ScheduleDecision] as const)\n          : core.succeed([state, out, decision] as const))\n  ))\n\n/** @internal */\nexport const exponential = (\n  baseInput: Duration.DurationInput,\n  factor = 2.0\n): Schedule.Schedule<Duration.Duration> => {\n  const base = Duration.decode(baseInput)\n  return delayedSchedule(\n    map(forever, (i) => Duration.times(base, Math.pow(factor, i)))\n  )\n}\n\n/** @internal */\nexport const fibonacci = (oneInput: Duration.DurationInput): Schedule.Schedule<Duration.Duration> => {\n  const one = Duration.decode(oneInput)\n  return delayedSchedule(\n    pipe(\n      unfold(\n        [one, one] as const,\n        ([a, b]) => [b, Duration.sum(a, b)] as const\n      ),\n      map((out) => out[0])\n    )\n  )\n}\n\n/** @internal */\nexport const fixed = (intervalInput: Duration.DurationInput): Schedule.Schedule<number> => {\n  const interval = Duration.decode(intervalInput)\n  const intervalMillis = Duration.toMillis(interval)\n  return makeWithState<[Option.Option<[number, number]>, number], unknown, number>(\n    [Option.none(), 0],\n    (now, _, [option, n]) =>\n      core.sync(() => {\n        switch (option._tag) {\n          case \"None\": {\n            return [\n              [Option.some([now, now + intervalMillis]), n + 1],\n              n,\n              ScheduleDecision.continueWith(Interval.after(now + intervalMillis))\n            ]\n          }\n          case \"Some\": {\n            const [startMillis, lastRun] = option.value\n            const runningBehind = now > (lastRun + intervalMillis)\n            const boundary = Equal.equals(interval, Duration.zero)\n              ? interval\n              : Duration.millis(intervalMillis - ((now - startMillis) % intervalMillis))\n            const sleepTime = Equal.equals(boundary, Duration.zero) ? interval : boundary\n            const nextRun = runningBehind ? now : now + Duration.toMillis(sleepTime)\n            return [\n              [Option.some([startMillis, nextRun]), n + 1],\n              n,\n              ScheduleDecision.continueWith(Interval.after(nextRun))\n            ]\n          }\n        }\n      })\n  )\n}\n\n/** @internal */\nexport const fromDelay = (delay: Duration.DurationInput): Schedule.Schedule<Duration.Duration> => duration(delay)\n\n/** @internal */\nexport const fromDelays = (\n  delay: Duration.DurationInput,\n  ...delays: Array<Duration.DurationInput>\n): Schedule.Schedule<Duration.Duration> =>\n  makeWithState(\n    [[delay, ...delays].map((_) => Duration.decode(_)) as Array<Duration.Duration>, true as boolean] as const,\n    (now, _, [durations, cont]) =>\n      core.sync(() => {\n        if (cont) {\n          const x = durations[0]!\n          const interval = Interval.after(now + Duration.toMillis(x))\n          if (durations.length >= 2) {\n            return [\n              [durations.slice(1), true] as const,\n              x,\n              ScheduleDecision.continueWith(interval)\n            ] as const\n          }\n          const y = durations.slice(1)\n          return [\n            [[x, ...y] as Array<Duration.Duration>, false] as const,\n            x,\n            ScheduleDecision.continueWith(interval)\n          ] as const\n        }\n        return [[durations, false] as const, Duration.zero, ScheduleDecision.done] as const\n      })\n  )\n\n/** @internal */\nexport const fromFunction = <A, B>(f: (a: A) => B): Schedule.Schedule<B, A> => map(identity<A>(), f)\n\n/** @internal */\nexport const hourOfDay = (hour: number): Schedule.Schedule<number> =>\n  makeWithState<[number, number], unknown, number>(\n    [Number.NEGATIVE_INFINITY, 0],\n    (now, _, state) => {\n      if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {\n        return core.dieSync(() =>\n          new core.IllegalArgumentException(\n            `Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`\n          )\n        )\n      }\n      const n = state[1]\n      const initial = n === 0\n      const hour0 = nextHour(now, hour, initial)\n      const start = beginningOfHour(hour0)\n      const end = endOfHour(hour0)\n      const interval = Interval.make(start, end)\n      return core.succeed(\n        [\n          [end, n + 1],\n          n,\n          ScheduleDecision.continueWith(interval)\n        ]\n      )\n    }\n  )\n\n/** @internal */\nexport const identity = <A>(): Schedule.Schedule<A, A> =>\n  makeWithState(void 0, (now, input, state) =>\n    core.succeed(\n      [\n        state,\n        input,\n        ScheduleDecision.continueWith(Interval.after(now))\n      ] as const\n    ))\n\n/** @internal */\nexport const intersect = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>\n>(2, (self, that) => intersectWith(self, that, Intervals.intersect))\n\n/** @internal */\nexport const intersectWith = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>\n>(3, <Env, In, Out, Env2, In2, Out2>(\n  self: Schedule.Schedule<Out, In, Env>,\n  that: Schedule.Schedule<Out2, In2, Env2>,\n  f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n): Schedule.Schedule<[Out, Out2], In & In2, Env | Env2> =>\n  makeWithState<[any, any], In & In2, [Out, Out2], Env | Env2>(\n    [self.initial, that.initial],\n    (now, input: In & In2, state) =>\n      pipe(\n        core.zipWith(\n          self.step(now, input, state[0]),\n          that.step(now, input, state[1]),\n          (a, b) => [a, b] as const\n        ),\n        core.flatMap(([\n          [lState, out, lDecision],\n          [rState, out2, rDecision]\n        ]) => {\n          if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n            return intersectWithLoop(\n              self,\n              that,\n              input,\n              lState,\n              out,\n              lDecision.intervals,\n              rState,\n              out2,\n              rDecision.intervals,\n              f\n            )\n          }\n          return core.succeed(\n            [\n              [lState, rState],\n              [out, out2],\n              ScheduleDecision.done\n            ]\n          )\n        })\n      )\n  ))\n\n/** @internal */\nconst intersectWithLoop = <State, State1, Env, In, Out, Env1, In1, Out2>(\n  self: Schedule.Schedule<Out, In, Env>,\n  that: Schedule.Schedule<Out2, In1, Env1>,\n  input: In & In1,\n  lState: State,\n  out: Out,\n  lInterval: Intervals.Intervals,\n  rState: State1,\n  out2: Out2,\n  rInterval: Intervals.Intervals,\n  f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n): Effect.Effect<\n  [[State, State1], [Out, Out2], ScheduleDecision.ScheduleDecision],\n  never,\n  Env | Env1\n> => {\n  const combined = f(lInterval, rInterval)\n  if (Intervals.isNonEmpty(combined)) {\n    return core.succeed([\n      [lState, rState],\n      [out, out2],\n      ScheduleDecision.continue(combined)\n    ])\n  }\n\n  if (pipe(lInterval, Intervals.lessThan(rInterval))) {\n    return core.flatMap(self.step(Intervals.end(lInterval), input, lState), ([lState, out, decision]) => {\n      if (ScheduleDecision.isDone(decision)) {\n        return core.succeed([\n          [lState, rState],\n          [out, out2],\n          ScheduleDecision.done\n        ])\n      }\n      return intersectWithLoop(\n        self,\n        that,\n        input,\n        lState,\n        out,\n        decision.intervals,\n        rState,\n        out2,\n        rInterval,\n        f\n      )\n    })\n  }\n  return core.flatMap(that.step(Intervals.end(rInterval), input, rState), ([rState, out2, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.succeed([\n        [lState, rState],\n        [out, out2],\n        ScheduleDecision.done\n      ])\n    }\n    return intersectWithLoop(\n      self,\n      that,\n      input,\n      lState,\n      out,\n      lInterval,\n      rState,\n      out2,\n      decision.intervals,\n      f\n    )\n  })\n}\n\n/** @internal */\nexport const jittered = <Out, In, R>(self: Schedule.Schedule<Out, In, R>): Schedule.Schedule<Out, In, R> =>\n  jitteredWith(self, { min: 0.8, max: 1.2 })\n\n/** @internal */\nexport const jitteredWith = dual<\n  (options: { min?: number | undefined; max?: number | undefined }) => <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>\n  ) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    options: { min?: number | undefined; max?: number | undefined }\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, options) => {\n  const { max, min } = Object.assign({ min: 0.8, max: 1.2 }, options)\n  return delayedEffect(self, (duration) =>\n    core.map(Random.next, (random) => {\n      const d = Duration.toMillis(duration)\n      const jittered = d * min * (1 - random) + d * max * random\n      return Duration.millis(jittered)\n    }))\n})\n\n/** @internal */\nexport const linear = (baseInput: Duration.DurationInput): Schedule.Schedule<Duration.Duration> => {\n  const base = Duration.decode(baseInput)\n  return delayedSchedule(map(forever, (i) => Duration.times(base, i + 1)))\n}\n\n/** @internal */\nexport const map = dual<\n  <Out, Out2>(\n    f: (out: Out) => Out2\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In, R>,\n  <Out, In, R, Out2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Out2\n  ) => Schedule.Schedule<Out2, In, R>\n>(2, (self, f) => mapEffect(self, (out) => core.sync(() => f(out))))\n\n/** @internal */\nexport const mapEffect = dual<\n  <Out, Out2, R2>(\n    f: (out: Out) => Effect.Effect<Out2, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In, R | R2>,\n  <Out, In, R, Out2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<Out2, never, R2>\n  ) => Schedule.Schedule<Out2, In, R | R2>\n>(2, (self, f) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) =>\n      core.flatMap(self.step(now, input, state), ([state, out, decision]) =>\n        core.map(\n          f(out),\n          (out2) => [state, out2, decision] as const\n        ))\n  ))\n\n/** @internal */\nexport const minuteOfHour = (minute: number): Schedule.Schedule<number> =>\n  makeWithState<[number, number], unknown, number>(\n    [Number.MIN_SAFE_INTEGER, 0],\n    (now, _, state) => {\n      if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {\n        return core.dieSync(() =>\n          new core.IllegalArgumentException(\n            `Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`\n          )\n        )\n      }\n      const n = state[1]\n      const initial = n === 0\n      const minute0 = nextMinute(now, minute, initial)\n      const start = beginningOfMinute(minute0)\n      const end = endOfMinute(minute0)\n      const interval = Interval.make(start, end)\n      return core.succeed(\n        [\n          [end, n + 1],\n          n,\n          ScheduleDecision.continueWith(interval)\n        ]\n      )\n    }\n  )\n\n/** @internal */\nexport const modifyDelay = dual<\n  <Out>(\n    f: (out: Out, duration: Duration.Duration) => Duration.DurationInput\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out, duration: Duration.Duration) => Duration.DurationInput\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => modifyDelayEffect(self, (out, duration) => core.sync(() => f(out, duration))))\n\n/** @internal */\nexport const modifyDelayEffect = dual<\n  <Out, R2>(\n    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) =>\n      core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n        if (ScheduleDecision.isDone(decision)) {\n          return core.succeed([state, out, decision] as const)\n        }\n        const intervals = decision.intervals\n        const delay = Interval.size(Interval.make(now, Intervals.start(intervals)))\n        return core.map(f(out, delay), (durationInput) => {\n          const duration = Duration.decode(durationInput)\n          const oldStart = Intervals.start(intervals)\n          const newStart = now + Duration.toMillis(duration)\n          const delta = newStart - oldStart\n          const newEnd = Math.max(0, Intervals.end(intervals) + delta)\n          const newInterval = Interval.make(newStart, newEnd)\n          return [state, out, ScheduleDecision.continueWith(newInterval)] as const\n        })\n      })\n  ))\n\n/** @internal */\nexport const onDecision = dual<\n  <Out, X, R2>(\n    f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, X, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) =>\n      core.flatMap(\n        self.step(now, input, state),\n        ([state, out, decision]) => core.as(f(out, decision), [state, out, decision] as const)\n      )\n  ))\n\n/** @internal */\nexport const passthrough = <Out, In, R>(\n  self: Schedule.Schedule<Out, In, R>\n): Schedule.Schedule<In, In, R> =>\n  makeWithState(self.initial, (now, input, state) =>\n    pipe(\n      self.step(now, input, state),\n      core.map(([state, _, decision]) => [state, input, decision] as const)\n    ))\n\n/** @internal */\nexport const provideContext = dual<\n  <R>(\n    context: Context.Context<R>\n  ) => <Out, In>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    context: Context.Context<R>\n  ) => Schedule.Schedule<Out, In>\n>(2, (self, context) =>\n  makeWithState(self.initial, (now, input, state) =>\n    core.provideContext(\n      self.step(now, input, state),\n      context\n    )))\n\n/** @internal */\nexport const provideService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>\n  ) => Schedule.Schedule<Out, In, Exclude<R, I>>,\n  <Out, In, R, I, S>(\n    self: Schedule.Schedule<Out, In, R>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => Schedule.Schedule<Out, In, Exclude<R, I>>\n>(3, <Out, In, R, I, S>(\n  self: Schedule.Schedule<Out, In, R>,\n  tag: Context.Tag<I, S>,\n  service: Types.NoInfer<S>\n): Schedule.Schedule<Out, In, Exclude<R, I>> =>\n  makeWithState(self.initial, (now, input, state) =>\n    core.contextWithEffect((env) =>\n      core.provideContext(\n        // @ts-expect-error\n        self.step(now, input, state),\n        Context.add(env, tag, service)\n      )\n    )))\n\n/** @internal */\nexport const recurUntil = <A>(f: Predicate<A>): Schedule.Schedule<A, A> => untilInput(identity<A>(), f)\n\n/** @internal */\nexport const recurUntilEffect = <A, R>(\n  f: (a: A) => Effect.Effect<boolean, never, R>\n): Schedule.Schedule<A, A, R> => untilInputEffect(identity<A>(), f)\n\n/** @internal */\nexport const recurUntilOption = <A, B>(pf: (a: A) => Option.Option<B>): Schedule.Schedule<Option.Option<B>, A> =>\n  untilOutput(map(identity<A>(), pf), Option.isSome)\n\n/** @internal */\nexport const recurUpTo = (\n  durationInput: Duration.DurationInput\n): Schedule.Schedule<Duration.Duration> => {\n  const duration = Duration.decode(durationInput)\n  return whileOutput(elapsed, (elapsed) => Duration.lessThan(elapsed, duration))\n}\n\n/** @internal */\nexport const recurWhile = <A>(f: Predicate<A>): Schedule.Schedule<A, A> => whileInput(identity<A>(), f)\n\n/** @internal */\nexport const recurWhileEffect = <A, R>(\n  f: (a: A) => Effect.Effect<boolean, never, R>\n): Schedule.Schedule<A, A, R> => whileInputEffect(identity<A>(), f)\n\n/** @internal */\nexport const recurs = (n: number): Schedule.Schedule<number> => whileOutput(forever, (out) => out < n)\n\n/** @internal */\nexport const reduce = dual<\n  <Out, Z>(\n    zero: Z,\n    f: (z: Z, out: Out) => Z\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Z, In, R>,\n  <Out, In, R, Z>(\n    self: Schedule.Schedule<Out, In, R>,\n    zero: Z,\n    f: (z: Z, out: Out) => Z\n  ) => Schedule.Schedule<Z, In, R>\n>(3, (self, zero, f) => reduceEffect(self, zero, (z, out) => core.sync(() => f(z, out))))\n\n/** @internal */\nexport const reduceEffect = dual<\n  <Z, Out, R2>(\n    zero: Z,\n    f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Z, In, R | R2>,\n  <Out, In, R, Z, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    zero: Z,\n    f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>\n  ) => Schedule.Schedule<Z, In, R | R2>\n>(3, (self, zero, f) =>\n  makeWithState(\n    [self.initial, zero] as const,\n    (now, input, [s, z]) =>\n      core.flatMap(self.step(now, input, s), ([s, out, decision]) =>\n        ScheduleDecision.isDone(decision)\n          ? core.succeed([[s, z], z, decision as ScheduleDecision.ScheduleDecision] as const)\n          : core.map(f(z, out), (z2) => [[s, z2], z, decision] as const))\n  ))\n\n/** @internal */\nexport const repeatForever = <Env, In, Out>(self: Schedule.Schedule<Out, In, Env>): Schedule.Schedule<Out, In, Env> =>\n  makeWithState(self.initial, (now, input, state) => {\n    const step = (\n      now: number,\n      input: In,\n      state: any\n    ): Effect.Effect<[any, Out, ScheduleDecision.ScheduleDecision], never, Env> =>\n      core.flatMap(\n        self.step(now, input, state),\n        ([state, out, decision]) =>\n          ScheduleDecision.isDone(decision)\n            ? step(now, input, self.initial)\n            : core.succeed([state, out, decision])\n      )\n    return step(now, input, state)\n  })\n\n/** @internal */\nexport const repetitions = <Out, In, R>(self: Schedule.Schedule<Out, In, R>): Schedule.Schedule<number, In, R> =>\n  reduce(self, 0, (n, _) => n + 1)\n\n/** @internal */\nexport const resetAfter = dual<\n  (\n    duration: Duration.DurationInput\n  ) => <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>\n  ) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    duration: Duration.DurationInput\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, durationInput) => {\n  const duration = Duration.decode(durationInput)\n  return pipe(\n    self,\n    intersect(elapsed),\n    resetWhen(([, time]) => Duration.greaterThanOrEqualTo(time, duration)),\n    map((out) => out[0])\n  )\n})\n\n/** @internal */\nexport const resetWhen = dual<\n  <Out>(f: Predicate<Out>) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(self: Schedule.Schedule<Out, In, R>, f: Predicate<Out>) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) =>\n  makeWithState(\n    self.initial,\n    (now, input, state) =>\n      core.flatMap(self.step(now, input, state), ([state, out, decision]) =>\n        f(out)\n          ? self.step(now, input, self.initial)\n          : core.succeed([state, out, decision] as const))\n  ))\n\n/** @internal */\nexport const run = dual<\n  <In>(\n    now: number,\n    input: Iterable<In>\n  ) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    now: number,\n    input: Iterable<In>\n  ) => Effect.Effect<Chunk.Chunk<Out>, never, R>\n>(3, (self, now, input) =>\n  pipe(\n    runLoop(self, now, Chunk.fromIterable(input), self.initial, Chunk.empty()),\n    core.map((list) => Chunk.reverse(list))\n  ))\n\n/** @internal */\nconst runLoop = <Env, In, Out>(\n  self: Schedule.Schedule<Out, In, Env>,\n  now: number,\n  inputs: Chunk.Chunk<In>,\n  state: any,\n  acc: Chunk.Chunk<Out>\n): Effect.Effect<Chunk.Chunk<Out>, never, Env> => {\n  if (!Chunk.isNonEmpty(inputs)) {\n    return core.succeed(acc)\n  }\n  const input = Chunk.headNonEmpty(inputs)\n  const nextInputs = Chunk.tailNonEmpty(inputs)\n  return core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.sync(() => pipe(acc, Chunk.prepend(out)))\n    }\n    return runLoop(\n      self,\n      Intervals.start(decision.intervals),\n      nextInputs,\n      state,\n      Chunk.prepend(acc, out)\n    )\n  })\n}\n\n/** @internal */\nexport const secondOfMinute = (second: number): Schedule.Schedule<number> =>\n  makeWithState<[number, number], unknown, number>(\n    [Number.NEGATIVE_INFINITY, 0],\n    (now, _, state) => {\n      if (!Number.isInteger(second) || second < 0 || 59 < second) {\n        return core.dieSync(() =>\n          new core.IllegalArgumentException(\n            `Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`\n          )\n        )\n      }\n      const n = state[1]\n      const initial = n === 0\n      const second0 = nextSecond(now, second, initial)\n      const start = beginningOfSecond(second0)\n      const end = endOfSecond(second0)\n      const interval = Interval.make(start, end)\n      return core.succeed(\n        [\n          [end, n + 1],\n          n,\n          ScheduleDecision.continueWith(interval)\n        ]\n      )\n    }\n  )\n\n/** @internal */\nexport const spaced = (duration: Duration.DurationInput): Schedule.Schedule<number> => addDelay(forever, () => duration)\n\n/** @internal */\nexport const succeed = <A>(value: A): Schedule.Schedule<A> => map(forever, () => value)\n\n/** @internal */\nexport const sync = <A>(evaluate: LazyArg<A>): Schedule.Schedule<A> => map(forever, evaluate)\n\n/** @internal */\nexport const tapInput = dual<\n  <In2, X, R2>(\n    f: (input: In2) => Effect.Effect<X, never, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In & In2, R | R2>,\n  <Out, In, R, In2, X, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (input: In2) => Effect.Effect<X, never, R2>\n  ) => Schedule.Schedule<Out, In & In2, R | R2>\n>(2, (self, f) =>\n  makeWithState(self.initial, (now, input, state) =>\n    core.zipRight(\n      f(input),\n      self.step(now, input, state)\n    )))\n\n/** @internal */\nexport const tapOutput = dual<\n  <X, R2, Out>(\n    f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R2 | R>,\n  <Out, In, R, X, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<X, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(\n  2,\n  <Out, In, R, X, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<X, never, R2>\n  ): Schedule.Schedule<Out, In, R | R2> =>\n    makeWithState(self.initial, (now, input, state) =>\n      core.tap(\n        self.step(now, input, state),\n        ([, out]) => f(out)\n      ))\n)\n\n/** @internal */\nexport const unfold = <A>(initial: A, f: (a: A) => A): Schedule.Schedule<A> =>\n  makeWithState(initial, (now, _, state) =>\n    core.sync(() =>\n      [\n        f(state),\n        state,\n        ScheduleDecision.continueWith(Interval.after(now))\n      ] as const\n    ))\n\n/** @internal */\nexport const union = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>\n>(2, (self, that) => unionWith(self, that, Intervals.union))\n\n/** @internal */\nexport const unionWith = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals\n  ) => Schedule.Schedule<[Out, Out2], In & In2, R | R2>\n>(3, (self, that, f) =>\n  makeWithState([self.initial, that.initial], (now, input, state) =>\n    core.zipWith(\n      self.step(now, input, state[0]),\n      that.step(now, input, state[1]),\n      ([lState, l, lDecision], [rState, r, rDecision]) => {\n        if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isDone(rDecision)) {\n          return [[lState, rState], [l, r], ScheduleDecision.done]\n        }\n        if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n          return [\n            [lState, rState],\n            [l, r],\n            ScheduleDecision.continue(rDecision.intervals)\n          ]\n        }\n        if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isDone(rDecision)) {\n          return [\n            [lState, rState],\n            [l, r],\n            ScheduleDecision.continue(lDecision.intervals)\n          ]\n        }\n        if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n          const combined = f(lDecision.intervals, rDecision.intervals)\n          return [\n            [lState, rState],\n            [l, r],\n            ScheduleDecision.continue(combined)\n          ]\n        }\n        throw new Error(\n          \"BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues\"\n        )\n      }\n    )))\n\n/** @internal */\nexport const untilInput = dual<\n  <In>(f: Predicate<In>) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(self: Schedule.Schedule<Out, In, R>, f: Predicate<In>) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => check(self, (input, _) => !f(input)))\n\n/** @internal */\nexport const untilInputEffect = dual<\n  <In, R2>(\n    f: (input: In) => Effect.Effect<boolean, never, R2>\n  ) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (input: In) => Effect.Effect<boolean, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) => checkEffect(self, (input, _) => effect.negate(f(input))))\n\n/** @internal */\nexport const untilOutput = dual<\n  <Out>(f: Predicate<Out>) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(self: Schedule.Schedule<Out, In, R>, f: Predicate<Out>) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => check(self, (_, out) => !f(out)))\n\n/** @internal */\nexport const untilOutputEffect = dual<\n  <Out, R2>(\n    f: (out: Out) => Effect.Effect<boolean, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<boolean, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) => checkEffect(self, (_, out) => effect.negate(f(out))))\n\n/** @internal */\nexport const upTo = dual<\n  (duration: Duration.DurationInput) => <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>\n  ) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(\n    self: Schedule.Schedule<Out, In, R>,\n    duration: Duration.DurationInput\n  ) => Schedule.Schedule<Out, In, R>\n>(2, (self, duration) => zipLeft(self, recurUpTo(duration)))\n\n/** @internal */\nexport const whileInput = dual<\n  <In>(f: Predicate<In>) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(self: Schedule.Schedule<Out, In, R>, f: Predicate<In>) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => check(self, (input, _) => f(input)))\n\n/** @internal */\nexport const whileInputEffect = dual<\n  <In, R2>(\n    f: (input: In) => Effect.Effect<boolean, never, R2>\n  ) => <Out, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (input: In) => Effect.Effect<boolean, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) => checkEffect(self, (input, _) => f(input)))\n\n/** @internal */\nexport const whileOutput = dual<\n  <Out>(f: Predicate<Out>) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R>,\n  <Out, In, R>(self: Schedule.Schedule<Out, In, R>, f: Predicate<Out>) => Schedule.Schedule<Out, In, R>\n>(2, (self, f) => check(self, (_, out) => f(out)))\n\n/** @internal */\nexport const whileOutputEffect = dual<\n  <Out, R2>(\n    f: (out: Out) => Effect.Effect<boolean, never, R2>\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In, R | R2>,\n  <Out, In, R, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    f: (out: Out) => Effect.Effect<boolean, never, R2>\n  ) => Schedule.Schedule<Out, In, R | R2>\n>(2, (self, f) => checkEffect(self, (_, out) => f(out)))\n\n/** @internal */\nexport const windowed = (intervalInput: Duration.DurationInput): Schedule.Schedule<number> => {\n  const interval = Duration.decode(intervalInput)\n  const millis = Duration.toMillis(interval)\n  return makeWithState<[Option.Option<number>, number], unknown, number>(\n    [Option.none(), 0],\n    (now, _, [option, n]) => {\n      switch (option._tag) {\n        case \"None\": {\n          return core.succeed(\n            [\n              [Option.some(now), n + 1],\n              n,\n              ScheduleDecision.continueWith(Interval.after(now + millis))\n            ]\n          )\n        }\n        case \"Some\": {\n          return core.succeed(\n            [\n              [Option.some(option.value), n + 1],\n              n,\n              ScheduleDecision.continueWith(\n                Interval.after(now + (millis - ((now - option.value) % millis)))\n              )\n            ]\n          )\n        }\n      }\n    }\n  )\n}\n\n/** @internal */\nexport const zipLeft = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out, In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<Out, In & In2, R | R2>\n>(2, (self, that) => map(intersect(self, that), (out) => out[0]))\n\n/** @internal */\nexport const zipRight = dual<\n  <Out2, In2, R2>(\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => <Out, In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out2, In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>\n  ) => Schedule.Schedule<Out2, In & In2, R | R2>\n>(2, (self, that) => map(intersect(self, that), (out) => out[1]))\n\n/** @internal */\nexport const zipWith = dual<\n  <Out2, In2, R2, Out, Out3>(\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (out: Out, out2: Out2) => Out3\n  ) => <In, R>(self: Schedule.Schedule<Out, In, R>) => Schedule.Schedule<Out3, In & In2, R | R2>,\n  <Out, In, R, Out2, In2, R2, Out3>(\n    self: Schedule.Schedule<Out, In, R>,\n    that: Schedule.Schedule<Out2, In2, R2>,\n    f: (out: Out, out2: Out2) => Out3\n  ) => Schedule.Schedule<Out3, In & In2, R | R2>\n>(3, (self, that, f) => map(intersect(self, that), ([out, out2]) => f(out, out2)))\n\n// -----------------------------------------------------------------------------\n// Seconds\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const beginningOfSecond = (now: number): number => {\n  const date = new Date(now)\n  return new Date(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n    date.getSeconds(),\n    0\n  ).getTime()\n}\n\n/** @internal */\nexport const endOfSecond = (now: number): number => {\n  const date = new Date(beginningOfSecond(now))\n  return date.setSeconds(date.getSeconds() + 1)\n}\n\n/** @internal */\nexport const nextSecond = (now: number, second: number, initial: boolean): number => {\n  const date = new Date(now)\n  if (date.getSeconds() === second && initial) {\n    return now\n  }\n  if (date.getSeconds() < second) {\n    return date.setSeconds(second)\n  }\n  // Set seconds to the provided value and add one minute\n  const newDate = new Date(date.setSeconds(second))\n  return newDate.setTime(newDate.getTime() + 1000 * 60)\n}\n\n// -----------------------------------------------------------------------------\n// Minutes\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const beginningOfMinute = (now: number): number => {\n  const date = new Date(now)\n  return new Date(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    date.getMinutes(),\n    0,\n    0\n  ).getTime()\n}\n\n/** @internal */\nexport const endOfMinute = (now: number): number => {\n  const date = new Date(beginningOfMinute(now))\n  return date.setMinutes(date.getMinutes() + 1)\n}\n\n/** @internal */\nexport const nextMinute = (now: number, minute: number, initial: boolean): number => {\n  const date = new Date(now)\n  if (date.getMinutes() === minute && initial) {\n    return now\n  }\n  if (date.getMinutes() < minute) {\n    return date.setMinutes(minute)\n  }\n  // Set minutes to the provided value and add one hour\n  const newDate = new Date(date.setMinutes(minute))\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60)\n}\n\n// -----------------------------------------------------------------------------\n// Hours\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const beginningOfHour = (now: number): number => {\n  const date = new Date(now)\n  return new Date(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    date.getHours(),\n    0,\n    0,\n    0\n  ).getTime()\n}\n\n/** @internal */\nexport const endOfHour = (now: number): number => {\n  const date = new Date(beginningOfHour(now))\n  return date.setHours(date.getHours() + 1)\n}\n\n/** @internal */\nexport const nextHour = (now: number, hour: number, initial: boolean): number => {\n  const date = new Date(now)\n  if (date.getHours() === hour && initial) {\n    return now\n  }\n  if (date.getHours() < hour) {\n    return date.setHours(hour)\n  }\n  // Set hours to the provided value and add one day\n  const newDate = new Date(date.setHours(hour))\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24)\n}\n\n// -----------------------------------------------------------------------------\n// Days\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const beginningOfDay = (now: number): number => {\n  const date = new Date(now)\n  return new Date(\n    date.getFullYear(),\n    date.getMonth(),\n    date.getDate(),\n    0,\n    0,\n    0,\n    0\n  ).getTime()\n}\n\n/** @internal */\nexport const endOfDay = (now: number): number => {\n  const date = new Date(beginningOfDay(now))\n  return date.setDate(date.getDate() + 1)\n}\n\n/** @internal */\nexport const nextDay = (now: number, dayOfWeek: number, initial: boolean): number => {\n  const date = new Date(now)\n  if (date.getDay() === dayOfWeek && initial) {\n    return now\n  }\n  const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7\n  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek))\n}\n\n/** @internal */\nexport const nextDayOfMonth = (now: number, day: number, initial: boolean): number => {\n  const date = new Date(now)\n  if (date.getDate() === day && initial) {\n    return now\n  }\n  if (date.getDate() < day) {\n    return date.setDate(day)\n  }\n  return findNextMonth(now, day, 1)\n}\n\n/** @internal */\nexport const findNextMonth = (now: number, day: number, months: number): number => {\n  const d = new Date(now)\n  const tmp1 = new Date(d.setDate(day))\n  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months))\n  if (tmp2.getDate() === day) {\n    const d2 = new Date(now)\n    const tmp3 = new Date(d2.setDate(day))\n    return tmp3.setMonth(tmp3.getMonth() + months)\n  }\n  return findNextMonth(now, day, months + 1)\n}\n\n// circular with Effect\n\nconst ScheduleDefectTypeId = Symbol.for(\"effect/Schedule/ScheduleDefect\")\nclass ScheduleDefect<E> {\n  readonly [ScheduleDefectTypeId]: typeof ScheduleDefectTypeId\n  constructor(readonly error: E) {\n    this[ScheduleDefectTypeId] = ScheduleDefectTypeId\n  }\n}\nconst isScheduleDefect = <E = unknown>(u: unknown): u is ScheduleDefect<E> => hasProperty(u, ScheduleDefectTypeId)\nconst scheduleDefectWrap = <A, E, R>(self: Effect.Effect<A, E, R>) =>\n  core.catchAll(self, (e) => core.die(new ScheduleDefect(e)))\n\n/** @internal */\nexport const scheduleDefectRefailCause = <E>(cause: Cause.Cause<E>) =>\n  Option.match(\n    internalCause.find(\n      cause,\n      (_) => internalCause.isDieType(_) && isScheduleDefect<E>(_.defect) ? Option.some(_.defect) : Option.none()\n    ),\n    {\n      onNone: () => cause,\n      onSome: (error) => internalCause.fail(error.error)\n    }\n  )\n\n/** @internal */\nexport const scheduleDefectRefail = <A, E, R>(effect: Effect.Effect<A, E, R>) =>\n  core.catchAllCause(effect, (cause) => core.failCause(scheduleDefectRefailCause(cause)))\n\n/** @internal */\nexport const repeat_Effect = dual<\n  <R1, A, B>(\n    schedule: Schedule.Schedule<B, A, R1>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R | R1>,\n  <A, E, R, R1, B>(\n    self: Effect.Effect<A, E, R>,\n    schedule: Schedule.Schedule<B, A, R1>\n  ) => Effect.Effect<B, E, R | R1>\n>(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => core.fail(e)))\n\n/** @internal */\nexport const repeat_combined = dual<{\n  <O extends Types.NoExcessProperties<Effect.Repeat.Options<A>, O>, A>(\n    options: O\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Repeat.Return<R, E, A, O>\n  <B, A, R1>(\n    schedule: Schedule.Schedule<B, A, R1>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R | R1>\n}, {\n  <A, E, R, O extends Types.NoExcessProperties<Effect.Repeat.Options<A>, O>>(\n    self: Effect.Effect<A, E, R>,\n    options: O\n  ): Effect.Repeat.Return<R, E, A, O>\n  <A, E, R, B, R1>(\n    self: Effect.Effect<A, E, R>,\n    schedule: Schedule.Schedule<B, A, R1>\n  ): Effect.Effect<B, E, R | R1>\n}>(\n  2,\n  (self: Effect.Effect<any, any, any>, options: Effect.Repeat.Options<any> | Schedule.Schedule<any, any, any>) => {\n    if (isSchedule(options)) {\n      return repeat_Effect(self, options)\n    }\n\n    const base = options.schedule ?? passthrough(forever)\n    const withWhile = options.while ?\n      whileInputEffect(base, (a) => {\n        const applied = options.while!(a)\n        if (typeof applied === \"boolean\") {\n          return core.succeed(applied)\n        }\n        return scheduleDefectWrap(applied)\n      }) :\n      base\n    const withUntil = options.until ?\n      untilInputEffect(withWhile, (a) => {\n        const applied = options.until!(a)\n        if (typeof applied === \"boolean\") {\n          return core.succeed(applied)\n        }\n        return scheduleDefectWrap(applied)\n      }) :\n      withWhile\n    const withTimes = options.times ?\n      intersect(withUntil, recurs(options.times)).pipe(map((intersectionPair) => intersectionPair[0])) :\n      withUntil\n    return scheduleDefectRefail(repeat_Effect(self, withTimes))\n  }\n)\n\n/** @internal */\nexport const repeatOrElse_Effect = dual<\n  <R2, A, B, E, E2, R3>(\n    schedule: Schedule.Schedule<B, A, R2>,\n    orElse: (error: E, option: Option.Option<B>) => Effect.Effect<B, E2, R3>\n  ) => <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E2, R | R2 | R3>,\n  <A, E, R, R2, B, E2, R3>(\n    self: Effect.Effect<A, E, R>,\n    schedule: Schedule.Schedule<B, A, R2>,\n    orElse: (error: E, option: Option.Option<B>) => Effect.Effect<B, E2, R3>\n  ) => Effect.Effect<B, E2, R | R2 | R3>\n>(3, (self, schedule, orElse) =>\n  core.flatMap(driver(schedule), (driver) =>\n    core.matchEffect(self, {\n      onFailure: (error) => orElse(error, Option.none()),\n      onSuccess: (value) =>\n        repeatOrElseEffectLoop(\n          effect.provideServiceEffect(\n            self,\n            CurrentIterationMetadata,\n            ref.get(driver.iterationMeta)\n          ),\n          driver,\n          (error, option) =>\n            effect.provideServiceEffect(\n              orElse(error, option),\n              CurrentIterationMetadata,\n              ref.get(driver.iterationMeta)\n            ),\n          value\n        )\n    })))\n\n/** @internal */\nconst repeatOrElseEffectLoop = <A, E, R, R1, B, C, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  driver: Schedule.ScheduleDriver<B, A, R1>,\n  orElse: (error: E, option: Option.Option<B>) => Effect.Effect<C, E2, R2>,\n  value: A\n): Effect.Effect<B | C, E2, R | R1 | R2> =>\n  core.matchEffect(driver.next(value), {\n    onFailure: () => core.orDie(driver.last),\n    onSuccess: (b) =>\n      core.matchEffect(self, {\n        onFailure: (error) => orElse(error, Option.some(b)),\n        onSuccess: (value) => repeatOrElseEffectLoop(self, driver, orElse, value)\n      })\n  })\n\n/** @internal */\nexport const retry_Effect = dual<\n  <B, E, R1>(\n    policy: Schedule.Schedule<B, E, R1>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | R1>,\n  <A, E, R, B, R1>(\n    self: Effect.Effect<A, E, R>,\n    policy: Schedule.Schedule<B, E, R1>\n  ) => Effect.Effect<A, E, R | R1>\n>(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => core.fail(e)))\n\n/** @internal */\nexport const retry_combined: {\n  <E, O extends Types.NoExcessProperties<Effect.Retry.Options<E>, O>>(\n    options: O\n  ): <A, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Retry.Return<R, E, A, O>\n  <B, E, R1>(\n    policy: Schedule.Schedule<B, Types.NoInfer<E>, R1>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R1 | R>\n  <A, E, R, O extends Types.NoExcessProperties<Effect.Retry.Options<E>, O>>(\n    self: Effect.Effect<A, E, R>,\n    options: O\n  ): Effect.Retry.Return<R, E, A, O>\n  <A, E, R, B, R1>(\n    self: Effect.Effect<A, E, R>,\n    policy: Schedule.Schedule<B, Types.NoInfer<E>, R1>\n  ): Effect.Effect<A, E, R1 | R>\n} = dual(\n  2,\n  (\n    self: Effect.Effect<any, any, any>,\n    options: Effect.Retry.Options<any> | Schedule.Schedule<any, any, any>\n  ) => {\n    if (isSchedule(options)) {\n      return retry_Effect(self, options)\n    }\n    return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)))\n  }\n)\n\n/** @internal */\nexport const fromRetryOptions = (options: Effect.Retry.Options<any>): Schedule.Schedule<any, any, any> => {\n  const base = options.schedule ?? forever\n  const withWhile = options.while ?\n    whileInputEffect(base, (e) => {\n      const applied = options.while!(e)\n      if (typeof applied === \"boolean\") {\n        return core.succeed(applied)\n      }\n      return scheduleDefectWrap(applied)\n    }) :\n    base\n  const withUntil = options.until ?\n    untilInputEffect(withWhile, (e) => {\n      const applied = options.until!(e)\n      if (typeof applied === \"boolean\") {\n        return core.succeed(applied)\n      }\n      return scheduleDefectWrap(applied)\n    }) :\n    withWhile\n  return options.times ?\n    intersect(withUntil, recurs(options.times)) :\n    withUntil\n}\n\n/** @internal */\nexport const retryOrElse_Effect = dual<\n  <A1, E, R1, A2, E2, R2>(\n    policy: Schedule.Schedule<A1, Types.NoInfer<E>, R1>,\n    orElse: (e: Types.NoInfer<E>, out: A1) => Effect.Effect<A2, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E2, R | R1 | R2>,\n  <A, E, R, A1, R1, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    policy: Schedule.Schedule<A1, Types.NoInfer<E>, R1>,\n    orElse: (e: Types.NoInfer<E>, out: A1) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A | A2, E2, R | R1 | R2>\n>(3, (self, policy, orElse) =>\n  core.flatMap(\n    driver(policy),\n    (driver) =>\n      retryOrElse_EffectLoop(\n        effect.provideServiceEffect(\n          self,\n          CurrentIterationMetadata,\n          ref.get(driver.iterationMeta)\n        ),\n        driver,\n        (e, out) =>\n          effect.provideServiceEffect(\n            orElse(e, out),\n            CurrentIterationMetadata,\n            ref.get(driver.iterationMeta)\n          )\n      )\n  ))\n\n/** @internal */\nconst retryOrElse_EffectLoop = <A, E, R, R1, A1, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  driver: Schedule.ScheduleDriver<A1, E, R1>,\n  orElse: (e: E, out: A1) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E2, R | R1 | R2> => {\n  return core.catchAll(\n    self,\n    (e) =>\n      core.matchEffect(driver.next(e), {\n        onFailure: () =>\n          pipe(\n            driver.last,\n            core.orDie,\n            core.flatMap((out) => orElse(e, out))\n          ),\n        onSuccess: () => retryOrElse_EffectLoop(self, driver, orElse)\n      })\n  )\n}\n\n/** @internal */\nexport const schedule_Effect = dual<\n  <A, R2, Out>(\n    schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Out, E, R | R2>,\n  <A, E, R, R2, Out>(\n    self: Effect.Effect<A, E, R>,\n    schedule: Schedule.Schedule<Out, A | undefined, R2>\n  ) => Effect.Effect<Out, E, R | R2>\n>(2, <A, E, R, R2, Out>(\n  self: Effect.Effect<A, E, R>,\n  schedule: Schedule.Schedule<Out, A | undefined, R2>\n) => scheduleFrom_Effect(self, void 0, schedule))\n\n/** @internal */\nexport const scheduleFrom_Effect = dual<\n  <R2, In, Out>(\n    initial: In,\n    schedule: Schedule.Schedule<Out, In, R2>\n  ) => <E, R>(self: Effect.Effect<In, E, R>) => Effect.Effect<Out, E, R | R2>,\n  <In, E, R, R2, Out>(\n    self: Effect.Effect<In, E, R>,\n    initial: In,\n    schedule: Schedule.Schedule<Out, In, R2>\n  ) => Effect.Effect<Out, E, R | R2>\n>(3, (self, initial, schedule) =>\n  core.flatMap(\n    driver(schedule),\n    (driver) =>\n      scheduleFrom_EffectLoop(\n        effect.provideServiceEffect(\n          self,\n          CurrentIterationMetadata,\n          ref.get(driver.iterationMeta)\n        ),\n        initial,\n        driver\n      )\n  ))\n\n/** @internal */\nconst scheduleFrom_EffectLoop = <In, E, R, R2, Out>(\n  self: Effect.Effect<In, E, R>,\n  initial: In,\n  driver: Schedule.ScheduleDriver<Out, In, R2>\n): Effect.Effect<Out, E, R | R2> =>\n  core.matchEffect(driver.next(initial), {\n    onFailure: () => core.orDie(driver.last),\n    onSuccess: () =>\n      core.flatMap(\n        self,\n        (a) => scheduleFrom_EffectLoop(self, a, driver)\n      )\n  })\n\n/** @internal */\nexport const count: Schedule.Schedule<number> = unfold(0, (n) => n + 1)\n\n/** @internal */\nexport const elapsed: Schedule.Schedule<Duration.Duration> = makeWithState(\n  Option.none() as Option.Option<number>,\n  (now, _, state) => {\n    switch (state._tag) {\n      case \"None\": {\n        return core.succeed(\n          [\n            Option.some(now),\n            Duration.zero,\n            ScheduleDecision.continueWith(Interval.after(now))\n          ] as const\n        )\n      }\n      case \"Some\": {\n        return core.succeed(\n          [\n            Option.some(state.value),\n            Duration.millis(now - state.value),\n            ScheduleDecision.continueWith(Interval.after(now))\n          ] as const\n        )\n      }\n    }\n  }\n)\n\n/** @internal */\nexport const forever: Schedule.Schedule<number> = unfold(0, (n) => n + 1)\n\n/** @internal */\nexport const once: Schedule.Schedule<void> = asVoid(recurs(1))\n\n/** @internal */\nexport const stop: Schedule.Schedule<void> = asVoid(recurs(0))\n\n/** @internal */\nexport const scheduleForked = dual<\n  <Out, R2>(\n    schedule: Schedule.Schedule<Out, unknown, R2>\n  ) => <A, E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<Fiber.RuntimeFiber<Out, E>, never, R | R2 | Scope>,\n  <A, E, R, Out, R2>(\n    self: Effect.Effect<A, E, R>,\n    schedule: Schedule.Schedule<Out, unknown, R2>\n  ) => Effect.Effect<Fiber.RuntimeFiber<Out, E>, never, R | R2 | Scope>\n>(2, (self, schedule) => forkScoped(schedule_Effect(self, schedule)))\n","import type * as Cache from \"../Cache.js\"\nimport type * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Deferred from \"../Deferred.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Exit from \"../Exit.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport { pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as MutableHashMap from \"../MutableHashMap.js\"\nimport * as MutableQueue from \"../MutableQueue.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport * as effect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as Data from \"./data.js\"\nimport { none } from \"./fiberId.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\n\n/**\n * A `MapValue` represents a value in the cache. A value may either be\n * `Pending` with a `Promise` that will contain the result of computing the\n * lookup function, when it is available, or `Complete` with an `Exit` value\n * that contains the result of computing the lookup function.\n *\n * @internal\n */\nexport type MapValue<Key, Value, Error> =\n  | Complete<Key, Value, Error>\n  | Pending<Key, Value, Error>\n  | Refreshing<Key, Value, Error>\n\n/** @internal */\nexport interface Complete<out Key, out Value, out Error> {\n  readonly _tag: \"Complete\"\n  readonly key: MapKey<Key>\n  readonly exit: Exit.Exit<Value, Error>\n  readonly entryStats: Cache.EntryStats\n  readonly timeToLiveMillis: number\n}\n\n/** @internal */\nexport interface Pending<out Key, in out Value, in out Error> {\n  readonly _tag: \"Pending\"\n  readonly key: MapKey<Key>\n  readonly deferred: Deferred.Deferred<Value, Error>\n}\n\n/** @internal */\nexport interface Refreshing<out Key, in out Value, in out Error> {\n  readonly _tag: \"Refreshing\"\n  readonly deferred: Deferred.Deferred<Value, Error>\n  readonly complete: Complete<Key, Value, Error>\n}\n\n/** @internal */\nexport const complete = <Key, Value, Error>(\n  key: MapKey<Key>,\n  exit: Exit.Exit<Value, Error>,\n  entryStats: Cache.EntryStats,\n  timeToLiveMillis: number\n): MapValue<Key, Value, Error> =>\n  Data.struct({\n    _tag: \"Complete\" as const,\n    key,\n    exit,\n    entryStats,\n    timeToLiveMillis\n  })\n\n/** @internal */\nexport const pending = <Key, Value, Error>(\n  key: MapKey<Key>,\n  deferred: Deferred.Deferred<Value, Error>\n): MapValue<Key, Value, Error> =>\n  Data.struct({\n    _tag: \"Pending\" as const,\n    key,\n    deferred\n  })\n\n/** @internal */\nexport const refreshing = <Key, Value, Error>(\n  deferred: Deferred.Deferred<Value, Error>,\n  complete: Complete<Key, Value, Error>\n): MapValue<Key, Value, Error> =>\n  Data.struct({\n    _tag: \"Refreshing\" as const,\n    deferred,\n    complete\n  })\n\n/** @internal */\nexport const MapKeyTypeId = Symbol.for(\"effect/Cache/MapKey\")\n\n/** @internal */\nexport type MapKeyTypeId = typeof MapKeyTypeId\n\n/**\n * A `MapKey` represents a key in the cache. It contains mutable references\n * to the previous key and next key in the `KeySet` to support an efficient\n * implementation of a sorted set of keys.\n *\n * @internal\n */\nexport interface MapKey<out K> extends Equal.Equal {\n  readonly [MapKeyTypeId]: MapKeyTypeId\n  readonly current: K\n  previous: MapKey<K> | undefined // mutable by design\n  next: MapKey<K> | undefined // mutable by design\n}\n\nclass MapKeyImpl<out K> implements MapKey<K> {\n  readonly [MapKeyTypeId]: MapKeyTypeId = MapKeyTypeId\n  previous: MapKey<K> | undefined = undefined\n  next: MapKey<K> | undefined = undefined\n  constructor(readonly current: K) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(this.current),\n      Hash.combine(Hash.hash(this.previous)),\n      Hash.combine(Hash.hash(this.next)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    if (this === that) {\n      return true\n    }\n    return isMapKey(that) &&\n      Equal.equals(this.current, that.current) &&\n      Equal.equals(this.previous, that.previous) &&\n      Equal.equals(this.next, that.next)\n  }\n}\n\n/** @internal */\nexport const makeMapKey = <K>(current: K): MapKey<K> => new MapKeyImpl(current)\n\n/** @internal */\nexport const isMapKey = (u: unknown): u is MapKey<unknown> => hasProperty(u, MapKeyTypeId)\n\n/**\n * A `KeySet` is a sorted set of keys in the cache ordered by last access.\n * For efficiency, the set is implemented in terms of a doubly linked list\n * and is not safe for concurrent access.\n *\n * @internal\n */\nexport interface KeySet<in out K> {\n  head: MapKey<K> | undefined // mutable by design\n  tail: MapKey<K> | undefined // mutable by design\n  /**\n   * Adds the specified key to the set.\n   */\n  add(key: MapKey<K>): void\n  /**\n   * Removes the lowest priority key from the set.\n   */\n  remove(): MapKey<K> | undefined\n}\n\nclass KeySetImpl<in out K> implements KeySet<K> {\n  head: MapKey<K> | undefined = undefined\n  tail: MapKey<K> | undefined = undefined\n  add(key: MapKey<K>): void {\n    if (key !== this.tail) {\n      if (this.tail === undefined) {\n        this.head = key\n        this.tail = key\n      } else {\n        const previous = key.previous\n        const next = key.next\n        if (next !== undefined) {\n          key.next = undefined\n          if (previous !== undefined) {\n            previous.next = next\n            next.previous = previous\n          } else {\n            this.head = next\n            this.head.previous = undefined\n          }\n        }\n        this.tail.next = key\n        key.previous = this.tail\n        this.tail = key\n      }\n    }\n  }\n  remove(): MapKey<K> | undefined {\n    const key = this.head\n    if (key !== undefined) {\n      const next = key.next\n      if (next !== undefined) {\n        key.next = undefined\n        this.head = next\n        this.head.previous = undefined\n      } else {\n        this.head = undefined\n        this.tail = undefined\n      }\n    }\n    return key\n  }\n}\n\n/** @internal */\nexport const makeKeySet = <K>(): KeySet<K> => new KeySetImpl<K>()\n\n/**\n * The `CacheState` represents the mutable state underlying the cache.\n *\n * @internal\n */\nexport interface CacheState<in out Key, in out Value, in out Error> {\n  map: MutableHashMap.MutableHashMap<Key, MapValue<Key, Value, Error>> // mutable by design\n  keys: KeySet<Key> // mutable by design\n  accesses: MutableQueue.MutableQueue<MapKey<Key>> // mutable by design\n  updating: MutableRef.MutableRef<boolean> // mutable by design\n  hits: number // mutable by design\n  misses: number // mutable by design\n}\n\n/**\n * Constructs a new `CacheState` from the specified values.\n *\n * @internal\n */\nexport const makeCacheState = <Key, Value, Error>(\n  map: MutableHashMap.MutableHashMap<Key, MapValue<Key, Value, Error>>,\n  keys: KeySet<Key>,\n  accesses: MutableQueue.MutableQueue<MapKey<Key>>,\n  updating: MutableRef.MutableRef<boolean>,\n  hits: number,\n  misses: number\n): CacheState<Key, Value, Error> => ({\n  map,\n  keys,\n  accesses,\n  updating,\n  hits,\n  misses\n})\n\n/**\n * Constructs an initial cache state.\n *\n * @internal\n */\nexport const initialCacheState = <Key, Value, Error>(): CacheState<Key, Value, Error> =>\n  makeCacheState(\n    MutableHashMap.empty(),\n    makeKeySet(),\n    MutableQueue.unbounded(),\n    MutableRef.make(false),\n    0,\n    0\n  )\n\n/** @internal */\nconst CacheSymbolKey = \"effect/Cache\"\n\n/** @internal */\nexport const CacheTypeId: Cache.CacheTypeId = Symbol.for(\n  CacheSymbolKey\n) as Cache.CacheTypeId\n\nconst cacheVariance = {\n  /* c8 ignore next */\n  _Key: (_: any) => _,\n  /* c8 ignore next */\n  _Error: (_: never) => _,\n  /* c8 ignore next */\n  _Value: (_: any) => _\n}\n\n/** @internal */\nconst ConsumerCacheSymbolKey = \"effect/ConsumerCache\"\n\n/** @internal */\nexport const ConsumerCacheTypeId: Cache.ConsumerCacheTypeId = Symbol.for(\n  ConsumerCacheSymbolKey\n) as Cache.ConsumerCacheTypeId\n\nconst consumerCacheVariance = {\n  /* c8 ignore next */\n  _Key: (_: any) => _,\n  /* c8 ignore next */\n  _Error: (_: never) => _,\n  /* c8 ignore next */\n  _Value: (_: never) => _\n}\n\n/** @internal */\nexport const makeCacheStats = (\n  options: {\n    readonly hits: number\n    readonly misses: number\n    readonly size: number\n  }\n): Cache.CacheStats => options\n\n/** @internal */\nexport const makeEntryStats = (loadedMillis: number): Cache.EntryStats => ({\n  loadedMillis\n})\n\nclass CacheImpl<in out Key, in out Value, in out Error> implements Cache.Cache<Key, Value, Error> {\n  readonly [CacheTypeId] = cacheVariance\n  readonly [ConsumerCacheTypeId] = consumerCacheVariance\n  readonly cacheState: CacheState<Key, Value, Error>\n  constructor(\n    readonly capacity: number,\n    readonly context: Context.Context<any>,\n    readonly fiberId: FiberId.FiberId,\n    readonly lookup: Cache.Lookup<Key, Value, Error, any>,\n    readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput\n  ) {\n    this.cacheState = initialCacheState()\n  }\n\n  get(key: Key): Effect.Effect<Value, Error> {\n    return core.map(this.getEither(key), Either.merge)\n  }\n\n  get cacheStats(): Effect.Effect<Cache.CacheStats> {\n    return core.sync(() =>\n      makeCacheStats({\n        hits: this.cacheState.hits,\n        misses: this.cacheState.misses,\n        size: MutableHashMap.size(this.cacheState.map)\n      })\n    )\n  }\n\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error> {\n    return core.suspend(() =>\n      Option.match(MutableHashMap.get(this.cacheState.map, key), {\n        onNone: () => {\n          const mapKey = makeMapKey(key)\n          this.trackAccess(mapKey)\n          this.trackMiss()\n          return core.succeed(Option.none<Value>())\n        },\n        onSome: (value) => this.resolveMapValue(value)\n      })\n    )\n  }\n\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>> {\n    return core.suspend(() =>\n      Option.match(MutableHashMap.get(this.cacheState.map, key), {\n        onNone: () => {\n          const mapKey = makeMapKey(key)\n          this.trackAccess(mapKey)\n          this.trackMiss()\n          return core.succeed(Option.none<Value>())\n        },\n        onSome: (value) => this.resolveMapValue(value, true) as Effect.Effect<Option.Option<Value>>\n      })\n    )\n  }\n\n  contains(key: Key): Effect.Effect<boolean> {\n    return core.sync(() => MutableHashMap.has(this.cacheState.map, key))\n  }\n\n  entryStats(key: Key): Effect.Effect<Option.Option<Cache.EntryStats>> {\n    return core.sync(() => {\n      const option = MutableHashMap.get(this.cacheState.map, key)\n      if (Option.isSome(option)) {\n        switch (option.value._tag) {\n          case \"Complete\": {\n            const loaded = option.value.entryStats.loadedMillis\n            return Option.some(makeEntryStats(loaded))\n          }\n          case \"Pending\": {\n            return Option.none()\n          }\n          case \"Refreshing\": {\n            const loaded = option.value.complete.entryStats.loadedMillis\n            return Option.some(makeEntryStats(loaded))\n          }\n        }\n      }\n      return Option.none()\n    })\n  }\n\n  getEither(key: Key): Effect.Effect<Either.Either<Value, Value>, Error> {\n    return core.suspend((): Effect.Effect<Either.Either<Value, Value>, Error> => {\n      const k = key\n      let mapKey: MapKey<Key> | undefined = undefined\n      let deferred: Deferred.Deferred<Value, Error> | undefined = undefined\n      let value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, k))\n      if (value === undefined) {\n        deferred = Deferred.unsafeMake<Value, Error>(this.fiberId)\n        mapKey = makeMapKey(k)\n        if (MutableHashMap.has(this.cacheState.map, k)) {\n          value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, k))\n        } else {\n          MutableHashMap.set(this.cacheState.map, k, pending(mapKey, deferred))\n        }\n      }\n      if (value === undefined) {\n        this.trackAccess(mapKey!)\n        this.trackMiss()\n        return core.map(this.lookupValueOf(key, deferred!), Either.right)\n      } else {\n        return core.flatMap(\n          this.resolveMapValue(value),\n          Option.match({\n            onNone: () => this.getEither(key),\n            onSome: (value) => core.succeed(Either.left(value))\n          })\n        )\n      }\n    })\n  }\n\n  invalidate(key: Key): Effect.Effect<void> {\n    return core.sync(() => {\n      MutableHashMap.remove(this.cacheState.map, key)\n    })\n  }\n\n  invalidateWhen(key: Key, when: (value: Value) => boolean): Effect.Effect<void> {\n    return core.sync(() => {\n      const value = MutableHashMap.get(this.cacheState.map, key)\n      if (Option.isSome(value) && value.value._tag === \"Complete\") {\n        if (value.value.exit._tag === \"Success\") {\n          if (when(value.value.exit.value)) {\n            MutableHashMap.remove(this.cacheState.map, key)\n          }\n        }\n      }\n    })\n  }\n\n  get invalidateAll(): Effect.Effect<void> {\n    return core.sync(() => {\n      this.cacheState.map = MutableHashMap.empty()\n    })\n  }\n\n  refresh(key: Key): Effect.Effect<void, Error> {\n    return effect.clockWith((clock) =>\n      core.suspend(() => {\n        const k = key\n        const deferred: Deferred.Deferred<Value, Error> = Deferred.unsafeMake(this.fiberId)\n        let value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, k))\n        if (value === undefined) {\n          if (MutableHashMap.has(this.cacheState.map, k)) {\n            value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, k))\n          } else {\n            MutableHashMap.set(this.cacheState.map, k, pending(makeMapKey(k), deferred))\n          }\n        }\n        if (value === undefined) {\n          return core.asVoid(this.lookupValueOf(key, deferred))\n        } else {\n          switch (value._tag) {\n            case \"Complete\": {\n              if (this.hasExpired(clock, value.timeToLiveMillis)) {\n                const found = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, k))\n                if (Equal.equals(found, value)) {\n                  MutableHashMap.remove(this.cacheState.map, k)\n                }\n                return core.asVoid(this.get(key))\n              }\n              // Only trigger the lookup if we're still the current value, `completedResult`\n              return pipe(\n                this.lookupValueOf(key, deferred),\n                effect.when(() => {\n                  const current = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, k))\n                  if (Equal.equals(current, value)) {\n                    const mapValue = refreshing(deferred, value as Complete<Key, Value, Error>)\n                    MutableHashMap.set(this.cacheState.map, k, mapValue)\n                    return true\n                  }\n                  return false\n                }),\n                core.asVoid\n              )\n            }\n            case \"Pending\": {\n              return Deferred.await(value.deferred)\n            }\n            case \"Refreshing\": {\n              return Deferred.await(value.deferred)\n            }\n          }\n        }\n      })\n    )\n  }\n\n  set(key: Key, value: Value): Effect.Effect<void> {\n    return effect.clockWith((clock) =>\n      core.sync(() => {\n        const now = clock.unsafeCurrentTimeMillis()\n        const k = key\n        const lookupResult = Exit.succeed(value)\n        const mapValue = complete(\n          makeMapKey(k),\n          lookupResult,\n          makeEntryStats(now),\n          now + Duration.toMillis(Duration.decode(this.timeToLive(lookupResult)))\n        )\n        MutableHashMap.set(\n          this.cacheState.map,\n          k,\n          mapValue as Complete<Key, Value, Error>\n        )\n      })\n    )\n  }\n\n  get size(): Effect.Effect<number> {\n    return core.sync(() => {\n      return MutableHashMap.size(this.cacheState.map)\n    })\n  }\n\n  get values(): Effect.Effect<Array<Value>> {\n    return core.sync(() => {\n      const values: Array<Value> = []\n      for (const entry of this.cacheState.map) {\n        if (entry[1]._tag === \"Complete\" && entry[1].exit._tag === \"Success\") {\n          values.push(entry[1].exit.value)\n        }\n      }\n      return values\n    })\n  }\n\n  get entries(): Effect.Effect<Array<[Key, Value]>> {\n    return core.sync(() => {\n      const values: Array<[Key, Value]> = []\n      for (const entry of this.cacheState.map) {\n        if (entry[1]._tag === \"Complete\" && entry[1].exit._tag === \"Success\") {\n          values.push([entry[0], entry[1].exit.value])\n        }\n      }\n      return values\n    })\n  }\n\n  get keys(): Effect.Effect<Array<Key>> {\n    return core.sync(() => {\n      const keys: Array<Key> = []\n      for (const entry of this.cacheState.map) {\n        if (entry[1]._tag === \"Complete\" && entry[1].exit._tag === \"Success\") {\n          keys.push(entry[0])\n        }\n      }\n      return keys\n    })\n  }\n\n  resolveMapValue(\n    value: MapValue<Key, Value, Error>,\n    ignorePending = false\n  ): Effect.Effect<Option.Option<Value>, Error> {\n    return effect.clockWith((clock) => {\n      switch (value._tag) {\n        case \"Complete\": {\n          this.trackAccess(value.key)\n          if (this.hasExpired(clock, value.timeToLiveMillis)) {\n            MutableHashMap.remove(this.cacheState.map, value.key.current)\n            return core.succeed(Option.none<Value>())\n          }\n          this.trackHit()\n          return core.map(value.exit, Option.some)\n        }\n        case \"Pending\": {\n          this.trackAccess(value.key)\n          this.trackHit()\n          if (ignorePending) {\n            return core.succeed(Option.none<Value>())\n          }\n          return core.map(Deferred.await(value.deferred), Option.some)\n        }\n        case \"Refreshing\": {\n          this.trackAccess(value.complete.key)\n          this.trackHit()\n          if (this.hasExpired(clock, value.complete.timeToLiveMillis)) {\n            if (ignorePending) {\n              return core.succeed(Option.none<Value>())\n            }\n            return core.map(Deferred.await(value.deferred), Option.some)\n          }\n          return core.map(value.complete.exit, Option.some)\n        }\n      }\n    })\n  }\n\n  trackHit(): void {\n    this.cacheState.hits = this.cacheState.hits + 1\n  }\n\n  trackMiss(): void {\n    this.cacheState.misses = this.cacheState.misses + 1\n  }\n\n  trackAccess(key: MapKey<Key>): void {\n    MutableQueue.offer(this.cacheState.accesses, key)\n    if (MutableRef.compareAndSet(this.cacheState.updating, false, true)) {\n      let loop = true\n      while (loop) {\n        const key = MutableQueue.poll(this.cacheState.accesses, MutableQueue.EmptyMutableQueue)\n        if (key === MutableQueue.EmptyMutableQueue) {\n          loop = false\n        } else {\n          this.cacheState.keys.add(key)\n        }\n      }\n      let size = MutableHashMap.size(this.cacheState.map)\n      loop = size > this.capacity\n      while (loop) {\n        const key = this.cacheState.keys.remove()\n        if (key !== undefined) {\n          if (MutableHashMap.has(this.cacheState.map, key.current)) {\n            MutableHashMap.remove(this.cacheState.map, key.current)\n            size = size - 1\n            loop = size > this.capacity\n          }\n        } else {\n          loop = false\n        }\n      }\n      MutableRef.set(this.cacheState.updating, false)\n    }\n  }\n\n  hasExpired(clock: Clock.Clock, timeToLiveMillis: number): boolean {\n    return clock.unsafeCurrentTimeMillis() > timeToLiveMillis\n  }\n\n  lookupValueOf(\n    input: Key,\n    deferred: Deferred.Deferred<Value, Error>\n  ): Effect.Effect<Value, Error> {\n    return effect.clockWith((clock) =>\n      core.suspend(() => {\n        const key = input\n        return pipe(\n          this.lookup(input),\n          core.provideContext(this.context),\n          core.exit,\n          core.flatMap((exit) => {\n            const now = clock.unsafeCurrentTimeMillis()\n            const stats = makeEntryStats(now)\n            const value = complete(\n              makeMapKey(key),\n              exit,\n              stats,\n              now + Duration.toMillis(Duration.decode(this.timeToLive(exit)))\n            )\n            MutableHashMap.set(this.cacheState.map, key, value)\n            return core.zipRight(\n              Deferred.done(deferred, exit),\n              exit\n            )\n          }),\n          core.onInterrupt(() =>\n            core.zipRight(\n              Deferred.interrupt(deferred),\n              core.sync(() => {\n                MutableHashMap.remove(this.cacheState.map, key)\n              })\n            )\n          )\n        )\n      })\n    )\n  }\n}\n\n/** @internal */\nexport const make = <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly capacity: number\n    readonly timeToLive: Duration.DurationInput\n    readonly lookup: Cache.Lookup<Key, Value, Error, Environment>\n  }\n): Effect.Effect<Cache.Cache<Key, Value, Error>, never, Environment> => {\n  const timeToLive = Duration.decode(options.timeToLive)\n  return makeWith({\n    capacity: options.capacity,\n    lookup: options.lookup,\n    timeToLive: () => timeToLive\n  })\n}\n\n/** @internal */\nexport const makeWith = <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly capacity: number\n    readonly lookup: Cache.Lookup<Key, Value, Error, Environment>\n    readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput\n  }\n): Effect.Effect<Cache.Cache<Key, Value, Error>, never, Environment> =>\n  core.map(\n    fiberRuntime.all([core.context<Environment>(), core.fiberId]),\n    ([context, fiberId]) =>\n      new CacheImpl(\n        options.capacity,\n        context,\n        fiberId,\n        options.lookup,\n        (exit) => Duration.decode(options.timeToLive(exit))\n      )\n  )\n\n/** @internal */\nexport const unsafeMakeWith = <Key, Value, Error = never>(\n  capacity: number,\n  lookup: Cache.Lookup<Key, Value, Error>,\n  timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput\n): Cache.Cache<Key, Value, Error> =>\n  new CacheImpl<Key, Value, Error>(\n    capacity,\n    Context.empty() as Context.Context<any>,\n    none,\n    lookup,\n    (exit) => Duration.decode(timeToLive(exit))\n  )\n","import type { Effect } from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport type * as Api from \"../ExecutionPlan.js\"\nimport { dual } from \"../Function.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport * as core from \"./core.js\"\nimport * as layer from \"./layer.js\"\nimport * as InternalSchedule from \"./schedule.js\"\n\n/** @internal */\nexport const TypeId: Api.TypeId = Symbol.for(\"effect/ExecutionPlan\") as Api.TypeId\n\n/** @internal */\nexport const isExecutionPlan = (u: unknown): u is Api.ExecutionPlan<any> => Predicate.hasProperty(u, TypeId)\n\n/** @internal */\nexport const withExecutionPlan: {\n  <Input, Provides, PlanE, PlanR>(\n    plan: Api.ExecutionPlan<{\n      provides: Provides\n      input: Input\n      error: PlanE\n      requirements: PlanR\n    }>\n  ): <A, E extends Input, R>(effect: Effect<A, E, R>) => Effect<\n    A,\n    E | PlanE,\n    Exclude<R, Provides> | PlanR\n  >\n  <A, E extends Input, R, Provides, Input, PlanE, PlanR>(\n    effect: Effect<A, E, R>,\n    plan: Api.ExecutionPlan<{\n      provides: Provides\n      input: Input\n      error: PlanE\n      requirements: PlanR\n    }>\n  ): Effect<\n    A,\n    E | PlanE,\n    Exclude<R, Provides> | PlanR\n  >\n} = dual(2, <A, E extends Input, R, Provides, Input, PlanE, PlanR>(\n  effect: Effect<A, E, R>,\n  plan: Api.ExecutionPlan<{\n    provides: Provides\n    input: Input\n    error: PlanE\n    requirements: PlanR\n  }>\n) =>\n  core.suspend(() => {\n    let i = 0\n    let result: Either.Either<A, any> | undefined\n    return core.flatMap(\n      core.whileLoop({\n        while: () => i < plan.steps.length && (result === undefined || Either.isLeft(result)),\n        body: () => {\n          const step = plan.steps[i]\n          let nextEffect: Effect<A, any, any> = layer.effect_provide(effect, step.provide as any)\n          if (result) {\n            let attempted = false\n            const wrapped = nextEffect\n            // ensure the schedule is applied at least once\n            nextEffect = core.suspend(() => {\n              if (attempted) return wrapped\n              attempted = true\n              return result!\n            })\n            nextEffect = InternalSchedule.scheduleDefectRefail(\n              InternalSchedule.retry_Effect(nextEffect, scheduleFromStep(step, false)!)\n            )\n          } else {\n            const schedule = scheduleFromStep(step, true)\n            nextEffect = schedule\n              ? InternalSchedule.scheduleDefectRefail(InternalSchedule.retry_Effect(nextEffect, schedule))\n              : nextEffect\n          }\n          return core.either(nextEffect)\n        },\n        step: (either) => {\n          result = either\n          i++\n        }\n      }),\n      () => result!\n    )\n  }))\n\n/** @internal */\nexport const scheduleFromStep = <Provides, In, PlanE, PlanR>(\n  step: Api.ExecutionPlan<{\n    provides: Provides\n    input: In\n    error: PlanE\n    requirements: PlanR\n  }>[\"steps\"][number],\n  first: boolean\n) => {\n  if (!first) {\n    return InternalSchedule.fromRetryOptions({\n      schedule: step.schedule ? step.schedule : step.attempts ? undefined : InternalSchedule.once,\n      times: step.attempts,\n      while: step.while\n    })\n  } else if (step.attempts === 1 || !(step.schedule || step.attempts)) {\n    return undefined\n  }\n  return InternalSchedule.fromRetryOptions({\n    schedule: step.schedule,\n    while: step.while,\n    times: step.attempts ? step.attempts - 1 : undefined\n  })\n}\n","/**\n * @since 2.0.0\n */\nimport type * as _Cache from \"./Cache.js\"\nimport type { Cause } from \"./Cause.js\"\nimport type { Deferred } from \"./Deferred.js\"\nimport type { DurationInput } from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type { FiberId } from \"./FiberId.js\"\nimport * as RequestBlock_ from \"./internal/blockedRequests.js\"\nimport * as cache from \"./internal/cache.js\"\nimport * as core from \"./internal/core.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as internal from \"./internal/request.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const RequestTypeId: unique symbol = internal.RequestTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type RequestTypeId = typeof RequestTypeId\n\n/**\n * A `Request<A, E>` is a request from a data source for a value of type `A`\n * that may fail with an `E`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Request<out A, out E = never> extends Request.Variance<A, E> {}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Request {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out A, out E> {\n    readonly [RequestTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Constructor<R extends Request<any, any>, T extends keyof R = never> {\n    (args: Omit<R, T | keyof (Request.Variance<Request.Success<R>, Request.Error<R>>)>): R\n  }\n\n  /**\n   * A utility type to extract the error type from a `Request`.\n   *\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Error<T extends Request<any, any>> = [T] extends [Request<infer _A, infer _E>] ? _E : never\n\n  /**\n   * A utility type to extract the value type from a `Request`.\n   *\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Success<T extends Request<any, any>> = [T] extends [Request<infer _A, infer _E>] ? _A : never\n\n  /**\n   * A utility type to extract the result type from a `Request`.\n   *\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Result<T extends Request<any, any>> = T extends Request<infer A, infer E> ? Exit.Exit<A, E> : never\n\n  /**\n   * A utility type to extract the optional result type from a `Request`.\n   *\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type OptionalResult<T extends Request<any, any>> = T extends Request<infer A, infer E>\n    ? Exit.Exit<Option.Option<A>, E>\n    : never\n}\n\n/**\n * Returns `true` if the specified value is a `Request`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRequest: (u: unknown) => u is Request<unknown, unknown> = internal.isRequest\n\n/**\n * Constructs a new `Request`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const of: <R extends Request<any, any>>() => Request.Constructor<R> = internal.of\n\n/**\n * Constructs a new `Request`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const tagged: <R extends Request<any, any> & { _tag: string }>(\n  tag: R[\"_tag\"]\n) => Request.Constructor<R, \"_tag\"> = internal.tagged\n\n/**\n * Provides a constructor for a Request Class.\n *\n * @example\n * ```ts\n * import { Request } from \"effect\"\n *\n * type Success = string\n * type Error = never\n *\n * class MyRequest extends Request.Class<Success, Error, {\n *   readonly id: string\n * }> {}\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Class: new<Success, Error, A extends Record<string, any>>(\n  args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void\n    : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P] }\n) => Request<Success, Error> & Readonly<A> = internal.Class as any\n\n/**\n * Provides a Tagged constructor for a Request Class.\n *\n * @example\n * ```ts\n * import { Request } from \"effect\"\n *\n * type Success = string\n * type Error = never\n *\n * class MyRequest extends Request.TaggedClass(\"MyRequest\")<Success, Error, {\n *   readonly name: string\n * }> {}\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const TaggedClass: <Tag extends string>(\n  tag: Tag\n) => new<Success, Error, A extends Record<string, any>>(\n  args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void\n    : { readonly [P in keyof A as P extends \"_tag\" | keyof Request<unknown, unknown> ? never : P]: A[P] }\n) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag } = internal.TaggedClass as any\n\n/**\n * Complete a `Request` with the specified result.\n *\n * @since 2.0.0\n * @category request completion\n */\nexport const complete: {\n  /**\n   * Complete a `Request` with the specified result.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>\n  /**\n   * Complete a `Request` with the specified result.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>\n} = internal.complete\n\n/**\n * Interrupts the child effect when requests are no longer needed\n *\n * @since 2.0.0\n * @category request completion\n */\nexport const interruptWhenPossible: {\n  /**\n   * Interrupts the child effect when requests are no longer needed\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>\n  /**\n   * Interrupts the child effect when requests are no longer needed\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>\n} = fiberRuntime.interruptWhenPossible\n\n/**\n * Complete a `Request` with the specified effectful computation, failing the\n * request with the error from the effect workflow if it fails, and completing\n * the request with the value of the effect workflow if it succeeds.\n *\n * @since 2.0.0\n * @category request completion\n */\nexport const completeEffect: {\n  /**\n   * Complete a `Request` with the specified effectful computation, failing the\n   * request with the error from the effect workflow if it fails, and completing\n   * the request with the value of the effect workflow if it succeeds.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>, R>(effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): (self: A) => Effect.Effect<void, never, R>\n  /**\n   * Complete a `Request` with the specified effectful computation, failing the\n   * request with the error from the effect workflow if it fails, and completing\n   * the request with the value of the effect workflow if it succeeds.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>, R>(self: A, effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): Effect.Effect<void, never, R>\n} = internal.completeEffect\n\n/**\n * Complete a `Request` with the specified error.\n *\n * @since 2.0.0\n * @category request completion\n */\nexport const fail: {\n  /**\n   * Complete a `Request` with the specified error.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>\n  /**\n   * Complete a `Request` with the specified error.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>\n} = internal.fail\n\n/**\n * Complete a `Request` with the specified cause.\n *\n * @since 2.0.0\n * @category request completion\n */\nexport const failCause: {\n  /**\n   * Complete a `Request` with the specified cause.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>\n  /**\n   * Complete a `Request` with the specified cause.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>\n} = internal.failCause\n\n/**\n * Complete a `Request` with the specified value.\n *\n * @since 2.0.0\n * @category request completion\n */\nexport const succeed: {\n  /**\n   * Complete a `Request` with the specified value.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>\n  /**\n   * Complete a `Request` with the specified value.\n   *\n   * @since 2.0.0\n   * @category request completion\n   */\n  <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>\n} = internal.succeed\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Listeners {\n  readonly count: number\n  readonly observers: Set<(count: number) => void>\n  interrupted: boolean\n  addObserver(f: (count: number) => void): void\n  removeObserver(f: (count: number) => void): void\n  increment(): void\n  decrement(): void\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Cache extends\n  _Cache.ConsumerCache<Request<any, any>, {\n    listeners: Listeners\n    handle: Deferred<unknown, unknown>\n  }>\n{}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport const makeCache = (\n  options: {\n    readonly capacity: number\n    readonly timeToLive: DurationInput\n  }\n): Effect.Effect<Cache> =>\n  cache.make({\n    ...options,\n    lookup: () =>\n      core.map(core.deferredMake<unknown, unknown>(), (handle) => ({ listeners: new internal.Listeners(), handle }))\n  })\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const EntryTypeId: unique symbol = Symbol.for(\"effect/RequestBlock.Entry\")\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type EntryTypeId = typeof EntryTypeId\n\n/**\n * A `Entry<A>` keeps track of a request of type `A` along with a\n * `Ref` containing the result of the request, existentially hiding the result\n * type. This is used internally by the library to support data sources that\n * return different result types for different requests while guaranteeing that\n * results will be of the type requested.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Entry<out R> extends Entry.Variance<R> {\n  readonly request: R\n  readonly result: Deferred<\n    [R] extends [Request<infer _A, infer _E>] ? _A : never,\n    [R] extends [Request<infer _A, infer _E>] ? _E : never\n  >\n  readonly listeners: Listeners\n  readonly ownerId: FiberId\n  readonly state: {\n    completed: boolean\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport declare namespace Entry {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out R> {\n    readonly [EntryTypeId]: {\n      readonly _R: Types.Covariant<R>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category guards\n */\nexport const isEntry = RequestBlock_.isEntry\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const makeEntry = RequestBlock_.makeEntry\n","import { IllegalArgumentException } from \"../Cause.js\"\nimport * as Clock from \"../Clock.js\"\nimport type * as DateTime from \"../DateTime.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as equivalence from \"../Equivalence.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as Inspectable from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport * as order from \"../Order.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type { Mutable } from \"../Types.js\"\nimport * as internalEffect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\n\n/** @internal */\nexport const TypeId: DateTime.TypeId = Symbol.for(\"effect/DateTime\") as DateTime.TypeId\n\n/** @internal */\nexport const TimeZoneTypeId: DateTime.TimeZoneTypeId = Symbol.for(\"effect/DateTime/TimeZone\") as DateTime.TimeZoneTypeId\n\nconst Proto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  [Inspectable.NodeInspectSymbol](this: DateTime.DateTime) {\n    return this.toString()\n  },\n  toJSON(this: DateTime.DateTime) {\n    return toDateUtc(this).toJSON()\n  }\n}\n\nconst ProtoUtc = {\n  ...Proto,\n  _tag: \"Utc\",\n  [Hash.symbol](this: DateTime.Utc) {\n    return Hash.cached(this, Hash.number(this.epochMillis))\n  },\n  [Equal.symbol](this: DateTime.Utc, that: unknown) {\n    return isDateTime(that) && that._tag === \"Utc\" && this.epochMillis === that.epochMillis\n  },\n  toString(this: DateTime.Utc) {\n    return `DateTime.Utc(${toDateUtc(this).toJSON()})`\n  }\n}\n\nconst ProtoZoned = {\n  ...Proto,\n  _tag: \"Zoned\",\n  [Hash.symbol](this: DateTime.Zoned) {\n    return pipe(\n      Hash.number(this.epochMillis),\n      Hash.combine(Hash.hash(this.zone)),\n      Hash.cached(this)\n    )\n  },\n  [Equal.symbol](this: DateTime.Zoned, that: unknown) {\n    return isDateTime(that) && that._tag === \"Zoned\" && this.epochMillis === that.epochMillis &&\n      Equal.equals(this.zone, that.zone)\n  },\n  toString(this: DateTime.Zoned) {\n    return `DateTime.Zoned(${formatIsoZoned(this)})`\n  }\n}\n\nconst ProtoTimeZone = {\n  [TimeZoneTypeId]: TimeZoneTypeId,\n  [Inspectable.NodeInspectSymbol](this: DateTime.TimeZone) {\n    return this.toString()\n  }\n}\n\nconst ProtoTimeZoneNamed = {\n  ...ProtoTimeZone,\n  _tag: \"Named\",\n  [Hash.symbol](this: DateTime.TimeZone.Named) {\n    return Hash.cached(this, Hash.string(`Named:${this.id}`))\n  },\n  [Equal.symbol](this: DateTime.TimeZone.Named, that: unknown) {\n    return isTimeZone(that) && that._tag === \"Named\" && this.id === that.id\n  },\n  toString(this: DateTime.TimeZone.Named) {\n    return `TimeZone.Named(${this.id})`\n  },\n  toJSON(this: DateTime.TimeZone.Named) {\n    return {\n      _id: \"TimeZone\",\n      _tag: \"Named\",\n      id: this.id\n    }\n  }\n}\n\nconst ProtoTimeZoneOffset = {\n  ...ProtoTimeZone,\n  _tag: \"Offset\",\n  [Hash.symbol](this: DateTime.TimeZone.Offset) {\n    return Hash.cached(this, Hash.string(`Offset:${this.offset}`))\n  },\n  [Equal.symbol](this: DateTime.TimeZone.Offset, that: unknown) {\n    return isTimeZone(that) && that._tag === \"Offset\" && this.offset === that.offset\n  },\n  toString(this: DateTime.TimeZone.Offset) {\n    return `TimeZone.Offset(${offsetToString(this.offset)})`\n  },\n  toJSON(this: DateTime.TimeZone.Offset) {\n    return {\n      _id: \"TimeZone\",\n      _tag: \"Offset\",\n      offset: this.offset\n    }\n  }\n}\n\n/** @internal */\nexport const makeZonedProto = (\n  epochMillis: number,\n  zone: DateTime.TimeZone,\n  partsUtc?: DateTime.DateTime.PartsWithWeekday\n): DateTime.Zoned => {\n  const self = Object.create(ProtoZoned)\n  self.epochMillis = epochMillis\n  self.zone = zone\n  Object.defineProperty(self, \"partsUtc\", {\n    value: partsUtc,\n    enumerable: false,\n    writable: true\n  })\n  Object.defineProperty(self, \"adjustedEpochMillis\", {\n    value: undefined,\n    enumerable: false,\n    writable: true\n  })\n  Object.defineProperty(self, \"partsAdjusted\", {\n    value: undefined,\n    enumerable: false,\n    writable: true\n  })\n  return self\n}\n\n// =============================================================================\n// guards\n// =============================================================================\n\n/** @internal */\nexport const isDateTime = (u: unknown): u is DateTime.DateTime => Predicate.hasProperty(u, TypeId)\n\nconst isDateTimeArgs = (args: IArguments) => isDateTime(args[0])\n\n/** @internal */\nexport const isTimeZone = (u: unknown): u is DateTime.TimeZone => Predicate.hasProperty(u, TimeZoneTypeId)\n\n/** @internal */\nexport const isTimeZoneOffset = (u: unknown): u is DateTime.TimeZone.Offset => isTimeZone(u) && u._tag === \"Offset\"\n\n/** @internal */\nexport const isTimeZoneNamed = (u: unknown): u is DateTime.TimeZone.Named => isTimeZone(u) && u._tag === \"Named\"\n\n/** @internal */\nexport const isUtc = (self: DateTime.DateTime): self is DateTime.Utc => self._tag === \"Utc\"\n\n/** @internal */\nexport const isZoned = (self: DateTime.DateTime): self is DateTime.Zoned => self._tag === \"Zoned\"\n\n// =============================================================================\n// instances\n// =============================================================================\n\n/** @internal */\nexport const Equivalence: equivalence.Equivalence<DateTime.DateTime> = equivalence.make((a, b) =>\n  a.epochMillis === b.epochMillis\n)\n\n/** @internal */\nexport const Order: order.Order<DateTime.DateTime> = order.make((self, that) =>\n  self.epochMillis < that.epochMillis ? -1 : self.epochMillis > that.epochMillis ? 1 : 0\n)\n\n/** @internal */\nexport const clamp: {\n  <Min extends DateTime.DateTime, Max extends DateTime.DateTime>(\n    options: { readonly minimum: Min; readonly maximum: Max }\n  ): <A extends DateTime.DateTime>(self: A) => A | Min | Max\n  <A extends DateTime.DateTime, Min extends DateTime.DateTime, Max extends DateTime.DateTime>(\n    self: A,\n    options: { readonly minimum: Min; readonly maximum: Max }\n  ): A | Min | Max\n} = order.clamp(Order)\n\n// =============================================================================\n// constructors\n// =============================================================================\n\nconst makeUtc = (epochMillis: number): DateTime.Utc => {\n  const self = Object.create(ProtoUtc)\n  self.epochMillis = epochMillis\n  Object.defineProperty(self, \"partsUtc\", {\n    value: undefined,\n    enumerable: false,\n    writable: true\n  })\n  return self\n}\n\n/** @internal */\nexport const unsafeFromDate = (date: Date): DateTime.Utc => {\n  const epochMillis = date.getTime()\n  if (Number.isNaN(epochMillis)) {\n    throw new IllegalArgumentException(\"Invalid date\")\n  }\n  return makeUtc(epochMillis)\n}\n\n/** @internal */\nexport const unsafeMake = <A extends DateTime.DateTime.Input>(input: A): DateTime.DateTime.PreserveZone<A> => {\n  if (isDateTime(input)) {\n    return input as DateTime.DateTime.PreserveZone<A>\n  } else if (input instanceof Date) {\n    return unsafeFromDate(input) as DateTime.DateTime.PreserveZone<A>\n  } else if (typeof input === \"object\") {\n    const date = new Date(0)\n    setPartsDate(date, input)\n    return unsafeFromDate(date) as DateTime.DateTime.PreserveZone<A>\n  } else if (typeof input === \"string\" && !hasZone(input)) {\n    return unsafeFromDate(new Date(input + \"Z\")) as DateTime.DateTime.PreserveZone<A>\n  }\n  return unsafeFromDate(new Date(input)) as DateTime.DateTime.PreserveZone<A>\n}\n\nconst hasZone = (input: string): boolean => /Z|[+-]\\d{2}$|[+-]\\d{2}:?\\d{2}$|\\]$/.test(input)\n\nconst minEpochMillis = -8640000000000000 + (12 * 60 * 60 * 1000)\nconst maxEpochMillis = 8640000000000000 - (14 * 60 * 60 * 1000)\n\n/** @internal */\nexport const unsafeMakeZoned = (input: DateTime.DateTime.Input, options?: {\n  readonly timeZone?: number | string | DateTime.TimeZone | undefined\n  readonly adjustForTimeZone?: boolean | undefined\n  readonly disambiguation?: DateTime.Disambiguation | undefined\n}): DateTime.Zoned => {\n  if (options?.timeZone === undefined && isDateTime(input) && isZoned(input)) {\n    return input\n  }\n  const self = unsafeMake(input)\n  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {\n    throw new RangeError(`Epoch millis out of range: ${self.epochMillis}`)\n  }\n  let zone: DateTime.TimeZone\n  if (options?.timeZone === undefined) {\n    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1000\n    zone = zoneMakeOffset(offset)\n  } else if (isTimeZone(options?.timeZone)) {\n    zone = options.timeZone\n  } else if (typeof options?.timeZone === \"number\") {\n    zone = zoneMakeOffset(options.timeZone)\n  } else {\n    const parsedZone = zoneFromString(options.timeZone)\n    if (Option.isNone(parsedZone)) {\n      throw new IllegalArgumentException(`Invalid time zone: ${options.timeZone}`)\n    }\n    zone = parsedZone.value\n  }\n  if (options?.adjustForTimeZone !== true) {\n    return makeZonedProto(self.epochMillis, zone, self.partsUtc)\n  }\n  return makeZonedFromAdjusted(self.epochMillis, zone, options?.disambiguation ?? \"compatible\")\n}\n\n/** @internal */\nexport const makeZoned: (\n  input: DateTime.DateTime.Input,\n  options?: {\n    readonly timeZone?: number | string | DateTime.TimeZone | undefined\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }\n) => Option.Option<DateTime.Zoned> = Option.liftThrowable(unsafeMakeZoned)\n\n/** @internal */\nexport const make: <A extends DateTime.DateTime.Input>(input: A) => Option.Option<DateTime.DateTime.PreserveZone<A>> =\n  Option.liftThrowable(unsafeMake)\n\nconst zonedStringRegex = /^(.{17,35})\\[(.+)\\]$/\n\n/** @internal */\nexport const makeZonedFromString = (input: string): Option.Option<DateTime.Zoned> => {\n  const match = zonedStringRegex.exec(input)\n  if (match === null) {\n    const offset = parseOffset(input)\n    return offset !== null ? makeZoned(input, { timeZone: offset }) : Option.none()\n  }\n  const [, isoString, timeZone] = match\n  return makeZoned(isoString, { timeZone })\n}\n\n/** @internal */\nexport const now: Effect.Effect<DateTime.Utc> = core.map(Clock.currentTimeMillis, makeUtc)\n\n/** @internal */\nexport const nowAsDate: Effect.Effect<Date> = core.map(Clock.currentTimeMillis, (millis) => new Date(millis))\n\n/** @internal */\nexport const unsafeNow: LazyArg<DateTime.Utc> = () => makeUtc(Date.now())\n\n// =============================================================================\n// time zones\n// =============================================================================\n\n/** @internal */\nexport const toUtc = (self: DateTime.DateTime): DateTime.Utc => makeUtc(self.epochMillis)\n\n/** @internal */\nexport const setZone: {\n  (zone: DateTime.TimeZone, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): (self: DateTime.DateTime) => DateTime.Zoned\n  (self: DateTime.DateTime, zone: DateTime.TimeZone, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): DateTime.Zoned\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, zone: DateTime.TimeZone, options?: {\n  readonly adjustForTimeZone?: boolean | undefined\n  readonly disambiguation?: DateTime.Disambiguation | undefined\n}): DateTime.Zoned =>\n  options?.adjustForTimeZone === true\n    ? makeZonedFromAdjusted(self.epochMillis, zone, options?.disambiguation ?? \"compatible\")\n    : makeZonedProto(self.epochMillis, zone, self.partsUtc))\n\n/** @internal */\nexport const setZoneOffset: {\n  (offset: number, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): (self: DateTime.DateTime) => DateTime.Zoned\n  (self: DateTime.DateTime, offset: number, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): DateTime.Zoned\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, offset: number, options?: {\n  readonly adjustForTimeZone?: boolean | undefined\n  readonly disambiguation?: DateTime.Disambiguation | undefined\n}): DateTime.Zoned => setZone(self, zoneMakeOffset(offset), options))\n\nconst validZoneCache = globalValue(\"effect/DateTime/validZoneCache\", () => new Map<string, DateTime.TimeZone.Named>())\n\nconst formatOptions: Intl.DateTimeFormatOptions = {\n  day: \"numeric\",\n  month: \"numeric\",\n  year: \"numeric\",\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\",\n  timeZoneName: \"longOffset\",\n  fractionalSecondDigits: 3,\n  hourCycle: \"h23\"\n}\n\nconst zoneMakeIntl = (format: Intl.DateTimeFormat): DateTime.TimeZone.Named => {\n  const zoneId = format.resolvedOptions().timeZone\n  if (validZoneCache.has(zoneId)) {\n    return validZoneCache.get(zoneId)!\n  }\n  const zone = Object.create(ProtoTimeZoneNamed)\n  zone.id = zoneId\n  zone.format = format\n  validZoneCache.set(zoneId, zone)\n  return zone\n}\n\n/** @internal */\nexport const zoneUnsafeMakeNamed = (zoneId: string): DateTime.TimeZone.Named => {\n  if (validZoneCache.has(zoneId)) {\n    return validZoneCache.get(zoneId)!\n  }\n  try {\n    return zoneMakeIntl(\n      new Intl.DateTimeFormat(\"en-US\", {\n        ...formatOptions,\n        timeZone: zoneId\n      })\n    )\n  } catch {\n    throw new IllegalArgumentException(`Invalid time zone: ${zoneId}`)\n  }\n}\n\n/** @internal */\nexport const zoneMakeOffset = (offset: number): DateTime.TimeZone.Offset => {\n  const zone = Object.create(ProtoTimeZoneOffset)\n  zone.offset = offset\n  return zone\n}\n\n/** @internal */\nexport const zoneMakeNamed: (zoneId: string) => Option.Option<DateTime.TimeZone.Named> = Option.liftThrowable(\n  zoneUnsafeMakeNamed\n)\n\n/** @internal */\nexport const zoneMakeNamedEffect = (zoneId: string): Effect.Effect<DateTime.TimeZone.Named, IllegalArgumentException> =>\n  internalEffect.try_({\n    try: () => zoneUnsafeMakeNamed(zoneId),\n    catch: (e) => e as IllegalArgumentException\n  })\n\n/** @internal */\nexport const zoneMakeLocal = (): DateTime.TimeZone.Named =>\n  zoneMakeIntl(new Intl.DateTimeFormat(\"en-US\", formatOptions))\n\nconst offsetZoneRegex = /^(?:GMT|[+-])/\n\n/** @internal */\nexport const zoneFromString = (zone: string): Option.Option<DateTime.TimeZone> => {\n  if (offsetZoneRegex.test(zone)) {\n    const offset = parseOffset(zone)\n    return offset === null ? Option.none() : Option.some(zoneMakeOffset(offset))\n  }\n  return zoneMakeNamed(zone)\n}\n\n/** @internal */\nexport const zoneToString = (self: DateTime.TimeZone): string => {\n  if (self._tag === \"Offset\") {\n    return offsetToString(self.offset)\n  }\n  return self.id\n}\n\n/** @internal */\nexport const setZoneNamed: {\n  (zoneId: string, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): (self: DateTime.DateTime) => Option.Option<DateTime.Zoned>\n  (self: DateTime.DateTime, zoneId: string, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): Option.Option<DateTime.Zoned>\n} = dual(\n  isDateTimeArgs,\n  (self: DateTime.DateTime, zoneId: string, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): Option.Option<DateTime.Zoned> => Option.map(zoneMakeNamed(zoneId), (zone) => setZone(self, zone, options))\n)\n\n/** @internal */\nexport const unsafeSetZoneNamed: {\n  (zoneId: string, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): (self: DateTime.DateTime) => DateTime.Zoned\n  (self: DateTime.DateTime, zoneId: string, options?: {\n    readonly adjustForTimeZone?: boolean | undefined\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): DateTime.Zoned\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, zoneId: string, options?: {\n  readonly adjustForTimeZone?: boolean | undefined\n  readonly disambiguation?: DateTime.Disambiguation | undefined\n}): DateTime.Zoned => setZone(self, zoneUnsafeMakeNamed(zoneId), options))\n\n// =============================================================================\n// comparisons\n// =============================================================================\n\n/** @internal */\nexport const distance: {\n  (other: DateTime.DateTime): (self: DateTime.DateTime) => number\n  (self: DateTime.DateTime, other: DateTime.DateTime): number\n} = dual(2, (self: DateTime.DateTime, other: DateTime.DateTime): number => toEpochMillis(other) - toEpochMillis(self))\n\n/** @internal */\nexport const distanceDurationEither: {\n  (other: DateTime.DateTime): (self: DateTime.DateTime) => Either.Either<Duration.Duration, Duration.Duration>\n  (self: DateTime.DateTime, other: DateTime.DateTime): Either.Either<Duration.Duration, Duration.Duration>\n} = dual(\n  2,\n  (self: DateTime.DateTime, other: DateTime.DateTime): Either.Either<Duration.Duration, Duration.Duration> => {\n    const diffMillis = distance(self, other)\n    return diffMillis > 0\n      ? Either.right(Duration.millis(diffMillis))\n      : Either.left(Duration.millis(-diffMillis))\n  }\n)\n\n/** @internal */\nexport const distanceDuration: {\n  (other: DateTime.DateTime): (self: DateTime.DateTime) => Duration.Duration\n  (self: DateTime.DateTime, other: DateTime.DateTime): Duration.Duration\n} = dual(\n  2,\n  (self: DateTime.DateTime, other: DateTime.DateTime): Duration.Duration =>\n    Duration.millis(Math.abs(distance(self, other)))\n)\n\n/** @internal */\nexport const min: {\n  <That extends DateTime.DateTime>(that: That): <Self extends DateTime.DateTime>(self: Self) => Self | That\n  <Self extends DateTime.DateTime, That extends DateTime.DateTime>(self: Self, that: That): Self | That\n} = order.min(Order)\n\n/** @internal */\nexport const max: {\n  <That extends DateTime.DateTime>(that: That): <Self extends DateTime.DateTime>(self: Self) => Self | That\n  <Self extends DateTime.DateTime, That extends DateTime.DateTime>(self: Self, that: That): Self | That\n} = order.max(Order)\n\n/** @internal */\nexport const greaterThan: {\n  (that: DateTime.DateTime): (self: DateTime.DateTime) => boolean\n  (self: DateTime.DateTime, that: DateTime.DateTime): boolean\n} = order.greaterThan(Order)\n\n/** @internal */\nexport const greaterThanOrEqualTo: {\n  (that: DateTime.DateTime): (self: DateTime.DateTime) => boolean\n  (self: DateTime.DateTime, that: DateTime.DateTime): boolean\n} = order.greaterThanOrEqualTo(Order)\n\n/** @internal */\nexport const lessThan: {\n  (that: DateTime.DateTime): (self: DateTime.DateTime) => boolean\n  (self: DateTime.DateTime, that: DateTime.DateTime): boolean\n} = order.lessThan(Order)\n\n/** @internal */\nexport const lessThanOrEqualTo: {\n  (that: DateTime.DateTime): (self: DateTime.DateTime) => boolean\n  (self: DateTime.DateTime, that: DateTime.DateTime): boolean\n} = order.lessThanOrEqualTo(Order)\n\n/** @internal */\nexport const between: {\n  (options: { minimum: DateTime.DateTime; maximum: DateTime.DateTime }): (self: DateTime.DateTime) => boolean\n  (self: DateTime.DateTime, options: { minimum: DateTime.DateTime; maximum: DateTime.DateTime }): boolean\n} = order.between(Order)\n\n/** @internal */\nexport const isFuture = (self: DateTime.DateTime): Effect.Effect<boolean> => core.map(now, lessThan(self))\n\n/** @internal */\nexport const unsafeIsFuture = (self: DateTime.DateTime): boolean => lessThan(unsafeNow(), self)\n\n/** @internal */\nexport const isPast = (self: DateTime.DateTime): Effect.Effect<boolean> => core.map(now, greaterThan(self))\n\n/** @internal */\nexport const unsafeIsPast = (self: DateTime.DateTime): boolean => greaterThan(unsafeNow(), self)\n\n// =============================================================================\n// conversions\n// =============================================================================\n\n/** @internal */\nexport const toDateUtc = (self: DateTime.DateTime): Date => new Date(self.epochMillis)\n\n/** @internal */\nexport const toDate = (self: DateTime.DateTime): Date => {\n  if (self._tag === \"Utc\") {\n    return new Date(self.epochMillis)\n  } else if (self.zone._tag === \"Offset\") {\n    return new Date(self.epochMillis + self.zone.offset)\n  } else if (self.adjustedEpochMillis !== undefined) {\n    return new Date(self.adjustedEpochMillis)\n  }\n  const parts = self.zone.format.formatToParts(self.epochMillis).filter((_) => _.type !== \"literal\")\n  const date = new Date(0)\n  date.setUTCFullYear(\n    Number(parts[2].value),\n    Number(parts[0].value) - 1,\n    Number(parts[1].value)\n  )\n  date.setUTCHours(\n    Number(parts[3].value),\n    Number(parts[4].value),\n    Number(parts[5].value),\n    Number(parts[6].value)\n  )\n  self.adjustedEpochMillis = date.getTime()\n  return date\n}\n\n/** @internal */\nexport const zonedOffset = (self: DateTime.Zoned): number => {\n  const date = toDate(self)\n  return date.getTime() - toEpochMillis(self)\n}\n\nconst offsetToString = (offset: number): string => {\n  const abs = Math.abs(offset)\n  let hours = Math.floor(abs / (60 * 60 * 1000))\n  let minutes = Math.round((abs % (60 * 60 * 1000)) / (60 * 1000))\n  if (minutes === 60) {\n    hours += 1\n    minutes = 0\n  }\n  return `${offset < 0 ? \"-\" : \"+\"}${String(hours).padStart(2, \"0\")}:${String(minutes).padStart(2, \"0\")}`\n}\n\n/** @internal */\nexport const zonedOffsetIso = (self: DateTime.Zoned): string => offsetToString(zonedOffset(self))\n\n/** @internal */\nexport const toEpochMillis = (self: DateTime.DateTime): number => self.epochMillis\n\n/** @internal */\nexport const removeTime = (self: DateTime.DateTime): DateTime.Utc =>\n  withDate(self, (date) => {\n    date.setUTCHours(0, 0, 0, 0)\n    return makeUtc(date.getTime())\n  })\n\n// =============================================================================\n// parts\n// =============================================================================\n\nconst dateToParts = (date: Date): DateTime.DateTime.PartsWithWeekday => ({\n  millis: date.getUTCMilliseconds(),\n  seconds: date.getUTCSeconds(),\n  minutes: date.getUTCMinutes(),\n  hours: date.getUTCHours(),\n  day: date.getUTCDate(),\n  weekDay: date.getUTCDay(),\n  month: date.getUTCMonth() + 1,\n  year: date.getUTCFullYear()\n})\n\n/** @internal */\nexport const toParts = (self: DateTime.DateTime): DateTime.DateTime.PartsWithWeekday => {\n  if (self._tag === \"Utc\") {\n    return toPartsUtc(self)\n  } else if (self.partsAdjusted !== undefined) {\n    return self.partsAdjusted\n  }\n  self.partsAdjusted = withDate(self, dateToParts)\n  return self.partsAdjusted\n}\n\n/** @internal */\nexport const toPartsUtc = (self: DateTime.DateTime): DateTime.DateTime.PartsWithWeekday => {\n  if (self.partsUtc !== undefined) {\n    return self.partsUtc\n  }\n  self.partsUtc = withDateUtc(self, dateToParts)\n  return self.partsUtc\n}\n\n/** @internal */\nexport const getPartUtc: {\n  (part: keyof DateTime.DateTime.PartsWithWeekday): (self: DateTime.DateTime) => number\n  (self: DateTime.DateTime, part: keyof DateTime.DateTime.PartsWithWeekday): number\n} = dual(2, (self: DateTime.DateTime, part: keyof DateTime.DateTime.PartsWithWeekday): number => toPartsUtc(self)[part])\n\n/** @internal */\nexport const getPart: {\n  (part: keyof DateTime.DateTime.PartsWithWeekday): (self: DateTime.DateTime) => number\n  (self: DateTime.DateTime, part: keyof DateTime.DateTime.PartsWithWeekday): number\n} = dual(2, (self: DateTime.DateTime, part: keyof DateTime.DateTime.PartsWithWeekday): number => toParts(self)[part])\n\nconst setPartsDate = (date: Date, parts: Partial<DateTime.DateTime.PartsWithWeekday>): void => {\n  if (parts.year !== undefined) {\n    date.setUTCFullYear(parts.year)\n  }\n  if (parts.month !== undefined) {\n    date.setUTCMonth(parts.month - 1)\n  }\n  if (parts.day !== undefined) {\n    date.setUTCDate(parts.day)\n  }\n  if (parts.weekDay !== undefined) {\n    const diff = parts.weekDay - date.getUTCDay()\n    date.setUTCDate(date.getUTCDate() + diff)\n  }\n  if (parts.hours !== undefined) {\n    date.setUTCHours(parts.hours)\n  }\n  if (parts.minutes !== undefined) {\n    date.setUTCMinutes(parts.minutes)\n  }\n  if (parts.seconds !== undefined) {\n    date.setUTCSeconds(parts.seconds)\n  }\n  if (parts.millis !== undefined) {\n    date.setUTCMilliseconds(parts.millis)\n  }\n}\n\n/** @internal */\nexport const setParts: {\n  (\n    parts: Partial<DateTime.DateTime.PartsWithWeekday>\n  ): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(\n    self: A,\n    parts: Partial<DateTime.DateTime.PartsWithWeekday>\n  ): A\n} = dual(\n  2,\n  (self: DateTime.DateTime, parts: Partial<DateTime.DateTime.PartsWithWeekday>): DateTime.DateTime =>\n    mutate(self, (date) => setPartsDate(date, parts))\n)\n\n/** @internal */\nexport const setPartsUtc: {\n  (\n    parts: Partial<DateTime.DateTime.PartsWithWeekday>\n  ): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(\n    self: A,\n    parts: Partial<DateTime.DateTime.PartsWithWeekday>\n  ): A\n} = dual(\n  2,\n  (self: DateTime.DateTime, parts: Partial<DateTime.DateTime.PartsWithWeekday>): DateTime.DateTime =>\n    mutateUtc(self, (date) => setPartsDate(date, parts))\n)\n\n// =============================================================================\n// mapping\n// =============================================================================\n\nconst constDayMillis = 24 * 60 * 60 * 1000\n\nconst makeZonedFromAdjusted = (\n  adjustedMillis: number,\n  zone: DateTime.TimeZone,\n  disambiguation: DateTime.Disambiguation\n): DateTime.Zoned => {\n  if (zone._tag === \"Offset\") {\n    return makeZonedProto(adjustedMillis - zone.offset, zone)\n  }\n  const beforeOffset = calculateNamedOffset(\n    adjustedMillis - constDayMillis,\n    adjustedMillis,\n    zone\n  )\n  const afterOffset = calculateNamedOffset(\n    adjustedMillis + constDayMillis,\n    adjustedMillis,\n    zone\n  )\n  // If there is no transition, we can return early\n  if (beforeOffset === afterOffset) {\n    return makeZonedProto(adjustedMillis - beforeOffset, zone)\n  }\n  const isForwards = beforeOffset < afterOffset\n  const transitionMillis = beforeOffset - afterOffset\n  // If the transition is forwards, we only need to check if we should move the\n  // local wall clock time forward if it is inside the gap\n  if (isForwards) {\n    const currentAfterOffset = calculateNamedOffset(\n      adjustedMillis - afterOffset,\n      adjustedMillis,\n      zone\n    )\n    if (currentAfterOffset === afterOffset) {\n      return makeZonedProto(adjustedMillis - afterOffset, zone)\n    }\n    const before = makeZonedProto(adjustedMillis - beforeOffset, zone)\n    const beforeAdjustedMillis = toDate(before).getTime()\n    // If the wall clock time has changed, we are inside the gap\n    if (adjustedMillis !== beforeAdjustedMillis) {\n      switch (disambiguation) {\n        case \"reject\": {\n          const formatted = new Date(adjustedMillis).toISOString()\n          throw new RangeError(`Gap time: ${formatted} does not exist in time zone ${zone.id}`)\n        }\n        case \"earlier\":\n          return makeZonedProto(adjustedMillis - afterOffset, zone)\n\n        case \"compatible\":\n        case \"later\":\n          return before\n      }\n    }\n    // The wall clock time is in the earlier offset, so we use that\n    return before\n  }\n\n  const currentBeforeOffset = calculateNamedOffset(\n    adjustedMillis - beforeOffset,\n    adjustedMillis,\n    zone\n  )\n  // The wall clock time is in the earlier offset, so we use that\n  if (currentBeforeOffset === beforeOffset) {\n    if (disambiguation === \"earlier\" || disambiguation === \"compatible\") {\n      return makeZonedProto(adjustedMillis - beforeOffset, zone)\n    }\n    const laterOffset = calculateNamedOffset(\n      adjustedMillis - beforeOffset + transitionMillis,\n      adjustedMillis + transitionMillis,\n      zone\n    )\n    if (laterOffset === beforeOffset) {\n      return makeZonedProto(adjustedMillis - beforeOffset, zone)\n    }\n    // If the offset changed in this period, then we are inside the period where\n    // the wall clock time occurs twice, once in the earlier offset and once in\n    // the later offset.\n    if (disambiguation === \"reject\") {\n      const formatted = new Date(adjustedMillis).toISOString()\n      throw new RangeError(`Ambiguous time: ${formatted} occurs twice in time zone ${zone.id}`)\n    }\n    // If the disambiguation is \"later\", we return the later offset below\n  }\n  return makeZonedProto(adjustedMillis - afterOffset, zone)\n}\n\nconst offsetRegex = /([+-])(\\d{2}):(\\d{2})$/\nconst parseOffset = (offset: string): number | null => {\n  const match = offsetRegex.exec(offset)\n  if (match === null) {\n    return null\n  }\n  const [, sign, hours, minutes] = match\n  return (sign === \"+\" ? 1 : -1) * (Number(hours) * 60 + Number(minutes)) * 60 * 1000\n}\n\nconst calculateNamedOffset = (\n  utcMillis: number,\n  adjustedMillis: number,\n  zone: DateTime.TimeZone.Named\n): number => {\n  const offset = zone.format.formatToParts(utcMillis).find((_) => _.type === \"timeZoneName\")?.value ?? \"\"\n  if (offset === \"GMT\") {\n    return 0\n  }\n  const result = parseOffset(offset)\n  if (result === null) {\n    // fallback to using the adjusted date\n    return zonedOffset(makeZonedProto(adjustedMillis, zone))\n  }\n  return result\n}\n\n/** @internal */\nexport const mutate: {\n  (f: (date: Date) => void, options?: {\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, f: (date: Date) => void, options?: {\n    readonly disambiguation?: DateTime.Disambiguation | undefined\n  }): A\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, f: (date: Date) => void, options?: {\n  readonly disambiguation?: DateTime.Disambiguation | undefined\n}): DateTime.DateTime => {\n  if (self._tag === \"Utc\") {\n    const date = toDateUtc(self)\n    f(date)\n    return makeUtc(date.getTime())\n  }\n  const adjustedDate = toDate(self)\n  const newAdjustedDate = new Date(adjustedDate.getTime())\n  f(newAdjustedDate)\n  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone, options?.disambiguation ?? \"compatible\")\n})\n\n/** @internal */\nexport const mutateUtc: {\n  (f: (date: Date) => void): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, f: (date: Date) => void): A\n} = dual(2, (self: DateTime.DateTime, f: (date: Date) => void): DateTime.DateTime =>\n  mapEpochMillis(self, (millis) => {\n    const date = new Date(millis)\n    f(date)\n    return date.getTime()\n  }))\n\n/** @internal */\nexport const mapEpochMillis: {\n  (f: (millis: number) => number): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, f: (millis: number) => number): A\n} = dual(2, (self: DateTime.DateTime, f: (millis: number) => number): DateTime.DateTime => {\n  const millis = f(toEpochMillis(self))\n  return self._tag === \"Utc\" ? makeUtc(millis) : makeZonedProto(millis, self.zone)\n})\n\n/** @internal */\nexport const withDate: {\n  <A>(f: (date: Date) => A): (self: DateTime.DateTime) => A\n  <A>(self: DateTime.DateTime, f: (date: Date) => A): A\n} = dual(2, <A>(self: DateTime.DateTime, f: (date: Date) => A): A => f(toDate(self)))\n\n/** @internal */\nexport const withDateUtc: {\n  <A>(f: (date: Date) => A): (self: DateTime.DateTime) => A\n  <A>(self: DateTime.DateTime, f: (date: Date) => A): A\n} = dual(2, <A>(self: DateTime.DateTime, f: (date: Date) => A): A => f(toDateUtc(self)))\n\n/** @internal */\nexport const match: {\n  <A, B>(options: {\n    readonly onUtc: (_: DateTime.Utc) => A\n    readonly onZoned: (_: DateTime.Zoned) => B\n  }): (self: DateTime.DateTime) => A | B\n  <A, B>(self: DateTime.DateTime, options: {\n    readonly onUtc: (_: DateTime.Utc) => A\n    readonly onZoned: (_: DateTime.Zoned) => B\n  }): A | B\n} = dual(2, <A, B>(self: DateTime.DateTime, options: {\n  readonly onUtc: (_: DateTime.Utc) => A\n  readonly onZoned: (_: DateTime.Zoned) => B\n}): A | B => self._tag === \"Utc\" ? options.onUtc(self) : options.onZoned(self))\n\n// =============================================================================\n// math\n// =============================================================================\n\n/** @internal */\nexport const addDuration: {\n  (duration: Duration.DurationInput): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, duration: Duration.DurationInput): A\n} = dual(\n  2,\n  (self: DateTime.DateTime, duration: Duration.DurationInput): DateTime.DateTime =>\n    mapEpochMillis(self, (millis) => millis + Duration.toMillis(duration))\n)\n\n/** @internal */\nexport const subtractDuration: {\n  (duration: Duration.DurationInput): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, duration: Duration.DurationInput): A\n} = dual(\n  2,\n  (self: DateTime.DateTime, duration: Duration.DurationInput): DateTime.DateTime =>\n    mapEpochMillis(self, (millis) => millis - Duration.toMillis(duration))\n)\n\nconst addMillis = (date: Date, amount: number): void => {\n  date.setTime(date.getTime() + amount)\n}\n\n/** @internal */\nexport const add: {\n  (\n    parts: Partial<DateTime.DateTime.PartsForMath>\n  ): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(\n    self: A,\n    parts: Partial<DateTime.DateTime.PartsForMath>\n  ): A\n} = dual(\n  2,\n  (self: DateTime.DateTime, parts: Partial<DateTime.DateTime.PartsForMath>): DateTime.DateTime =>\n    mutate(self, (date) => {\n      if (parts.millis) {\n        addMillis(date, parts.millis)\n      }\n      if (parts.seconds) {\n        addMillis(date, parts.seconds * 1000)\n      }\n      if (parts.minutes) {\n        addMillis(date, parts.minutes * 60 * 1000)\n      }\n      if (parts.hours) {\n        addMillis(date, parts.hours * 60 * 60 * 1000)\n      }\n      if (parts.days) {\n        date.setUTCDate(date.getUTCDate() + parts.days)\n      }\n      if (parts.weeks) {\n        date.setUTCDate(date.getUTCDate() + parts.weeks * 7)\n      }\n      if (parts.months) {\n        const day = date.getUTCDate()\n        date.setUTCMonth(date.getUTCMonth() + parts.months + 1, 0)\n        if (day < date.getUTCDate()) {\n          date.setUTCDate(day)\n        }\n      }\n      if (parts.years) {\n        const day = date.getUTCDate()\n        const month = date.getUTCMonth()\n        date.setUTCFullYear(\n          date.getUTCFullYear() + parts.years,\n          month + 1,\n          0\n        )\n        if (day < date.getUTCDate()) {\n          date.setUTCDate(day)\n        }\n      }\n    })\n)\n\n/** @internal */\nexport const subtract: {\n  (\n    parts: Partial<DateTime.DateTime.PartsForMath>\n  ): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(\n    self: A,\n    parts: Partial<DateTime.DateTime.PartsForMath>\n  ): A\n} = dual(2, (self: DateTime.DateTime, parts: Partial<DateTime.DateTime.PartsForMath>): DateTime.DateTime => {\n  const newParts = {} as Partial<Mutable<DateTime.DateTime.PartsForMath>>\n  for (const key in parts) {\n    newParts[key as keyof DateTime.DateTime.PartsForMath] = -1 * parts[key as keyof DateTime.DateTime.PartsForMath]!\n  }\n  return add(self, newParts)\n})\n\nconst startOfDate = (date: Date, part: DateTime.DateTime.UnitSingular, options?: {\n  readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n}) => {\n  switch (part) {\n    case \"second\": {\n      date.setUTCMilliseconds(0)\n      break\n    }\n    case \"minute\": {\n      date.setUTCSeconds(0, 0)\n      break\n    }\n    case \"hour\": {\n      date.setUTCMinutes(0, 0, 0)\n      break\n    }\n    case \"day\": {\n      date.setUTCHours(0, 0, 0, 0)\n      break\n    }\n    case \"week\": {\n      const weekStartsOn = options?.weekStartsOn ?? 0\n      const day = date.getUTCDay()\n      const diff = (day - weekStartsOn + 7) % 7\n      date.setUTCDate(date.getUTCDate() - diff)\n      date.setUTCHours(0, 0, 0, 0)\n      break\n    }\n    case \"month\": {\n      date.setUTCDate(1)\n      date.setUTCHours(0, 0, 0, 0)\n      break\n    }\n    case \"year\": {\n      date.setUTCMonth(0, 1)\n      date.setUTCHours(0, 0, 0, 0)\n      break\n    }\n  }\n}\n\n/** @internal */\nexport const startOf: {\n  (part: DateTime.DateTime.UnitSingular, options?: {\n    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n  }): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, part: DateTime.DateTime.UnitSingular, options?: {\n    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n  }): A\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, part: DateTime.DateTime.UnitSingular, options?: {\n  readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n}): DateTime.DateTime => mutate(self, (date) => startOfDate(date, part, options)))\n\nconst endOfDate = (date: Date, part: DateTime.DateTime.UnitSingular, options?: {\n  readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n}) => {\n  switch (part) {\n    case \"second\": {\n      date.setUTCMilliseconds(999)\n      break\n    }\n    case \"minute\": {\n      date.setUTCSeconds(59, 999)\n      break\n    }\n    case \"hour\": {\n      date.setUTCMinutes(59, 59, 999)\n      break\n    }\n    case \"day\": {\n      date.setUTCHours(23, 59, 59, 999)\n      break\n    }\n    case \"week\": {\n      const weekStartsOn = options?.weekStartsOn ?? 0\n      const day = date.getUTCDay()\n      const diff = (day - weekStartsOn + 7) % 7\n      date.setUTCDate(date.getUTCDate() - diff + 6)\n      date.setUTCHours(23, 59, 59, 999)\n      break\n    }\n    case \"month\": {\n      date.setUTCMonth(date.getUTCMonth() + 1, 0)\n      date.setUTCHours(23, 59, 59, 999)\n      break\n    }\n    case \"year\": {\n      date.setUTCMonth(11, 31)\n      date.setUTCHours(23, 59, 59, 999)\n      break\n    }\n  }\n}\n\n/** @internal */\nexport const endOf: {\n  (part: DateTime.DateTime.UnitSingular, options?: {\n    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n  }): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, part: DateTime.DateTime.UnitSingular, options?: {\n    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n  }): A\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, part: DateTime.DateTime.UnitSingular, options?: {\n  readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n}): DateTime.DateTime => mutate(self, (date) => endOfDate(date, part, options)))\n\n/** @internal */\nexport const nearest: {\n  (part: DateTime.DateTime.UnitSingular, options?: {\n    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n  }): <A extends DateTime.DateTime>(self: A) => A\n  <A extends DateTime.DateTime>(self: A, part: DateTime.DateTime.UnitSingular, options?: {\n    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n  }): A\n} = dual(isDateTimeArgs, (self: DateTime.DateTime, part: DateTime.DateTime.UnitSingular, options?: {\n  readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined\n}): DateTime.DateTime =>\n  mutate(self, (date) => {\n    if (part === \"milli\") return\n    const millis = date.getTime()\n    const start = new Date(millis)\n    startOfDate(start, part, options)\n    const startMillis = start.getTime()\n    const end = new Date(millis)\n    endOfDate(end, part, options)\n    const endMillis = end.getTime() + 1\n    const diffStart = millis - startMillis\n    const diffEnd = endMillis - millis\n    if (diffStart < diffEnd) {\n      date.setTime(startMillis)\n    } else {\n      date.setTime(endMillis)\n    }\n  }))\n\n// =============================================================================\n// formatting\n// =============================================================================\n\nconst intlTimeZone = (self: DateTime.TimeZone): string => {\n  if (self._tag === \"Named\") {\n    return self.id\n  }\n  return offsetToString(self.offset)\n}\n\n/** @internal */\nexport const format: {\n  (\n    options?:\n      | Intl.DateTimeFormatOptions & {\n        readonly locale?: Intl.LocalesArgument\n      }\n      | undefined\n  ): (self: DateTime.DateTime) => string\n  (\n    self: DateTime.DateTime,\n    options?:\n      | Intl.DateTimeFormatOptions & {\n        readonly locale?: Intl.LocalesArgument\n      }\n      | undefined\n  ): string\n} = dual(isDateTimeArgs, (\n  self: DateTime.DateTime,\n  options?:\n    | Intl.DateTimeFormatOptions & {\n      readonly locale?: Intl.LocalesArgument\n    }\n    | undefined\n): string => {\n  try {\n    return new Intl.DateTimeFormat(options?.locale, {\n      timeZone: self._tag === \"Utc\" ? \"UTC\" : intlTimeZone(self.zone),\n      ...options\n    }).format(self.epochMillis)\n  } catch {\n    return new Intl.DateTimeFormat(options?.locale, {\n      timeZone: \"UTC\",\n      ...options\n    }).format(toDate(self))\n  }\n})\n\n/** @internal */\nexport const formatLocal: {\n  (\n    options?:\n      | Intl.DateTimeFormatOptions & {\n        readonly locale?: Intl.LocalesArgument\n      }\n      | undefined\n  ): (self: DateTime.DateTime) => string\n  (\n    self: DateTime.DateTime,\n    options?:\n      | Intl.DateTimeFormatOptions & {\n        readonly locale?: Intl.LocalesArgument\n      }\n      | undefined\n  ): string\n} = dual(isDateTimeArgs, (\n  self: DateTime.DateTime,\n  options?:\n    | Intl.DateTimeFormatOptions & {\n      readonly locale?: Intl.LocalesArgument\n    }\n    | undefined\n): string => new Intl.DateTimeFormat(options?.locale, options).format(self.epochMillis))\n\n/** @internal */\nexport const formatUtc: {\n  (\n    options?:\n      | Intl.DateTimeFormatOptions & {\n        readonly locale?: Intl.LocalesArgument\n      }\n      | undefined\n  ): (self: DateTime.DateTime) => string\n  (\n    self: DateTime.DateTime,\n    options?:\n      | Intl.DateTimeFormatOptions & {\n        readonly locale?: Intl.LocalesArgument\n      }\n      | undefined\n  ): string\n} = dual(isDateTimeArgs, (\n  self: DateTime.DateTime,\n  options?:\n    | Intl.DateTimeFormatOptions & {\n      readonly locale?: Intl.LocalesArgument\n    }\n    | undefined\n): string =>\n  new Intl.DateTimeFormat(options?.locale, {\n    ...options,\n    timeZone: \"UTC\"\n  }).format(self.epochMillis))\n\n/** @internal */\nexport const formatIntl: {\n  (format: Intl.DateTimeFormat): (self: DateTime.DateTime) => string\n  (self: DateTime.DateTime, format: Intl.DateTimeFormat): string\n} = dual(2, (self: DateTime.DateTime, format: Intl.DateTimeFormat): string => format.format(self.epochMillis))\n\n/** @internal */\nexport const formatIso = (self: DateTime.DateTime): string => toDateUtc(self).toISOString()\n\n/** @internal */\nexport const formatIsoDate = (self: DateTime.DateTime): string => toDate(self).toISOString().slice(0, 10)\n\n/** @internal */\nexport const formatIsoDateUtc = (self: DateTime.DateTime): string => toDateUtc(self).toISOString().slice(0, 10)\n\n/** @internal */\nexport const formatIsoOffset = (self: DateTime.DateTime): string => {\n  const date = toDate(self)\n  return self._tag === \"Utc\" ? date.toISOString() : `${date.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`\n}\n\n/** @internal */\nexport const formatIsoZoned = (self: DateTime.Zoned): string =>\n  self.zone._tag === \"Offset\" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`\n","/**\n * @since 2.0.0\n */\nimport * as Dual from \"./Function.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/MutableList\") as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface MutableList<out A> extends Iterable<A>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  head: LinkedListNode<A> | undefined\n  /** @internal */\n  tail: LinkedListNode<A> | undefined\n}\n\nconst MutableListProto: Omit<MutableList<unknown>, \"head\" | \"tail\"> = {\n  [TypeId]: TypeId,\n  [Symbol.iterator](this: MutableList<unknown>): Iterator<unknown> {\n    let done = false\n    let head: LinkedListNode<unknown> | undefined = this.head\n    return {\n      next() {\n        if (done) {\n          return this.return!()\n        }\n        if (head == null) {\n          done = true\n          return this.return!()\n        }\n        const value = head.value\n        head = head.next\n        return { done, value }\n      },\n      return(value?: unknown) {\n        if (!done) {\n          done = true\n        }\n        return { done: true, value }\n      }\n    }\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"MutableList\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\ninterface MutableListImpl<A> extends MutableList<A> {\n  _length: number\n}\n\n/** @internal */\ninterface LinkedListNode<T> {\n  removed: boolean\n  value: T\n  prev: LinkedListNode<T> | undefined\n  next: LinkedListNode<T> | undefined\n}\n\n/** @internal */\nconst makeNode = <T>(value: T): LinkedListNode<T> => ({\n  value,\n  removed: false,\n  prev: undefined,\n  next: undefined\n})\n\n/**\n * Creates an empty `MutableList`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = <A = never>(): MutableList<A> => {\n  const list = Object.create(MutableListProto)\n  list.head = undefined\n  list.tail = undefined\n  list._length = 0\n  return list\n}\n\n/**\n * Creates a new `MutableList` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable = <A>(iterable: Iterable<A>): MutableList<A> => {\n  const list = empty<A>()\n  for (const element of iterable) {\n    append(list, element)\n  }\n  return list\n}\n\n/**\n * Creates a new `MutableList` from the specified elements.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make = <A>(...elements: ReadonlyArray<A>): MutableList<A> => fromIterable(elements)\n\n/**\n * Returns `true` if the list contains zero elements, `false`, otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty = <A>(self: MutableList<A>): boolean => length(self) === 0\n\n/**\n * Returns the length of the list.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const length = <A>(self: MutableList<A>): number => (self as MutableListImpl<A>)._length\n\n/**\n * Returns the last element of the list, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const tail = <A>(self: MutableList<A>): A | undefined => self.tail === undefined ? undefined : self.tail.value\n\n/**\n * Returns the first element of the list, if it exists.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head = <A>(self: MutableList<A>): A | undefined => self.head === undefined ? undefined : self.head.value\n\n/**\n * Executes the specified function `f` for each element in the list.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach: {\n  /**\n   * Executes the specified function `f` for each element in the list.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A>(f: (element: A) => void): (self: MutableList<A>) => void\n  /**\n   * Executes the specified function `f` for each element in the list.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A>(self: MutableList<A>, f: (element: A) => void): void\n} = Dual.dual<\n  <A>(f: (element: A) => void) => (self: MutableList<A>) => void,\n  <A>(self: MutableList<A>, f: (element: A) => void) => void\n>(2, (self, f) => {\n  let current = self.head\n  while (current !== undefined) {\n    f(current.value)\n    current = current.next\n  }\n})\n\n/**\n * Removes all elements from the doubly-linked list.\n *\n * @since 2.0.0\n */\nexport const reset = <A>(self: MutableList<A>): MutableList<A> => {\n  ;(self as MutableListImpl<A>)._length = 0\n  self.head = undefined\n  self.tail = undefined\n  return self\n}\n\n/**\n * Appends the specified element to the end of the `MutableList`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  /**\n   * Appends the specified element to the end of the `MutableList`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A>(value: A): (self: MutableList<A>) => MutableList<A>\n  /**\n   * Appends the specified element to the end of the `MutableList`.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A>(self: MutableList<A>, value: A): MutableList<A>\n} = Dual.dual<\n  <A>(value: A) => (self: MutableList<A>) => MutableList<A>,\n  <A>(self: MutableList<A>, value: A) => MutableList<A>\n>(2, <A>(self: MutableList<A>, value: A) => {\n  const node = makeNode(value)\n  if (self.head === undefined) {\n    self.head = node\n  }\n  if (self.tail === undefined) {\n    self.tail = node\n  } else {\n    self.tail.next = node\n    node.prev = self.tail\n    self.tail = node\n  }\n  ;(self as MutableListImpl<A>)._length += 1\n  return self\n})\n\n/**\n * Removes the first value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n */\nexport const shift = <A>(self: MutableList<A>): A | undefined => {\n  const head = self.head\n  if (head !== undefined) {\n    remove(self, head)\n    return head.value\n  }\n  return undefined\n}\n\n/**\n * Removes the last value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n */\nexport const pop = <A>(self: MutableList<A>): A | undefined => {\n  const tail = self.tail\n  if (tail !== undefined) {\n    remove(self, tail)\n    return tail.value\n  }\n  return undefined\n}\n\n/**\n * Prepends the specified value to the beginning of the list.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  /**\n   * Prepends the specified value to the beginning of the list.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A>(value: A): (self: MutableList<A>) => MutableList<A>\n  /**\n   * Prepends the specified value to the beginning of the list.\n   *\n   * @category concatenating\n   * @since 2.0.0\n   */\n  <A>(self: MutableList<A>, value: A): MutableList<A>\n} = Dual.dual<\n  <A>(value: A) => (self: MutableList<A>) => MutableList<A>,\n  <A>(self: MutableList<A>, value: A) => MutableList<A>\n>(2, <A>(self: MutableList<A>, value: A) => {\n  const node = makeNode(value)\n  node.next = self.head\n  if (self.head !== undefined) {\n    self.head.prev = node\n  }\n  self.head = node\n  if (self.tail === undefined) {\n    self.tail = node\n  }\n  ;(self as MutableListImpl<A>)._length += 1\n  return self\n})\n\nconst remove = <A>(self: MutableList<A>, node: LinkedListNode<A>): void => {\n  if (node.removed) {\n    return\n  }\n  node.removed = true\n  if (node.prev !== undefined && node.next !== undefined) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n  } else if (node.prev !== undefined) {\n    self.tail = node.prev\n    node.prev.next = undefined\n  } else if (node.next !== undefined) {\n    self.head = node.next\n    node.next.prev = undefined\n  } else {\n    self.tail = undefined\n    self.head = undefined\n  }\n  if ((self as MutableListImpl<A>)._length > 0) {\n    ;(self as MutableListImpl<A>)._length -= 1\n  }\n}\n","import type * as Cache from \"../Cache.js\"\nimport type { Deferred } from \"../Deferred.js\"\nimport { seconds } from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { dual } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport * as BlockedRequests from \"./blockedRequests.js\"\nimport { unsafeMakeWith } from \"./cache.js\"\nimport * as core from \"./core.js\"\nimport { ensuring } from \"./fiberRuntime.js\"\nimport { Listeners } from \"./request.js\"\n\ntype RequestCache = Cache.Cache<Request.Request<any, any>, {\n  listeners: Request.Listeners\n  handle: Deferred<any, any>\n}>\n\n/** @internal */\nexport const currentCache = globalValue(\n  Symbol.for(\"effect/FiberRef/currentCache\"),\n  () =>\n    core.fiberRefUnsafeMake<RequestCache>(unsafeMakeWith<Request.Request<any, any>, {\n      listeners: Request.Listeners\n      handle: Deferred<any, any>\n    }>(\n      65536,\n      () => core.map(core.deferredMake<any, any>(), (handle) => ({ listeners: new Listeners(), handle })),\n      () => seconds(60)\n    ))\n)\n\n/** @internal */\nexport const currentCacheEnabled = globalValue(\n  Symbol.for(\"effect/FiberRef/currentCacheEnabled\"),\n  () => core.fiberRefUnsafeMake(false)\n)\n\n/** @internal */\nexport const fromRequest = <\n  A extends Request.Request<any, any>,\n  Ds extends\n    | RequestResolver.RequestResolver<A>\n    | Effect.Effect<RequestResolver.RequestResolver<A>, any, any>\n>(\n  request: A,\n  dataSource: Ds\n): Effect.Effect<\n  Request.Request.Success<A>,\n  Request.Request.Error<A>,\n  [Ds] extends [Effect.Effect<any, any, any>] ? Effect.Effect.Context<Ds> : never\n> =>\n  core.flatMap(\n    (core.isEffect(dataSource) ? dataSource : core.succeed(dataSource)) as Effect.Effect<\n      RequestResolver.RequestResolver<A>\n    >,\n    (ds) =>\n      core.fiberIdWith((id) => {\n        const proxy = new Proxy(request, {})\n        return core.fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {\n          if (cacheEnabled) {\n            const cached: Effect.Effect<any, any> = core.fiberRefGetWith(currentCache, (cache) =>\n              core.flatMap(cache.getEither(proxy), (orNew) => {\n                switch (orNew._tag) {\n                  case \"Left\": {\n                    if (orNew.left.listeners.interrupted) {\n                      return core.flatMap(\n                        cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle),\n                        () => cached\n                      )\n                    }\n                    orNew.left.listeners.increment()\n                    return core.uninterruptibleMask((restore) =>\n                      core.flatMap(\n                        core.exit(core.blocked(\n                          BlockedRequests.empty,\n                          restore(core.deferredAwait(orNew.left.handle))\n                        )),\n                        (exit) => {\n                          orNew.left.listeners.decrement()\n                          return exit\n                        }\n                      )\n                    )\n                  }\n                  case \"Right\": {\n                    orNew.right.listeners.increment()\n                    return core.uninterruptibleMask((restore) =>\n                      core.flatMap(\n                        core.exit(\n                          core.blocked(\n                            BlockedRequests.single(\n                              ds as RequestResolver.RequestResolver<A>,\n                              BlockedRequests.makeEntry({\n                                request: proxy,\n                                result: orNew.right.handle,\n                                listeners: orNew.right.listeners,\n                                ownerId: id,\n                                state: { completed: false }\n                              })\n                            ),\n                            restore(core.deferredAwait(orNew.right.handle))\n                          )\n                        ),\n                        () => {\n                          orNew.right.listeners.decrement()\n                          return core.deferredAwait(orNew.right.handle)\n                        }\n                      )\n                    )\n                  }\n                }\n              }))\n            return cached\n          }\n          const listeners = new Listeners()\n          listeners.increment()\n          return core.flatMap(\n            core.deferredMake<Request.Request.Success<A>, Request.Request.Error<A>>(),\n            (ref) =>\n              ensuring(\n                core.blocked(\n                  BlockedRequests.single(\n                    ds as RequestResolver.RequestResolver<A>,\n                    BlockedRequests.makeEntry({\n                      request: proxy,\n                      result: ref,\n                      listeners,\n                      ownerId: id,\n                      state: { completed: false }\n                    })\n                  ),\n                  core.deferredAwait(ref)\n                ),\n                core.sync(() =>\n                  listeners.decrement()\n                )\n              )\n          )\n        })\n      })\n  )\n\n/** @internal */\nexport const cacheRequest = <A extends Request.Request<any, any>>(\n  request: A,\n  result: Request.Request.Result<A>\n): Effect.Effect<void> => {\n  return core.fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {\n    if (cacheEnabled) {\n      return core.fiberRefGetWith(currentCache, (cache) =>\n        core.flatMap(cache.getEither(request), (orNew) => {\n          switch (orNew._tag) {\n            case \"Left\": {\n              return core.void\n            }\n            case \"Right\": {\n              return core.deferredComplete(orNew.right.handle, result)\n            }\n          }\n        }))\n    }\n    return core.void\n  })\n}\n\n/** @internal */\nexport const withRequestCaching: {\n  (strategy: boolean): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    strategy: boolean\n  ): Effect.Effect<A, E, R>\n} = dual<\n  (\n    strategy: boolean\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    strategy: boolean\n  ) => Effect.Effect<A, E, R>\n>(2, (self, strategy) => core.fiberRefLocally(self, currentCacheEnabled, strategy))\n\n/** @internal */\nexport const withRequestCache: {\n  (cache: Request.Cache): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    cache: Request.Cache\n  ): Effect.Effect<A, E, R>\n} = dual<\n  (\n    cache: Request.Cache\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    cache: Request.Cache\n  ) => Effect.Effect<A, E, R>\n>(\n  2,\n  // @ts-expect-error\n  (self, cache) => core.fiberRefLocally(self, currentCache, cache)\n)\n","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport * as core from \"./internal/core.js\"\nimport * as internal from \"./internal/deferred.js\"\nimport type * as MutableRef from \"./MutableRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const DeferredTypeId: unique symbol = internal.DeferredTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type DeferredTypeId = typeof DeferredTypeId\n\n/**\n * A `Deferred` represents an asynchronous variable that can be set exactly\n * once, with the ability for an arbitrary number of fibers to suspend (by\n * calling `Deferred.await`) and automatically resume when the variable is set.\n *\n * `Deferred` can be used for building primitive actions whose completions\n * require the coordinated action of multiple fibers, and for building\n * higher-level concurrent or asynchronous structures.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Deferred<in out A, in out E = never> extends Effect.Effect<A, E>, Deferred.Variance<A, E> {\n  /** @internal */\n  readonly state: MutableRef.MutableRef<internal.State<A, E>>\n  /** @internal */\n  readonly blockingOn: FiberId.FiberId\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: DeferredUnify<this>\n  readonly [Unify.ignoreSymbol]?: DeferredUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface DeferredUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Deferred?: () => Extract<A[Unify.typeSymbol], Deferred<any, any>>\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface DeferredUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Deferred {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A, in out E> {\n    readonly [DeferredTypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Invariant<E>\n    }\n  }\n}\n\n/**\n * Creates a new `Deferred`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A, E = never>() => Effect.Effect<Deferred<A, E>> = core.deferredMake\n\n/**\n * Creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>> = core.deferredMakeAs\n\nconst _await: <A, E>(self: Deferred<A, E>) => Effect.Effect<A, E> = core.deferredAwait\n\nexport {\n  /**\n   * Retrieves the value of the `Deferred`, suspending the fiber running the\n   * workflow until the result is available.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  _await as await\n}\n\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * Note that `Deferred.completeWith` will be much faster, so consider using\n * that if you do not need to memoize the result of the specified effect.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const complete: {\n  /**\n   * Completes the deferred with the result of the specified effect. If the\n   * deferred has already been completed, the method will produce false.\n   *\n   * Note that `Deferred.completeWith` will be much faster, so consider using\n   * that if you do not need to memoize the result of the specified effect.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Completes the deferred with the result of the specified effect. If the\n   * deferred has already been completed, the method will produce false.\n   *\n   * Note that `Deferred.completeWith` will be much faster, so consider using\n   * that if you do not need to memoize the result of the specified effect.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = core.deferredComplete\n\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const completeWith: {\n  /**\n   * Completes the deferred with the result of the specified effect. If the\n   * deferred has already been completed, the method will produce false.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Completes the deferred with the result of the specified effect. If the\n   * deferred has already been completed, the method will produce false.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>\n} = core.deferredCompleteWith\n\n/**\n * Exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const done: {\n  /**\n   * Exits the `Deferred` with the specified `Exit` value, which will be\n   * propagated to all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Exits the `Deferred` with the specified `Exit` value, which will be\n   * propagated to all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>\n} = core.deferredDone\n\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const fail: {\n  /**\n   * Fails the `Deferred` with the specified error, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Fails the `Deferred` with the specified error, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>\n} = core.deferredFail\n\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const failSync: {\n  /**\n   * Fails the `Deferred` with the specified error, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Fails the `Deferred` with the specified error, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>\n} = core.deferredFailSync\n\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const failCause: {\n  /**\n   * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <E>(cause: Cause.Cause<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, cause: Cause.Cause<E>): Effect.Effect<boolean>\n} = core.deferredFailCause\n\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const failCauseSync: {\n  /**\n   * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>\n} = core.deferredFailCauseSync\n\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const die: {\n  /**\n   * Kills the `Deferred` with the specified defect, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Kills the `Deferred` with the specified defect, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>\n} = core.deferredDie\n\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const dieSync: {\n  /**\n   * Kills the `Deferred` with the specified defect, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Kills the `Deferred` with the specified defect, which will be propagated to\n   * all fibers waiting on the value of the `Deferred`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>\n} = core.deferredDieSync\n\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the `FiberId` of the fiber\n * calling this method.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean> = core.deferredInterrupt\n\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the specified `FiberId`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const interruptWith: {\n  /**\n   * Completes the `Deferred` with interruption. This will interrupt all fibers\n   * waiting on the value of the `Deferred` with the specified `FiberId`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Completes the `Deferred` with interruption. This will interrupt all fibers\n   * waiting on the value of the `Deferred` with the specified `FiberId`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>\n} = core.deferredInterruptWith\n\n/**\n * Returns `true` if this `Deferred` has already been completed with a value or\n * an error, `false` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean> = core.deferredIsDone\n\n/**\n * Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has\n * already been completed, `None` otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const poll: <A, E>(\n  self: Deferred<A, E>\n) => Effect.Effect<Option.Option<Effect.Effect<A, E>>> = core.deferredPoll\n\n/**\n * Completes the `Deferred` with the specified value.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const succeed: {\n  /**\n   * Completes the `Deferred` with the specified value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Completes the `Deferred` with the specified value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>\n} = core.deferredSucceed\n\n/**\n * Completes the `Deferred` with the specified lazily evaluated value.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const sync: {\n  /**\n   * Completes the `Deferred` with the specified lazily evaluated value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>\n  /**\n   * Completes the `Deferred` with the specified lazily evaluated value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>\n} = core.deferredSync\n\n/**\n * Unsafely creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E> = core.deferredUnsafeMake\n\n/**\n * Unsafely exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void = core.deferredUnsafeDone\n","/**\n * @since 2.0.0\n */\nimport type * as Array from \"./Array.js\"\nimport type * as Cause from \"./Cause.js\"\nimport type * as Chunk from \"./Chunk.js\"\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\nimport * as internal from \"./internal/random.js\"\nimport type * as NonEmptyIterable from \"./NonEmptyIterable.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const RandomTypeId: unique symbol = internal.RandomTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type RandomTypeId = typeof RandomTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Random {\n  readonly [RandomTypeId]: RandomTypeId\n  /**\n   * Returns the next numeric value from the pseudo-random number generator.\n   */\n  readonly next: Effect.Effect<number>\n  /**\n   * Returns the next boolean value from the pseudo-random number generator.\n   */\n  readonly nextBoolean: Effect.Effect<boolean>\n  /**\n   * Returns the next integer value from the pseudo-random number generator.\n   */\n  readonly nextInt: Effect.Effect<number>\n  /**\n   * Returns the next numeric value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextRange(min: number, max: number): Effect.Effect<number>\n  /**\n   * Returns the next integer value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextIntBetween(min: number, max: number): Effect.Effect<number>\n  /**\n   * Uses the pseudo-random number generator to shuffle the specified iterable.\n   */\n  shuffle<A>(elements: Iterable<A>): Effect.Effect<Chunk.Chunk<A>>\n}\n\n/**\n * Returns the next numeric value from the pseudo-random number generator.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const next: Effect.Effect<number> = defaultServices.next\n\n/**\n * Returns the next integer value from the pseudo-random number generator.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nextInt: Effect.Effect<number> = defaultServices.nextInt\n\n/**\n * Returns the next boolean value from the pseudo-random number generator.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nextBoolean: Effect.Effect<boolean> = defaultServices.nextBoolean\n\n/**\n * Returns the next numeric value in the specified range from the\n * pseudo-random number generator.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nextRange: (min: number, max: number) => Effect.Effect<number> = defaultServices.nextRange\n\n/**\n * Returns the next integer value in the specified range from the\n * pseudo-random number generator.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const nextIntBetween: (min: number, max: number) => Effect.Effect<number> = defaultServices.nextIntBetween\n\n/**\n * Uses the pseudo-random number generator to shuffle the specified iterable.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>> = defaultServices.shuffle\n\n/**\n * Get a random element from an iterable.\n *\n * @example\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * Effect.gen(function* () {\n *   const randomItem = yield* Random.choice([1, 2, 3])\n *   console.log(randomItem)\n * })\n * ```\n *\n * @since 3.6.0\n * @category constructors\n */\nexport const choice: <Self extends Iterable<unknown>>(\n  elements: Self\n) => Self extends NonEmptyIterable.NonEmptyIterable<infer A> ? Effect.Effect<A>\n  : Self extends Array.NonEmptyReadonlyArray<infer A> ? Effect.Effect<A>\n  : Self extends Iterable<infer A> ? Effect.Effect<A, Cause.NoSuchElementException>\n  : never = defaultServices.choice\n\n/**\n * Retreives the `Random` service from the context and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  defaultServices.randomWith\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const Random: Context.Tag<Random, Random> = internal.randomTag\n\n/**\n * Constructs the `Random` service, seeding the pseudo-random number generator\n * with an hash of the specified seed.\n * This constructor is useful for generating predictable sequences of random values for specific use cases.\n *\n * Example uses:\n * - Generating random UI data for visual tests.\n * - Creating data that needs to change daily but remain the same throughout a single day, such as using a date as the seed.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, Random } from \"effect\"\n *\n * const random1 = Random.make(\"myseed\")\n * const random2 = Random.make(\"myseed\")\n *\n * assert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))\n * ```\n *\n * @since 3.5.0\n * @category constructors\n */\nexport const make: <A>(seed: A) => Random = internal.make\n\n/**\n * Constructs the `Random` service from an array of literal values.\n * The service will cycle through the provided values in order when generating random values.\n * This constructor is useful for creating deterministic sequences for testing or when specific values need to be returned.\n *\n * @example\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * Effect.gen(function* () {\n *   console.log(yield* Random.next) // 0.2\n *   console.log(yield* Random.next) // 0.5\n *   console.log(yield* Random.next) // 0.8\n *   console.log(yield* Random.next) // 0.2 (cycles back)\n * }).pipe(Effect.withRandom(Random.fixed([0.2, 0.5, 0.8])))\n * ```\n *\n * @example\n * ```ts\n * import { Effect, Random } from \"effect\"\n *\n * Effect.gen(function* () {\n *   console.log(yield* Random.nextBoolean) // true\n *   console.log(yield* Random.nextBoolean) // false\n *   console.log(yield* Random.nextBoolean) // true\n * }).pipe(Effect.withRandom(Random.fixed([true, false, true])))\n * ```\n *\n * @since 3.11.0\n * @category constructors\n */\nexport const fixed: <const T extends Array.NonEmptyArray<any>>(values: T) => Random = internal.fixed\n"],"names":["internal","EffectTypeId","StreamTypeId","SinkTypeId","ChannelTypeId","EffectPrototype","CommitPrototype","StructuralCommitPrototype","Base","StructuralBase","Class","StructuralClass","RA","Equal","Equivalence","dual","identity","pipe","Hash","format","NodeInspectSymbol","toJSON","O","Order","pipeArguments","hasProperty","TypeId","Symbol","for","copy","src","srcPos","dest","destPos","len","i","Math","min","length","emptyArray","getEquivalence","isEquivalent","make","self","that","toReadonlyArray","every","value","unsafeGet","_equivalence","equals","ChunkProto","_A","_","toString","_id","values","map","symbol","isChunk","cached","array","iterator","backing","_tag","arguments","makeChunk","chunk","Object","create","depth","left","right","max","_empty","u","empty","as","unsafeFromNonEmptyArray","of","a","fromIterable","unsafeFromArray","copyToArray","initial","j","toArray_","slice","toArray","toReadonlyArray_","arr","Array","reverseChunk","reverse","get","index","none","some","Error","offset","append","appendAll","prepend","elem","take","n","drop","dropRight","dropWhile","predicate","prependAll","diff","abs","nr","nrr","nl","nll","filterMap","f","filter","filterMapWhile","compact","flatMap","out","k","forEach","flatten","chunksOf","gr","current","push","intersection","isEmpty","isNonEmpty","head","unsafeHead","headNonEmpty","last","unsafeLast","lastNonEmpty","mapAccum","s","s1","partition","l","r","partitionMap","separate","size","sort","sortWith","order","mapInput","splitAt","splitNonEmptyAt","_n","floor","split","ceil","splitWhere","tail","tailNonEmpty","takeRight","takeWhile","union","dedupe","dedupeAdjacent","unzip","zipWith","zip","b","remove","removeOption","modifyOption","modify","getOrElse","replace","replaceOption","makeBy","range","start","end","contains","containsWith","findFirst","findFirstIndex","findLast","findLastIndex","refinement","join","reduce","reduceRight","differenceWith","difference","globalValue","TagTypeId","effectVariance","option","ReferenceTypeId","STMSymbolKey","STMTypeId","TagProto","_op","_Service","_Identifier","GenericTag","makeGenericTag","unsafeMake","makeContext","key","stack","context","isContext","limit","stackTraceLimit","creationError","tag","defineProperty","isTag","Tag","id","isReference","TagClass","setPrototypeOf","Reference","options","ReferenceClass","ReferenceProto","defaultValue","ContextProto","_Services","unsafeMap","keys","has","number","add","services","from","serviceNotFoundError","error","String","lines","afterAt","match","message","splice","Map","service","set","defaultValueCache","getDefaultValue","unsafeGetReference","orElse","getOption","merge","mergeAll","ctxs","ctx","pick","tags","tagSet","Set","newEnv","entries","omit","delete","Option","isBigInt","isNumber","isString","bigint0","BigInt","bigint24","bigint60","bigint1e3","bigint1e6","bigint1e9","DURATION_REGEX","decode","input","isDuration","millis","nanos","isArray","Infinity","Number","isNaN","zero","infinity","round","exec","valueStr","unit","micros","seconds","minutes","hours","days","weeks","decodeUnknown","liftThrowable","zeroValue","infinityValue","DurationProto","structure","hrtime","toHrTime","duration","isFinite","isInteger","isZero","toMillis","onMillis","onNanos","toSeconds","toMinutes","toHours","toDays","toWeeks","toNanos","_self","unsafeToNanos","matchWith","_that","selfNanos","thatNanos","between","_min","_max","_clamp","clamp","minimum","maximum","divide","by","unsafeDivide","is","times","subtract","sum","lessThan","lessThanOrEqualTo","greaterThan","greaterThanOrEqualTo","parts","ms","sec","hr","fragments","pieces","unsafeFormatIso","RangeError","rest","years","months","total","str","toFixed","formatIso","fromIso","iso","result","DURATION_ISO_REGEX","mins","secs","previous","arrayUpdate","mutate","at","v","isTagged","BUCKET_SIZE","pow","SIZE","arraySpliceIn","arraySpliceOut","fromBitmap","MASK","toBitmap","MIN_ARRAY_NODE","HashSetSymbolKey","MAX_INDEX_NODE","EmptyNode","popcount","hashFragment","x","HashSetTypeId","HashSetProto","edit","Node","_shift","HM","_keyMap","HashMapSymbolKey","LeafNode","hash","g","HashMapTypeId","combine","HashMapIterator","shift","h","isEmptyNode","isHashSet","isLeafNode","node","item","newLen","bitmap","bit","_size","getHash","isNone","makeImpl","keyMap","canEditNode","elements","beginMutation","endMutation","editable","root","HashMapProto","_edit","_root","constructor","children","found","list","updateCollisionList","canEdit","visitLazy","undefined","CollisionNode","next","done","mergeLeaves","isSubset","v0","cont","child","newValue","_editable","applyCont","visitLazyChildren","transient","isSome","IndexedNode","mask","frag","indx","exists","_newChild","expand","toggle","entry","newChildren","isHashMap","Dual","z","ArrayNode","count","newChild","pack","removed","element","hasHash","hasBy","subNodes","modifyAt","setTree","newRoot","newSize","mergeLeavesInner","h1","n1","h2","n2","subH1","subH2","countBy","currentShift","res","Stack","final","HS","modifyHash","NaN","removeMany","toVisit","pop","ka","toValues","BIT_MASK","BIT_SHIFT","None","assign","prototype","HashMapPatch","MutableRef","patch","MutableRefProto","Data","active","enabled","ReadonlyArrayPatchTypeId","PatchProto","ChunkPatchTypeId","_Value","variance","FiberIdSymbolKey","DifferProto","DifferTypeId","OP_NONE","CooperativeYielding","_Patch","runtime","flag","Interruption","OpSupervision","RuntimeMetrics","WindDown","print","par","Structural","args","string","composite","EmptyProto","FiberIdTypeId","isEnabled","Chunk","params","differ","exclude","emptyHash","first","unsafeCoerce","StructuralPrototype","o","seq","makeAndThen","second","isFiberId","disable","ref","environment","AppendProto","inverse","invert","oldValue","ContextPatch","makeAdd","single","dataSource","blockedRequest","SetLeftProto","SliceProto","isRuntime","makeSlice","until","Arr","MapRequestResolversReducer","isActive","emptyCase","parCase","makeRemoveService","makeRemove","ChunkPatch","seqCase","RemoveProto","singleCase","SetRightProto","isComposite","flags","UpdateProto","enable","startTimeMillis","enableAll","makeUpdateService","decrementAndGet","updateAndGet","interruptible","HashSet","interruption","update","mapRequestResolvers","UpdateLeftProto","OP_RUNTIME","UpdateRightProto","HashMap","missingServices","oldElement","HashSetPatch","reducer","newElement","List","valuePatch","includes","newService","patches","getAndUpdate","allFlags","output","getAndSet","makeAppend","OrPatch","ret","Either","runtimeMetrics","return","OP_COMPOSITE","ReadonlyArrayPatch","enabledSet","toSet","runtimeFlagsPatch","readonlyArray","makeSetRight","disabledSet","increment","cons","either","transform","makeSetLeft","disabled","toOption","unshift","toOld","toNew","acc","updatedContext","andThen","_patch","makeUpdateRight","updateWith","unsafeTail","makeCons","ConsProto","NilHash","keySet_","keySet","NilProto","Composite","runtimeFlags","setAndGet","constant","isNil","render","renderPatch","updated","parallel","toEntries","sequential","step","fiberIds","parallelCollectionCombine","E","_Nil","isList","requests","ids","parallelCollectionEmpty","_fiberCounter","startTimeSeconds","Runtime","identifiers","these","fiberId","nil","Date","now","parallelCollectionAdd","prefix","temp","curr","parallelCollectionToSequentialCollection","parallelCollectionIsEmpty","seqHeadKeys","sequentialCollectionKeys","parKeys","parallelCollectionKeys","sequentialCollectionCombine","EntryTypeId","EntryImpl","request","listeners","ownerId","state","blockedRequestVariance","_R","isEntry","makeEntry","RequestBlockParallelTypeId","parallelVariance","ParallelImpl","parallelCollectionMake","orElseSome","onNone","onSome","other","sequentialCollectionMake","SequentialCollectionTypeId","sequentialVariance","SequentialImpl","prependAllReversed","pres","isCons","sequentialCollectionIsEmpty","sequentialCollectionToChunk","noneIn","isFlipped","allIn","remaining","partialFill","origStart","firstMiss","newHead","toProcess","currentLast","newElem","nextToCopy","bs","oa","nextHead","e","isLeft","toChunk","getExpectedListToBeNonEmptyErrorMessage","scout","OP_DIE","OP_EMPTY","constFalse","constTrue","OP_FAIL","OP_INTERRUPT","OP_PARALLEL","OP_SEQUENTIAL","isFunction","getBugErrorMessage","CauseSymbolKey","CauseTypeId","_E","proto","flattenCause","isCause","causeEquals","defect","failure","pretty","OpCodes","fail","die","interrupt","isEmptyType","isFailType","isDieType","isInterruptType","isSequentialType","isParallelType","reduceWithContext","SizeCauseReducer","cause","isFailure","failureOption","isDie","dieOption","isInterrupted","interruptOption","isInterruptedOnly","IsInterruptedOnlyCauseReducer","failures","defects","interruptors","find","failureOrCause","flipCauseOption","onEmpty","onFail","onDie","onInterrupt","onSequential","mergeWith","onParallel","keepDefects","keepDefectsAndElectFailures","linearize","leftSet","rightSet","leftCause","rightCause","stripFailures","electFailures","stripSomeDefects","pf","accumulator","leftStack","rightStack","leftParallel","leftSequential","evaluateCause","rightParallel","rightSequential","flattenCauseLoop","causes","flattened","FilterCauseReducer","_parallel","_sequential","failCase","dieCase","interruptCase","sequentialCase","parallelCase","OP_SEQUENTIAL_CASE","OP_PARALLEL_CASE","prettyErrors","renderErrorCause","PrettyError","globalThis","span","originalError","originalErrorIsObject","prevLimit","prettyErrorMessage","name","spanSymbol","prettyErrorStack","stringifyCircular","locationRegex","spanToTrace","WeakMap","startsWith","stackFn","locationMatchAll","matchAll","location","getOrUndefined","parent","unknownError","OP_STATE_PENDING","DeferredSymbolKey","called","Duration","OP_STATE_DONE","DeferredTypeId","deferredVariance","pending","joiners","isObject","isPromiseLike","RuntimeFlagsPatch","internalCall","YieldWrap","effect","deferred","throw","DeferredOpCodes","SingleShotGen","runtimeFlags_","blocked","blockedRequests","_continue","EffectPrimitive","effect_instruction_i0","effect_instruction_i1","runRequestBlock","RevertFlags","op","OP_REVERT_FLAGS","effect_instruction_i2","trace","random","EffectPrimitiveFailure","exitIsExit","EffectPrimitiveSuccess","isEffect","withFiberRuntime","withRuntime","OP_WITH_RUNTIME","acquireUseRelease","acquire","use","release","uninterruptibleMask","restore","exit","suspend","matchCauseEffect","onFailure","OP_FAILURE","failCause","internalCause","OP_SUCCESS","onSuccess","succeed","asVoid","custom","wrapper","OP_COMMIT","commit","unsafeAsync","register","blockingOn","FiberId","OP_ASYNC","cancelerRef","resume","void_","asyncInterrupt","async_","backingResume","pendingEffect","proxyResume","controllerRef","AbortController","signal","abort","catchAllCause","OP_ON_FAILURE","catchAll","matchEffect","catchIf","catchSome","checkInterruptible","status","originalSymbol","originalInstance","obj","capture","Proxy","target","p","fiber","currentSpanFromFiber","dieMessage","failCauseSync","RuntimeException","dieSync","evaluate","sync","matchCause","exitFailCause","exitSucceed","failSync","fiberIdWith","OP_ON_SUCCESS","then","UnknownException","flip","OP_ON_SUCCESS_AND_FAILURE","forEachSequential","allocate","whileLoop","while","body","forEachSequentialDiscard","if_","onTrue","onFalse","interruptWith","OP_UPDATE_RUNTIME_FLAGS","interruptibleMask","oldFlags","uninterruptible","intoDeferred","deferredDone","mapBoth","mapError","onError","cleanup","onExit","exitIsSuccess","cause1","cause2","success","zipRight","exitMatch","attemptOrElse","orDie","orDieWith","thunk","OP_SYNC","tap","transplant","scopeOverride","getFiberRef","currentForkScopeOverride","scope","fiberRefLocally","getOrThrow","updateRuntimeFlags","whenEffect","condition","OP_WHILE","fromIterator","OP_ITERATOR","gen","bind","fnUntraced","pipeables","apply","configurable","withConcurrency","concurrency","currentConcurrency","withRequestBatching","requestBatching","currentRequestBatching","withRuntimeFlags","withTracerEnabled","currentTracerEnabled","withTracerTiming","currentTracerTimingEnabled","yieldNow","OP_YIELD","priority","withSchedulingPriority","zipFlatten","zipLeft","never","interval","setInterval","clearInterval","interruptFiber","interruptAsFiber","interruptAsFork","await","logLevelAll","syslog","label","ordinal","MIN_SAFE_INTEGER","logLevelFatal","logLevelError","logLevelWarning","logLevelInfo","logLevelDebug","logLevelTrace","logLevelNone","MAX_SAFE_INTEGER","allLogLevels","FiberRefSymbolKey","FiberRefTypeId","fiberRefVariance","fiberRefGet","fiberRefGetAndSet","fiberRefModify","fiberRefGetAndUpdate","fiberRefGetAndUpdateSome","fiberRefGetWith","fiberRefSet","fiberRefDelete","unsafeDeleteFiberRef","fiberRefReset","setFiberRef","fiberRefModifySome","def","fiberRefUpdate","fiberRefUpdateSome","fiberRefUpdateAndGet","fiberRefUpdateSomeAndGet","RequestResolverSymbolKey","RequestResolverTypeId","requestResolverVariance","RequestResolverImpl","runAll","isRequestResolver","identified","resolverLocally","requestBlockLocally","blockedRequests_","LocallyReducer","fiberRefLocallyWith","fiberRefUnsafeMake","fiberRefUnsafeMakePatch","internalDiffer","fork","fiberRefUnsafeMakeHashSet","hashSet","fiberRefUnsafeMakeReadonlyArray","fiberRefUnsafeMakeContext","_fiberRef","fiberRefUnsafeMakeRuntimeFlags","currentContext","Context","currentSchedulingPriority","currentMaxOpsBeforeYield","currentLogAnnotations","currentLogLevel","currentLogSpan","scheduler","withMaxOpsBeforeYield","currentUnhandledErrorLogLevel","currentVersionMismatchErrorLogLevel","withUnhandledErrorLogLevel","level","currentMetricLabels","metricLabels","currentInterruptedCause","currentTracerSpanAnnotations","currentTracerSpanLinks","ScopeTypeId","CloseableScopeTypeId","scopeAddFinalizer","finalizer","addFinalizer","scopeAddFinalizerExit","scopeClose","close","scopeFork","strategy","causeSquash","causeSquashWith","interrupts","InterruptedException","YieldableError","makeException","RuntimeExceptionTypeId","isRuntimeException","InterruptedExceptionTypeId","isInterruptedException","IllegalArgumentExceptionTypeId","IllegalArgumentException","isIllegalArgumentException","NoSuchElementExceptionTypeId","NoSuchElementException","isNoSuchElementException","InvalidPubSubCapacityExceptionTypeId","InvalidPubSubCapacityException","ExceededCapacityExceptionTypeId","ExceededCapacityException","isExceededCapacityException","isInvalidCapacityError","TimeoutExceptionTypeId","TimeoutException","timeoutExceptionFromDuration","isTimeoutException","UnknownExceptionTypeId","isUnknownException","exitIsFailure","exitIsInterrupted","exitAs","exitAsVoid","exitCauseOption","exitCollectAll","exits","exitCollectAllInternal","exitDie","exitExists","exitFail","exitFlatMap","exitFlatMapEffect","exitFlatten","exitForEachEffect","exitFromEither","exitFromOption","exitGetOrElse","exitInterrupt","exitMap","exitMapBoth","exitMapError","exitMapErrorCause","exitMatchEffect","exitVoid","exitZip","exitZipWith","a2","exitZipLeft","exitZipRight","exitZipPar","exitZipParLeft","exitZipParRight","combineCauses","deferredUnsafeMake","_deferred","deferredAwait","deferredMake","deferredMakeAs","deferredInterruptJoiner","deferredComplete","deferredCompleteWith","deferredFail","deferredFailSync","deferredFailCause","deferredFailCauseSync","deferredDie","deferredDieSync","deferredInterrupt","deferredInterruptWith","deferredIsDone","deferredPoll","deferredSucceed","deferredSync","deferredUnsafeDone","joiner","indexOf","constContext","contextWith","contextWithEffect","provideContext","provideSomeContext","mapInputContext","filterEffectOrElse","pass","filterEffectOrFail","orFailWith","currentSpan","NoopSpanProto","spanId","traceId","sampled","startTime","endTime","attributes","links","kind","attribute","event","addLinks","noopSpan","equivalence","isBoolean","boolean","not","and","nand","or","nor","xor","eqv","implies","collection","FiberStatusSymbolKey","delete_","fiberRefLocals","refVariance","PriorityBuckets","OP_UPDATE","constVoid","DoneHash","core","OP_DONE","buckets","Proto","toStringUnknown","Done","running","FiberStatusTypeId","doNotation","OP_PARALLEL_N","scheduleTask","RefTypeId","Readable","FiberRefsSym","bucket","isIterable","locals","fiberRefs","parallelN","yieldWrapGet","fiberRef","pairs","old","missingLocals","Info","_ref","_parentStack","isSequential","_childModified","task","forkAs","getAndUpdateSome","parentStack","isDone","OP_ADD","isNonEmptyReadonlyArray","childStack","isFiberStatus","parentFiberId","isParallel","OP_RUNNING","parentAncestors","childFiberId","isMicro","parallelism","childRefValue","modifySome","Suspended","childAncestors","isRunning","childModified","OP_SUSPENDED","OP_REMOVE","getOrDefault","allLevels","MicroCauseTypeId","microCauseVariance","joinAs","maxNextTickBeforeTimer","Running","starveInternal","suspended","setAll","traces","tasks","parentFiberRefs","updateSome","toRun","childValue","causeName","fallback","updateAs","messageLines","fiberRefs_","starve","updateManyAs","ancestor","wasModified","findAncestor","setTimeout","Promise","resolve","newStack","currentOpCount","FiberRefsImpl","OP_AND_THEN","MicroCauseImpl","childId","lessThanEqual","unsafeForkAs","defaultScheduler","MixedScheduler","greaterThanEqual","causeFail","Fail","SyncScheduler","fromLiteral","literal","causeDie","Die","Fatal","Trace","Warning","causeInterrupt","Interrupt","shouldYield","causeIsFail","flush","unsafeUpdateAs","oldStack","currentId","currentValue","causeIsInterrupt","ControlledScheduler","MicroFiberTypeId","MicroFiberImpl","_stack","_observers","_children","makeMatrix","fiberVariance","record","p0","p1","getRef","InternalContext","addObserver","_exit","cb","_interrupted","unsafeInterrupt","unsafePoll","defaultShouldYield","_yielded","yielded","runLoop","Yield","makeBatched","callback","interruptChildren","fiberMiddleware","tasksToRun","yielding","CurrentScheduler","prev","MicroExitTypeId","timer","timerBatched","currentScheduler","withScheduler","getCont","ensureCont","yieldWith","fiberInterruptChildren","fiberInterruptAll","fiberAwait","async","fiberJoin","fiberInterrupt","fibers","iter","wait","identifier","successCont","failureCont","microVariance","MicroProto","Effectable","defaultEvaluate","_fiber","makePrimitiveProto","eval","contA","contE","ensure","makePrimitive","makeExit","prop","isMicroExit","yieldNowWith","resumed","succeedSome","succeedNone","fromOption","fromEither","try_","try","err","catch","promise","asyncOptions","tryPromise","withMicroFiber","yieldFlush","controller","onCancel","asyncFinalizer","setInterruptible","call","asSome","sandbox","raceAll","all","effects","doneCount","unsafeFork","raceAllFirst","race","raceFirst","OnSuccessProto","exitIsInterrupt","exitIsFail","exitIsDie","exitVoidAll","setImmediate","MicroSchedulerDefault","_priority","afterScheduled","runTasks","MaxOpsBeforeYield","serviceOption","updateContext","updateService","getContext","provided","provideService","provideServiceEffect","CurrentConcurrency","concurrent","filterOrFailCause","filterOrFail","when","repeatExit","startedAt","schedule","attempt","loop","delayEffect","elapsed","sleep","repeat","replicate","replicateEffect","forever","scheduleRecurs","scheduleSpaced","scheduleExponential","baseMillis","factor","scheduleAddDelay","scheduleWithMaxDelay","scheduleWithMaxElapsed","scheduleUnion","d1","d2","scheduleIntersect","OnFailureProto","catchCauseIf","catchAllDefect","causeIsDie","tapErrorCause","tapErrorCauseIf","tapError","tapDefect","catchTag","mapErrorCause","orElseSucceed","ignore","ignoreLogged","console","retry","withTrace","generate","line","trim","lineMatch","causeWithTrace","primitive","OnSuccessAndFailureProto","timeout","clearTimeout","delay","timeoutOrElse","onTimeout","timeoutOption","MicroScopeTypeId","MicroScope","MicroScopeImpl","finalizers","unsafeAddFinalizer","unsafeRemoveFinalizer","microExit","newScope","fin","scopeMake","scopeUnsafeMake","provideScope","scoped","acquireRelease","ensuring","onExitIf","arg","discard","iterable","concurrencyOption","POSITIVE_INFINITY","items","inProgress","pumping","interrupted","pump","currentIndex","negate","Do","bindTo","let_","immediate","daemon","forkDaemon","forkIn","forkScoped","runFork","aborted","addEventListener","once","removeEventListener","runPromiseExit","_reject","handle","runPromise","runSyncExit","runSync","TaggedError","ClockSymbolKey","ClockTypeId","clockTag","MAX_TIMER_MILLIS","globalClockScheduler","unsafeSchedule","completed","performanceNowNanos","performance","origin","processOrPerformanceNow","processHrtime","process","bigint","ClockImpl","unsafeCurrentTimeMillis","unsafeCurrentTimeNanos","currentTimeMillis","currentTimeNanos","canceler","void","unbounded","bounded","currentRequestMap","matchSimple","isRegExp","escape","OP_AND","OP_OR","OP_INVALID_DATA","ConfigErrorSymbolKey","OP_MISSING_DATA","ConfigErrorTypeId","OP_SOURCE_UNAVAILABLE","OP_UNSUPPORTED","And","enumerable","Or","InvalidData","path","pathDelim","MissingData","SourceUnavailable","Unsupported","isConfigError","isAnd","isOr","isInvalidData","isMissingData","isSourceUnavailable","isUnsupported","prefixed","IsMissingDataOnlyReducer","andCase","orCase","invalidDataCase","missingDataCase","sourceUnavailableCase","unsupportedCase","isMissingDataOnly","OP_CONSTANT","lowerCase","toLowerCase","RandomSymbolKey","OP_DESCRIBED","toUpperCase","TracerTypeId","Predicate","OP_LAZY","configError","OP_MAP_OR_FAIL","assert","pathPatch","liveServices","re","RegExp","clock","console_","consoleTag","defaultConsole","randomTag","configProvider","configProviderTag","fromEnv","tracer","tracerTag","nativeTracer","RandomImpl","DEFAULT_SPLIT_REGEXP","RandomTypeId","OP_PRIMITIVE","concat","OP_SEQUENCE","seed","characters","currentServices","PCGRandom","noCase","ConfigProviderTypeId","ConfigProviderSymbolKey","OP_ZIP_WITH","countReset","PRNG","charactersLength","decodedDuration","clockWith","nextBoolean","DEFAULT_STRIP_REGEXP","FlatConfigProviderSymbolKey","nextInt","defaultServicesWith","stripRegexp","currentDefaultServices","NativeSpan","integer","debug","nextRange","dir","nextIntBetween","withClock","c","shuffle","makeFlat","FlatConfigProviderTypeId","dirxml","shuffleWith","withConfigProvider","provider","delimiter","config","load","pascalCaseTransform","configProviderWith","firstChar","charAt","buffer","numbers","substring","flat","configOrDie","fromFlatLoop","lowerChars","nextIntBounded","swap","collapsed","groupCollapsed","group","index1","index2","tmp","groupEnd","randomWith","info","randomHexString","camelCaseTransform","camelCase","pascalCase","seqDelim","unmakePathString","log","pathString","getEnv","constantCase","env","tabularData","choice","containsName","makePathString","valueOpt","properties","parsePrimitive","kebabCase","getNextValue","time","events","tracerWith","timeEnd","withTracer","filteredKeyPaths","snakeCase","keyPaths","keyPath","timeLog","pathComponent","currentElement","externalSpan","fromFlat","enumerateChildren","warn","fromMap","captureStackTrace","traceError","cache","mapWithIndexSplit","splitIndexInKeys","fixed","FixedRandomImpl","DisablePropagation","extend","leftDef","rightDef","leftPad","unfold","rightPad","leftExtension","rightExtension","appendConfigPath","OP_FALLBACK","error1","error2","original","mapOrFail","OP_NESTED","description","patchedPrefix","indicesFrom","indices","chunkChunk","OP_HASHMAP","valueConfig","matrix","transpose","isRight","fromFlatLoopFail","lefts","rights","mapInputPath","mapInputPathFlat","mapName","nested","unnested","orElseFlat","StringUtils","upperCase","within","unnest","nest","splitPathString","text","delim","regexp","parse","char","column","row","quotedIndices","parseQuotedIndex","STR_INDEX_REGEX","QUOTED_INDEX_REGEX","matchedIndex","parseInteger","newMap","keyWithIndex","splitIndexFrom","matchedString","optionalString","optionalIndex","parsedIndex","parseInt","keyName","keyIndex","fromJson","json","hiddenDelimiter","indexedEntries","getIndexedEntries","configPathToString","component","nextComponent","loopAny","loopArray","loopObject","onNonEmpty","isNotNullable","newPath","isEmptyReadonlyArray","RBT","defaultServices","Clock","RedBlackTreeTypeId","metricHook","FiberScopeSymbolKey","SortedSet","metricKeyType","FiberStatus","MetricPairTypeId","MetricPairSymbolKey","Backward","MetricLabelSymbolKey","clone","_Type","MetricBoundariesSymbolKey","Direction","RequestSymbolKey","MetricLabelImpl","metricBoundaries","MetricStateSymbolKey","MetricRegistrySymbolKey","MetricKeySymbolKey","OP_INTERRUPT_SIGNAL","metricState","MetricHookSymbolKey","MetricLabelTypeId","_runtimeFlags","formatLabel","MutableHashMap","direction","CounterKeyTypeSymbolKey","ContextPatchTypeId","roots","Micro","RequestTypeId","_hash","metricPair","requestVariance","hook","LoggerSymbolKey","supervisorVariance","FiberSymbolKey","underlying","keyTree","metricKey","GaugeStateSymbolKey","GaugeKeyTypeSymbolKey","value0","RequestPrototype","isMetricBoundaries","metricKeyVariance","HistogramStateSymbolKey","loggerVariance","metricRegistry","Forward","FiberTypeId","tell","keyType","parentFiber","SummaryKeyTypeSymbolKey","unsafeModify","annotations","MetricTypeId","MetricBoundariesTypeId","removeChild","makeLogger","itemSelf","itemThat","isSummaryKey","isMetricKey","onSuspend","arrayEquivilence","linear","CounterStateTypeId","width","movePrev","onResume","CounterKeyTypeTypeId","supervisor","logLevel","globalScope","SortedSetProto","BucketIterator","Global","incremental","CounterStateSymbolKey","patchLoop","MetricKeyTypeId","LoggerTypeId","complete","_patches","counter","completedRequestMap","fromNullable","extraTags","unsafeUpdate","unsafeValue","MutableHashMapIterator","MetricKeyImpl","frequency","gauge","arrayEquals","histogram","boundaries","fiberStarted","_value","MetricStateTypeId","metricStateVariance","taggedWithLabels","metricLabel","FrequencyStateTypeId","occurrences","untaggedHook","metric","ord","FrequencyKeyTypeTypeId","onStart","removeSupervisor","fiberFailures","preregisteredWords","isFrequencyState","tree","FrequencyKeyTypeHash","RedBlackTreeProto","tagged","exponential","isFrequencyKey","dump","onEffect","fromTree","insert","GaugeState","Exit","tuple","EvaluationSignalContinue","slotCount","removeObserver","word","GaugeStateTypeId","EvaluationSignalDone","fromMetricKey","inheritAll","isZip","GaugeKeyTypeTypeId","amount","isGaugeState","_key","startAt","interruptAllAs","Zip","Inspectable","YieldedOp","whitespace","currentOp","unsafeInterruptAsFork","SupervisorTypeId","HistogramState","contOpSuccess","summary","OnStep","_cont","greaterThanForwards","withNow","summaryTimestamp","formatValue","quoteValue","metricKeyTypeVariance","HistogramKeyTypeTypeId","Uint32Array","idx","optionEffect","toISOString","patchRuntimeFlags","taggedWithLabelsInput","fiberId_","currentRuntimeFlags","newSupervisors","messages","extraTags1","added","mapEffect","oldSupervisors","Cause","referential","MAX_VALUE","moveNext","RedBlackTreeIterator","pushStack","greaterThanEqualForwards","ProxySupervisor","date","base","Differ","timerWithBoundaries","to","execution","poll","boundary","MetricKeyTypeTypeId","mid","SummaryKeyTypeTypeId","maxAge","maxSize","SummaryStateTypeId","quantiles","JSON","stringify","FiberMessage","cur","cases","trackDefectWith","_cur","_message","_effect","updater","onFiber","trackDurationWith","isSummaryState","structuredMessage","getFromBucket","descriptorWith","runBlockedRequests","getBuckets","RequestBlock_","requestsByRequestResolver","forEachConcurrentDiscard","builder","trackErrorWith","block","_ord","keysBackward","effectable","allowInterrupt","descriptor","cumulated","messageArr","fiberProto","summarized","fiberRefsPatch","trackSuccessWith","d","invokeWithInterrupt","SummaryState","refs","refsNew","flagsNew","version","getCurrentVersion","internalFiber","_never","lessThanForwards","runtimeFiberVariance","_fiberId","_context","_running","getOrder","exit1","isSuccess","exit2","bucketsSize","_steps","option1","HistogramStateTypeId","option2","dropping","bool","globalMetricRegistry","snapshot","structuredLogger","currentTracer","isLogger","withColor","fiberRefs0","colors","runtimeFlags0","lessThanEqualBackwards","removeFirst","_fiberRefs","orElseEither","withColorNoop","fiberActive","bold","unsafeTrack","refreshRefCache","milliseconds","roundTowardsZero","forEachGreaterThanEqual","age","t","fromEffect","microseconds","fibersIn","FibersIn","All","gray","eventually","Debug","forEachLessThan","blue","green","cmp","sortedQuantiles","red","observe","bgBrightRed","timestamp","black","filterOrElse","logLevelStyle","d_stack","isInterruptible","forEachBetween","liftPredicate","ask","getHours","padStart","getMinutes","getSeconds","getMilliseconds","findLoop","stdout","n_stack","processStdoutIsTTY","hasProcessStdout","isTTY","Color","lifeMsg","mode","hasProcessStdoutOrDeno","mode_","isBrowser","formatDate","fiberScope","showColors","reversed","calculateQuantiles","color","unsafeRoots","sortedSamples","firstSuccessOf","getChildren","sampleCount","resolvedHead","resolveQuantile","consumed","quantile","valuesForward","rq","getCurrentFiber","currentFiberURI","message_","error_1","sampleCount_1","forAllLoop","FiberRefs","consumed_1","valuesReversed","unsafe","stderr","rest_1","getInterruptedCause","error_2","Black","n3","white","logLevelColors","threadName","getTime","pp","logSpan_","spans","firstLine","y","getFiberRefs","Red","repaint","firstMaybeString","clear","cyan","stateful","recount","ppp","logDebug","messageIndex","inheritFiberRefs","childFiberRefs","updateFiberRefs","_queue","desired","quantile_1","candConsumed","_exitValue","sameHead","allowedError","iterate","z2","consumed_2","logWithLevel","rest_2","levelOption","current_1","current_2","parentStatus","firstParams","msg","updatedFiberRefs","setFiberRefs","updatedRuntimeFlags","parentRuntimeFlags","headValue","valueToReturn","fiberState","logTrace","LogLevel","logInfo","logWarning","logError","withLogSpan","LogSpan","logAnnotations","prevError","redact","loopInternal","inc","loopDiscard","quantile_2","redacted","observer","prettyLoggerDefault","prettyLogger","memoize","diffFiberRefsAndRuntimeFlags","patchFiberRefs","keysForward","begin","Ref","parallelErrors","errors","currentSupervisor","el","addChild","reduceWhile","reduceWhileLoop","nextState","greaterThanBackwards","repeatN","repeatNLoop","last_ptr","transferChildren","tagMetrics","labelMetrics","labels","takeUntil","greaterThanEqualBackwards","drainQueueOnCurrentThread","recurse","evaluationSignal","evaluateMessageWhileSuspended","EvaluationSignalYieldNow","drainQueueLaterOnExecutor","taking","run","drainQueueWhileRunning","cur0","drainQueueWhileRunningTable","tapErrorTag","addInterruptedCause","oldSC","processNewInterruptSignal","sendInterruptSignalToAllChildren","timedWith","Tracer","catcher","told","interruptSignal","visitLessThan","interruptAllChildren","it","visitBetween","tryMap","tryMapPromise","unless","unlessEffect","unsandbox","reportExitValue","endTimeMillis","whenFiberRef","fiberSuccesses","serviceFunctionEffect","getService","serviceFunction","serviceFunctions","_target","_receiver","cstack","serviceConstants","setExitValue","serviceMembers","functions","constants","getLoggers","currentLoggers","overrideLogLevel","minimumLogLevel","currentMinimumLogLevel","annotateCurrentSpan","loggers","clockService","withRedactableContext","contextMap","logger","linkSpanCurrent","annotateSpans","currentParentSpan","serviceOptional","internalTracer","spanTag","linkSpans","_asyncInterruptor","filterDisablePropagation","unsafeMakeSpan","disablePropagation","OP_RESUME","_asyncBlockingOn","evaluateEffect","OP_STATEFUL","timingEnabled","absurd","linksFromEnv","annotationsFromEnv","effect0","eff","makeSpan","yieldedOpChannel","cooperativeYielding","spanAnnotations","fixDoubleBlack","endSpan","useSpan","addSpanStackTrace","valuesBackward","withParentSpan","withSpan","dataFirst","functionWithSpan","visitFull","visit","opts","startFork","optionFromOptional","visitGreaterThanEqual","oldRuntimeFlags","newRuntimeFlags","initiateAsync","asyncRegister","alreadyCalled","popStack","getNextSuccessCont","frame","getNextFailCont","OP_TAG","Left","Right","Some","microResume","abortResume","oldCur","Blocked","frames","snap","patchRefs","FiberRefsPatch","patchFlags","newFiber","RunBlocked","updateFlags","revertFlags","_isYielding","check","_version","_V","effectVersion","loggerWithConsoleLog","internalLogger","loggerWithLeveledLog","unsafeLogger","loggerWithConsoleError","defaultLogger","stringLogger","jsonLogger","logFmtLogger","logfmtLogger","tracerLogger","loggerWithSpanAnnotations","mapInputOptions","batchedLogger","window","internalEffect","annotateLogsScoped","fiberRefLocallyScopedWith","whenLogLevel","requiredLogLevel","acquireReleaseInterruptible","acquireRefs","acquireFlags","runtimeFinalizer","preRefs","preFlags","inverseRefs","daemonChildren","forkScope","_existsParFound","existsLoop","predicate_","Boolean","getSomes","allResolveInput","allValidate","reconcile","eitherEffects","batching","concurrentFinalizers","eithers","successes","errored","allEither","allWith","allSuccesses","isRequestBatchingEnabled","finalizersMaskInternal","ExecutionStrategy","forEachParN","forEachParUnbounded","fn","processAll","graft","todos","fibersCount","results","interruptAll","startOrder","joinOrder","residual","collectExits","runFiber","interruptImmediately","runnable","unsafeForkUnstarted","onInterruptSignal","stepOrExit","processingFiber","pushResult","returnNextElement","onRes","todo","wrapped","toPop","hitNext","forkWithScopeOverride","forkWithErrorHandler","handler","overrideScope","childFiber","unsafeMakeChildFiber","FiberRuntime","childContext","onEnd","parentScope","validateAll","es","isNonEmptyArray","winner","latch","reduceEffect","parallelFinalizers","scopeTag","inner","scopeExtend","parallelNFinalizers","finalizersMask","sequentialFinalizers","scopeWith","scopedWith","scopedEffect","scopeUse","tagMetricsScoped","labelMetricsScoped","using","validate","validateWith","zipWithOptions","ea","eb","ca","validateAllPar","validateAllParDiscard","validateFirst","withClockScoped","withRandomScoped","withConfigProviderScoped","withEarlyRelease","executionStrategy","zipOptions","zipLeftOptions","zipRightOptions","withRuntimeFlagsScoped","revertRuntimeFlags","scopeUnsafeAddFinalizer","ScopeImplProto","fiberRefUnsafeMakeSupervisor","SupervisorPatch","fiberRefLocallyScoped","fiberRefMake","fiberRefMakeWith","fiberRefMakeContext","fiberRefMakeRuntimeFlags","fiberAwaitAll","_await","fiberAll","_fiberAll","optionB","optionA","fiberInterruptFork","fiberJoinAll","fiberScoped","raceWith","raceFibersWith","onSelfWin","loser","onSelfDone","onOtherWin","onOtherDone","disconnect","raceIndicator","MRef","leftFiber","selfScope","rightFiber","otherScope","completeRace","ab","compareAndSet","processing","counts","checkDone","interruptWhenPossible","makeSpanScoped","clock_","withTracerScoped","withSpanScoped","fiberRuntime","Scope","addFinalizerExit","squash","squashWith","OP_CONTINUE","IntervalTypeId","IntervalsTypeId","IntervalsSymbolKey","IntervalSymbolKey","intervals","startMillis","endMillis","continueWith","Intervals","unionLoop","_interval","_acc","intersect","Interval","after","startMilliseconds","before","endMilliseconds","NEGATIVE_INFINITY","intersectLoop","_left","_right","circular","OP_EXTEND_SCOPE","OP_FOLD","getAndUpdateEffect","modifyEffect","getAndUpdateSomeEffect","OP_FROM_EFFECT","OP_SCOPED","scheduler_","OP_SUSPEND","scope_","InternalCause","RuntimeFiberTypeId","OP_PROVIDE_MERGE","circularManagedRuntime","makeDual","Semaphore","permits","waiters","modifySomeEffect","LayerSymbolKey","isFiber","updateEffect","LayerTypeId","layerVariance","updateAndGetEffect","free","_RIn","taken","fiberRefUpdates","isRuntimeFiber","_ROut","updateRefs","MemoMapTypeIdKey","closeableScope","MemoMapTypeId","CurrentMemoMap","supervisor_","unsafeMakeMemoMap","isFresh","_op_layer","awaitAll","MemoMapImpl","unsafeRunCallback","updateTakenUnsafe","cancelOptions","Fiber","interruptAs","getOrElseMemoize","layer","synchronized","updateTaken","releaseAll","inMap","withPermits","unsafeRunSyncExit","observers","finalizerRef","resource","innerScope","makeBuilder","diffFiberRefs","unsafeMakeSemaphore","EffectOpCodes","makeSemaphore","Latch","dumpAll","isOpen","scheduled","asyncFiberException","memoized","FiberFailureCauseId","flushWaiters","FiberFailureImpl","FiberFailureId","makeMemoMap","makeSynchronized","unsafeMakeSynchronized","build","buildWithScope","memoMap","buildWithMemoMap","open","inMemoMap","unsafeOpen","failureK","successK","isFiberFailure","unsafeClose","whenOpen","zipK","unsafeMakeLatch","makeLatch","awaitAllChildren","ensuringChildren","timeToLive","cachedInvalidateWithTTL","getCachedValue","invalidateCache","computeCachedValue","timeToLiveMillis","succeedContext","fastPath","updateSomeAndGetEffectSynchronized","interruptFork","fromEffectContext","extendScope","internalRef","unsafeRunPromiseExit","track","supervised","fiberFailure","scopeImpl","fresh","OP_FRESH","fromFiber","tagFirst","fromFiberEffect","memoKeySymbol","fromEffectDiscard","eq","locallyEffect","locally","RuntimeImpl","cachedFunction","Key","scopedDiscard","defaultRuntimeFlags","fromFunction","tagA","tagB","mock","mockImpl","supervise","enableRuntimeFlag","timeoutFail","timeoutTo","makeUnimplemented","timeoutFailCause","dead","unimplemented","deleteFiberRef","getPrototypeOf","unsafeRunEffect","defaultRuntime","unsafeRunPromiseEffect","unsafeRunPromise","unsafeRunSyncEffect","unsafeRunSync","unsafeRunSyncExitEffect","fold","cleanup_","SynchronizedSymbolKey","SynchronizedTypeId","synchronizedVariance","SynchronizedImpl","withLock","layers","zipLeftFiber","passthrough","zipRightFiber","project","stateTag","retryLoop","zipWithFiber","sem","retryUpdate","decision","ScheduleDecision","scopedContext","zipFiber","exitA","exitB","bindAll","syncContext","toRuntime","toRuntimeWithMemoMap","provide","provideTo","OP_PROVIDE","provideMerge","unwrapEffect","unwrapScoped","annotateLogs","isLayer","provideSomeLayer","provideSomeRuntime","rt","oldContext","oldRefs","newRefs","newFlags","rollbackRefs","rollbackFlags","effect_provide","source","runtimeEffect","struct","unsafeStruct","unsafeArray","ArrayProto","_case","case","TaggedClass","taggedEnum","taggedMatch","plainArgsSymbol","BaseEffectError","consoleWith","withConsole","withConsoleScoped","setConsole","table","withGroup","withTime","unsafeMakeWith","MutableListProto","MutableQueue","option_","dateTime","Random","withExecutionPlan","plan","MutableQueueProto","currentCacheEnabled","fromRequest","isRequest","ds","proxy","steps","queue","cacheEnabled","isGeneratorFunction","entryStats","attempted","currentCache","getEither","orNew","ScheduleSymbolKey","nextEffect","isCron","isSchedule","ScheduleTypeId","tz","scheduleDefectRefail","BlockedRequests","scheduleFromStep","weekdays","decrement","ScheduleDriverSymbolKey","defaultIterationMetadata","InternalSchedule","retry_Effect","refreshing","epochMillis","capacity","MapKeyTypeId","scheduleVariance","attempts","_Out","zone","scheduleDriverVariance","fromRetryOptions","Listeners","TimeZoneTypeId","MapKeyImpl","ScheduleImpl","MutableList","ProtoTimeZoneNamed","cacheRequest","N","_length","updateInfo","iterationMetaRef","recurrence","elapsedSincePrevious","ProtoTimeZoneOffset","month","ProtoTimeZone","weekday","withRequestCaching","nextLookupTable","hour","completeEffect","day","offer","offsetToString","queueLength","fill","partsUtc","cachedWithTTL","KeySetImpl","remainder","writable","offering","makeCacheState","accesses","updating","hits","misses","reset","lookup","iterationMeta","setState","ParseError","initialCacheState","makeKeySet","CacheSymbolKey","ParseErrorTypeId","isDateTime","_Key","isTimeZoneOffset","isTimeZone","isParseError","makeWithState","ConsumerCacheSymbolKey","addDelayEffect","modifyDelayEffect","consumerCacheVariance","andThenEither","lState","_Error","rState","EmptyMutableQueue","makeCacheStats","makeEntryStats","loadedMillis","makeUtc","ProtoUtc","CacheImpl","bothInOut","in1","in2","lDecision","out2","rDecision","isContinue","cron","continue","segments","CacheTypeId","cacheVariance","ConsumerCacheTypeId","cacheState","test","checkEffect","unsafeFromDate","zoneFromString","collectAllInputs","collectAllOutputs","outs","cacheStats","secondOptions","recurUntil","parseSegment","minuteOptions","collectUntilEffect","hourOptions","recurUntilEffect","collectWhile","recurWhile","weekdayOptions","hasZone","collectWhileEffect","recurWhileEffect","compose","mapKey","makeMapKey","mapInputEffect","input2","minEpochMillis","maxEpochMillis","unsafeMakeZoned","isZoned","expression","parsed","Cron","getOptionComplete","trackAccess","trackMiss","getTimezoneOffset","zoneMakeOffset","resolveMapValue","makeNode","timeZone","parsedZone","beginningOfSecond","adjustForTimeZone","makeZonedProto","dayOfMonth","loaded","disambiguation","makeZoned","nextDayOfMonth","zonedStringRegex","beginningOfDay","day0","endOfDay","parseOffset","dayOfWeek","isoString","nextDay","nowAsDate","unsafeNow","delayed","delayedEffect","toParts","addDelay","setZone","isDateTimeArgs","makeZonedFromAdjusted","setZoneOffset","formatOptions","year","invalidate","onInput","onOutput","fractionalSecondDigits","invalidateWhen","zoneId","validZoneCache","driver","weekDay","ScheduleDriverImpl","daysInMonth","durationInput","UTC","getUTCFullYear","getUTCMonth","getUTCDate","durationMillis","invalidateAll","zoneUnsafeMakeNamed","eitherWith","unionWith","refresh","baseInput","delayedSchedule","Deferred","fibonacci","oneInput","one","intervalInput","startFrom","lookupValueOf","isTimeZoneNamed","adjustDst","zoneMakeNamed","utc","adjusted","zoned","hasExpired","intervalMillis","lastRun","drift","zoneMakeLocal","Intl","DateTimeFormat","offsetZoneRegex","sleepTime","nextRun","setUTCSeconds","getUTCSeconds","mapValue","currentSecond","nextSecond","fromDelay","zoneToString","setUTCMinutes","getUTCMinutes","fromDelays","delays","durations","setZoneNamed","currentMinute","nextMinute","minute","setUTCHours","getUTCHours","toEpochMillis","distance","diffMillis","lookupResult","distanceDuration","nextHour","hour0","currentHour","setUTCDate","intersectWith","intersectWithLoop","lInterval","rInterval","isPast","combined","unsafeIsPast","getUTCDay","currentWeekday","nextWeekday","toDateUtc","currentDay","toDate","addDays","adjustedEpochMillis","formatToParts","type","setUTCFullYear","jittered","currentMonth","ignorePending","nextMonth","setUTCMonth","zonedOffset","trackHit","removeTime","sequence","minuteOfHour","dateToParts","getUTCMilliseconds","minute0","beginningOfMinute","restrictionsEquals","restrictionsArrayEquals","endOfMinute","toPartsUtc","partsAdjusted","withDate","delta","newStart","oldStart","withDateUtc","newInterval","dayOptions","getPartUtc","part","onDecision","monthOptions","getPart","setPartsDate","aliases","jan","feb","mar","untilInput","jul","untilInputEffect","recurUntilOption","untilOutput","dec","recurUpTo","whileOutput","stats","mon","tue","recurs","thu","fri","sat","setParts","repeatForever","makeWith","setPartsUtc","mutateUtc","fields","constDayMillis","repetitions","raw","splitStep","adjustedMillis","field","resetAfter","resetWhen","calculateNamedOffset","afterOffset","beforeOffset","isForwards","inputs","transitionMillis","currentAfterOffset","nextInputs","beforeAdjustedMillis","formatted","splitRange","second0","endOfSecond","spaced","currentBeforeOffset","laterOffset","offsetRegex","sign","untilOutputEffect","seperator","upTo","whileInput","whileInputEffect","aliasOrValue","whileOutputEffect","windowed","newAdjustedDate","toLocaleLowerCase","mapEpochMillis","onUtc","onZoned","getFullYear","getMonth","getDate","subtractDuration","addMillis","setTime","setSeconds","newDate","setMinutes","newParts","startOfDate","beginningOfHour","setUTCMilliseconds","endOfHour","setHours","weekStartsOn","setDate","getDay","nextDayOfWeek","startOf","endOfDate","findNextMonth","dropUntil","tmp1","tmp2","setMonth","tmp3","ScheduleDefect","ScheduleDefectTypeId","scheduleDefectWrap","isScheduleDefect","scheduleDefectRefailCause","repeatOrElse_Effect","repeat_combined","repeat_Effect","endOf","withWhile","applied","nearest","diffStart","diffEnd","withTimes","withUntil","intersectionPair","repeatOrElseEffectLoop","CurrentIterationMetadata","intlTimeZone","locale","policy","retryOrElse_Effect","formatLocal","formatUtc","formatIntl","formatIsoDate","formatIsoDateUtc","formatIsoOffset","zonedOffsetIso","retryOrElse_EffectLoop","formatIsoZoned","schedule_Effect","scheduleFrom_Effect","scheduleFrom_EffectLoop","stop","scheduleForked","asyncEffect","runtime_","_void","_catch","catchSomeCause","catchSomeDefect","catchTags","schedule_","retry_combined","internalExecutionPlan","retryOrElse","asSomeError","flipWith","ensuringChild","forkAll","Scheduler","timed","filterOrDie","filterOrDieMessage","whenRef","tapBoth","repeatOrElse","scheduleFrom","locallyWith","locallyScoped","locallyScopedWith","logFatal","orElseFail","withRandom","withRandomFixed","getRuntimeFlags","withRuntimeFlagsPatch","withRuntimeFlagsPatchScoped","withMetric","unsafeForkEffect","runCallback","unsafeRunPromiseExitEffect","ap","Request","query","cacheRequestResult","withRequestCache","spanLinks","transposeOption","transposeMapOption","makeTagProxy","receiver","Reflect","cn","Service","maker","patchState","selfProto","hasDeps","dependencies","layerName","layerCache","layerWithDepsCache","DefaultWithoutDependencies","nameOrBody","errorDef","defineLength","errorCall","fnApply","spanName","spanOptions","fnError","stackDef","stackCall","endStackDef","endStackCall","ensureSuccessType","ensureErrorType","ensureRequirementsType"],"mappings":"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,CAAC0hD,GAAiBv6C,GAAG,AAAd,CAAe,AAAdw6C,CAAe,CAAN,AAAO,iOGxJpF,IAAA,EIA6C,CSAtC,AJAA,AKAA,ACMA,ACNA,ACCA,ACKA,ACCA,ACPA,ApBAA,AYAA,AFQA,AFRA,ADIA,ADJA,ADAA,ADAA,ADAA,AFQA,ACRA,ASAA,AOMwC,CjBEiB,CoBJvDjmD,ACJAP,ACEAF,AFEwC,ANEA,ASFxCE,AvBIuD,CAAA,EDRpDL,AaAAC,AJAAmiB,AMMAwwC,AdEAC,AgBPAC,ACKA1zD,AENAkhB,AVQAqsB,ASDA9wB,AZHA5b,AHJA4zB,AQAAzR,AJAAA,ALAAA,ADAAA,AIAAA,ADAAA,AWAAsV,ALAAtV,AGAA9B,CUIC,ADFA,ADFA,CtBAC,CEAC,AMAA,AOMA,ANNA,AHAA,AKAA,ARAA,ASAA,APAA,CcOC,ATCA,CGRC,ANIA,AOJA,AMAA,AHCA,EDDE,ChBAC,AkBMA,AdNA,CKAC,AeIA,AbJA,AYEA,ArBFA,AIAA,AEAA,AcAA,AjBAA,AFAA,AYMA,AHNA,CSIC,AXIA,ASDA,CZHC,AUHA,AGDA,APAA,ACAA,CbQyC,CeRvC,CZAC,AcMA,CjBEC,GoBJG,GrBJG,ACQA,CCRC,ASAA,ANAA,CEIC,COJC,AGCA,CEMC,AhBPA,AoBEA,AXFA,ANAA,AkBIA,AfJA,ADAA,EKAE,AOAA,CJAC,AMAA,EZQE,GNRG,+SOyC5C,EAAA,EAAA,CAAA,CAAA,yFO5ByClhB,GAAAA,WAAAA,OAkEW,iBAYGyzD,EAAAA,iBAAiC,SVrDpE,CACY,GJDV,CACc,Oc0DkD,iBAavCzzD,EAAAA,QAAiB,EIjDzB,iKIhD2B,OAG5C6pB,GAAAA,AAAiBlnB,UACxByyD,EAAYzyD,EAAAA,KAAAA,kBACDA,CViBA,AClBC,CAAA,SSCa,CAAA,EAAA,CAAI,G1BOG,GGNqD,CuBhBjE+oC,GGe+B1rC,CFTnC,ALHA,AIH4C,CRI3C,AUKX,AjBOA,CFlBuB,AHYtB,AiBVsB,CNQrB,AfAA,CGKC,AIHA,AeRsB,ARJA,CfQC,ADStB,AuBJA,AJJsB,GON9CogC,CCK2D,EFPxD,GHIoD,EPCE,KGAK,kHjB4IyB,gCAo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9C,EAAA,iBAWmB,QAMwDA,EAAAA,WAAAA,CAM3E,GAAA,EAAA,iBAWmB,AAQmDA,CLbhD,CYxGD,CAAA,cPqHoE,kBAqC5FA,CC+EsB,CAAA,aAAA,CDtEnB,IAAA,GAAA,EAAA,aAA+E,iBAyDlFA,EAAAA,WAAgB,CCgH8C,eD5D9DA,ECgHkC,CM/RN,AN+RM,gBDhHZ,CAMnB,IAAA,GAAA,EAAA,SAgBW,CAMLhU,CLAK91B,EAAAA,EAAAA,eAAAA,CK8BLo0B,CLPK,ELxLF,EAAA,WU+LiD,CIzQzB,Ad0EA,GUiMd0V,EVhMR,CiBbD,CP6Ma,AVhMZ,MAAA,CUkNL9iC,GAiBT8iC,EAAAA,OAAY,AA0BZA,EL0BqB,AI3UA,CCiTjB,CAAA,UAAA,CASD,IAAMzQ,GAAAA,EAAAA,YAiBQ,AA0BjByQ,GAAAA,UAAe,CASZ,EAAA,cAiBgB,kBA0BC,CASjB,CRtUoF,GAAA,GQoWvFA,EAAK3E,EAAD,CAACA,QAAAA,8WiBnsB0B,CbRC,AHAA,AJIA,AFHA,CqBCiB,AbFhB,CIEC,CXDC,AFDA,AIAA,ALAA,CDAC,AFAA,CYAC,AQAA,eOcd,CLPC,ATJA,EMQE,AKJA,EtBJE,CqBGC,CTJC,APIkB,AIFlB,CiBFC,CrBImBvnC,AIFlBJ,CLDC,AFDA,AuBYS,AnBZT,CgBKC,CFAC,CnBLC,AHGA,AoBHA,ATEA,AMCA,AZFA,CIGC,AkBchB,CddC,ANAkC,MLHZ,ASCA,AEDA,CgBDC,CtBImB,KiBCb,SbHS,CQOC,EQ4CjCuuB,CpBjDsD,GoBiDT,MACrEulC,C3BpCCh0D,AgBUS,AClBTS,WU8CR,QAQmB,GRJkC,CjB9Cd,AiB8Ceg0D,gBQOtD,IAGsBpgC,GAAwD,oBAG9E,IAGuBgK,CAAA,AJxCR,GAAA,CAAA,UI0Cf,IXvE+Bz9B,CFFc,MEEPC,GAAAA,CAHX,AAGeiyD,CKAd,AJHA,AZO4B,CGR3B,AJAA,AeOA,CGJC,AjBK4B5yD,GEFK,CAAW,AFEZ,QAAQ,IWJT,CAAC,WXIwB,MWgBrB,sBAE/C,CMXK,AbDA,CJDC,AMGA,EAAA,GAAA,KKWnBk0D,CAAAA,CAAAA,CAAAA,CAAAA,CACF,CPZC,A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","ignoreList":[2,3,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,54,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,98,99,100,101,102,103,104,105,106,107,108,109,110,113,114,115,116,117,118,119,120,121,122,123,124]}