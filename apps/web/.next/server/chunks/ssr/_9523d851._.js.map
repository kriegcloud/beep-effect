{"version":3,"sources":["turbopack:///[project]/node_modules/detect-libc/lib/process.js","turbopack:///[project]/node_modules/detect-libc/lib/filesystem.js","turbopack:///[project]/node_modules/detect-libc/lib/elf.js","turbopack:///[project]/node_modules/detect-libc/lib/detect-libc.js","turbopack:///[project]/node_modules/node-gyp-build-optional-packages/node-gyp-build.js","turbopack:///[project]/node_modules/node-gyp-build-optional-packages/index.js","turbopack:///[project]/node_modules/msgpackr-extract/index.js","turbopack:///[project]/packages/runtime/client/src/worker/worker-client.ts","turbopack:///[project]/node_modules/msgpackr/unpack.js","turbopack:///[project]/node_modules/msgpackr/stream.js","turbopack:///[project]/node_modules/msgpackr/pack.js","turbopack:///[project]/node_modules/@effect/platform/src/internal/httpClientError.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcGroup.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/httpBody.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/httpClientRequest.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcSchema.ts","turbopack:///[project]/node_modules/@effect/platform/src/WorkerError.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/worker.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/httpClient.ts","turbopack:///[project]/node_modules/@effect/platform/src/HttpBody.ts","turbopack:///[project]/node_modules/@effect/platform-browser/src/internal/worker.ts","turbopack:///[project]/node_modules/effect/src/internal/pool.ts","turbopack:///[project]/node_modules/@effect/rpc/src/Rpc.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/httpClientResponse.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/workerError.ts","turbopack:///[project]/node_modules/@effect/rpc/src/internal/utils.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcClient.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcWorker.ts","turbopack:///[project]/packages/runtime/client/src/worker/worker-rpc.ts","turbopack:///[project]/node_modules/msgpackr/node-index.js","turbopack:///[project]/node_modules/@effect/platform/src/HttpClient.ts","turbopack:///[project]/node_modules/effect/src/Pool.ts","turbopack:///[project]/node_modules/@effect/platform/src/Headers.ts","turbopack:///[project]/node_modules/@effect/platform/src/Cookies.ts","turbopack:///[project]/node_modules/@effect/platform/src/HttpClientRequest.ts","turbopack:///[project]/node_modules/@effect/platform/src/Worker.ts","turbopack:///[project]/node_modules/@effect/platform-browser/src/BrowserWorker.ts","turbopack:///[project]/node_modules/effect/src/FiberSet.ts","turbopack:///[project]/node_modules/@effect/platform/src/Transferable.ts","turbopack:///[project]/node_modules/@effect/platform/src/HttpIncomingMessage.ts","turbopack:///[project]/node_modules/@effect/platform/src/UrlParams.ts","turbopack:///[project]/node_modules/@effect/platform/src/HttpTraceContext.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcMessage.ts","turbopack:///[project]/node_modules/@effect/platform/src/HttpClientError.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcSerialization.ts","turbopack:///[project]/node_modules/@effect/platform/src/Socket.ts","turbopack:///[project]/node_modules/@effect/rpc/src/RpcClientError.ts","turbopack:///[project]/node_modules/msgpackr/iterators.js","turbopack:///[project]/node_modules/msgpackr/struct.js","turbopack:///[project]/node_modules/@protobufjs/aspromise/index.js","turbopack:///[project]/node_modules/@protobufjs/base64/index.js","turbopack:///[project]/node_modules/@protobufjs/eventemitter/index.js","turbopack:///[project]/node_modules/@protobufjs/float/index.js","turbopack:///[project]/node_modules/@protobufjs/inquire/index.js","turbopack:///[project]/node_modules/@protobufjs/utf8/index.js","turbopack:///[project]/node_modules/@protobufjs/pool/index.js","turbopack:///[project]/node_modules/protobufjs/src/util/longbits.js","turbopack:///[project]/node_modules/protobufjs/src/util/minimal.js","turbopack:///[project]/node_modules/protobufjs/src/writer.js","turbopack:///[project]/node_modules/protobufjs/src/writer_buffer.js","turbopack:///[project]/node_modules/protobufjs/src/reader.js","turbopack:///[project]/node_modules/protobufjs/src/reader_buffer.js","turbopack:///[project]/node_modules/protobufjs/src/rpc/service.js","turbopack:///[project]/node_modules/protobufjs/src/rpc.js","turbopack:///[project]/node_modules/protobufjs/src/roots.js","turbopack:///[project]/node_modules/protobufjs/src/index-minimal.js","turbopack:///[project]/node_modules/protobufjs/minimal.js","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/generated/root.js","turbopack:///[project]/node_modules/effect/src/SubscriptionRef.ts","turbopack:///[project]/node_modules/effect/src/Subscribable.ts","turbopack:///[project]/node_modules/effect/src/internal/subscriptionRef.ts","turbopack:///[project]/node_modules/effect/src/SynchronizedRef.ts","turbopack:///[project]/packages/runtime/client/src/services/runtime/live-layer.ts","turbopack:///[project]/packages/runtime/client/src/services/common/network-monitor.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/common/internal.ts","turbopack:///[project]/node_modules/effect/src/internal/logger-circular.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/internal/metrics.ts","turbopack:///[project]/node_modules/@effect/platform/src/internal/fetchHttpClient.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/metrics/internal.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/internal/tracer.ts","turbopack:///[project]/node_modules/effect/src/MetricKeyType.ts","turbopack:///[project]/node_modules/effect/src/MetricState.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/Metrics.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/Tracer.ts","turbopack:///[project]/node_modules/@effect/platform-browser/src/BrowserKeyValueStore.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/Resource.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/convert-legacy-node-http-options.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/transport/http-transport-utils.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/internal/utils.ts","turbopack:///[project]/node_modules/effect/src/Logger.ts","turbopack:///[project]/node_modules/@effect/platform-browser/src/internal/keyValueStore.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/WebSdk.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/trace/json/trace.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/trace/internal.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/status.ts","turbopack:///[project]/node_modules/@effect/platform/src/FetchHttpClient.ts","turbopack:///[project]/node_modules/@effect/opentelemetry/src/Logger.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/metrics/internal-types.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/logs/json/logs.ts","turbopack:///[project]/node_modules/@opentelemetry/semantic-conventions/src/stable_attributes.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/otlp-http-configuration.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/otlp-node-http-configuration.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/view/AggregationOption.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/is-export-retryable.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/common/attributes.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/trace/suppress-tracing.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/logs/internal.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/metrics/protobuf/metrics.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/internal/validators.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/internal/tracestate-validators.ts","turbopack:///[project]/node_modules/@opentelemetry/resources/src/ResourceImpl.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/export/MetricReader.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/baggage/propagation/W3CBaggagePropagator.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/Span.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/common/time.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-web/src/WebTracerProvider.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/trace/W3CTraceContextPropagator.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/baggage/utils.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/common/utils.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/internal/global-utils.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/shared-configuration.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/metrics/Metric.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts","turbopack:///[project]/node_modules/@opentelemetry/exporter-metrics-otlp-proto/node_modules/@opentelemetry/exporter-metrics-otlp-http/src/OTLPMetricExporterOptions.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/sampler/AlwaysOffSampler.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/getMapping.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/baggage/context-helpers.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/index.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/otlp-node-http-env-configuration.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/internal/exporter.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts","turbopack:///[project]/node_modules/@opentelemetry/exporter-metrics-otlp-proto/node_modules/@opentelemetry/exporter-metrics-otlp-http/src/OTLPMetricExporterBase.ts","turbopack:///[project]/node_modules/@opentelemetry/exporter-metrics-otlp-proto/src/platform/node/OTLPMetricExporter.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/ExponentialHistogram.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/export/AggregationTemporality.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/utils/timeout.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/util.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/common/logging-error-handler.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Sum.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/LastValue.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/propagation/NoopTextMapPropagator.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/export/AggregationSelector.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/config.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/types.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/LogRecordImpl.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/view/Aggregation.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/transport/http-exporter-transport.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/shared-env-configuration.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/utils/lodash.merge.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/export/PeriodicExportingMetricReader.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/retrying-transport.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/internal/LoggerProviderSharedState.ts","turbopack:///[project]/node_modules/@opentelemetry/exporter-trace-otlp-http/src/platform/node/OTLPTraceExporter.ts","turbopack:///[project]/node_modules/@opentelemetry/exporter-logs-otlp-http/src/platform/node/OTLPLogExporter.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/baggage/constants.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/Logger.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/config.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/logging-response-handler.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/utils/merge.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/utils.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/BasicTracerProvider.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/otlp-export-delegate.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/export/MetricData.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/propagation/composite.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/semconv.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/utility.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Drop.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ieee754.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/platform/node/RandomIdGenerator.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/MultiLogRecordProcessor.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/LoggerProvider.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-exporter-base/src/bounded-queue-export-promise-handler.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/util.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts","turbopack:///[project]/node_modules/@opentelemetry/otlp-transformer/src/common/hex-to-binary.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/context-utils.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/internal/semver.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/platform/node/environment.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/sampler/ParentBasedSampler.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/baggage/utils.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/common/global-error-handler.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/trace/TraceState.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/Tracer.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/context/context.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/internal/tracestate-impl.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/Sampler.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/SamplingResult.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/api/propagation.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-trace-web/src/StackContextManager.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/Buckets.ts","turbopack:///[project]/node_modules/@opentelemetry/core/src/utils/callback.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/Histogram.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/trace/span_kind.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/api/context.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ExponentMapping.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/LogarithmMapping.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/baggage/internal/baggage-impl.ts","turbopack:///[project]/node_modules/@opentelemetry/sdk-logs/src/export/BatchLogRecordProcessorBase.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/api/trace.ts","turbopack:///[project]/node_modules/@opentelemetry/api/src/api/diag.ts","turbopack:///[project]/packages/runtime/client/src/services/runtime/runtime-context.tsx","turbopack:///[project]/packages/runtime/client/src/beep-provider.tsx","turbopack:///[project]/packages/runtime/client/src/services/runtime/runtime-provider.tsx","turbopack:///[project]/node_modules/effect/src/internal/managedRuntime.ts","turbopack:///[project]/node_modules/nuqs/src/lib/debug.ts","turbopack:///[project]/node_modules/nuqs/src/lib/queues/reset.ts","turbopack:///[project]/node_modules/nuqs/src/adapters/lib/patch-history.ts","turbopack:///[project]/node_modules/nuqs/src/lib/queues/rate-limiting.ts","turbopack:///[project]/node_modules/effect/src/ManagedRuntime.ts","turbopack:///[project]/node_modules/nuqs/src/adapters/next/impl.app.ts","turbopack:///[project]/node_modules/nuqs/src/adapters/next/app.ts","turbopack:///[project]/node_modules/nuqs/src/lib/search-params.ts","turbopack:///[project]/node_modules/nuqs/src/lib/errors.ts","turbopack:///[project]/node_modules/nuqs/src/lib/emitter.ts","turbopack:///[project]/node_modules/nuqs/src/lib/url-encoding.ts","turbopack:///[project]/node_modules/nuqs/src/lib/timeout.ts","turbopack:///[project]/node_modules/nuqs/src/adapters/lib/context.ts","turbopack:///[project]/node_modules/nuqs/src/lib/with-resolvers.ts","turbopack:///[project]/node_modules/nuqs/src/lib/compose.ts","turbopack:///[project]/node_modules/nuqs/src/lib/queues/throttle.ts","turbopack:///[project]/node_modules/nuqs/src/lib/queues/useSyncExternalStores.ts","turbopack:///[project]/node_modules/nuqs/src/lib/queues/debounce.ts","turbopack:///[project]/node_modules/scheduler/cjs/scheduler.production.js","turbopack:///[project]/node_modules/scheduler/index.js","turbopack:///[project]/node_modules/@effect-atom/atom/src/internal/registry.ts","turbopack:///[project]/node_modules/@effect-atom/atom/src/Result.ts","turbopack:///[project]/node_modules/@effect-atom/atom/src/Registry.ts","turbopack:///[project]/node_modules/@effect-atom/atom-react/src/RegistryContext.ts","turbopack:///[project]/node_modules/@effect-atom/atom/src/Atom.ts","turbopack:///[project]/node_modules/@effect-atom/atom-react/src/Hooks.ts","turbopack:///[project]/node_modules/@effect-atom/atom/src/internal/runtime.ts","turbopack:///[project]/packages/runtime/client/src/services/runtime/make-atom-runtime.ts","turbopack:///[project]/packages/runtime/client/src/services/runtime/ka-services.ts","turbopack:///[project]/packages/runtime/client/src/services/runtime/use-runtime.tsx","turbopack:///[project]/packages/runtime/client/src/index.ts"],"sourcesContent":["// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst isLinux = () => process.platform === 'linux';\n\nlet report = null;\nconst getReport = () => {\n  if (!report) {\n    /* istanbul ignore next */\n    if (isLinux() && process.report) {\n      const orig = process.report.excludeNetwork;\n      process.report.excludeNetwork = true;\n      report = process.report.getReport();\n      process.report.excludeNetwork = orig;\n    } else {\n      report = {};\n    }\n  }\n  return report;\n};\n\nmodule.exports = { isLinux, getReport };\n","// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst fs = require('fs');\n\nconst LDD_PATH = '/usr/bin/ldd';\nconst SELF_PATH = '/proc/self/exe';\nconst MAX_LENGTH = 2048;\n\n/**\n * Read the content of a file synchronous\n *\n * @param {string} path\n * @returns {Buffer}\n */\nconst readFileSync = (path) => {\n  const fd = fs.openSync(path, 'r');\n  const buffer = Buffer.alloc(MAX_LENGTH);\n  const bytesRead = fs.readSync(fd, buffer, 0, MAX_LENGTH, 0);\n  fs.close(fd, () => {});\n  return buffer.subarray(0, bytesRead);\n};\n\n/**\n * Read the content of a file\n *\n * @param {string} path\n * @returns {Promise<Buffer>}\n */\nconst readFile = (path) => new Promise((resolve, reject) => {\n  fs.open(path, 'r', (err, fd) => {\n    if (err) {\n      reject(err);\n    } else {\n      const buffer = Buffer.alloc(MAX_LENGTH);\n      fs.read(fd, buffer, 0, MAX_LENGTH, 0, (_, bytesRead) => {\n        resolve(buffer.subarray(0, bytesRead));\n        fs.close(fd, () => {});\n      });\n    }\n  });\n});\n\nmodule.exports = {\n  LDD_PATH,\n  SELF_PATH,\n  readFileSync,\n  readFile\n};\n","// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst interpreterPath = (elf) => {\n  if (elf.length < 64) {\n    return null;\n  }\n  if (elf.readUInt32BE(0) !== 0x7F454C46) {\n    // Unexpected magic bytes\n    return null;\n  }\n  if (elf.readUInt8(4) !== 2) {\n    // Not a 64-bit ELF\n    return null;\n  }\n  if (elf.readUInt8(5) !== 1) {\n    // Not little-endian\n    return null;\n  }\n  const offset = elf.readUInt32LE(32);\n  const size = elf.readUInt16LE(54);\n  const count = elf.readUInt16LE(56);\n  for (let i = 0; i < count; i++) {\n    const headerOffset = offset + (i * size);\n    const type = elf.readUInt32LE(headerOffset);\n    if (type === 3) {\n      const fileOffset = elf.readUInt32LE(headerOffset + 8);\n      const fileSize = elf.readUInt32LE(headerOffset + 32);\n      return elf.subarray(fileOffset, fileOffset + fileSize).toString().replace(/\\0.*$/g, '');\n    }\n  }\n  return null;\n};\n\nmodule.exports = {\n  interpreterPath\n};\n","// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst childProcess = require('child_process');\nconst { isLinux, getReport } = require('./process');\nconst { LDD_PATH, SELF_PATH, readFile, readFileSync } = require('./filesystem');\nconst { interpreterPath } = require('./elf');\n\nlet cachedFamilyInterpreter;\nlet cachedFamilyFilesystem;\nlet cachedVersionFilesystem;\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise((resolve) => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, { encoding: 'utf8' });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A Regexp constant to get the GLIBC Version.\n * @type {string}\n */\nconst RE_GLIBC_VERSION = /LIBC[a-z0-9 \\-).]*?(\\d+\\.\\d+)/i;\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\nconst isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\n\nconst familyFromCommand = (out) => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\n\nconst familyFromInterpreterPath = (path) => {\n  if (path) {\n    if (path.includes('/ld-musl-')) {\n      return MUSL;\n    } else if (path.includes('/ld-linux-')) {\n      return GLIBC;\n    }\n  }\n  return null;\n};\n\nconst getFamilyFromLddContent = (content) => {\n  content = content.toString();\n  if (content.includes('musl')) {\n    return MUSL;\n  }\n  if (content.includes('GNU C Library')) {\n    return GLIBC;\n  }\n  return null;\n};\n\nconst familyFromFilesystem = async () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\nconst familyFromFilesystemSync = () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\nconst familyFromInterpreter = async () => {\n  if (cachedFamilyInterpreter !== undefined) {\n    return cachedFamilyInterpreter;\n  }\n  cachedFamilyInterpreter = null;\n  try {\n    const selfContent = await readFile(SELF_PATH);\n    const path = interpreterPath(selfContent);\n    cachedFamilyInterpreter = familyFromInterpreterPath(path);\n  } catch (e) {}\n  return cachedFamilyInterpreter;\n};\n\nconst familyFromInterpreterSync = () => {\n  if (cachedFamilyInterpreter !== undefined) {\n    return cachedFamilyInterpreter;\n  }\n  cachedFamilyInterpreter = null;\n  try {\n    const selfContent = readFileSync(SELF_PATH);\n    const path = interpreterPath(selfContent);\n    cachedFamilyInterpreter = familyFromInterpreterPath(path);\n  } catch (e) {}\n  return cachedFamilyInterpreter;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = async () => {\n  let family = null;\n  if (isLinux()) {\n    family = await familyFromInterpreter();\n    if (!family) {\n      family = await familyFromFilesystem();\n      if (!family) {\n        family = familyFromReport();\n      }\n      if (!family) {\n        const out = await safeCommand();\n        family = familyFromCommand(out);\n      }\n    }\n  }\n  return family;\n};\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromInterpreterSync();\n    if (!family) {\n      family = familyFromFilesystemSync();\n      if (!family) {\n        family = familyFromReport();\n      }\n      if (!family) {\n        const out = safeCommandSync();\n        family = familyFromCommand(out);\n      }\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromFilesystem = async () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromFilesystemSync = () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\n\nconst versionSuffix = (s) => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = (out) => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = async () => {\n  let version = null;\n  if (isLinux()) {\n    version = await versionFromFilesystem();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = await safeCommand();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromFilesystemSync();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};\n","var fs = require('fs')\nvar path = require('path')\nvar url = require('url')\nvar os = require('os')\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar versions = process.versions\nvar abi = versions.modules\nif (versions.deno || process.isBun) {\n  // both Deno and Bun made the very poor decision to shoot themselves in the foot and lie about support for ABI\n  // (which they do not have)\n  abi = 'unsupported'\n}\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isMusl(platform) ? 'musl' : 'glibc')\n\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.resolve(dir))\n}\n\nload.resolve = load.path = function (dir) {\n  dir = path.resolve(dir || '.')\n  var packageName = ''\n  var packageNameError\n  try {\n    packageName = runtimeRequire(path.join(dir, 'package.json')).name;\n    var varName = packageName.toUpperCase().replace(/-/g, '_')\n    if (process.env[varName + '_PREBUILD']) dir = process.env[varName + '_PREBUILD']\n  } catch (err) {\n    packageNameError = err;\n  }\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var platformPackage = (packageName[0] == '@' ? '' : '@' + packageName + '/') + packageName + '-' + platform + '-' + arch\n  var packageResolutionError\n  try {\n    var prebuildPackage = path.dirname(require('module').createRequire(url.pathToFileURL(path.join(dir, 'package.json'))).resolve(platformPackage))\n    return resolveFile(prebuildPackage)\n  } catch(error) {\n    packageResolutionError = error\n  }\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n  let errMessage = 'No native build was found for ' + target + '\\n    attempted loading from: ' + dir + ' and package:' +\n    ' ' + platformPackage + '\\n';\n  if (packageNameError) {\n    errMessage += 'Error finding package.json: ' + packageNameError.message + '\\n';\n  }\n  if (packageResolutionError) {\n    errMessage += 'Error resolving package: ' + packageResolutionError.message + '\\n';\n  }\n  throw new Error(errMessage)\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n    return resolveFile(path.join(dir, 'prebuilds', tuple.name))\n  }\n  function resolveFile (prebuilds) {\n    // Find most specific flavor first\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isMusl (platform) {\n  if (platform !== 'linux') return false;\n  const { familySync, MUSL } = require('detect-libc');\n  return familySync() === MUSL;\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n\n","const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\nif (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that\n  module.exports = runtimeRequire.addon.bind(runtimeRequire)\n} else { // else use the runtime version here\n  module.exports = require('./node-gyp-build.js')\n}\n","module.exports = require('node-gyp-build-optional-packages')(__dirname);","\"use client\";\nimport * as BrowserWorker from \"@effect/platform-browser/BrowserWorker\";\nimport * as RpcClient from \"@effect/rpc/RpcClient\";\nimport * as Effect from \"effect/Effect\";\nimport * as Layer from \"effect/Layer\";\nimport { WorkerRpc } from \"./worker-rpc\";\n\nconst RpcProtocol = RpcClient.layerProtocolWorker({\n  size: 1,\n  concurrency: 1,\n}).pipe(\n  Layer.provide(\n    BrowserWorker.layerPlatform(\n      () =>\n        new Worker(new URL(\"./worker.ts?worker\", import.meta.url), {\n          type: \"module\",\n        })\n    )\n  ),\n  Layer.orDie\n);\n\nexport class WorkerClient extends Effect.Service<WorkerClient>()(\"@beep/runtime-client/WorkerClient\", {\n  dependencies: [RpcProtocol],\n  scoped: Effect.gen(function* () {\n    return {\n      client: yield* RpcClient.make(WorkerRpc),\n    };\n  }),\n}) {}\n","var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n\t\treturn property.flat().toString();\n\t}\n\tthrow new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = data => {\n\tlet headLength = (data.byteLength % 8) || 8\n\tlet head = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0])\n\tfor (let i = 1; i < headLength; i++) {\n\t\thead <<= BigInt(8)\n\t\thead += BigInt(data[i])\n\t}\n\tif (data.byteLength !== headLength) {\n\t\tlet view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\t\tlet decode = (start, end) => {\n\t\t\tlet length = end - start\n\t\t\tif (length <= 40) {\n\t\t\t\tlet out = view.getBigUint64(start)\n\t\t\t\tfor (let i = start + 8; i < end; i += 8) {\n\t\t\t\t\tout <<= BigInt(64n)\n\t\t\t\t\tout |= view.getBigUint64(i)\n\t\t\t\t}\n\t\t\t\treturn out\n\t\t\t}\n\t\t\t// if (length === 8) return view.getBigUint64(start)\n\t\t\tlet middle = start + (length >> 4 << 3)\n\t\t\tlet left = decode(start, middle)\n\t\t\tlet right = decode(middle, end)\n\t\t\treturn (left << BigInt((end - middle) * 8)) | right\n\t\t}\n\t\thead = (head << BigInt((view.byteLength - headLength) * 8)) | decode(headLength, view.byteLength)\n\t}\n\treturn head\n}\n\nlet errors = {\n\tError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError: typeof AggregateError === 'function' ? AggregateError : null,\n}\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\tif (!errors[data[0]]) {\n\t\tlet error = Error(data[1], { cause: data[2] })\n\t\terror.name = data[0]\n\t\treturn error\n\t}\n\treturn errors[data[0]](data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf)\n\t\ttarget = new Map()\n\telse if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position + 1] === 0x73)\n\t\ttarget = new Set()\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (!refEntry.used) {\n\t\t// no cycle, can just use the returned read object\n\t\treturn refEntry.target = targetProperties // replace the placeholder with the real one\n\t} else {\n\t\t// there is a cycle, so we have to assign properties to original target\n\t\tObject.assign(target, targetProperties)\n\t}\n\n\t// copy over map/set entries if we're able to\n\tif (target instanceof Map)\n\t\tfor (let [k, v] of targetProperties.entries()) target.set(k, v)\n\tif (target instanceof Set)\n\t\tfor (let i of Array.from(targetProperties)) target.add(i)\n\treturn target\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\t// we always have to slice to get a new ArrayBuffer that is aligned\n\tlet buffer = Uint8Array.prototype.slice.call(data, 1).buffer\n\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) return buffer\n\t\tif (typeCode === 17) return new DataView(buffer)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\treturn new glbl[typedArrayName](buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Transform } from 'stream'\nimport { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\nvar DEFAULT_OPTIONS = {objectMode: true}\n\nexport class PackrStream extends Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.writableObjectMode = true\n\t\tsuper(options)\n\t\toptions.sequential = true\n\t\tthis.packr = options.packr || new Packr(options)\n\t}\n\t_transform(value, encoding, callback) {\n\t\tthis.push(this.packr.pack(value))\n\t\tcallback()\n\t}\n}\n\nexport class UnpackrStream extends Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {}\n\t\toptions.objectMode = true\n\t\tsuper(options)\n\t\toptions.structures = []\n\t\tthis.unpackr = options.unpackr || new Unpackr(options)\n\t}\n\t_transform(chunk, encoding, callback) {\n\t\tif (this.incompleteBuffer) {\n\t\t\tchunk = Buffer.concat([this.incompleteBuffer, chunk])\n\t\t\tthis.incompleteBuffer = null\n\t\t}\n\t\tlet values\n\t\ttry {\n\t\t\tvalues = this.unpackr.unpackMultiple(chunk)\n\t\t} catch(error) {\n\t\t\tif (error.incomplete) {\n\t\t\t\tthis.incompleteBuffer = chunk.slice(error.lastPosition)\n\t\t\t\tvalues = error.values\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow error\n\t\t} finally {\n\t\t\tfor (let value of values || []) {\n\t\t\t\tif (value === null)\n\t\t\t\t\tvalue = this.getNullValue()\n\t\t\t\tthis.push(value)\n\t\t\t}\n\t\t}\n\t\tif (callback) callback()\n\t}\n\tgetNullValue() {\n\t\treturn Symbol.for(null)\n\t}\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < 0x10000000000000000 && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if (this.useBigIntExtension || this.moreTypes) {\n\t\t\t\t\t\tlet empty = value < 0 ? BigInt(-1) : BigInt(0)\n\n\t\t\t\t\t\tlet array\n\t\t\t\t\t\tif (value >> BigInt(0x10000) === empty) {\n\t\t\t\t\t\t\tlet mask = BigInt(0x10000000000000000) - BigInt(1) // literal would overflow\n\t\t\t\t\t\t\tlet chunks = []\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tchunks.push(value & mask)\n\t\t\t\t\t\t\t\tif ((value >> BigInt(63)) === empty) break\n\t\t\t\t\t\t\t\tvalue >>= BigInt(64)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray = new Uint8Array(new BigUint64Array(chunks).buffer)\n\t\t\t\t\t\t\tarray.reverse()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet invert = value < 0\n\t\t\t\t\t\t\tlet string = (invert ? ~value : value).toString(16)\n\t\t\t\t\t\t\tif (string.length % 2) {\n\t\t\t\t\t\t\t\tstring = '0' + string\n\t\t\t\t\t\t\t} else if (parseInt(string.charAt(0), 16) >= 8) {\n\t\t\t\t\t\t\t\tstring = '00' + string\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hasNodeBuffer) {\n\t\t\t\t\t\t\t\tarray = Buffer.from(string, 'hex')\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tarray = new Uint8Array(string.length / 2)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\t\t\t\tarray[i] = parseInt(string.slice(i * 2, i * 2 + 2), 16)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (invert) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = ~array[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (array.length + position > safeEnd)\n\t\t\t\t\t\t\tmakeRoom(array.length + position)\n\t\t\t\t\t\tposition = writeExtensionData(array, target, position, 0x42)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\ttargetView = target.dataView;\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, DataView, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x11, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048\n","import type * as Error from \"../HttpClientError.js\"\n\n/** @internal */\nexport const TypeId: Error.TypeId = Symbol.for(\n  \"@effect/platform/HttpClientError\"\n) as Error.TypeId\n","/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { identity } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport type { ReadonlyMailbox } from \"effect/Mailbox\"\nimport { type Pipeable } from \"effect/Pipeable\"\nimport type * as Record from \"effect/Record\"\nimport * as Schema from \"effect/Schema\"\nimport type { Scope } from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Rpc from \"./Rpc.js\"\nimport type * as RpcMiddleware from \"./RpcMiddleware.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcGroup\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport interface RpcGroup<in out R extends Rpc.Any> extends Pipeable {\n  new(_: never): {}\n\n  readonly [TypeId]: TypeId\n  readonly requests: ReadonlyMap<string, R>\n  readonly annotations: Context.Context<never>\n\n  /**\n   * Add one or more procedures to the group.\n   */\n  add<const Rpcs2 extends ReadonlyArray<Rpc.Any>>(\n    ...rpcs: Rpcs2\n  ): RpcGroup<R | Rpcs2[number]>\n\n  /**\n   * Merge this group with one or more other groups.\n   */\n  merge<const Groups extends ReadonlyArray<Any>>(\n    ...groups: Groups\n  ): RpcGroup<R | Rpcs<Groups[number]>>\n\n  /**\n   * Add middleware to all the procedures added to the group until this point.\n   */\n  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): RpcGroup<Rpc.AddMiddleware<R, M>>\n\n  /**\n   * Add a prefix to the procedures in this group, returning a new group\n   */\n  prefix<const Prefix extends string>(prefix: Prefix): RpcGroup<Rpc.Prefixed<R, Prefix>>\n\n  /**\n   * Implement the handlers for the procedures in this group, returning a\n   * context object.\n   */\n  toHandlersContext<\n    Handlers extends HandlersFrom<R>,\n    EX = never,\n    RX = never\n  >(\n    build:\n      | Handlers\n      | Effect.Effect<Handlers, EX, RX>\n  ): Effect.Effect<\n    Context.Context<Rpc.ToHandler<R>>,\n    EX,\n    | RX\n    | HandlersContext<R, Handlers>\n  >\n\n  /**\n   * Implement the handlers for the procedures in this group.\n   */\n  toLayer<\n    Handlers extends HandlersFrom<R>,\n    EX = never,\n    RX = never\n  >(\n    build:\n      | Handlers\n      | Effect.Effect<Handlers, EX, RX>\n  ): Layer.Layer<\n    Rpc.ToHandler<R>,\n    EX,\n    | Exclude<RX, Scope>\n    | HandlersContext<R, Handlers>\n  >\n\n  of<const Handlers extends HandlersFrom<R>>(handlers: Handlers): Handlers\n\n  /**\n   * Implement a single handler from the group.\n   */\n  toLayerHandler<\n    const Tag extends R[\"_tag\"],\n    Handler extends HandlerFrom<R, Tag>,\n    EX = never,\n    RX = never\n  >(\n    tag: Tag,\n    build:\n      | Handler\n      | Effect.Effect<Handler, EX, RX>\n  ): Layer.Layer<\n    Rpc.Handler<Tag>,\n    EX,\n    | Exclude<RX, Scope>\n    | HandlerContext<R, Tag, Handler>\n  >\n\n  /**\n   * Retrieve a handler for a specific procedure in the group.\n   */\n  accessHandler<const Tag extends R[\"_tag\"]>(tag: Tag): Effect.Effect<\n    (\n      payload: Rpc.Payload<Extract<R, { readonly _tag: Tag }>>,\n      headers: Headers\n    ) => Rpc.ResultFrom<Extract<R, { readonly _tag: Tag }>, never>,\n    never,\n    Rpc.Handler<Tag>\n  >\n\n  /**\n   * Annotate the group with a value.\n   */\n  annotate<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<R>\n\n  /**\n   * Annotate the Rpc's above this point with a value.\n   */\n  annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<R>\n\n  /**\n   * Annotate the group with a context object.\n   */\n  annotateContext<S>(context: Context.Context<S>): RpcGroup<R>\n\n  /**\n   * Annotate the Rpc's above this point with a context object.\n   */\n  annotateRpcsContext<S>(context: Context.Context<S>): RpcGroup<R>\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport interface Any {\n  readonly [TypeId]: TypeId\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlersFrom<Rpc extends Rpc.Any> = {\n  readonly [Current in Rpc as Current[\"_tag\"]]: Rpc.ToHandlerFn<Current>\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlerFrom<Rpc extends Rpc.Any, Tag extends Rpc[\"_tag\"]> = Extract<Rpc, { readonly _tag: Tag }> extends\n  infer Current ? Current extends Rpc.Any ? Rpc.ToHandlerFn<Current> : never : never\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlersContext<Rpcs extends Rpc.Any, Handlers> = keyof Handlers extends infer K ?\n  K extends keyof Handlers & string ? HandlerContext<Rpcs, K, Handlers[K]> : never :\n  never\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlerContext<Rpcs extends Rpc.Any, K extends Rpcs[\"_tag\"], Handler> = [Rpc.IsStream<Rpcs, K>] extends\n  [true] ? Handler extends (...args: any) =>\n    | Stream.Stream<infer _A, infer _E, infer _R>\n    | Rpc.Wrapper<Stream.Stream<infer _A, infer _E, infer _R>>\n    | Effect.Effect<\n      ReadonlyMailbox<infer _A, infer _E>,\n      infer _EX,\n      infer _R\n    >\n    | Rpc.Wrapper<\n      Effect.Effect<\n        ReadonlyMailbox<infer _A, infer _E>,\n        infer _EX,\n        infer _R\n      >\n    > ? Exclude<Rpc.ExcludeProvides<_R, Rpcs, K>, Scope> :\n  never :\n  Handler extends (\n    ...args: any\n  ) => Effect.Effect<infer _A, infer _E, infer _R> | Rpc.Wrapper<Effect.Effect<infer _A, infer _E, infer _R>> ?\n    Rpc.ExcludeProvides<_R, Rpcs, K>\n  : never\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type Rpcs<Group> = Group extends RpcGroup<infer R> ? string extends R[\"_tag\"] ? never : R : never\n\nconst RpcGroupProto = {\n  add(this: RpcGroup<any>, ...rpcs: Array<any>) {\n    return makeProto({\n      requests: resolveInput(\n        ...this.requests.values(),\n        ...rpcs\n      ),\n      annotations: this.annotations\n    })\n  },\n  merge(this: RpcGroup<any>, ...groups: ReadonlyArray<RpcGroup<any>>) {\n    const requests = new Map(this.requests)\n    const annotations = new Map(this.annotations.unsafeMap)\n\n    for (const group of groups) {\n      for (const [tag, rpc] of group.requests) {\n        requests.set(tag, rpc)\n      }\n      for (const [key, value] of group.annotations.unsafeMap) {\n        annotations.set(key, value)\n      }\n    }\n\n    return makeProto({\n      requests,\n      annotations: Context.unsafeMake(annotations)\n    })\n  },\n  middleware(this: RpcGroup<any>, middleware: RpcMiddleware.TagClassAny) {\n    const requests = new Map<string, any>()\n    for (const [tag, rpc] of this.requests) {\n      requests.set(tag, rpc.middleware(middleware))\n    }\n    return makeProto({\n      requests,\n      annotations: this.annotations\n    })\n  },\n  toHandlersContext(this: RpcGroup<any>, build: Effect.Effect<Record<string, (request: any) => any>>) {\n    return Effect.gen(this, function*() {\n      const context = yield* Effect.context<never>()\n      const handlers = Effect.isEffect(build) ? yield* build : build\n      const contextMap = new Map<string, unknown>()\n      for (const [tag, handler] of Object.entries(handlers)) {\n        const rpc = this.requests.get(tag)!\n        contextMap.set(rpc.key, {\n          handler,\n          context\n        })\n      }\n      return Context.unsafeMake(contextMap)\n    })\n  },\n  prefix<const Prefix extends string>(this: RpcGroup<any>, prefix: Prefix) {\n    const requests = new Map<string, any>()\n    for (const rpc of this.requests.values()) {\n      const newRpc = rpc.prefix(prefix)\n      requests.set(newRpc._tag, newRpc)\n    }\n    return makeProto({\n      requests,\n      annotations: this.annotations\n    })\n  },\n  toLayer(this: RpcGroup<any>, build: Effect.Effect<Record<string, (request: any) => any>>) {\n    return Layer.scopedContext(this.toHandlersContext(build))\n  },\n  of: identity,\n  toLayerHandler(this: RpcGroup<any>, tag: string, build: Effect.Effect<Record<string, (request: any) => any>>) {\n    return Layer.scopedContext(Effect.gen(this, function*() {\n      const context = yield* Effect.context<never>()\n      const handler = Effect.isEffect(build) ? yield* build : build\n      const contextMap = new Map<string, unknown>()\n      const rpc = this.requests.get(tag)!\n      contextMap.set(rpc.key, {\n        handler,\n        context\n      })\n      return Context.unsafeMake(contextMap)\n    }))\n  },\n  accessHandler(this: RpcGroup<any>, tag: string) {\n    return Effect.contextWith((parentContext: Context.Context<any>) => {\n      const rpc = this.requests.get(tag)!\n      const { context, handler } = parentContext.unsafeMap.get(rpc.key) as Rpc.Handler<any>\n      return (payload: Rpc.Payload<any>, options: {\n        readonly clientId: number\n        readonly headers: Headers\n      }) => {\n        const result = handler(payload, options)\n        const effectOrStream = Rpc.isWrapper(result) ? result.value : result\n        return Effect.isEffect(effectOrStream)\n          ? Effect.provide(effectOrStream, context)\n          : Stream.provideContext(effectOrStream, context)\n      }\n    })\n  },\n  annotate(this: RpcGroup<any>, tag: Context.Tag<any, any>, value: any) {\n    return makeProto({\n      requests: this.requests,\n      annotations: Context.add(this.annotations, tag, value)\n    })\n  },\n  annotateRpcs(this: RpcGroup<any>, tag: Context.Tag<any, any>, value: any) {\n    return this.annotateRpcsContext(Context.make(tag, value))\n  },\n  annotateContext(this: RpcGroup<any>, context: Context.Context<any>) {\n    return makeProto({\n      requests: this.requests,\n      annotations: Context.merge(this.annotations, context)\n    })\n  },\n  annotateRpcsContext(this: RpcGroup<any>, context: Context.Context<any>) {\n    const requests = new Map<string, any>()\n    for (const [tag, rpc] of this.requests) {\n      requests.set(tag, rpc.annotateContext(Context.merge(context, rpc.annotations)))\n    }\n    return makeProto({\n      requests,\n      annotations: this.annotations\n    })\n  }\n}\n\nconst makeProto = <Rpcs extends Rpc.Any>(options: {\n  readonly requests: ReadonlyMap<string, Rpcs>\n  readonly annotations: Context.Context<never>\n}): RpcGroup<Rpcs> =>\n  Object.assign(function() {}, RpcGroupProto, {\n    requests: options.requests,\n    annotations: options.annotations\n  }) as any\n\nconst resolveInput = <Rpcs extends ReadonlyArray<Rpc.Any>>(\n  ...rpcs: Rpcs\n): ReadonlyMap<string, Rpcs[number]> => {\n  const requests = new Map<string, Rpcs[number]>()\n  for (const rpc of rpcs) {\n    requests.set(rpc._tag, Schema.isSchema(rpc) ? Rpc.fromTaggedRequest(rpc as any) : rpc as any)\n  }\n  return requests\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport const make = <const Rpcs extends ReadonlyArray<Rpc.Any>>(\n  ...rpcs: Rpcs\n): RpcGroup<Rpcs[number]> =>\n  makeProto({\n    requests: resolveInput(...rpcs),\n    annotations: Context.empty()\n  })\n","import * as Data from \"effect/Data\"\nimport * as Effect from \"effect/Effect\"\nimport { identity } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport * as Stream_ from \"effect/Stream\"\nimport type * as PlatformError from \"../Error.js\"\nimport * as FileSystem from \"../FileSystem.js\"\nimport type * as Body from \"../HttpBody.js\"\nimport * as UrlParams from \"../UrlParams.js\"\n\n/** @internal */\nexport const TypeId: Body.TypeId = Symbol.for(\n  \"@effect/platform/HttpBody\"\n) as Body.TypeId\n\n/** @internal */\nexport const ErrorTypeId: Body.ErrorTypeId = Symbol.for(\n  \"@effect/platform/HttpBody/HttpBodyError\"\n) as Body.ErrorTypeId\n\nconst bodyError = Data.tagged<Body.HttpBodyError>(\"HttpBodyError\")\n\n/** @internal */\nexport const HttpBodyError = (reason: Body.ErrorReason): Body.HttpBodyError =>\n  bodyError({ [ErrorTypeId]: ErrorTypeId, reason })\n\nabstract class BodyBase implements Body.HttpBody.Proto {\n  readonly [TypeId]: Body.TypeId\n  abstract readonly _tag: string\n  constructor() {\n    this[TypeId] = TypeId\n  }\n  abstract toJSON(): unknown\n  [Inspectable.NodeInspectSymbol](): unknown {\n    return this.toJSON()\n  }\n  toString(): string {\n    return Inspectable.format(this)\n  }\n}\n\nclass EmptyImpl extends BodyBase implements Body.Empty {\n  readonly _tag = \"Empty\"\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Empty\"\n    }\n  }\n}\n\n/** @internal */\nexport const empty: Body.Empty = new EmptyImpl()\n\nclass RawImpl extends BodyBase implements Body.Raw {\n  readonly _tag = \"Raw\"\n  constructor(\n    readonly body: unknown,\n    readonly contentType?: string | undefined,\n    readonly contentLength?: number | undefined\n  ) {\n    super()\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Raw\",\n      body: this.body,\n      contentType: this.contentType,\n      contentLength: this.contentLength\n    }\n  }\n}\n\n/** @internal */\nexport const raw = (body: unknown, options?: {\n  readonly contentType?: string | undefined\n  readonly contentLength?: number | undefined\n}): Body.Raw => new RawImpl(body, options?.contentType, options?.contentLength)\n\nclass Uint8ArrayImpl extends BodyBase implements Body.Uint8Array {\n  readonly _tag = \"Uint8Array\"\n  constructor(\n    readonly body: Uint8Array,\n    readonly contentType: string\n  ) {\n    super()\n  }\n  get contentLength(): number {\n    return this.body.length\n  }\n  toJSON(): unknown {\n    const toString = this.contentType.startsWith(\"text/\") || this.contentType.endsWith(\"json\")\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Uint8Array\",\n      body: toString ? new TextDecoder().decode(this.body) : `Uint8Array(${this.body.length})`,\n      contentType: this.contentType,\n      contentLength: this.contentLength\n    }\n  }\n}\n\n/** @internal */\nexport const uint8Array = (body: Uint8Array, contentType?: string): Body.Uint8Array =>\n  new Uint8ArrayImpl(body, contentType ?? \"application/octet-stream\")\n\nconst encoder = new TextEncoder()\n\n/** @internal */\nexport const text = (body: string, contentType?: string): Body.Uint8Array =>\n  uint8Array(encoder.encode(body), contentType ?? \"text/plain\")\n\n/** @internal */\nexport const unsafeJson = (body: unknown): Body.Uint8Array => text(JSON.stringify(body), \"application/json\")\n\n/** @internal */\nexport const json = (body: unknown): Effect.Effect<Body.Uint8Array, Body.HttpBodyError> =>\n  Effect.try({\n    try: () => unsafeJson(body),\n    catch: (error) => HttpBodyError({ _tag: \"JsonError\", error })\n  })\n\n/** @internal */\nexport const urlParams = (urlParams: UrlParams.UrlParams): Body.Uint8Array =>\n  text(UrlParams.toString(urlParams), \"application/x-www-form-urlencoded\")\n\n/** @internal */\nexport const jsonSchema = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions) => {\n  const encode = Schema.encode(schema, options)\n  return (body: A): Effect.Effect<Body.Uint8Array, Body.HttpBodyError, R> =>\n    Effect.flatMap(\n      Effect.mapError(encode(body), (error) => HttpBodyError({ _tag: \"SchemaError\", error })),\n      json\n    )\n}\n\n/** @internal */\nexport const file = (\n  path: string,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n): Effect.Effect<Body.Stream, PlatformError.PlatformError, FileSystem.FileSystem> =>\n  Effect.flatMap(\n    FileSystem.FileSystem,\n    (fs) =>\n      Effect.map(fs.stat(path), (info) =>\n        stream(\n          fs.stream(path, options),\n          options?.contentType,\n          Number(info.size)\n        ))\n  )\n\n/** @internal */\nexport const fileInfo = (\n  path: string,\n  info: FileSystem.File.Info,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n): Effect.Effect<Body.Stream, PlatformError.PlatformError, FileSystem.FileSystem> =>\n  Effect.map(\n    FileSystem.FileSystem,\n    (fs) =>\n      stream(\n        fs.stream(path, options),\n        options?.contentType,\n        Number(info.size)\n      )\n  )\n\n/** @internal */\nexport const fileWeb = (file: Body.HttpBody.FileLike): Body.Stream =>\n  stream(Stream_.fromReadableStream(() => file.stream() as ReadableStream<Uint8Array>, identity), file.type, file.size)\n\nclass FormDataImpl extends BodyBase implements Body.FormData {\n  readonly _tag = \"FormData\"\n  constructor(\n    readonly formData: FormData\n  ) {\n    super()\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"FormData\",\n      formData: this.formData\n    }\n  }\n}\n\n/** @internal */\nexport const formData = (body: FormData): Body.FormData => new FormDataImpl(body)\n\n/** @internal */\nexport const formDataRecord = (\n  entries: Body.FormDataInput\n): Body.FormData => {\n  const formData = new FormData()\n  for (const [key, value] of Object.entries(entries)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (item == null) continue\n        formData.append(key, typeof value === \"object\" ? item as any : String(item))\n      }\n    } else if (value != null) {\n      formData.append(key, typeof value === \"object\" ? value as any : String(value))\n    }\n  }\n  return new FormDataImpl(formData)\n}\n\nclass StreamImpl extends BodyBase implements Body.Stream {\n  readonly _tag = \"Stream\"\n  constructor(\n    readonly stream: Stream_.Stream<Uint8Array, unknown>,\n    readonly contentType: string,\n    readonly contentLength?: number | undefined\n  ) {\n    super()\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Stream\",\n      contentType: this.contentType,\n      contentLength: this.contentLength\n    }\n  }\n}\n\n/** @internal */\nexport const stream = (\n  body: Stream_.Stream<Uint8Array, unknown>,\n  contentType?: string | undefined,\n  contentLength?: number | undefined\n): Body.Stream => new StreamImpl(body, contentType ?? \"application/octet-stream\", contentLength)\n","import * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport * as Redacted from \"effect/Redacted\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport type * as PlatformError from \"../Error.js\"\nimport type * as FileSystem from \"../FileSystem.js\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Body from \"../HttpBody.js\"\nimport type * as ClientRequest from \"../HttpClientRequest.js\"\nimport type { HttpMethod } from \"../HttpMethod.js\"\nimport * as UrlParams from \"../UrlParams.js\"\nimport * as internalBody from \"./httpBody.js\"\n\n/** @internal */\nexport const TypeId: ClientRequest.TypeId = Symbol.for(\"@effect/platform/HttpClientRequest\") as ClientRequest.TypeId\n\nconst Proto = {\n  [TypeId]: TypeId,\n  ...Inspectable.BaseProto,\n  toJSON(this: ClientRequest.HttpClientRequest): unknown {\n    return {\n      _id: \"@effect/platform/HttpClientRequest\",\n      method: this.method,\n      url: this.url,\n      urlParams: this.urlParams,\n      hash: this.hash,\n      headers: Inspectable.redact(this.headers),\n      body: this.body.toJSON()\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nfunction makeInternal(\n  method: HttpMethod,\n  url: string,\n  urlParams: UrlParams.UrlParams,\n  hash: Option.Option<string>,\n  headers: Headers.Headers,\n  body: Body.HttpBody\n): ClientRequest.HttpClientRequest {\n  const self = Object.create(Proto)\n  self.method = method\n  self.url = url\n  self.urlParams = urlParams\n  self.hash = hash\n  self.headers = headers\n  self.body = body\n  return self\n}\n\n/** @internal */\nexport const isClientRequest = (u: unknown): u is ClientRequest.HttpClientRequest =>\n  typeof u === \"object\" && u !== null && TypeId in u\n\n/** @internal */\nexport const empty: ClientRequest.HttpClientRequest = makeInternal(\n  \"GET\",\n  \"\",\n  UrlParams.empty,\n  Option.none(),\n  Headers.empty,\n  internalBody.empty\n)\n\n/** @internal */\nexport const make = <M extends HttpMethod>(method: M) =>\n(\n  url: string | URL,\n  options?: M extends \"GET\" | \"HEAD\" ? ClientRequest.Options.NoBody : ClientRequest.Options.NoUrl\n) =>\n  modify(empty, {\n    method,\n    url,\n    ...(options ?? undefined)\n  })\n\n/** @internal */\nexport const get = make(\"GET\")\n\n/** @internal */\nexport const post = make(\"POST\")\n\n/** @internal */\nexport const put = make(\"PUT\")\n\n/** @internal */\nexport const patch = make(\"PATCH\")\n\n/** @internal */\nexport const del = make(\"DELETE\")\n\n/** @internal */\nexport const head = make(\"HEAD\")\n\n/** @internal */\nexport const options = make(\"OPTIONS\")\n\n/** @internal */\nexport const modify = dual<\n  (options: ClientRequest.Options) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, options: ClientRequest.Options) => ClientRequest.HttpClientRequest\n>(2, (self, options) => {\n  let result = self\n\n  if (options.method) {\n    result = setMethod(result, options.method)\n  }\n  if (options.url) {\n    result = setUrl(result, options.url)\n  }\n  if (options.headers) {\n    result = setHeaders(result, options.headers)\n  }\n  if (options.urlParams) {\n    result = setUrlParams(result, options.urlParams)\n  }\n  if (options.hash) {\n    result = setHash(result, options.hash)\n  }\n  if (options.body) {\n    result = setBody(result, options.body)\n  }\n  if (options.accept) {\n    result = accept(result, options.accept)\n  }\n  if (options.acceptJson) {\n    result = acceptJson(result)\n  }\n\n  return result\n})\n\n/** @internal */\nexport const setHeader = dual<\n  (key: string, value: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, key: string, value: string) => ClientRequest.HttpClientRequest\n>(3, (self, key, value) =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    Headers.set(self.headers, key, value),\n    self.body\n  ))\n\n/** @internal */\nexport const setHeaders = dual<\n  (input: Headers.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: Headers.Input) => ClientRequest.HttpClientRequest\n>(2, (self, input) =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    Headers.setAll(self.headers, input),\n    self.body\n  ))\n\nconst stringOrRedacted = (value: string | Redacted.Redacted): string =>\n  typeof value === \"string\" ? value : Redacted.value(value)\n\n/** @internal */\nexport const basicAuth = dual<\n  (\n    username: string | Redacted.Redacted,\n    password: string | Redacted.Redacted\n  ) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (\n    self: ClientRequest.HttpClientRequest,\n    username: string | Redacted.Redacted,\n    password: string | Redacted.Redacted\n  ) => ClientRequest.HttpClientRequest\n>(\n  3,\n  (self, username, password) =>\n    setHeader(self, \"Authorization\", `Basic ${btoa(`${stringOrRedacted(username)}:${stringOrRedacted(password)}`)}`)\n)\n\n/** @internal */\nexport const bearerToken = dual<\n  (token: string | Redacted.Redacted) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, token: string | Redacted.Redacted) => ClientRequest.HttpClientRequest\n>(2, (self, token) => setHeader(self, \"Authorization\", `Bearer ${stringOrRedacted(token)}`))\n\n/** @internal */\nexport const accept = dual<\n  (mediaType: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, mediaType: string) => ClientRequest.HttpClientRequest\n>(2, (self, mediaType) => setHeader(self, \"Accept\", mediaType))\n\n/** @internal */\nexport const acceptJson = accept(\"application/json\")\n\n/** @internal */\nexport const setMethod = dual<\n  (method: HttpMethod) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, method: HttpMethod) => ClientRequest.HttpClientRequest\n>(2, (self, method) =>\n  makeInternal(\n    method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setUrl = dual<\n  (url: string | URL) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, url: string | URL) => ClientRequest.HttpClientRequest\n>(2, (self, url) => {\n  if (typeof url === \"string\") {\n    return makeInternal(\n      self.method,\n      url,\n      self.urlParams,\n      self.hash,\n      self.headers,\n      self.body\n    )\n  }\n  const clone = new URL(url.toString())\n  const urlParams = UrlParams.fromInput(clone.searchParams)\n  const hash = clone.hash ? Option.some(clone.hash.slice(1)) : Option.none()\n  clone.search = \"\"\n  clone.hash = \"\"\n  return makeInternal(\n    self.method,\n    clone.toString(),\n    urlParams,\n    hash,\n    self.headers,\n    self.body\n  )\n})\n\n/** @internal */\nexport const appendUrl = dual<\n  (path: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, path: string) => ClientRequest.HttpClientRequest\n>(2, (self, url) =>\n  makeInternal(\n    self.method,\n    self.url.endsWith(\"/\") && url.startsWith(\"/\") ?\n      self.url + url.slice(1) :\n      self.url + url,\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const prependUrl = dual<\n  (path: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, path: string) => ClientRequest.HttpClientRequest\n>(2, (self, url) =>\n  makeInternal(\n    self.method,\n    url.endsWith(\"/\") && self.url.startsWith(\"/\") ?\n      url + self.url.slice(1) :\n      url + self.url,\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const updateUrl = dual<\n  (f: (url: string) => string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, f: (url: string) => string) => ClientRequest.HttpClientRequest\n>(2, (self, f) =>\n  makeInternal(\n    self.method,\n    f(self.url),\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const appendUrlParam = dual<\n  (key: string, value: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, key: string, value: string) => ClientRequest.HttpClientRequest\n>(3, (self, key, value) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.append(self.urlParams, key, value),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const appendUrlParams = dual<\n  (input: UrlParams.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: UrlParams.Input) => ClientRequest.HttpClientRequest\n>(2, (self, input) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.appendAll(self.urlParams, input),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setUrlParam = dual<\n  (key: string, value: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, key: string, value: string) => ClientRequest.HttpClientRequest\n>(3, (self, key, value) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.set(self.urlParams, key, value),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setUrlParams = dual<\n  (input: UrlParams.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: UrlParams.Input) => ClientRequest.HttpClientRequest\n>(2, (self, input) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.setAll(self.urlParams, input),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setHash = dual<\n  (hash: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, hash: string) => ClientRequest.HttpClientRequest\n>(2, (self, hash) =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    Option.some(hash),\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const removeHash = (self: ClientRequest.HttpClientRequest): ClientRequest.HttpClientRequest =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    Option.none(),\n    self.headers,\n    self.body\n  )\n\n/** @internal */\nexport const toUrl = (self: ClientRequest.HttpClientRequest): Option.Option<URL> =>\n  Either.getRight(UrlParams.makeUrl(self.url, self.urlParams, self.hash))\n\n/** @internal */\nexport const setBody = dual<\n  (body: Body.HttpBody) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: Body.HttpBody) => ClientRequest.HttpClientRequest\n>(2, (self, body) => {\n  let headers = self.headers\n  if (body._tag === \"Empty\" || body._tag === \"FormData\") {\n    headers = Headers.remove(headers, [\"Content-type\", \"Content-length\"])\n  } else {\n    const contentType = body.contentType\n    if (contentType) {\n      headers = Headers.set(headers, \"content-type\", contentType)\n    }\n\n    const contentLength = body.contentLength\n    if (contentLength) {\n      headers = Headers.set(headers, \"content-length\", contentLength.toString())\n    }\n  }\n  return makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    headers,\n    body\n  )\n})\n\n/** @internal */\nexport const bodyUint8Array = dual<\n  (\n    body: Uint8Array,\n    contentType?: string\n  ) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: Uint8Array, contentType?: string) => ClientRequest.HttpClientRequest\n>(\n  (args) => isClientRequest(args[0]),\n  (self, body, contentType = \"application/octet-stream\") => setBody(self, internalBody.uint8Array(body, contentType))\n)\n\n/** @internal */\nexport const bodyText = dual<\n  (body: string, contentType?: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: string, contentType?: string) => ClientRequest.HttpClientRequest\n>(\n  (args) => isClientRequest(args[0]),\n  (self, body, contentType = \"text/plain\") => setBody(self, internalBody.text(body, contentType))\n)\n\n/** @internal */\nexport const bodyJson = dual<\n  (\n    body: unknown\n  ) => (self: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError>,\n  (\n    self: ClientRequest.HttpClientRequest,\n    body: unknown\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError>\n>(2, (self, body) => Effect.map(internalBody.json(body), (body) => setBody(self, body)))\n\n/** @internal */\nexport const bodyUnsafeJson = dual<\n  (body: unknown) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: unknown) => ClientRequest.HttpClientRequest\n>(2, (self, body) => setBody(self, internalBody.unsafeJson(body)))\n\n/** @internal */\nexport const bodyFile = dual<\n  (\n    path: string,\n    options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ) => (\n    self: ClientRequest.HttpClientRequest\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>,\n  (\n    self: ClientRequest.HttpClientRequest,\n    path: string,\n    options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>\n>(\n  (args) => isClientRequest(args[0]),\n  (self, path, options) => Effect.map(internalBody.file(path, options), (body) => setBody(self, body))\n)\n\n/** @internal */\nexport const bodyFileWeb = dual<\n  (file: Body.HttpBody.FileLike) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, file: Body.HttpBody.FileLike) => ClientRequest.HttpClientRequest\n>(2, (self, file) => setBody(self, internalBody.fileWeb(file)))\n\n/** @internal */\nexport const schemaBodyJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined): {\n  (\n    body: A\n  ): (self: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>\n  (\n    self: ClientRequest.HttpClientRequest,\n    body: A\n  ): Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>\n} => {\n  const encode = internalBody.jsonSchema(schema, options)\n  return dual<\n    (\n      body: A\n    ) => (\n      self: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>,\n    (\n      self: ClientRequest.HttpClientRequest,\n      body: A\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>\n  >(2, (self, body) => Effect.map(encode(body), (body) => setBody(self, body)))\n}\n\n/** @internal */\nexport const bodyUrlParams = dual<\n  (input: UrlParams.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: UrlParams.Input) => ClientRequest.HttpClientRequest\n>(2, (self, body) =>\n  setBody(\n    self,\n    internalBody.text(\n      UrlParams.toString(UrlParams.fromInput(body)),\n      \"application/x-www-form-urlencoded\"\n    )\n  ))\n\n/** @internal */\nexport const bodyFormData = dual<\n  (body: FormData) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: FormData) => ClientRequest.HttpClientRequest\n>(2, (self, body) => setBody(self, internalBody.formData(body)))\n\n/** @internal */\nexport const bodyFormDataRecord = dual<\n  (entries: Body.FormDataInput) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, entries: Body.FormDataInput) => ClientRequest.HttpClientRequest\n>(2, (self, entries) => setBody(self, internalBody.formDataRecord(entries)))\n\n/** @internal */\nexport const bodyStream = dual<\n  (\n    body: Stream.Stream<Uint8Array, unknown>,\n    options?: {\n      readonly contentType?: string | undefined\n      readonly contentLength?: number | undefined\n    }\n  ) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (\n    self: ClientRequest.HttpClientRequest,\n    body: Stream.Stream<Uint8Array, unknown>,\n    options?: {\n      readonly contentType?: string | undefined\n      readonly contentLength?: number | undefined\n    }\n  ) => ClientRequest.HttpClientRequest\n>(\n  (args) => isClientRequest(args[0]),\n  (self, body, { contentLength, contentType = \"application/octet-stream\" } = {}) =>\n    setBody(self, internalBody.stream(body, contentType, contentLength))\n)\n","/**\n * @since 1.0.0\n */\nimport type * as Chunk from \"effect/Chunk\"\nimport * as Effect from \"effect/Effect\"\nimport * as Option from \"effect/Option\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport * as AST from \"effect/SchemaAST\"\nimport * as Stream_ from \"effect/Stream\"\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const StreamSchemaId: unique symbol = Symbol.for(\"@effect/rpc/RpcSchema/Stream\")\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const isStreamSchema = (schema: Schema.Schema.All): schema is Stream<any, any> =>\n  schema.ast.annotations[AST.SchemaIdAnnotationId] === StreamSchemaId\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const isStreamSerializable = (schema: Schema.WithResult.Any): boolean =>\n  isStreamSchema(Schema.successSchema(schema))\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const getStreamSchemas = (\n  ast: AST.AST\n): Option.Option<{\n  readonly success: Schema.Schema.Any\n  readonly failure: Schema.Schema.All\n}> => ast.annotations[StreamSchemaId] ? Option.some(ast.annotations[StreamSchemaId] as any) : Option.none()\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport interface Stream<A extends Schema.Schema.Any, E extends Schema.Schema.All> extends\n  Schema.Schema<\n    Stream_.Stream<A[\"Type\"], E[\"Type\"]>,\n    Stream_.Stream<A[\"Encoded\"], E[\"Encoded\"]>,\n    A[\"Context\"] | E[\"Context\"]\n  >\n{\n  readonly success: A\n  readonly failure: E\n}\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const Stream = <A extends Schema.Schema.Any, E extends Schema.Schema.All>(\n  { failure, success }: {\n    readonly failure: E\n    readonly success: A\n  }\n): Stream<A, E> =>\n  Object.assign(\n    Schema.declare(\n      [success, failure],\n      {\n        decode: (success, failure) =>\n          parseStream(\n            ParseResult.decodeUnknown(Schema.ChunkFromSelf(success)),\n            ParseResult.decodeUnknown(failure)\n          ),\n        encode: (success, failure) =>\n          parseStream(\n            ParseResult.encodeUnknown(Schema.ChunkFromSelf(success)),\n            ParseResult.encodeUnknown(failure)\n          )\n      },\n      {\n        schemaId: StreamSchemaId,\n        [StreamSchemaId]: { success, failure }\n      }\n    ),\n    {\n      success,\n      failure\n    }\n  )\n\nconst isStream = (u: unknown): u is Stream_.Stream<unknown, unknown> => hasProperty(u, Stream_.StreamTypeId)\n\nconst parseStream = <A, E, RA, RE>(\n  decodeSuccess: (\n    u: Chunk.Chunk<unknown>,\n    overrideOptions?: AST.ParseOptions\n  ) => Effect.Effect<Chunk.Chunk<A>, ParseResult.ParseIssue, RA>,\n  decodeFailure: (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<E, ParseResult.ParseIssue, RE>\n) =>\n(u: unknown, options: AST.ParseOptions, ast: AST.AST) =>\n  Effect.flatMap(\n    Effect.context<RA | RE>(),\n    (context) => {\n      if (!isStream(u)) return Effect.fail(new ParseResult.Type(ast, u))\n      return Effect.succeed(u.pipe(\n        Stream_.mapChunksEffect((value) => decodeSuccess(value, options)),\n        Stream_.catchAll((error) => {\n          if (ParseResult.isParseError(error)) return Stream_.die(error)\n          return Effect.matchEffect(decodeFailure(error, options), {\n            onFailure: Effect.die,\n            onSuccess: Effect.fail\n          })\n        }),\n        Stream_.provideContext(context)\n      ))\n    }\n  )\n","/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport * as internal from \"./internal/workerError.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const WorkerErrorTypeId: unique symbol = internal.WorkerErrorTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type WorkerErrorTypeId = typeof WorkerErrorTypeId\n\n/**\n * @since 1.0.0\n * @category predicates\n */\nexport const isWorkerError = (u: unknown): u is WorkerError => Predicate.hasProperty(u, WorkerErrorTypeId)\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class WorkerError extends Schema.TaggedError<WorkerError>()(\"WorkerError\", {\n  reason: Schema.Literal(\"spawn\", \"decode\", \"send\", \"unknown\", \"encode\"),\n  cause: Schema.Defect\n}) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [WorkerErrorTypeId]: WorkerErrorTypeId = WorkerErrorTypeId\n\n  /**\n   * @since 1.0.0\n   */\n  static readonly Cause: Schema.Schema<\n    Cause.Cause<WorkerError>,\n    Schema.CauseEncoded<WorkerErrorFrom, unknown>\n  > = Schema.Cause({ error: this, defect: Schema.Defect })\n\n  /**\n   * @since 1.0.0\n   */\n  static readonly encodeCause: (a: Cause.Cause<WorkerError>) => Schema.CauseEncoded<WorkerErrorFrom, unknown> = Schema\n    .encodeSync(this.Cause)\n\n  /**\n   * @since 1.0.0\n   */\n  static readonly decodeCause: (u: Schema.CauseEncoded<WorkerErrorFrom, unknown>) => Cause.Cause<WorkerError> = Schema\n    .decodeSync(this.Cause)\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    switch (this.reason) {\n      case \"send\":\n        return \"An error occurred calling .postMessage\"\n      case \"spawn\":\n        return \"An error occurred while spawning a worker\"\n      case \"decode\":\n        return \"An error occurred during decoding\"\n      case \"encode\":\n        return \"An error occurred during encoding\"\n      case \"unknown\":\n        return \"An unexpected error occurred\"\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport interface WorkerErrorFrom {\n  readonly _tag: \"WorkerError\"\n  readonly reason: \"spawn\" | \"decode\" | \"send\" | \"unknown\" | \"encode\"\n  readonly cause: unknown\n}\n","import * as Channel from \"effect/Channel\"\nimport * as Context from \"effect/Context\"\nimport * as Deferred from \"effect/Deferred\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberSet from \"effect/FiberSet\"\nimport { identity, pipe } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport * as Pool from \"effect/Pool\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Schema from \"effect/Schema\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Tracer from \"effect/Tracer\"\nimport * as Transferable from \"../Transferable.js\"\nimport type * as Worker from \"../Worker.js\"\nimport { WorkerError } from \"../WorkerError.js\"\n\n/** @internal */\nexport const PlatformWorkerTypeId: Worker.PlatformWorkerTypeId = Symbol.for(\n  \"@effect/platform/Worker/PlatformWorker\"\n) as Worker.PlatformWorkerTypeId\n\n/** @internal */\nexport const PlatformWorker = Context.GenericTag<Worker.PlatformWorker>(\n  \"@effect/platform/Worker/PlatformWorker\"\n)\n\n/** @internal */\nexport const WorkerManagerTypeId: Worker.WorkerManagerTypeId = Symbol.for(\n  \"@effect/platform/Worker/WorkerManager\"\n) as Worker.WorkerManagerTypeId\n\n/** @internal */\nexport const WorkerManager = Context.GenericTag<Worker.WorkerManager>(\n  \"@effect/platform/Worker/WorkerManager\"\n)\n\n/** @internal */\nexport const Spawner = Context.GenericTag<Worker.Spawner, Worker.SpawnerFn>(\n  \"@effect/platform/Worker/Spawner\"\n)\n\n/** @internal */\nexport const makeManager = Effect.gen(function*() {\n  const platform = yield* PlatformWorker\n  let idCounter = 0\n  return WorkerManager.of({\n    [WorkerManagerTypeId]: WorkerManagerTypeId,\n    spawn<I, O, E>({\n      encode,\n      initialMessage\n    }: Worker.Worker.Options<I>) {\n      return Effect.gen(function*() {\n        const id = idCounter++\n        let requestIdCounter = 0\n        const requestMap = new Map<\n          number,\n          Mailbox.Mailbox<O, E | WorkerError> | Deferred.Deferred<O, E | WorkerError>\n        >()\n\n        const collector = Transferable.unsafeMakeCollector()\n        const wrappedEncode = encode ?\n          ((message: I) =>\n            Effect.zipRight(\n              collector.clear,\n              Effect.provideService(encode(message), Transferable.Collector, collector)\n            )) :\n          Effect.succeed\n\n        const readyLatch = yield* Deferred.make<void>()\n        const backing = yield* platform.spawn<Worker.Worker.Request, Worker.Worker.Response<E, O>>(id)\n\n        yield* backing.run((message) => {\n          if (message[0] === 0) {\n            return Deferred.complete(readyLatch, Effect.void)\n          }\n          return handleMessage(message[1])\n        }).pipe(\n          Effect.onError((cause) =>\n            Effect.forEach(requestMap.values(), (mailbox) =>\n              Deferred.DeferredTypeId in mailbox\n                ? Deferred.failCause(mailbox, cause)\n                : mailbox.failCause(cause))\n          ),\n          Effect.tapErrorCause(Effect.logWarning),\n          Effect.retry(Schedule.spaced(1000)),\n          Effect.annotateLogs({\n            package: \"@effect/platform\",\n            module: \"Worker\"\n          }),\n          Effect.interruptible,\n          Effect.forkScoped\n        )\n\n        yield* Effect.addFinalizer(() =>\n          Effect.zipRight(\n            Effect.forEach(requestMap.values(), (mailbox) =>\n              Deferred.DeferredTypeId in mailbox\n                ? Deferred.interrupt(mailbox)\n                : mailbox.end, {\n              discard: true\n            }),\n            Effect.sync(() => requestMap.clear())\n          )\n        )\n\n        const handleMessage = (response: Worker.Worker.Response<E, O>) =>\n          Effect.suspend(() => {\n            const mailbox = requestMap.get(response[0])\n            if (!mailbox) return Effect.void\n\n            switch (response[1]) {\n              // data\n              case 0: {\n                return Deferred.DeferredTypeId in mailbox\n                  ? Deferred.succeed(mailbox, response[2][0])\n                  : mailbox.offerAll(response[2])\n              }\n              // end\n              case 1: {\n                if (response.length === 2) {\n                  return Deferred.DeferredTypeId in mailbox\n                    ? Deferred.interrupt(mailbox)\n                    : mailbox.end\n                }\n                return Deferred.DeferredTypeId in mailbox\n                  ? Deferred.succeed(mailbox, response[2][0])\n                  : Effect.zipRight(mailbox.offerAll(response[2]), mailbox.end)\n              }\n              // error / defect\n              case 2:\n              case 3: {\n                if (response[1] === 2) {\n                  return Deferred.DeferredTypeId in mailbox\n                    ? Deferred.fail(mailbox, response[2])\n                    : mailbox.fail(response[2])\n                }\n                const cause = WorkerError.decodeCause(response[2])\n                return Deferred.DeferredTypeId in mailbox\n                  ? Deferred.failCause(mailbox, cause)\n                  : mailbox.failCause(cause)\n              }\n            }\n          })\n\n        const executeAcquire = <\n          Q extends Mailbox.Mailbox<O, E | WorkerError> | Deferred.Deferred<O, E | WorkerError>\n        >(request: I, makeMailbox: Effect.Effect<Q>) =>\n          Effect.withFiberRuntime<{\n            readonly id: number\n            readonly mailbox: Q\n          }>((fiber) => {\n            const context = fiber.getFiberRef(FiberRef.currentContext)\n            const span = Context.getOption(context, Tracer.ParentSpan).pipe(\n              Option.filter((span): span is Tracer.Span => span._tag === \"Span\")\n            )\n            const id = requestIdCounter++\n            return makeMailbox.pipe(\n              Effect.tap((mailbox) => {\n                requestMap.set(id, mailbox)\n                return wrappedEncode(request).pipe(\n                  Effect.tap((payload) =>\n                    backing.send([\n                      id,\n                      0,\n                      payload,\n                      span._tag === \"Some\" ? [span.value.traceId, span.value.spanId, span.value.sampled] : undefined\n                    ], collector.unsafeRead())\n                  ),\n                  Effect.catchAllCause((cause) =>\n                    Mailbox.isMailbox<O, E | WorkerError>(mailbox)\n                      ? mailbox.failCause(cause)\n                      : Deferred.failCause(mailbox, cause)\n                  )\n                )\n              }),\n              Effect.map((mailbox) => ({ id, mailbox }))\n            )\n          })\n\n        const executeRelease = ({ id }: { readonly id: number }, exit: Exit.Exit<unknown, unknown>) => {\n          const release = Effect.sync(() => requestMap.delete(id))\n          return Exit.isFailure(exit) ?\n            Effect.zipRight(Effect.orDie(backing.send([id, 1])), release) :\n            release\n        }\n\n        const execute = (request: I) =>\n          Stream.fromChannel(\n            Channel.acquireUseRelease(\n              executeAcquire(request, Mailbox.make<O, E | WorkerError>()),\n              ({ mailbox }) => Mailbox.toChannel(mailbox),\n              executeRelease\n            )\n          )\n\n        const executeEffect = (request: I) =>\n          Effect.acquireUseRelease(\n            executeAcquire(request, Deferred.make<O, WorkerError | E>()),\n            ({ mailbox }) => Deferred.await(mailbox),\n            executeRelease\n          )\n\n        yield* Deferred.await(readyLatch)\n\n        if (initialMessage) {\n          yield* Effect.sync(initialMessage).pipe(\n            Effect.flatMap(executeEffect),\n            Effect.mapError((cause) => new WorkerError({ reason: \"spawn\", cause }))\n          )\n        }\n\n        return { id, execute, executeEffect }\n      })\n    }\n  })\n})\n\n/** @internal */\nexport const layerManager = Layer.effect(WorkerManager, makeManager)\n\n/** @internal */\nexport const makePool = <I, O, E>(\n  options: Worker.WorkerPool.Options<I>\n) =>\n  Effect.gen(function*() {\n    const manager = yield* WorkerManager\n    const workers = new Set<Worker.Worker<I, O, E>>()\n    const acquire = pipe(\n      manager.spawn<I, O, E>(options),\n      Effect.tap((worker) =>\n        Effect.acquireRelease(\n          Effect.sync(() => workers.add(worker)),\n          () => Effect.sync(() => workers.delete(worker))\n        )\n      ),\n      options.onCreate ? Effect.tap(options.onCreate) : identity\n    )\n    const backing = \"minSize\" in options ?\n      yield* Pool.makeWithTTL({\n        acquire,\n        min: options.minSize,\n        max: options.maxSize,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization,\n        timeToLive: options.timeToLive\n      }) :\n      yield* Pool.make({\n        acquire,\n        size: options.size,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization\n      })\n    const pool: Worker.WorkerPool<I, O, E> = {\n      backing,\n      broadcast: (message: I) =>\n        Effect.forEach(workers, (worker) => worker.executeEffect(message), {\n          concurrency: \"unbounded\",\n          discard: true\n        }),\n      execute: (message: I) =>\n        Stream.unwrapScoped(Effect.map(\n          backing.get,\n          (worker) => worker.execute(message)\n        )),\n      executeEffect: (message: I) =>\n        Effect.scoped(Effect.flatMap(\n          backing.get,\n          (worker) => worker.executeEffect(message)\n        ))\n    }\n\n    // report any spawn errors\n    yield* Effect.scoped(backing.get)\n\n    return pool\n  })\n\n/** @internal */\nexport const makePoolLayer = <Tag, I, O, E>(\n  tag: Context.Tag<Tag, Worker.WorkerPool<I, O, E>>,\n  options: Worker.WorkerPool.Options<I>\n) => Layer.scoped(tag, makePool(options))\n\n/** @internal */\nexport const makeSerialized = <\n  I extends Schema.TaggedRequest.All\n>(\n  options: Worker.SerializedWorker.Options<I>\n): Effect.Effect<Worker.SerializedWorker<I>, WorkerError, Worker.WorkerManager | Worker.Spawner | Scope.Scope> =>\n  Effect.gen(function*() {\n    const manager = yield* WorkerManager\n    const backing = yield* manager.spawn({\n      ...options as any,\n      encode(message) {\n        return Effect.mapError(\n          Schema.serialize(message as any),\n          (cause) => new WorkerError({ reason: \"encode\", cause })\n        )\n      }\n    })\n    const execute = <Req extends I>(message: Req) => {\n      const parseSuccess = Schema.decode(Schema.successSchema(message as any))\n      const parseFailure = Schema.decode(Schema.failureSchema(message as any))\n      return pipe(\n        backing.execute(message),\n        Stream.catchAll((error) => Effect.flatMap(parseFailure(error), Effect.fail)),\n        Stream.mapEffect(parseSuccess)\n      )\n    }\n    const executeEffect = <Req extends I>(message: Req) => {\n      const parseSuccess = Schema.decode(Schema.successSchema(message as any))\n      const parseFailure = Schema.decode(Schema.failureSchema(message as any))\n      return Effect.matchEffect(backing.executeEffect(message), {\n        onFailure: (error) => Effect.flatMap(parseFailure(error), Effect.fail),\n        onSuccess: parseSuccess\n      })\n    }\n    return identity<Worker.SerializedWorker<I>>({\n      id: backing.id,\n      execute: execute as any,\n      executeEffect: executeEffect as any\n    })\n  })\n\n/** @internal */\nexport const makePoolSerialized = <I extends Schema.TaggedRequest.All>(\n  options: Worker.SerializedWorkerPool.Options<I>\n) =>\n  Effect.gen(function*() {\n    const manager = yield* WorkerManager\n    const workers = new Set<Worker.SerializedWorker<I>>()\n    const acquire = pipe(\n      makeSerialized<I>(options),\n      Effect.tap((worker) => Effect.sync(() => workers.add(worker))),\n      Effect.tap((worker) => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))),\n      options.onCreate\n        ? Effect.tap(\n          options.onCreate as (worker: Worker.SerializedWorker<I>) => Effect.Effect<void, WorkerError>\n        )\n        : identity,\n      Effect.provideService(WorkerManager, manager)\n    )\n    const backing = yield* \"timeToLive\" in options ?\n      Pool.makeWithTTL({\n        acquire,\n        min: options.minSize,\n        max: options.maxSize,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization,\n        timeToLive: options.timeToLive\n      }) :\n      Pool.make({\n        acquire,\n        size: options.size,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization\n      })\n    const pool: Worker.SerializedWorkerPool<I> = {\n      backing,\n      broadcast: <Req extends I>(message: Req) =>\n        Effect.forEach(workers, (worker) => worker.executeEffect(message), {\n          concurrency: \"unbounded\",\n          discard: true\n        }) as any,\n      execute: <Req extends I>(message: Req) =>\n        Stream.unwrapScoped(Effect.map(backing.get, (worker) => worker.execute(message))) as any,\n      executeEffect: <Req extends I>(message: Req) =>\n        Effect.scoped(Effect.flatMap(backing.get, (worker) => worker.executeEffect(message))) as any\n    }\n\n    // report any spawn errors\n    yield* Effect.scoped(backing.get)\n\n    return pool\n  })\n\n/** @internal */\nexport const makePoolSerializedLayer = <Tag, I extends Schema.TaggedRequest.All>(\n  tag: Context.Tag<Tag, Worker.SerializedWorkerPool<I>>,\n  options: Worker.SerializedWorkerPool.Options<I>\n) => Layer.scoped(tag, makePoolSerialized(options))\n\n/** @internal */\nexport const layerSpawner = <W = unknown>(spawner: Worker.SpawnerFn<W>) =>\n  Layer.succeed(\n    Spawner,\n    spawner\n  )\n\n/** @internal */\nexport const makePlatform = <W>() =>\n<\n  P extends {\n    readonly postMessage: (message: any, transfers?: any | undefined) => void\n  }\n>(options: {\n  readonly setup: (options: {\n    readonly worker: W\n    readonly scope: Scope.Scope\n  }) => Effect.Effect<P, WorkerError>\n  readonly listen: (options: {\n    readonly port: P\n    readonly emit: (data: any) => void\n    readonly deferred: Deferred.Deferred<never, WorkerError>\n    readonly scope: Scope.Scope\n  }) => Effect.Effect<void>\n}) =>\n  PlatformWorker.of({\n    [PlatformWorkerTypeId]: PlatformWorkerTypeId,\n    spawn<I, O>(id: number) {\n      return Effect.gen(function*() {\n        const spawn = (yield* Spawner) as Worker.SpawnerFn<W>\n        let currentPort: P | undefined\n        const buffer: Array<[I, ReadonlyArray<unknown> | undefined]> = []\n\n        const run = <A, E, R>(\n          handler: (_: Worker.BackingWorker.Message<O>) => Effect.Effect<A, E, R>\n        ): Effect.Effect<never, WorkerError | E, R> =>\n          Effect.uninterruptibleMask((restore) =>\n            Effect.gen(function*() {\n              const scope = yield* Effect.scope\n              const port = yield* options.setup({ worker: spawn(id), scope })\n              currentPort = port\n              yield* Scope.addFinalizer(\n                scope,\n                Effect.sync(() => {\n                  currentPort = undefined\n                })\n              )\n              const runtime = (yield* Effect.runtime<R | Scope.Scope>()).pipe(\n                Runtime.updateContext(Context.omit(Scope.Scope))\n              ) as Runtime.Runtime<R>\n              const fiberSet = yield* FiberSet.make<any, WorkerError | E>()\n              const runFork = Runtime.runFork(runtime)\n              yield* options.listen({\n                port,\n                scope,\n                emit(data) {\n                  FiberSet.unsafeAdd(fiberSet, runFork(handler(data)))\n                },\n                deferred: fiberSet.deferred as any\n              })\n              if (buffer.length > 0) {\n                for (const [message, transfers] of buffer) {\n                  port.postMessage([0, message], transfers as any)\n                }\n                buffer.length = 0\n              }\n              return (yield* restore(FiberSet.join(fiberSet))) as never\n            }).pipe(Effect.scoped)\n          )\n\n        const send = (message: I, transfers?: ReadonlyArray<unknown>) =>\n          Effect.try({\n            try: () => {\n              if (currentPort === undefined) {\n                buffer.push([message, transfers])\n              } else {\n                currentPort.postMessage([0, message], transfers as any)\n              }\n            },\n            catch: (cause) => new WorkerError({ reason: \"send\", cause })\n          })\n\n        return { run, send }\n      })\n    }\n  })\n","import * as Cause from \"effect/Cause\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport type * as Fiber from \"effect/Fiber\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { constFalse, dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Layer from \"effect/Layer\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Ref from \"effect/Ref\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport type { NoExcessProperties, NoInfer } from \"effect/Types\"\nimport * as Cookies from \"../Cookies.js\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Client from \"../HttpClient.js\"\nimport * as Error from \"../HttpClientError.js\"\nimport type * as ClientRequest from \"../HttpClientRequest.js\"\nimport type * as ClientResponse from \"../HttpClientResponse.js\"\nimport * as IncomingMessage from \"../HttpIncomingMessage.js\"\nimport * as TraceContext from \"../HttpTraceContext.js\"\nimport * as UrlParams from \"../UrlParams.js\"\nimport * as internalRequest from \"./httpClientRequest.js\"\nimport * as internalResponse from \"./httpClientResponse.js\"\n\nconst ATTR_HTTP_REQUEST_HEADER = (key: string): string => `http.request.header.${key}`\nconst ATTR_HTTP_REQUEST_METHOD = \"http.request.method\"\nconst ATTR_HTTP_RESPONSE_HEADER = (key: string): string => `http.response.header.${key}`\nconst ATTR_HTTP_RESPONSE_STATUS_CODE = \"http.response.status_code\"\nconst ATTR_SERVER_ADDRESS = \"server.address\"\nconst ATTR_SERVER_PORT = \"server.port\"\nconst ATTR_URL_FULL = \"url.full\"\nconst ATTR_URL_PATH = \"url.path\"\nconst ATTR_URL_SCHEME = \"url.scheme\"\nconst ATTR_URL_QUERY = \"url.query\"\n\n/** @internal */\nexport const TypeId: Client.TypeId = Symbol.for(\n  \"@effect/platform/HttpClient\"\n) as Client.TypeId\n\n/** @internal */\nexport const tag = Context.GenericTag<Client.HttpClient>(\"@effect/platform/HttpClient\")\n\n/** @internal */\nexport const currentTracerDisabledWhen = globalValue(\n  Symbol.for(\"@effect/platform/HttpClient/tracerDisabledWhen\"),\n  () => FiberRef.unsafeMake<Predicate.Predicate<ClientRequest.HttpClientRequest>>(constFalse)\n)\n\n/** @internal */\nexport const withTracerDisabledWhen = dual<\n  (\n    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, pred) => transformResponse(self, Effect.locally(currentTracerDisabledWhen, pred)))\n\n/** @internal */\nexport const currentTracerPropagation = globalValue(\n  Symbol.for(\"@effect/platform/HttpClient/currentTracerPropagation\"),\n  () => FiberRef.unsafeMake(true)\n)\n\n/** @internal */\nexport const withTracerPropagation = dual<\n  (\n    enabled: boolean\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    enabled: boolean\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, enabled) => transformResponse(self, Effect.locally(currentTracerPropagation, enabled)))\n\n/** @internal */\nexport const SpanNameGenerator = Context.Reference<Client.SpanNameGenerator>()(\n  \"@effect/platform/HttpClient/SpanNameGenerator\",\n  {\n    defaultValue: () => (request: ClientRequest.HttpClientRequest) => `http.client ${request.method}`\n  }\n)\n\n/** @internal */\nexport const withSpanNameGenerator = dual<\n  (\n    f: (request: ClientRequest.HttpClientRequest) => string\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (request: ClientRequest.HttpClientRequest) => string\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, f) => transformResponse(self, Effect.provideService(SpanNameGenerator, f)))\n\nconst ClientProto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  ...Inspectable.BaseProto,\n  toJSON() {\n    return {\n      _id: \"@effect/platform/HttpClient\"\n    }\n  },\n  get(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoBody) {\n    return this.execute(internalRequest.get(url, options))\n  },\n  head(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoBody) {\n    return this.execute(internalRequest.head(url, options))\n  },\n  post(this: Client.HttpClient, url: string | URL, options: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.post(url, options))\n  },\n  put(this: Client.HttpClient, url: string | URL, options: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.put(url, options))\n  },\n  patch(this: Client.HttpClient, url: string | URL, options: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.patch(url, options))\n  },\n  del(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.del(url, options))\n  },\n  options(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoBody) {\n    return this.execute(internalRequest.options(url, options))\n  }\n}\n\nconst isClient = (u: unknown): u is Client.HttpClient.With<unknown, unknown> => Predicate.hasProperty(u, TypeId)\n\ninterface HttpClientImpl<E, R> extends Client.HttpClient.With<E, R> {\n  readonly preprocess: Client.HttpClient.Preprocess<E, R>\n  readonly postprocess: Client.HttpClient.Postprocess<E, R>\n}\n\n/** @internal */\nexport const makeWith = <E2, R2, E, R>(\n  postprocess: (\n    request: Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n  preprocess: Client.HttpClient.Preprocess<E2, R2>\n): Client.HttpClient.With<E, R> => {\n  const self = Object.create(ClientProto)\n  self.preprocess = preprocess\n  self.postprocess = postprocess\n  self.execute = function(request: ClientRequest.HttpClientRequest) {\n    return postprocess(preprocess(request))\n  }\n  return self\n}\n\nconst responseRegistry = globalValue(\n  \"@effect/platform/HttpClient/responseRegistry\",\n  () => {\n    if (\"FinalizationRegistry\" in globalThis && globalThis.FinalizationRegistry) {\n      const registry = new FinalizationRegistry((controller: AbortController) => {\n        controller.abort()\n      })\n      return {\n        register(response: ClientResponse.HttpClientResponse, controller: AbortController) {\n          registry.register(response, controller, response)\n        },\n        unregister(response: ClientResponse.HttpClientResponse) {\n          registry.unregister(response)\n        }\n      }\n    }\n\n    const timers = new Map<ClientResponse.HttpClientResponse, any>()\n    return {\n      register(response: ClientResponse.HttpClientResponse, controller: AbortController) {\n        timers.set(response, setTimeout(() => controller.abort(), 5000))\n      },\n      unregister(response: ClientResponse.HttpClientResponse) {\n        const timer = timers.get(response)\n        if (timer === undefined) return\n        clearTimeout(timer)\n        timers.delete(response)\n      }\n    }\n  }\n)\n\nconst scopedRequests = globalValue(\n  \"@effect/platform/HttpClient/scopedRequests\",\n  () => new WeakMap<ClientRequest.HttpClientRequest, AbortController>()\n)\n\n/** @internal */\nexport const make = (\n  f: (\n    request: ClientRequest.HttpClientRequest,\n    url: URL,\n    signal: AbortSignal,\n    fiber: Fiber.RuntimeFiber<ClientResponse.HttpClientResponse, Error.HttpClientError>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.HttpClientError>\n): Client.HttpClient =>\n  makeWith((effect) =>\n    Effect.flatMap(effect, (request) =>\n      Effect.withFiberRuntime((fiber) => {\n        const scopedController = scopedRequests.get(request)\n        const controller = scopedController ?? new AbortController()\n        const urlResult = UrlParams.makeUrl(request.url, request.urlParams, request.hash)\n        if (urlResult._tag === \"Left\") {\n          return Effect.fail(new Error.RequestError({ request, reason: \"InvalidUrl\", cause: urlResult.left }))\n        }\n        const url = urlResult.right\n        const tracerDisabled = !fiber.getFiberRef(FiberRef.currentTracerEnabled) ||\n          fiber.getFiberRef(currentTracerDisabledWhen)(request)\n        if (tracerDisabled) {\n          const effect = f(request, url, controller.signal, fiber)\n          if (scopedController) return effect\n          return Effect.uninterruptibleMask((restore) =>\n            Effect.matchCauseEffect(restore(effect), {\n              onSuccess(response) {\n                responseRegistry.register(response, controller)\n                return Effect.succeed(new InterruptibleResponse(response, controller))\n              },\n              onFailure(cause) {\n                if (Cause.isInterrupted(cause)) {\n                  controller.abort()\n                }\n                return Effect.failCause(cause)\n              }\n            })\n          )\n        }\n        const nameGenerator = Context.get(fiber.currentContext, SpanNameGenerator)\n        return Effect.useSpan(\n          nameGenerator(request),\n          { kind: \"client\", captureStackTrace: false },\n          (span) => {\n            span.attribute(ATTR_HTTP_REQUEST_METHOD, request.method)\n            span.attribute(ATTR_SERVER_ADDRESS, url.origin)\n            if (url.port !== \"\") {\n              span.attribute(ATTR_SERVER_PORT, +url.port)\n            }\n            span.attribute(ATTR_URL_FULL, url.toString())\n            span.attribute(ATTR_URL_PATH, url.pathname)\n            span.attribute(ATTR_URL_SCHEME, url.protocol.slice(0, -1))\n            const query = url.search.slice(1)\n            if (query !== \"\") {\n              span.attribute(ATTR_URL_QUERY, query)\n            }\n            const redactedHeaderNames = fiber.getFiberRef(Headers.currentRedactedNames)\n            const redactedHeaders = Headers.redact(request.headers, redactedHeaderNames)\n            for (const name in redactedHeaders) {\n              span.attribute(ATTR_HTTP_REQUEST_HEADER(name), String(redactedHeaders[name]))\n            }\n            request = fiber.getFiberRef(currentTracerPropagation)\n              ? internalRequest.setHeaders(request, TraceContext.toHeaders(span))\n              : request\n            return Effect.uninterruptibleMask((restore) =>\n              restore(f(request, url, controller.signal, fiber)).pipe(\n                Effect.withParentSpan(span),\n                Effect.matchCauseEffect({\n                  onSuccess: (response) => {\n                    span.attribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status)\n                    const redactedHeaders = Headers.redact(response.headers, redactedHeaderNames)\n                    for (const name in redactedHeaders) {\n                      span.attribute(ATTR_HTTP_RESPONSE_HEADER(name), String(redactedHeaders[name]))\n                    }\n                    if (scopedController) return Effect.succeed(response)\n                    responseRegistry.register(response, controller)\n                    return Effect.succeed(new InterruptibleResponse(response, controller))\n                  },\n                  onFailure(cause) {\n                    if (!scopedController && Cause.isInterrupted(cause)) {\n                      controller.abort()\n                    }\n                    return Effect.failCause(cause)\n                  }\n                })\n              )\n            )\n          }\n        )\n      })), Effect.succeed as Client.HttpClient.Preprocess<never, never>)\n\nclass InterruptibleResponse implements ClientResponse.HttpClientResponse {\n  constructor(\n    readonly original: ClientResponse.HttpClientResponse,\n    readonly controller: AbortController\n  ) {}\n\n  readonly [internalResponse.TypeId]: ClientResponse.TypeId = internalResponse.TypeId\n  readonly [IncomingMessage.TypeId]: IncomingMessage.TypeId = IncomingMessage.TypeId\n\n  private applyInterrupt<A, E, R>(effect: Effect.Effect<A, E, R>) {\n    return Effect.suspend(() => {\n      responseRegistry.unregister(this.original)\n      return Effect.onInterrupt(effect, () =>\n        Effect.sync(() => {\n          this.controller.abort()\n        }))\n    })\n  }\n\n  get request() {\n    return this.original.request\n  }\n\n  get status() {\n    return this.original.status\n  }\n\n  get headers() {\n    return this.original.headers\n  }\n\n  get cookies() {\n    return this.original.cookies\n  }\n\n  get remoteAddress() {\n    return this.original.remoteAddress\n  }\n\n  get formData() {\n    return this.applyInterrupt(this.original.formData)\n  }\n\n  get text() {\n    return this.applyInterrupt(this.original.text)\n  }\n\n  get json() {\n    return this.applyInterrupt(this.original.json)\n  }\n\n  get urlParamsBody() {\n    return this.applyInterrupt(this.original.urlParamsBody)\n  }\n\n  get arrayBuffer() {\n    return this.applyInterrupt(this.original.arrayBuffer)\n  }\n\n  get stream() {\n    return Stream.suspend(() => {\n      responseRegistry.unregister(this.original)\n      return Stream.ensuring(\n        this.original.stream,\n        Effect.sync(() => {\n          this.controller.abort()\n        })\n      )\n    })\n  }\n\n  toJSON() {\n    return this.original.toJSON()\n  }\n\n  [Inspectable.NodeInspectSymbol]() {\n    return this.original[Inspectable.NodeInspectSymbol]()\n  }\n}\n\n/** @internal */\nexport const withScope = <E, R>(\n  self: Client.HttpClient.With<E, R>\n): Client.HttpClient.With<E, R | Scope.Scope> =>\n  transform(\n    self,\n    (effect, request) => {\n      const controller = new AbortController()\n      scopedRequests.set(request, controller)\n      return Effect.zipRight(\n        Effect.scopeWith((scope) => Scope.addFinalizer(scope, Effect.sync(() => controller.abort()))),\n        effect\n      )\n    }\n  )\n\nexport const {\n  /** @internal */\n  del,\n  /** @internal */\n  execute,\n  /** @internal */\n  get,\n  /** @internal */\n  head,\n  /** @internal */\n  options,\n  /** @internal */\n  patch,\n  /** @internal */\n  post,\n  /** @internal */\n  put\n} = Effect.serviceFunctions(tag)\n\n/** @internal */\nexport const transform = dual<\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => (self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E | E1, R | R1>,\n  <E, R, E1, R1>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => Client.HttpClient.With<E | E1, R | R1>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(\n    Effect.flatMap((request) => f(client.postprocess(Effect.succeed(request)), request)),\n    client.preprocess\n  )\n})\n\n/** @internal */\nexport const filterStatus = dual<\n  (\n    f: (status: number) => boolean\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | Error.ResponseError, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (status: number) => boolean\n  ) => Client.HttpClient.With<E | Error.ResponseError, R>\n>(2, (self, f) => transformResponse(self, Effect.flatMap(internalResponse.filterStatus(f))))\n\n/** @internal */\nexport const filterStatusOk = <E, R>(\n  self: Client.HttpClient.With<E, R>\n): Client.HttpClient.With<E | Error.ResponseError, R> =>\n  transformResponse(self, Effect.flatMap(internalResponse.filterStatusOk))\n\n/** @internal */\nexport const transformResponse = dual<\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => (self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E1, R1>,\n  <E, R, E1, R1>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => Client.HttpClient.With<E1, R1>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith((request) => f(client.postprocess(request)), client.preprocess)\n})\n\n/** @internal */\nexport const catchTag: {\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, E1, R1>(\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n  <\n    R,\n    E,\n    K extends E extends { _tag: string } ? E[\"_tag\"] : never,\n    R1,\n    E1\n  >(\n    self: Client.HttpClient.With<E, R>,\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): Client.HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n} = dual(\n  3,\n  <\n    R,\n    E,\n    K extends E extends { _tag: string } ? E[\"_tag\"] : never,\n    R1,\n    E1\n  >(\n    self: Client.HttpClient.With<E, R>,\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): Client.HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R> => transformResponse(self, Effect.catchTag(tag, f))\n)\n\n/** @internal */\nexport const catchTags: {\n  <\n    E,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {}\n        : {\n          [\n            K in Exclude<\n              keyof Cases,\n              Extract<E, { _tag: string }>[\"_tag\"]\n            >\n          ]: never\n        })\n  >(\n    cases: Cases\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, infer E, any> ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, any, infer R> ? R\n        : never\n    }[keyof Cases]\n  >\n  <\n    E extends { _tag: string },\n    R,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {}\n        : {\n          [\n            K in Exclude<\n              keyof Cases,\n              Extract<E, { _tag: string }>[\"_tag\"]\n            >\n          ]: never\n        })\n  >(\n    self: Client.HttpClient.With<E, R>,\n    cases: Cases\n  ): Client.HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, infer E, any> ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, any, infer R> ? R\n        : never\n    }[keyof Cases]\n  >\n} = dual(\n  2,\n  <\n    E extends { _tag: string },\n    R,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {}\n        : {\n          [\n            K in Exclude<\n              keyof Cases,\n              Extract<E, { _tag: string }>[\"_tag\"]\n            >\n          ]: never\n        })\n  >(\n    self: Client.HttpClient.With<E, R>,\n    cases: Cases\n  ): Client.HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, infer E, any> ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, any, infer R> ? R\n        : never\n    }[keyof Cases]\n  > => transformResponse(self, Effect.catchTags(cases) as any)\n)\n\n/** @internal */\nexport const catchAll: {\n  <E, E2, R2>(\n    f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E2, R | R2>\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): Client.HttpClient.With<E2, R | R2>\n} = dual(\n  2,\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): Client.HttpClient.With<E2, R | R2> => transformResponse(self, Effect.catchAll(f))\n)\n\n/** @internal */\nexport const filterOrElse: {\n  <E2, R2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E2 | E, R2 | R>\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): Client.HttpClient.With<E2 | E, R2 | R>\n} = dual(3, (self, f, orElse) => transformResponse(self, Effect.filterOrElse(f, orElse)))\n\n/** @internal */\nexport const filterOrFail: {\n  <E2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E2 | E, R>\n  <E, R, E2>(\n    self: Client.HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): Client.HttpClient.With<E2 | E, R>\n} = dual(3, (self, f, orFailWith) => transformResponse(self, Effect.filterOrFail(f, orFailWith)))\n\n/** @internal */\nexport const mapRequest = dual<\n  (\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess, (request) => Effect.map(client.preprocess(request), f))\n})\n\n/** @internal */\nexport const mapRequestEffect = dual<\n  <E2, R2>(\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess as any, (request) => Effect.flatMap(client.preprocess(request), f))\n})\n\n/** @internal */\nexport const mapRequestInput = dual<\n  (\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess, (request) => client.preprocess(f(request)))\n})\n\n/** @internal */\nexport const mapRequestInputEffect = dual<\n  <E2, R2>(\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess as any, (request) => Effect.flatMap(f(request), client.preprocess))\n})\n\n/** @internal */\nexport const retry: {\n  <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(\n    options: O\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.Retry.Return<R, E, O>\n  <B, E, R1>(\n    policy: Schedule.Schedule<B, NoInfer<E>, R1>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R1 | R>\n  <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(\n    self: Client.HttpClient.With<E, R>,\n    options: O\n  ): Client.Retry.Return<R, E, O>\n  <E, R, B, R1>(\n    self: Client.HttpClient.With<E, R>,\n    policy: Schedule.Schedule<B, E, R1>\n  ): Client.HttpClient.With<E, R1 | R>\n} = dual(\n  2,\n  <E extends E0, E0, R, R1, B>(\n    self: Client.HttpClient.With<E, R>,\n    policy: Schedule.Schedule<B, E0, R1>\n  ): Client.HttpClient.With<E, R | R1> => transformResponse(self, Effect.retry(policy))\n)\n\n/** @internal */\nexport const retryTransient: {\n  <B, E, R1 = never>(\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R1 | R>\n  <E, R, B, R1 = never>(\n    self: Client.HttpClient.With<E, R>,\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): Client.HttpClient.With<E, R1 | R>\n} = dual(\n  2,\n  <E extends E0, E0, R, B, R1 = never>(\n    self: Client.HttpClient.With<E, R>,\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): Client.HttpClient.With<E, R | R1> =>\n    transformResponse(\n      self,\n      Effect.retry({\n        while: Schedule.ScheduleTypeId in options || options.while === undefined\n          ? isTransientError\n          : Predicate.or(isTransientError, options.while),\n        schedule: Schedule.ScheduleTypeId in options ? options : options.schedule,\n        times: Schedule.ScheduleTypeId in options ? undefined : options.times\n      })\n    )\n)\n\nconst isTransientError = (error: unknown) =>\n  Predicate.hasProperty(error, Cause.TimeoutExceptionTypeId) || isTransientHttpError(error)\n\nconst isTransientHttpError = (error: unknown) =>\n  Error.isHttpClientError(error) &&\n  ((error._tag === \"RequestError\" && error.reason === \"Transport\") ||\n    (error._tag === \"ResponseError\" && error.response.status >= 429))\n\n/** @internal */\nexport const tap = dual<\n  <_, E2, R2>(\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, _, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => transformResponse(self, Effect.tap(f)))\n\n/** @internal */\nexport const tapError = dual<\n  <_, E, E2, R2>(\n    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>\n  ) => <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, _, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => transformResponse(self, Effect.tapError(f)))\n\n/** @internal */\nexport const tapRequest = dual<\n  <_, E2, R2>(\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, _, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess as any, (request) => Effect.tap(client.preprocess(request), f))\n})\n\n/** @internal */\nexport const withCookiesRef = dual<\n  (\n    ref: Ref.Ref<Cookies.Cookies>\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    ref: Ref.Ref<Cookies.Cookies>\n  ) => Client.HttpClient.With<E, R>\n>(\n  2,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    ref: Ref.Ref<Cookies.Cookies>\n  ): Client.HttpClient.With<E, R> => {\n    const client = self as HttpClientImpl<E, R>\n    return makeWith(\n      (request: Effect.Effect<ClientRequest.HttpClientRequest, E, R>) =>\n        Effect.tap(\n          client.postprocess(request),\n          (response) => Ref.update(ref, (cookies) => Cookies.merge(cookies, response.cookies))\n        ),\n      (request) =>\n        Effect.flatMap(client.preprocess(request), (request) =>\n          Effect.map(\n            Ref.get(ref),\n            (cookies) =>\n              Cookies.isEmpty(cookies)\n                ? request\n                : internalRequest.setHeader(request, \"cookie\", Cookies.toCookieHeader(cookies))\n          ))\n    )\n  }\n)\n\n/** @internal */\nexport const followRedirects = dual<\n  (\n    maxRedirects?: number | undefined\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    maxRedirects?: number | undefined\n  ) => Client.HttpClient.With<E, R>\n>((args) => isClient(args[0]), <E, R>(\n  self: Client.HttpClient.With<E, R>,\n  maxRedirects?: number | undefined\n): Client.HttpClient.With<E, R> => {\n  const client = self as HttpClientImpl<E, R>\n  return makeWith(\n    (request) => {\n      const loop = (\n        request: ClientRequest.HttpClientRequest,\n        redirects: number\n      ): Effect.Effect<ClientResponse.HttpClientResponse, E, R> =>\n        Effect.flatMap(\n          client.postprocess(Effect.succeed(request)),\n          (response) =>\n            response.status >= 300 && response.status < 400 && response.headers.location &&\n              redirects < (maxRedirects ?? 10)\n              ? loop(\n                internalRequest.setUrl(\n                  request,\n                  new URL(response.headers.location, response.request.url)\n                ),\n                redirects + 1\n              )\n              : Effect.succeed(response)\n        )\n      return Effect.flatMap(request, (request) => loop(request, 0))\n    },\n    client.preprocess\n  )\n})\n\n/** @internal */\nexport const layerMergedContext = <E, R>(\n  effect: Effect.Effect<Client.HttpClient, E, R>\n): Layer.Layer<Client.HttpClient, E, R> =>\n  Layer.effect(\n    tag,\n    Effect.flatMap(Effect.context<never>(), (context) =>\n      Effect.map(effect, (client) =>\n        transformResponse(\n          client,\n          Effect.mapInputContext((input: Context.Context<never>) => Context.merge(context, input))\n        )))\n  )\n","/**\n * @since 1.0.0\n */\nimport type * as Effect from \"effect/Effect\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as Stream_ from \"effect/Stream\"\nimport type * as PlatformError from \"./Error.js\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport * as internal from \"./internal/httpBody.js\"\nimport type * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHttpBody = (u: unknown): u is HttpBody => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type HttpBody = Empty | Raw | Uint8Array | FormData | Stream\n\n/**\n * @since 1.0.0\n */\nexport declare namespace HttpBody {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Proto extends Inspectable {\n    readonly [TypeId]: TypeId\n    readonly _tag: string\n    readonly contentType?: string | undefined\n    readonly contentLength?: number | undefined\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface FileLike {\n    readonly name: string\n    readonly lastModified: number\n    readonly size: number\n    readonly stream: () => unknown\n    readonly type: string\n  }\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const ErrorTypeId: unique symbol = internal.ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport interface HttpBodyError {\n  readonly [ErrorTypeId]: ErrorTypeId\n  readonly _tag: \"HttpBodyError\"\n  readonly reason: ErrorReason\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport const HttpBodyError: (reason: ErrorReason) => HttpBodyError = internal.HttpBodyError\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport type ErrorReason = {\n  readonly _tag: \"JsonError\"\n  readonly error: unknown\n} | {\n  readonly _tag: \"SchemaError\"\n  readonly error: ParseResult.ParseError\n}\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Empty extends HttpBody.Proto {\n  readonly _tag: \"Empty\"\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: Empty = internal.empty\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Raw extends HttpBody.Proto {\n  readonly _tag: \"Raw\"\n  readonly body: unknown\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const raw: (\n  body: unknown,\n  options?: {\n    readonly contentType?: string | undefined\n    readonly contentLength?: number | undefined\n  } | undefined\n) => Raw = internal.raw\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Uint8Array extends HttpBody.Proto {\n  readonly _tag: \"Uint8Array\"\n  readonly body: globalThis.Uint8Array\n  readonly contentType: string\n  readonly contentLength: number\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const uint8Array: (body: globalThis.Uint8Array, contentType?: string) => Uint8Array = internal.uint8Array\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const text: (body: string, contentType?: string) => Uint8Array = internal.text\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeJson: (body: unknown) => Uint8Array = internal.unsafeJson\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const json: (body: unknown) => Effect.Effect<Uint8Array, HttpBodyError> = internal.json\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const jsonSchema: <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) => (body: A) => Effect.Effect<Uint8Array, HttpBodyError, R> = internal.jsonSchema\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const urlParams: (urlParams: UrlParams.UrlParams) => Uint8Array = internal.urlParams\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface FormData extends HttpBody.Proto {\n  readonly _tag: \"FormData\"\n  readonly formData: globalThis.FormData\n}\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport const formData: (body: globalThis.FormData) => FormData = internal.formData\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport type FormDataInput = Record<string, FormDataCoercible | ReadonlyArray<FormDataCoercible>>\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport type FormDataCoercible = string | number | boolean | File | Blob | null | undefined\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport const formDataRecord: (entries: FormDataInput) => FormData = internal.formDataRecord\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Stream extends HttpBody.Proto {\n  readonly _tag: \"Stream\"\n  readonly stream: Stream_.Stream<globalThis.Uint8Array, unknown>\n  readonly contentType: string\n  readonly contentLength?: number | undefined\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const stream: (\n  body: Stream_.Stream<globalThis.Uint8Array, unknown>,\n  contentType?: string,\n  contentLength?: number\n) => Stream = internal.stream\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const file: (\n  path: string,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n) => Effect.Effect<Stream, PlatformError.PlatformError, FileSystem.FileSystem> = internal.file\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fileInfo: (\n  path: string,\n  info: FileSystem.File.Info,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n) => Effect.Effect<Stream, PlatformError.PlatformError, FileSystem.FileSystem> = internal.fileInfo\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fileWeb: (file: HttpBody.FileLike) => Stream = internal.fileWeb\n","import * as Worker from \"@effect/platform/Worker\"\nimport { WorkerError } from \"@effect/platform/WorkerError\"\nimport * as Deferred from \"effect/Deferred\"\nimport * as Effect from \"effect/Effect\"\nimport * as Layer from \"effect/Layer\"\nimport * as Scope from \"effect/Scope\"\n\nconst platformWorkerImpl = Worker.makePlatform<globalThis.SharedWorker | globalThis.Worker | MessagePort>()({\n  setup({ scope, worker }) {\n    const port = \"port\" in worker ? worker.port : worker\n    return Effect.as(\n      Scope.addFinalizer(\n        scope,\n        Effect.sync(() => {\n          port.postMessage([1])\n        })\n      ),\n      port\n    )\n  },\n  listen({ deferred, emit, port, scope }) {\n    function onMessage(event: MessageEvent) {\n      emit(event.data)\n    }\n    function onError(event: ErrorEvent) {\n      Deferred.unsafeDone(\n        deferred,\n        new WorkerError({ reason: \"unknown\", cause: event.error ?? event.message })\n      )\n    }\n    port.addEventListener(\"message\", onMessage as any)\n    port.addEventListener(\"error\", onError as any)\n    if (\"start\" in port) {\n      port.start()\n    }\n    return Scope.addFinalizer(\n      scope,\n      Effect.sync(() => {\n        port.removeEventListener(\"message\", onMessage as any)\n        port.removeEventListener(\"error\", onError as any)\n      })\n    )\n  }\n})\n\n/** @internal */\nexport const layerWorker = Layer.succeed(Worker.PlatformWorker, platformWorkerImpl)\n\n/** @internal */\nexport const layerManager = Layer.provide(Worker.layerManager, layerWorker)\n\n/** @internal */\nexport const layer = (spawn: (id: number) => globalThis.Worker | globalThis.SharedWorker | MessagePort) =>\n  Layer.merge(layerManager, Worker.layerSpawner(spawn))\n\n/** @internal */\nexport const layerPlatform = (spawn: (id: number) => globalThis.Worker | globalThis.SharedWorker | MessagePort) =>\n  Layer.merge(layerWorker, Worker.layerSpawner(spawn))\n","import type { Cause } from \"../Cause.js\"\nimport * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport type { Effect, Semaphore } from \"../Effect.js\"\nimport * as Effectable from \"../Effectable.js\"\nimport type { Exit } from \"../Exit.js\"\nimport { dual, identity } from \"../Function.js\"\nimport * as Iterable from \"../Iterable.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type { Pool, PoolTypeId as PoolTypeId_ } from \"../Pool.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type { Scope } from \"../Scope.js\"\nimport * as coreEffect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport * as circular from \"./effect/circular.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as internalQueue from \"./queue.js\"\n\n/** @internal */\nexport const PoolTypeId: PoolTypeId_ = Symbol.for(\"effect/Pool\") as PoolTypeId_\n\nconst poolVariance = {\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nexport const isPool = (u: unknown): u is Pool<unknown, unknown> => hasProperty(u, PoolTypeId)\n\n/** @internal */\nexport const makeWith = <A, E, R>(options: {\n  readonly acquire: Effect<A, E, R>\n  readonly min: number\n  readonly max: number\n  readonly concurrency?: number | undefined\n  readonly targetUtilization?: number | undefined\n  readonly strategy: Strategy<A, E>\n}): Effect<Pool<A, E>, never, Scope | R> =>\n  core.uninterruptibleMask((restore) =>\n    core.flatMap(core.context<R | Scope>(), (context) => {\n      const scope = Context.get(context, fiberRuntime.scopeTag)\n      const acquire = core.mapInputContext(\n        options.acquire,\n        (input) => Context.merge(context, input)\n      ) as Effect<\n        A,\n        E,\n        Scope\n      >\n      const pool = new PoolImpl<A, E>(\n        scope,\n        acquire,\n        options.concurrency ?? 1,\n        options.min,\n        options.max,\n        options.strategy,\n        Math.min(Math.max(options.targetUtilization ?? 1, 0.1), 1)\n      )\n      const initialize = core.tap(fiberRuntime.forkDaemon(restore(pool.resize)), (fiber) =>\n        scope.addFinalizer(() => core.interruptFiber(fiber)))\n      const runStrategy = core.tap(fiberRuntime.forkDaemon(restore(options.strategy.run(pool))), (fiber) =>\n        scope.addFinalizer(() =>\n          core.interruptFiber(fiber)\n        ))\n      return core.succeed(pool).pipe(\n        core.zipLeft(scope.addFinalizer(() =>\n          pool.shutdown\n        )),\n        core.zipLeft(initialize),\n        core.zipLeft(runStrategy)\n      )\n    })\n  )\n\n/** @internal */\nexport const make = <A, E, R>(options: {\n  readonly acquire: Effect<A, E, R>\n  readonly size: number\n  readonly concurrency?: number | undefined\n  readonly targetUtilization?: number | undefined\n}): Effect<Pool<A, E>, never, R | Scope> =>\n  makeWith({ ...options, min: options.size, max: options.size, strategy: strategyNoop() })\n\n/** @internal */\nexport const makeWithTTL = <A, E, R>(options: {\n  readonly acquire: Effect<A, E, R>\n  readonly min: number\n  readonly max: number\n  readonly concurrency?: number | undefined\n  readonly targetUtilization?: number | undefined\n  readonly timeToLive: Duration.DurationInput\n  readonly timeToLiveStrategy?: \"creation\" | \"usage\" | undefined\n}): Effect<Pool<A, E>, never, R | Scope> =>\n  core.flatMap(\n    options.timeToLiveStrategy === \"creation\" ?\n      strategyCreationTTL<A, E>(options.timeToLive) :\n      strategyUsageTTL<A, E>(options.timeToLive),\n    (strategy) => makeWith({ ...options, strategy })\n  )\n\n/** @internal */\nexport const get = <A, E>(self: Pool<A, E>): Effect<A, E, Scope> => self.get\n\n/** @internal */\nexport const invalidate: {\n  <A>(item: A): <E>(self: Pool<A, E>) => Effect<void>\n  <A, E>(self: Pool<A, E>, item: A): Effect<void>\n} = dual(2, <A, E>(self: Pool<A, E>, item: A): Effect<void> => self.invalidate(item))\n\ninterface PoolItem<A, E> {\n  readonly exit: Exit<A, E>\n  finalizer: Effect<void>\n  refCount: number\n  disableReclaim: boolean\n}\n\ninterface Strategy<A, E> {\n  readonly run: (pool: PoolImpl<A, E>) => Effect<void>\n  readonly onAcquire: (item: PoolItem<A, E>) => Effect<void>\n  readonly reclaim: (pool: PoolImpl<A, E>) => Effect<Option.Option<PoolItem<A, E>>>\n}\n\nclass PoolImpl<A, E> extends Effectable.Class<A, E, Scope> implements Pool<A, E> {\n  readonly [PoolTypeId]: Pool.Variance<A, E>[PoolTypeId_]\n\n  isShuttingDown = false\n  readonly semaphore: Semaphore\n  readonly items = new Set<PoolItem<A, E>>()\n  readonly available = new Set<PoolItem<A, E>>()\n  readonly availableLatch = circular.unsafeMakeLatch(false)\n  readonly invalidated = new Set<PoolItem<A, E>>()\n  waiters = 0\n\n  constructor(\n    readonly scope: Scope,\n    readonly acquire: Effect<A, E, Scope>,\n    readonly concurrency: number,\n    readonly minSize: number,\n    readonly maxSize: number,\n    readonly strategy: Strategy<A, E>,\n    readonly targetUtilization: number\n  ) {\n    super()\n    this[PoolTypeId] = poolVariance\n    this.semaphore = circular.unsafeMakeSemaphore(concurrency * maxSize)\n  }\n\n  readonly allocate: Effect<PoolItem<A, E>> = core.acquireUseRelease(\n    fiberRuntime.scopeMake(),\n    (scope) =>\n      this.acquire.pipe(\n        fiberRuntime.scopeExtend(scope),\n        core.exit,\n        core.flatMap((exit) => {\n          const item: PoolItem<A, E> = {\n            exit,\n            finalizer: core.catchAllCause(scope.close(exit), reportUnhandledError),\n            refCount: 0,\n            disableReclaim: false\n          }\n          this.items.add(item)\n          this.available.add(item)\n          return core.as(\n            exit._tag === \"Success\"\n              ? this.strategy.onAcquire(item)\n              : core.zipRight(item.finalizer, this.strategy.onAcquire(item)),\n            item\n          )\n        })\n      ),\n    (scope, exit) => exit._tag === \"Failure\" ? scope.close(exit) : core.void\n  )\n\n  get currentUsage() {\n    let count = this.waiters\n    for (const item of this.items) {\n      count += item.refCount\n    }\n    return count\n  }\n\n  get targetSize() {\n    if (this.isShuttingDown) return 0\n    const utilization = this.currentUsage / this.targetUtilization\n    const target = Math.ceil(utilization / this.concurrency)\n    return Math.min(Math.max(this.minSize, target), this.maxSize)\n  }\n\n  get activeSize() {\n    return this.items.size - this.invalidated.size\n  }\n\n  readonly resizeLoop: Effect<void> = core.suspend(() => {\n    if (this.activeSize >= this.targetSize) {\n      return core.void\n    }\n    const toAcquire = this.targetSize - this.activeSize\n    return this.strategy.reclaim(this).pipe(\n      core.flatMap(Option.match({\n        onNone: () => this.allocate,\n        onSome: core.succeed\n      })),\n      fiberRuntime.replicateEffect(toAcquire, { concurrency: toAcquire }),\n      core.zipLeft(this.availableLatch.open),\n      core.flatMap((items) => items.some((_) => _.exit._tag === \"Failure\") ? core.void : this.resizeLoop)\n    )\n  })\n  readonly resizeSemaphore = circular.unsafeMakeSemaphore(1)\n  readonly resize = this.resizeSemaphore.withPermits(1)(this.resizeLoop)\n\n  readonly getPoolItem: Effect<PoolItem<A, E>, never, Scope> = core.uninterruptibleMask((restore) =>\n    restore(this.semaphore.take(1)).pipe(\n      core.zipRight(fiberRuntime.scopeTag),\n      core.flatMap((scope) =>\n        core.suspend(() => {\n          this.waiters++\n          if (this.isShuttingDown) {\n            return core.interrupt\n          } else if (this.targetSize > this.activeSize) {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const self = this\n            return core.flatMap(\n              this.resizeSemaphore.withPermitsIfAvailable(1)(\n                circular.forkIn(core.interruptible(this.resize), this.scope)\n              ),\n              function loop(): Effect<PoolItem<A, E>> {\n                if (self.isShuttingDown) {\n                  return core.interrupt\n                } else if (self.available.size > 0) {\n                  return core.succeed(Iterable.unsafeHead(self.available))\n                }\n                self.availableLatch.unsafeClose()\n                return core.flatMap(self.availableLatch.await, loop)\n              }\n            )\n          }\n          return core.succeed(Iterable.unsafeHead(this.available))\n        }).pipe(\n          fiberRuntime.ensuring(core.sync(() => this.waiters--)),\n          core.tap((item) => {\n            if (item.exit._tag === \"Failure\") {\n              this.items.delete(item)\n              this.invalidated.delete(item)\n              this.available.delete(item)\n              return this.semaphore.release(1)\n            }\n            item.refCount++\n            this.available.delete(item)\n            if (item.refCount < this.concurrency) {\n              this.available.add(item)\n            }\n            return scope.addFinalizer(() =>\n              core.zipRight(\n                core.suspend(() => {\n                  item.refCount--\n                  if (this.invalidated.has(item)) {\n                    return this.invalidatePoolItem(item)\n                  }\n                  this.available.add(item)\n                  return core.exitVoid\n                }),\n                this.semaphore.release(1)\n              )\n            )\n          }),\n          core.onInterrupt(() => this.semaphore.release(1))\n        )\n      )\n    )\n  )\n\n  commit() {\n    return this.get\n  }\n\n  readonly get: Effect<A, E, Scope> = core.flatMap(\n    core.suspend(() => this.isShuttingDown ? core.interrupt : this.getPoolItem),\n    (_) => _.exit\n  )\n\n  invalidate(item: A): Effect<void> {\n    return core.suspend(() => {\n      if (this.isShuttingDown) return core.void\n      for (const poolItem of this.items) {\n        if (poolItem.exit._tag === \"Success\" && poolItem.exit.value === item) {\n          poolItem.disableReclaim = true\n          return core.uninterruptible(this.invalidatePoolItem(poolItem))\n        }\n      }\n      return core.void\n    })\n  }\n\n  invalidatePoolItem(poolItem: PoolItem<A, E>): Effect<void> {\n    return core.suspend(() => {\n      if (!this.items.has(poolItem)) {\n        return core.void\n      } else if (poolItem.refCount === 0) {\n        this.items.delete(poolItem)\n        this.available.delete(poolItem)\n        this.invalidated.delete(poolItem)\n        return core.zipRight(\n          poolItem.finalizer,\n          circular.forkIn(core.interruptible(this.resize), this.scope)\n        )\n      }\n      this.invalidated.add(poolItem)\n      this.available.delete(poolItem)\n      return core.void\n    })\n  }\n\n  get shutdown(): Effect<void> {\n    return core.suspend(() => {\n      if (this.isShuttingDown) return core.void\n      this.isShuttingDown = true\n      const size = this.items.size\n      const semaphore = circular.unsafeMakeSemaphore(size)\n      return core.forEachSequentialDiscard(this.items, (item) => {\n        if (item.refCount > 0) {\n          item.finalizer = core.zipLeft(item.finalizer, semaphore.release(1))\n          this.invalidated.add(item)\n          return semaphore.take(1)\n        }\n        this.items.delete(item)\n        this.available.delete(item)\n        this.invalidated.delete(item)\n        return item.finalizer\n      }).pipe(\n        core.zipRight(this.semaphore.releaseAll),\n        core.zipRight(this.availableLatch.open),\n        core.zipRight(semaphore.take(size))\n      )\n    })\n  }\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst strategyNoop = <A, E>(): Strategy<A, E> => ({\n  run: (_) => core.void,\n  onAcquire: (_) => core.void,\n  reclaim: (_) => coreEffect.succeedNone\n})\n\nconst strategyCreationTTL = <A, E>(ttl: Duration.DurationInput) =>\n  defaultServices.clockWith((clock) =>\n    core.map(internalQueue.unbounded<PoolItem<A, E>>(), (queue) => {\n      const ttlMillis = Duration.toMillis(ttl)\n      const creationTimes = new WeakMap<PoolItem<A, E>, number>()\n      return identity<Strategy<A, E>>({\n        run: (pool) => {\n          const process = (item: PoolItem<A, E>): Effect<void> =>\n            core.suspend(() => {\n              if (!pool.items.has(item) || pool.invalidated.has(item)) {\n                return core.void\n              }\n              const now = clock.unsafeCurrentTimeMillis()\n              const created = creationTimes.get(item)!\n              const remaining = ttlMillis - (now - created)\n              return remaining > 0\n                ? coreEffect.delay(process(item), remaining)\n                : pool.invalidatePoolItem(item)\n            })\n          return queue.take.pipe(\n            core.tap(process),\n            coreEffect.forever\n          )\n        },\n        onAcquire: (item) =>\n          core.suspend(() => {\n            creationTimes.set(item, clock.unsafeCurrentTimeMillis())\n            return queue.offer(item)\n          }),\n        reclaim: (_) => coreEffect.succeedNone\n      })\n    })\n  )\n\nconst strategyUsageTTL = <A, E>(ttl: Duration.DurationInput) =>\n  core.map(internalQueue.unbounded<PoolItem<A, E>>(), (queue) => {\n    return identity<Strategy<A, E>>({\n      run: (pool) => {\n        const process: Effect<void> = core.suspend(() => {\n          const excess = pool.activeSize - pool.targetSize\n          if (excess <= 0) return core.void\n          return queue.take.pipe(\n            core.tap((item) => pool.invalidatePoolItem(item)),\n            core.zipRight(process)\n          )\n        })\n        return process.pipe(\n          coreEffect.delay(ttl),\n          coreEffect.forever\n        )\n      },\n      onAcquire: (item) => queue.offer(item),\n      reclaim(pool) {\n        return core.suspend((): Effect<Option.Option<PoolItem<A, E>>> => {\n          if (pool.invalidated.size === 0) {\n            return coreEffect.succeedNone\n          }\n          const item = Iterable.head(\n            Iterable.filter(pool.invalidated, (item) => !item.disableReclaim)\n          )\n          if (item._tag === \"None\") {\n            return coreEffect.succeedNone\n          }\n          pool.invalidated.delete(item.value)\n          if (item.value.refCount < pool.concurrency) {\n            pool.available.add(item.value)\n          }\n          return core.as(queue.offer(item.value), item)\n        })\n      }\n    })\n  })\n\nconst reportUnhandledError = <E>(cause: Cause<E>) =>\n  core.withFiberRuntime<void>((fiber) => {\n    const unhandledLogLevel = fiber.getFiberRef(core.currentUnhandledErrorLogLevel)\n    if (unhandledLogLevel._tag === \"Some\") {\n      fiber.log(\"Unhandled error in pool finalizer\", cause, unhandledLogLevel)\n    }\n    return core.void\n  })\n","/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport * as Context_ from \"effect/Context\"\nimport type { Effect } from \"effect/Effect\"\nimport type { Exit as Exit_ } from \"effect/Exit\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport type { ReadonlyMailbox } from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as PrimaryKey from \"effect/PrimaryKey\"\nimport * as Schema from \"effect/Schema\"\nimport type * as AST from \"effect/SchemaAST\"\nimport type { Stream } from \"effect/Stream\"\nimport type { NoInfer } from \"effect/Types\"\nimport type * as RpcMiddleware from \"./RpcMiddleware.js\"\nimport * as RpcSchema from \"./RpcSchema.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/rpc/Rpc\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isRpc = (u: unknown): u is Rpc<any, any, any> => Predicate.hasProperty(u, TypeId)\n\n/**\n * Represents an API endpoint. An API endpoint is mapped to a single route on\n * the underlying `HttpRouter`.\n *\n * @since 1.0.0\n * @category models\n */\nexport interface Rpc<\n  in out Tag extends string,\n  out Payload extends AnySchema = typeof Schema.Void,\n  out Success extends Schema.Schema.Any = typeof Schema.Void,\n  out Error extends Schema.Schema.All = typeof Schema.Never,\n  out Middleware extends RpcMiddleware.TagClassAny = never\n> extends Pipeable {\n  new(_: never): {}\n\n  readonly [TypeId]: TypeId\n  readonly _tag: Tag\n  readonly key: string\n  readonly payloadSchema: Payload\n  readonly successSchema: Success\n  readonly errorSchema: Error\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<Middleware>\n\n  /**\n   * Set the schema for the success response of the rpc.\n   */\n  setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<\n    Tag,\n    Payload,\n    S,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Set the schema for the error response of the rpc.\n   */\n  setError<E extends Schema.Schema.Any>(schema: E): Rpc<\n    Tag,\n    Payload,\n    Success,\n    E,\n    Middleware\n  >\n\n  /**\n   * Set the schema for the payload of the rpc.\n   */\n  setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(\n    schema: P\n  ): Rpc<\n    Tag,\n    P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never,\n    Success,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Add an `RpcMiddleware` to this procedure.\n   */\n  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<\n    Tag,\n    Payload,\n    Success,\n    Error,\n    Middleware | M\n  >\n\n  /**\n   * Set the schema for the error response of the rpc.\n   */\n  prefix<const Prefix extends string>(prefix: Prefix): Rpc<\n    `${Prefix}${Tag}`,\n    Payload,\n    Success,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Add an annotation on the rpc.\n   */\n  annotate<I, S>(\n    tag: Context_.Tag<I, S>,\n    value: S\n  ): Rpc<Tag, Payload, Success, Error, Middleware>\n\n  /**\n   * Merge the annotations of the rpc with the provided context.\n   */\n  annotateContext<I>(\n    context: Context_.Context<I>\n  ): Rpc<Tag, Payload, Success, Error, Middleware>\n}\n\n/**\n * Represents an implemented rpc.\n *\n * @since 1.0.0\n * @category models\n */\nexport interface Handler<Tag extends string> {\n  readonly _: unique symbol\n  readonly tag: Tag\n  readonly handler: (request: any, options: {\n    readonly clientId: number\n    readonly headers: Headers\n  }) => Effect<any, any> | Stream<any, any>\n  readonly context: Context<never>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Any extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly _tag: string\n  readonly key: string\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface AnyWithProps {\n  readonly [TypeId]: TypeId\n  readonly _tag: string\n  readonly key: string\n  readonly payloadSchema: AnySchema\n  readonly successSchema: Schema.Schema.Any\n  readonly errorSchema: Schema.Schema.All\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<RpcMiddleware.TagClassAnyWithProps>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Tag<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Tag\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Success<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Success[\"Type\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessEncoded<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Success[\"Encoded\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessExit<R> = Success<R> extends infer T ? T extends Stream<infer _A, infer _E, infer _Env> ? void : T\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessExitEncoded<R> = SuccessEncoded<R> extends infer T ?\n  T extends Stream<infer _A, infer _E, infer _Env> ? void : T\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessChunk<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessChunkEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorSchema<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Error | _Middleware\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Error<R> = Schema.Schema.Type<ErrorSchema<R>>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorEncoded<R> = Schema.Schema.Encoded<ErrorSchema<R>>\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorExit<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _E | Error<R> : Error<R>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorExitEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env>\n  ? _E | ErrorEncoded<R>\n  : ErrorEncoded<R>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Exit<R> = Exit_<SuccessExit<R>, ErrorExit<R>>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExitEncoded<R, Defect = unknown> = Schema.ExitEncoded<SuccessExitEncoded<R>, ErrorExitEncoded<R>, Defect>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type PayloadConstructor<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ?\n  _Payload extends { readonly fields: Schema.Struct.Fields } ?\n    Schema.Simplify<Schema.Struct.Constructor<_Payload[\"fields\"]>>\n  : _Payload[\"Type\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Payload<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Payload[\"Type\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Context<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Middleware<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Context_.Tag.Identifier<_Middleware>\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type MiddlewareClient<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ?\n  _Middleware extends { readonly requiredForClient: true }\n    ? RpcMiddleware.ForClient<Context_.Tag.Identifier<_Middleware>>\n  : never\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type AddError<R extends Any, Error extends Schema.Schema.All> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Rpc<\n    _Tag,\n    _Payload,\n    _Success,\n    _Error | Error,\n    _Middleware\n  > :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type AddMiddleware<R extends Any, Middleware extends RpcMiddleware.TagClassAny> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Rpc<\n    _Tag,\n    _Payload,\n    _Success,\n    _Error,\n    _Middleware | Middleware\n  > :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ToHandler<R extends Any> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Handler<_Tag> :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ToHandlerFn<Current extends Any, R = any> = (\n  payload: Payload<Current>,\n  options: {\n    readonly clientId: number\n    readonly headers: Headers\n  }\n) => ResultFrom<Current, R> | Wrapper<ResultFrom<Current, R>>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type IsStream<R extends Any, Tag extends string> = R extends\n  Rpc<Tag, infer _Payload, RpcSchema.Stream<infer _A, infer _E>, infer _Error, infer _Middleware> ? true : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExtractTag<R extends Any, Tag extends string> = R extends\n  Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? R : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExtractProvides<R extends Any, Tag extends string> = R extends\n  Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Middleware extends {\n    readonly provides: Context_.Tag<infer _I, infer _S>\n  } ? _I :\n  never :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExcludeProvides<Env, R extends Any, Tag extends string> = Exclude<\n  Env,\n  ExtractProvides<R, Tag>\n>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface From<S extends AnyTaggedRequestSchema> extends Rpc<S[\"_tag\"], S, S[\"success\"], S[\"failure\"]> {}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ResultFrom<R extends Any, Context> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? [_Success] extends [RpcSchema.Stream<infer _SA, infer _SE>] ?\n      | Stream<\n        _SA[\"Type\"],\n        _SE[\"Type\"] | _Error[\"Type\"],\n        Context\n      >\n      | Effect<\n        ReadonlyMailbox<_SA[\"Type\"], _SE[\"Type\"] | _Error[\"Type\"]>,\n        _SE[\"Type\"] | Schema.Schema.Type<_Error>,\n        Context\n      > :\n  Effect<\n    _Success[\"Type\"],\n    _Error[\"Type\"],\n    Context\n  > :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Prefixed<Rpcs extends Any, Prefix extends string> = Rpcs extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Rpc<\n    `${Prefix}${_Tag}`,\n    _Payload,\n    _Success,\n    _Error,\n    _Middleware\n  >\n  : never\n\nconst Proto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  setSuccess(\n    this: AnyWithProps,\n    successSchema: Schema.Schema.Any\n  ) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  setError(this: AnyWithProps, errorSchema: Schema.Schema.All) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  setPayload(this: AnyWithProps, payloadSchema: Schema.Struct<any> | Schema.Struct.Fields) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: Schema.isSchema(payloadSchema) ? payloadSchema as any : Schema.Struct(payloadSchema as any),\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  middleware(this: AnyWithProps, middleware: RpcMiddleware.TagClassAny) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: new Set([...this.middlewares, middleware])\n    })\n  },\n  prefix(this: AnyWithProps, prefix: string) {\n    return makeProto({\n      _tag: `${prefix}${this._tag}`,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  annotate(this: AnyWithProps, tag: Context_.Tag<any, any>, value: any) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      middlewares: this.middlewares,\n      annotations: Context_.add(this.annotations, tag, value)\n    })\n  },\n  annotateContext(this: AnyWithProps, context: Context_.Context<any>) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      middlewares: this.middlewares,\n      annotations: Context_.merge(this.annotations, context)\n    })\n  }\n}\n\nconst makeProto = <\n  const Tag extends string,\n  Payload extends Schema.Schema.Any,\n  Success extends Schema.Schema.Any,\n  Error extends Schema.Schema.All,\n  Middleware extends RpcMiddleware.TagClassAny\n>(options: {\n  readonly _tag: Tag\n  readonly payloadSchema: Payload\n  readonly successSchema: Success\n  readonly errorSchema: Error\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<Middleware>\n}): Rpc<Tag, Payload, Success, Error, Middleware> => {\n  function Rpc() {}\n  Object.setPrototypeOf(Rpc, Proto)\n  Object.assign(Rpc, options)\n  Rpc.key = `@effect/rpc/Rpc/${options._tag}`\n  return Rpc as any\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = <\n  const Tag extends string,\n  Payload extends Schema.Schema.Any | Schema.Struct.Fields = typeof Schema.Void,\n  Success extends Schema.Schema.Any = typeof Schema.Void,\n  Error extends Schema.Schema.All = typeof Schema.Never,\n  const Stream extends boolean = false\n>(tag: Tag, options?: {\n  readonly payload?: Payload\n  readonly success?: Success\n  readonly error?: Error\n  readonly stream?: Stream\n  readonly primaryKey?: [Payload] extends [Schema.Struct.Fields] ?\n    ((payload: Schema.Simplify<Schema.Struct.Type<NoInfer<Payload>>>) => string) :\n    never\n}): Rpc<\n  Tag,\n  Payload extends Schema.Struct.Fields ? Schema.Struct<Payload> : Payload,\n  Stream extends true ? RpcSchema.Stream<Success, Error> : Success,\n  Stream extends true ? typeof Schema.Never : Error\n> => {\n  const successSchema = options?.success ?? Schema.Void\n  const errorSchema = options?.error ?? Schema.Never\n  let payloadSchema: any\n  if (options?.primaryKey) {\n    payloadSchema = class Payload extends Schema.Class<Payload>(`@effect/rpc/Rpc/${tag}`)(options.payload as any) {\n      [PrimaryKey.symbol](): string {\n        return options.primaryKey!(this as any)\n      }\n    }\n  } else {\n    payloadSchema = Schema.isSchema(options?.payload)\n      ? options?.payload as any\n      : options?.payload\n      ? Schema.Struct(options?.payload as any)\n      : Schema.Void\n  }\n  return makeProto({\n    _tag: tag,\n    payloadSchema,\n    successSchema: options?.stream ?\n      RpcSchema.Stream({\n        success: successSchema,\n        failure: errorSchema\n      }) :\n      successSchema,\n    errorSchema: options?.stream ? Schema.Never : errorSchema,\n    annotations: Context_.empty(),\n    middlewares: new Set<never>()\n  }) as any\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport interface AnySchema extends Pipeable {\n  readonly [Schema.TypeId]: any\n  readonly Type: any\n  readonly Encoded: any\n  readonly Context: any\n  readonly make?: (params: any, ...rest: ReadonlyArray<any>) => any\n  readonly ast: AST.AST\n  readonly annotations: any\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport interface AnyTaggedRequestSchema extends AnySchema {\n  readonly _tag: string\n  readonly success: Schema.Schema.Any\n  readonly failure: Schema.Schema.All\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromTaggedRequest = <S extends AnyTaggedRequestSchema>(\n  schema: S\n): From<S> =>\n  makeProto({\n    _tag: schema._tag,\n    payloadSchema: schema as any,\n    successSchema: schema.success as any,\n    errorSchema: schema.failure,\n    annotations: Context_.empty(),\n    middlewares: new Set()\n  })\n\nconst exitSchemaCache = globalValue(\"@effect/rpc/Rpc/exitSchemaCache\", () => new WeakMap<Any, Schema.Schema.Any>())\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const exitSchema = <R extends Any>(\n  self: R\n): Schema.Schema<Exit<R>, ExitEncoded<R>, Context<R>> => {\n  if (exitSchemaCache.has(self)) {\n    return exitSchemaCache.get(self) as any\n  }\n  const rpc = self as any as AnyWithProps\n  const failures = new Set<Schema.Schema.All>([rpc.errorSchema])\n  const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)\n  if (Option.isSome(streamSchemas)) {\n    failures.add(streamSchemas.value.failure)\n  }\n  for (const middleware of rpc.middlewares) {\n    failures.add(middleware.failure)\n  }\n  const schema = Schema.Exit({\n    success: Option.isSome(streamSchemas) ? Schema.Void : rpc.successSchema,\n    failure: Schema.Union(...failures),\n    defect: Schema.Defect\n  })\n  exitSchemaCache.set(self, schema)\n  return schema as any\n}\n\n/**\n * @since 1.0.0\n * @category Wrapper\n */\nexport const WrapperTypeId: unique symbol = Symbol.for(\"@effect/rpc/Rpc/Wrapper\")\n\n/**\n * @since 1.0.0\n * @category Wrapper\n */\nexport type WrapperTypeId = typeof WrapperTypeId\n\n/**\n * @since 1.0.0\n * @category Wrapper\n */\nexport interface Wrapper<A> {\n  readonly [WrapperTypeId]: WrapperTypeId\n  readonly value: A\n  readonly fork: boolean\n  readonly uninterruptible: boolean\n}\n\n/**\n * @since 1.0.0\n * @category Wrapper\n */\nexport const isWrapper = (u: object): u is Wrapper<any> => WrapperTypeId in u\n\n/**\n * @since 1.0.0\n * @category Wrapper\n */\nexport const wrap = (options: {\n  readonly fork?: boolean | undefined\n  readonly uninterruptible?: boolean | undefined\n}) =>\n<A extends object>(value: A): A extends Wrapper<infer _> ? A : Wrapper<A> =>\n  (isWrapper(value) ?\n    {\n      [WrapperTypeId]: WrapperTypeId,\n      value: value.value,\n      fork: options.fork ?? value.fork,\n      uninterruptible: options.uninterruptible ?? value.uninterruptible\n    } :\n    {\n      [WrapperTypeId]: WrapperTypeId,\n      value,\n      fork: options.fork ?? false,\n      uninterruptible: options.uninterruptible ?? false\n    }) as any\n\n/**\n * You can use `fork` to wrap a response Effect or Stream, to ensure that the\n * response is executed concurrently regardless of the RpcServer concurrency\n * setting.\n *\n * @since 1.0.0\n * @category Wrapper\n */\nexport const fork: <A extends object>(value: A) => A extends Wrapper<infer _> ? A : Wrapper<A> = wrap({ fork: true })\n\n/**\n * You can use `uninterruptible` to wrap a response Effect or Stream, to ensure\n * that it is executed inside an uninterruptible region.\n *\n * @since 1.0.0\n * @category Wrapper\n */\nexport const uninterruptible: <A extends object>(value: A) => A extends Wrapper<infer _> ? A : Wrapper<A> = wrap({\n  uninterruptible: true\n})\n","import * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport * as Stream from \"effect/Stream\"\nimport type { Unify } from \"effect/Unify\"\nimport * as Cookies from \"../Cookies.js\"\nimport * as Headers from \"../Headers.js\"\nimport * as Error from \"../HttpClientError.js\"\nimport type * as ClientRequest from \"../HttpClientRequest.js\"\nimport type * as ClientResponse from \"../HttpClientResponse.js\"\nimport * as IncomingMessage from \"../HttpIncomingMessage.js\"\nimport * as UrlParams from \"../UrlParams.js\"\n\n/** @internal */\nexport const TypeId: ClientResponse.TypeId = Symbol.for(\"@effect/platform/HttpClientResponse\") as ClientResponse.TypeId\n\n/** @internal */\nexport const fromWeb = (\n  request: ClientRequest.HttpClientRequest,\n  source: globalThis.Response\n): ClientResponse.HttpClientResponse => new ClientResponseImpl(request, source)\n\nclass ClientResponseImpl extends Inspectable.Class implements ClientResponse.HttpClientResponse {\n  readonly [IncomingMessage.TypeId]: IncomingMessage.TypeId\n  readonly [TypeId]: ClientResponse.TypeId\n\n  constructor(\n    readonly request: ClientRequest.HttpClientRequest,\n    private readonly source: globalThis.Response\n  ) {\n    super()\n    this[IncomingMessage.TypeId] = IncomingMessage.TypeId\n    this[TypeId] = TypeId\n  }\n\n  toJSON(): unknown {\n    return IncomingMessage.inspect(this, {\n      _id: \"@effect/platform/HttpClientResponse\",\n      request: this.request.toJSON(),\n      status: this.status\n    })\n  }\n\n  get status(): number {\n    return this.source.status\n  }\n\n  get headers(): Headers.Headers {\n    return Headers.fromInput(this.source.headers as any)\n  }\n\n  cachedCookies?: Cookies.Cookies\n  get cookies(): Cookies.Cookies {\n    if (this.cachedCookies) {\n      return this.cachedCookies\n    }\n    return this.cachedCookies = Cookies.fromSetCookie(this.source.headers.getSetCookie())\n  }\n\n  get remoteAddress(): Option.Option<string> {\n    return Option.none()\n  }\n\n  get stream(): Stream.Stream<Uint8Array, Error.ResponseError> {\n    return this.source.body\n      ? Stream.fromReadableStream(() => this.source.body!, (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        }))\n      : Stream.fail(\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"EmptyBody\",\n          description: \"can not create stream from empty body\"\n        })\n      )\n  }\n\n  get json(): Effect.Effect<unknown, Error.ResponseError> {\n    return Effect.tryMap(this.text, {\n      try: (text) => text === \"\" ? null : JSON.parse(text) as unknown,\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    })\n  }\n\n  private textBody?: Effect.Effect<string, Error.ResponseError>\n  get text(): Effect.Effect<string, Error.ResponseError> {\n    return this.textBody ??= Effect.tryPromise({\n      try: () => this.source.text(),\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    }).pipe(Effect.cached, Effect.runSync)\n  }\n\n  get urlParamsBody(): Effect.Effect<UrlParams.UrlParams, Error.ResponseError> {\n    return Effect.flatMap(this.text, (_) =>\n      Effect.try({\n        try: () => UrlParams.fromInput(new URLSearchParams(_)),\n        catch: (cause) =>\n          new Error.ResponseError({\n            request: this.request,\n            response: this,\n            reason: \"Decode\",\n            cause\n          })\n      }))\n  }\n\n  private formDataBody?: Effect.Effect<FormData, Error.ResponseError>\n  get formData(): Effect.Effect<FormData, Error.ResponseError> {\n    return this.formDataBody ??= Effect.tryPromise({\n      try: () => this.source.formData(),\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    }).pipe(Effect.cached, Effect.runSync)\n  }\n\n  private arrayBufferBody?: Effect.Effect<ArrayBuffer, Error.ResponseError>\n  get arrayBuffer(): Effect.Effect<ArrayBuffer, Error.ResponseError> {\n    return this.arrayBufferBody ??= Effect.tryPromise({\n      try: () => this.source.arrayBuffer(),\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    }).pipe(Effect.cached, Effect.runSync)\n  }\n}\n\n/** @internal */\nexport const schemaJson = <\n  R,\n  I extends {\n    readonly status?: number | undefined\n    readonly headers?: Readonly<Record<string, string>> | undefined\n    readonly body?: unknown | undefined\n  },\n  A\n>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return (self: ClientResponse.HttpClientResponse): Effect.Effect<A, Error.ResponseError | ParseResult.ParseError, R> =>\n    Effect.flatMap(\n      self.json,\n      (body) =>\n        parse({\n          status: self.status,\n          headers: self.headers,\n          body\n        })\n    )\n}\n\n/** @internal */\nexport const schemaNoBody = <\n  R,\n  I extends {\n    readonly status?: number | undefined\n    readonly headers?: Readonly<Record<string, string>> | undefined\n  },\n  A\n>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return (self: ClientResponse.HttpClientResponse): Effect.Effect<A, ParseResult.ParseError, R> =>\n    parse({\n      status: self.status,\n      headers: self.headers\n    })\n}\n\n/** @internal */\nexport const stream = <E, R>(effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>) =>\n  Stream.unwrap(Effect.map(effect, (_) => _.stream))\n\n/** @internal */\nexport const matchStatus = dual<\n  <\n    const Cases extends {\n      readonly [status: number]: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"2xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"3xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"4xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"5xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly orElse: (_: ClientResponse.HttpClientResponse) => any\n    }\n  >(\n    cases: Cases\n  ) => (self: ClientResponse.HttpClientResponse) => Cases[keyof Cases] extends (_: any) => infer R ? Unify<R> : never,\n  <\n    const Cases extends {\n      readonly [status: number]: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"2xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"3xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"4xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"5xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly orElse: (_: ClientResponse.HttpClientResponse) => any\n    }\n  >(\n    self: ClientResponse.HttpClientResponse,\n    cases: Cases\n  ) => Cases[keyof Cases] extends (_: any) => infer R ? Unify<R> : never\n>(2, (self, cases) => {\n  const status = self.status\n  if (cases[status]) {\n    return cases[status](self)\n  } else if (status >= 200 && status < 300 && cases[\"2xx\"]) {\n    return cases[\"2xx\"](self)\n  } else if (status >= 300 && status < 400 && cases[\"3xx\"]) {\n    return cases[\"3xx\"](self)\n  } else if (status >= 400 && status < 500 && cases[\"4xx\"]) {\n    return cases[\"4xx\"](self)\n  } else if (status >= 500 && status < 600 && cases[\"5xx\"]) {\n    return cases[\"5xx\"](self)\n  }\n  return cases.orElse(self)\n})\n\n/** @internal */\nexport const filterStatus = dual<\n  (\n    f: (status: number) => boolean\n  ) => (\n    self: ClientResponse.HttpClientResponse\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.ResponseError>,\n  (\n    self: ClientResponse.HttpClientResponse,\n    f: (status: number) => boolean\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.ResponseError>\n>(\n  2,\n  (self, f) =>\n    Effect.suspend(() =>\n      f(self.status) ? Effect.succeed(self) : Effect.fail(\n        new Error.ResponseError({\n          response: self,\n          request: self.request,\n          reason: \"StatusCode\",\n          description: \"invalid status code\"\n        })\n      )\n    )\n)\n\n/** @internal */\nexport const filterStatusOk = (\n  self: ClientResponse.HttpClientResponse\n): Effect.Effect<ClientResponse.HttpClientResponse, Error.ResponseError> =>\n  self.status >= 200 && self.status < 300 ? Effect.succeed(self) : Effect.fail(\n    new Error.ResponseError({\n      response: self,\n      request: self.request,\n      reason: \"StatusCode\",\n      description: \"non 2xx status code\"\n    })\n  )\n","import type * as WorkerError_ from \"../WorkerError.js\"\n\n/** @internal */\nexport const WorkerErrorTypeId: WorkerError_.WorkerErrorTypeId = Symbol.for(\n  \"@effect/platform/WorkerError\"\n) as WorkerError_.WorkerErrorTypeId\n","import type * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\n\n/** @internal */\nexport const withRun = <\n  A extends {\n    readonly run: (f: (...args: Array<any>) => Effect.Effect<void>) => Effect.Effect<never>\n  }\n>() =>\n<EX, RX>(f: (write: Parameters<A[\"run\"]>[0]) => Effect.Effect<Omit<A, \"run\">, EX, RX>): Effect.Effect<A, EX, RX> =>\n  Effect.suspend(() => {\n    const semaphore = Effect.unsafeMakeSemaphore(1)\n    let buffer: Array<[Array<any>, Context.Context<never>]> = []\n    let write = (...args: Array<any>): Effect.Effect<void> =>\n      Effect.contextWith((context) => {\n        buffer.push([args, context])\n      })\n    return Effect.map(f((...args) => write(...args)), (a) => ({\n      ...a,\n      run(f) {\n        return semaphore.withPermits(1)(Effect.gen(function*() {\n          const prev = write\n          write = f\n\n          for (const [args, context] of buffer) {\n            yield* Effect.provide(write(...args), context)\n          }\n          buffer = []\n\n          return yield* Effect.onExit(Effect.never, () => {\n            write = prev\n            return Effect.void\n          })\n        }))\n      }\n    } as A))\n  })\n","/**\n * @since 1.0.0\n */\nimport * as Headers from \"@effect/platform/Headers\"\nimport * as HttpBody from \"@effect/platform/HttpBody\"\nimport * as HttpClient from \"@effect/platform/HttpClient\"\nimport * as HttpClientRequest from \"@effect/platform/HttpClientRequest\"\nimport * as Socket from \"@effect/platform/Socket\"\nimport * as Transferable from \"@effect/platform/Transferable\"\nimport * as Worker from \"@effect/platform/Worker\"\nimport type { WorkerError } from \"@effect/platform/WorkerError\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport * as Cause from \"effect/Cause\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport type * as Duration from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as Fiber from \"effect/Fiber\"\nimport * as FiberId from \"effect/FiberId\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { constVoid, dual, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport type { ParseError } from \"effect/ParseResult\"\nimport * as Pool from \"effect/Pool\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Schema from \"effect/Schema\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport type { Span } from \"effect/Tracer\"\nimport type { Mutable } from \"effect/Types\"\nimport { withRun } from \"./internal/utils.js\"\nimport * as Rpc from \"./Rpc.js\"\nimport { RpcClientError } from \"./RpcClientError.js\"\nimport type * as RpcGroup from \"./RpcGroup.js\"\nimport type { FromClient, FromClientEncoded, FromServer, FromServerEncoded, Request } from \"./RpcMessage.js\"\nimport { constPing, RequestId } from \"./RpcMessage.js\"\nimport type * as RpcMiddleware from \"./RpcMiddleware.js\"\nimport * as RpcSchema from \"./RpcSchema.js\"\nimport * as RpcSerialization from \"./RpcSerialization.js\"\nimport * as RpcWorker from \"./RpcWorker.js\"\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport type RpcClient<Rpcs extends Rpc.Any, E = never> = Schema.Simplify<\n  & RpcClient.From<RpcClient.NonPrefixed<Rpcs>, E, \"\">\n  & {\n    readonly [CurrentPrefix in RpcClient.Prefixes<Rpcs>]: RpcClient.From<\n      RpcClient.Prefixed<Rpcs, CurrentPrefix>,\n      E,\n      CurrentPrefix\n    >\n  }\n>\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport declare namespace RpcClient {\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type Prefixes<Rpcs extends Rpc.Any> = Rpcs[\"_tag\"] extends infer Tag\n    ? Tag extends `${infer Prefix}.${string}` ? Prefix : never\n    : never\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type NonPrefixed<Rpcs extends Rpc.Any> = Exclude<Rpcs, { readonly _tag: `${string}.${string}` }>\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type Prefixed<Rpcs extends Rpc.Any, Prefix extends string> = Extract<\n    Rpcs,\n    { readonly _tag: `${Prefix}.${string}` }\n  >\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type From<Rpcs extends Rpc.Any, E = never, Prefix extends string = \"\"> = {\n    readonly [\n      Current in Rpcs as Current[\"_tag\"] extends `${Prefix}.${infer Method}` ? Method\n        : Current[\"_tag\"]\n    ]: <\n      const AsMailbox extends boolean = false,\n      const Discard = false\n    >(\n      input: Rpc.PayloadConstructor<Current>,\n      options?: Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R> ? {\n          readonly asMailbox?: AsMailbox | undefined\n          readonly streamBufferSize?: number | undefined\n          readonly headers?: Headers.Input | undefined\n          readonly context?: Context.Context<never> | undefined\n        } :\n        {\n          readonly headers?: Headers.Input | undefined\n          readonly context?: Context.Context<never> | undefined\n          readonly discard?: Discard | undefined\n        }\n    ) => Current extends Rpc.Rpc<\n      infer _Tag,\n      infer _Payload,\n      infer _Success,\n      infer _Error,\n      infer _Middleware\n    > ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? AsMailbox extends true ? Effect.Effect<\n            Mailbox.ReadonlyMailbox<_A[\"Type\"], _E[\"Type\"] | _Error[\"Type\"] | E | _Middleware[\"failure\"][\"Type\"]>,\n            never,\n            | Scope.Scope\n            | _Payload[\"Context\"]\n            | _Success[\"Context\"]\n            | _Error[\"Context\"]\n            | _Middleware[\"failure\"][\"Context\"]\n          >\n        : Stream.Stream<\n          _A[\"Type\"],\n          _E[\"Type\"] | _Error[\"Type\"] | E | _Middleware[\"failure\"][\"Type\"],\n          _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"] | _Middleware[\"failure\"][\"Context\"]\n        >\n      : Effect.Effect<\n        Discard extends true ? void : _Success[\"Type\"],\n        Discard extends true ? E : _Error[\"Type\"] | E | _Middleware[\"failure\"][\"Type\"],\n        _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"] | _Middleware[\"failure\"][\"Context\"]\n      > :\n      never\n  }\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type Flat<Rpcs extends Rpc.Any, E = never> = <\n    const Tag extends Rpcs[\"_tag\"],\n    const AsMailbox extends boolean = false,\n    const Discard = false\n  >(\n    tag: Tag,\n    payload: Rpc.PayloadConstructor<Rpc.ExtractTag<Rpcs, Tag>>,\n    options?: Rpc.Success<Rpc.ExtractTag<Rpcs, Tag>> extends Stream.Stream<infer _A, infer _E, infer _R> ? {\n        readonly asMailbox?: AsMailbox | undefined\n        readonly streamBufferSize?: number | undefined\n        readonly headers?: Headers.Input | undefined\n        readonly context?: Context.Context<never> | undefined\n      } :\n      {\n        readonly headers?: Headers.Input | undefined\n        readonly context?: Context.Context<never> | undefined\n        readonly discard?: Discard | undefined\n      }\n  ) => Rpc.ExtractTag<Rpcs, Tag> extends Rpc.Rpc<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error,\n    infer _Middleware\n  > ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? AsMailbox extends true ? Effect.Effect<\n          Mailbox.ReadonlyMailbox<_A[\"Type\"], _E[\"Type\"] | _Error[\"Type\"] | E | _Middleware[\"failure\"][\"Type\"]>,\n          never,\n          | Scope.Scope\n          | _Payload[\"Context\"]\n          | _Success[\"Context\"]\n          | _Error[\"Context\"]\n          | _Middleware[\"failure\"][\"Context\"]\n        >\n      : Stream.Stream<\n        _A[\"Type\"],\n        _E[\"Type\"] | _Error[\"Type\"] | E | _Middleware[\"failure\"][\"Type\"],\n        _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"] | _Middleware[\"failure\"][\"Context\"]\n      >\n    : Effect.Effect<\n      Discard extends true ? void : _Success[\"Type\"],\n      Discard extends true ? E : _Error[\"Type\"] | E | _Middleware[\"failure\"][\"Type\"],\n      _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"] | _Middleware[\"failure\"][\"Context\"]\n    > :\n    never\n}\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport type FromGroup<Group, E = never> = RpcClient<RpcGroup.Rpcs<Group>, E>\n\nlet requestIdCounter = BigInt(0)\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport const makeNoSerialization: <Rpcs extends Rpc.Any, E, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly onFromClient: (\n      options: {\n        readonly message: FromClient<Rpcs>\n        readonly context: Context.Context<never>\n        readonly discard: boolean\n      }\n    ) => Effect.Effect<void, E>\n    readonly supportsAck?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  }\n) => Effect.Effect<\n  {\n    readonly client: Flatten extends true ? RpcClient.Flat<Rpcs, E> : RpcClient<Rpcs, E>\n    readonly write: (message: FromServer<Rpcs>) => Effect.Effect<void>\n  },\n  never,\n  Scope.Scope | Rpc.MiddlewareClient<Rpcs>\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any, E, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly onFromClient: (\n      options: {\n        readonly message: FromClient<Rpcs>\n        readonly context: Context.Context<never>\n        readonly discard: boolean\n      }\n    ) => Effect.Effect<void, E>\n    readonly supportsAck?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  }\n) {\n  const spanPrefix = options?.spanPrefix ?? \"RpcClient\"\n  const supportsAck = options?.supportsAck ?? true\n  const disableTracing = options?.disableTracing ?? false\n  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++ as RequestId)\n\n  const context = yield* Effect.context<Rpc.MiddlewareClient<Rpcs> | Scope.Scope>()\n  const scope = Context.get(context, Scope.Scope)\n\n  type ClientEntry = {\n    readonly _tag: \"Effect\"\n    readonly rpc: Rpc.AnyWithProps\n    readonly context: Context.Context<never>\n    resume: (_: Exit.Exit<any, any>) => void\n  } | {\n    readonly _tag: \"Mailbox\"\n    readonly rpc: Rpc.AnyWithProps\n    readonly mailbox: Mailbox.Mailbox<any, any>\n    readonly scope: Scope.Scope\n    readonly context: Context.Context<never>\n  }\n  const entries = new Map<RequestId, ClientEntry>()\n\n  let isShutdown = false\n  yield* Scope.addFinalizer(\n    scope,\n    Effect.fiberIdWith((fiberId) => {\n      isShutdown = true\n      return clearEntries(Exit.interrupt(fiberId))\n    })\n  )\n\n  const clearEntries = Effect.fnUntraced(function*(exit: Exit.Exit<never>) {\n    for (const [id, entry] of entries) {\n      entries.delete(id)\n      if (entry._tag === \"Mailbox\") {\n        yield* entry.mailbox.done(exit)\n      } else {\n        entry.resume(exit)\n      }\n    }\n  })\n\n  const onRequest = (rpc: Rpc.AnyWithProps) => {\n    const isStream = RpcSchema.isStreamSchema(rpc.successSchema)\n    const middleware = getRpcClientMiddleware(rpc)\n    return (payload: any, opts?: {\n      readonly asMailbox?: boolean | undefined\n      readonly streamBufferSize?: number | undefined\n      readonly headers?: Headers.Input | undefined\n      readonly context?: Context.Context<never> | undefined\n      readonly discard?: boolean | undefined\n    }) => {\n      const headers = opts?.headers ? Headers.fromInput(opts.headers) : Headers.empty\n      const context = opts?.context ?? Context.empty()\n      if (!isStream) {\n        const onRequest = (span: Span | undefined) =>\n          onEffectRequest(\n            rpc,\n            middleware,\n            span,\n            rpc.payloadSchema.make ? rpc.payloadSchema.make(payload) : payload,\n            headers,\n            context,\n            opts?.discard ?? false\n          )\n        return disableTracing ? onRequest(undefined) : Effect.useSpan(\n          `${spanPrefix}.${rpc._tag}`,\n          { captureStackTrace: false, attributes: options.spanAttributes },\n          onRequest\n        )\n      }\n      const mailbox = onStreamRequest(\n        rpc,\n        middleware,\n        rpc.payloadSchema.make ? rpc.payloadSchema.make(payload) : payload,\n        headers,\n        opts?.streamBufferSize ?? 16,\n        context\n      )\n      if (opts?.asMailbox) return mailbox\n      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream))\n    }\n  }\n\n  const onEffectRequest = (\n    rpc: Rpc.AnyWithProps,\n    middleware: (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>>,\n    span: Span | undefined,\n    payload: any,\n    headers: Headers.Headers,\n    context: Context.Context<never>,\n    discard: boolean\n  ) =>\n    Effect.withFiberRuntime<any, any, any>((parentFiber) => {\n      if (isShutdown) {\n        return Effect.interrupt\n      }\n      const id = generateRequestId()\n      const send = middleware({\n        _tag: \"Request\",\n        id,\n        tag: rpc._tag as Rpc.Tag<Rpcs>,\n        payload,\n        traceId: span?.traceId,\n        spanId: span?.spanId,\n        sampled: span?.sampled,\n        headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)\n      })\n      if (discard) {\n        return Effect.flatMap(send, (message) =>\n          options.onFromClient({\n            message,\n            context,\n            discard\n          }))\n      }\n      const runtime = Runtime.make({\n        context: parentFiber.currentContext,\n        fiberRefs: parentFiber.getFiberRefs(),\n        runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n      })\n      let fiber: Fiber.RuntimeFiber<any, any>\n      return Effect.onInterrupt(\n        Effect.async<any, any>((resume) => {\n          const entry: ClientEntry = {\n            _tag: \"Effect\",\n            rpc,\n            context,\n            resume(exit) {\n              resume(exit)\n              if (fiber && !fiber.unsafePoll()) {\n                parentFiber.currentScheduler.scheduleTask(() => {\n                  fiber.unsafeInterruptAsFork(parentFiber.id())\n                }, 0)\n              }\n            }\n          }\n          entries.set(id, entry)\n          fiber = send.pipe(\n            Effect.flatMap((request) =>\n              options.onFromClient({\n                message: request,\n                context,\n                discard\n              })\n            ),\n            span ? Effect.withParentSpan(span) : identity,\n            Runtime.runFork(runtime)\n          )\n          fiber.addObserver((exit) => {\n            if (exit._tag === \"Failure\") {\n              return resume(exit)\n            }\n          })\n        }),\n        (interruptors) => {\n          entries.delete(id)\n          const ids = Array.from(interruptors).flatMap((id) => Array.from(FiberId.toSet(id)))\n          return Effect.zipRight(\n            Fiber.interrupt(fiber),\n            sendInterrupt(id, ids, context)\n          )\n        }\n      )\n    })\n\n  const onStreamRequest = Effect.fnUntraced(function*(\n    rpc: Rpc.AnyWithProps,\n    middleware: (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>>,\n    payload: any,\n    headers: Headers.Headers,\n    streamBufferSize: number,\n    context: Context.Context<never>\n  ) {\n    if (isShutdown) {\n      return yield* Effect.interrupt\n    }\n\n    const span = disableTracing ? undefined : yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, {\n      captureStackTrace: false,\n      attributes: options.spanAttributes\n    })\n    const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n    const id = generateRequestId()\n\n    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope)\n    yield* Scope.addFinalizerExit(\n      scope,\n      (exit) => {\n        if (!entries.has(id)) return Effect.void\n        entries.delete(id)\n        return sendInterrupt(\n          id,\n          Exit.isFailure(exit)\n            ? Array.from(Cause.interruptors(exit.cause)).flatMap((id) => Array.from(FiberId.toSet(id)))\n            : [],\n          context\n        )\n      }\n    )\n\n    const mailbox = yield* Mailbox.make<any, any>(streamBufferSize)\n    entries.set(id, {\n      _tag: \"Mailbox\",\n      rpc,\n      mailbox,\n      scope,\n      context\n    })\n\n    yield* middleware({\n      _tag: \"Request\",\n      id,\n      tag: rpc._tag as Rpc.Tag<Rpcs>,\n      traceId: span?.traceId,\n      payload,\n      spanId: span?.spanId,\n      sampled: span?.sampled,\n      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)\n    }).pipe(\n      Effect.flatMap(\n        (request) =>\n          options.onFromClient({\n            message: request,\n            context,\n            discard: false\n          })\n      ),\n      span ? Effect.withParentSpan(span) : identity,\n      Effect.catchAllCause((error) => mailbox.failCause(error)),\n      Effect.interruptible,\n      Effect.forkIn(scope)\n    )\n\n    return mailbox\n  })\n\n  const getRpcClientMiddleware = (rpc: Rpc.AnyWithProps): (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>> => {\n    const middlewares: Array<RpcMiddleware.RpcMiddlewareClient> = []\n    for (const tag of rpc.middlewares.values()) {\n      const middleware = context.unsafeMap.get(`${tag.key}/Client`)\n      if (!middleware) continue\n      middlewares.push(middleware)\n    }\n    return middlewares.length === 0\n      ? Effect.succeed\n      : function(request) {\n        let i = 0\n        return Effect.map(\n          Effect.whileLoop({\n            while: () => i < middlewares.length,\n            body: () =>\n              middlewares[i]({\n                rpc,\n                request\n              }) as Effect.Effect<Request<Rpcs>>,\n            step(nextRequest) {\n              request = nextRequest\n              i++\n            }\n          }),\n          () => request\n        )\n      }\n  }\n\n  const sendInterrupt = (\n    requestId: RequestId,\n    interruptors: ReadonlyArray<FiberId.FiberId>,\n    context: Context.Context<never>\n  ): Effect.Effect<void> =>\n    Effect.async<void>((resume) => {\n      const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber())\n      const runtime = Runtime.make({\n        context: parentFiber.currentContext,\n        fiberRefs: parentFiber.getFiberRefs(),\n        runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n      })\n      const fiber = options.onFromClient({\n        message: { _tag: \"Interrupt\", requestId, interruptors },\n        context,\n        discard: false\n      }).pipe(\n        Effect.timeout(1000),\n        Runtime.runFork(runtime)\n      )\n      fiber.addObserver(() => {\n        resume(Effect.void)\n      })\n    })\n\n  const write = (message: FromServer<Rpcs>): Effect.Effect<void> => {\n    switch (message._tag) {\n      case \"Chunk\": {\n        const requestId = message.requestId\n        const entry = entries.get(requestId)\n        if (!entry || entry._tag !== \"Mailbox\") return Effect.void\n        return entry.mailbox.offerAll(message.values).pipe(\n          supportsAck\n            ? Effect.zipRight(\n              options.onFromClient({\n                message: { _tag: \"Ack\", requestId: message.requestId },\n                context: entry.context,\n                discard: false\n              })\n            )\n            : identity,\n          Effect.catchAllCause((cause) => entry.mailbox.done(Exit.failCause(cause)))\n        )\n      }\n      case \"Exit\": {\n        const requestId = message.requestId\n        const entry = entries.get(requestId)\n        if (!entry) return Effect.void\n        entries.delete(requestId)\n        if (entry._tag === \"Effect\") {\n          entry.resume(message.exit)\n          return Effect.void\n        }\n        return entry.mailbox.done(Exit.asVoid(message.exit))\n      }\n      case \"Defect\": {\n        return clearEntries(Exit.die(message.defect))\n      }\n      case \"ClientEnd\": {\n        return Effect.void\n      }\n    }\n  }\n\n  let client: any\n  if (options.flatten) {\n    const fns = new Map<string, any>()\n    client = function client(tag: string, payload: any, options?: {}) {\n      let fn = fns.get(tag)\n      if (!fn) {\n        fn = onRequest(group.requests.get(tag)! as any)\n        fns.set(tag, fn)\n      }\n      return fn(payload, options)\n    }\n  } else {\n    client = {}\n    for (const rpc of group.requests.values()) {\n      const dot = rpc._tag.indexOf(\".\")\n      const prefix = dot === -1 ? undefined : rpc._tag.slice(0, dot)\n      if (prefix !== undefined && !(prefix in client)) {\n        ;(client as any)[prefix] = {} as Mutable<RpcClient.Prefixed<Rpcs, typeof prefix>>\n      }\n      const target = prefix !== undefined ? (client as any)[prefix] : client\n      const tag = prefix !== undefined ? rpc._tag.slice(dot + 1) : rpc._tag\n      target[tag] = onRequest(rpc as any)\n    }\n  }\n\n  return { client, write } as const\n})\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport const make: <Rpcs extends Rpc.Any, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  } | undefined\n) => Effect.Effect<\n  Flatten extends true ? RpcClient.Flat<Rpcs, RpcClientError> : RpcClient<Rpcs, RpcClientError>,\n  never,\n  Protocol | Rpc.MiddlewareClient<Rpcs> | Scope.Scope\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  } | undefined\n) {\n  const { run, send, supportsAck, supportsTransferables } = yield* Protocol\n\n  type ClientEntry = {\n    readonly rpc: Rpc.AnyWithProps\n    readonly context: Context.Context<never>\n    readonly decodeChunk:\n      | ((chunk: ReadonlyArray<unknown>) => Effect.Effect<NonEmptyReadonlyArray<any>, ParseError, unknown>)\n      | undefined\n  }\n  const entries = new Map<RequestId, ClientEntry>()\n\n  const { client, write } = yield* makeNoSerialization(group, {\n    ...options,\n    supportsAck,\n    onFromClient({ message }) {\n      switch (message._tag) {\n        case \"Request\": {\n          const rpc = group.requests.get(message.tag)! as any as Rpc.AnyWithProps\n          const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)\n          const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined\n\n          const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n\n          const entry: ClientEntry = {\n            rpc,\n            context: collector\n              ? Context.add(fiber.currentContext, Transferable.Collector, collector)\n              : fiber.currentContext,\n            decodeChunk: Option.isSome(schemas)\n              ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success))\n              : undefined\n          }\n          entries.set(message.id, entry)\n\n          return Schema.encode(rpc.payloadSchema)(message.payload).pipe(\n            Effect.locally(FiberRef.currentContext, entry.context),\n            Effect.orDie,\n            Effect.flatMap((payload) =>\n              send({\n                ...message,\n                id: String(message.id),\n                payload,\n                headers: Object.entries(message.headers)\n              }, collector && collector.unsafeClear())\n            )\n          ) as Effect.Effect<void, RpcClientError>\n        }\n        case \"Ack\": {\n          const entry = entries.get(message.requestId)\n          if (!entry) return Effect.void\n          return send({\n            _tag: \"Ack\",\n            requestId: String(message.requestId)\n          }) as Effect.Effect<void, RpcClientError>\n        }\n        case \"Interrupt\": {\n          const entry = entries.get(message.requestId)\n          if (!entry) return Effect.void\n          entries.delete(message.requestId)\n          return send({\n            _tag: \"Interrupt\",\n            requestId: String(message.requestId)\n          }) as Effect.Effect<void, RpcClientError>\n        }\n        case \"Eof\": {\n          return Effect.void\n        }\n      }\n    }\n  })\n\n  yield* run((message) => {\n    switch (message._tag) {\n      case \"Chunk\": {\n        const requestId = RequestId(message.requestId)\n        const entry = entries.get(requestId)\n        if (!entry || !entry.decodeChunk) return Effect.void\n        return entry.decodeChunk(message.values).pipe(\n          Effect.locally(FiberRef.currentContext, entry.context),\n          Effect.orDie,\n          Effect.flatMap((chunk) =>\n            write({ _tag: \"Chunk\", clientId: 0, requestId: RequestId(message.requestId), values: chunk })\n          ),\n          Effect.onError((cause) =>\n            write({\n              _tag: \"Exit\",\n              clientId: 0,\n              requestId: RequestId(message.requestId),\n              exit: Exit.failCause(cause)\n            })\n          )\n        ) as Effect.Effect<void>\n      }\n      case \"Exit\": {\n        const requestId = RequestId(message.requestId)\n        const entry = entries.get(requestId)\n        if (!entry) return Effect.void\n        entries.delete(requestId)\n        return Schema.decode(Rpc.exitSchema(entry.rpc as any))(message.exit).pipe(\n          Effect.locally(FiberRef.currentContext, entry.context),\n          Effect.orDie,\n          Effect.matchCauseEffect({\n            onSuccess: (exit) => write({ _tag: \"Exit\", clientId: 0, requestId, exit }),\n            onFailure: (cause) => write({ _tag: \"Exit\", clientId: 0, requestId, exit: Exit.failCause(cause) })\n          })\n        ) as Effect.Effect<void>\n      }\n      case \"Defect\": {\n        return write({ _tag: \"Defect\", clientId: 0, defect: decodeDefect(message.defect) })\n      }\n      case \"ClientProtocolError\": {\n        const exit = Exit.fail(message.error)\n        return Effect.forEach(\n          entries.keys(),\n          (requestId) => write({ _tag: \"Exit\", clientId: 0, requestId, exit: exit as any })\n        )\n      }\n      default: {\n        return Effect.void\n      }\n    }\n  }).pipe(\n    Effect.catchAllCause(Effect.logError),\n    Effect.interruptible,\n    Effect.forkScoped\n  )\n\n  return client\n})\n\n/**\n * @since 1.0.0\n * @category headers\n */\nexport const currentHeaders: FiberRef.FiberRef<Headers.Headers> = globalValue(\n  \"@effect/rpc/RpcClient/currentHeaders\",\n  () => FiberRef.unsafeMake(Headers.empty)\n)\n\n/**\n * @since 1.0.0\n * @category headers\n */\nexport const withHeaders: {\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  (headers: Headers.Input): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R> =>\n    Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers)))\n)\n\n/**\n * @since 1.0.0\n * @category headers\n */\nexport const withHeadersEffect: {\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  <E2, R2>(headers: Effect.Effect<Headers.Input, E2, R2>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  <A, E, R, E2, R2>(\n    effect: Effect.Effect<A, E, R>,\n    headers: Effect.Effect<Headers.Input, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, E2, R2>(\n    effect: Effect.Effect<A, E, R>,\n    headers: Effect.Effect<Headers.Input, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2> => Effect.flatMap(headers, (headers) => withHeaders(effect, headers))\n)\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport class Protocol extends Context.Tag(\"@effect/rpc/RpcClient/Protocol\")<Protocol, {\n  readonly run: (\n    f: (data: FromServerEncoded) => Effect.Effect<void>\n  ) => Effect.Effect<never>\n  readonly send: (\n    request: FromClientEncoded,\n    transferables?: ReadonlyArray<globalThis.Transferable>\n  ) => Effect.Effect<void, RpcClientError>\n  readonly supportsAck: boolean\n  readonly supportsTransferables: boolean\n}>() {\n  /**\n   * @since 1.0.0\n   */\n  static make = withRun<Protocol[\"Type\"]>()\n}\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolHttp = (client: HttpClient.HttpClient): Effect.Effect<\n  Protocol[\"Type\"],\n  never,\n  RpcSerialization.RpcSerialization\n> =>\n  Protocol.make(Effect.fnUntraced(function*(writeResponse) {\n    const serialization = yield* RpcSerialization.RpcSerialization\n    const isJson = serialization.contentType === \"application/json\"\n\n    const send = (request: FromClientEncoded): Effect.Effect<void, RpcClientError> => {\n      if (request._tag !== \"Request\") {\n        return Effect.void\n      }\n\n      const parser = serialization.unsafeMake()\n\n      const encoded = parser.encode(request)!\n      const body = typeof encoded === \"string\" ?\n        HttpBody.text(encoded, serialization.contentType) :\n        HttpBody.uint8Array(encoded, serialization.contentType)\n\n      if (isJson) {\n        return client.post(\"\", { body }).pipe(\n          Effect.flatMap((r) => r.json),\n          Effect.mapError((cause) =>\n            new RpcClientError({\n              reason: \"Protocol\",\n              message: \"Failed to send HTTP request\",\n              cause\n            })\n          ),\n          Effect.flatMap((u) => {\n            if (!Array.isArray(u)) {\n              return Effect.dieMessage(`Expected an array of responses, but got: ${u}`)\n            }\n            let i = 0\n            return Effect.whileLoop({\n              while: () => i < u.length,\n              body: () => writeResponse(u[i++]),\n              step: constVoid\n            })\n          })\n        )\n      }\n\n      return client.post(\"\", { body }).pipe(\n        Effect.flatMap((r) =>\n          Stream.runForEachChunk(r.stream, (chunk) => {\n            const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode) as Array<FromServerEncoded>\n            if (responses.length === 0) return Effect.void\n            let i = 0\n            return Effect.whileLoop({\n              while: () => i < responses.length,\n              body: () => writeResponse(responses[i++]),\n              step: constVoid\n            })\n          })\n        ),\n        Effect.mapError((cause) =>\n          new RpcClientError({\n            reason: \"Protocol\",\n            message: \"Failed to send HTTP request\",\n            cause\n          })\n        )\n      )\n    }\n\n    return {\n      send,\n      supportsAck: false,\n      supportsTransferables: false\n    }\n  }))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolHttp = (options: {\n  readonly url: string\n  readonly transformClient?: <E, R>(client: HttpClient.HttpClient.With<E, R>) => HttpClient.HttpClient.With<E, R>\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient> =>\n  Layer.scoped(\n    Protocol,\n    Effect.flatMap(\n      HttpClient.HttpClient,\n      (client) => {\n        client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url))\n        return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client)\n      }\n    )\n  )\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolSocket = (options?: {\n  readonly retryTransientErrors?: boolean | undefined\n}): Effect.Effect<\n  Protocol[\"Type\"],\n  never,\n  Scope.Scope | RpcSerialization.RpcSerialization | Socket.Socket\n> =>\n  Protocol.make(Effect.fnUntraced(function*(writeResponse) {\n    const socket = yield* Socket.Socket\n    const serialization = yield* RpcSerialization.RpcSerialization\n    const write = yield* socket.writer\n    let parser = serialization.unsafeMake()\n    const pinger = yield* makePinger(write(parser.encode(constPing)!))\n\n    let currentError: RpcClientError | undefined\n    const clearCurrentError = Effect.sync(() => {\n      currentError = undefined\n    })\n\n    yield* Effect.suspend(() => {\n      parser = serialization.unsafeMake()\n      pinger.reset()\n      return socket.runRaw((message) => {\n        try {\n          const responses = parser.decode(message) as Array<FromServerEncoded>\n          if (responses.length === 0) return\n          let i = 0\n          return Effect.whileLoop({\n            while: () => i < responses.length,\n            body: () => {\n              const response = responses[i++]\n              if (response._tag === \"Pong\") {\n                pinger.onPong()\n              }\n              return writeResponse(response)\n            },\n            step: constVoid\n          })\n        } catch (defect) {\n          return writeResponse({\n            _tag: \"ClientProtocolError\",\n            error: new RpcClientError({\n              reason: \"Protocol\",\n              message: \"Error decoding message\",\n              cause: Cause.fail(defect)\n            })\n          })\n        }\n      }, { onOpen: clearCurrentError }).pipe(\n        Effect.raceFirst(Effect.zipRight(\n          pinger.timeout,\n          Effect.fail(\n            new Socket.SocketGenericError({\n              reason: \"OpenTimeout\",\n              cause: new Error(\"ping timeout\")\n            })\n          )\n        ))\n      )\n    }).pipe(\n      Effect.zipRight(Effect.fail(\n        new Socket.SocketCloseError({\n          reason: \"Close\",\n          code: 1000\n        })\n      )),\n      Effect.tapErrorCause((cause) => {\n        const error = Cause.failureOption(cause)\n        if (\n          options?.retryTransientErrors && Option.isSome(error) &&\n          (error.value.reason === \"Open\" || error.value.reason === \"OpenTimeout\")\n        ) {\n          return Effect.void\n        }\n        currentError = new RpcClientError({\n          reason: \"Protocol\",\n          message: \"Error in socket\",\n          cause: Cause.squash(cause)\n        })\n        return writeResponse({\n          _tag: \"ClientProtocolError\",\n          error: currentError\n        })\n      }),\n      Effect.retry(Schedule.spaced(1000)),\n      Effect.annotateLogs({\n        module: \"RpcClient\",\n        method: \"makeProtocolSocket\"\n      }),\n      Effect.interruptible,\n      Effect.forkScoped\n    )\n\n    return {\n      send(request) {\n        if (currentError) {\n          return Effect.fail(currentError)\n        }\n        const encoded = parser.encode(request)\n        if (encoded === undefined) return Effect.void\n        return Effect.orDie(write(encoded))\n      },\n      supportsAck: true,\n      supportsTransferables: false\n    }\n  }))\n\nconst makePinger = Effect.fnUntraced(function*<A, E, R>(writePing: Effect.Effect<A, E, R>) {\n  let recievedPong = true\n  const latch = Effect.unsafeMakeLatch()\n  const reset = () => {\n    recievedPong = true\n    latch.unsafeClose()\n  }\n  const onPong = () => {\n    recievedPong = true\n  }\n  yield* Effect.suspend(() => {\n    if (!recievedPong) return latch.open\n    recievedPong = false\n    return writePing\n  }).pipe(\n    Effect.delay(\"5 seconds\"),\n    Effect.ignore,\n    Effect.forever,\n    Effect.interruptible,\n    Effect.forkScoped\n  )\n  return { timeout: latch.await, reset, onPong } as const\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWorker = (\n  options: {\n    readonly size: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n  } | {\n    readonly minSize: number\n    readonly maxSize: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n    readonly timeToLive: Duration.DurationInput\n  }\n): Effect.Effect<\n  Protocol[\"Type\"],\n  WorkerError,\n  Scope.Scope | Worker.PlatformWorker | Worker.Spawner\n> =>\n  Protocol.make(Effect.fnUntraced(function*(writeResponse) {\n    const worker = yield* Worker.PlatformWorker\n    const scope = yield* Effect.scope\n    let workerId = 0\n    const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage)\n\n    const entries = new Map<string, {\n      readonly worker: Worker.BackingWorker<FromClientEncoded | RpcWorker.InitialMessage.Encoded, FromServerEncoded>\n      readonly latch: Effect.Latch\n    }>()\n\n    const acquire = Effect.gen(function*() {\n      const id = workerId++\n      const backing = yield* worker.spawn<FromClientEncoded | RpcWorker.InitialMessage.Encoded, FromServerEncoded>(id)\n      const readyLatch = yield* Effect.makeLatch()\n\n      yield* backing.run((message) => {\n        if (message[0] === 0) {\n          return readyLatch.open\n        }\n        const response = message[1]\n        if (response._tag === \"Exit\") {\n          const entry = entries.get(response.requestId)\n          if (entry) {\n            entries.delete(response.requestId)\n            entry.latch.unsafeOpen()\n            return writeResponse(response)\n          }\n        } else if (response._tag === \"Defect\") {\n          for (const [requestId, entry] of entries) {\n            entries.delete(requestId)\n            entry.latch.unsafeOpen()\n          }\n          return writeResponse(response)\n        }\n        return writeResponse(response)\n      }).pipe(\n        Effect.tapErrorCause((cause) =>\n          writeResponse({\n            _tag: \"ClientProtocolError\",\n            error: new RpcClientError({\n              reason: \"Protocol\",\n              message: \"Error in worker\",\n              cause: Cause.squash(cause)\n            })\n          })\n        ),\n        Effect.retry(Schedule.spaced(1000)),\n        Effect.annotateLogs({\n          module: \"RpcClient\",\n          method: \"makeProtocolWorker\"\n        }),\n        Effect.interruptible,\n        Effect.forkScoped\n      )\n\n      yield* readyLatch.await\n\n      if (Option.isSome(initialMessage)) {\n        const [value, transfers] = yield* initialMessage.value\n        yield* backing.send({ _tag: \"InitialMessage\", value }, transfers)\n      }\n\n      return backing\n    })\n\n    const pool = \"minSize\" in options ?\n      yield* Pool.makeWithTTL({\n        acquire,\n        min: options.minSize,\n        max: options.maxSize,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization,\n        timeToLive: options.timeToLive\n      }) :\n      yield* Pool.make({\n        acquire,\n        size: options.size,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization\n      })\n\n    yield* Scope.addFinalizer(\n      scope,\n      Effect.sync(() => {\n        for (const entry of entries.values()) {\n          entry.latch.unsafeOpen()\n        }\n        entries.clear()\n      })\n    )\n\n    const send = (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => {\n      switch (request._tag) {\n        case \"Request\": {\n          return pool.get.pipe(\n            Effect.flatMap((worker) => {\n              const latch = Effect.unsafeMakeLatch(false)\n              entries.set(request.id, { worker, latch })\n              return Effect.zipRight(worker.send(request, transferables), latch.await)\n            }),\n            Effect.scoped,\n            Effect.orDie\n          )\n        }\n        case \"Interrupt\": {\n          const entry = entries.get(request.requestId)\n          if (!entry) return Effect.void\n          entries.delete(request.requestId)\n          entry.latch.unsafeOpen()\n          return Effect.orDie(entry.worker.send(request))\n        }\n        case \"Ack\": {\n          const entry = entries.get(request.requestId)\n          if (!entry) return Effect.void\n          return Effect.orDie(entry.worker.send(request))\n        }\n      }\n      return Effect.void\n    }\n\n    yield* Effect.scoped(pool.get)\n\n    return {\n      send,\n      supportsAck: true,\n      supportsTransferables: true\n    }\n  }))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolWorker = (\n  options: {\n    readonly size: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n  } | {\n    readonly minSize: number\n    readonly maxSize: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n    readonly timeToLive: Duration.DurationInput\n  }\n): Layer.Layer<Protocol, WorkerError, Worker.PlatformWorker | Worker.Spawner> =>\n  Layer.scoped(Protocol, makeProtocolWorker(options))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolSocket = (options?: {\n  readonly retryTransientErrors?: boolean | undefined\n}): Layer.Layer<\n  Protocol,\n  never,\n  Socket.Socket | RpcSerialization.RpcSerialization\n> => Layer.scoped(Protocol, makeProtocolSocket(options))\n\n// internal\n\nconst decodeDefect = Schema.decodeSync(Schema.Defect)\n","/**\n * @since 1.0.0\n */\nimport * as Transferable from \"@effect/platform/Transferable\"\nimport type { NoSuchElementException } from \"effect/Cause\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Layer from \"effect/Layer\"\nimport type { ParseError } from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { Protocol } from \"./RpcServer.js\"\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport class InitialMessage extends Context.Tag(\"@effect/rpc/RpcWorker/InitialMessage\")<\n  InitialMessage,\n  Effect.Effect<\n    readonly [\n      data: unknown,\n      transfers: ReadonlyArray<Transferable>\n    ]\n  >\n>() {}\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport declare namespace InitialMessage {\n  /**\n   * @since 1.0.0\n   * @category initial message\n   */\n  export interface Encoded {\n    readonly _tag: \"InitialMessage\"\n    readonly value: unknown\n  }\n}\n\nconst ProtocolTag: typeof Protocol = Context.GenericTag(\"@effect/rpc/RpcServer/Protocol\") as any\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport const makeInitialMessage = <A, I, R, E, R2>(\n  schema: Schema.Schema<A, I, R>,\n  effect: Effect.Effect<A, E, R2>\n): Effect.Effect<\n  readonly [data: unknown, transferables: ReadonlyArray<globalThis.Transferable>],\n  E | ParseError,\n  R | R2\n> =>\n  Effect.flatMap(effect, (value) => {\n    const collector = Transferable.unsafeMakeCollector()\n    return Schema.encode(schema)(value).pipe(\n      Effect.provideService(Transferable.Collector, collector),\n      Effect.map((encoded) => [encoded, collector.unsafeClear()] as const)\n    )\n  })\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport const layerInitialMessage = <A, I, R, R2>(\n  schema: Schema.Schema<A, I, R>,\n  build: Effect.Effect<A, never, R2>\n): Layer.Layer<InitialMessage, never, R | R2> =>\n  Layer.effect(\n    InitialMessage,\n    Effect.contextWith((context: Context.Context<R | R2>) =>\n      Effect.provide(Effect.orDie(makeInitialMessage(schema, build)), context)\n    )\n  )\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport const initialMessage = <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n): Effect.Effect<A, NoSuchElementException | ParseError, Protocol | R> =>\n  ProtocolTag.pipe(\n    Effect.flatMap((protocol) => protocol.initialMessage),\n    Effect.flatten,\n    Effect.flatMap(Schema.decodeUnknown(schema))\n  )\n","import * as Rpc from \"@effect/rpc/Rpc\";\nimport * as RpcGroup from \"@effect/rpc/RpcGroup\";\nimport * as Schema from \"effect/Schema\";\n\nexport class FilterError extends Schema.TaggedError<FilterError>()(\"FilterError\", {\n  message: Schema.String,\n}) {}\n\nexport class WorkerRpc extends RpcGroup.make(\n  Rpc.make(\"filterData\", {\n    success: Schema.Array(Schema.Number),\n    error: FilterError,\n    payload: {\n      data: Schema.Array(Schema.Number),\n      threshold: Schema.Number,\n    },\n  }),\n  Rpc.make(\"calculatePrimes\", {\n    success: Schema.Number,\n    error: Schema.Never,\n    payload: {\n      upperBound: Schema.Number,\n    },\n  })\n) {}\n","export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nimport './struct.js'\nexport { PackrStream, UnpackrStream, PackrStream as EncoderStream, UnpackrStream as DecoderStream } from './stream.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\nimport { setExtractor } from './unpack.js'\nimport { createRequire } from 'module'\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = createRequire(import.meta.url)('msgpackr-extract')\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}","/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type { RuntimeFiber } from \"effect/Fiber\"\nimport type * as FiberRef from \"effect/FiberRef\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type { Layer } from \"effect/Layer\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport type * as Predicate from \"effect/Predicate\"\nimport type { Ref } from \"effect/Ref\"\nimport type * as Schedule from \"effect/Schedule\"\nimport type { Scope } from \"effect/Scope\"\nimport type { NoExcessProperties, NoInfer } from \"effect/Types\"\nimport type { Cookies } from \"./Cookies.js\"\nimport type * as Error from \"./HttpClientError.js\"\nimport type * as ClientRequest from \"./HttpClientRequest.js\"\nimport type * as ClientResponse from \"./HttpClientResponse.js\"\nimport * as internal from \"./internal/httpClient.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpClient extends HttpClient.With<Error.HttpClientError> {}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace HttpClient {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface With<E, R = never> extends Pipeable, Inspectable {\n    readonly [TypeId]: TypeId\n    readonly execute: (\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n\n    readonly get: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoBody\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly head: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoBody\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly post: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly patch: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly put: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly del: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly options: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Preprocess<E, R> = (\n    request: ClientRequest.HttpClientRequest\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, E, R>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Postprocess<E = never, R = never> = (\n    request: Effect.Effect<ClientRequest.HttpClientRequest, E, R>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const HttpClient: Context.Tag<HttpClient, HttpClient> = internal.tag\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const execute: (\n  request: ClientRequest.HttpClientRequest\n) => Effect.Effect<ClientResponse.HttpClientResponse, Error.HttpClientError, HttpClient> = internal.execute\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const get: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoBody | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.get\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const head: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoBody | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.head\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const post: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.post\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const patch: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.patch\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const put: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.put\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const del: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.del\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const options: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.options\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAll: {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, E2, R2>(f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E2, R2 | R>\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, A2, E2, R2>(self: HttpClient.With<E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): HttpClient.With<E2, R | R2>\n} = internal.catchAll\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const catchTag: {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, E1, R1>(\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <R, E, K extends E extends { _tag: string } ? E[\"_tag\"] : never, R1, E1>(\n    self: HttpClient.With<E, R>,\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n} = internal.catchTag\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const catchTags: {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <\n    E,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>[\"_tag\"]>]: never })\n  >(cases: Cases): <R>(\n    self: HttpClient.With<E, R>\n  ) => HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, any, infer R> ? R : never\n    }[keyof Cases]\n  >\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <\n    E extends { _tag: string },\n    R,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>[\"_tag\"]>]: never })\n  >(self: HttpClient.With<E, R>, cases: Cases): HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, any, infer R> ? R : never\n    }[keyof Cases]\n  >\n} = internal.catchTags\n\n/**\n * Filters the result of a response, or runs an alternative effect if the predicate fails.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterOrElse: {\n  /**\n   * Filters the result of a response, or runs an alternative effect if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E2, R2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>\n  /**\n   * Filters the result of a response, or runs an alternative effect if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E, R, E2, R2>(\n    self: HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): HttpClient.With<E2 | E, R2 | R>\n} = internal.filterOrElse\n\n/**\n * Filters the result of a response, or throws an error if the predicate fails.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterOrFail: {\n  /**\n   * Filters the result of a response, or throws an error if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>\n  /**\n   * Filters the result of a response, or throws an error if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E, R, E2>(\n    self: HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): HttpClient.With<E2 | E, R>\n} = internal.filterOrFail\n\n/**\n * Filters responses by HTTP status code.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterStatus: {\n  /**\n   * Filters responses by HTTP status code.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>\n  /**\n   * Filters responses by HTTP status code.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<E | Error.ResponseError, R>\n} = internal.filterStatus\n\n/**\n * Filters responses that return a 2xx status code.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterStatusOk: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R> =\n  internal.filterStatusOk\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWith: <E2, R2, E, R>(\n  postprocess: (\n    request: Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n  preprocess: HttpClient.Preprocess<E2, R2>\n) => HttpClient.With<E, R> = internal.makeWith\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: (\n  f: (\n    request: ClientRequest.HttpClientRequest,\n    url: URL,\n    signal: AbortSignal,\n    fiber: RuntimeFiber<ClientResponse.HttpClientResponse, Error.HttpClientError>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.HttpClientError>\n) => HttpClient = internal.make\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const transform: {\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): (self: HttpClient.With<E, R>) => HttpClient.With<E | E1, R | R1>\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    self: HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): HttpClient.With<E | E1, R | R1>\n} = internal.transform\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const transformResponse: {\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): (self: HttpClient.With<E, R>) => HttpClient.With<E1, R1>\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    self: HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): HttpClient.With<E1, R1>\n} = internal.transformResponse\n\n/**\n * Appends a transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequest: {\n  /**\n   * Appends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Appends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ): HttpClient.With<E, R>\n} = internal.mapRequest\n\n/**\n * Appends an effectful transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequestEffect: {\n  /**\n   * Appends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E2, R2>(\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Appends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.mapRequestEffect\n\n/**\n * Prepends a transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequestInput: {\n  /**\n   * Prepends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Prepends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ): HttpClient.With<E, R>\n} = internal.mapRequestInput\n\n/**\n * Prepends an effectful transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequestInputEffect: {\n  /**\n   * Prepends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E2, R2>(\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Prepends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.mapRequestInputEffect\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport declare namespace Retry {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  export type Return<R, E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>> = HttpClient.With<\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer _R> } ? E\n      : O extends { until: Predicate.Refinement<E, infer E2> } ? E2\n      : E)\n    | (O extends { while: (...args: Array<any>) => Effect.Effect<infer _A, infer E, infer _R> } ? E : never)\n    | (O extends { until: (...args: Array<any>) => Effect.Effect<infer _A, infer E, infer _R> } ? E : never),\n    | R\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R> } ? R : never)\n    | (O extends { while: (...args: Array<any>) => Effect.Effect<infer _A, infer _E, infer R> } ? R : never)\n    | (O extends { until: (...args: Array<any>) => Effect.Effect<infer _A, infer _E, infer R> } ? R : never)\n  > extends infer Z ? Z : never\n}\n\n/**\n * Retries the request based on a provided schedule or policy.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const retry: {\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(options: O): <R>(self: HttpClient.With<E, R>) => Retry.Return<R, E, O>\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(self: HttpClient.With<E, R>, options: O): Retry.Return<R, E, O>\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule.Schedule<B, E, R1>): HttpClient.With<E, R1 | R>\n} = internal.retry\n\n/**\n * Retries common transient errors, such as rate limiting, timeouts or network issues.\n *\n * Specifying a `while` predicate allows you to consider other errors as\n * transient.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const retryTransient: {\n  /**\n   * Retries common transient errors, such as rate limiting, timeouts or network issues.\n   *\n   * Specifying a `while` predicate allows you to consider other errors as\n   * transient.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <B, E, R1 = never>(\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>\n  /**\n   * Retries common transient errors, such as rate limiting, timeouts or network issues.\n   *\n   * Specifying a `while` predicate allows you to consider other errors as\n   * transient.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, B, R1 = never>(\n    self: HttpClient.With<E, R>,\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): HttpClient.With<E, R1 | R>\n} = internal.retryTransient\n\n/**\n * Performs an additional effect after a successful request.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const tap: {\n  /**\n   * Performs an additional effect after a successful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <_, E2, R2>(\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Performs an additional effect after a successful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, _, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.tap\n\n/**\n * Performs an additional effect after an unsuccessful request.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const tapError: {\n  /**\n   * Performs an additional effect after an unsuccessful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <_, E, E2, R2>(f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Performs an additional effect after an unsuccessful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, _, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.tapError\n\n/**\n * Performs an additional effect on the request before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const tapRequest: {\n  /**\n   * Performs an additional effect on the request before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <_, E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Performs an additional effect on the request before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, _, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.tapRequest\n\n/**\n * Associates a `Ref` of cookies with the client for handling cookies across requests.\n *\n * @since 1.0.0\n * @category cookies\n */\nexport const withCookiesRef: {\n  /**\n   * Associates a `Ref` of cookies with the client for handling cookies across requests.\n   *\n   * @since 1.0.0\n   * @category cookies\n   */\n  (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Associates a `Ref` of cookies with the client for handling cookies across requests.\n   *\n   * @since 1.0.0\n   * @category cookies\n   */\n  <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>\n} = internal.withCookiesRef\n\n/**\n * Follows HTTP redirects up to a specified number of times.\n *\n * @since 1.0.0\n * @category redirects\n */\nexport const followRedirects: {\n  /**\n   * Follows HTTP redirects up to a specified number of times.\n   *\n   * @since 1.0.0\n   * @category redirects\n   */\n  (maxRedirects?: number | undefined): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Follows HTTP redirects up to a specified number of times.\n   *\n   * @since 1.0.0\n   * @category redirects\n   */\n  <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number | undefined): HttpClient.With<E, R>\n} = internal.followRedirects\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const currentTracerDisabledWhen: FiberRef.FiberRef<Predicate.Predicate<ClientRequest.HttpClientRequest>> =\n  internal.currentTracerDisabledWhen\n\n/**\n * Disables tracing for specific requests based on a provided predicate.\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withTracerDisabledWhen: {\n  /**\n   * Disables tracing for specific requests based on a provided predicate.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Disables tracing for specific requests based on a provided predicate.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>\n  ): HttpClient.With<E, R>\n} = internal.withTracerDisabledWhen\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const currentTracerPropagation: FiberRef.FiberRef<boolean> = internal.currentTracerPropagation\n\n/**\n * Enables or disables tracing propagation for the request.\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withTracerPropagation: {\n  /**\n   * Enables or disables tracing propagation for the request.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (enabled: boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Enables or disables tracing propagation for the request.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <E, R>(self: HttpClient.With<E, R>, enabled: boolean): HttpClient.With<E, R>\n} = internal.withTracerPropagation\n\n/**\n * @since 1.0.0\n */\nexport const layerMergedContext: <E, R>(\n  effect: Effect.Effect<HttpClient, E, R>\n) => Layer<HttpClient, E, R> = internal.layerMergedContext\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport interface SpanNameGenerator {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const SpanNameGenerator: Context.Reference<\n  SpanNameGenerator,\n  (request: ClientRequest.HttpClientRequest) => string\n> = internal.SpanNameGenerator\n\n/**\n * Customizes the span names for tracing.\n *\n * ```ts\n * import { FetchHttpClient, HttpClient } from \"@effect/platform\"\n * import { NodeRuntime } from \"@effect/platform-node\"\n * import { Effect } from \"effect\"\n *\n * Effect.gen(function* () {\n *   const client = (yield* HttpClient.HttpClient).pipe(\n *     // Customize the span names for this HttpClient\n *     HttpClient.withSpanNameGenerator(\n *       (request) => `http.client ${request.method} ${request.url}`\n *     )\n *   )\n *\n *   yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n * }).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n * ```\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withSpanNameGenerator: {\n  /**\n   * Customizes the span names for tracing.\n   *\n   * ```ts\n   * import { FetchHttpClient, HttpClient } from \"@effect/platform\"\n   * import { NodeRuntime } from \"@effect/platform-node\"\n   * import { Effect } from \"effect\"\n   *\n   * Effect.gen(function* () {\n   *   const client = (yield* HttpClient.HttpClient).pipe(\n   *     // Customize the span names for this HttpClient\n   *     HttpClient.withSpanNameGenerator(\n   *       (request) => `http.client ${request.method} ${request.url}`\n   *     )\n   *   )\n   *\n   *   yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n   * }).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n   * ```\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (f: (request: ClientRequest.HttpClientRequest) => string): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Customizes the span names for tracing.\n   *\n   * ```ts\n   * import { FetchHttpClient, HttpClient } from \"@effect/platform\"\n   * import { NodeRuntime } from \"@effect/platform-node\"\n   * import { Effect } from \"effect\"\n   *\n   * Effect.gen(function* () {\n   *   const client = (yield* HttpClient.HttpClient).pipe(\n   *     // Customize the span names for this HttpClient\n   *     HttpClient.withSpanNameGenerator(\n   *       (request) => `http.client ${request.method} ${request.url}`\n   *     )\n   *   )\n   *\n   *   yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n   * }).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n   * ```\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    f: (request: ClientRequest.HttpClientRequest) => string\n  ): HttpClient.With<E, R>\n} = internal.withSpanNameGenerator\n\n/**\n * Ties the lifetime of the `HttpClientRequest` to a `Scope`.\n *\n * @since 1.0.0\n * @category Scope\n */\nexport const withScope: <E, R>(\n  self: HttpClient.With<E, R>\n) => HttpClient.With<E, R | Scope> = internal.withScope\n","/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/pool.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const PoolTypeId: unique symbol = internal.PoolTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type PoolTypeId = typeof PoolTypeId\n\n/**\n * A `Pool<A, E>` is a pool of items of type `A`, each of which may be\n * associated with the acquisition and release of resources. An attempt to get\n * an item `A` from a pool may fail with an error of type `E`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Pool<in out A, out E = never> extends Pool.Variance<A, E>, Effect.Effect<A, E, Scope.Scope>, Pipeable {\n  /**\n   * Retrieves an item from the pool in a scoped effect. Note that if\n   * acquisition fails, then the returned effect will fail for that same reason.\n   * Retrying a failed acquisition attempt will repeat the acquisition attempt.\n   */\n  readonly get: Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: PoolUnify<this>\n  readonly [Unify.ignoreSymbol]?: PoolUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface PoolUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Pool?: () => Extract<A[Unify.typeSymbol], Pool<any, any>> extends Pool<infer A0, infer _E0> | infer _ ?\n    A0 extends any ? Extract<A[Unify.typeSymbol], Pool<A0, any>> extends Pool<A0, infer E1> ? Pool<A0, E1>\n      : never\n    : never :\n    never\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface PoolUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Pool {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A, out E> {\n    readonly [PoolTypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }\n}\n\n/**\n * Returns `true` if the specified value is a `Pool`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isPool: (u: unknown) => u is Pool<unknown, unknown> = internal.isPool\n\n/**\n * Makes a new pool of the specified fixed size. The pool is returned in a\n * `Scope`, which governs the lifetime of the pool. When the pool is shutdown\n * because the `Scope` is closed, the individual items allocated by the pool\n * will be released in some unspecified order.\n *\n * By setting the `concurrency` parameter, you can control the level of concurrent\n * access per pool item. By default, the number of permits is set to `1`.\n *\n * `targetUtilization` determines when to create new pool items. It is a value\n * between 0 and 1, where 1 means only create new pool items when all the existing\n * items are fully utilized.\n *\n * A `targetUtilization` of 0.5 will create new pool items when the existing items are\n * 50% utilized.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A, E, R>(\n  options: {\n    readonly acquire: Effect.Effect<A, E, R>\n    readonly size: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n  }\n) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R> = internal.make\n\n/**\n * Makes a new pool with the specified minimum and maximum sizes and time to\n * live before a pool whose excess items are not being used will be shrunk\n * down to the minimum size. The pool is returned in a `Scope`, which governs\n * the lifetime of the pool. When the pool is shutdown because the `Scope` is\n * used, the individual items allocated by the pool will be released in some\n * unspecified order.\n *\n * By setting the `concurrency` parameter, you can control the level of concurrent\n * access per pool item. By default, the number of permits is set to `1`.\n *\n * `targetUtilization` determines when to create new pool items. It is a value\n * between 0 and 1, where 1 means only create new pool items when all the existing\n * items are fully utilized.\n *\n * A `targetUtilization` of 0.5 will create new pool items when the existing items are\n * 50% utilized.\n *\n * The `timeToLiveStrategy` determines how items are invalidated. If set to\n * \"creation\", then items are invalidated based on their creation time. If set\n * to \"usage\", then items are invalidated based on pool usage.\n *\n * By default, the `timeToLiveStrategy` is set to \"usage\".\n *\n * ```ts skip-type-checking\n * import { createConnection } from \"mysql2\";\n * import { Duration, Effect, Pool } from \"effect\"\n *\n * const acquireDBConnection = Effect.acquireRelease(\n *   Effect.sync(() => createConnection('mysql://...')),\n *   (connection) => Effect.sync(() => connection.end(() => {})),\n * )\n *\n * const connectionPool = Effect.flatMap(\n *  Pool.makeWithTTL({\n *     acquire: acquireDBConnection,\n *     min: 10,\n *     max: 20,\n *     timeToLive: Duration.seconds(60)\n *   }),\n *   (pool) => pool.get\n * )\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWithTTL: <A, E, R>(\n  options: {\n    readonly acquire: Effect.Effect<A, E, R>\n    readonly min: number\n    readonly max: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n    readonly timeToLive: Duration.DurationInput\n    readonly timeToLiveStrategy?: \"creation\" | \"usage\" | undefined\n  }\n) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R> = internal.makeWithTTL\n\n/**\n * Retrieves an item from the pool in a scoped effect. Note that if\n * acquisition fails, then the returned effect will fail for that same reason.\n * Retrying a failed acquisition attempt will repeat the acquisition attempt.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope> = internal.get\n\n/**\n * Invalidates the specified item. This will cause the pool to eventually\n * reallocate the item, although this reallocation may occur lazily rather\n * than eagerly.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const invalidate: {\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>\n} = internal.invalidate\n","/**\n * @since 1.0.0\n */\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberRefs from \"effect/FiberRefs\"\nimport { dual, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport { type Redactable, symbolRedactable } from \"effect/Inspectable\"\nimport type * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport * as Redacted from \"effect/Redacted\"\nimport * as Schema from \"effect/Schema\"\nimport * as String from \"effect/String\"\nimport type { Mutable } from \"effect/Types\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const HeadersTypeId: unique symbol = Symbol.for(\"@effect/platform/Headers\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type HeadersTypeId = typeof HeadersTypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHeaders = (u: unknown): u is Headers => Predicate.hasProperty(u, HeadersTypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Headers extends Redactable {\n  readonly [HeadersTypeId]: HeadersTypeId\n  readonly [key: string]: string\n}\n\nconst Proto = Object.assign(Object.create(null), {\n  [HeadersTypeId]: HeadersTypeId,\n  [symbolRedactable](\n    this: Headers,\n    fiberRefs: FiberRefs.FiberRefs\n  ): Record<string, string | Redacted.Redacted<string>> {\n    return redact(this, FiberRefs.getOrDefault(fiberRefs, currentRedactedNames))\n  }\n})\n\nconst make = (input: Record.ReadonlyRecord<string, string>): Mutable<Headers> =>\n  Object.assign(Object.create(Proto), input) as Headers\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schemaFromSelf: Schema.Schema<Headers> = Schema.declare(isHeaders, {\n  identifier: \"Headers\",\n  equivalence: () => Record.getEquivalence(String.Equivalence)\n})\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schema: Schema.Schema<Headers, Record.ReadonlyRecord<string, string>> = Schema\n  .transform(\n    Schema.Record({ key: Schema.String, value: Schema.String }),\n    schemaFromSelf,\n    { strict: true, decode: (record) => fromInput(record), encode: identity }\n  )\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Input =\n  | Record.ReadonlyRecord<string, string | ReadonlyArray<string> | undefined>\n  | Iterable<readonly [string, string]>\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: Headers = Object.create(Proto)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromInput: (input?: Input) => Headers = (input) => {\n  if (input === undefined) {\n    return empty\n  } else if (Symbol.iterator in input) {\n    const out: Record<string, string> = Object.create(Proto)\n    for (const [k, v] of input) {\n      out[k.toLowerCase()] = v\n    }\n    return out as Headers\n  }\n  const out: Record<string, string> = Object.create(Proto)\n  for (const [k, v] of Object.entries(input)) {\n    if (Array.isArray(v)) {\n      out[k.toLowerCase()] = v.join(\", \")\n    } else if (v !== undefined) {\n      out[k.toLowerCase()] = v as string\n    }\n  }\n  return out as Headers\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeFromRecord = (input: Record.ReadonlyRecord<string, string>): Headers =>\n  Object.setPrototypeOf(input, Proto) as Headers\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const has: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: Headers) => boolean\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string): boolean\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string) => (self: Headers) => boolean,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string) => boolean\n>(2, (self, key) => key.toLowerCase() in self)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const get: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: Headers) => Option.Option<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string): Option.Option<string>\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string) => (self: Headers) => Option.Option<string>,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string) => Option.Option<string>\n>(2, (self, key) => Record.get(self as Record<string, string>, key.toLowerCase()))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const set: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string, value: string): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string, value: string) => Headers\n>(3, (self, key, value) => {\n  const out = make(self)\n  out[key.toLowerCase()] = value\n  return out\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Input): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Input): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Input) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Input) => Headers\n>(2, (self, headers) =>\n  make({\n    ...self,\n    ...fromInput(headers)\n  }))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const merge: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Headers): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Headers): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Headers) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Headers) => Headers\n>(2, (self, headers) => {\n  const out = make(self)\n  Object.assign(out, headers)\n  return out\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const remove: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string | RegExp | ReadonlyArray<string | RegExp>): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string | RegExp | ReadonlyArray<string | RegExp>): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string | RegExp | ReadonlyArray<string | RegExp>) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string | RegExp | ReadonlyArray<string | RegExp>) => Headers\n>(2, (self, key) => {\n  const out = make(self)\n  const modify = (key: string | RegExp) => {\n    if (typeof key === \"string\") {\n      const k = key.toLowerCase()\n      if (k in self) {\n        delete out[k]\n      }\n    } else {\n      for (const name in self) {\n        if (key.test(name)) {\n          delete out[name]\n        }\n      }\n    }\n  }\n  if (Array.isArray(key)) {\n    for (let i = 0; i < key.length; i++) {\n      modify(key[i])\n    }\n  } else {\n    modify(key as string | RegExp)\n  }\n  return out\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const redact: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string | RegExp | ReadonlyArray<string | RegExp>): (self: Headers) => Record<string, string | Redacted.Redacted>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string | RegExp | ReadonlyArray<string | RegExp>): Record<string, string | Redacted.Redacted>\n} = dual(\n  2,\n  (\n    self: Headers,\n    key: string | RegExp | ReadonlyArray<string | RegExp>\n  ): Record<string, string | Redacted.Redacted> => {\n    const out: Record<string, string | Redacted.Redacted> = { ...self }\n    const modify = (key: string | RegExp) => {\n      if (typeof key === \"string\") {\n        const k = key.toLowerCase()\n        if (k in self) {\n          out[k] = Redacted.make(self[k])\n        }\n      } else {\n        for (const name in self) {\n          if (key.test(name)) {\n            out[name] = Redacted.make(self[name])\n          }\n        }\n      }\n    }\n    if (Array.isArray(key)) {\n      for (let i = 0; i < key.length; i++) {\n        modify(key[i])\n      }\n    } else {\n      modify(key as string | RegExp)\n    }\n    return out\n  }\n)\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentRedactedNames: FiberRef.FiberRef<ReadonlyArray<string | RegExp>> = globalValue(\n  \"@effect/platform/Headers/currentRedactedNames\",\n  () =>\n    FiberRef.unsafeMake<ReadonlyArray<string | RegExp>>([\n      \"authorization\",\n      \"cookie\",\n      \"set-cookie\",\n      \"x-api-key\"\n    ])\n)\n","/**\n * @since 1.0.0\n */\nimport * as Duration from \"effect/Duration\"\nimport * as Either from \"effect/Either\"\nimport { dual, identity } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport type * as Types from \"effect/Types\"\nimport { TypeIdError } from \"./Error.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/Cookies\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isCookies = (u: unknown): u is Cookies => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Cookies extends Pipeable, Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly cookies: Record.ReadonlyRecord<string, Cookie>\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const CookieTypeId: unique symbol = Symbol.for(\"@effect/platform/Cookies/Cookie\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type CookieTypeId = typeof CookieTypeId\n\n/**\n * @since 1.0.0\n * @category cookie\n */\nexport interface Cookie extends Inspectable.Inspectable {\n  readonly [CookieTypeId]: CookieTypeId\n  readonly name: string\n  readonly value: string\n  readonly valueEncoded: string\n  readonly options?: {\n    readonly domain?: string | undefined\n    readonly expires?: Date | undefined\n    readonly maxAge?: Duration.DurationInput | undefined\n    readonly path?: string | undefined\n    readonly priority?: \"low\" | \"medium\" | \"high\" | undefined\n    readonly httpOnly?: boolean | undefined\n    readonly secure?: boolean | undefined\n    readonly partitioned?: boolean | undefined\n    readonly sameSite?: \"lax\" | \"strict\" | \"none\" | undefined\n  } | undefined\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const ErrorTypeId: unique symbol = Symbol.for(\"@effect/platform/Cookies/CookieError\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class CookiesError extends TypeIdError(ErrorTypeId, \"CookieError\")<{\n  readonly reason: \"InvalidName\" | \"InvalidValue\" | \"InvalidDomain\" | \"InvalidPath\" | \"InfinityMaxAge\"\n}> {\n  get message() {\n    return this.reason\n  }\n}\n\nconst Proto: Omit<Cookies, \"cookies\"> = {\n  [TypeId]: TypeId,\n  ...Inspectable.BaseProto,\n  toJSON(this: Cookies) {\n    return {\n      _id: \"@effect/platform/Cookies\",\n      cookies: Record.map(this.cookies, (cookie) => cookie.toJSON())\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * Create a Cookies object from an Iterable\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromReadonlyRecord = (cookies: Record.ReadonlyRecord<string, Cookie>): Cookies => {\n  const self = Object.create(Proto)\n  self.cookies = cookies\n  return self\n}\n\n/**\n * Create a Cookies object from an Iterable\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable = (cookies: Iterable<Cookie>): Cookies => {\n  const record: Record<string, Cookie> = {}\n  for (const cookie of cookies) {\n    record[cookie.name] = cookie\n  }\n  return fromReadonlyRecord(record)\n}\n\n/**\n * Create a Cookies object from a set of Set-Cookie headers\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromSetCookie = (headers: Iterable<string> | string): Cookies => {\n  const arrayHeaders = typeof headers === \"string\" ? [headers] : headers\n  const cookies: Array<Cookie> = []\n  for (const header of arrayHeaders) {\n    const cookie = parseSetCookie(header.trim())\n    if (Option.isSome(cookie)) {\n      cookies.push(cookie.value)\n    }\n  }\n\n  return fromIterable(cookies)\n}\n\nfunction parseSetCookie(header: string): Option.Option<Cookie> {\n  const parts = header.split(\";\").map((_) => _.trim()).filter((_) => _ !== \"\")\n  if (parts.length === 0) {\n    return Option.none()\n  }\n\n  const firstEqual = parts[0].indexOf(\"=\")\n  if (firstEqual === -1) {\n    return Option.none()\n  }\n  const name = parts[0].slice(0, firstEqual)\n  if (!fieldContentRegExp.test(name)) {\n    return Option.none()\n  }\n\n  const valueEncoded = parts[0].slice(firstEqual + 1)\n  const value = tryDecodeURIComponent(valueEncoded)\n\n  if (parts.length === 1) {\n    return Option.some(Object.assign(Object.create(CookieProto), {\n      name,\n      value,\n      valueEncoded\n    }))\n  }\n\n  const options: Types.Mutable<Cookie[\"options\"]> = {}\n\n  for (let i = 1; i < parts.length; i++) {\n    const part = parts[i]\n    const equalIndex = part.indexOf(\"=\")\n    const key = equalIndex === -1 ? part : part.slice(0, equalIndex).trim()\n    const value = equalIndex === -1 ? undefined : part.slice(equalIndex + 1).trim()\n\n    switch (key.toLowerCase()) {\n      case \"domain\": {\n        if (value === undefined) {\n          break\n        }\n        const domain = value.trim().replace(/^\\./, \"\")\n        if (domain) {\n          options.domain = domain\n        }\n        break\n      }\n      case \"expires\": {\n        if (value === undefined) {\n          break\n        }\n        const date = new Date(value)\n        if (!isNaN(date.getTime())) {\n          options.expires = date\n        }\n        break\n      }\n      case \"max-age\": {\n        if (value === undefined) {\n          break\n        }\n        const maxAge = parseInt(value, 10)\n        if (!isNaN(maxAge)) {\n          options.maxAge = Duration.seconds(maxAge)\n        }\n        break\n      }\n      case \"path\": {\n        if (value === undefined) {\n          break\n        }\n        if (value[0] === \"/\") {\n          options.path = value\n        }\n        break\n      }\n      case \"priority\": {\n        if (value === undefined) {\n          break\n        }\n        switch (value.toLowerCase()) {\n          case \"low\":\n            options.priority = \"low\"\n            break\n          case \"medium\":\n            options.priority = \"medium\"\n            break\n          case \"high\":\n            options.priority = \"high\"\n            break\n        }\n        break\n      }\n      case \"httponly\": {\n        options.httpOnly = true\n        break\n      }\n      case \"secure\": {\n        options.secure = true\n        break\n      }\n      case \"partitioned\": {\n        options.partitioned = true\n        break\n      }\n      case \"samesite\": {\n        if (value === undefined) {\n          break\n        }\n        switch (value.toLowerCase()) {\n          case \"lax\":\n            options.sameSite = \"lax\"\n            break\n          case \"strict\":\n            options.sameSite = \"strict\"\n            break\n          case \"none\":\n            options.sameSite = \"none\"\n            break\n        }\n        break\n      }\n    }\n  }\n\n  return Option.some(Object.assign(Object.create(CookieProto), {\n    name,\n    value,\n    valueEncoded,\n    options: Object.keys(options).length > 0 ? options : undefined\n  }))\n}\n\n/**\n * An empty Cookies object\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: Cookies = fromIterable([])\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isEmpty = (self: Cookies): boolean => Record.isEmptyRecord(self.cookies)\n\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/\n\nconst CookieProto = {\n  [CookieTypeId]: CookieTypeId,\n  ...Inspectable.BaseProto,\n  toJSON(this: Cookie) {\n    return {\n      _id: \"@effect/platform/Cookies/Cookie\",\n      name: this.name,\n      value: this.value,\n      options: this.options\n    }\n  }\n}\n\n/**\n * Create a new cookie\n *\n * @since 1.0.0\n * @category constructors\n */\nexport function makeCookie(\n  name: string,\n  value: string,\n  options?: Cookie[\"options\"] | undefined\n): Either.Either<Cookie, CookiesError> {\n  if (!fieldContentRegExp.test(name)) {\n    return Either.left(new CookiesError({ reason: \"InvalidName\" }))\n  }\n  const encodedValue = encodeURIComponent(value)\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    return Either.left(new CookiesError({ reason: \"InvalidValue\" }))\n  }\n\n  if (options !== undefined) {\n    if (options.domain !== undefined && !fieldContentRegExp.test(options.domain)) {\n      return Either.left(new CookiesError({ reason: \"InvalidDomain\" }))\n    }\n\n    if (options.path !== undefined && !fieldContentRegExp.test(options.path)) {\n      return Either.left(new CookiesError({ reason: \"InvalidPath\" }))\n    }\n\n    if (options.maxAge !== undefined && !Duration.isFinite(Duration.decode(options.maxAge))) {\n      return Either.left(new CookiesError({ reason: \"InfinityMaxAge\" }))\n    }\n  }\n\n  return Either.right(Object.assign(Object.create(CookieProto), {\n    name,\n    value,\n    valueEncoded: encodedValue,\n    options\n  }))\n}\n\n/**\n * Create a new cookie, throwing an error if invalid\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeMakeCookie = (\n  name: string,\n  value: string,\n  options?: Cookie[\"options\"] | undefined\n): Cookie => Either.getOrThrowWith(makeCookie(name, value, options), identity)\n\n/**\n * Add a cookie to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const setCookie: {\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (cookie: Cookie): (self: Cookies) => Cookies\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, cookie: Cookie): Cookies\n} = dual(\n  2,\n  (self: Cookies, cookie: Cookie) =>\n    fromReadonlyRecord(Record.set(\n      self.cookies,\n      cookie.name,\n      cookie\n    ))\n)\n\n/**\n * Add multiple cookies to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const setAllCookie: {\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (cookies: Iterable<Cookie>): (self: Cookies) => Cookies\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, cookies: Iterable<Cookie>): Cookies\n} = dual(2, (self: Cookies, cookies: Iterable<Cookie>) => {\n  const record = { ...self.cookies }\n  for (const cookie of cookies) {\n    record[cookie.name] = cookie\n  }\n  return fromReadonlyRecord(record)\n})\n\n/**\n * Combine two Cookies objects, removing duplicates from the first\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const merge: {\n  /**\n   * Combine two Cookies objects, removing duplicates from the first\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (that: Cookies): (self: Cookies) => Cookies\n  /**\n   * Combine two Cookies objects, removing duplicates from the first\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, that: Cookies): Cookies\n} = dual(2, (self: Cookies, that: Cookies) =>\n  fromReadonlyRecord({\n    ...self.cookies,\n    ...that.cookies\n  }))\n\n/**\n * Remove a cookie by name\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const remove: {\n  /**\n   * Remove a cookie by name\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: Cookies) => Cookies\n  /**\n   * Remove a cookie by name\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string): Cookies\n} = dual(2, (self: Cookies, name: string) => fromReadonlyRecord(Record.remove(self.cookies, name)))\n\n/**\n * Get a cookie from a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const get: {\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: Cookies) => Option.Option<Cookie>\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string): Option.Option<Cookie>\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string): Option.Option<Cookie> => Record.get(self.cookies, name)\n)\n\n/**\n * Get a cookie from a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const getValue: {\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: Cookies) => Option.Option<string>\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string): Option.Option<string>\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string): Option.Option<string> =>\n    Option.map(Record.get(self.cookies, name), (cookie) => cookie.value)\n)\n\n/**\n * Add a cookie to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const set: {\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string, value: string, options?: Cookie[\"options\"]): (self: Cookies) => Either.Either<Cookies, CookiesError>\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]): Either.Either<Cookies, CookiesError>\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]) =>\n    Either.map(\n      makeCookie(name, value, options),\n      (cookie) => fromReadonlyRecord(Record.set(self.cookies, name, cookie))\n    )\n)\n\n/**\n * Add a cookie to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const unsafeSet: {\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string, value: string, options?: Cookie[\"options\"]): (self: Cookies) => Cookies\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]): Cookies\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]) =>\n    fromReadonlyRecord(Record.set(\n      self.cookies,\n      name,\n      unsafeMakeCookie(name, value, options)\n    ))\n)\n\n/**\n * Add multiple cookies to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll: {\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): (self: Cookies) => Either.Either<Cookies, CookiesError>\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Either.Either<Cookies, CookiesError>\n} = dual(\n  2,\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Either.Either<Cookies, CookiesError> => {\n    const record: Record<string, Cookie> = { ...self.cookies }\n    for (const [name, value, options] of cookies) {\n      const either = makeCookie(name, value, options)\n      if (Either.isLeft(either)) {\n        return either as Either.Left<CookiesError, never>\n      }\n      record[name] = either.right\n    }\n    return Either.right(fromReadonlyRecord(record))\n  }\n)\n\n/**\n * Add multiple cookies to a Cookies object, throwing an error if invalid\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const unsafeSetAll: {\n  /**\n   * Add multiple cookies to a Cookies object, throwing an error if invalid\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): (self: Cookies) => Cookies\n  /**\n   * Add multiple cookies to a Cookies object, throwing an error if invalid\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Cookies\n} = dual(\n  2,\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Cookies => Either.getOrThrowWith(setAll(self, cookies), identity)\n)\n\n/**\n * Serialize a cookie into a string\n *\n * Adapted from https://github.com/fastify/fastify-cookie under MIT License\n *\n * @since 1.0.0\n * @category encoding\n */\nexport function serializeCookie(self: Cookie): string {\n  let str = self.name + \"=\" + self.valueEncoded\n\n  if (self.options === undefined) {\n    return str\n  }\n  const options = self.options\n\n  if (options.maxAge !== undefined) {\n    const maxAge = Duration.toSeconds(options.maxAge)\n    str += \"; Max-Age=\" + Math.trunc(maxAge)\n  }\n\n  if (options.domain !== undefined) {\n    str += \"; Domain=\" + options.domain\n  }\n\n  if (options.path !== undefined) {\n    str += \"; Path=\" + options.path\n  }\n\n  if (options.priority !== undefined) {\n    switch (options.priority) {\n      case \"low\":\n        str += \"; Priority=Low\"\n        break\n      case \"medium\":\n        str += \"; Priority=Medium\"\n        break\n      case \"high\":\n        str += \"; Priority=High\"\n        break\n    }\n  }\n\n  if (options.expires !== undefined) {\n    str += \"; Expires=\" + options.expires.toUTCString()\n  }\n\n  if (options.httpOnly) {\n    str += \"; HttpOnly\"\n  }\n\n  if (options.secure) {\n    str += \"; Secure\"\n  }\n\n  // Draft implementation to support Chrome from 2024-Q1 forward.\n  // See https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1\n  if (options.partitioned) {\n    str += \"; Partitioned\"\n  }\n\n  if (options.sameSite !== undefined) {\n    switch (options.sameSite) {\n      case \"lax\":\n        str += \"; SameSite=Lax\"\n        break\n      case \"strict\":\n        str += \"; SameSite=Strict\"\n        break\n      case \"none\":\n        str += \"; SameSite=None\"\n        break\n    }\n  }\n\n  return str\n}\n\n/**\n * Serialize a Cookies object into a Cookie header\n *\n * @since 1.0.0\n * @category encoding\n */\nexport const toCookieHeader = (self: Cookies): string =>\n  Object.values(self.cookies).map((cookie) => `${cookie.name}=${cookie.valueEncoded}`).join(\"; \")\n\n/**\n * To record\n *\n * @since 1.0.0\n * @category encoding\n */\nexport const toRecord = (self: Cookies): Record<string, string> => {\n  const record: Record<string, string> = {}\n  const cookies = Object.values(self.cookies)\n  for (let index = 0; index < cookies.length; index++) {\n    const cookie = cookies[index]\n    record[cookie.name] = cookie.value\n  }\n  return record\n}\n\n/**\n * Serialize a Cookies object into Headers object containing one or more Set-Cookie headers\n *\n * @since 1.0.0\n * @category encoding\n */\nexport const toSetCookieHeaders = (self: Cookies): Array<string> => Object.values(self.cookies).map(serializeCookie)\n\n/**\n * Parse a cookie header into a record of key-value pairs\n *\n * Adapted from https://github.com/fastify/fastify-cookie under MIT License\n *\n * @since 1.0.0\n * @category decoding\n */\nexport function parseHeader(header: string): Record<string, string> {\n  const result: Record<string, string> = {}\n\n  const strLen = header.length\n  let pos = 0\n  let terminatorPos = 0\n\n  while (true) {\n    if (terminatorPos === strLen) break\n    terminatorPos = header.indexOf(\";\", pos)\n    if (terminatorPos === -1) terminatorPos = strLen // This is the last pair\n\n    let eqIdx = header.indexOf(\"=\", pos)\n    if (eqIdx === -1) break // No key-value pairs left\n    if (eqIdx > terminatorPos) {\n      // Malformed key-value pair\n      pos = terminatorPos + 1\n      continue\n    }\n\n    const key = header.substring(pos, eqIdx++).trim()\n    if (result[key] === undefined) {\n      const val = header.charCodeAt(eqIdx) === 0x22\n        ? header.substring(eqIdx + 1, terminatorPos - 1).trim()\n        : header.substring(eqIdx, terminatorPos).trim()\n\n      result[key] = !(val.indexOf(\"%\") === -1)\n        ? tryDecodeURIComponent(val)\n        : val\n    }\n\n    pos = terminatorPos + 1\n  }\n\n  return result\n}\n\nconst tryDecodeURIComponent = (str: string): string => {\n  try {\n    return decodeURIComponent(str)\n  } catch {\n    return str\n  }\n}\n","/**\n * @since 1.0.0\n */\nimport type * as Effect from \"effect/Effect\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type * as Option from \"effect/Option\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport type { Redacted } from \"effect/Redacted\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport type * as PlatformError from \"./Error.js\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Headers from \"./Headers.js\"\nimport type * as Body from \"./HttpBody.js\"\nimport type { HttpMethod } from \"./HttpMethod.js\"\nimport * as internal from \"./internal/httpClientRequest.js\"\nimport type * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpClientRequest\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpClientRequest extends Inspectable, Pipeable {\n  readonly [TypeId]: TypeId\n  readonly method: HttpMethod\n  readonly url: string\n  readonly urlParams: UrlParams.UrlParams\n  readonly hash: Option.Option<string>\n  readonly headers: Headers.Headers\n  readonly body: Body.HttpBody\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Options {\n  readonly method?: HttpMethod | undefined\n  readonly url?: string | URL | undefined\n  readonly urlParams?: UrlParams.Input | undefined\n  readonly hash?: string | undefined\n  readonly headers?: Headers.Input | undefined\n  readonly body?: Body.HttpBody | undefined\n  readonly accept?: string | undefined\n  readonly acceptJson?: boolean | undefined\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Options {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface NoBody extends Omit<Options, \"method\" | \"url\" | \"body\"> {}\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface NoUrl extends Omit<Options, \"method\" | \"url\"> {}\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: <M extends HttpMethod>(\n  method: M\n) => (\n  url: string | URL,\n  options?: (M extends \"GET\" | \"HEAD\" ? Options.NoBody : Options.NoUrl) | undefined\n) => HttpClientRequest = internal.make\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const get: (url: string | URL, options?: Options.NoBody) => HttpClientRequest = internal.get\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const post: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.post\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const patch: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.patch\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const put: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.put\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const del: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.del\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const head: (url: string | URL, options?: Options.NoBody) => HttpClientRequest = internal.head\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const options: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.options\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const modify: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (options: Options): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, options: Options): HttpClientRequest\n} = internal.modify\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setMethod: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (method: HttpMethod): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, method: HttpMethod): HttpClientRequest\n} = internal.setMethod\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHeader: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, key: string, value: string): HttpClientRequest\n} = internal.setHeader\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHeaders: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Headers.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: Headers.Input): HttpClientRequest\n} = internal.setHeaders\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const basicAuth: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (username: string | Redacted, password: string | Redacted): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   self: HttpClientRequest,\n   username: string | Redacted,\n   password: string | Redacted\n  ): HttpClientRequest\n} = internal.basicAuth\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bearerToken: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (token: string | Redacted): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, token: string | Redacted): HttpClientRequest\n} = internal.bearerToken\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const accept: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (mediaType: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, mediaType: string): HttpClientRequest\n} = internal.accept\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const acceptJson: (self: HttpClientRequest) => HttpClientRequest = internal.acceptJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (url: string | URL): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, url: string | URL): HttpClientRequest\n} = internal.setUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const prependUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (path: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, path: string): HttpClientRequest\n} = internal.prependUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (path: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, path: string): HttpClientRequest\n} = internal.appendUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const updateUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (f: (url: string) => string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, f: (url: string) => string): HttpClientRequest\n} = internal.updateUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setUrlParam: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, key: string, value: string): HttpClientRequest\n} = internal.setUrlParam\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setUrlParams: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: UrlParams.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: UrlParams.Input): HttpClientRequest\n} = internal.setUrlParams\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendUrlParam: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, key: string, value: string): HttpClientRequest\n} = internal.appendUrlParam\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendUrlParams: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: UrlParams.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: UrlParams.Input): HttpClientRequest\n} = internal.appendUrlParams\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHash: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (hash: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, hash: string): HttpClientRequest\n} = internal.setHash\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const removeHash: (self: HttpClientRequest) => HttpClientRequest = internal.removeHash\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toUrl: (self: HttpClientRequest) => Option.Option<URL> = internal.toUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setBody: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: Body.HttpBody): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: Body.HttpBody): HttpClientRequest\n} = internal.setBody\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyUint8Array: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: Uint8Array, contentType?: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: Uint8Array, contentType?: string): HttpClientRequest\n} = internal.bodyUint8Array\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyText: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: string, contentType?: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: string, contentType?: string): HttpClientRequest\n} = internal.bodyText\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyJson: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: unknown): (self: HttpClientRequest) => Effect.Effect<HttpClientRequest, Body.HttpBodyError>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: unknown): Effect.Effect<HttpClientRequest, Body.HttpBodyError>\n} = internal.bodyJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyUnsafeJson: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: unknown): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: unknown): HttpClientRequest\n} = internal.bodyUnsafeJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const schemaBodyJson: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  (body: A): (self: HttpClientRequest) => Effect.Effect<HttpClientRequest, Body.HttpBodyError, R>\n  (self: HttpClientRequest, body: A): Effect.Effect<HttpClientRequest, Body.HttpBodyError, R>\n} = internal.schemaBodyJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyUrlParams: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: UrlParams.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: UrlParams.Input): HttpClientRequest\n} = internal.bodyUrlParams\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFormData: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: FormData): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: FormData): HttpClientRequest\n} = internal.bodyFormData\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFormDataRecord: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (entries: Body.FormDataInput): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, entries: Body.FormDataInput): HttpClientRequest\n} = internal.bodyFormDataRecord\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyStream: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   body: Stream.Stream<Uint8Array, unknown>,\n   options?: { readonly contentType?: string | undefined; readonly contentLength?: number | undefined } | undefined\n  ): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   self: HttpClientRequest,\n   body: Stream.Stream<Uint8Array, unknown>,\n   options?: { readonly contentType?: string | undefined; readonly contentLength?: number | undefined } | undefined\n  ): HttpClientRequest\n} = internal.bodyStream\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFile: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   path: string,\n   options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ): (self: HttpClientRequest) => Effect.Effect<HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   self: HttpClientRequest,\n   path: string,\n   options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ): Effect.Effect<HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>\n} = internal.bodyFile\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFileWeb: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (file: Body.HttpBody.FileLike): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, file: Body.HttpBody.FileLike): HttpClientRequest\n} = internal.bodyFileWeb\n","/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Deferred from \"effect/Deferred\"\nimport type * as Duration from \"effect/Duration\"\nimport type * as Effect from \"effect/Effect\"\nimport type { LazyArg } from \"effect/Function\"\nimport type * as Layer from \"effect/Layer\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport type * as Pool from \"effect/Pool\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as Stream from \"effect/Stream\"\nimport * as internal from \"./internal/worker.js\"\nimport type { WorkerError, WorkerErrorFrom } from \"./WorkerError.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface BackingWorker<I, O> {\n  readonly send: (message: I, transfers?: ReadonlyArray<unknown>) => Effect.Effect<void, WorkerError>\n  readonly run: <A, E, R>(\n    handler: (_: BackingWorker.Message<O>) => Effect.Effect<A, E, R>\n  ) => Effect.Effect<never, E | WorkerError, R>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace BackingWorker {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Message<O> = readonly [ready: 0] | readonly [data: 1, O]\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const PlatformWorkerTypeId: unique symbol = internal.PlatformWorkerTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type PlatformWorkerTypeId = typeof PlatformWorkerTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface PlatformWorker {\n  readonly [PlatformWorkerTypeId]: PlatformWorkerTypeId\n  readonly spawn: <I, O>(id: number) => Effect.Effect<BackingWorker<I, O>, WorkerError, Spawner>\n}\n\n/**\n * @since 1.0.0\n */\nexport const makePlatform: <W>() => <\n  P extends { readonly postMessage: (message: any, transfers?: any | undefined) => void }\n>(\n  options: {\n    readonly setup: (options: { readonly worker: W; readonly scope: Scope.Scope }) => Effect.Effect<P, WorkerError>\n    readonly listen: (\n      options: {\n        readonly port: P\n        readonly emit: (data: any) => void\n        readonly deferred: Deferred.Deferred<never, WorkerError>\n        readonly scope: Scope.Scope\n      }\n    ) => Effect.Effect<void>\n  }\n) => PlatformWorker = internal.makePlatform\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const PlatformWorker: Context.Tag<PlatformWorker, PlatformWorker> = internal.PlatformWorker\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Worker<I, O, E = never> {\n  readonly id: number\n  readonly execute: (message: I) => Stream.Stream<O, E | WorkerError>\n  readonly executeEffect: (message: I) => Effect.Effect<O, E | WorkerError>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Spawner {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Spawner: Context.Tag<Spawner, SpawnerFn<unknown>> = internal.Spawner\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface SpawnerFn<W = unknown> {\n  (id: number): W\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace Worker {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Options<I> {\n    readonly encode?: ((message: I) => Effect.Effect<unknown, WorkerError>) | undefined\n    readonly initialMessage?: LazyArg<I> | undefined\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Request<I = unknown> =\n    | readonly [id: number, data: 0, I, trace: Span | undefined]\n    | readonly [id: number, interrupt: 1]\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Span = readonly [traceId: string, spanId: string, sampled: boolean]\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Response<E, O = unknown> =\n    | readonly [id: number, data: 0, ReadonlyArray<O>]\n    | readonly [id: number, end: 1]\n    | readonly [id: number, end: 1, ReadonlyArray<O>]\n    | readonly [id: number, error: 2, E]\n    | readonly [id: number, defect: 3, Schema.CauseEncoded<WorkerErrorFrom, unknown>]\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface WorkerPool<I, O, E = never> {\n  readonly backing: Pool.Pool<Worker<I, O, E>, WorkerError>\n  readonly broadcast: (message: I) => Effect.Effect<void, E | WorkerError>\n  readonly execute: (message: I) => Stream.Stream<O, E | WorkerError>\n  readonly executeEffect: (message: I) => Effect.Effect<O, E | WorkerError>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace WorkerPool {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Options<I> =\n    & Worker.Options<I>\n    & ({\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly size: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n    } | {\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly minSize: number\n      readonly maxSize: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n      readonly timeToLive: Duration.DurationInput\n    })\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const WorkerManagerTypeId: unique symbol = internal.WorkerManagerTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type WorkerManagerTypeId = typeof WorkerManagerTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface WorkerManager {\n  readonly [WorkerManagerTypeId]: WorkerManagerTypeId\n  readonly spawn: <I, O, E>(\n    options: Worker.Options<I>\n  ) => Effect.Effect<Worker<I, O, E>, WorkerError, Scope.Scope | Spawner>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WorkerManager: Context.Tag<WorkerManager, WorkerManager> = internal.WorkerManager\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeManager: Effect.Effect<WorkerManager, never, PlatformWorker> = internal.makeManager\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerManager: Layer.Layer<WorkerManager, never, PlatformWorker> = internal.layerManager\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makePool: <I, O, E>(\n  options: WorkerPool.Options<I>\n) => Effect.Effect<WorkerPool<I, O, E>, WorkerError, WorkerManager | Spawner | Scope.Scope> = internal.makePool\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makePoolLayer: <Tag, I, O, E>(\n  tag: Context.Tag<Tag, WorkerPool<I, O, E>>,\n  options: WorkerPool.Options<I>\n) => Layer.Layer<Tag, WorkerError, WorkerManager | Spawner> = internal.makePoolLayer\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface SerializedWorker<I extends Schema.TaggedRequest.All> {\n  readonly id: number\n  readonly execute: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Stream.Stream<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n  readonly executeEffect: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Effect.Effect<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace SerializedWorker {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Options<I> = Extract<I, { readonly _tag: \"InitialMessage\" }> extends never ? {\n      readonly initialMessage?: LazyArg<I>\n    }\n    : {\n      readonly initialMessage: LazyArg<Extract<I, { readonly _tag: \"InitialMessage\" }>>\n    }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface SerializedWorkerPool<I extends Schema.TaggedRequest.All> {\n  readonly backing: Pool.Pool<SerializedWorker<I>, WorkerError>\n  readonly broadcast: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer _A, infer _I, infer E, infer _EI, infer R>\n    ? Effect.Effect<void, E | WorkerError | ParseResult.ParseError, R>\n    : never\n  readonly execute: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Stream.Stream<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n  readonly executeEffect: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Effect.Effect<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace SerializedWorkerPool {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Options<I> =\n    & SerializedWorker.Options<I>\n    & ({\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly size: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n    } | {\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly minSize: number\n      readonly maxSize: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n      readonly timeToLive: Duration.DurationInput\n    })\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeSerialized: <I extends Schema.TaggedRequest.All>(\n  options: SerializedWorker.Options<I>\n) => Effect.Effect<SerializedWorker<I>, WorkerError, WorkerManager | Spawner | Scope.Scope> = internal.makeSerialized\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makePoolSerialized: <I extends Schema.TaggedRequest.All>(\n  options: SerializedWorkerPool.Options<I>\n) => Effect.Effect<SerializedWorkerPool<I>, WorkerError, WorkerManager | Spawner | Scope.Scope> =\n  internal.makePoolSerialized\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const makePoolSerializedLayer: <Tag, I extends Schema.TaggedRequest.All>(\n  tag: Context.Tag<Tag, SerializedWorkerPool<I>>,\n  options: SerializedWorkerPool.Options<I>\n) => Layer.Layer<Tag, WorkerError, WorkerManager | Spawner> = internal.makePoolSerializedLayer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerSpawner: <W = unknown>(spawner: SpawnerFn<W>) => Layer.Layer<Spawner, never, never> =\n  internal.layerSpawner\n","/**\n * @since 1.0.0\n */\nimport type * as Worker from \"@effect/platform/Worker\"\nimport type * as Layer from \"effect/Layer\"\nimport * as internal from \"./internal/worker.js\"\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerManager: Layer.Layer<Worker.WorkerManager> = internal.layerManager\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWorker: Layer.Layer<Worker.PlatformWorker> = internal.layerWorker\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layer: (\n  spawn: (id: number) => Worker | SharedWorker | MessagePort\n) => Layer.Layer<Worker.WorkerManager | Worker.Spawner> = internal.layer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerPlatform: (\n  spawn: (id: number) => globalThis.Worker | globalThis.SharedWorker | MessagePort\n) => Layer.Layer<Worker.PlatformWorker | Worker.Spawner> = internal.layerPlatform\n","/**\n * @since 2.0.0\n */\nimport * as Cause from \"./Cause.js\"\nimport * as Deferred from \"./Deferred.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as Exit from \"./Exit.js\"\nimport * as Fiber from \"./Fiber.js\"\nimport * as FiberId from \"./FiberId.js\"\nimport { constFalse, constVoid, dual } from \"./Function.js\"\nimport * as HashSet from \"./HashSet.js\"\nimport * as Inspectable from \"./Inspectable.js\"\nimport * as Iterable from \"./Iterable.js\"\nimport { type Pipeable, pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport * as Runtime from \"./Runtime.js\"\nimport type * as Scope from \"./Scope.js\"\n\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/FiberSet\")\n\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @categories models\n */\nexport interface FiberSet<out A = unknown, out E = unknown>\n  extends Pipeable, Inspectable.Inspectable, Iterable<Fiber.RuntimeFiber<A, E>>\n{\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    readonly backing: Set<Fiber.RuntimeFiber<A, E>>\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}\n\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberSet = (u: unknown): u is FiberSet<unknown, unknown> => Predicate.hasProperty(u, TypeId)\n\nconst Proto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator](this: FiberSet<unknown, unknown>) {\n    if (this.state._tag === \"Closed\") {\n      return Iterable.empty()\n    }\n    return this.state.backing[Symbol.iterator]()\n  },\n  toString(this: FiberSet<unknown, unknown>) {\n    return Inspectable.format(this.toJSON())\n  },\n  toJSON(this: FiberSet<unknown, unknown>) {\n    return {\n      _id: \"FiberMap\",\n      state: this.state\n    }\n  },\n  [Inspectable.NodeInspectSymbol](this: FiberSet<unknown, unknown>) {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst unsafeMake = <A, E>(\n  backing: Set<Fiber.RuntimeFiber<A, E>>,\n  deferred: Deferred.Deferred<void, unknown>\n): FiberSet<A, E> => {\n  const self = Object.create(Proto)\n  self.state = { _tag: \"Open\", backing }\n  self.deferred = deferred\n  return self\n}\n\n/**\n * A FiberSet can be used to store a collection of fibers.\n * When the associated Scope is closed, all fibers in the set will be interrupted.\n *\n * You can add fibers to the set using `FiberSet.add` or `FiberSet.run`, and the fibers will\n * be automatically removed from the FiberSet when they complete.\n *\n * @example\n * ```ts\n * import { Effect, FiberSet } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const set = yield* FiberSet.make()\n *\n *   // run some effects and add the fibers to the set\n *   yield* FiberSet.run(set, Effect.never)\n *   yield* FiberSet.run(set, Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = <A = unknown, E = unknown>(): Effect.Effect<FiberSet<A, E>, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    Effect.map(Deferred.make<void, unknown>(), (deferred) => unsafeMake(new Set(), deferred)),\n    (set) =>\n      Effect.withFiberRuntime((parent) => {\n        const state = set.state\n        if (state._tag === \"Closed\") return Effect.void\n        set.state = { _tag: \"Closed\" }\n        const fibers = state.backing\n        return Fiber.interruptAllAs(fibers, FiberId.combine(parent.id(), internalFiberId)).pipe(\n          Effect.intoDeferred(set.deferred)\n        )\n      })\n  )\n\n/**\n * Create an Effect run function that is backed by a FiberSet.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = <R = never, A = unknown, E = unknown>(): Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?: Runtime.RunForkOptions | undefined\n  ) => Fiber.RuntimeFiber<XA, XE>,\n  never,\n  Scope.Scope | R\n> =>\n  Effect.flatMap(\n    make<A, E>(),\n    (self) => runtime(self)<R>()\n  )\n\n/**\n * Create an Effect run function that is backed by a FiberSet.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = <R = never, A = unknown, E = unknown>(): Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?: Runtime.RunForkOptions | undefined\n  ) => Promise<XA>,\n  never,\n  Scope.Scope | R\n> =>\n  Effect.flatMap(\n    make<A, E>(),\n    (self) => runtimePromise(self)<R>()\n  )\n\nconst internalFiberIdId = -1\nconst internalFiberId = FiberId.make(internalFiberIdId, 0)\nconst isInternalInterruption = Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n})\n\n/**\n * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeAdd: {\n  /**\n   * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly interruptAs?: FiberId.FiberId | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): (self: FiberSet<A, E>) => void\n  /**\n   * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    self: FiberSet<A, E>,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly interruptAs?: FiberId.FiberId | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): void\n} = dual((args) => isFiberSet(args[0]), <A, E, XE extends E, XA extends A>(\n  self: FiberSet<A, E>,\n  fiber: Fiber.RuntimeFiber<XA, XE>,\n  options?: {\n    readonly interruptAs?: FiberId.FiberId | undefined\n    readonly propagateInterruption?: boolean | undefined\n  } | undefined\n): void => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n    return\n  } else if (self.state.backing.has(fiber)) {\n    return\n  }\n  self.state.backing.add(fiber)\n  fiber.addObserver((exit) => {\n    if (self.state._tag === \"Closed\") {\n      return\n    }\n    self.state.backing.delete(fiber)\n    if (\n      Exit.isFailure(exit) &&\n      (\n        options?.propagateInterruption === true ?\n          !isInternalInterruption(exit.cause) :\n          !Cause.isInterruptedOnly(exit.cause)\n      )\n    ) {\n      Deferred.unsafeDone(self.deferred, exit as any)\n    }\n  })\n})\n\n/**\n * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const add: {\n  /**\n   * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): (self: FiberSet<A, E>) => Effect.Effect<void>\n  /**\n   * Add a fiber to the FiberSet. When the fiber completes, it will be removed.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    self: FiberSet<A, E>,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<void>\n} = dual(\n  (args) => isFiberSet(args[0]),\n  <A, E, XE extends E, XA extends A>(\n    self: FiberSet<A, E>,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<void> =>\n    Effect.fiberIdWith((fiberId) =>\n      Effect.sync(() =>\n        unsafeAdd(self, fiber, {\n          ...options,\n          interruptAs: fiberId\n        })\n      )\n    )\n)\n\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = <A, E>(self: FiberSet<A, E>): Effect.Effect<void> =>\n  Effect.withFiberRuntime((clearFiber) => {\n    if (self.state._tag === \"Closed\") {\n      return Effect.void\n    }\n    return Effect.forEach(self.state.backing, (fiber) =>\n      // will be removed by the observer\n      Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)))\n  })\n\nconst constInterruptedFiber = (function() {\n  let fiber: Fiber.RuntimeFiber<never, never> | undefined = undefined\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt)\n    }\n    return fiber\n  }\n})()\n\n/**\n * Fork an Effect and add the forked fiber to the FiberSet.\n * When the fiber completes, it will be removed from the FiberSet.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run: {\n  /**\n   * Fork an Effect and add the forked fiber to the FiberSet.\n   * When the fiber completes, it will be removed from the FiberSet.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E>(\n    self: FiberSet<A, E>,\n    options?: {\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): <R, XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>\n  ) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>\n  /**\n   * Fork an Effect and add the forked fiber to the FiberSet.\n   * When the fiber completes, it will be removed from the FiberSet.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, R, XE extends E, XA extends A>(\n    self: FiberSet<A, E>,\n    effect: Effect.Effect<XA, XE, R>,\n    options?: {\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>\n} = function() {\n  const self = arguments[0] as FiberSet<any, any>\n  if (!Effect.isEffect(arguments[1])) {\n    const options = arguments[1]\n    return (effect: Effect.Effect<any, any, any>) => runImpl(self, effect, options)\n  }\n  return runImpl(self, arguments[1], arguments[2]) as any\n}\n\nconst runImpl = <A, E, R, XE extends E, XA extends A>(\n  self: FiberSet<A, E>,\n  effect: Effect.Effect<XA, XE, R>,\n  options?: {\n    readonly propagateInterruption?: boolean | undefined\n  }\n): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R> =>\n  Effect.fiberIdWith((fiberId) => {\n    if (self.state._tag === \"Closed\") {\n      return Effect.sync(constInterruptedFiber)\n    }\n    return Effect.tap(\n      Effect.forkDaemon(effect),\n      (fiber) =>\n        unsafeAdd(self, fiber, {\n          ...options,\n          interruptAs: fiberId\n        })\n    )\n  })\n\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberSet } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const set = yield* FiberSet.make()\n *   const run = yield* FiberSet.runtime(set)<Users>()\n *\n *   // run some effects and add the fibers to the set\n *   run(Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime: <A, E>(\n  self: FiberSet<A, E>\n) => <R = never>() => Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n      | undefined\n  ) => Fiber.RuntimeFiber<XA, XE>,\n  never,\n  R\n> = <A, E>(self: FiberSet<A, E>) => <R>() =>\n  Effect.map(\n    Effect.runtime<R>(),\n    (runtime) => {\n      const runFork = Runtime.runFork(runtime)\n      return <XE extends E, XA extends A>(\n        effect: Effect.Effect<XA, XE, R>,\n        options?:\n          | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n          | undefined\n      ) => {\n        if (self.state._tag === \"Closed\") {\n          return constInterruptedFiber()\n        }\n        const fiber = runFork(effect, options)\n        unsafeAdd(self, fiber)\n        return fiber\n      }\n    }\n  )\n\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberSet.\n *\n * The returned run function will return Promise's.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = <A, E>(self: FiberSet<A, E>): <R = never>() => Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n      | undefined\n  ) => Promise<XA>,\n  never,\n  R\n> =>\n<R>() =>\n  Effect.map(\n    runtime(self)<R>(),\n    (runFork) =>\n    <XE extends E, XA extends A>(\n      effect: Effect.Effect<XA, XE, R>,\n      options?:\n        | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n        | undefined\n    ): Promise<XA> =>\n      new Promise((resolve, reject) =>\n        runFork(effect, options).addObserver((exit) => {\n          if (Exit.isSuccess(exit)) {\n            resolve(exit.value)\n          } else {\n            reject(Cause.squash(exit.cause))\n          }\n        })\n      )\n  )\n\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const size = <A, E>(self: FiberSet<A, E>): Effect.Effect<number> =>\n  Effect.sync(() => self.state._tag === \"Closed\" ? 0 : self.state.backing.size)\n\n/**\n * Join all fibers in the FiberSet. If any of the Fiber's in the set terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberSet } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const set = yield* _(FiberSet.make());\n *   yield* _(FiberSet.add(set, Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberSet.join(set));\n * });\n * ```\n */\nexport const join = <A, E>(self: FiberSet<A, E>): Effect.Effect<void, E> =>\n  Deferred.await(self.deferred as Deferred.Deferred<void, E>)\n\n/**\n * Wait until the fiber set is empty.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = <A, E>(self: FiberSet<A, E>): Effect.Effect<void> =>\n  Effect.whileLoop({\n    while: () => self.state._tag === \"Open\" && self.state.backing.size > 0,\n    body: () => Fiber.await(Iterable.unsafeHead(self)),\n    step: constVoid\n  })\n","/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface CollectorService {\n  readonly addAll: (_: Iterable<globalThis.Transferable>) => Effect.Effect<void>\n  readonly unsafeAddAll: (_: Iterable<globalThis.Transferable>) => void\n  readonly read: Effect.Effect<Array<globalThis.Transferable>>\n  readonly unsafeRead: () => Array<globalThis.Transferable>\n  readonly unsafeClear: () => Array<globalThis.Transferable>\n  readonly clear: Effect.Effect<Array<globalThis.Transferable>>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class Collector extends Context.Tag(\"@effect/platform/Transferable/Collector\")<\n  Collector,\n  CollectorService\n>() {}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeMakeCollector = (): CollectorService => {\n  let tranferables: Array<globalThis.Transferable> = []\n  const unsafeAddAll = (transfers: Iterable<globalThis.Transferable>): void => {\n    // eslint-disable-next-line no-restricted-syntax\n    tranferables.push(...transfers)\n  }\n  const unsafeRead = (): Array<globalThis.Transferable> => tranferables\n  const unsafeClear = (): Array<globalThis.Transferable> => {\n    const prev = tranferables\n    tranferables = []\n    return prev\n  }\n  return Collector.of({\n    unsafeAddAll,\n    addAll: (transferables) => Effect.sync(() => unsafeAddAll(transferables)),\n    unsafeRead,\n    read: Effect.sync(unsafeRead),\n    unsafeClear,\n    clear: Effect.sync(unsafeClear)\n  })\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeCollector: Effect.Effect<CollectorService> = Effect.sync(unsafeMakeCollector)\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const addAll = (tranferables: Iterable<globalThis.Transferable>): Effect.Effect<void> =>\n  Effect.flatMap(\n    Effect.serviceOption(Collector),\n    Option.match({\n      onNone: () => Effect.void,\n      onSome: (_) => _.addAll(tranferables)\n    })\n  )\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schema: {\n  /**\n   * @since 1.0.0\n   * @category schema\n   */\n  <I>(f: (_: I) => Iterable<globalThis.Transferable>): <A, R>(self: Schema.Schema<A, I, R>) => Schema.Schema<A, I, R>\n  /**\n   * @since 1.0.0\n   * @category schema\n   */\n  <A, I, R>(\n    self: Schema.Schema<A, I, R>,\n    f: (_: I) => Iterable<globalThis.Transferable>\n  ): Schema.Schema<A, I, R>\n} = dual(2, <A, I, R>(\n  self: Schema.Schema<A, I, R>,\n  f: (_: I) => Iterable<globalThis.Transferable>\n) =>\n  Schema.transformOrFail(\n    Schema.encodedSchema(self),\n    self,\n    { strict: true, decode: ParseResult.succeed, encode: (i) => Effect.as(addAll(f(i)), i) }\n  ))\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const ImageData: Schema.Schema<ImageData> = schema(\n  Schema.Any,\n  (_) => [(_ as ImageData).data.buffer]\n)\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const MessagePort: Schema.Schema<MessagePort> = schema(\n  Schema.Any,\n  (_) => [_ as MessagePort]\n)\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const Uint8Array: Schema.Schema<Uint8Array> = schema(\n  Schema.Uint8ArrayFromSelf,\n  (_) => [_.buffer]\n)\n","/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport * as FileSystem from \"./FileSystem.js\"\nimport type * as Headers from \"./Headers.js\"\nimport * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpIncomingMessage\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpIncomingMessage<E> extends Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly headers: Headers.Headers\n  readonly remoteAddress: Option.Option<string>\n  readonly json: Effect.Effect<unknown, E>\n  readonly text: Effect.Effect<string, E>\n  readonly urlParamsBody: Effect.Effect<UrlParams.UrlParams, E>\n  readonly arrayBuffer: Effect.Effect<ArrayBuffer, E>\n  readonly stream: Stream.Stream<Uint8Array, E>\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return <E>(self: HttpIncomingMessage<E>): Effect.Effect<A, E | ParseResult.ParseError, R> =>\n    Effect.flatMap(self.json, parse)\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyUrlParams = <\n  A,\n  I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>,\n  R\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const decode = UrlParams.schemaStruct(schema, options)\n  return <E>(self: HttpIncomingMessage<E>): Effect.Effect<A, E | ParseResult.ParseError, R> =>\n    Effect.flatMap(self.urlParamsBody, decode)\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaHeaders = <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return <E>(self: HttpIncomingMessage<E>): Effect.Effect<A, ParseResult.ParseError, R> => parse(self.headers)\n}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxBodySize extends Context.Reference<MaxBodySize>()(\"@effect/platform/HttpIncomingMessage/MaxBodySize\", {\n  defaultValue: Option.none<FileSystem.Size>\n}) {}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxBodySize = dual<\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (size: Option.Option<FileSystem.SizeInput>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: Option.Option<FileSystem.SizeInput>) => Effect.Effect<A, E, R>\n>(2, (effect, size) => Effect.provideService(effect, MaxBodySize, Option.map(size, FileSystem.Size)))\n\n/**\n * @since 1.0.0\n */\nexport const inspect = <E>(self: HttpIncomingMessage<E>, that: object): object => {\n  const contentType = self.headers[\"content-type\"] ?? \"\"\n  let body: unknown\n  if (contentType.includes(\"application/json\")) {\n    try {\n      body = Effect.runSync(self.json)\n    } catch {\n      //\n    }\n  } else if (contentType.includes(\"text/\") || contentType.includes(\"urlencoded\")) {\n    try {\n      body = Effect.runSync(self.text)\n    } catch {\n      //\n    }\n  }\n  const obj: any = {\n    ...that,\n    headers: Inspectable.redact(self.headers),\n    remoteAddress: self.remoteAddress.toJSON()\n  }\n  if (body !== undefined) {\n    obj.body = body\n  }\n  return obj\n}\n","/**\n * @since 1.0.0\n */\nimport * as Arr from \"effect/Array\"\nimport type * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport { dual } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface UrlParams extends ReadonlyArray<readonly [string, string]> {}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Input =\n  | CoercibleRecord\n  | Iterable<readonly [string, Coercible]>\n  | URLSearchParams\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Coercible = string | number | bigint | boolean | null | undefined\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface CoercibleRecord {\n  readonly [key: string]: Coercible | ReadonlyArray<Coercible> | CoercibleRecord\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromInput = (input: Input): UrlParams => {\n  const parsed = fromInputNested(input)\n  const out: Array<[string, string]> = []\n  for (let i = 0; i < parsed.length; i++) {\n    if (Array.isArray(parsed[i][0])) {\n      const [keys, value] = parsed[i] as [Array<string>, string]\n      out.push([`${keys[0]}[${keys.slice(1).join(\"][\")}]`, value])\n    } else {\n      out.push(parsed[i] as [string, string])\n    }\n  }\n  return out\n}\n\nconst fromInputNested = (input: Input): Array<[string | Array<string>, any]> => {\n  const entries = Symbol.iterator in input ? Arr.fromIterable(input) : Object.entries(input)\n  const out: Array<[string | Array<string>, string]> = []\n  for (const [key, value] of entries) {\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (value[i] !== undefined) {\n          out.push([key, String(value[i])])\n        }\n      }\n    } else if (typeof value === \"object\") {\n      const nested = fromInputNested(value as CoercibleRecord)\n      for (const [k, v] of nested) {\n        out.push([[key, ...(typeof k === \"string\" ? [k] : k)], v])\n      }\n    } else if (value !== undefined) {\n      out.push([key, String(value)])\n    }\n  }\n  return out\n}\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schemaFromSelf: Schema.Schema<UrlParams> = Schema.Array(\n  Schema.Tuple(Schema.String, Schema.String)\n).annotations({ identifier: \"UrlParams\" })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: UrlParams = []\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const getAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => ReadonlyArray<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): ReadonlyArray<string>\n} = dual(\n  2,\n  (self: UrlParams, key: string): ReadonlyArray<string> =>\n    Arr.reduce(self, [] as Array<string>, (acc, [k, value]) => {\n      if (k === key) {\n        acc.push(value)\n      }\n      return acc\n    })\n)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const getFirst: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => Option.Option<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): Option.Option<string>\n} = dual(2, (self: UrlParams, key: string): Option.Option<string> =>\n  Option.map(\n    Arr.findFirst(self, ([k]) => k === key),\n    ([, value]) => value\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const getLast: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => Option.Option<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): Option.Option<string>\n} = dual(2, (self: UrlParams, key: string): Option.Option<string> =>\n  Option.map(\n    Arr.findLast(self, ([k]) => k === key),\n    ([, value]) => value\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const set: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: Coercible): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string, value: Coercible): UrlParams\n} = dual(3, (self: UrlParams, key: string, value: Coercible): UrlParams =>\n  Arr.append(\n    Arr.filter(self, ([k]) => k !== key),\n    [key, String(value)]\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Input): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, input: Input): UrlParams\n} = dual(2, (self: UrlParams, input: Input): UrlParams => {\n  const toSet = fromInput(input)\n  const keys = toSet.map(([k]) => k)\n  return Arr.appendAll(\n    Arr.filter(self, ([k]) => keys.includes(k)),\n    toSet\n  )\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const append: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: Coercible): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string, value: Coercible): UrlParams\n} = dual(3, (self: UrlParams, key: string, value: Coercible): UrlParams =>\n  Arr.append(\n    self,\n    [key, String(value)]\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Input): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, input: Input): UrlParams\n} = dual(2, (self: UrlParams, input: Input): UrlParams => Arr.appendAll(self, fromInput(input)))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const remove: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): UrlParams\n} = dual(2, (self: UrlParams, key: string): UrlParams => Arr.filter(self, ([k]) => k !== key))\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const makeUrl = (url: string, params: UrlParams, hash: Option.Option<string>): Either.Either<URL, Error> => {\n  try {\n    const urlInstance = new URL(url, baseUrl())\n    for (let i = 0; i < params.length; i++) {\n      const [key, value] = params[i]\n      if (value !== undefined) {\n        urlInstance.searchParams.append(key, value)\n      }\n    }\n    if (hash._tag === \"Some\") {\n      urlInstance.hash = hash.value\n    }\n    return Either.right(urlInstance)\n  } catch (e) {\n    return Either.left(e as Error)\n  }\n}\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toString = (self: UrlParams): string => new URLSearchParams(self as any).toString()\n\nconst baseUrl = (): string | undefined => {\n  if (\n    \"location\" in globalThis &&\n    globalThis.location !== undefined &&\n    globalThis.location.origin !== undefined &&\n    globalThis.location.pathname !== undefined\n  ) {\n    return location.origin + location.pathname\n  }\n  return undefined\n}\n\n/**\n * Builds a `Record` containing all the key-value pairs in the given `UrlParams`\n * as `string` (if only one value for a key) or a `NonEmptyArray<string>`\n * (when more than one value for a key)\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { UrlParams } from \"@effect/platform\"\n *\n * const urlParams = UrlParams.fromInput({ a: 1, b: true, c: \"string\", e: [1, 2, 3] })\n * const result = UrlParams.toRecord(urlParams)\n *\n * assert.deepStrictEqual(\n *   result,\n *   { \"a\": \"1\", \"b\": \"true\", \"c\": \"string\", \"e\": [\"1\", \"2\", \"3\"] }\n * )\n * ```\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toRecord = (self: UrlParams): Record<string, string | Arr.NonEmptyArray<string>> => {\n  const out: Record<string, string | Arr.NonEmptyArray<string>> = Object.create(null)\n  for (const [k, value] of self) {\n    const curr = out[k]\n    if (curr === undefined) {\n      out[k] = value\n    } else if (typeof curr === \"string\") {\n      out[k] = [curr, value]\n    } else {\n      curr.push(value)\n    }\n  }\n  return { ...out }\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined): {\n  (\n    field: string\n  ): (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>\n  (\n    self: UrlParams,\n    field: string\n  ): Effect.Effect<A, ParseResult.ParseError, R>\n} => {\n  const parse = Schema.decodeUnknown(Schema.parseJson(schema), options)\n  return dual<\n    (field: string) => (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>,\n    (self: UrlParams, field: string) => Effect.Effect<A, ParseResult.ParseError, R>\n  >(2, (self, field) => parse(Option.getOrElse(getLast(self, field), () => \"\")))\n}\n\n/**\n * Extract schema from all key-value pairs in the given `UrlParams`.\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, Schema } from \"effect\"\n * import { UrlParams } from \"@effect/platform\"\n *\n * Effect.gen(function* () {\n *   const urlParams = UrlParams.fromInput({ \"a\": [10, \"string\"], \"b\": false })\n *   const result = yield* UrlParams.schemaStruct(Schema.Struct({\n *     a: Schema.Tuple(Schema.NumberFromString, Schema.String),\n *     b: Schema.BooleanFromString\n *   }))(urlParams)\n *\n *   assert.deepStrictEqual(result, {\n *     a: [10, \"string\"],\n *     b: false\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n * @category schema\n */\nexport const schemaStruct = <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) =>\n(self: UrlParams): Effect.Effect<A, ParseResult.ParseError, R> => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return parse(toRecord(self))\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaFromString: Schema.Schema<UrlParams, string> = Schema.transform(\n  Schema.String,\n  schemaFromSelf,\n  {\n    decode(fromA) {\n      return fromInput(new URLSearchParams(fromA))\n    },\n    encode(toI) {\n      return toString(toI)\n    }\n  }\n)\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaRecord = <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(\n  schema: Schema.Schema<A, I, R>\n): Schema.Schema<A, UrlParams, R> =>\n  Schema.transform(\n    schemaFromSelf,\n    schema,\n    {\n      decode(fromA) {\n        return toRecord(fromA) as I\n      },\n      encode(toI) {\n        return fromInput(toI as Input) as UrlParams\n      }\n    }\n  )\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaParse = <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(\n  schema: Schema.Schema<A, I, R>\n): Schema.Schema<A, string, R> =>\n  Schema.compose(\n    schemaFromString,\n    schemaRecord(schema)\n  )\n","/**\n * @since 1.0.0\n */\nimport * as Option from \"effect/Option\"\nimport * as Tracer from \"effect/Tracer\"\nimport * as Headers from \"./Headers.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface FromHeaders {\n  (headers: Headers.Headers): Option.Option<Tracer.ExternalSpan>\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const toHeaders = (span: Tracer.Span): Headers.Headers =>\n  Headers.unsafeFromRecord({\n    b3: `${span.traceId}-${span.spanId}-${span.sampled ? \"1\" : \"0\"}${\n      span.parent._tag === \"Some\" ? `-${span.parent.value.spanId}` : \"\"\n    }`,\n    traceparent: `00-${span.traceId}-${span.spanId}-${span.sampled ? \"01\" : \"00\"}`\n  })\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const fromHeaders = (headers: Headers.Headers): Option.Option<Tracer.ExternalSpan> => {\n  let span = w3c(headers)\n  if (span._tag === \"Some\") {\n    return span\n  }\n  span = b3(headers)\n  if (span._tag === \"Some\") {\n    return span\n  }\n  return xb3(headers)\n}\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const b3: FromHeaders = (headers) => {\n  if (!(\"b3\" in headers)) {\n    return Option.none()\n  }\n  const parts = headers[\"b3\"].split(\"-\")\n  if (parts.length < 2) {\n    return Option.none()\n  }\n  return Option.some(Tracer.externalSpan({\n    traceId: parts[0],\n    spanId: parts[1],\n    sampled: parts[2] ? parts[2] === \"1\" : true\n  }))\n}\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const xb3: FromHeaders = (headers) => {\n  if (!(headers[\"x-b3-traceid\"]) || !(headers[\"x-b3-spanid\"])) {\n    return Option.none()\n  }\n  return Option.some(Tracer.externalSpan({\n    traceId: headers[\"x-b3-traceid\"],\n    spanId: headers[\"x-b3-spanid\"],\n    sampled: headers[\"x-b3-sampled\"] ? headers[\"x-b3-sampled\"] === \"1\" : true\n  }))\n}\n\nconst w3cTraceId = /^[0-9a-f]{32}$/i\nconst w3cSpanId = /^[0-9a-f]{16}$/i\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const w3c: FromHeaders = (headers) => {\n  if (!(headers[\"traceparent\"])) {\n    return Option.none()\n  }\n  const parts = headers[\"traceparent\"].split(\"-\")\n  if (parts.length !== 4) {\n    return Option.none()\n  }\n  const [version, traceId, spanId, flags] = parts\n  switch (version) {\n    case \"00\": {\n      if (w3cTraceId.test(traceId) === false || w3cSpanId.test(spanId) === false) {\n        return Option.none()\n      }\n      return Option.some(Tracer.externalSpan({\n        traceId,\n        spanId,\n        sampled: (parseInt(flags, 16) & 1) === 1\n      }))\n    }\n    default: {\n      return Option.none()\n    }\n  }\n}\n","/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport type { Branded } from \"effect/Brand\"\nimport type * as FiberId from \"effect/FiberId\"\nimport * as Schema from \"effect/Schema\"\nimport type * as Rpc from \"./Rpc.js\"\nimport type { RpcClientError } from \"./RpcClientError.js\"\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type FromClient<A extends Rpc.Any> = Request<A> | Ack | Interrupt | Eof\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type FromClientEncoded = RequestEncoded | AckEncoded | InterruptEncoded | Ping | Eof\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const RequestIdTypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcServer/RequestId\")\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type RequestIdTypeId = typeof RequestIdTypeId\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type RequestId = Branded<bigint, RequestIdTypeId>\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const RequestId = (id: bigint | string): RequestId =>\n  typeof id === \"bigint\" ? id as RequestId : BigInt(id) as RequestId\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface RequestEncoded {\n  readonly _tag: \"Request\"\n  readonly id: string\n  readonly tag: string\n  readonly payload: unknown\n  readonly headers: ReadonlyArray<[string, string]>\n  readonly traceId?: string | undefined\n  readonly spanId?: string | undefined\n  readonly sampled?: boolean | undefined\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Request<A extends Rpc.Any> {\n  readonly _tag: \"Request\"\n  readonly id: RequestId\n  readonly tag: Rpc.Tag<A>\n  readonly payload: Rpc.Payload<A>\n  readonly headers: Headers\n  readonly traceId?: string | undefined\n  readonly spanId?: string | undefined\n  readonly sampled?: boolean | undefined\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Ack {\n  readonly _tag: \"Ack\"\n  readonly requestId: RequestId\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Interrupt {\n  readonly _tag: \"Interrupt\"\n  readonly requestId: RequestId\n  readonly interruptors: ReadonlyArray<FiberId.FiberId>\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface AckEncoded {\n  readonly _tag: \"Ack\"\n  readonly requestId: string\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface InterruptEncoded {\n  readonly _tag: \"Interrupt\"\n  readonly requestId: string\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Eof {\n  readonly _tag: \"Eof\"\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Ping {\n  readonly _tag: \"Ping\"\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const constEof: Eof = { _tag: \"Eof\" }\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const constPing: Ping = { _tag: \"Ping\" }\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type FromServer<A extends Rpc.Any> =\n  | ResponseChunk<A>\n  | ResponseExit<A>\n  | ResponseDefect\n  | ClientEnd\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type FromServerEncoded =\n  | ResponseChunkEncoded\n  | ResponseExitEncoded\n  | ResponseDefectEncoded\n  | Pong\n  | ClientProtocolError\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport const ResponseIdTypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcServer/ResponseId\")\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type ResponseIdTypeId = typeof ResponseIdTypeId\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type ResponseId = Branded<number, ResponseIdTypeId>\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseChunkEncoded {\n  readonly _tag: \"Chunk\"\n  readonly requestId: string\n  readonly values: NonEmptyReadonlyArray<unknown>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseChunk<A extends Rpc.Any> {\n  readonly _tag: \"Chunk\"\n  readonly clientId: number\n  readonly requestId: RequestId\n  readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunk<A>>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseExitEncoded {\n  readonly _tag: \"Exit\"\n  readonly requestId: string\n  readonly exit: Schema.ExitEncoded<unknown, unknown, unknown>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ClientProtocolError {\n  readonly _tag: \"ClientProtocolError\"\n  readonly error: RpcClientError\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseExit<A extends Rpc.Any> {\n  readonly _tag: \"Exit\"\n  readonly clientId: number\n  readonly requestId: RequestId\n  readonly exit: Rpc.Exit<A>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseDefectEncoded {\n  readonly _tag: \"Defect\"\n  readonly defect: unknown\n}\n\nconst encodeDefect = Schema.encodeSync(Schema.Defect)\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport const ResponseDefectEncoded = (input: unknown): ResponseDefectEncoded => ({\n  _tag: \"Defect\",\n  defect: encodeDefect(input)\n})\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseDefect {\n  readonly _tag: \"Defect\"\n  readonly clientId: number\n  readonly defect: unknown\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ClientEnd {\n  readonly _tag: \"ClientEnd\"\n  readonly clientId: number\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface Pong {\n  readonly _tag: \"Pong\"\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport const constPong: Pong = { _tag: \"Pong\" }\n","/**\n * @since 1.0.0\n */\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Error from \"./Error.js\"\nimport type * as ClientRequest from \"./HttpClientRequest.js\"\nimport type * as ClientResponse from \"./HttpClientResponse.js\"\nimport * as internal from \"./internal/httpClientError.js\"\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isHttpClientError = (u: unknown): u is HttpClientError => hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport type HttpClientError = RequestError | ResponseError\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class RequestError extends Error.TypeIdError(TypeId, \"RequestError\")<{\n  readonly request: ClientRequest.HttpClientRequest\n  readonly reason: \"Transport\" | \"Encode\" | \"InvalidUrl\"\n  readonly cause?: unknown\n  readonly description?: string\n}> {\n  get methodAndUrl() {\n    return `${this.request.method} ${this.request.url}`\n  }\n\n  get message() {\n    return this.description ?\n      `${this.reason}: ${this.description} (${this.methodAndUrl})` :\n      `${this.reason} error (${this.methodAndUrl})`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class ResponseError extends Error.TypeIdError(TypeId, \"ResponseError\")<{\n  readonly request: ClientRequest.HttpClientRequest\n  readonly response: ClientResponse.HttpClientResponse\n  readonly reason: \"StatusCode\" | \"Decode\" | \"EmptyBody\"\n  readonly cause?: unknown\n  readonly description?: string\n}> {\n  get methodAndUrl() {\n    return `${this.request.method} ${this.request.url}`\n  }\n\n  get message() {\n    const info = `${this.response.status} ${this.methodAndUrl}`\n    return this.description ?\n      `${this.reason}: ${this.description} (${info})` :\n      `${this.reason} error (${info})`\n  }\n}\n","/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Layer from \"effect/Layer\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Msgpackr from \"msgpackr\"\nimport type * as RpcMessage from \"./RpcMessage.js\"\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport class RpcSerialization extends Context.Tag(\"@effect/rpc/RpcSerialization\")<RpcSerialization, {\n  unsafeMake(): Parser\n  readonly contentType: string\n  readonly includesFraming: boolean\n}>() {}\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport interface Parser {\n  readonly decode: (data: Uint8Array | string) => ReadonlyArray<unknown>\n  readonly encode: (response: unknown) => Uint8Array | string | undefined\n}\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const json: RpcSerialization[\"Type\"] = RpcSerialization.of({\n  contentType: \"application/json\",\n  includesFraming: false,\n  unsafeMake: () => {\n    const decoder = new TextDecoder()\n    return {\n      decode: (bytes) => [JSON.parse(typeof bytes === \"string\" ? bytes : decoder.decode(bytes))],\n      encode: (response) => JSON.stringify(response)\n    }\n  }\n})\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const ndjson: RpcSerialization[\"Type\"] = RpcSerialization.of({\n  contentType: \"application/ndjson\",\n  includesFraming: true,\n  unsafeMake: () => {\n    const decoder = new TextDecoder()\n    let buffer = \"\"\n    return ({\n      decode: (bytes) => {\n        buffer += typeof bytes === \"string\" ? bytes : decoder.decode(bytes)\n        let position = 0\n        let nlIndex = buffer.indexOf(\"\\n\", position)\n        const items: Array<unknown> = []\n        while (nlIndex !== -1) {\n          const item = JSON.parse(buffer.slice(position, nlIndex))\n          items.push(item)\n          position = nlIndex + 1\n          nlIndex = buffer.indexOf(\"\\n\", position)\n        }\n        buffer = buffer.slice(position)\n        return items\n      },\n      encode: (response) => {\n        if (Array.isArray(response)) {\n          if (response.length === 0) return undefined\n          let data = \"\"\n          for (let i = 0; i < response.length; i++) {\n            data += JSON.stringify(response[i]) + \"\\n\"\n          }\n          return data\n        }\n        return JSON.stringify(response) + \"\\n\"\n      }\n    })\n  }\n})\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const jsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): RpcSerialization[\"Type\"] =>\n  RpcSerialization.of({\n    contentType: options?.contentType ?? \"application/json\",\n    includesFraming: false,\n    unsafeMake: () => {\n      const decoder = new TextDecoder()\n      const batches = new Map<string, {\n        readonly size: number\n        readonly responses: Map<string, RpcMessage.FromServerEncoded>\n      }>()\n      return {\n        decode: (bytes) => {\n          const decoded: JsonRpcMessage | Array<JsonRpcMessage> = JSON.parse(\n            typeof bytes === \"string\" ? bytes : decoder.decode(bytes)\n          )\n          return decodeJsonRpcRaw(decoded, batches)\n        },\n        encode: (response) => {\n          if (Array.isArray(response)) {\n            if (response.length === 0) return undefined\n            return JSON.stringify(response.map(encodeJsonRpcMessage))\n          }\n          const encoded = encodeJsonRpcRaw(response as any, batches)\n          return encoded && JSON.stringify(encoded)\n        }\n      }\n    }\n  })\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const ndJsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): RpcSerialization[\"Type\"] =>\n  RpcSerialization.of({\n    contentType: options?.contentType ?? \"application/json-rpc\",\n    includesFraming: true,\n    unsafeMake: () => {\n      const parser = ndjson.unsafeMake()\n      const batches = new Map<string, {\n        readonly size: number\n        readonly responses: Map<string, RpcMessage.FromServerEncoded>\n      }>()\n      return ({\n        decode: (bytes) => {\n          const frames = parser.decode(bytes)\n          if (frames.length === 0) return []\n          const messages: Array<RpcMessage.FromClientEncoded | RpcMessage.FromServerEncoded> = []\n          for (let i = 0; i < frames.length; i++) {\n            const frame = frames[i]\n            // eslint-disable-next-line no-restricted-syntax\n            messages.push(...decodeJsonRpcRaw(frame as any, batches) as any)\n          }\n          return messages\n        },\n        encode: (response) => {\n          if (Array.isArray(response)) {\n            return parser.encode(response.map(encodeJsonRpcMessage))\n          }\n          const encoded = encodeJsonRpcRaw(response as any, batches)\n          return encoded && parser.encode(encoded)\n        }\n      })\n    }\n  })\n\nfunction decodeJsonRpcRaw(\n  decoded: JsonRpcMessage | Array<JsonRpcMessage>,\n  batches: Map<string, {\n    readonly size: number\n    readonly responses: Map<string, RpcMessage.FromServerEncoded>\n  }>\n) {\n  if (Array.isArray(decoded)) {\n    const batch = {\n      size: 0,\n      responses: new Map<string, RpcMessage.FromServerEncoded>()\n    }\n    const messages: Array<RpcMessage.FromClientEncoded | RpcMessage.FromServerEncoded> = []\n    for (let i = 0; i < decoded.length; i++) {\n      const message = decodeJsonRpcMessage(decoded[i])\n      if (message._tag === \"Request\") {\n        batch.size++\n        batches.set(message.id, batch)\n      }\n    }\n    return messages\n  }\n  return Array.isArray(decoded) ? decoded.map(decodeJsonRpcMessage) : [decodeJsonRpcMessage(decoded)]\n}\n\nfunction decodeJsonRpcMessage(decoded: JsonRpcMessage): RpcMessage.FromClientEncoded | RpcMessage.FromServerEncoded {\n  if (\"method\" in decoded) {\n    if (!decoded.id && decoded.method.startsWith(\"@effect/rpc/\")) {\n      const tag = decoded.method.slice(\"@effect/rpc/\".length) as\n        | RpcMessage.FromServerEncoded[\"_tag\"]\n        | Exclude<RpcMessage.FromClientEncoded[\"_tag\"], \"Request\">\n      const requestId = (decoded as any).params?.requestId\n      return requestId ?\n        {\n          _tag: tag,\n          requestId: String(requestId)\n        } as any :\n        { _tag: tag } as any\n    }\n    return {\n      _tag: \"Request\",\n      id: decoded.id ? String(decoded.id) : \"\",\n      tag: decoded.method,\n      payload: decoded.params,\n      headers: decoded.headers ?? [],\n      traceId: decoded.traceId,\n      spanId: decoded.spanId,\n      sampled: decoded.sampled\n    }\n  } else if (decoded.error && decoded.error._tag === \"Defect\") {\n    return {\n      _tag: \"Defect\",\n      defect: decoded.error.data\n    }\n  } else if (decoded.chunk === true) {\n    return {\n      _tag: \"Chunk\",\n      requestId: String(decoded.id),\n      values: decoded.result as any\n    }\n  }\n  return {\n    _tag: \"Exit\",\n    requestId: String(decoded.id),\n    exit: decoded.error != null ?\n      {\n        _tag: \"Failure\",\n        cause: decoded.error._tag === \"Cause\" ?\n          decoded.error.data as any :\n          {\n            _tag: \"Die\",\n            defect: decoded.error\n          }\n      } :\n      {\n        _tag: \"Success\",\n        value: decoded.result\n      }\n  }\n}\n\nfunction encodeJsonRpcRaw(\n  response: RpcMessage.FromServerEncoded | RpcMessage.FromClientEncoded,\n  batches: Map<string, {\n    readonly size: number\n    readonly responses: Map<string, RpcMessage.FromServerEncoded>\n  }>\n) {\n  if (!(\"requestId\" in response)) {\n    return encodeJsonRpcMessage(response)\n  }\n  const batch = batches.get(response.requestId)\n  if (batch) {\n    batches.delete(response.requestId)\n    batch.responses.set(response.requestId, response as any)\n    if (batch.size === batch.responses.size) {\n      return Array.from(batch.responses.values(), encodeJsonRpcMessage)\n    }\n    return undefined\n  }\n  return encodeJsonRpcMessage(response)\n}\n\nfunction encodeJsonRpcMessage(response: RpcMessage.FromServerEncoded | RpcMessage.FromClientEncoded): JsonRpcMessage {\n  switch (response._tag) {\n    case \"Request\":\n      return {\n        jsonrpc: \"2.0\",\n        method: response.tag,\n        params: response.payload,\n        id: response.id && Number(response.id),\n        headers: response.headers,\n        traceId: response.traceId,\n        spanId: response.spanId,\n        sampled: response.sampled\n      }\n    case \"Ping\":\n    case \"Pong\":\n    case \"Interrupt\":\n    case \"Ack\":\n    case \"Eof\":\n      return {\n        jsonrpc: \"2.0\",\n        method: `@effect/rpc/${response._tag}`,\n        params: \"requestId\" in response ? { requestId: response.requestId } : undefined\n      }\n    case \"Chunk\":\n      return {\n        jsonrpc: \"2.0\",\n        chunk: true,\n        id: Number(response.requestId),\n        result: response.values\n      }\n    case \"Exit\":\n      return {\n        jsonrpc: \"2.0\",\n        id: response.requestId ? Number(response.requestId) : undefined,\n        result: response.exit._tag === \"Success\" ? response.exit.value : undefined,\n        error: response.exit._tag === \"Failure\" ?\n          {\n            _tag: \"Cause\",\n            code: response.exit.cause._tag === \"Fail\" && hasProperty(response.exit.cause.error, \"code\")\n              ? Number(response.exit.cause.error.code)\n              : 0,\n            message: response.exit.cause._tag === \"Fail\" && hasProperty(response.exit.cause.error, \"message\")\n              ? response.exit.cause.error.message\n              : JSON.stringify(response.exit.cause),\n            data: response.exit.cause\n          } :\n          undefined\n      } as any\n    case \"Defect\":\n      return {\n        jsonrpc: \"2.0\",\n        id: jsonRpcInternalError,\n        error: {\n          _tag: \"Defect\",\n          code: 1,\n          message: \"A defect occurred\",\n          data: response.defect\n        }\n      }\n    case \"ClientProtocolError\":\n      return {} as never\n  }\n}\n\nconst jsonRpcInternalError = -32603\n\ninterface JsonRpcRequest {\n  readonly jsonrpc: \"2.0\"\n  readonly id?: number | string | null\n  readonly method: string\n  readonly params?: unknown\n  readonly headers?: ReadonlyArray<[string, string]>\n  readonly traceId?: string\n  readonly spanId?: string\n  readonly sampled?: boolean\n}\n\ninterface JsonRpcResponse {\n  readonly jsonrpc: \"2.0\"\n  readonly id?: number | string | null\n  readonly result?: unknown\n  readonly chunk?: boolean\n  readonly error?: {\n    readonly code: number\n    readonly message: string\n    readonly data?: unknown\n    readonly _tag?: \"Cause\" | \"Defect\"\n  }\n}\n\ntype JsonRpcMessage = JsonRpcRequest | JsonRpcResponse\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const msgPack: RpcSerialization[\"Type\"] = RpcSerialization.of({\n  contentType: \"application/msgpack\",\n  includesFraming: true,\n  unsafeMake: () => {\n    const unpackr = new Msgpackr.Unpackr()\n    const packr = new Msgpackr.Packr()\n    const encoder = new TextEncoder()\n    let incomplete: Uint8Array | undefined = undefined\n    return {\n      decode: (bytes) => {\n        let buf = typeof bytes === \"string\" ? encoder.encode(bytes) : bytes\n        if (incomplete !== undefined) {\n          const prev = buf\n          bytes = new Uint8Array(incomplete.length + buf.length)\n          bytes.set(incomplete)\n          bytes.set(prev, incomplete.length)\n          buf = bytes\n          incomplete = undefined\n        }\n        try {\n          return unpackr.unpackMultiple(buf)\n        } catch (error_) {\n          const error = error_ as any\n          if (error.incomplete) {\n            incomplete = buf.subarray(error.lastPosition)\n            return error.values ?? []\n          }\n          return []\n        }\n      },\n      encode: (response) => packr.pack(response)\n    }\n  }\n})\n\n/**\n * A rpc serialization layer that uses JSON for serialization.\n *\n * Use this if your protocol supports framing for messages, otherwise use\n * {@link layerNdjson}.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerJson: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, json)\n\n/**\n * A rpc serialization layer that uses NDJSON for serialization.\n *\n * Use this if your protocol does not support framing for messages, otherwise\n * use {@link layerJson}.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerNdjson: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, ndjson)\n\n/**\n * A rpc serialization layer that uses JSON-RPC for serialization.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerJsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): Layer.Layer<RpcSerialization> => Layer.succeed(RpcSerialization, jsonRpc(options))\n\n/**\n * A rpc serialization layer that uses JSON-RPC for serialization seperated by\n * new lines.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerNdJsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): Layer.Layer<RpcSerialization> => Layer.succeed(RpcSerialization, ndJsonRpc(options))\n\n/**\n * A rpc serialization layer that uses MessagePack for serialization.\n *\n * MessagePack has a more compact binary format compared to JSON and NDJSON. It\n * also has better support for binary data.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerMsgPack: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, msgPack)\n","/**\n * @since 1.0.0\n */\nimport * as Channel from \"effect/Channel\"\nimport type * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Deferred from \"effect/Deferred\"\nimport type { DurationInput } from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as ExecutionStrategy from \"effect/ExecutionStrategy\"\nimport * as Exit from \"effect/Exit\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberSet from \"effect/FiberSet\"\nimport { dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Scope from \"effect/Scope\"\nimport type * as AsyncProducer from \"effect/SingleProducerAsyncInput\"\nimport { TypeIdError } from \"./Error.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/Socket\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isSocket = (u: unknown): u is Socket => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Socket: Context.Tag<Socket, Socket> = Context.GenericTag<Socket>(\n  \"@effect/platform/Socket\"\n)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Socket {\n  readonly [TypeId]: TypeId\n  readonly run: <_, E = never, R = never>(\n    handler: (_: Uint8Array) => Effect.Effect<_, E, R> | void,\n    options?: {\n      readonly onOpen?: Effect.Effect<void> | undefined\n    }\n  ) => Effect.Effect<void, SocketError | E, R>\n  readonly runRaw: <_, E = never, R = never>(\n    handler: (_: string | Uint8Array) => Effect.Effect<_, E, R> | void,\n    options?: {\n      readonly onOpen?: Effect.Effect<void> | undefined\n    }\n  ) => Effect.Effect<void, SocketError | E, R>\n  readonly writer: Effect.Effect<\n    (chunk: Uint8Array | string | CloseEvent) => Effect.Effect<void, SocketError>,\n    never,\n    Scope.Scope\n  >\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const CloseEventTypeId: unique symbol = Symbol.for(\"@effect/platform/Socket/CloseEvent\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type CloseEventTypeId = typeof CloseEventTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport class CloseEvent {\n  /**\n   * @since 1.0.0\n   */\n  readonly [CloseEventTypeId]: CloseEventTypeId\n  constructor(readonly code = 1000, readonly reason?: string) {\n    this[CloseEventTypeId] = CloseEventTypeId\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    return this.reason ? `${this.code}: ${this.reason}` : `${this.code}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isCloseEvent = (u: unknown): u is CloseEvent => Predicate.hasProperty(u, CloseEventTypeId)\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const SocketErrorTypeId: unique symbol = Symbol.for(\"@effect/platform/Socket/SocketError\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type SocketErrorTypeId = typeof SocketErrorTypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isSocketError = (u: unknown): u is SocketError => Predicate.hasProperty(u, SocketErrorTypeId)\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport type SocketError = SocketGenericError | SocketCloseError\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketGenericError extends TypeIdError(SocketErrorTypeId, \"SocketError\")<{\n  readonly reason: \"Write\" | \"Read\" | \"Open\" | \"OpenTimeout\"\n  readonly cause: unknown\n}> {\n  get message() {\n    return `An error occurred during ${this.reason}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketCloseError extends TypeIdError(SocketErrorTypeId, \"SocketError\")<{\n  readonly reason: \"Close\"\n  readonly code: number\n  readonly closeReason?: string | undefined\n}> {\n  /**\n   * @since 1.0.0\n   */\n  static is(u: unknown): u is SocketCloseError {\n    return isSocketError(u) && u.reason === \"Close\"\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  static isClean(isClean: (code: number) => boolean) {\n    return function(u: unknown): u is SocketCloseError {\n      return SocketCloseError.is(u) && isClean(u.code)\n    }\n  }\n\n  get message() {\n    if (this.closeReason) {\n      return `${this.reason}: ${this.code}: ${this.closeReason}`\n    }\n    return `${this.reason}: ${this.code}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelMap = <IE, A>(\n  self: Socket,\n  f: (data: Uint8Array | string) => A\n): Channel.Channel<\n  Chunk.Chunk<A>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> =>\n  Effect.gen(function*() {\n    const scope = yield* Effect.scope\n    const mailbox = yield* Mailbox.make<A, SocketError | IE>()\n    const writeScope = yield* Scope.fork(scope, ExecutionStrategy.sequential)\n    const write = yield* Scope.extend(self.writer, writeScope)\n    function* emit(chunk: Chunk.Chunk<Uint8Array | string | CloseEvent>) {\n      for (const data of chunk) {\n        yield* write(data)\n      }\n    }\n    const input: AsyncProducer.AsyncInputProducer<IE, Chunk.Chunk<Uint8Array | string | CloseEvent>, unknown> = {\n      awaitRead: () => Effect.void,\n      emit(chunk) {\n        return Effect.catchAllCause(\n          Effect.gen(() => emit(chunk)),\n          (cause) => mailbox.failCause(cause)\n        )\n      },\n      error(error) {\n        return Effect.zipRight(\n          Scope.close(writeScope, Exit.void),\n          mailbox.failCause(error)\n        )\n      },\n      done() {\n        return Scope.close(writeScope, Exit.void)\n      }\n    }\n\n    yield* self.runRaw((data) => {\n      mailbox.unsafeOffer(f(data))\n    }).pipe(\n      Mailbox.into(mailbox),\n      Effect.forkIn(scope),\n      Effect.interruptible\n    )\n\n    return Channel.embedInput(Mailbox.toChannel(mailbox), input)\n  }).pipe(Channel.unwrapScoped)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannel = <IE>(\n  self: Socket\n): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> => {\n  const encoder = new TextEncoder()\n  return toChannelMap(self, (data) => typeof data === \"string\" ? encoder.encode(data) : data)\n}\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelString: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (encoding?: string | undefined): <IE>(self: Socket) => Channel.Channel<\n    Chunk.Chunk<string>,\n    Chunk.Chunk<Uint8Array | string | CloseEvent>,\n    SocketError | IE,\n    IE,\n    void,\n    unknown\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <IE>(self: Socket, encoding?: string | undefined): Channel.Channel<\n    Chunk.Chunk<string>,\n    Chunk.Chunk<Uint8Array | string | CloseEvent>,\n    SocketError | IE,\n    IE,\n    void,\n    unknown\n  >\n} = dual((args) => isSocket(args[0]), <IE>(\n  self: Socket,\n  encoding?: string | undefined\n): Channel.Channel<\n  Chunk.Chunk<string>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> => {\n  const decoder = new TextDecoder(encoding)\n  return toChannelMap(self, (data) => typeof data === \"string\" ? data : decoder.decode(data))\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelWith = <IE = never>() =>\n(\n  self: Socket\n): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> => toChannel(self)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeChannel = <IE = never>(): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown,\n  Socket\n> => Channel.unwrap(Effect.map(Socket, toChannelWith<IE>()))\n\n/**\n * @since 1.0.0\n */\nexport const defaultCloseCodeIsError = (code: number) => code !== 1000 && code !== 1006\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface WebSocket {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WebSocket: Context.Tag<WebSocket, globalThis.WebSocket> = Context.GenericTag(\n  \"@effect/platform/Socket/WebSocket\"\n)\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface WebSocketConstructor {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WebSocketConstructor: Context.Tag<\n  WebSocketConstructor,\n  (url: string, protocols?: string | Array<string> | undefined) => globalThis.WebSocket\n> = Context\n  .GenericTag(\"@effect/platform/Socket/WebSocketConstructor\")\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWebSocketConstructorGlobal: Layer.Layer<WebSocketConstructor> = Layer.succeed(\n  WebSocketConstructor,\n  (url, protocols) => new globalThis.WebSocket(url, protocols)\n)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWebSocket = (url: string | Effect.Effect<string>, options?: {\n  readonly closeCodeIsError?: ((code: number) => boolean) | undefined\n  readonly openTimeout?: DurationInput | undefined\n  readonly protocols?: string | Array<string> | undefined\n}): Effect.Effect<Socket, never, WebSocketConstructor> =>\n  fromWebSocket(\n    Effect.acquireRelease(\n      (typeof url === \"string\" ? Effect.succeed(url) : url).pipe(\n        Effect.flatMap((url) => Effect.map(WebSocketConstructor, (f) => f(url, options?.protocols)))\n      ),\n      (ws) => Effect.sync(() => ws.close(1000))\n    ),\n    options\n  )\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromWebSocket = <RO>(\n  acquire: Effect.Effect<globalThis.WebSocket, SocketError, RO>,\n  options?: {\n    readonly closeCodeIsError?: (code: number) => boolean\n    readonly openTimeout?: DurationInput\n  }\n): Effect.Effect<Socket, never, Exclude<RO, Scope.Scope>> =>\n  Effect.withFiberRuntime((fiber) => {\n    let currentWS: globalThis.WebSocket | undefined\n    const latch = Effect.unsafeMakeLatch(false)\n    const acquireContext = fiber.currentContext as Context.Context<RO>\n    const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError\n\n    const runRaw = <_, E, R>(handler: (_: string | Uint8Array) => Effect.Effect<_, E, R> | void, opts?: {\n      readonly onOpen?: Effect.Effect<void> | undefined\n    }) =>\n      Effect.scopedWith(Effect.fnUntraced(function*(scope) {\n        const fiberSet = yield* FiberSet.make<any, E | SocketError>().pipe(\n          Scope.extend(scope)\n        )\n        const ws = yield* Scope.extend(acquire, scope)\n        const run = yield* Effect.provideService(FiberSet.runtime(fiberSet)<R>(), WebSocket, ws)\n        let open = false\n\n        function onMessage(event: MessageEvent) {\n          if (event.data instanceof Blob) {\n            return Effect.promise(() => event.data.arrayBuffer() as Promise<ArrayBuffer>).pipe(\n              Effect.andThen((buffer) => handler(new Uint8Array(buffer))),\n              run\n            )\n          }\n          const result = handler(event.data)\n          if (Effect.isEffect(result)) {\n            run(result)\n          }\n        }\n        function onError(cause: Event) {\n          ws.removeEventListener(\"message\", onMessage)\n          ws.removeEventListener(\"close\", onClose)\n          Deferred.unsafeDone(\n            fiberSet.deferred,\n            Effect.fail(new SocketGenericError({ reason: open ? \"Read\" : \"Open\", cause }))\n          )\n        }\n        function onClose(event: globalThis.CloseEvent) {\n          ws.removeEventListener(\"message\", onMessage)\n          ws.removeEventListener(\"error\", onError)\n          Deferred.unsafeDone(\n            fiberSet.deferred,\n            Effect.fail(\n              new SocketCloseError({\n                reason: \"Close\",\n                code: event.code,\n                closeReason: event.reason\n              })\n            )\n          )\n        }\n\n        ws.addEventListener(\"close\", onClose, { once: true })\n        ws.addEventListener(\"error\", onError, { once: true })\n        ws.addEventListener(\"message\", onMessage)\n\n        if (ws.readyState !== 1) {\n          const openDeferred = Deferred.unsafeMake<void>(fiber.id())\n          ws.addEventListener(\"open\", () => {\n            open = true\n            Deferred.unsafeDone(openDeferred, Effect.void)\n          }, { once: true })\n          yield* Deferred.await(openDeferred).pipe(\n            Effect.timeoutFail({\n              duration: options?.openTimeout ?? 10000,\n              onTimeout: () => new SocketGenericError({ reason: \"OpenTimeout\", cause: \"timeout waiting for \\\"open\\\"\" })\n            }),\n            Effect.raceFirst(FiberSet.join(fiberSet))\n          )\n        }\n        open = true\n        currentWS = ws\n        yield* latch.open\n        if (opts?.onOpen) yield* opts.onOpen\n        return yield* FiberSet.join(fiberSet).pipe(\n          Effect.catchIf(\n            SocketCloseError.isClean((_) => !closeCodeIsError(_)),\n            (_) => Effect.void\n          )\n        )\n      })).pipe(\n        Effect.mapInputContext((input: Context.Context<R>) => Context.merge(acquireContext, input)),\n        Effect.ensuring(Effect.sync(() => {\n          latch.unsafeClose()\n          currentWS = undefined\n        })),\n        Effect.interruptible\n      )\n\n    const encoder = new TextEncoder()\n    const run = <_, E, R>(handler: (_: Uint8Array) => Effect.Effect<_, E, R> | void, opts?: {\n      readonly onOpen?: Effect.Effect<void> | undefined\n    }) =>\n      runRaw((data) =>\n        typeof data === \"string\"\n          ? handler(encoder.encode(data))\n          : data instanceof Uint8Array\n          ? handler(data)\n          : handler(new Uint8Array(data)), opts)\n\n    const write = (chunk: Uint8Array | string | CloseEvent) =>\n      latch.whenOpen(Effect.sync(() => {\n        const ws = currentWS!\n        if (isCloseEvent(chunk)) {\n          ws.close(chunk.code, chunk.reason)\n        } else {\n          ws.send(chunk)\n        }\n      }))\n    const writer = Effect.succeed(write)\n\n    return Effect.succeed(Socket.of({\n      [TypeId]: TypeId,\n      run,\n      runRaw,\n      writer\n    }))\n  })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWebSocketChannel = <IE = never>(\n  url: string,\n  options?: {\n    readonly closeCodeIsError?: (code: number) => boolean\n  }\n): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown,\n  WebSocketConstructor\n> =>\n  Channel.unwrapScoped(\n    Effect.map(makeWebSocket(url, options), toChannelWith<IE>())\n  )\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWebSocket = (url: string, options?: {\n  readonly closeCodeIsError?: (code: number) => boolean\n}): Layer.Layer<Socket, never, WebSocketConstructor> =>\n  Layer.effect(\n    Socket,\n    makeWebSocket(url, options)\n  )\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentSendQueueCapacity: FiberRef.FiberRef<number> = globalValue(\n  \"@effect/platform/Socket/currentSendQueueCapacity\",\n  () => FiberRef.unsafeMake(16)\n)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface InputTransformStream {\n  readonly readable: ReadableStream<Uint8Array> | ReadableStream<string> | ReadableStream<Uint8Array | string>\n  readonly writable: WritableStream<Uint8Array>\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromTransformStream = <R>(acquire: Effect.Effect<InputTransformStream, SocketError, R>, options?: {\n  readonly closeCodeIsError?: (code: number) => boolean\n}): Effect.Effect<Socket, never, Exclude<R, Scope.Scope>> =>\n  Effect.withFiberRuntime((fiber) => {\n    const latch = Effect.unsafeMakeLatch(false)\n    let currentStream: {\n      readonly stream: InputTransformStream\n      readonly fiberSet: FiberSet.FiberSet<any, any>\n    } | undefined\n    const acquireContext = fiber.currentContext as Context.Context<R>\n    const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError\n    const runRaw = <_, E, R>(handler: (_: string | Uint8Array) => Effect.Effect<_, E, R> | void, opts?: {\n      readonly onOpen?: Effect.Effect<void> | undefined\n    }) =>\n      Effect.scopedWith(Effect.fnUntraced(function*(scope) {\n        const stream = yield* Scope.extend(acquire, scope)\n        const reader = stream.readable.getReader()\n        yield* Scope.addFinalizer(scope, Effect.promise(() => reader.cancel()))\n        const fiberSet = yield* FiberSet.make<any, E | SocketError>().pipe(\n          Scope.extend(scope)\n        )\n        const runFork = yield* FiberSet.runtime(fiberSet)<R>()\n\n        yield* Effect.tryPromise({\n          try: async () => {\n            while (true) {\n              const { done, value } = await reader.read()\n              if (done) {\n                throw new SocketCloseError({ reason: \"Close\", code: 1000 })\n              }\n              const result = handler(value)\n              if (Effect.isEffect(result)) {\n                runFork(result)\n              }\n            }\n          },\n          catch: (cause) => isSocketError(cause) ? cause : new SocketGenericError({ reason: \"Read\", cause })\n        }).pipe(\n          FiberSet.run(fiberSet)\n        )\n\n        currentStream = { stream, fiberSet }\n        yield* latch.open\n        if (opts?.onOpen) yield* opts.onOpen\n\n        return yield* FiberSet.join(fiberSet).pipe(\n          Effect.catchIf(\n            SocketCloseError.isClean((_) => !closeCodeIsError(_)),\n            (_) => Effect.void\n          )\n        )\n      })).pipe(\n        (_) => _,\n        Effect.mapInputContext((input: Context.Context<R>) => Context.merge(acquireContext, input)),\n        Effect.ensuring(Effect.sync(() => {\n          latch.unsafeClose()\n          currentStream = undefined\n        })),\n        Effect.interruptible\n      )\n\n    const encoder = new TextEncoder()\n    const run = <_, E, R>(handler: (_: Uint8Array) => Effect.Effect<_, E, R> | void, opts?: {\n      readonly onOpen?: Effect.Effect<void> | undefined\n    }) =>\n      runRaw((data) =>\n        typeof data === \"string\"\n          ? handler(encoder.encode(data))\n          : handler(data), opts)\n\n    const writers = new WeakMap<InputTransformStream, WritableStreamDefaultWriter<Uint8Array>>()\n    const getWriter = (stream: InputTransformStream) => {\n      let writer = writers.get(stream)\n      if (!writer) {\n        writer = stream.writable.getWriter()\n        writers.set(stream, writer)\n      }\n      return writer\n    }\n    const write = (chunk: Uint8Array | string | CloseEvent) =>\n      latch.whenOpen(Effect.suspend(() => {\n        const { fiberSet, stream } = currentStream!\n        if (isCloseEvent(chunk)) {\n          return Deferred.fail(\n            fiberSet.deferred,\n            new SocketCloseError({ reason: \"Close\", code: chunk.code, closeReason: chunk.reason })\n          )\n        }\n        return Effect.promise(() => getWriter(stream).write(typeof chunk === \"string\" ? encoder.encode(chunk) : chunk))\n      }))\n    const writer = Effect.acquireRelease(\n      Effect.succeed(write),\n      () =>\n        Effect.promise(async () => {\n          if (!currentStream) return\n          await getWriter(currentStream.stream).close()\n        })\n    )\n\n    return Effect.succeed(Socket.of({\n      [TypeId]: TypeId,\n      run,\n      runRaw,\n      writer\n    }))\n  })\n","/**\n * @since 1.0.0\n */\nimport * as Schema from \"effect/Schema\"\n\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcClientError\")\n\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category Errors\n */\nexport class RpcClientError extends Schema.TaggedError<RpcClientError>(\"@effect/rpc/RpcClientError\")(\"RpcClientError\", {\n  reason: Schema.Literal(\"Protocol\", \"Unknown\"),\n  message: Schema.String,\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: TypeId = TypeId\n}\n","import { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nexport const decodeIter = unpackIter\nexport const encodeIter = packIter","\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\nimport {setWriteStructSlots, RECORD_SYMBOL, addExtension} from './pack.js'\nimport {setReadStruct, mult10, readString} from './unpack.js';\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, target.byteLength - position)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tvar fullConstruct = structure.fullConstruct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tfullConstruct = structure.fullConstruct = function LoadedObject() {\n\t\t}\n\t\tfullConstruct.prototype = unpackr.structPrototype || {};\n\t\tvar prototype = construct.prototype = unpackr.structPrototype ? Object.create(unpackr.structPrototype) : {};\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('o[' + JSON.stringify(property.key) + ']=' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'var c=this;return function(s){var o=new c();' + objectLiteralProperties.join(';') + ';return o;}')).apply(fullConstruct, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.opentelemetry = (function() {\n\n    /**\n     * Namespace opentelemetry.\n     * @exports opentelemetry\n     * @namespace\n     */\n    var opentelemetry = {};\n\n    opentelemetry.proto = (function() {\n\n        /**\n         * Namespace proto.\n         * @memberof opentelemetry\n         * @namespace\n         */\n        var proto = {};\n\n        proto.common = (function() {\n\n            /**\n             * Namespace common.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var common = {};\n\n            common.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.common\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.AnyValue = (function() {\n\n                    /**\n                     * Properties of an AnyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IAnyValue\n                     * @property {string|null} [stringValue] AnyValue stringValue\n                     * @property {boolean|null} [boolValue] AnyValue boolValue\n                     * @property {number|Long|null} [intValue] AnyValue intValue\n                     * @property {number|null} [doubleValue] AnyValue doubleValue\n                     * @property {opentelemetry.proto.common.v1.IArrayValue|null} [arrayValue] AnyValue arrayValue\n                     * @property {opentelemetry.proto.common.v1.IKeyValueList|null} [kvlistValue] AnyValue kvlistValue\n                     * @property {Uint8Array|null} [bytesValue] AnyValue bytesValue\n                     */\n\n                    /**\n                     * Constructs a new AnyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an AnyValue.\n                     * @implements IAnyValue\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IAnyValue=} [properties] Properties to set\n                     */\n                    function AnyValue(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * AnyValue stringValue.\n                     * @member {string|null|undefined} stringValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.stringValue = null;\n\n                    /**\n                     * AnyValue boolValue.\n                     * @member {boolean|null|undefined} boolValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.boolValue = null;\n\n                    /**\n                     * AnyValue intValue.\n                     * @member {number|Long|null|undefined} intValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.intValue = null;\n\n                    /**\n                     * AnyValue doubleValue.\n                     * @member {number|null|undefined} doubleValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.doubleValue = null;\n\n                    /**\n                     * AnyValue arrayValue.\n                     * @member {opentelemetry.proto.common.v1.IArrayValue|null|undefined} arrayValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.arrayValue = null;\n\n                    /**\n                     * AnyValue kvlistValue.\n                     * @member {opentelemetry.proto.common.v1.IKeyValueList|null|undefined} kvlistValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.kvlistValue = null;\n\n                    /**\n                     * AnyValue bytesValue.\n                     * @member {Uint8Array|null|undefined} bytesValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.bytesValue = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * AnyValue value.\n                     * @member {\"stringValue\"|\"boolValue\"|\"intValue\"|\"doubleValue\"|\"arrayValue\"|\"kvlistValue\"|\"bytesValue\"|undefined} value\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    Object.defineProperty(AnyValue.prototype, \"value\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"boolValue\", \"intValue\", \"doubleValue\", \"arrayValue\", \"kvlistValue\", \"bytesValue\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new AnyValue instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IAnyValue=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue instance\n                     */\n                    AnyValue.create = function create(properties) {\n                        return new AnyValue(properties);\n                    };\n\n                    /**\n                     * Encodes the specified AnyValue message. Does not implicitly {@link opentelemetry.proto.common.v1.AnyValue.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IAnyValue} message AnyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AnyValue.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);\n                        if (message.boolValue != null && Object.hasOwnProperty.call(message, \"boolValue\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.boolValue);\n                        if (message.intValue != null && Object.hasOwnProperty.call(message, \"intValue\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.intValue);\n                        if (message.doubleValue != null && Object.hasOwnProperty.call(message, \"doubleValue\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.doubleValue);\n                        if (message.arrayValue != null && Object.hasOwnProperty.call(message, \"arrayValue\"))\n                            $root.opentelemetry.proto.common.v1.ArrayValue.encode(message.arrayValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.kvlistValue != null && Object.hasOwnProperty.call(message, \"kvlistValue\"))\n                            $root.opentelemetry.proto.common.v1.KeyValueList.encode(message.kvlistValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.bytesValue != null && Object.hasOwnProperty.call(message, \"bytesValue\"))\n                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.bytesValue);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified AnyValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.AnyValue.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IAnyValue} message AnyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AnyValue.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an AnyValue message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AnyValue.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.AnyValue();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.stringValue = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.boolValue = reader.bool();\n                                    break;\n                                }\n                            case 3: {\n                                    message.intValue = reader.int64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.doubleValue = reader.double();\n                                    break;\n                                }\n                            case 5: {\n                                    message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 6: {\n                                    message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 7: {\n                                    message.bytesValue = reader.bytes();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an AnyValue message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AnyValue.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an AnyValue message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    AnyValue.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n                            properties.value = 1;\n                            if (!$util.isString(message.stringValue))\n                                return \"stringValue: string expected\";\n                        }\n                        if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (typeof message.boolValue !== \"boolean\")\n                                return \"boolValue: boolean expected\";\n                        }\n                        if (message.intValue != null && message.hasOwnProperty(\"intValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))\n                                return \"intValue: integer|Long expected\";\n                        }\n                        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (typeof message.doubleValue !== \"number\")\n                                return \"doubleValue: number expected\";\n                        }\n                        if (message.arrayValue != null && message.hasOwnProperty(\"arrayValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            {\n                                var error = $root.opentelemetry.proto.common.v1.ArrayValue.verify(message.arrayValue);\n                                if (error)\n                                    return \"arrayValue.\" + error;\n                            }\n                        }\n                        if (message.kvlistValue != null && message.hasOwnProperty(\"kvlistValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValueList.verify(message.kvlistValue);\n                                if (error)\n                                    return \"kvlistValue.\" + error;\n                            }\n                        }\n                        if (message.bytesValue != null && message.hasOwnProperty(\"bytesValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!(message.bytesValue && typeof message.bytesValue.length === \"number\" || $util.isString(message.bytesValue)))\n                                return \"bytesValue: buffer expected\";\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an AnyValue message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue\n                     */\n                    AnyValue.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.AnyValue)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.AnyValue();\n                        if (object.stringValue != null)\n                            message.stringValue = String(object.stringValue);\n                        if (object.boolValue != null)\n                            message.boolValue = Boolean(object.boolValue);\n                        if (object.intValue != null)\n                            if ($util.Long)\n                                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;\n                            else if (typeof object.intValue === \"string\")\n                                message.intValue = parseInt(object.intValue, 10);\n                            else if (typeof object.intValue === \"number\")\n                                message.intValue = object.intValue;\n                            else if (typeof object.intValue === \"object\")\n                                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();\n                        if (object.doubleValue != null)\n                            message.doubleValue = Number(object.doubleValue);\n                        if (object.arrayValue != null) {\n                            if (typeof object.arrayValue !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.common.v1.AnyValue.arrayValue: object expected\");\n                            message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.fromObject(object.arrayValue);\n                        }\n                        if (object.kvlistValue != null) {\n                            if (typeof object.kvlistValue !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.common.v1.AnyValue.kvlistValue: object expected\");\n                            message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.fromObject(object.kvlistValue);\n                        }\n                        if (object.bytesValue != null)\n                            if (typeof object.bytesValue === \"string\")\n                                $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);\n                            else if (object.bytesValue.length >= 0)\n                                message.bytesValue = object.bytesValue;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an AnyValue message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.AnyValue} message AnyValue\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    AnyValue.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n                            object.stringValue = message.stringValue;\n                            if (options.oneofs)\n                                object.value = \"stringValue\";\n                        }\n                        if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n                            object.boolValue = message.boolValue;\n                            if (options.oneofs)\n                                object.value = \"boolValue\";\n                        }\n                        if (message.intValue != null && message.hasOwnProperty(\"intValue\")) {\n                            if (typeof message.intValue === \"number\")\n                                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;\n                            else\n                                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;\n                            if (options.oneofs)\n                                object.value = \"intValue\";\n                        }\n                        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) {\n                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;\n                            if (options.oneofs)\n                                object.value = \"doubleValue\";\n                        }\n                        if (message.arrayValue != null && message.hasOwnProperty(\"arrayValue\")) {\n                            object.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.toObject(message.arrayValue, options);\n                            if (options.oneofs)\n                                object.value = \"arrayValue\";\n                        }\n                        if (message.kvlistValue != null && message.hasOwnProperty(\"kvlistValue\")) {\n                            object.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.toObject(message.kvlistValue, options);\n                            if (options.oneofs)\n                                object.value = \"kvlistValue\";\n                        }\n                        if (message.bytesValue != null && message.hasOwnProperty(\"bytesValue\")) {\n                            object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;\n                            if (options.oneofs)\n                                object.value = \"bytesValue\";\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this AnyValue to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    AnyValue.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for AnyValue\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    AnyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.AnyValue\";\n                    };\n\n                    return AnyValue;\n                })();\n\n                v1.ArrayValue = (function() {\n\n                    /**\n                     * Properties of an ArrayValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IArrayValue\n                     * @property {Array.<opentelemetry.proto.common.v1.IAnyValue>|null} [values] ArrayValue values\n                     */\n\n                    /**\n                     * Constructs a new ArrayValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an ArrayValue.\n                     * @implements IArrayValue\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IArrayValue=} [properties] Properties to set\n                     */\n                    function ArrayValue(properties) {\n                        this.values = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ArrayValue values.\n                     * @member {Array.<opentelemetry.proto.common.v1.IAnyValue>} values\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @instance\n                     */\n                    ArrayValue.prototype.values = $util.emptyArray;\n\n                    /**\n                     * Creates a new ArrayValue instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IArrayValue=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue instance\n                     */\n                    ArrayValue.create = function create(properties) {\n                        return new ArrayValue(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ArrayValue message. Does not implicitly {@link opentelemetry.proto.common.v1.ArrayValue.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IArrayValue} message ArrayValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ArrayValue.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.values != null && message.values.length)\n                            for (var i = 0; i < message.values.length; ++i)\n                                $root.opentelemetry.proto.common.v1.AnyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ArrayValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.ArrayValue.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IArrayValue} message ArrayValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an ArrayValue message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ArrayValue.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.ArrayValue();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.values && message.values.length))\n                                        message.values = [];\n                                    message.values.push($root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an ArrayValue message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ArrayValue.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an ArrayValue message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ArrayValue.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.values != null && message.hasOwnProperty(\"values\")) {\n                            if (!Array.isArray(message.values))\n                                return \"values: array expected\";\n                            for (var i = 0; i < message.values.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.values[i]);\n                                if (error)\n                                    return \"values.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an ArrayValue message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue\n                     */\n                    ArrayValue.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.ArrayValue)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.ArrayValue();\n                        if (object.values) {\n                            if (!Array.isArray(object.values))\n                                throw TypeError(\".opentelemetry.proto.common.v1.ArrayValue.values: array expected\");\n                            message.values = [];\n                            for (var i = 0; i < object.values.length; ++i) {\n                                if (typeof object.values[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.common.v1.ArrayValue.values: object expected\");\n                                message.values[i] = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.values[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an ArrayValue message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.ArrayValue} message ArrayValue\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ArrayValue.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.values = [];\n                        if (message.values && message.values.length) {\n                            object.values = [];\n                            for (var j = 0; j < message.values.length; ++j)\n                                object.values[j] = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.values[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ArrayValue to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ArrayValue.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ArrayValue\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ArrayValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.ArrayValue\";\n                    };\n\n                    return ArrayValue;\n                })();\n\n                v1.KeyValueList = (function() {\n\n                    /**\n                     * Properties of a KeyValueList.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IKeyValueList\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [values] KeyValueList values\n                     */\n\n                    /**\n                     * Constructs a new KeyValueList.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents a KeyValueList.\n                     * @implements IKeyValueList\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList=} [properties] Properties to set\n                     */\n                    function KeyValueList(properties) {\n                        this.values = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * KeyValueList values.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} values\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @instance\n                     */\n                    KeyValueList.prototype.values = $util.emptyArray;\n\n                    /**\n                     * Creates a new KeyValueList instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList instance\n                     */\n                    KeyValueList.create = function create(properties) {\n                        return new KeyValueList(properties);\n                    };\n\n                    /**\n                     * Encodes the specified KeyValueList message. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValueList.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList} message KeyValueList message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValueList.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.values != null && message.values.length)\n                            for (var i = 0; i < message.values.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified KeyValueList message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValueList.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList} message KeyValueList message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValueList.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a KeyValueList message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValueList.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValueList();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.values && message.values.length))\n                                        message.values = [];\n                                    message.values.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a KeyValueList message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValueList.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a KeyValueList message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    KeyValueList.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.values != null && message.hasOwnProperty(\"values\")) {\n                            if (!Array.isArray(message.values))\n                                return \"values: array expected\";\n                            for (var i = 0; i < message.values.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.values[i]);\n                                if (error)\n                                    return \"values.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a KeyValueList message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList\n                     */\n                    KeyValueList.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.KeyValueList)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.KeyValueList();\n                        if (object.values) {\n                            if (!Array.isArray(object.values))\n                                throw TypeError(\".opentelemetry.proto.common.v1.KeyValueList.values: array expected\");\n                            message.values = [];\n                            for (var i = 0; i < object.values.length; ++i) {\n                                if (typeof object.values[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.common.v1.KeyValueList.values: object expected\");\n                                message.values[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.values[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a KeyValueList message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.KeyValueList} message KeyValueList\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    KeyValueList.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.values = [];\n                        if (message.values && message.values.length) {\n                            object.values = [];\n                            for (var j = 0; j < message.values.length; ++j)\n                                object.values[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.values[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this KeyValueList to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    KeyValueList.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for KeyValueList\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    KeyValueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.KeyValueList\";\n                    };\n\n                    return KeyValueList;\n                })();\n\n                v1.KeyValue = (function() {\n\n                    /**\n                     * Properties of a KeyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IKeyValue\n                     * @property {string|null} [key] KeyValue key\n                     * @property {opentelemetry.proto.common.v1.IAnyValue|null} [value] KeyValue value\n                     */\n\n                    /**\n                     * Constructs a new KeyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents a KeyValue.\n                     * @implements IKeyValue\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IKeyValue=} [properties] Properties to set\n                     */\n                    function KeyValue(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * KeyValue key.\n                     * @member {string|null|undefined} key\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @instance\n                     */\n                    KeyValue.prototype.key = null;\n\n                    /**\n                     * KeyValue value.\n                     * @member {opentelemetry.proto.common.v1.IAnyValue|null|undefined} value\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @instance\n                     */\n                    KeyValue.prototype.value = null;\n\n                    /**\n                     * Creates a new KeyValue instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValue=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue instance\n                     */\n                    KeyValue.create = function create(properties) {\n                        return new KeyValue(properties);\n                    };\n\n                    /**\n                     * Encodes the specified KeyValue message. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValue.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValue} message KeyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValue.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.key != null && Object.hasOwnProperty.call(message, \"key\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);\n                        if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n                            $root.opentelemetry.proto.common.v1.AnyValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValue.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValue} message KeyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValue.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a KeyValue message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValue.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValue();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.key = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.value = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a KeyValue message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValue.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a KeyValue message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    KeyValue.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.key != null && message.hasOwnProperty(\"key\"))\n                            if (!$util.isString(message.key))\n                                return \"key: string expected\";\n                        if (message.value != null && message.hasOwnProperty(\"value\")) {\n                            var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.value);\n                            if (error)\n                                return \"value.\" + error;\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue\n                     */\n                    KeyValue.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.KeyValue)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.KeyValue();\n                        if (object.key != null)\n                            message.key = String(object.key);\n                        if (object.value != null) {\n                            if (typeof object.value !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.common.v1.KeyValue.value: object expected\");\n                            message.value = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.value);\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a KeyValue message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.KeyValue} message KeyValue\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    KeyValue.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.key = \"\";\n                            object.value = null;\n                        }\n                        if (message.key != null && message.hasOwnProperty(\"key\"))\n                            object.key = message.key;\n                        if (message.value != null && message.hasOwnProperty(\"value\"))\n                            object.value = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.value, options);\n                        return object;\n                    };\n\n                    /**\n                     * Converts this KeyValue to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    KeyValue.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for KeyValue\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    KeyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.KeyValue\";\n                    };\n\n                    return KeyValue;\n                })();\n\n                v1.InstrumentationScope = (function() {\n\n                    /**\n                     * Properties of an InstrumentationScope.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IInstrumentationScope\n                     * @property {string|null} [name] InstrumentationScope name\n                     * @property {string|null} [version] InstrumentationScope version\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] InstrumentationScope attributes\n                     * @property {number|null} [droppedAttributesCount] InstrumentationScope droppedAttributesCount\n                     */\n\n                    /**\n                     * Constructs a new InstrumentationScope.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an InstrumentationScope.\n                     * @implements IInstrumentationScope\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope=} [properties] Properties to set\n                     */\n                    function InstrumentationScope(properties) {\n                        this.attributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * InstrumentationScope name.\n                     * @member {string|null|undefined} name\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.name = null;\n\n                    /**\n                     * InstrumentationScope version.\n                     * @member {string|null|undefined} version\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.version = null;\n\n                    /**\n                     * InstrumentationScope attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * InstrumentationScope droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * Creates a new InstrumentationScope instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope instance\n                     */\n                    InstrumentationScope.create = function create(properties) {\n                        return new InstrumentationScope(properties);\n                    };\n\n                    /**\n                     * Encodes the specified InstrumentationScope message. Does not implicitly {@link opentelemetry.proto.common.v1.InstrumentationScope.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope} message InstrumentationScope message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    InstrumentationScope.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.droppedAttributesCount);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified InstrumentationScope message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.InstrumentationScope.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope} message InstrumentationScope message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    InstrumentationScope.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an InstrumentationScope message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    InstrumentationScope.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.name = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.version = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 4: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an InstrumentationScope message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    InstrumentationScope.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an InstrumentationScope message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    InstrumentationScope.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            if (!$util.isString(message.name))\n                                return \"name: string expected\";\n                        if (message.version != null && message.hasOwnProperty(\"version\"))\n                            if (!$util.isString(message.version))\n                                return \"version: string expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates an InstrumentationScope message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope\n                     */\n                    InstrumentationScope.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.InstrumentationScope)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        if (object.version != null)\n                            message.version = String(object.version);\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.common.v1.InstrumentationScope.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.common.v1.InstrumentationScope.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an InstrumentationScope message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.InstrumentationScope} message InstrumentationScope\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    InstrumentationScope.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.attributes = [];\n                        if (options.defaults) {\n                            object.name = \"\";\n                            object.version = \"\";\n                            object.droppedAttributesCount = 0;\n                        }\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.version != null && message.hasOwnProperty(\"version\"))\n                            object.version = message.version;\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this InstrumentationScope to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    InstrumentationScope.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for InstrumentationScope\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    InstrumentationScope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.InstrumentationScope\";\n                    };\n\n                    return InstrumentationScope;\n                })();\n\n                v1.EntityRef = (function() {\n\n                    /**\n                     * Properties of an EntityRef.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IEntityRef\n                     * @property {string|null} [schemaUrl] EntityRef schemaUrl\n                     * @property {string|null} [type] EntityRef type\n                     * @property {Array.<string>|null} [idKeys] EntityRef idKeys\n                     * @property {Array.<string>|null} [descriptionKeys] EntityRef descriptionKeys\n                     */\n\n                    /**\n                     * Constructs a new EntityRef.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an EntityRef.\n                     * @implements IEntityRef\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IEntityRef=} [properties] Properties to set\n                     */\n                    function EntityRef(properties) {\n                        this.idKeys = [];\n                        this.descriptionKeys = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * EntityRef schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @instance\n                     */\n                    EntityRef.prototype.schemaUrl = null;\n\n                    /**\n                     * EntityRef type.\n                     * @member {string|null|undefined} type\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @instance\n                     */\n                    EntityRef.prototype.type = null;\n\n                    /**\n                     * EntityRef idKeys.\n                     * @member {Array.<string>} idKeys\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @instance\n                     */\n                    EntityRef.prototype.idKeys = $util.emptyArray;\n\n                    /**\n                     * EntityRef descriptionKeys.\n                     * @member {Array.<string>} descriptionKeys\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @instance\n                     */\n                    EntityRef.prototype.descriptionKeys = $util.emptyArray;\n\n                    /**\n                     * Creates a new EntityRef instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IEntityRef=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.EntityRef} EntityRef instance\n                     */\n                    EntityRef.create = function create(properties) {\n                        return new EntityRef(properties);\n                    };\n\n                    /**\n                     * Encodes the specified EntityRef message. Does not implicitly {@link opentelemetry.proto.common.v1.EntityRef.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IEntityRef} message EntityRef message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    EntityRef.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.schemaUrl);\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);\n                        if (message.idKeys != null && message.idKeys.length)\n                            for (var i = 0; i < message.idKeys.length; ++i)\n                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.idKeys[i]);\n                        if (message.descriptionKeys != null && message.descriptionKeys.length)\n                            for (var i = 0; i < message.descriptionKeys.length; ++i)\n                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.descriptionKeys[i]);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified EntityRef message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.EntityRef.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IEntityRef} message EntityRef message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    EntityRef.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an EntityRef message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.EntityRef} EntityRef\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    EntityRef.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.EntityRef();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.type = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    if (!(message.idKeys && message.idKeys.length))\n                                        message.idKeys = [];\n                                    message.idKeys.push(reader.string());\n                                    break;\n                                }\n                            case 4: {\n                                    if (!(message.descriptionKeys && message.descriptionKeys.length))\n                                        message.descriptionKeys = [];\n                                    message.descriptionKeys.push(reader.string());\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an EntityRef message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.EntityRef} EntityRef\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    EntityRef.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an EntityRef message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    EntityRef.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        if (message.type != null && message.hasOwnProperty(\"type\"))\n                            if (!$util.isString(message.type))\n                                return \"type: string expected\";\n                        if (message.idKeys != null && message.hasOwnProperty(\"idKeys\")) {\n                            if (!Array.isArray(message.idKeys))\n                                return \"idKeys: array expected\";\n                            for (var i = 0; i < message.idKeys.length; ++i)\n                                if (!$util.isString(message.idKeys[i]))\n                                    return \"idKeys: string[] expected\";\n                        }\n                        if (message.descriptionKeys != null && message.hasOwnProperty(\"descriptionKeys\")) {\n                            if (!Array.isArray(message.descriptionKeys))\n                                return \"descriptionKeys: array expected\";\n                            for (var i = 0; i < message.descriptionKeys.length; ++i)\n                                if (!$util.isString(message.descriptionKeys[i]))\n                                    return \"descriptionKeys: string[] expected\";\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an EntityRef message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.EntityRef} EntityRef\n                     */\n                    EntityRef.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.EntityRef)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.EntityRef();\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        if (object.type != null)\n                            message.type = String(object.type);\n                        if (object.idKeys) {\n                            if (!Array.isArray(object.idKeys))\n                                throw TypeError(\".opentelemetry.proto.common.v1.EntityRef.idKeys: array expected\");\n                            message.idKeys = [];\n                            for (var i = 0; i < object.idKeys.length; ++i)\n                                message.idKeys[i] = String(object.idKeys[i]);\n                        }\n                        if (object.descriptionKeys) {\n                            if (!Array.isArray(object.descriptionKeys))\n                                throw TypeError(\".opentelemetry.proto.common.v1.EntityRef.descriptionKeys: array expected\");\n                            message.descriptionKeys = [];\n                            for (var i = 0; i < object.descriptionKeys.length; ++i)\n                                message.descriptionKeys[i] = String(object.descriptionKeys[i]);\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an EntityRef message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.EntityRef} message EntityRef\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    EntityRef.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.idKeys = [];\n                            object.descriptionKeys = [];\n                        }\n                        if (options.defaults) {\n                            object.schemaUrl = \"\";\n                            object.type = \"\";\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        if (message.type != null && message.hasOwnProperty(\"type\"))\n                            object.type = message.type;\n                        if (message.idKeys && message.idKeys.length) {\n                            object.idKeys = [];\n                            for (var j = 0; j < message.idKeys.length; ++j)\n                                object.idKeys[j] = message.idKeys[j];\n                        }\n                        if (message.descriptionKeys && message.descriptionKeys.length) {\n                            object.descriptionKeys = [];\n                            for (var j = 0; j < message.descriptionKeys.length; ++j)\n                                object.descriptionKeys[j] = message.descriptionKeys[j];\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this EntityRef to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    EntityRef.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for EntityRef\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.EntityRef\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    EntityRef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.EntityRef\";\n                    };\n\n                    return EntityRef;\n                })();\n\n                return v1;\n            })();\n\n            return common;\n        })();\n\n        proto.resource = (function() {\n\n            /**\n             * Namespace resource.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var resource = {};\n\n            resource.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.resource\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.Resource = (function() {\n\n                    /**\n                     * Properties of a Resource.\n                     * @memberof opentelemetry.proto.resource.v1\n                     * @interface IResource\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Resource attributes\n                     * @property {number|null} [droppedAttributesCount] Resource droppedAttributesCount\n                     * @property {Array.<opentelemetry.proto.common.v1.IEntityRef>|null} [entityRefs] Resource entityRefs\n                     */\n\n                    /**\n                     * Constructs a new Resource.\n                     * @memberof opentelemetry.proto.resource.v1\n                     * @classdesc Represents a Resource.\n                     * @implements IResource\n                     * @constructor\n                     * @param {opentelemetry.proto.resource.v1.IResource=} [properties] Properties to set\n                     */\n                    function Resource(properties) {\n                        this.attributes = [];\n                        this.entityRefs = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Resource attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     */\n                    Resource.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * Resource droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     */\n                    Resource.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * Resource entityRefs.\n                     * @member {Array.<opentelemetry.proto.common.v1.IEntityRef>} entityRefs\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     */\n                    Resource.prototype.entityRefs = $util.emptyArray;\n\n                    /**\n                     * Creates a new Resource instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.IResource=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource instance\n                     */\n                    Resource.create = function create(properties) {\n                        return new Resource(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Resource message. Does not implicitly {@link opentelemetry.proto.resource.v1.Resource.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.IResource} message Resource message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Resource.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.droppedAttributesCount);\n                        if (message.entityRefs != null && message.entityRefs.length)\n                            for (var i = 0; i < message.entityRefs.length; ++i)\n                                $root.opentelemetry.proto.common.v1.EntityRef.encode(message.entityRefs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Resource message, length delimited. Does not implicitly {@link opentelemetry.proto.resource.v1.Resource.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.IResource} message Resource message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Resource.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Resource message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Resource.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.resource.v1.Resource();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            case 3: {\n                                    if (!(message.entityRefs && message.entityRefs.length))\n                                        message.entityRefs = [];\n                                    message.entityRefs.push($root.opentelemetry.proto.common.v1.EntityRef.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Resource message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Resource.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Resource message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Resource.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        if (message.entityRefs != null && message.hasOwnProperty(\"entityRefs\")) {\n                            if (!Array.isArray(message.entityRefs))\n                                return \"entityRefs: array expected\";\n                            for (var i = 0; i < message.entityRefs.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.EntityRef.verify(message.entityRefs[i]);\n                                if (error)\n                                    return \"entityRefs.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Resource message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource\n                     */\n                    Resource.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.resource.v1.Resource)\n                            return object;\n                        var message = new $root.opentelemetry.proto.resource.v1.Resource();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.resource.v1.Resource.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.resource.v1.Resource.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        if (object.entityRefs) {\n                            if (!Array.isArray(object.entityRefs))\n                                throw TypeError(\".opentelemetry.proto.resource.v1.Resource.entityRefs: array expected\");\n                            message.entityRefs = [];\n                            for (var i = 0; i < object.entityRefs.length; ++i) {\n                                if (typeof object.entityRefs[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.resource.v1.Resource.entityRefs: object expected\");\n                                message.entityRefs[i] = $root.opentelemetry.proto.common.v1.EntityRef.fromObject(object.entityRefs[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Resource message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.Resource} message Resource\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Resource.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.attributes = [];\n                            object.entityRefs = [];\n                        }\n                        if (options.defaults)\n                            object.droppedAttributesCount = 0;\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        if (message.entityRefs && message.entityRefs.length) {\n                            object.entityRefs = [];\n                            for (var j = 0; j < message.entityRefs.length; ++j)\n                                object.entityRefs[j] = $root.opentelemetry.proto.common.v1.EntityRef.toObject(message.entityRefs[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Resource to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Resource.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Resource\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Resource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.resource.v1.Resource\";\n                    };\n\n                    return Resource;\n                })();\n\n                return v1;\n            })();\n\n            return resource;\n        })();\n\n        proto.trace = (function() {\n\n            /**\n             * Namespace trace.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var trace = {};\n\n            trace.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.trace\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.TracesData = (function() {\n\n                    /**\n                     * Properties of a TracesData.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface ITracesData\n                     * @property {Array.<opentelemetry.proto.trace.v1.IResourceSpans>|null} [resourceSpans] TracesData resourceSpans\n                     */\n\n                    /**\n                     * Constructs a new TracesData.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a TracesData.\n                     * @implements ITracesData\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.ITracesData=} [properties] Properties to set\n                     */\n                    function TracesData(properties) {\n                        this.resourceSpans = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * TracesData resourceSpans.\n                     * @member {Array.<opentelemetry.proto.trace.v1.IResourceSpans>} resourceSpans\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @instance\n                     */\n                    TracesData.prototype.resourceSpans = $util.emptyArray;\n\n                    /**\n                     * Creates a new TracesData instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ITracesData=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData instance\n                     */\n                    TracesData.create = function create(properties) {\n                        return new TracesData(properties);\n                    };\n\n                    /**\n                     * Encodes the specified TracesData message. Does not implicitly {@link opentelemetry.proto.trace.v1.TracesData.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ITracesData} message TracesData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    TracesData.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resourceSpans != null && message.resourceSpans.length)\n                            for (var i = 0; i < message.resourceSpans.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified TracesData message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.TracesData.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ITracesData} message TracesData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    TracesData.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a TracesData message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    TracesData.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.TracesData();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.resourceSpans && message.resourceSpans.length))\n                                        message.resourceSpans = [];\n                                    message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a TracesData message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    TracesData.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a TracesData message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    TracesData.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resourceSpans != null && message.hasOwnProperty(\"resourceSpans\")) {\n                            if (!Array.isArray(message.resourceSpans))\n                                return \"resourceSpans: array expected\";\n                            for (var i = 0; i < message.resourceSpans.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);\n                                if (error)\n                                    return \"resourceSpans.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a TracesData message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData\n                     */\n                    TracesData.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.TracesData)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.TracesData();\n                        if (object.resourceSpans) {\n                            if (!Array.isArray(object.resourceSpans))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.TracesData.resourceSpans: array expected\");\n                            message.resourceSpans = [];\n                            for (var i = 0; i < object.resourceSpans.length; ++i) {\n                                if (typeof object.resourceSpans[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.TracesData.resourceSpans: object expected\");\n                                message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a TracesData message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.TracesData} message TracesData\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    TracesData.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.resourceSpans = [];\n                        if (message.resourceSpans && message.resourceSpans.length) {\n                            object.resourceSpans = [];\n                            for (var j = 0; j < message.resourceSpans.length; ++j)\n                                object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this TracesData to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    TracesData.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for TracesData\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    TracesData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.TracesData\";\n                    };\n\n                    return TracesData;\n                })();\n\n                v1.ResourceSpans = (function() {\n\n                    /**\n                     * Properties of a ResourceSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface IResourceSpans\n                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceSpans resource\n                     * @property {Array.<opentelemetry.proto.trace.v1.IScopeSpans>|null} [scopeSpans] ResourceSpans scopeSpans\n                     * @property {string|null} [schemaUrl] ResourceSpans schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ResourceSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a ResourceSpans.\n                     * @implements IResourceSpans\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans=} [properties] Properties to set\n                     */\n                    function ResourceSpans(properties) {\n                        this.scopeSpans = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ResourceSpans resource.\n                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     */\n                    ResourceSpans.prototype.resource = null;\n\n                    /**\n                     * ResourceSpans scopeSpans.\n                     * @member {Array.<opentelemetry.proto.trace.v1.IScopeSpans>} scopeSpans\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     */\n                    ResourceSpans.prototype.scopeSpans = $util.emptyArray;\n\n                    /**\n                     * ResourceSpans schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     */\n                    ResourceSpans.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ResourceSpans instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans instance\n                     */\n                    ResourceSpans.create = function create(properties) {\n                        return new ResourceSpans(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ResourceSpans message. Does not implicitly {@link opentelemetry.proto.trace.v1.ResourceSpans.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans} message ResourceSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceSpans.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resource != null && Object.hasOwnProperty.call(message, \"resource\"))\n                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.scopeSpans != null && message.scopeSpans.length)\n                            for (var i = 0; i < message.scopeSpans.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.ScopeSpans.encode(message.scopeSpans[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ResourceSpans message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.ResourceSpans.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans} message ResourceSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceSpans.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ResourceSpans message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceSpans.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.scopeSpans && message.scopeSpans.length))\n                                        message.scopeSpans = [];\n                                    message.scopeSpans.push($root.opentelemetry.proto.trace.v1.ScopeSpans.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ResourceSpans message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceSpans.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ResourceSpans message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ResourceSpans.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resource != null && message.hasOwnProperty(\"resource\")) {\n                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);\n                            if (error)\n                                return \"resource.\" + error;\n                        }\n                        if (message.scopeSpans != null && message.hasOwnProperty(\"scopeSpans\")) {\n                            if (!Array.isArray(message.scopeSpans))\n                                return \"scopeSpans: array expected\";\n                            for (var i = 0; i < message.scopeSpans.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.ScopeSpans.verify(message.scopeSpans[i]);\n                                if (error)\n                                    return \"scopeSpans.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ResourceSpans message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans\n                     */\n                    ResourceSpans.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.ResourceSpans)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();\n                        if (object.resource != null) {\n                            if (typeof object.resource !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ResourceSpans.resource: object expected\");\n                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);\n                        }\n                        if (object.scopeSpans) {\n                            if (!Array.isArray(object.scopeSpans))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: array expected\");\n                            message.scopeSpans = [];\n                            for (var i = 0; i < object.scopeSpans.length; ++i) {\n                                if (typeof object.scopeSpans[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: object expected\");\n                                message.scopeSpans[i] = $root.opentelemetry.proto.trace.v1.ScopeSpans.fromObject(object.scopeSpans[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ResourceSpans message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ResourceSpans} message ResourceSpans\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ResourceSpans.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.scopeSpans = [];\n                        if (options.defaults) {\n                            object.resource = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.resource != null && message.hasOwnProperty(\"resource\"))\n                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);\n                        if (message.scopeSpans && message.scopeSpans.length) {\n                            object.scopeSpans = [];\n                            for (var j = 0; j < message.scopeSpans.length; ++j)\n                                object.scopeSpans[j] = $root.opentelemetry.proto.trace.v1.ScopeSpans.toObject(message.scopeSpans[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ResourceSpans to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ResourceSpans.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ResourceSpans\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ResourceSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.ResourceSpans\";\n                    };\n\n                    return ResourceSpans;\n                })();\n\n                v1.ScopeSpans = (function() {\n\n                    /**\n                     * Properties of a ScopeSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface IScopeSpans\n                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeSpans scope\n                     * @property {Array.<opentelemetry.proto.trace.v1.ISpan>|null} [spans] ScopeSpans spans\n                     * @property {string|null} [schemaUrl] ScopeSpans schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ScopeSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a ScopeSpans.\n                     * @implements IScopeSpans\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans=} [properties] Properties to set\n                     */\n                    function ScopeSpans(properties) {\n                        this.spans = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ScopeSpans scope.\n                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     */\n                    ScopeSpans.prototype.scope = null;\n\n                    /**\n                     * ScopeSpans spans.\n                     * @member {Array.<opentelemetry.proto.trace.v1.ISpan>} spans\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     */\n                    ScopeSpans.prototype.spans = $util.emptyArray;\n\n                    /**\n                     * ScopeSpans schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     */\n                    ScopeSpans.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ScopeSpans instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans instance\n                     */\n                    ScopeSpans.create = function create(properties) {\n                        return new ScopeSpans(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ScopeSpans message. Does not implicitly {@link opentelemetry.proto.trace.v1.ScopeSpans.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans} message ScopeSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeSpans.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.spans != null && message.spans.length)\n                            for (var i = 0; i < message.spans.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.Span.encode(message.spans[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ScopeSpans message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.ScopeSpans.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans} message ScopeSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeSpans.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ScopeSpans message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeSpans.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.spans && message.spans.length))\n                                        message.spans = [];\n                                    message.spans.push($root.opentelemetry.proto.trace.v1.Span.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ScopeSpans message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeSpans.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ScopeSpans message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ScopeSpans.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.scope != null && message.hasOwnProperty(\"scope\")) {\n                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);\n                            if (error)\n                                return \"scope.\" + error;\n                        }\n                        if (message.spans != null && message.hasOwnProperty(\"spans\")) {\n                            if (!Array.isArray(message.spans))\n                                return \"spans: array expected\";\n                            for (var i = 0; i < message.spans.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.Span.verify(message.spans[i]);\n                                if (error)\n                                    return \"spans.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ScopeSpans message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans\n                     */\n                    ScopeSpans.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.ScopeSpans)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();\n                        if (object.scope != null) {\n                            if (typeof object.scope !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ScopeSpans.scope: object expected\");\n                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);\n                        }\n                        if (object.spans) {\n                            if (!Array.isArray(object.spans))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ScopeSpans.spans: array expected\");\n                            message.spans = [];\n                            for (var i = 0; i < object.spans.length; ++i) {\n                                if (typeof object.spans[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.ScopeSpans.spans: object expected\");\n                                message.spans[i] = $root.opentelemetry.proto.trace.v1.Span.fromObject(object.spans[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ScopeSpans message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ScopeSpans} message ScopeSpans\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ScopeSpans.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.spans = [];\n                        if (options.defaults) {\n                            object.scope = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);\n                        if (message.spans && message.spans.length) {\n                            object.spans = [];\n                            for (var j = 0; j < message.spans.length; ++j)\n                                object.spans[j] = $root.opentelemetry.proto.trace.v1.Span.toObject(message.spans[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ScopeSpans to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ScopeSpans.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ScopeSpans\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ScopeSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.ScopeSpans\";\n                    };\n\n                    return ScopeSpans;\n                })();\n\n                v1.Span = (function() {\n\n                    /**\n                     * Properties of a Span.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface ISpan\n                     * @property {Uint8Array|null} [traceId] Span traceId\n                     * @property {Uint8Array|null} [spanId] Span spanId\n                     * @property {string|null} [traceState] Span traceState\n                     * @property {Uint8Array|null} [parentSpanId] Span parentSpanId\n                     * @property {number|null} [flags] Span flags\n                     * @property {string|null} [name] Span name\n                     * @property {opentelemetry.proto.trace.v1.Span.SpanKind|null} [kind] Span kind\n                     * @property {number|Long|null} [startTimeUnixNano] Span startTimeUnixNano\n                     * @property {number|Long|null} [endTimeUnixNano] Span endTimeUnixNano\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Span attributes\n                     * @property {number|null} [droppedAttributesCount] Span droppedAttributesCount\n                     * @property {Array.<opentelemetry.proto.trace.v1.Span.IEvent>|null} [events] Span events\n                     * @property {number|null} [droppedEventsCount] Span droppedEventsCount\n                     * @property {Array.<opentelemetry.proto.trace.v1.Span.ILink>|null} [links] Span links\n                     * @property {number|null} [droppedLinksCount] Span droppedLinksCount\n                     * @property {opentelemetry.proto.trace.v1.IStatus|null} [status] Span status\n                     */\n\n                    /**\n                     * Constructs a new Span.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a Span.\n                     * @implements ISpan\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.ISpan=} [properties] Properties to set\n                     */\n                    function Span(properties) {\n                        this.attributes = [];\n                        this.events = [];\n                        this.links = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Span traceId.\n                     * @member {Uint8Array|null|undefined} traceId\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.traceId = null;\n\n                    /**\n                     * Span spanId.\n                     * @member {Uint8Array|null|undefined} spanId\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.spanId = null;\n\n                    /**\n                     * Span traceState.\n                     * @member {string|null|undefined} traceState\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.traceState = null;\n\n                    /**\n                     * Span parentSpanId.\n                     * @member {Uint8Array|null|undefined} parentSpanId\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.parentSpanId = null;\n\n                    /**\n                     * Span flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.flags = null;\n\n                    /**\n                     * Span name.\n                     * @member {string|null|undefined} name\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.name = null;\n\n                    /**\n                     * Span kind.\n                     * @member {opentelemetry.proto.trace.v1.Span.SpanKind|null|undefined} kind\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.kind = null;\n\n                    /**\n                     * Span startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * Span endTimeUnixNano.\n                     * @member {number|Long|null|undefined} endTimeUnixNano\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.endTimeUnixNano = null;\n\n                    /**\n                     * Span attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * Span droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * Span events.\n                     * @member {Array.<opentelemetry.proto.trace.v1.Span.IEvent>} events\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.events = $util.emptyArray;\n\n                    /**\n                     * Span droppedEventsCount.\n                     * @member {number|null|undefined} droppedEventsCount\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.droppedEventsCount = null;\n\n                    /**\n                     * Span links.\n                     * @member {Array.<opentelemetry.proto.trace.v1.Span.ILink>} links\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.links = $util.emptyArray;\n\n                    /**\n                     * Span droppedLinksCount.\n                     * @member {number|null|undefined} droppedLinksCount\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.droppedLinksCount = null;\n\n                    /**\n                     * Span status.\n                     * @member {opentelemetry.proto.trace.v1.IStatus|null|undefined} status\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.status = null;\n\n                    /**\n                     * Creates a new Span instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ISpan=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span instance\n                     */\n                    Span.create = function create(properties) {\n                        return new Span(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Span message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ISpan} message Span message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Span.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.traceId);\n                        if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spanId);\n                        if (message.traceState != null && Object.hasOwnProperty.call(message, \"traceState\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.traceState);\n                        if (message.parentSpanId != null && Object.hasOwnProperty.call(message, \"parentSpanId\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.parentSpanId);\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);\n                        if (message.kind != null && Object.hasOwnProperty.call(message, \"kind\"))\n                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.kind);\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 7, wireType 1 =*/57).fixed64(message.startTimeUnixNano);\n                        if (message.endTimeUnixNano != null && Object.hasOwnProperty.call(message, \"endTimeUnixNano\"))\n                            writer.uint32(/* id 8, wireType 1 =*/65).fixed64(message.endTimeUnixNano);\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.droppedAttributesCount);\n                        if (message.events != null && message.events.length)\n                            for (var i = 0; i < message.events.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.Span.Event.encode(message.events[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                        if (message.droppedEventsCount != null && Object.hasOwnProperty.call(message, \"droppedEventsCount\"))\n                            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.droppedEventsCount);\n                        if (message.links != null && message.links.length)\n                            for (var i = 0; i < message.links.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.Span.Link.encode(message.links[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n                        if (message.droppedLinksCount != null && Object.hasOwnProperty.call(message, \"droppedLinksCount\"))\n                            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.droppedLinksCount);\n                        if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                            $root.opentelemetry.proto.trace.v1.Status.encode(message.status, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 16, wireType 5 =*/133).fixed32(message.flags);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Span message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ISpan} message Span message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Span.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Span message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Span.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.traceId = reader.bytes();\n                                    break;\n                                }\n                            case 2: {\n                                    message.spanId = reader.bytes();\n                                    break;\n                                }\n                            case 3: {\n                                    message.traceState = reader.string();\n                                    break;\n                                }\n                            case 4: {\n                                    message.parentSpanId = reader.bytes();\n                                    break;\n                                }\n                            case 16: {\n                                    message.flags = reader.fixed32();\n                                    break;\n                                }\n                            case 5: {\n                                    message.name = reader.string();\n                                    break;\n                                }\n                            case 6: {\n                                    message.kind = reader.int32();\n                                    break;\n                                }\n                            case 7: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 8: {\n                                    message.endTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 9: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 10: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            case 11: {\n                                    if (!(message.events && message.events.length))\n                                        message.events = [];\n                                    message.events.push($root.opentelemetry.proto.trace.v1.Span.Event.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 12: {\n                                    message.droppedEventsCount = reader.uint32();\n                                    break;\n                                }\n                            case 13: {\n                                    if (!(message.links && message.links.length))\n                                        message.links = [];\n                                    message.links.push($root.opentelemetry.proto.trace.v1.Span.Link.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 14: {\n                                    message.droppedLinksCount = reader.uint32();\n                                    break;\n                                }\n                            case 15: {\n                                    message.status = $root.opentelemetry.proto.trace.v1.Status.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Span message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Span.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Span message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Span.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                return \"traceId: buffer expected\";\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                return \"spanId: buffer expected\";\n                        if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                            if (!$util.isString(message.traceState))\n                                return \"traceState: string expected\";\n                        if (message.parentSpanId != null && message.hasOwnProperty(\"parentSpanId\"))\n                            if (!(message.parentSpanId && typeof message.parentSpanId.length === \"number\" || $util.isString(message.parentSpanId)))\n                                return \"parentSpanId: buffer expected\";\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            if (!$util.isString(message.name))\n                                return \"name: string expected\";\n                        if (message.kind != null && message.hasOwnProperty(\"kind\"))\n                            switch (message.kind) {\n                            default:\n                                return \"kind: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                            case 3:\n                            case 4:\n                            case 5:\n                                break;\n                            }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.endTimeUnixNano != null && message.hasOwnProperty(\"endTimeUnixNano\"))\n                            if (!$util.isInteger(message.endTimeUnixNano) && !(message.endTimeUnixNano && $util.isInteger(message.endTimeUnixNano.low) && $util.isInteger(message.endTimeUnixNano.high)))\n                                return \"endTimeUnixNano: integer|Long expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        if (message.events != null && message.hasOwnProperty(\"events\")) {\n                            if (!Array.isArray(message.events))\n                                return \"events: array expected\";\n                            for (var i = 0; i < message.events.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.Span.Event.verify(message.events[i]);\n                                if (error)\n                                    return \"events.\" + error;\n                            }\n                        }\n                        if (message.droppedEventsCount != null && message.hasOwnProperty(\"droppedEventsCount\"))\n                            if (!$util.isInteger(message.droppedEventsCount))\n                                return \"droppedEventsCount: integer expected\";\n                        if (message.links != null && message.hasOwnProperty(\"links\")) {\n                            if (!Array.isArray(message.links))\n                                return \"links: array expected\";\n                            for (var i = 0; i < message.links.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.Span.Link.verify(message.links[i]);\n                                if (error)\n                                    return \"links.\" + error;\n                            }\n                        }\n                        if (message.droppedLinksCount != null && message.hasOwnProperty(\"droppedLinksCount\"))\n                            if (!$util.isInteger(message.droppedLinksCount))\n                                return \"droppedLinksCount: integer expected\";\n                        if (message.status != null && message.hasOwnProperty(\"status\")) {\n                            var error = $root.opentelemetry.proto.trace.v1.Status.verify(message.status);\n                            if (error)\n                                return \"status.\" + error;\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Span message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span\n                     */\n                    Span.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.Span)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.Span();\n                        if (object.traceId != null)\n                            if (typeof object.traceId === \"string\")\n                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                            else if (object.traceId.length >= 0)\n                                message.traceId = object.traceId;\n                        if (object.spanId != null)\n                            if (typeof object.spanId === \"string\")\n                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                            else if (object.spanId.length >= 0)\n                                message.spanId = object.spanId;\n                        if (object.traceState != null)\n                            message.traceState = String(object.traceState);\n                        if (object.parentSpanId != null)\n                            if (typeof object.parentSpanId === \"string\")\n                                $util.base64.decode(object.parentSpanId, message.parentSpanId = $util.newBuffer($util.base64.length(object.parentSpanId)), 0);\n                            else if (object.parentSpanId.length >= 0)\n                                message.parentSpanId = object.parentSpanId;\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        switch (object.kind) {\n                        default:\n                            if (typeof object.kind === \"number\") {\n                                message.kind = object.kind;\n                                break;\n                            }\n                            break;\n                        case \"SPAN_KIND_UNSPECIFIED\":\n                        case 0:\n                            message.kind = 0;\n                            break;\n                        case \"SPAN_KIND_INTERNAL\":\n                        case 1:\n                            message.kind = 1;\n                            break;\n                        case \"SPAN_KIND_SERVER\":\n                        case 2:\n                            message.kind = 2;\n                            break;\n                        case \"SPAN_KIND_CLIENT\":\n                        case 3:\n                            message.kind = 3;\n                            break;\n                        case \"SPAN_KIND_PRODUCER\":\n                        case 4:\n                            message.kind = 4;\n                            break;\n                        case \"SPAN_KIND_CONSUMER\":\n                        case 5:\n                            message.kind = 5;\n                            break;\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.endTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.endTimeUnixNano = $util.Long.fromValue(object.endTimeUnixNano)).unsigned = false;\n                            else if (typeof object.endTimeUnixNano === \"string\")\n                                message.endTimeUnixNano = parseInt(object.endTimeUnixNano, 10);\n                            else if (typeof object.endTimeUnixNano === \"number\")\n                                message.endTimeUnixNano = object.endTimeUnixNano;\n                            else if (typeof object.endTimeUnixNano === \"object\")\n                                message.endTimeUnixNano = new $util.LongBits(object.endTimeUnixNano.low >>> 0, object.endTimeUnixNano.high >>> 0).toNumber();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        if (object.events) {\n                            if (!Array.isArray(object.events))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.events: array expected\");\n                            message.events = [];\n                            for (var i = 0; i < object.events.length; ++i) {\n                                if (typeof object.events[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.events: object expected\");\n                                message.events[i] = $root.opentelemetry.proto.trace.v1.Span.Event.fromObject(object.events[i]);\n                            }\n                        }\n                        if (object.droppedEventsCount != null)\n                            message.droppedEventsCount = object.droppedEventsCount >>> 0;\n                        if (object.links) {\n                            if (!Array.isArray(object.links))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.links: array expected\");\n                            message.links = [];\n                            for (var i = 0; i < object.links.length; ++i) {\n                                if (typeof object.links[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.links: object expected\");\n                                message.links[i] = $root.opentelemetry.proto.trace.v1.Span.Link.fromObject(object.links[i]);\n                            }\n                        }\n                        if (object.droppedLinksCount != null)\n                            message.droppedLinksCount = object.droppedLinksCount >>> 0;\n                        if (object.status != null) {\n                            if (typeof object.status !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.status: object expected\");\n                            message.status = $root.opentelemetry.proto.trace.v1.Status.fromObject(object.status);\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Span message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.Span} message Span\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Span.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.attributes = [];\n                            object.events = [];\n                            object.links = [];\n                        }\n                        if (options.defaults) {\n                            if (options.bytes === String)\n                                object.traceId = \"\";\n                            else {\n                                object.traceId = [];\n                                if (options.bytes !== Array)\n                                    object.traceId = $util.newBuffer(object.traceId);\n                            }\n                            if (options.bytes === String)\n                                object.spanId = \"\";\n                            else {\n                                object.spanId = [];\n                                if (options.bytes !== Array)\n                                    object.spanId = $util.newBuffer(object.spanId);\n                            }\n                            object.traceState = \"\";\n                            if (options.bytes === String)\n                                object.parentSpanId = \"\";\n                            else {\n                                object.parentSpanId = [];\n                                if (options.bytes !== Array)\n                                    object.parentSpanId = $util.newBuffer(object.parentSpanId);\n                            }\n                            object.name = \"\";\n                            object.kind = options.enums === String ? \"SPAN_KIND_UNSPECIFIED\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.endTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.endTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.droppedAttributesCount = 0;\n                            object.droppedEventsCount = 0;\n                            object.droppedLinksCount = 0;\n                            object.status = null;\n                            object.flags = 0;\n                        }\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                        if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                            object.traceState = message.traceState;\n                        if (message.parentSpanId != null && message.hasOwnProperty(\"parentSpanId\"))\n                            object.parentSpanId = options.bytes === String ? $util.base64.encode(message.parentSpanId, 0, message.parentSpanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentSpanId) : message.parentSpanId;\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.kind != null && message.hasOwnProperty(\"kind\"))\n                            object.kind = options.enums === String ? $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] === undefined ? message.kind : $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] : message.kind;\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.endTimeUnixNano != null && message.hasOwnProperty(\"endTimeUnixNano\"))\n                            if (typeof message.endTimeUnixNano === \"number\")\n                                object.endTimeUnixNano = options.longs === String ? String(message.endTimeUnixNano) : message.endTimeUnixNano;\n                            else\n                                object.endTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.endTimeUnixNano.low >>> 0, message.endTimeUnixNano.high >>> 0).toNumber() : message.endTimeUnixNano;\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        if (message.events && message.events.length) {\n                            object.events = [];\n                            for (var j = 0; j < message.events.length; ++j)\n                                object.events[j] = $root.opentelemetry.proto.trace.v1.Span.Event.toObject(message.events[j], options);\n                        }\n                        if (message.droppedEventsCount != null && message.hasOwnProperty(\"droppedEventsCount\"))\n                            object.droppedEventsCount = message.droppedEventsCount;\n                        if (message.links && message.links.length) {\n                            object.links = [];\n                            for (var j = 0; j < message.links.length; ++j)\n                                object.links[j] = $root.opentelemetry.proto.trace.v1.Span.Link.toObject(message.links[j], options);\n                        }\n                        if (message.droppedLinksCount != null && message.hasOwnProperty(\"droppedLinksCount\"))\n                            object.droppedLinksCount = message.droppedLinksCount;\n                        if (message.status != null && message.hasOwnProperty(\"status\"))\n                            object.status = $root.opentelemetry.proto.trace.v1.Status.toObject(message.status, options);\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Span to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Span.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Span\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Span.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Span\";\n                    };\n\n                    /**\n                     * SpanKind enum.\n                     * @name opentelemetry.proto.trace.v1.Span.SpanKind\n                     * @enum {number}\n                     * @property {number} SPAN_KIND_UNSPECIFIED=0 SPAN_KIND_UNSPECIFIED value\n                     * @property {number} SPAN_KIND_INTERNAL=1 SPAN_KIND_INTERNAL value\n                     * @property {number} SPAN_KIND_SERVER=2 SPAN_KIND_SERVER value\n                     * @property {number} SPAN_KIND_CLIENT=3 SPAN_KIND_CLIENT value\n                     * @property {number} SPAN_KIND_PRODUCER=4 SPAN_KIND_PRODUCER value\n                     * @property {number} SPAN_KIND_CONSUMER=5 SPAN_KIND_CONSUMER value\n                     */\n                    Span.SpanKind = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"SPAN_KIND_UNSPECIFIED\"] = 0;\n                        values[valuesById[1] = \"SPAN_KIND_INTERNAL\"] = 1;\n                        values[valuesById[2] = \"SPAN_KIND_SERVER\"] = 2;\n                        values[valuesById[3] = \"SPAN_KIND_CLIENT\"] = 3;\n                        values[valuesById[4] = \"SPAN_KIND_PRODUCER\"] = 4;\n                        values[valuesById[5] = \"SPAN_KIND_CONSUMER\"] = 5;\n                        return values;\n                    })();\n\n                    Span.Event = (function() {\n\n                        /**\n                         * Properties of an Event.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @interface IEvent\n                         * @property {number|Long|null} [timeUnixNano] Event timeUnixNano\n                         * @property {string|null} [name] Event name\n                         * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Event attributes\n                         * @property {number|null} [droppedAttributesCount] Event droppedAttributesCount\n                         */\n\n                        /**\n                         * Constructs a new Event.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @classdesc Represents an Event.\n                         * @implements IEvent\n                         * @constructor\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent=} [properties] Properties to set\n                         */\n                        function Event(properties) {\n                            this.attributes = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * Event timeUnixNano.\n                         * @member {number|Long|null|undefined} timeUnixNano\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.timeUnixNano = null;\n\n                        /**\n                         * Event name.\n                         * @member {string|null|undefined} name\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.name = null;\n\n                        /**\n                         * Event attributes.\n                         * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.attributes = $util.emptyArray;\n\n                        /**\n                         * Event droppedAttributesCount.\n                         * @member {number|null|undefined} droppedAttributesCount\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.droppedAttributesCount = null;\n\n                        /**\n                         * Creates a new Event instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event instance\n                         */\n                        Event.create = function create(properties) {\n                            return new Event(properties);\n                        };\n\n                        /**\n                         * Encodes the specified Event message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Event.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent} message Event message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Event.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.timeUnixNano);\n                            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                            if (message.attributes != null && message.attributes.length)\n                                for (var i = 0; i < message.attributes.length; ++i)\n                                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                            if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.droppedAttributesCount);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified Event message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Event.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent} message Event message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Event.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an Event message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Event.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Event();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.timeUnixNano = reader.fixed64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.name = reader.string();\n                                        break;\n                                    }\n                                case 3: {\n                                        if (!(message.attributes && message.attributes.length))\n                                            message.attributes = [];\n                                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                case 4: {\n                                        message.droppedAttributesCount = reader.uint32();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an Event message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Event.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an Event message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        Event.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                    return \"timeUnixNano: integer|Long expected\";\n                            if (message.name != null && message.hasOwnProperty(\"name\"))\n                                if (!$util.isString(message.name))\n                                    return \"name: string expected\";\n                            if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                                if (!Array.isArray(message.attributes))\n                                    return \"attributes: array expected\";\n                                for (var i = 0; i < message.attributes.length; ++i) {\n                                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                    if (error)\n                                        return \"attributes.\" + error;\n                                }\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                if (!$util.isInteger(message.droppedAttributesCount))\n                                    return \"droppedAttributesCount: integer expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an Event message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event\n                         */\n                        Event.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Event)\n                                return object;\n                            var message = new $root.opentelemetry.proto.trace.v1.Span.Event();\n                            if (object.timeUnixNano != null)\n                                if ($util.Long)\n                                    (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                                else if (typeof object.timeUnixNano === \"string\")\n                                    message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                                else if (typeof object.timeUnixNano === \"number\")\n                                    message.timeUnixNano = object.timeUnixNano;\n                                else if (typeof object.timeUnixNano === \"object\")\n                                    message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                            if (object.name != null)\n                                message.name = String(object.name);\n                            if (object.attributes) {\n                                if (!Array.isArray(object.attributes))\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.Event.attributes: array expected\");\n                                message.attributes = [];\n                                for (var i = 0; i < object.attributes.length; ++i) {\n                                    if (typeof object.attributes[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.trace.v1.Span.Event.attributes: object expected\");\n                                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                                }\n                            }\n                            if (object.droppedAttributesCount != null)\n                                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an Event message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.Event} message Event\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        Event.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.attributes = [];\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                                object.name = \"\";\n                                object.droppedAttributesCount = 0;\n                            }\n                            if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                                if (typeof message.timeUnixNano === \"number\")\n                                    object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                                else\n                                    object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                            if (message.name != null && message.hasOwnProperty(\"name\"))\n                                object.name = message.name;\n                            if (message.attributes && message.attributes.length) {\n                                object.attributes = [];\n                                for (var j = 0; j < message.attributes.length; ++j)\n                                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                object.droppedAttributesCount = message.droppedAttributesCount;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this Event to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        Event.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for Event\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Span.Event\";\n                        };\n\n                        return Event;\n                    })();\n\n                    Span.Link = (function() {\n\n                        /**\n                         * Properties of a Link.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @interface ILink\n                         * @property {Uint8Array|null} [traceId] Link traceId\n                         * @property {Uint8Array|null} [spanId] Link spanId\n                         * @property {string|null} [traceState] Link traceState\n                         * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Link attributes\n                         * @property {number|null} [droppedAttributesCount] Link droppedAttributesCount\n                         * @property {number|null} [flags] Link flags\n                         */\n\n                        /**\n                         * Constructs a new Link.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @classdesc Represents a Link.\n                         * @implements ILink\n                         * @constructor\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink=} [properties] Properties to set\n                         */\n                        function Link(properties) {\n                            this.attributes = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * Link traceId.\n                         * @member {Uint8Array|null|undefined} traceId\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.traceId = null;\n\n                        /**\n                         * Link spanId.\n                         * @member {Uint8Array|null|undefined} spanId\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.spanId = null;\n\n                        /**\n                         * Link traceState.\n                         * @member {string|null|undefined} traceState\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.traceState = null;\n\n                        /**\n                         * Link attributes.\n                         * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.attributes = $util.emptyArray;\n\n                        /**\n                         * Link droppedAttributesCount.\n                         * @member {number|null|undefined} droppedAttributesCount\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.droppedAttributesCount = null;\n\n                        /**\n                         * Link flags.\n                         * @member {number|null|undefined} flags\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.flags = null;\n\n                        /**\n                         * Creates a new Link instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link instance\n                         */\n                        Link.create = function create(properties) {\n                            return new Link(properties);\n                        };\n\n                        /**\n                         * Encodes the specified Link message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Link.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink} message Link message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Link.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.traceId);\n                            if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spanId);\n                            if (message.traceState != null && Object.hasOwnProperty.call(message, \"traceState\"))\n                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.traceState);\n                            if (message.attributes != null && message.attributes.length)\n                                for (var i = 0; i < message.attributes.length; ++i)\n                                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                            if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.droppedAttributesCount);\n                            if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                                writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.flags);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified Link message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Link.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink} message Link message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Link.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes a Link message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Link.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Link();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.traceId = reader.bytes();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.spanId = reader.bytes();\n                                        break;\n                                    }\n                                case 3: {\n                                        message.traceState = reader.string();\n                                        break;\n                                    }\n                                case 4: {\n                                        if (!(message.attributes && message.attributes.length))\n                                            message.attributes = [];\n                                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                case 5: {\n                                        message.droppedAttributesCount = reader.uint32();\n                                        break;\n                                    }\n                                case 6: {\n                                        message.flags = reader.fixed32();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes a Link message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Link.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies a Link message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        Link.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                                if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                    return \"traceId: buffer expected\";\n                            if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                                if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                    return \"spanId: buffer expected\";\n                            if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                                if (!$util.isString(message.traceState))\n                                    return \"traceState: string expected\";\n                            if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                                if (!Array.isArray(message.attributes))\n                                    return \"attributes: array expected\";\n                                for (var i = 0; i < message.attributes.length; ++i) {\n                                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                    if (error)\n                                        return \"attributes.\" + error;\n                                }\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                if (!$util.isInteger(message.droppedAttributesCount))\n                                    return \"droppedAttributesCount: integer expected\";\n                            if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                                if (!$util.isInteger(message.flags))\n                                    return \"flags: integer expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates a Link message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link\n                         */\n                        Link.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Link)\n                                return object;\n                            var message = new $root.opentelemetry.proto.trace.v1.Span.Link();\n                            if (object.traceId != null)\n                                if (typeof object.traceId === \"string\")\n                                    $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                                else if (object.traceId.length >= 0)\n                                    message.traceId = object.traceId;\n                            if (object.spanId != null)\n                                if (typeof object.spanId === \"string\")\n                                    $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                                else if (object.spanId.length >= 0)\n                                    message.spanId = object.spanId;\n                            if (object.traceState != null)\n                                message.traceState = String(object.traceState);\n                            if (object.attributes) {\n                                if (!Array.isArray(object.attributes))\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.Link.attributes: array expected\");\n                                message.attributes = [];\n                                for (var i = 0; i < object.attributes.length; ++i) {\n                                    if (typeof object.attributes[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.trace.v1.Span.Link.attributes: object expected\");\n                                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                                }\n                            }\n                            if (object.droppedAttributesCount != null)\n                                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                            if (object.flags != null)\n                                message.flags = object.flags >>> 0;\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from a Link message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.Link} message Link\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        Link.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.attributes = [];\n                            if (options.defaults) {\n                                if (options.bytes === String)\n                                    object.traceId = \"\";\n                                else {\n                                    object.traceId = [];\n                                    if (options.bytes !== Array)\n                                        object.traceId = $util.newBuffer(object.traceId);\n                                }\n                                if (options.bytes === String)\n                                    object.spanId = \"\";\n                                else {\n                                    object.spanId = [];\n                                    if (options.bytes !== Array)\n                                        object.spanId = $util.newBuffer(object.spanId);\n                                }\n                                object.traceState = \"\";\n                                object.droppedAttributesCount = 0;\n                                object.flags = 0;\n                            }\n                            if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                                object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                            if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                                object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                            if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                                object.traceState = message.traceState;\n                            if (message.attributes && message.attributes.length) {\n                                object.attributes = [];\n                                for (var j = 0; j < message.attributes.length; ++j)\n                                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                object.droppedAttributesCount = message.droppedAttributesCount;\n                            if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                                object.flags = message.flags;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this Link to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        Link.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for Link\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        Link.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Span.Link\";\n                        };\n\n                        return Link;\n                    })();\n\n                    return Span;\n                })();\n\n                v1.Status = (function() {\n\n                    /**\n                     * Properties of a Status.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface IStatus\n                     * @property {string|null} [message] Status message\n                     * @property {opentelemetry.proto.trace.v1.Status.StatusCode|null} [code] Status code\n                     */\n\n                    /**\n                     * Constructs a new Status.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a Status.\n                     * @implements IStatus\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.IStatus=} [properties] Properties to set\n                     */\n                    function Status(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Status message.\n                     * @member {string|null|undefined} message\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @instance\n                     */\n                    Status.prototype.message = null;\n\n                    /**\n                     * Status code.\n                     * @member {opentelemetry.proto.trace.v1.Status.StatusCode|null|undefined} code\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @instance\n                     */\n                    Status.prototype.code = null;\n\n                    /**\n                     * Creates a new Status instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IStatus=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status instance\n                     */\n                    Status.create = function create(properties) {\n                        return new Status(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Status message. Does not implicitly {@link opentelemetry.proto.trace.v1.Status.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IStatus} message Status message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Status.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);\n                        if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Status message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Status.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IStatus} message Status message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Status.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Status message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Status.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Status();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 2: {\n                                    message.message = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    message.code = reader.int32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Status message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Status.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Status message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Status.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.message != null && message.hasOwnProperty(\"message\"))\n                            if (!$util.isString(message.message))\n                                return \"message: string expected\";\n                        if (message.code != null && message.hasOwnProperty(\"code\"))\n                            switch (message.code) {\n                            default:\n                                return \"code: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Status message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status\n                     */\n                    Status.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.Status)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.Status();\n                        if (object.message != null)\n                            message.message = String(object.message);\n                        switch (object.code) {\n                        default:\n                            if (typeof object.code === \"number\") {\n                                message.code = object.code;\n                                break;\n                            }\n                            break;\n                        case \"STATUS_CODE_UNSET\":\n                        case 0:\n                            message.code = 0;\n                            break;\n                        case \"STATUS_CODE_OK\":\n                        case 1:\n                            message.code = 1;\n                            break;\n                        case \"STATUS_CODE_ERROR\":\n                        case 2:\n                            message.code = 2;\n                            break;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Status message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.Status} message Status\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Status.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.message = \"\";\n                            object.code = options.enums === String ? \"STATUS_CODE_UNSET\" : 0;\n                        }\n                        if (message.message != null && message.hasOwnProperty(\"message\"))\n                            object.message = message.message;\n                        if (message.code != null && message.hasOwnProperty(\"code\"))\n                            object.code = options.enums === String ? $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] === undefined ? message.code : $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] : message.code;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Status to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Status.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Status\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Status\";\n                    };\n\n                    /**\n                     * StatusCode enum.\n                     * @name opentelemetry.proto.trace.v1.Status.StatusCode\n                     * @enum {number}\n                     * @property {number} STATUS_CODE_UNSET=0 STATUS_CODE_UNSET value\n                     * @property {number} STATUS_CODE_OK=1 STATUS_CODE_OK value\n                     * @property {number} STATUS_CODE_ERROR=2 STATUS_CODE_ERROR value\n                     */\n                    Status.StatusCode = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"STATUS_CODE_UNSET\"] = 0;\n                        values[valuesById[1] = \"STATUS_CODE_OK\"] = 1;\n                        values[valuesById[2] = \"STATUS_CODE_ERROR\"] = 2;\n                        return values;\n                    })();\n\n                    return Status;\n                })();\n\n                /**\n                 * SpanFlags enum.\n                 * @name opentelemetry.proto.trace.v1.SpanFlags\n                 * @enum {number}\n                 * @property {number} SPAN_FLAGS_DO_NOT_USE=0 SPAN_FLAGS_DO_NOT_USE value\n                 * @property {number} SPAN_FLAGS_TRACE_FLAGS_MASK=255 SPAN_FLAGS_TRACE_FLAGS_MASK value\n                 * @property {number} SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK=256 SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK value\n                 * @property {number} SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK=512 SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK value\n                 */\n                v1.SpanFlags = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"SPAN_FLAGS_DO_NOT_USE\"] = 0;\n                    values[valuesById[255] = \"SPAN_FLAGS_TRACE_FLAGS_MASK\"] = 255;\n                    values[valuesById[256] = \"SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK\"] = 256;\n                    values[valuesById[512] = \"SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK\"] = 512;\n                    return values;\n                })();\n\n                return v1;\n            })();\n\n            return trace;\n        })();\n\n        proto.collector = (function() {\n\n            /**\n             * Namespace collector.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var collector = {};\n\n            collector.trace = (function() {\n\n                /**\n                 * Namespace trace.\n                 * @memberof opentelemetry.proto.collector\n                 * @namespace\n                 */\n                var trace = {};\n\n                trace.v1 = (function() {\n\n                    /**\n                     * Namespace v1.\n                     * @memberof opentelemetry.proto.collector.trace\n                     * @namespace\n                     */\n                    var v1 = {};\n\n                    v1.TraceService = (function() {\n\n                        /**\n                         * Constructs a new TraceService service.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents a TraceService\n                         * @extends $protobuf.rpc.Service\n                         * @constructor\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         */\n                        function TraceService(rpcImpl, requestDelimited, responseDelimited) {\n                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n                        }\n\n                        (TraceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TraceService;\n\n                        /**\n                         * Creates new TraceService service using the specified rpc implementation.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @static\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         * @returns {TraceService} RPC service. Useful where requests and/or responses are streamed.\n                         */\n                        TraceService.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                            return new this(rpcImpl, requestDelimited, responseDelimited);\n                        };\n\n                        /**\n                         * Callback as used by {@link opentelemetry.proto.collector.trace.v1.TraceService#export_}.\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @typedef ExportCallback\n                         * @type {function}\n                         * @param {Error|null} error Error, if any\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} [response] ExportTraceServiceResponse\n                         */\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} request ExportTraceServiceRequest message or plain object\n                         * @param {opentelemetry.proto.collector.trace.v1.TraceService.ExportCallback} callback Node-style callback called with the error, if any, and ExportTraceServiceResponse\n                         * @returns {undefined}\n                         * @variation 1\n                         */\n                        Object.defineProperty(TraceService.prototype[\"export\"] = function export_(request, callback) {\n                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, request, callback);\n                        }, \"name\", { value: \"Export\" });\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} request ExportTraceServiceRequest message or plain object\n                         * @returns {Promise<opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse>} Promise\n                         * @variation 2\n                         */\n\n                        return TraceService;\n                    })();\n\n                    v1.ExportTraceServiceRequest = (function() {\n\n                        /**\n                         * Properties of an ExportTraceServiceRequest.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @interface IExportTraceServiceRequest\n                         * @property {Array.<opentelemetry.proto.trace.v1.IResourceSpans>|null} [resourceSpans] ExportTraceServiceRequest resourceSpans\n                         */\n\n                        /**\n                         * Constructs a new ExportTraceServiceRequest.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents an ExportTraceServiceRequest.\n                         * @implements IExportTraceServiceRequest\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest=} [properties] Properties to set\n                         */\n                        function ExportTraceServiceRequest(properties) {\n                            this.resourceSpans = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportTraceServiceRequest resourceSpans.\n                         * @member {Array.<opentelemetry.proto.trace.v1.IResourceSpans>} resourceSpans\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @instance\n                         */\n                        ExportTraceServiceRequest.prototype.resourceSpans = $util.emptyArray;\n\n                        /**\n                         * Creates a new ExportTraceServiceRequest instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest instance\n                         */\n                        ExportTraceServiceRequest.create = function create(properties) {\n                            return new ExportTraceServiceRequest(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} message ExportTraceServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceRequest.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.resourceSpans != null && message.resourceSpans.length)\n                                for (var i = 0; i < message.resourceSpans.length; ++i)\n                                    $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} message ExportTraceServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceRequest message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceRequest.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        if (!(message.resourceSpans && message.resourceSpans.length))\n                                            message.resourceSpans = [];\n                                        message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceRequest message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceRequest.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportTraceServiceRequest message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportTraceServiceRequest.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.resourceSpans != null && message.hasOwnProperty(\"resourceSpans\")) {\n                                if (!Array.isArray(message.resourceSpans))\n                                    return \"resourceSpans: array expected\";\n                                for (var i = 0; i < message.resourceSpans.length; ++i) {\n                                    var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);\n                                    if (error)\n                                        return \"resourceSpans.\" + error;\n                                }\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportTraceServiceRequest message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest\n                         */\n                        ExportTraceServiceRequest.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();\n                            if (object.resourceSpans) {\n                                if (!Array.isArray(object.resourceSpans))\n                                    throw TypeError(\".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: array expected\");\n                                message.resourceSpans = [];\n                                for (var i = 0; i < object.resourceSpans.length; ++i) {\n                                    if (typeof object.resourceSpans[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: object expected\");\n                                    message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportTraceServiceRequest message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} message ExportTraceServiceRequest\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportTraceServiceRequest.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.resourceSpans = [];\n                            if (message.resourceSpans && message.resourceSpans.length) {\n                                object.resourceSpans = [];\n                                for (var j = 0; j < message.resourceSpans.length; ++j)\n                                    object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportTraceServiceRequest to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportTraceServiceRequest.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportTraceServiceRequest\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportTraceServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\";\n                        };\n\n                        return ExportTraceServiceRequest;\n                    })();\n\n                    v1.ExportTraceServiceResponse = (function() {\n\n                        /**\n                         * Properties of an ExportTraceServiceResponse.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @interface IExportTraceServiceResponse\n                         * @property {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess|null} [partialSuccess] ExportTraceServiceResponse partialSuccess\n                         */\n\n                        /**\n                         * Constructs a new ExportTraceServiceResponse.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents an ExportTraceServiceResponse.\n                         * @implements IExportTraceServiceResponse\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse=} [properties] Properties to set\n                         */\n                        function ExportTraceServiceResponse(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportTraceServiceResponse partialSuccess.\n                         * @member {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess|null|undefined} partialSuccess\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @instance\n                         */\n                        ExportTraceServiceResponse.prototype.partialSuccess = null;\n\n                        /**\n                         * Creates a new ExportTraceServiceResponse instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse instance\n                         */\n                        ExportTraceServiceResponse.create = function create(properties) {\n                            return new ExportTraceServiceResponse(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse} message ExportTraceServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceResponse.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, \"partialSuccess\"))\n                                $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse} message ExportTraceServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceResponse message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceResponse.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.decode(reader, reader.uint32());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceResponse message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceResponse.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportTraceServiceResponse message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportTraceServiceResponse.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\")) {\n                                var error = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify(message.partialSuccess);\n                                if (error)\n                                    return \"partialSuccess.\" + error;\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportTraceServiceResponse message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse\n                         */\n                        ExportTraceServiceResponse.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();\n                            if (object.partialSuccess != null) {\n                                if (typeof object.partialSuccess !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.partialSuccess: object expected\");\n                                message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.fromObject(object.partialSuccess);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportTraceServiceResponse message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} message ExportTraceServiceResponse\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportTraceServiceResponse.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults)\n                                object.partialSuccess = null;\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\"))\n                                object.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.toObject(message.partialSuccess, options);\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportTraceServiceResponse to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportTraceServiceResponse.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportTraceServiceResponse\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportTraceServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\";\n                        };\n\n                        return ExportTraceServiceResponse;\n                    })();\n\n                    v1.ExportTracePartialSuccess = (function() {\n\n                        /**\n                         * Properties of an ExportTracePartialSuccess.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @interface IExportTracePartialSuccess\n                         * @property {number|Long|null} [rejectedSpans] ExportTracePartialSuccess rejectedSpans\n                         * @property {string|null} [errorMessage] ExportTracePartialSuccess errorMessage\n                         */\n\n                        /**\n                         * Constructs a new ExportTracePartialSuccess.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents an ExportTracePartialSuccess.\n                         * @implements IExportTracePartialSuccess\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess=} [properties] Properties to set\n                         */\n                        function ExportTracePartialSuccess(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportTracePartialSuccess rejectedSpans.\n                         * @member {number|Long|null|undefined} rejectedSpans\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @instance\n                         */\n                        ExportTracePartialSuccess.prototype.rejectedSpans = null;\n\n                        /**\n                         * ExportTracePartialSuccess errorMessage.\n                         * @member {string|null|undefined} errorMessage\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @instance\n                         */\n                        ExportTracePartialSuccess.prototype.errorMessage = null;\n\n                        /**\n                         * Creates a new ExportTracePartialSuccess instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess instance\n                         */\n                        ExportTracePartialSuccess.create = function create(properties) {\n                            return new ExportTracePartialSuccess(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportTracePartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess} message ExportTracePartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTracePartialSuccess.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.rejectedSpans != null && Object.hasOwnProperty.call(message, \"rejectedSpans\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rejectedSpans);\n                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportTracePartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess} message ExportTracePartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTracePartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportTracePartialSuccess message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTracePartialSuccess.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.rejectedSpans = reader.int64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.errorMessage = reader.string();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportTracePartialSuccess message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTracePartialSuccess.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportTracePartialSuccess message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportTracePartialSuccess.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.rejectedSpans != null && message.hasOwnProperty(\"rejectedSpans\"))\n                                if (!$util.isInteger(message.rejectedSpans) && !(message.rejectedSpans && $util.isInteger(message.rejectedSpans.low) && $util.isInteger(message.rejectedSpans.high)))\n                                    return \"rejectedSpans: integer|Long expected\";\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                if (!$util.isString(message.errorMessage))\n                                    return \"errorMessage: string expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportTracePartialSuccess message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess\n                         */\n                        ExportTracePartialSuccess.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();\n                            if (object.rejectedSpans != null)\n                                if ($util.Long)\n                                    (message.rejectedSpans = $util.Long.fromValue(object.rejectedSpans)).unsigned = false;\n                                else if (typeof object.rejectedSpans === \"string\")\n                                    message.rejectedSpans = parseInt(object.rejectedSpans, 10);\n                                else if (typeof object.rejectedSpans === \"number\")\n                                    message.rejectedSpans = object.rejectedSpans;\n                                else if (typeof object.rejectedSpans === \"object\")\n                                    message.rejectedSpans = new $util.LongBits(object.rejectedSpans.low >>> 0, object.rejectedSpans.high >>> 0).toNumber();\n                            if (object.errorMessage != null)\n                                message.errorMessage = String(object.errorMessage);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportTracePartialSuccess message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} message ExportTracePartialSuccess\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportTracePartialSuccess.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.rejectedSpans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.rejectedSpans = options.longs === String ? \"0\" : 0;\n                                object.errorMessage = \"\";\n                            }\n                            if (message.rejectedSpans != null && message.hasOwnProperty(\"rejectedSpans\"))\n                                if (typeof message.rejectedSpans === \"number\")\n                                    object.rejectedSpans = options.longs === String ? String(message.rejectedSpans) : message.rejectedSpans;\n                                else\n                                    object.rejectedSpans = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedSpans) : options.longs === Number ? new $util.LongBits(message.rejectedSpans.low >>> 0, message.rejectedSpans.high >>> 0).toNumber() : message.rejectedSpans;\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                object.errorMessage = message.errorMessage;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportTracePartialSuccess to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportTracePartialSuccess.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportTracePartialSuccess\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportTracePartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\";\n                        };\n\n                        return ExportTracePartialSuccess;\n                    })();\n\n                    return v1;\n                })();\n\n                return trace;\n            })();\n\n            collector.metrics = (function() {\n\n                /**\n                 * Namespace metrics.\n                 * @memberof opentelemetry.proto.collector\n                 * @namespace\n                 */\n                var metrics = {};\n\n                metrics.v1 = (function() {\n\n                    /**\n                     * Namespace v1.\n                     * @memberof opentelemetry.proto.collector.metrics\n                     * @namespace\n                     */\n                    var v1 = {};\n\n                    v1.MetricsService = (function() {\n\n                        /**\n                         * Constructs a new MetricsService service.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents a MetricsService\n                         * @extends $protobuf.rpc.Service\n                         * @constructor\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         */\n                        function MetricsService(rpcImpl, requestDelimited, responseDelimited) {\n                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n                        }\n\n                        (MetricsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsService;\n\n                        /**\n                         * Creates new MetricsService service using the specified rpc implementation.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @static\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         * @returns {MetricsService} RPC service. Useful where requests and/or responses are streamed.\n                         */\n                        MetricsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                            return new this(rpcImpl, requestDelimited, responseDelimited);\n                        };\n\n                        /**\n                         * Callback as used by {@link opentelemetry.proto.collector.metrics.v1.MetricsService#export_}.\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @typedef ExportCallback\n                         * @type {function}\n                         * @param {Error|null} error Error, if any\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} [response] ExportMetricsServiceResponse\n                         */\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} request ExportMetricsServiceRequest message or plain object\n                         * @param {opentelemetry.proto.collector.metrics.v1.MetricsService.ExportCallback} callback Node-style callback called with the error, if any, and ExportMetricsServiceResponse\n                         * @returns {undefined}\n                         * @variation 1\n                         */\n                        Object.defineProperty(MetricsService.prototype[\"export\"] = function export_(request, callback) {\n                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, request, callback);\n                        }, \"name\", { value: \"Export\" });\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} request ExportMetricsServiceRequest message or plain object\n                         * @returns {Promise<opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse>} Promise\n                         * @variation 2\n                         */\n\n                        return MetricsService;\n                    })();\n\n                    v1.ExportMetricsServiceRequest = (function() {\n\n                        /**\n                         * Properties of an ExportMetricsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @interface IExportMetricsServiceRequest\n                         * @property {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>|null} [resourceMetrics] ExportMetricsServiceRequest resourceMetrics\n                         */\n\n                        /**\n                         * Constructs a new ExportMetricsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents an ExportMetricsServiceRequest.\n                         * @implements IExportMetricsServiceRequest\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest=} [properties] Properties to set\n                         */\n                        function ExportMetricsServiceRequest(properties) {\n                            this.resourceMetrics = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportMetricsServiceRequest resourceMetrics.\n                         * @member {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>} resourceMetrics\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @instance\n                         */\n                        ExportMetricsServiceRequest.prototype.resourceMetrics = $util.emptyArray;\n\n                        /**\n                         * Creates a new ExportMetricsServiceRequest instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest instance\n                         */\n                        ExportMetricsServiceRequest.create = function create(properties) {\n                            return new ExportMetricsServiceRequest(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} message ExportMetricsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceRequest.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.resourceMetrics != null && message.resourceMetrics.length)\n                                for (var i = 0; i < message.resourceMetrics.length; ++i)\n                                    $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} message ExportMetricsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceRequest message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceRequest.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        if (!(message.resourceMetrics && message.resourceMetrics.length))\n                                            message.resourceMetrics = [];\n                                        message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceRequest message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceRequest.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportMetricsServiceRequest message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportMetricsServiceRequest.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.resourceMetrics != null && message.hasOwnProperty(\"resourceMetrics\")) {\n                                if (!Array.isArray(message.resourceMetrics))\n                                    return \"resourceMetrics: array expected\";\n                                for (var i = 0; i < message.resourceMetrics.length; ++i) {\n                                    var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);\n                                    if (error)\n                                        return \"resourceMetrics.\" + error;\n                                }\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportMetricsServiceRequest message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest\n                         */\n                        ExportMetricsServiceRequest.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();\n                            if (object.resourceMetrics) {\n                                if (!Array.isArray(object.resourceMetrics))\n                                    throw TypeError(\".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: array expected\");\n                                message.resourceMetrics = [];\n                                for (var i = 0; i < object.resourceMetrics.length; ++i) {\n                                    if (typeof object.resourceMetrics[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: object expected\");\n                                    message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportMetricsServiceRequest message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} message ExportMetricsServiceRequest\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportMetricsServiceRequest.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.resourceMetrics = [];\n                            if (message.resourceMetrics && message.resourceMetrics.length) {\n                                object.resourceMetrics = [];\n                                for (var j = 0; j < message.resourceMetrics.length; ++j)\n                                    object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportMetricsServiceRequest to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportMetricsServiceRequest.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportMetricsServiceRequest\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportMetricsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\";\n                        };\n\n                        return ExportMetricsServiceRequest;\n                    })();\n\n                    v1.ExportMetricsServiceResponse = (function() {\n\n                        /**\n                         * Properties of an ExportMetricsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @interface IExportMetricsServiceResponse\n                         * @property {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess|null} [partialSuccess] ExportMetricsServiceResponse partialSuccess\n                         */\n\n                        /**\n                         * Constructs a new ExportMetricsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents an ExportMetricsServiceResponse.\n                         * @implements IExportMetricsServiceResponse\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse=} [properties] Properties to set\n                         */\n                        function ExportMetricsServiceResponse(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportMetricsServiceResponse partialSuccess.\n                         * @member {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess|null|undefined} partialSuccess\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @instance\n                         */\n                        ExportMetricsServiceResponse.prototype.partialSuccess = null;\n\n                        /**\n                         * Creates a new ExportMetricsServiceResponse instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse instance\n                         */\n                        ExportMetricsServiceResponse.create = function create(properties) {\n                            return new ExportMetricsServiceResponse(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse} message ExportMetricsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceResponse.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, \"partialSuccess\"))\n                                $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse} message ExportMetricsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceResponse message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceResponse.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.decode(reader, reader.uint32());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceResponse message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceResponse.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportMetricsServiceResponse message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportMetricsServiceResponse.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\")) {\n                                var error = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify(message.partialSuccess);\n                                if (error)\n                                    return \"partialSuccess.\" + error;\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportMetricsServiceResponse message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse\n                         */\n                        ExportMetricsServiceResponse.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();\n                            if (object.partialSuccess != null) {\n                                if (typeof object.partialSuccess !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.partialSuccess: object expected\");\n                                message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.fromObject(object.partialSuccess);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportMetricsServiceResponse message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} message ExportMetricsServiceResponse\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportMetricsServiceResponse.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults)\n                                object.partialSuccess = null;\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\"))\n                                object.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.toObject(message.partialSuccess, options);\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportMetricsServiceResponse to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportMetricsServiceResponse.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportMetricsServiceResponse\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportMetricsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\";\n                        };\n\n                        return ExportMetricsServiceResponse;\n                    })();\n\n                    v1.ExportMetricsPartialSuccess = (function() {\n\n                        /**\n                         * Properties of an ExportMetricsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @interface IExportMetricsPartialSuccess\n                         * @property {number|Long|null} [rejectedDataPoints] ExportMetricsPartialSuccess rejectedDataPoints\n                         * @property {string|null} [errorMessage] ExportMetricsPartialSuccess errorMessage\n                         */\n\n                        /**\n                         * Constructs a new ExportMetricsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents an ExportMetricsPartialSuccess.\n                         * @implements IExportMetricsPartialSuccess\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess=} [properties] Properties to set\n                         */\n                        function ExportMetricsPartialSuccess(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportMetricsPartialSuccess rejectedDataPoints.\n                         * @member {number|Long|null|undefined} rejectedDataPoints\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @instance\n                         */\n                        ExportMetricsPartialSuccess.prototype.rejectedDataPoints = null;\n\n                        /**\n                         * ExportMetricsPartialSuccess errorMessage.\n                         * @member {string|null|undefined} errorMessage\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @instance\n                         */\n                        ExportMetricsPartialSuccess.prototype.errorMessage = null;\n\n                        /**\n                         * Creates a new ExportMetricsPartialSuccess instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess instance\n                         */\n                        ExportMetricsPartialSuccess.create = function create(properties) {\n                            return new ExportMetricsPartialSuccess(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsPartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess} message ExportMetricsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsPartialSuccess.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.rejectedDataPoints != null && Object.hasOwnProperty.call(message, \"rejectedDataPoints\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rejectedDataPoints);\n                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsPartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess} message ExportMetricsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsPartialSuccess message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsPartialSuccess.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.rejectedDataPoints = reader.int64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.errorMessage = reader.string();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsPartialSuccess message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportMetricsPartialSuccess message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportMetricsPartialSuccess.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.rejectedDataPoints != null && message.hasOwnProperty(\"rejectedDataPoints\"))\n                                if (!$util.isInteger(message.rejectedDataPoints) && !(message.rejectedDataPoints && $util.isInteger(message.rejectedDataPoints.low) && $util.isInteger(message.rejectedDataPoints.high)))\n                                    return \"rejectedDataPoints: integer|Long expected\";\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                if (!$util.isString(message.errorMessage))\n                                    return \"errorMessage: string expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportMetricsPartialSuccess message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess\n                         */\n                        ExportMetricsPartialSuccess.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();\n                            if (object.rejectedDataPoints != null)\n                                if ($util.Long)\n                                    (message.rejectedDataPoints = $util.Long.fromValue(object.rejectedDataPoints)).unsigned = false;\n                                else if (typeof object.rejectedDataPoints === \"string\")\n                                    message.rejectedDataPoints = parseInt(object.rejectedDataPoints, 10);\n                                else if (typeof object.rejectedDataPoints === \"number\")\n                                    message.rejectedDataPoints = object.rejectedDataPoints;\n                                else if (typeof object.rejectedDataPoints === \"object\")\n                                    message.rejectedDataPoints = new $util.LongBits(object.rejectedDataPoints.low >>> 0, object.rejectedDataPoints.high >>> 0).toNumber();\n                            if (object.errorMessage != null)\n                                message.errorMessage = String(object.errorMessage);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportMetricsPartialSuccess message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} message ExportMetricsPartialSuccess\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportMetricsPartialSuccess.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.rejectedDataPoints = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.rejectedDataPoints = options.longs === String ? \"0\" : 0;\n                                object.errorMessage = \"\";\n                            }\n                            if (message.rejectedDataPoints != null && message.hasOwnProperty(\"rejectedDataPoints\"))\n                                if (typeof message.rejectedDataPoints === \"number\")\n                                    object.rejectedDataPoints = options.longs === String ? String(message.rejectedDataPoints) : message.rejectedDataPoints;\n                                else\n                                    object.rejectedDataPoints = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedDataPoints) : options.longs === Number ? new $util.LongBits(message.rejectedDataPoints.low >>> 0, message.rejectedDataPoints.high >>> 0).toNumber() : message.rejectedDataPoints;\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                object.errorMessage = message.errorMessage;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportMetricsPartialSuccess to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportMetricsPartialSuccess.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportMetricsPartialSuccess\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportMetricsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\";\n                        };\n\n                        return ExportMetricsPartialSuccess;\n                    })();\n\n                    return v1;\n                })();\n\n                return metrics;\n            })();\n\n            collector.logs = (function() {\n\n                /**\n                 * Namespace logs.\n                 * @memberof opentelemetry.proto.collector\n                 * @namespace\n                 */\n                var logs = {};\n\n                logs.v1 = (function() {\n\n                    /**\n                     * Namespace v1.\n                     * @memberof opentelemetry.proto.collector.logs\n                     * @namespace\n                     */\n                    var v1 = {};\n\n                    v1.LogsService = (function() {\n\n                        /**\n                         * Constructs a new LogsService service.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents a LogsService\n                         * @extends $protobuf.rpc.Service\n                         * @constructor\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         */\n                        function LogsService(rpcImpl, requestDelimited, responseDelimited) {\n                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n                        }\n\n                        (LogsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogsService;\n\n                        /**\n                         * Creates new LogsService service using the specified rpc implementation.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @static\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         * @returns {LogsService} RPC service. Useful where requests and/or responses are streamed.\n                         */\n                        LogsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                            return new this(rpcImpl, requestDelimited, responseDelimited);\n                        };\n\n                        /**\n                         * Callback as used by {@link opentelemetry.proto.collector.logs.v1.LogsService#export_}.\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @typedef ExportCallback\n                         * @type {function}\n                         * @param {Error|null} error Error, if any\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} [response] ExportLogsServiceResponse\n                         */\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} request ExportLogsServiceRequest message or plain object\n                         * @param {opentelemetry.proto.collector.logs.v1.LogsService.ExportCallback} callback Node-style callback called with the error, if any, and ExportLogsServiceResponse\n                         * @returns {undefined}\n                         * @variation 1\n                         */\n                        Object.defineProperty(LogsService.prototype[\"export\"] = function export_(request, callback) {\n                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, request, callback);\n                        }, \"name\", { value: \"Export\" });\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} request ExportLogsServiceRequest message or plain object\n                         * @returns {Promise<opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse>} Promise\n                         * @variation 2\n                         */\n\n                        return LogsService;\n                    })();\n\n                    v1.ExportLogsServiceRequest = (function() {\n\n                        /**\n                         * Properties of an ExportLogsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @interface IExportLogsServiceRequest\n                         * @property {Array.<opentelemetry.proto.logs.v1.IResourceLogs>|null} [resourceLogs] ExportLogsServiceRequest resourceLogs\n                         */\n\n                        /**\n                         * Constructs a new ExportLogsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents an ExportLogsServiceRequest.\n                         * @implements IExportLogsServiceRequest\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest=} [properties] Properties to set\n                         */\n                        function ExportLogsServiceRequest(properties) {\n                            this.resourceLogs = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportLogsServiceRequest resourceLogs.\n                         * @member {Array.<opentelemetry.proto.logs.v1.IResourceLogs>} resourceLogs\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @instance\n                         */\n                        ExportLogsServiceRequest.prototype.resourceLogs = $util.emptyArray;\n\n                        /**\n                         * Creates a new ExportLogsServiceRequest instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest instance\n                         */\n                        ExportLogsServiceRequest.create = function create(properties) {\n                            return new ExportLogsServiceRequest(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} message ExportLogsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceRequest.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.resourceLogs != null && message.resourceLogs.length)\n                                for (var i = 0; i < message.resourceLogs.length; ++i)\n                                    $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} message ExportLogsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceRequest message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceRequest.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        if (!(message.resourceLogs && message.resourceLogs.length))\n                                            message.resourceLogs = [];\n                                        message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceRequest message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceRequest.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportLogsServiceRequest message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportLogsServiceRequest.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.resourceLogs != null && message.hasOwnProperty(\"resourceLogs\")) {\n                                if (!Array.isArray(message.resourceLogs))\n                                    return \"resourceLogs: array expected\";\n                                for (var i = 0; i < message.resourceLogs.length; ++i) {\n                                    var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);\n                                    if (error)\n                                        return \"resourceLogs.\" + error;\n                                }\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportLogsServiceRequest message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest\n                         */\n                        ExportLogsServiceRequest.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();\n                            if (object.resourceLogs) {\n                                if (!Array.isArray(object.resourceLogs))\n                                    throw TypeError(\".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: array expected\");\n                                message.resourceLogs = [];\n                                for (var i = 0; i < object.resourceLogs.length; ++i) {\n                                    if (typeof object.resourceLogs[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: object expected\");\n                                    message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportLogsServiceRequest message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} message ExportLogsServiceRequest\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportLogsServiceRequest.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.resourceLogs = [];\n                            if (message.resourceLogs && message.resourceLogs.length) {\n                                object.resourceLogs = [];\n                                for (var j = 0; j < message.resourceLogs.length; ++j)\n                                    object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportLogsServiceRequest to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportLogsServiceRequest.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportLogsServiceRequest\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportLogsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\";\n                        };\n\n                        return ExportLogsServiceRequest;\n                    })();\n\n                    v1.ExportLogsServiceResponse = (function() {\n\n                        /**\n                         * Properties of an ExportLogsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @interface IExportLogsServiceResponse\n                         * @property {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess|null} [partialSuccess] ExportLogsServiceResponse partialSuccess\n                         */\n\n                        /**\n                         * Constructs a new ExportLogsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents an ExportLogsServiceResponse.\n                         * @implements IExportLogsServiceResponse\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse=} [properties] Properties to set\n                         */\n                        function ExportLogsServiceResponse(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportLogsServiceResponse partialSuccess.\n                         * @member {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess|null|undefined} partialSuccess\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @instance\n                         */\n                        ExportLogsServiceResponse.prototype.partialSuccess = null;\n\n                        /**\n                         * Creates a new ExportLogsServiceResponse instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse instance\n                         */\n                        ExportLogsServiceResponse.create = function create(properties) {\n                            return new ExportLogsServiceResponse(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse} message ExportLogsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceResponse.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, \"partialSuccess\"))\n                                $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse} message ExportLogsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceResponse message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceResponse.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.decode(reader, reader.uint32());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceResponse message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceResponse.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportLogsServiceResponse message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportLogsServiceResponse.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\")) {\n                                var error = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify(message.partialSuccess);\n                                if (error)\n                                    return \"partialSuccess.\" + error;\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportLogsServiceResponse message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse\n                         */\n                        ExportLogsServiceResponse.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();\n                            if (object.partialSuccess != null) {\n                                if (typeof object.partialSuccess !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.partialSuccess: object expected\");\n                                message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.fromObject(object.partialSuccess);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportLogsServiceResponse message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} message ExportLogsServiceResponse\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportLogsServiceResponse.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults)\n                                object.partialSuccess = null;\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\"))\n                                object.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.toObject(message.partialSuccess, options);\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportLogsServiceResponse to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportLogsServiceResponse.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportLogsServiceResponse\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportLogsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\";\n                        };\n\n                        return ExportLogsServiceResponse;\n                    })();\n\n                    v1.ExportLogsPartialSuccess = (function() {\n\n                        /**\n                         * Properties of an ExportLogsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @interface IExportLogsPartialSuccess\n                         * @property {number|Long|null} [rejectedLogRecords] ExportLogsPartialSuccess rejectedLogRecords\n                         * @property {string|null} [errorMessage] ExportLogsPartialSuccess errorMessage\n                         */\n\n                        /**\n                         * Constructs a new ExportLogsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents an ExportLogsPartialSuccess.\n                         * @implements IExportLogsPartialSuccess\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess=} [properties] Properties to set\n                         */\n                        function ExportLogsPartialSuccess(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportLogsPartialSuccess rejectedLogRecords.\n                         * @member {number|Long|null|undefined} rejectedLogRecords\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @instance\n                         */\n                        ExportLogsPartialSuccess.prototype.rejectedLogRecords = null;\n\n                        /**\n                         * ExportLogsPartialSuccess errorMessage.\n                         * @member {string|null|undefined} errorMessage\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @instance\n                         */\n                        ExportLogsPartialSuccess.prototype.errorMessage = null;\n\n                        /**\n                         * Creates a new ExportLogsPartialSuccess instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess instance\n                         */\n                        ExportLogsPartialSuccess.create = function create(properties) {\n                            return new ExportLogsPartialSuccess(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsPartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess} message ExportLogsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsPartialSuccess.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.rejectedLogRecords != null && Object.hasOwnProperty.call(message, \"rejectedLogRecords\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rejectedLogRecords);\n                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsPartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess} message ExportLogsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportLogsPartialSuccess message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsPartialSuccess.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.rejectedLogRecords = reader.int64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.errorMessage = reader.string();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportLogsPartialSuccess message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportLogsPartialSuccess message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportLogsPartialSuccess.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.rejectedLogRecords != null && message.hasOwnProperty(\"rejectedLogRecords\"))\n                                if (!$util.isInteger(message.rejectedLogRecords) && !(message.rejectedLogRecords && $util.isInteger(message.rejectedLogRecords.low) && $util.isInteger(message.rejectedLogRecords.high)))\n                                    return \"rejectedLogRecords: integer|Long expected\";\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                if (!$util.isString(message.errorMessage))\n                                    return \"errorMessage: string expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportLogsPartialSuccess message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess\n                         */\n                        ExportLogsPartialSuccess.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();\n                            if (object.rejectedLogRecords != null)\n                                if ($util.Long)\n                                    (message.rejectedLogRecords = $util.Long.fromValue(object.rejectedLogRecords)).unsigned = false;\n                                else if (typeof object.rejectedLogRecords === \"string\")\n                                    message.rejectedLogRecords = parseInt(object.rejectedLogRecords, 10);\n                                else if (typeof object.rejectedLogRecords === \"number\")\n                                    message.rejectedLogRecords = object.rejectedLogRecords;\n                                else if (typeof object.rejectedLogRecords === \"object\")\n                                    message.rejectedLogRecords = new $util.LongBits(object.rejectedLogRecords.low >>> 0, object.rejectedLogRecords.high >>> 0).toNumber();\n                            if (object.errorMessage != null)\n                                message.errorMessage = String(object.errorMessage);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportLogsPartialSuccess message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} message ExportLogsPartialSuccess\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportLogsPartialSuccess.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.rejectedLogRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.rejectedLogRecords = options.longs === String ? \"0\" : 0;\n                                object.errorMessage = \"\";\n                            }\n                            if (message.rejectedLogRecords != null && message.hasOwnProperty(\"rejectedLogRecords\"))\n                                if (typeof message.rejectedLogRecords === \"number\")\n                                    object.rejectedLogRecords = options.longs === String ? String(message.rejectedLogRecords) : message.rejectedLogRecords;\n                                else\n                                    object.rejectedLogRecords = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedLogRecords) : options.longs === Number ? new $util.LongBits(message.rejectedLogRecords.low >>> 0, message.rejectedLogRecords.high >>> 0).toNumber() : message.rejectedLogRecords;\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                object.errorMessage = message.errorMessage;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportLogsPartialSuccess to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportLogsPartialSuccess.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportLogsPartialSuccess\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportLogsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\";\n                        };\n\n                        return ExportLogsPartialSuccess;\n                    })();\n\n                    return v1;\n                })();\n\n                return logs;\n            })();\n\n            return collector;\n        })();\n\n        proto.metrics = (function() {\n\n            /**\n             * Namespace metrics.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var metrics = {};\n\n            metrics.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.metrics\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.MetricsData = (function() {\n\n                    /**\n                     * Properties of a MetricsData.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IMetricsData\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>|null} [resourceMetrics] MetricsData resourceMetrics\n                     */\n\n                    /**\n                     * Constructs a new MetricsData.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a MetricsData.\n                     * @implements IMetricsData\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData=} [properties] Properties to set\n                     */\n                    function MetricsData(properties) {\n                        this.resourceMetrics = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * MetricsData resourceMetrics.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>} resourceMetrics\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @instance\n                     */\n                    MetricsData.prototype.resourceMetrics = $util.emptyArray;\n\n                    /**\n                     * Creates a new MetricsData instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData instance\n                     */\n                    MetricsData.create = function create(properties) {\n                        return new MetricsData(properties);\n                    };\n\n                    /**\n                     * Encodes the specified MetricsData message. Does not implicitly {@link opentelemetry.proto.metrics.v1.MetricsData.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData} message MetricsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    MetricsData.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resourceMetrics != null && message.resourceMetrics.length)\n                            for (var i = 0; i < message.resourceMetrics.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified MetricsData message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.MetricsData.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData} message MetricsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    MetricsData.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a MetricsData message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    MetricsData.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.MetricsData();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.resourceMetrics && message.resourceMetrics.length))\n                                        message.resourceMetrics = [];\n                                    message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a MetricsData message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    MetricsData.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a MetricsData message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    MetricsData.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resourceMetrics != null && message.hasOwnProperty(\"resourceMetrics\")) {\n                            if (!Array.isArray(message.resourceMetrics))\n                                return \"resourceMetrics: array expected\";\n                            for (var i = 0; i < message.resourceMetrics.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);\n                                if (error)\n                                    return \"resourceMetrics.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a MetricsData message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData\n                     */\n                    MetricsData.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.MetricsData)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.MetricsData();\n                        if (object.resourceMetrics) {\n                            if (!Array.isArray(object.resourceMetrics))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: array expected\");\n                            message.resourceMetrics = [];\n                            for (var i = 0; i < object.resourceMetrics.length; ++i) {\n                                if (typeof object.resourceMetrics[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: object expected\");\n                                message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a MetricsData message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.MetricsData} message MetricsData\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    MetricsData.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.resourceMetrics = [];\n                        if (message.resourceMetrics && message.resourceMetrics.length) {\n                            object.resourceMetrics = [];\n                            for (var j = 0; j < message.resourceMetrics.length; ++j)\n                                object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this MetricsData to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    MetricsData.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for MetricsData\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    MetricsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.MetricsData\";\n                    };\n\n                    return MetricsData;\n                })();\n\n                v1.ResourceMetrics = (function() {\n\n                    /**\n                     * Properties of a ResourceMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IResourceMetrics\n                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceMetrics resource\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IScopeMetrics>|null} [scopeMetrics] ResourceMetrics scopeMetrics\n                     * @property {string|null} [schemaUrl] ResourceMetrics schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ResourceMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a ResourceMetrics.\n                     * @implements IResourceMetrics\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics=} [properties] Properties to set\n                     */\n                    function ResourceMetrics(properties) {\n                        this.scopeMetrics = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ResourceMetrics resource.\n                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     */\n                    ResourceMetrics.prototype.resource = null;\n\n                    /**\n                     * ResourceMetrics scopeMetrics.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IScopeMetrics>} scopeMetrics\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     */\n                    ResourceMetrics.prototype.scopeMetrics = $util.emptyArray;\n\n                    /**\n                     * ResourceMetrics schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     */\n                    ResourceMetrics.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ResourceMetrics instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics instance\n                     */\n                    ResourceMetrics.create = function create(properties) {\n                        return new ResourceMetrics(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ResourceMetrics message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ResourceMetrics.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics} message ResourceMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceMetrics.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resource != null && Object.hasOwnProperty.call(message, \"resource\"))\n                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.scopeMetrics != null && message.scopeMetrics.length)\n                            for (var i = 0; i < message.scopeMetrics.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.ScopeMetrics.encode(message.scopeMetrics[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ResourceMetrics message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ResourceMetrics.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics} message ResourceMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceMetrics.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ResourceMetrics message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceMetrics.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.scopeMetrics && message.scopeMetrics.length))\n                                        message.scopeMetrics = [];\n                                    message.scopeMetrics.push($root.opentelemetry.proto.metrics.v1.ScopeMetrics.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ResourceMetrics message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceMetrics.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ResourceMetrics message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ResourceMetrics.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resource != null && message.hasOwnProperty(\"resource\")) {\n                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);\n                            if (error)\n                                return \"resource.\" + error;\n                        }\n                        if (message.scopeMetrics != null && message.hasOwnProperty(\"scopeMetrics\")) {\n                            if (!Array.isArray(message.scopeMetrics))\n                                return \"scopeMetrics: array expected\";\n                            for (var i = 0; i < message.scopeMetrics.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.verify(message.scopeMetrics[i]);\n                                if (error)\n                                    return \"scopeMetrics.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ResourceMetrics message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics\n                     */\n                    ResourceMetrics.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ResourceMetrics)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();\n                        if (object.resource != null) {\n                            if (typeof object.resource !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ResourceMetrics.resource: object expected\");\n                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);\n                        }\n                        if (object.scopeMetrics) {\n                            if (!Array.isArray(object.scopeMetrics))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: array expected\");\n                            message.scopeMetrics = [];\n                            for (var i = 0; i < object.scopeMetrics.length; ++i) {\n                                if (typeof object.scopeMetrics[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: object expected\");\n                                message.scopeMetrics[i] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.fromObject(object.scopeMetrics[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ResourceMetrics message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ResourceMetrics} message ResourceMetrics\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ResourceMetrics.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.scopeMetrics = [];\n                        if (options.defaults) {\n                            object.resource = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.resource != null && message.hasOwnProperty(\"resource\"))\n                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);\n                        if (message.scopeMetrics && message.scopeMetrics.length) {\n                            object.scopeMetrics = [];\n                            for (var j = 0; j < message.scopeMetrics.length; ++j)\n                                object.scopeMetrics[j] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.toObject(message.scopeMetrics[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ResourceMetrics to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ResourceMetrics.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ResourceMetrics\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ResourceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ResourceMetrics\";\n                    };\n\n                    return ResourceMetrics;\n                })();\n\n                v1.ScopeMetrics = (function() {\n\n                    /**\n                     * Properties of a ScopeMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IScopeMetrics\n                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeMetrics scope\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IMetric>|null} [metrics] ScopeMetrics metrics\n                     * @property {string|null} [schemaUrl] ScopeMetrics schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ScopeMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a ScopeMetrics.\n                     * @implements IScopeMetrics\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics=} [properties] Properties to set\n                     */\n                    function ScopeMetrics(properties) {\n                        this.metrics = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ScopeMetrics scope.\n                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     */\n                    ScopeMetrics.prototype.scope = null;\n\n                    /**\n                     * ScopeMetrics metrics.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IMetric>} metrics\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     */\n                    ScopeMetrics.prototype.metrics = $util.emptyArray;\n\n                    /**\n                     * ScopeMetrics schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     */\n                    ScopeMetrics.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ScopeMetrics instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics instance\n                     */\n                    ScopeMetrics.create = function create(properties) {\n                        return new ScopeMetrics(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ScopeMetrics message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ScopeMetrics.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics} message ScopeMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeMetrics.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.metrics != null && message.metrics.length)\n                            for (var i = 0; i < message.metrics.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Metric.encode(message.metrics[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ScopeMetrics message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ScopeMetrics.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics} message ScopeMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeMetrics.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ScopeMetrics message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeMetrics.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.metrics && message.metrics.length))\n                                        message.metrics = [];\n                                    message.metrics.push($root.opentelemetry.proto.metrics.v1.Metric.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ScopeMetrics message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeMetrics.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ScopeMetrics message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ScopeMetrics.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.scope != null && message.hasOwnProperty(\"scope\")) {\n                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);\n                            if (error)\n                                return \"scope.\" + error;\n                        }\n                        if (message.metrics != null && message.hasOwnProperty(\"metrics\")) {\n                            if (!Array.isArray(message.metrics))\n                                return \"metrics: array expected\";\n                            for (var i = 0; i < message.metrics.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Metric.verify(message.metrics[i]);\n                                if (error)\n                                    return \"metrics.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ScopeMetrics message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics\n                     */\n                    ScopeMetrics.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ScopeMetrics)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();\n                        if (object.scope != null) {\n                            if (typeof object.scope !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ScopeMetrics.scope: object expected\");\n                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);\n                        }\n                        if (object.metrics) {\n                            if (!Array.isArray(object.metrics))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: array expected\");\n                            message.metrics = [];\n                            for (var i = 0; i < object.metrics.length; ++i) {\n                                if (typeof object.metrics[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: object expected\");\n                                message.metrics[i] = $root.opentelemetry.proto.metrics.v1.Metric.fromObject(object.metrics[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ScopeMetrics message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ScopeMetrics} message ScopeMetrics\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ScopeMetrics.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.metrics = [];\n                        if (options.defaults) {\n                            object.scope = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);\n                        if (message.metrics && message.metrics.length) {\n                            object.metrics = [];\n                            for (var j = 0; j < message.metrics.length; ++j)\n                                object.metrics[j] = $root.opentelemetry.proto.metrics.v1.Metric.toObject(message.metrics[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ScopeMetrics to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ScopeMetrics.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ScopeMetrics\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ScopeMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ScopeMetrics\";\n                    };\n\n                    return ScopeMetrics;\n                })();\n\n                v1.Metric = (function() {\n\n                    /**\n                     * Properties of a Metric.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IMetric\n                     * @property {string|null} [name] Metric name\n                     * @property {string|null} [description] Metric description\n                     * @property {string|null} [unit] Metric unit\n                     * @property {opentelemetry.proto.metrics.v1.IGauge|null} [gauge] Metric gauge\n                     * @property {opentelemetry.proto.metrics.v1.ISum|null} [sum] Metric sum\n                     * @property {opentelemetry.proto.metrics.v1.IHistogram|null} [histogram] Metric histogram\n                     * @property {opentelemetry.proto.metrics.v1.IExponentialHistogram|null} [exponentialHistogram] Metric exponentialHistogram\n                     * @property {opentelemetry.proto.metrics.v1.ISummary|null} [summary] Metric summary\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [metadata] Metric metadata\n                     */\n\n                    /**\n                     * Constructs a new Metric.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Metric.\n                     * @implements IMetric\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IMetric=} [properties] Properties to set\n                     */\n                    function Metric(properties) {\n                        this.metadata = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Metric name.\n                     * @member {string|null|undefined} name\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.name = null;\n\n                    /**\n                     * Metric description.\n                     * @member {string|null|undefined} description\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.description = null;\n\n                    /**\n                     * Metric unit.\n                     * @member {string|null|undefined} unit\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.unit = null;\n\n                    /**\n                     * Metric gauge.\n                     * @member {opentelemetry.proto.metrics.v1.IGauge|null|undefined} gauge\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.gauge = null;\n\n                    /**\n                     * Metric sum.\n                     * @member {opentelemetry.proto.metrics.v1.ISum|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.sum = null;\n\n                    /**\n                     * Metric histogram.\n                     * @member {opentelemetry.proto.metrics.v1.IHistogram|null|undefined} histogram\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.histogram = null;\n\n                    /**\n                     * Metric exponentialHistogram.\n                     * @member {opentelemetry.proto.metrics.v1.IExponentialHistogram|null|undefined} exponentialHistogram\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.exponentialHistogram = null;\n\n                    /**\n                     * Metric summary.\n                     * @member {opentelemetry.proto.metrics.v1.ISummary|null|undefined} summary\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.summary = null;\n\n                    /**\n                     * Metric metadata.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} metadata\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.metadata = $util.emptyArray;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * Metric data.\n                     * @member {\"gauge\"|\"sum\"|\"histogram\"|\"exponentialHistogram\"|\"summary\"|undefined} data\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Object.defineProperty(Metric.prototype, \"data\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"gauge\", \"sum\", \"histogram\", \"exponentialHistogram\", \"summary\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new Metric instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetric=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric instance\n                     */\n                    Metric.create = function create(properties) {\n                        return new Metric(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Metric message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Metric.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetric} message Metric message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Metric.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.description != null && Object.hasOwnProperty.call(message, \"description\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);\n                        if (message.unit != null && Object.hasOwnProperty.call(message, \"unit\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.unit);\n                        if (message.gauge != null && Object.hasOwnProperty.call(message, \"gauge\"))\n                            $root.opentelemetry.proto.metrics.v1.Gauge.encode(message.gauge, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            $root.opentelemetry.proto.metrics.v1.Sum.encode(message.sum, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.histogram != null && Object.hasOwnProperty.call(message, \"histogram\"))\n                            $root.opentelemetry.proto.metrics.v1.Histogram.encode(message.histogram, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.exponentialHistogram != null && Object.hasOwnProperty.call(message, \"exponentialHistogram\"))\n                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.encode(message.exponentialHistogram, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                        if (message.summary != null && Object.hasOwnProperty.call(message, \"summary\"))\n                            $root.opentelemetry.proto.metrics.v1.Summary.encode(message.summary, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                        if (message.metadata != null && message.metadata.length)\n                            for (var i = 0; i < message.metadata.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.metadata[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Metric message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Metric.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetric} message Metric message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Metric.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Metric message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Metric.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Metric();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.name = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.description = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    message.unit = reader.string();\n                                    break;\n                                }\n                            case 5: {\n                                    message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 7: {\n                                    message.sum = $root.opentelemetry.proto.metrics.v1.Sum.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 9: {\n                                    message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 10: {\n                                    message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 11: {\n                                    message.summary = $root.opentelemetry.proto.metrics.v1.Summary.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 12: {\n                                    if (!(message.metadata && message.metadata.length))\n                                        message.metadata = [];\n                                    message.metadata.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Metric message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Metric.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Metric message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Metric.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            if (!$util.isString(message.name))\n                                return \"name: string expected\";\n                        if (message.description != null && message.hasOwnProperty(\"description\"))\n                            if (!$util.isString(message.description))\n                                return \"description: string expected\";\n                        if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                            if (!$util.isString(message.unit))\n                                return \"unit: string expected\";\n                        if (message.gauge != null && message.hasOwnProperty(\"gauge\")) {\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Gauge.verify(message.gauge);\n                                if (error)\n                                    return \"gauge.\" + error;\n                            }\n                        }\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Sum.verify(message.sum);\n                                if (error)\n                                    return \"sum.\" + error;\n                            }\n                        }\n                        if (message.histogram != null && message.hasOwnProperty(\"histogram\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Histogram.verify(message.histogram);\n                                if (error)\n                                    return \"histogram.\" + error;\n                            }\n                        }\n                        if (message.exponentialHistogram != null && message.hasOwnProperty(\"exponentialHistogram\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.verify(message.exponentialHistogram);\n                                if (error)\n                                    return \"exponentialHistogram.\" + error;\n                            }\n                        }\n                        if (message.summary != null && message.hasOwnProperty(\"summary\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Summary.verify(message.summary);\n                                if (error)\n                                    return \"summary.\" + error;\n                            }\n                        }\n                        if (message.metadata != null && message.hasOwnProperty(\"metadata\")) {\n                            if (!Array.isArray(message.metadata))\n                                return \"metadata: array expected\";\n                            for (var i = 0; i < message.metadata.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.metadata[i]);\n                                if (error)\n                                    return \"metadata.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric\n                     */\n                    Metric.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Metric)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Metric();\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        if (object.description != null)\n                            message.description = String(object.description);\n                        if (object.unit != null)\n                            message.unit = String(object.unit);\n                        if (object.gauge != null) {\n                            if (typeof object.gauge !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.gauge: object expected\");\n                            message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.fromObject(object.gauge);\n                        }\n                        if (object.sum != null) {\n                            if (typeof object.sum !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.sum: object expected\");\n                            message.sum = $root.opentelemetry.proto.metrics.v1.Sum.fromObject(object.sum);\n                        }\n                        if (object.histogram != null) {\n                            if (typeof object.histogram !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.histogram: object expected\");\n                            message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.fromObject(object.histogram);\n                        }\n                        if (object.exponentialHistogram != null) {\n                            if (typeof object.exponentialHistogram !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.exponentialHistogram: object expected\");\n                            message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.fromObject(object.exponentialHistogram);\n                        }\n                        if (object.summary != null) {\n                            if (typeof object.summary !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.summary: object expected\");\n                            message.summary = $root.opentelemetry.proto.metrics.v1.Summary.fromObject(object.summary);\n                        }\n                        if (object.metadata) {\n                            if (!Array.isArray(object.metadata))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.metadata: array expected\");\n                            message.metadata = [];\n                            for (var i = 0; i < object.metadata.length; ++i) {\n                                if (typeof object.metadata[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.metadata: object expected\");\n                                message.metadata[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.metadata[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Metric message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Metric} message Metric\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Metric.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.metadata = [];\n                        if (options.defaults) {\n                            object.name = \"\";\n                            object.description = \"\";\n                            object.unit = \"\";\n                        }\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.description != null && message.hasOwnProperty(\"description\"))\n                            object.description = message.description;\n                        if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                            object.unit = message.unit;\n                        if (message.gauge != null && message.hasOwnProperty(\"gauge\")) {\n                            object.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.toObject(message.gauge, options);\n                            if (options.oneofs)\n                                object.data = \"gauge\";\n                        }\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            object.sum = $root.opentelemetry.proto.metrics.v1.Sum.toObject(message.sum, options);\n                            if (options.oneofs)\n                                object.data = \"sum\";\n                        }\n                        if (message.histogram != null && message.hasOwnProperty(\"histogram\")) {\n                            object.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.toObject(message.histogram, options);\n                            if (options.oneofs)\n                                object.data = \"histogram\";\n                        }\n                        if (message.exponentialHistogram != null && message.hasOwnProperty(\"exponentialHistogram\")) {\n                            object.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.toObject(message.exponentialHistogram, options);\n                            if (options.oneofs)\n                                object.data = \"exponentialHistogram\";\n                        }\n                        if (message.summary != null && message.hasOwnProperty(\"summary\")) {\n                            object.summary = $root.opentelemetry.proto.metrics.v1.Summary.toObject(message.summary, options);\n                            if (options.oneofs)\n                                object.data = \"summary\";\n                        }\n                        if (message.metadata && message.metadata.length) {\n                            object.metadata = [];\n                            for (var j = 0; j < message.metadata.length; ++j)\n                                object.metadata[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.metadata[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Metric to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Metric.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Metric\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Metric\";\n                    };\n\n                    return Metric;\n                })();\n\n                v1.Gauge = (function() {\n\n                    /**\n                     * Properties of a Gauge.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IGauge\n                     * @property {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>|null} [dataPoints] Gauge dataPoints\n                     */\n\n                    /**\n                     * Constructs a new Gauge.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Gauge.\n                     * @implements IGauge\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IGauge=} [properties] Properties to set\n                     */\n                    function Gauge(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Gauge dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @instance\n                     */\n                    Gauge.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Creates a new Gauge instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IGauge=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge instance\n                     */\n                    Gauge.create = function create(properties) {\n                        return new Gauge(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Gauge message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Gauge.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IGauge} message Gauge message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Gauge.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Gauge message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Gauge.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IGauge} message Gauge message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Gauge.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Gauge message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Gauge.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Gauge();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Gauge message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Gauge.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Gauge message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Gauge.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Gauge message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge\n                     */\n                    Gauge.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Gauge)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Gauge();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Gauge.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Gauge.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Gauge message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Gauge} message Gauge\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Gauge.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Gauge to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Gauge.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Gauge\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Gauge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Gauge\";\n                    };\n\n                    return Gauge;\n                })();\n\n                v1.Sum = (function() {\n\n                    /**\n                     * Properties of a Sum.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface ISum\n                     * @property {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>|null} [dataPoints] Sum dataPoints\n                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] Sum aggregationTemporality\n                     * @property {boolean|null} [isMonotonic] Sum isMonotonic\n                     */\n\n                    /**\n                     * Constructs a new Sum.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Sum.\n                     * @implements ISum\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.ISum=} [properties] Properties to set\n                     */\n                    function Sum(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Sum dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     */\n                    Sum.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Sum aggregationTemporality.\n                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     */\n                    Sum.prototype.aggregationTemporality = null;\n\n                    /**\n                     * Sum isMonotonic.\n                     * @member {boolean|null|undefined} isMonotonic\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     */\n                    Sum.prototype.isMonotonic = null;\n\n                    /**\n                     * Creates a new Sum instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISum=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum instance\n                     */\n                    Sum.create = function create(properties) {\n                        return new Sum(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Sum message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Sum.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISum} message Sum message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Sum.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, \"aggregationTemporality\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationTemporality);\n                        if (message.isMonotonic != null && Object.hasOwnProperty.call(message, \"isMonotonic\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isMonotonic);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Sum message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Sum.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISum} message Sum message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Sum.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Sum message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Sum.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Sum();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.aggregationTemporality = reader.int32();\n                                    break;\n                                }\n                            case 3: {\n                                    message.isMonotonic = reader.bool();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Sum message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Sum.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Sum message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Sum.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            switch (message.aggregationTemporality) {\n                            default:\n                                return \"aggregationTemporality: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        if (message.isMonotonic != null && message.hasOwnProperty(\"isMonotonic\"))\n                            if (typeof message.isMonotonic !== \"boolean\")\n                                return \"isMonotonic: boolean expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Sum message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum\n                     */\n                    Sum.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Sum)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Sum();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Sum.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Sum.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        switch (object.aggregationTemporality) {\n                        default:\n                            if (typeof object.aggregationTemporality === \"number\") {\n                                message.aggregationTemporality = object.aggregationTemporality;\n                                break;\n                            }\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_UNSPECIFIED\":\n                        case 0:\n                            message.aggregationTemporality = 0;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_DELTA\":\n                        case 1:\n                            message.aggregationTemporality = 1;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_CUMULATIVE\":\n                        case 2:\n                            message.aggregationTemporality = 2;\n                            break;\n                        }\n                        if (object.isMonotonic != null)\n                            message.isMonotonic = Boolean(object.isMonotonic);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Sum message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Sum} message Sum\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Sum.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (options.defaults) {\n                            object.aggregationTemporality = options.enums === String ? \"AGGREGATION_TEMPORALITY_UNSPECIFIED\" : 0;\n                            object.isMonotonic = false;\n                        }\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;\n                        if (message.isMonotonic != null && message.hasOwnProperty(\"isMonotonic\"))\n                            object.isMonotonic = message.isMonotonic;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Sum to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Sum.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Sum\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Sum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Sum\";\n                    };\n\n                    return Sum;\n                })();\n\n                v1.Histogram = (function() {\n\n                    /**\n                     * Properties of a Histogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IHistogram\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IHistogramDataPoint>|null} [dataPoints] Histogram dataPoints\n                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] Histogram aggregationTemporality\n                     */\n\n                    /**\n                     * Constructs a new Histogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Histogram.\n                     * @implements IHistogram\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram=} [properties] Properties to set\n                     */\n                    function Histogram(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Histogram dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IHistogramDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @instance\n                     */\n                    Histogram.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Histogram aggregationTemporality.\n                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @instance\n                     */\n                    Histogram.prototype.aggregationTemporality = null;\n\n                    /**\n                     * Creates a new Histogram instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram instance\n                     */\n                    Histogram.create = function create(properties) {\n                        return new Histogram(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Histogram message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Histogram.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram} message Histogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Histogram.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, \"aggregationTemporality\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationTemporality);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Histogram message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Histogram.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram} message Histogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Histogram.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Histogram message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Histogram.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Histogram();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.HistogramDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.aggregationTemporality = reader.int32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Histogram message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Histogram.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Histogram message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Histogram.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            switch (message.aggregationTemporality) {\n                            default:\n                                return \"aggregationTemporality: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Histogram message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram\n                     */\n                    Histogram.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Histogram)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Histogram();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Histogram.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Histogram.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        switch (object.aggregationTemporality) {\n                        default:\n                            if (typeof object.aggregationTemporality === \"number\") {\n                                message.aggregationTemporality = object.aggregationTemporality;\n                                break;\n                            }\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_UNSPECIFIED\":\n                        case 0:\n                            message.aggregationTemporality = 0;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_DELTA\":\n                        case 1:\n                            message.aggregationTemporality = 1;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_CUMULATIVE\":\n                        case 2:\n                            message.aggregationTemporality = 2;\n                            break;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Histogram message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Histogram} message Histogram\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Histogram.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (options.defaults)\n                            object.aggregationTemporality = options.enums === String ? \"AGGREGATION_TEMPORALITY_UNSPECIFIED\" : 0;\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Histogram to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Histogram.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Histogram\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Histogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Histogram\";\n                    };\n\n                    return Histogram;\n                })();\n\n                v1.ExponentialHistogram = (function() {\n\n                    /**\n                     * Properties of an ExponentialHistogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IExponentialHistogram\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint>|null} [dataPoints] ExponentialHistogram dataPoints\n                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] ExponentialHistogram aggregationTemporality\n                     */\n\n                    /**\n                     * Constructs a new ExponentialHistogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents an ExponentialHistogram.\n                     * @implements IExponentialHistogram\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram=} [properties] Properties to set\n                     */\n                    function ExponentialHistogram(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ExponentialHistogram dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @instance\n                     */\n                    ExponentialHistogram.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * ExponentialHistogram aggregationTemporality.\n                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @instance\n                     */\n                    ExponentialHistogram.prototype.aggregationTemporality = null;\n\n                    /**\n                     * Creates a new ExponentialHistogram instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram instance\n                     */\n                    ExponentialHistogram.create = function create(properties) {\n                        return new ExponentialHistogram(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogram message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogram.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram} message ExponentialHistogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogram.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, \"aggregationTemporality\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationTemporality);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogram message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogram.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram} message ExponentialHistogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogram.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogram message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogram.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.aggregationTemporality = reader.int32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogram message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogram.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an ExponentialHistogram message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ExponentialHistogram.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            switch (message.aggregationTemporality) {\n                            default:\n                                return \"aggregationTemporality: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an ExponentialHistogram message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram\n                     */\n                    ExponentialHistogram.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogram)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        switch (object.aggregationTemporality) {\n                        default:\n                            if (typeof object.aggregationTemporality === \"number\") {\n                                message.aggregationTemporality = object.aggregationTemporality;\n                                break;\n                            }\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_UNSPECIFIED\":\n                        case 0:\n                            message.aggregationTemporality = 0;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_DELTA\":\n                        case 1:\n                            message.aggregationTemporality = 1;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_CUMULATIVE\":\n                        case 2:\n                            message.aggregationTemporality = 2;\n                            break;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an ExponentialHistogram message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ExponentialHistogram} message ExponentialHistogram\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ExponentialHistogram.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (options.defaults)\n                            object.aggregationTemporality = options.enums === String ? \"AGGREGATION_TEMPORALITY_UNSPECIFIED\" : 0;\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ExponentialHistogram to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ExponentialHistogram.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ExponentialHistogram\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ExponentialHistogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ExponentialHistogram\";\n                    };\n\n                    return ExponentialHistogram;\n                })();\n\n                v1.Summary = (function() {\n\n                    /**\n                     * Properties of a Summary.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface ISummary\n                     * @property {Array.<opentelemetry.proto.metrics.v1.ISummaryDataPoint>|null} [dataPoints] Summary dataPoints\n                     */\n\n                    /**\n                     * Constructs a new Summary.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Summary.\n                     * @implements ISummary\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.ISummary=} [properties] Properties to set\n                     */\n                    function Summary(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Summary dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.ISummaryDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @instance\n                     */\n                    Summary.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Creates a new Summary instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummary=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary instance\n                     */\n                    Summary.create = function create(properties) {\n                        return new Summary(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Summary message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Summary.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummary} message Summary message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Summary.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Summary message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Summary.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummary} message Summary message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Summary.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Summary message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Summary.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Summary();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Summary message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Summary.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Summary message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Summary.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Summary message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary\n                     */\n                    Summary.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Summary)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Summary();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Summary.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Summary.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Summary message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Summary} message Summary\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Summary.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Summary to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Summary.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Summary\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Summary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Summary\";\n                    };\n\n                    return Summary;\n                })();\n\n                /**\n                 * AggregationTemporality enum.\n                 * @name opentelemetry.proto.metrics.v1.AggregationTemporality\n                 * @enum {number}\n                 * @property {number} AGGREGATION_TEMPORALITY_UNSPECIFIED=0 AGGREGATION_TEMPORALITY_UNSPECIFIED value\n                 * @property {number} AGGREGATION_TEMPORALITY_DELTA=1 AGGREGATION_TEMPORALITY_DELTA value\n                 * @property {number} AGGREGATION_TEMPORALITY_CUMULATIVE=2 AGGREGATION_TEMPORALITY_CUMULATIVE value\n                 */\n                v1.AggregationTemporality = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"AGGREGATION_TEMPORALITY_UNSPECIFIED\"] = 0;\n                    values[valuesById[1] = \"AGGREGATION_TEMPORALITY_DELTA\"] = 1;\n                    values[valuesById[2] = \"AGGREGATION_TEMPORALITY_CUMULATIVE\"] = 2;\n                    return values;\n                })();\n\n                /**\n                 * DataPointFlags enum.\n                 * @name opentelemetry.proto.metrics.v1.DataPointFlags\n                 * @enum {number}\n                 * @property {number} DATA_POINT_FLAGS_DO_NOT_USE=0 DATA_POINT_FLAGS_DO_NOT_USE value\n                 * @property {number} DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK=1 DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK value\n                 */\n                v1.DataPointFlags = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"DATA_POINT_FLAGS_DO_NOT_USE\"] = 0;\n                    values[valuesById[1] = \"DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK\"] = 1;\n                    return values;\n                })();\n\n                v1.NumberDataPoint = (function() {\n\n                    /**\n                     * Properties of a NumberDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface INumberDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] NumberDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] NumberDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] NumberDataPoint timeUnixNano\n                     * @property {number|null} [asDouble] NumberDataPoint asDouble\n                     * @property {number|Long|null} [asInt] NumberDataPoint asInt\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] NumberDataPoint exemplars\n                     * @property {number|null} [flags] NumberDataPoint flags\n                     */\n\n                    /**\n                     * Constructs a new NumberDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a NumberDataPoint.\n                     * @implements INumberDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint=} [properties] Properties to set\n                     */\n                    function NumberDataPoint(properties) {\n                        this.attributes = [];\n                        this.exemplars = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * NumberDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * NumberDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * NumberDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * NumberDataPoint asDouble.\n                     * @member {number|null|undefined} asDouble\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.asDouble = null;\n\n                    /**\n                     * NumberDataPoint asInt.\n                     * @member {number|Long|null|undefined} asInt\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.asInt = null;\n\n                    /**\n                     * NumberDataPoint exemplars.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.exemplars = $util.emptyArray;\n\n                    /**\n                     * NumberDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.flags = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * NumberDataPoint value.\n                     * @member {\"asDouble\"|\"asInt\"|undefined} value\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(NumberDataPoint.prototype, \"value\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"asDouble\", \"asInt\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new NumberDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint instance\n                     */\n                    NumberDataPoint.create = function create(properties) {\n                        return new NumberDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified NumberDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.NumberDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint} message NumberDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NumberDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.asDouble != null && Object.hasOwnProperty.call(message, \"asDouble\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.asDouble);\n                        if (message.exemplars != null && message.exemplars.length)\n                            for (var i = 0; i < message.exemplars.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.asInt != null && Object.hasOwnProperty.call(message, \"asInt\"))\n                            writer.uint32(/* id 6, wireType 1 =*/49).sfixed64(message.asInt);\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified NumberDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.NumberDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint} message NumberDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NumberDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a NumberDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NumberDataPoint.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 7: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.asDouble = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    message.asInt = reader.sfixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    if (!(message.exemplars && message.exemplars.length))\n                                        message.exemplars = [];\n                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 8: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a NumberDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NumberDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a NumberDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    NumberDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            properties.value = 1;\n                            if (typeof message.asDouble !== \"number\")\n                                return \"asDouble: number expected\";\n                        }\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))\n                                return \"asInt: integer|Long expected\";\n                        }\n                        if (message.exemplars != null && message.hasOwnProperty(\"exemplars\")) {\n                            if (!Array.isArray(message.exemplars))\n                                return \"exemplars: array expected\";\n                            for (var i = 0; i < message.exemplars.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);\n                                if (error)\n                                    return \"exemplars.\" + error;\n                            }\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a NumberDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint\n                     */\n                    NumberDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.NumberDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.asDouble != null)\n                            message.asDouble = Number(object.asDouble);\n                        if (object.asInt != null)\n                            if ($util.Long)\n                                (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;\n                            else if (typeof object.asInt === \"string\")\n                                message.asInt = parseInt(object.asInt, 10);\n                            else if (typeof object.asInt === \"number\")\n                                message.asInt = object.asInt;\n                            else if (typeof object.asInt === \"object\")\n                                message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();\n                        if (object.exemplars) {\n                            if (!Array.isArray(object.exemplars))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: array expected\");\n                            message.exemplars = [];\n                            for (var i = 0; i < object.exemplars.length; ++i) {\n                                if (typeof object.exemplars[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: object expected\");\n                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);\n                            }\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a NumberDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.NumberDataPoint} message NumberDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    NumberDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.exemplars = [];\n                            object.attributes = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.flags = 0;\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;\n                            if (options.oneofs)\n                                object.value = \"asDouble\";\n                        }\n                        if (message.exemplars && message.exemplars.length) {\n                            object.exemplars = [];\n                            for (var j = 0; j < message.exemplars.length; ++j)\n                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);\n                        }\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (typeof message.asInt === \"number\")\n                                object.asInt = options.longs === String ? String(message.asInt) : message.asInt;\n                            else\n                                object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;\n                            if (options.oneofs)\n                                object.value = \"asInt\";\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this NumberDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    NumberDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for NumberDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    NumberDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.NumberDataPoint\";\n                    };\n\n                    return NumberDataPoint;\n                })();\n\n                v1.HistogramDataPoint = (function() {\n\n                    /**\n                     * Properties of a HistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IHistogramDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] HistogramDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] HistogramDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] HistogramDataPoint timeUnixNano\n                     * @property {number|Long|null} [count] HistogramDataPoint count\n                     * @property {number|null} [sum] HistogramDataPoint sum\n                     * @property {Array.<number|Long>|null} [bucketCounts] HistogramDataPoint bucketCounts\n                     * @property {Array.<number>|null} [explicitBounds] HistogramDataPoint explicitBounds\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] HistogramDataPoint exemplars\n                     * @property {number|null} [flags] HistogramDataPoint flags\n                     * @property {number|null} [min] HistogramDataPoint min\n                     * @property {number|null} [max] HistogramDataPoint max\n                     */\n\n                    /**\n                     * Constructs a new HistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a HistogramDataPoint.\n                     * @implements IHistogramDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint=} [properties] Properties to set\n                     */\n                    function HistogramDataPoint(properties) {\n                        this.attributes = [];\n                        this.bucketCounts = [];\n                        this.explicitBounds = [];\n                        this.exemplars = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * HistogramDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * HistogramDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * HistogramDataPoint count.\n                     * @member {number|Long|null|undefined} count\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.count = null;\n\n                    /**\n                     * HistogramDataPoint sum.\n                     * @member {number|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.sum = null;\n\n                    /**\n                     * HistogramDataPoint bucketCounts.\n                     * @member {Array.<number|Long>} bucketCounts\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.bucketCounts = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint explicitBounds.\n                     * @member {Array.<number>} explicitBounds\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.explicitBounds = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint exemplars.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.exemplars = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.flags = null;\n\n                    /**\n                     * HistogramDataPoint min.\n                     * @member {number|null|undefined} min\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.min = null;\n\n                    /**\n                     * HistogramDataPoint max.\n                     * @member {number|null|undefined} max\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.max = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * HistogramDataPoint _sum.\n                     * @member {\"sum\"|undefined} _sum\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(HistogramDataPoint.prototype, \"_sum\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"sum\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * HistogramDataPoint _min.\n                     * @member {\"min\"|undefined} _min\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(HistogramDataPoint.prototype, \"_min\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"min\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * HistogramDataPoint _max.\n                     * @member {\"max\"|undefined} _max\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(HistogramDataPoint.prototype, \"_max\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"max\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new HistogramDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint instance\n                     */\n                    HistogramDataPoint.create = function create(properties) {\n                        return new HistogramDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified HistogramDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.HistogramDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint} message HistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    HistogramDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.count);\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.sum);\n                        if (message.bucketCounts != null && message.bucketCounts.length) {\n                            writer.uint32(/* id 6, wireType 2 =*/50).fork();\n                            for (var i = 0; i < message.bucketCounts.length; ++i)\n                                writer.fixed64(message.bucketCounts[i]);\n                            writer.ldelim();\n                        }\n                        if (message.explicitBounds != null && message.explicitBounds.length) {\n                            writer.uint32(/* id 7, wireType 2 =*/58).fork();\n                            for (var i = 0; i < message.explicitBounds.length; ++i)\n                                writer.double(message.explicitBounds[i]);\n                            writer.ldelim();\n                        }\n                        if (message.exemplars != null && message.exemplars.length)\n                            for (var i = 0; i < message.exemplars.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags);\n                        if (message.min != null && Object.hasOwnProperty.call(message, \"min\"))\n                            writer.uint32(/* id 11, wireType 1 =*/89).double(message.min);\n                        if (message.max != null && Object.hasOwnProperty.call(message, \"max\"))\n                            writer.uint32(/* id 12, wireType 1 =*/97).double(message.max);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified HistogramDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.HistogramDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint} message HistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    HistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a HistogramDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    HistogramDataPoint.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 9: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.count = reader.fixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    message.sum = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    if (!(message.bucketCounts && message.bucketCounts.length))\n                                        message.bucketCounts = [];\n                                    if ((tag & 7) === 2) {\n                                        var end2 = reader.uint32() + reader.pos;\n                                        while (reader.pos < end2)\n                                            message.bucketCounts.push(reader.fixed64());\n                                    } else\n                                        message.bucketCounts.push(reader.fixed64());\n                                    break;\n                                }\n                            case 7: {\n                                    if (!(message.explicitBounds && message.explicitBounds.length))\n                                        message.explicitBounds = [];\n                                    if ((tag & 7) === 2) {\n                                        var end2 = reader.uint32() + reader.pos;\n                                        while (reader.pos < end2)\n                                            message.explicitBounds.push(reader.double());\n                                    } else\n                                        message.explicitBounds.push(reader.double());\n                                    break;\n                                }\n                            case 8: {\n                                    if (!(message.exemplars && message.exemplars.length))\n                                        message.exemplars = [];\n                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 10: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            case 11: {\n                                    message.min = reader.double();\n                                    break;\n                                }\n                            case 12: {\n                                    message.max = reader.double();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a HistogramDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    HistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a HistogramDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    HistogramDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                                return \"count: integer|Long expected\";\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            properties._sum = 1;\n                            if (typeof message.sum !== \"number\")\n                                return \"sum: number expected\";\n                        }\n                        if (message.bucketCounts != null && message.hasOwnProperty(\"bucketCounts\")) {\n                            if (!Array.isArray(message.bucketCounts))\n                                return \"bucketCounts: array expected\";\n                            for (var i = 0; i < message.bucketCounts.length; ++i)\n                                if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))\n                                    return \"bucketCounts: integer|Long[] expected\";\n                        }\n                        if (message.explicitBounds != null && message.hasOwnProperty(\"explicitBounds\")) {\n                            if (!Array.isArray(message.explicitBounds))\n                                return \"explicitBounds: array expected\";\n                            for (var i = 0; i < message.explicitBounds.length; ++i)\n                                if (typeof message.explicitBounds[i] !== \"number\")\n                                    return \"explicitBounds: number[] expected\";\n                        }\n                        if (message.exemplars != null && message.hasOwnProperty(\"exemplars\")) {\n                            if (!Array.isArray(message.exemplars))\n                                return \"exemplars: array expected\";\n                            for (var i = 0; i < message.exemplars.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);\n                                if (error)\n                                    return \"exemplars.\" + error;\n                            }\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            properties._min = 1;\n                            if (typeof message.min !== \"number\")\n                                return \"min: number expected\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            properties._max = 1;\n                            if (typeof message.max !== \"number\")\n                                return \"max: number expected\";\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a HistogramDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint\n                     */\n                    HistogramDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.HistogramDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.count != null)\n                            if ($util.Long)\n                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;\n                            else if (typeof object.count === \"string\")\n                                message.count = parseInt(object.count, 10);\n                            else if (typeof object.count === \"number\")\n                                message.count = object.count;\n                            else if (typeof object.count === \"object\")\n                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();\n                        if (object.sum != null)\n                            message.sum = Number(object.sum);\n                        if (object.bucketCounts) {\n                            if (!Array.isArray(object.bucketCounts))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.bucketCounts: array expected\");\n                            message.bucketCounts = [];\n                            for (var i = 0; i < object.bucketCounts.length; ++i)\n                                if ($util.Long)\n                                    (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = false;\n                                else if (typeof object.bucketCounts[i] === \"string\")\n                                    message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);\n                                else if (typeof object.bucketCounts[i] === \"number\")\n                                    message.bucketCounts[i] = object.bucketCounts[i];\n                                else if (typeof object.bucketCounts[i] === \"object\")\n                                    message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber();\n                        }\n                        if (object.explicitBounds) {\n                            if (!Array.isArray(object.explicitBounds))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.explicitBounds: array expected\");\n                            message.explicitBounds = [];\n                            for (var i = 0; i < object.explicitBounds.length; ++i)\n                                message.explicitBounds[i] = Number(object.explicitBounds[i]);\n                        }\n                        if (object.exemplars) {\n                            if (!Array.isArray(object.exemplars))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: array expected\");\n                            message.exemplars = [];\n                            for (var i = 0; i < object.exemplars.length; ++i) {\n                                if (typeof object.exemplars[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: object expected\");\n                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);\n                            }\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.min != null)\n                            message.min = Number(object.min);\n                        if (object.max != null)\n                            message.max = Number(object.max);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a HistogramDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.HistogramDataPoint} message HistogramDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    HistogramDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.bucketCounts = [];\n                            object.explicitBounds = [];\n                            object.exemplars = [];\n                            object.attributes = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.count = options.longs === String ? \"0\" : 0;\n                            object.flags = 0;\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (typeof message.count === \"number\")\n                                object.count = options.longs === String ? String(message.count) : message.count;\n                            else\n                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;\n                            if (options.oneofs)\n                                object._sum = \"sum\";\n                        }\n                        if (message.bucketCounts && message.bucketCounts.length) {\n                            object.bucketCounts = [];\n                            for (var j = 0; j < message.bucketCounts.length; ++j)\n                                if (typeof message.bucketCounts[j] === \"number\")\n                                    object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];\n                                else\n                                    object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber() : message.bucketCounts[j];\n                        }\n                        if (message.explicitBounds && message.explicitBounds.length) {\n                            object.explicitBounds = [];\n                            for (var j = 0; j < message.explicitBounds.length; ++j)\n                                object.explicitBounds[j] = options.json && !isFinite(message.explicitBounds[j]) ? String(message.explicitBounds[j]) : message.explicitBounds[j];\n                        }\n                        if (message.exemplars && message.exemplars.length) {\n                            object.exemplars = [];\n                            for (var j = 0; j < message.exemplars.length; ++j)\n                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;\n                            if (options.oneofs)\n                                object._min = \"min\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;\n                            if (options.oneofs)\n                                object._max = \"max\";\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this HistogramDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    HistogramDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for HistogramDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    HistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.HistogramDataPoint\";\n                    };\n\n                    return HistogramDataPoint;\n                })();\n\n                v1.ExponentialHistogramDataPoint = (function() {\n\n                    /**\n                     * Properties of an ExponentialHistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IExponentialHistogramDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] ExponentialHistogramDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] ExponentialHistogramDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] ExponentialHistogramDataPoint timeUnixNano\n                     * @property {number|Long|null} [count] ExponentialHistogramDataPoint count\n                     * @property {number|null} [sum] ExponentialHistogramDataPoint sum\n                     * @property {number|null} [scale] ExponentialHistogramDataPoint scale\n                     * @property {number|Long|null} [zeroCount] ExponentialHistogramDataPoint zeroCount\n                     * @property {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null} [positive] ExponentialHistogramDataPoint positive\n                     * @property {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null} [negative] ExponentialHistogramDataPoint negative\n                     * @property {number|null} [flags] ExponentialHistogramDataPoint flags\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] ExponentialHistogramDataPoint exemplars\n                     * @property {number|null} [min] ExponentialHistogramDataPoint min\n                     * @property {number|null} [max] ExponentialHistogramDataPoint max\n                     * @property {number|null} [zeroThreshold] ExponentialHistogramDataPoint zeroThreshold\n                     */\n\n                    /**\n                     * Constructs a new ExponentialHistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents an ExponentialHistogramDataPoint.\n                     * @implements IExponentialHistogramDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint=} [properties] Properties to set\n                     */\n                    function ExponentialHistogramDataPoint(properties) {\n                        this.attributes = [];\n                        this.exemplars = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ExponentialHistogramDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * ExponentialHistogramDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint count.\n                     * @member {number|Long|null|undefined} count\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.count = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint sum.\n                     * @member {number|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.sum = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint scale.\n                     * @member {number|null|undefined} scale\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.scale = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint zeroCount.\n                     * @member {number|Long|null|undefined} zeroCount\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.zeroCount = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint positive.\n                     * @member {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null|undefined} positive\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.positive = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint negative.\n                     * @member {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null|undefined} negative\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.negative = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.flags = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint exemplars.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.exemplars = $util.emptyArray;\n\n                    /**\n                     * ExponentialHistogramDataPoint min.\n                     * @member {number|null|undefined} min\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.min = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint max.\n                     * @member {number|null|undefined} max\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.max = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint zeroThreshold.\n                     * @member {number|null|undefined} zeroThreshold\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.zeroThreshold = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * ExponentialHistogramDataPoint _sum.\n                     * @member {\"sum\"|undefined} _sum\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, \"_sum\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"sum\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * ExponentialHistogramDataPoint _min.\n                     * @member {\"min\"|undefined} _min\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, \"_min\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"min\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * ExponentialHistogramDataPoint _max.\n                     * @member {\"max\"|undefined} _max\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, \"_max\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"max\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new ExponentialHistogramDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint instance\n                     */\n                    ExponentialHistogramDataPoint.create = function create(properties) {\n                        return new ExponentialHistogramDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogramDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint} message ExponentialHistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogramDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.count);\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.sum);\n                        if (message.scale != null && Object.hasOwnProperty.call(message, \"scale\"))\n                            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.scale);\n                        if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\"))\n                            writer.uint32(/* id 7, wireType 1 =*/57).fixed64(message.zeroCount);\n                        if (message.positive != null && Object.hasOwnProperty.call(message, \"positive\"))\n                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.positive, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                        if (message.negative != null && Object.hasOwnProperty.call(message, \"negative\"))\n                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.negative, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags);\n                        if (message.exemplars != null && message.exemplars.length)\n                            for (var i = 0; i < message.exemplars.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                        if (message.min != null && Object.hasOwnProperty.call(message, \"min\"))\n                            writer.uint32(/* id 12, wireType 1 =*/97).double(message.min);\n                        if (message.max != null && Object.hasOwnProperty.call(message, \"max\"))\n                            writer.uint32(/* id 13, wireType 1 =*/105).double(message.max);\n                        if (message.zeroThreshold != null && Object.hasOwnProperty.call(message, \"zeroThreshold\"))\n                            writer.uint32(/* id 14, wireType 1 =*/113).double(message.zeroThreshold);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogramDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint} message ExponentialHistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogramDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogramDataPoint.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.count = reader.fixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    message.sum = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    message.scale = reader.sint32();\n                                    break;\n                                }\n                            case 7: {\n                                    message.zeroCount = reader.fixed64();\n                                    break;\n                                }\n                            case 8: {\n                                    message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 9: {\n                                    message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 10: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            case 11: {\n                                    if (!(message.exemplars && message.exemplars.length))\n                                        message.exemplars = [];\n                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 12: {\n                                    message.min = reader.double();\n                                    break;\n                                }\n                            case 13: {\n                                    message.max = reader.double();\n                                    break;\n                                }\n                            case 14: {\n                                    message.zeroThreshold = reader.double();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogramDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an ExponentialHistogramDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ExponentialHistogramDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                                return \"count: integer|Long expected\";\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            properties._sum = 1;\n                            if (typeof message.sum !== \"number\")\n                                return \"sum: number expected\";\n                        }\n                        if (message.scale != null && message.hasOwnProperty(\"scale\"))\n                            if (!$util.isInteger(message.scale))\n                                return \"scale: integer expected\";\n                        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n                            if (!$util.isInteger(message.zeroCount) && !(message.zeroCount && $util.isInteger(message.zeroCount.low) && $util.isInteger(message.zeroCount.high)))\n                                return \"zeroCount: integer|Long expected\";\n                        if (message.positive != null && message.hasOwnProperty(\"positive\")) {\n                            var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.positive);\n                            if (error)\n                                return \"positive.\" + error;\n                        }\n                        if (message.negative != null && message.hasOwnProperty(\"negative\")) {\n                            var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.negative);\n                            if (error)\n                                return \"negative.\" + error;\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.exemplars != null && message.hasOwnProperty(\"exemplars\")) {\n                            if (!Array.isArray(message.exemplars))\n                                return \"exemplars: array expected\";\n                            for (var i = 0; i < message.exemplars.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);\n                                if (error)\n                                    return \"exemplars.\" + error;\n                            }\n                        }\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            properties._min = 1;\n                            if (typeof message.min !== \"number\")\n                                return \"min: number expected\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            properties._max = 1;\n                            if (typeof message.max !== \"number\")\n                                return \"max: number expected\";\n                        }\n                        if (message.zeroThreshold != null && message.hasOwnProperty(\"zeroThreshold\"))\n                            if (typeof message.zeroThreshold !== \"number\")\n                                return \"zeroThreshold: number expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates an ExponentialHistogramDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint\n                     */\n                    ExponentialHistogramDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.count != null)\n                            if ($util.Long)\n                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;\n                            else if (typeof object.count === \"string\")\n                                message.count = parseInt(object.count, 10);\n                            else if (typeof object.count === \"number\")\n                                message.count = object.count;\n                            else if (typeof object.count === \"object\")\n                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();\n                        if (object.sum != null)\n                            message.sum = Number(object.sum);\n                        if (object.scale != null)\n                            message.scale = object.scale | 0;\n                        if (object.zeroCount != null)\n                            if ($util.Long)\n                                (message.zeroCount = $util.Long.fromValue(object.zeroCount)).unsigned = false;\n                            else if (typeof object.zeroCount === \"string\")\n                                message.zeroCount = parseInt(object.zeroCount, 10);\n                            else if (typeof object.zeroCount === \"number\")\n                                message.zeroCount = object.zeroCount;\n                            else if (typeof object.zeroCount === \"object\")\n                                message.zeroCount = new $util.LongBits(object.zeroCount.low >>> 0, object.zeroCount.high >>> 0).toNumber();\n                        if (object.positive != null) {\n                            if (typeof object.positive !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.positive: object expected\");\n                            message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.positive);\n                        }\n                        if (object.negative != null) {\n                            if (typeof object.negative !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.negative: object expected\");\n                            message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.negative);\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.exemplars) {\n                            if (!Array.isArray(object.exemplars))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: array expected\");\n                            message.exemplars = [];\n                            for (var i = 0; i < object.exemplars.length; ++i) {\n                                if (typeof object.exemplars[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: object expected\");\n                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);\n                            }\n                        }\n                        if (object.min != null)\n                            message.min = Number(object.min);\n                        if (object.max != null)\n                            message.max = Number(object.max);\n                        if (object.zeroThreshold != null)\n                            message.zeroThreshold = Number(object.zeroThreshold);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an ExponentialHistogramDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} message ExponentialHistogramDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ExponentialHistogramDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.attributes = [];\n                            object.exemplars = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.count = options.longs === String ? \"0\" : 0;\n                            object.scale = 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.zeroCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.zeroCount = options.longs === String ? \"0\" : 0;\n                            object.positive = null;\n                            object.negative = null;\n                            object.flags = 0;\n                            object.zeroThreshold = 0;\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (typeof message.count === \"number\")\n                                object.count = options.longs === String ? String(message.count) : message.count;\n                            else\n                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;\n                            if (options.oneofs)\n                                object._sum = \"sum\";\n                        }\n                        if (message.scale != null && message.hasOwnProperty(\"scale\"))\n                            object.scale = message.scale;\n                        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n                            if (typeof message.zeroCount === \"number\")\n                                object.zeroCount = options.longs === String ? String(message.zeroCount) : message.zeroCount;\n                            else\n                                object.zeroCount = options.longs === String ? $util.Long.prototype.toString.call(message.zeroCount) : options.longs === Number ? new $util.LongBits(message.zeroCount.low >>> 0, message.zeroCount.high >>> 0).toNumber() : message.zeroCount;\n                        if (message.positive != null && message.hasOwnProperty(\"positive\"))\n                            object.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.positive, options);\n                        if (message.negative != null && message.hasOwnProperty(\"negative\"))\n                            object.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.negative, options);\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        if (message.exemplars && message.exemplars.length) {\n                            object.exemplars = [];\n                            for (var j = 0; j < message.exemplars.length; ++j)\n                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);\n                        }\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;\n                            if (options.oneofs)\n                                object._min = \"min\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;\n                            if (options.oneofs)\n                                object._max = \"max\";\n                        }\n                        if (message.zeroThreshold != null && message.hasOwnProperty(\"zeroThreshold\"))\n                            object.zeroThreshold = options.json && !isFinite(message.zeroThreshold) ? String(message.zeroThreshold) : message.zeroThreshold;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ExponentialHistogramDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ExponentialHistogramDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ExponentialHistogramDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ExponentialHistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\";\n                    };\n\n                    ExponentialHistogramDataPoint.Buckets = (function() {\n\n                        /**\n                         * Properties of a Buckets.\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                         * @interface IBuckets\n                         * @property {number|null} [offset] Buckets offset\n                         * @property {Array.<number|Long>|null} [bucketCounts] Buckets bucketCounts\n                         */\n\n                        /**\n                         * Constructs a new Buckets.\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                         * @classdesc Represents a Buckets.\n                         * @implements IBuckets\n                         * @constructor\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets=} [properties] Properties to set\n                         */\n                        function Buckets(properties) {\n                            this.bucketCounts = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * Buckets offset.\n                         * @member {number|null|undefined} offset\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @instance\n                         */\n                        Buckets.prototype.offset = null;\n\n                        /**\n                         * Buckets bucketCounts.\n                         * @member {Array.<number|Long>} bucketCounts\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @instance\n                         */\n                        Buckets.prototype.bucketCounts = $util.emptyArray;\n\n                        /**\n                         * Creates a new Buckets instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets instance\n                         */\n                        Buckets.create = function create(properties) {\n                            return new Buckets(properties);\n                        };\n\n                        /**\n                         * Encodes the specified Buckets message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets} message Buckets message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Buckets.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.offset);\n                            if (message.bucketCounts != null && message.bucketCounts.length) {\n                                writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                                for (var i = 0; i < message.bucketCounts.length; ++i)\n                                    writer.uint64(message.bucketCounts[i]);\n                                writer.ldelim();\n                            }\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified Buckets message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets} message Buckets message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Buckets.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes a Buckets message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Buckets.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.offset = reader.sint32();\n                                        break;\n                                    }\n                                case 2: {\n                                        if (!(message.bucketCounts && message.bucketCounts.length))\n                                            message.bucketCounts = [];\n                                        if ((tag & 7) === 2) {\n                                            var end2 = reader.uint32() + reader.pos;\n                                            while (reader.pos < end2)\n                                                message.bucketCounts.push(reader.uint64());\n                                        } else\n                                            message.bucketCounts.push(reader.uint64());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes a Buckets message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Buckets.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies a Buckets message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        Buckets.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                                if (!$util.isInteger(message.offset))\n                                    return \"offset: integer expected\";\n                            if (message.bucketCounts != null && message.hasOwnProperty(\"bucketCounts\")) {\n                                if (!Array.isArray(message.bucketCounts))\n                                    return \"bucketCounts: array expected\";\n                                for (var i = 0; i < message.bucketCounts.length; ++i)\n                                    if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))\n                                        return \"bucketCounts: integer|Long[] expected\";\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates a Buckets message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets\n                         */\n                        Buckets.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets)\n                                return object;\n                            var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();\n                            if (object.offset != null)\n                                message.offset = object.offset | 0;\n                            if (object.bucketCounts) {\n                                if (!Array.isArray(object.bucketCounts))\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucketCounts: array expected\");\n                                message.bucketCounts = [];\n                                for (var i = 0; i < object.bucketCounts.length; ++i)\n                                    if ($util.Long)\n                                        (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = true;\n                                    else if (typeof object.bucketCounts[i] === \"string\")\n                                        message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);\n                                    else if (typeof object.bucketCounts[i] === \"number\")\n                                        message.bucketCounts[i] = object.bucketCounts[i];\n                                    else if (typeof object.bucketCounts[i] === \"object\")\n                                        message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber(true);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from a Buckets message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} message Buckets\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        Buckets.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.bucketCounts = [];\n                            if (options.defaults)\n                                object.offset = 0;\n                            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                                object.offset = message.offset;\n                            if (message.bucketCounts && message.bucketCounts.length) {\n                                object.bucketCounts = [];\n                                for (var j = 0; j < message.bucketCounts.length; ++j)\n                                    if (typeof message.bucketCounts[j] === \"number\")\n                                        object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];\n                                    else\n                                        object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber(true) : message.bucketCounts[j];\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this Buckets to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        Buckets.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for Buckets\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        Buckets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\";\n                        };\n\n                        return Buckets;\n                    })();\n\n                    return ExponentialHistogramDataPoint;\n                })();\n\n                v1.SummaryDataPoint = (function() {\n\n                    /**\n                     * Properties of a SummaryDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface ISummaryDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] SummaryDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] SummaryDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] SummaryDataPoint timeUnixNano\n                     * @property {number|Long|null} [count] SummaryDataPoint count\n                     * @property {number|null} [sum] SummaryDataPoint sum\n                     * @property {Array.<opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile>|null} [quantileValues] SummaryDataPoint quantileValues\n                     * @property {number|null} [flags] SummaryDataPoint flags\n                     */\n\n                    /**\n                     * Constructs a new SummaryDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a SummaryDataPoint.\n                     * @implements ISummaryDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint=} [properties] Properties to set\n                     */\n                    function SummaryDataPoint(properties) {\n                        this.attributes = [];\n                        this.quantileValues = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * SummaryDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * SummaryDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * SummaryDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * SummaryDataPoint count.\n                     * @member {number|Long|null|undefined} count\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.count = null;\n\n                    /**\n                     * SummaryDataPoint sum.\n                     * @member {number|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.sum = null;\n\n                    /**\n                     * SummaryDataPoint quantileValues.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile>} quantileValues\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.quantileValues = $util.emptyArray;\n\n                    /**\n                     * SummaryDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.flags = null;\n\n                    /**\n                     * Creates a new SummaryDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint instance\n                     */\n                    SummaryDataPoint.create = function create(properties) {\n                        return new SummaryDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified SummaryDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint} message SummaryDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SummaryDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.count);\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.sum);\n                        if (message.quantileValues != null && message.quantileValues.length)\n                            for (var i = 0; i < message.quantileValues.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.encode(message.quantileValues[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified SummaryDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint} message SummaryDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SummaryDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a SummaryDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SummaryDataPoint.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 7: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.count = reader.fixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    message.sum = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    if (!(message.quantileValues && message.quantileValues.length))\n                                        message.quantileValues = [];\n                                    message.quantileValues.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 8: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a SummaryDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SummaryDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a SummaryDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    SummaryDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                                return \"count: integer|Long expected\";\n                        if (message.sum != null && message.hasOwnProperty(\"sum\"))\n                            if (typeof message.sum !== \"number\")\n                                return \"sum: number expected\";\n                        if (message.quantileValues != null && message.hasOwnProperty(\"quantileValues\")) {\n                            if (!Array.isArray(message.quantileValues))\n                                return \"quantileValues: array expected\";\n                            for (var i = 0; i < message.quantileValues.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify(message.quantileValues[i]);\n                                if (error)\n                                    return \"quantileValues.\" + error;\n                            }\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a SummaryDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint\n                     */\n                    SummaryDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.count != null)\n                            if ($util.Long)\n                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;\n                            else if (typeof object.count === \"string\")\n                                message.count = parseInt(object.count, 10);\n                            else if (typeof object.count === \"number\")\n                                message.count = object.count;\n                            else if (typeof object.count === \"object\")\n                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();\n                        if (object.sum != null)\n                            message.sum = Number(object.sum);\n                        if (object.quantileValues) {\n                            if (!Array.isArray(object.quantileValues))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: array expected\");\n                            message.quantileValues = [];\n                            for (var i = 0; i < object.quantileValues.length; ++i) {\n                                if (typeof object.quantileValues[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: object expected\");\n                                message.quantileValues[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.fromObject(object.quantileValues[i]);\n                            }\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a SummaryDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint} message SummaryDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    SummaryDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.quantileValues = [];\n                            object.attributes = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.count = options.longs === String ? \"0\" : 0;\n                            object.sum = 0;\n                            object.flags = 0;\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (typeof message.count === \"number\")\n                                object.count = options.longs === String ? String(message.count) : message.count;\n                            else\n                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;\n                        if (message.sum != null && message.hasOwnProperty(\"sum\"))\n                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;\n                        if (message.quantileValues && message.quantileValues.length) {\n                            object.quantileValues = [];\n                            for (var j = 0; j < message.quantileValues.length; ++j)\n                                object.quantileValues[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.toObject(message.quantileValues[j], options);\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this SummaryDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    SummaryDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for SummaryDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    SummaryDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.SummaryDataPoint\";\n                    };\n\n                    SummaryDataPoint.ValueAtQuantile = (function() {\n\n                        /**\n                         * Properties of a ValueAtQuantile.\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                         * @interface IValueAtQuantile\n                         * @property {number|null} [quantile] ValueAtQuantile quantile\n                         * @property {number|null} [value] ValueAtQuantile value\n                         */\n\n                        /**\n                         * Constructs a new ValueAtQuantile.\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                         * @classdesc Represents a ValueAtQuantile.\n                         * @implements IValueAtQuantile\n                         * @constructor\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile=} [properties] Properties to set\n                         */\n                        function ValueAtQuantile(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ValueAtQuantile quantile.\n                         * @member {number|null|undefined} quantile\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @instance\n                         */\n                        ValueAtQuantile.prototype.quantile = null;\n\n                        /**\n                         * ValueAtQuantile value.\n                         * @member {number|null|undefined} value\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @instance\n                         */\n                        ValueAtQuantile.prototype.value = null;\n\n                        /**\n                         * Creates a new ValueAtQuantile instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile instance\n                         */\n                        ValueAtQuantile.create = function create(properties) {\n                            return new ValueAtQuantile(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ValueAtQuantile message. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile} message ValueAtQuantile message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ValueAtQuantile.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.quantile != null && Object.hasOwnProperty.call(message, \"quantile\"))\n                                writer.uint32(/* id 1, wireType 1 =*/9).double(message.quantile);\n                            if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n                                writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ValueAtQuantile message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile} message ValueAtQuantile message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ValueAtQuantile.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes a ValueAtQuantile message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ValueAtQuantile.decode = function decode(reader, length, error) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                if (tag === error)\n                                    break;\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.quantile = reader.double();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.value = reader.double();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes a ValueAtQuantile message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ValueAtQuantile.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies a ValueAtQuantile message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ValueAtQuantile.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.quantile != null && message.hasOwnProperty(\"quantile\"))\n                                if (typeof message.quantile !== \"number\")\n                                    return \"quantile: number expected\";\n                            if (message.value != null && message.hasOwnProperty(\"value\"))\n                                if (typeof message.value !== \"number\")\n                                    return \"value: number expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates a ValueAtQuantile message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile\n                         */\n                        ValueAtQuantile.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile)\n                                return object;\n                            var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();\n                            if (object.quantile != null)\n                                message.quantile = Number(object.quantile);\n                            if (object.value != null)\n                                message.value = Number(object.value);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from a ValueAtQuantile message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} message ValueAtQuantile\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ValueAtQuantile.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                object.quantile = 0;\n                                object.value = 0;\n                            }\n                            if (message.quantile != null && message.hasOwnProperty(\"quantile\"))\n                                object.quantile = options.json && !isFinite(message.quantile) ? String(message.quantile) : message.quantile;\n                            if (message.value != null && message.hasOwnProperty(\"value\"))\n                                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ValueAtQuantile to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ValueAtQuantile.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ValueAtQuantile\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ValueAtQuantile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\";\n                        };\n\n                        return ValueAtQuantile;\n                    })();\n\n                    return SummaryDataPoint;\n                })();\n\n                v1.Exemplar = (function() {\n\n                    /**\n                     * Properties of an Exemplar.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IExemplar\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [filteredAttributes] Exemplar filteredAttributes\n                     * @property {number|Long|null} [timeUnixNano] Exemplar timeUnixNano\n                     * @property {number|null} [asDouble] Exemplar asDouble\n                     * @property {number|Long|null} [asInt] Exemplar asInt\n                     * @property {Uint8Array|null} [spanId] Exemplar spanId\n                     * @property {Uint8Array|null} [traceId] Exemplar traceId\n                     */\n\n                    /**\n                     * Constructs a new Exemplar.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents an Exemplar.\n                     * @implements IExemplar\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar=} [properties] Properties to set\n                     */\n                    function Exemplar(properties) {\n                        this.filteredAttributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Exemplar filteredAttributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} filteredAttributes\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.filteredAttributes = $util.emptyArray;\n\n                    /**\n                     * Exemplar timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.timeUnixNano = null;\n\n                    /**\n                     * Exemplar asDouble.\n                     * @member {number|null|undefined} asDouble\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.asDouble = null;\n\n                    /**\n                     * Exemplar asInt.\n                     * @member {number|Long|null|undefined} asInt\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.asInt = null;\n\n                    /**\n                     * Exemplar spanId.\n                     * @member {Uint8Array|null|undefined} spanId\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.spanId = null;\n\n                    /**\n                     * Exemplar traceId.\n                     * @member {Uint8Array|null|undefined} traceId\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.traceId = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * Exemplar value.\n                     * @member {\"asDouble\"|\"asInt\"|undefined} value\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Object.defineProperty(Exemplar.prototype, \"value\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"asDouble\", \"asInt\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new Exemplar instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar instance\n                     */\n                    Exemplar.create = function create(properties) {\n                        return new Exemplar(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Exemplar message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Exemplar.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar} message Exemplar message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Exemplar.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.timeUnixNano);\n                        if (message.asDouble != null && Object.hasOwnProperty.call(message, \"asDouble\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.asDouble);\n                        if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.spanId);\n                        if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.traceId);\n                        if (message.asInt != null && Object.hasOwnProperty.call(message, \"asInt\"))\n                            writer.uint32(/* id 6, wireType 1 =*/49).sfixed64(message.asInt);\n                        if (message.filteredAttributes != null && message.filteredAttributes.length)\n                            for (var i = 0; i < message.filteredAttributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.filteredAttributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Exemplar message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Exemplar.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar} message Exemplar message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Exemplar.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an Exemplar message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Exemplar.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Exemplar();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 7: {\n                                    if (!(message.filteredAttributes && message.filteredAttributes.length))\n                                        message.filteredAttributes = [];\n                                    message.filteredAttributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.asDouble = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    message.asInt = reader.sfixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.spanId = reader.bytes();\n                                    break;\n                                }\n                            case 5: {\n                                    message.traceId = reader.bytes();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an Exemplar message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Exemplar.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an Exemplar message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Exemplar.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.filteredAttributes != null && message.hasOwnProperty(\"filteredAttributes\")) {\n                            if (!Array.isArray(message.filteredAttributes))\n                                return \"filteredAttributes: array expected\";\n                            for (var i = 0; i < message.filteredAttributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.filteredAttributes[i]);\n                                if (error)\n                                    return \"filteredAttributes.\" + error;\n                            }\n                        }\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            properties.value = 1;\n                            if (typeof message.asDouble !== \"number\")\n                                return \"asDouble: number expected\";\n                        }\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))\n                                return \"asInt: integer|Long expected\";\n                        }\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                return \"spanId: buffer expected\";\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                return \"traceId: buffer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates an Exemplar message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar\n                     */\n                    Exemplar.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Exemplar)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Exemplar();\n                        if (object.filteredAttributes) {\n                            if (!Array.isArray(object.filteredAttributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: array expected\");\n                            message.filteredAttributes = [];\n                            for (var i = 0; i < object.filteredAttributes.length; ++i) {\n                                if (typeof object.filteredAttributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: object expected\");\n                                message.filteredAttributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.filteredAttributes[i]);\n                            }\n                        }\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.asDouble != null)\n                            message.asDouble = Number(object.asDouble);\n                        if (object.asInt != null)\n                            if ($util.Long)\n                                (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;\n                            else if (typeof object.asInt === \"string\")\n                                message.asInt = parseInt(object.asInt, 10);\n                            else if (typeof object.asInt === \"number\")\n                                message.asInt = object.asInt;\n                            else if (typeof object.asInt === \"object\")\n                                message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();\n                        if (object.spanId != null)\n                            if (typeof object.spanId === \"string\")\n                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                            else if (object.spanId.length >= 0)\n                                message.spanId = object.spanId;\n                        if (object.traceId != null)\n                            if (typeof object.traceId === \"string\")\n                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                            else if (object.traceId.length >= 0)\n                                message.traceId = object.traceId;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an Exemplar message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Exemplar} message Exemplar\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Exemplar.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.filteredAttributes = [];\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if (options.bytes === String)\n                                object.spanId = \"\";\n                            else {\n                                object.spanId = [];\n                                if (options.bytes !== Array)\n                                    object.spanId = $util.newBuffer(object.spanId);\n                            }\n                            if (options.bytes === String)\n                                object.traceId = \"\";\n                            else {\n                                object.traceId = [];\n                                if (options.bytes !== Array)\n                                    object.traceId = $util.newBuffer(object.traceId);\n                            }\n                        }\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;\n                            if (options.oneofs)\n                                object.value = \"asDouble\";\n                        }\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (typeof message.asInt === \"number\")\n                                object.asInt = options.longs === String ? String(message.asInt) : message.asInt;\n                            else\n                                object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;\n                            if (options.oneofs)\n                                object.value = \"asInt\";\n                        }\n                        if (message.filteredAttributes && message.filteredAttributes.length) {\n                            object.filteredAttributes = [];\n                            for (var j = 0; j < message.filteredAttributes.length; ++j)\n                                object.filteredAttributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.filteredAttributes[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Exemplar to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Exemplar.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Exemplar\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Exemplar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Exemplar\";\n                    };\n\n                    return Exemplar;\n                })();\n\n                return v1;\n            })();\n\n            return metrics;\n        })();\n\n        proto.logs = (function() {\n\n            /**\n             * Namespace logs.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var logs = {};\n\n            logs.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.logs\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.LogsData = (function() {\n\n                    /**\n                     * Properties of a LogsData.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface ILogsData\n                     * @property {Array.<opentelemetry.proto.logs.v1.IResourceLogs>|null} [resourceLogs] LogsData resourceLogs\n                     */\n\n                    /**\n                     * Constructs a new LogsData.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a LogsData.\n                     * @implements ILogsData\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.ILogsData=} [properties] Properties to set\n                     */\n                    function LogsData(properties) {\n                        this.resourceLogs = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * LogsData resourceLogs.\n                     * @member {Array.<opentelemetry.proto.logs.v1.IResourceLogs>} resourceLogs\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @instance\n                     */\n                    LogsData.prototype.resourceLogs = $util.emptyArray;\n\n                    /**\n                     * Creates a new LogsData instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogsData=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData instance\n                     */\n                    LogsData.create = function create(properties) {\n                        return new LogsData(properties);\n                    };\n\n                    /**\n                     * Encodes the specified LogsData message. Does not implicitly {@link opentelemetry.proto.logs.v1.LogsData.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogsData} message LogsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogsData.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resourceLogs != null && message.resourceLogs.length)\n                            for (var i = 0; i < message.resourceLogs.length; ++i)\n                                $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified LogsData message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.LogsData.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogsData} message LogsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogsData.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a LogsData message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogsData.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogsData();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.resourceLogs && message.resourceLogs.length))\n                                        message.resourceLogs = [];\n                                    message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a LogsData message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogsData.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a LogsData message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    LogsData.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resourceLogs != null && message.hasOwnProperty(\"resourceLogs\")) {\n                            if (!Array.isArray(message.resourceLogs))\n                                return \"resourceLogs: array expected\";\n                            for (var i = 0; i < message.resourceLogs.length; ++i) {\n                                var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);\n                                if (error)\n                                    return \"resourceLogs.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a LogsData message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData\n                     */\n                    LogsData.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.LogsData)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.LogsData();\n                        if (object.resourceLogs) {\n                            if (!Array.isArray(object.resourceLogs))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.LogsData.resourceLogs: array expected\");\n                            message.resourceLogs = [];\n                            for (var i = 0; i < object.resourceLogs.length; ++i) {\n                                if (typeof object.resourceLogs[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.LogsData.resourceLogs: object expected\");\n                                message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a LogsData message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.LogsData} message LogsData\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    LogsData.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.resourceLogs = [];\n                        if (message.resourceLogs && message.resourceLogs.length) {\n                            object.resourceLogs = [];\n                            for (var j = 0; j < message.resourceLogs.length; ++j)\n                                object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this LogsData to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    LogsData.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for LogsData\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    LogsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.LogsData\";\n                    };\n\n                    return LogsData;\n                })();\n\n                v1.ResourceLogs = (function() {\n\n                    /**\n                     * Properties of a ResourceLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface IResourceLogs\n                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceLogs resource\n                     * @property {Array.<opentelemetry.proto.logs.v1.IScopeLogs>|null} [scopeLogs] ResourceLogs scopeLogs\n                     * @property {string|null} [schemaUrl] ResourceLogs schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ResourceLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a ResourceLogs.\n                     * @implements IResourceLogs\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs=} [properties] Properties to set\n                     */\n                    function ResourceLogs(properties) {\n                        this.scopeLogs = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ResourceLogs resource.\n                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     */\n                    ResourceLogs.prototype.resource = null;\n\n                    /**\n                     * ResourceLogs scopeLogs.\n                     * @member {Array.<opentelemetry.proto.logs.v1.IScopeLogs>} scopeLogs\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     */\n                    ResourceLogs.prototype.scopeLogs = $util.emptyArray;\n\n                    /**\n                     * ResourceLogs schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     */\n                    ResourceLogs.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ResourceLogs instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs instance\n                     */\n                    ResourceLogs.create = function create(properties) {\n                        return new ResourceLogs(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ResourceLogs message. Does not implicitly {@link opentelemetry.proto.logs.v1.ResourceLogs.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs} message ResourceLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceLogs.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resource != null && Object.hasOwnProperty.call(message, \"resource\"))\n                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.scopeLogs != null && message.scopeLogs.length)\n                            for (var i = 0; i < message.scopeLogs.length; ++i)\n                                $root.opentelemetry.proto.logs.v1.ScopeLogs.encode(message.scopeLogs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ResourceLogs message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.ResourceLogs.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs} message ResourceLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceLogs.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ResourceLogs message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceLogs.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.scopeLogs && message.scopeLogs.length))\n                                        message.scopeLogs = [];\n                                    message.scopeLogs.push($root.opentelemetry.proto.logs.v1.ScopeLogs.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ResourceLogs message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceLogs.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ResourceLogs message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ResourceLogs.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resource != null && message.hasOwnProperty(\"resource\")) {\n                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);\n                            if (error)\n                                return \"resource.\" + error;\n                        }\n                        if (message.scopeLogs != null && message.hasOwnProperty(\"scopeLogs\")) {\n                            if (!Array.isArray(message.scopeLogs))\n                                return \"scopeLogs: array expected\";\n                            for (var i = 0; i < message.scopeLogs.length; ++i) {\n                                var error = $root.opentelemetry.proto.logs.v1.ScopeLogs.verify(message.scopeLogs[i]);\n                                if (error)\n                                    return \"scopeLogs.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ResourceLogs message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs\n                     */\n                    ResourceLogs.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.ResourceLogs)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();\n                        if (object.resource != null) {\n                            if (typeof object.resource !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ResourceLogs.resource: object expected\");\n                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);\n                        }\n                        if (object.scopeLogs) {\n                            if (!Array.isArray(object.scopeLogs))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: array expected\");\n                            message.scopeLogs = [];\n                            for (var i = 0; i < object.scopeLogs.length; ++i) {\n                                if (typeof object.scopeLogs[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: object expected\");\n                                message.scopeLogs[i] = $root.opentelemetry.proto.logs.v1.ScopeLogs.fromObject(object.scopeLogs[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ResourceLogs message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ResourceLogs} message ResourceLogs\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ResourceLogs.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.scopeLogs = [];\n                        if (options.defaults) {\n                            object.resource = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.resource != null && message.hasOwnProperty(\"resource\"))\n                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);\n                        if (message.scopeLogs && message.scopeLogs.length) {\n                            object.scopeLogs = [];\n                            for (var j = 0; j < message.scopeLogs.length; ++j)\n                                object.scopeLogs[j] = $root.opentelemetry.proto.logs.v1.ScopeLogs.toObject(message.scopeLogs[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ResourceLogs to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ResourceLogs.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ResourceLogs\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ResourceLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.ResourceLogs\";\n                    };\n\n                    return ResourceLogs;\n                })();\n\n                v1.ScopeLogs = (function() {\n\n                    /**\n                     * Properties of a ScopeLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface IScopeLogs\n                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeLogs scope\n                     * @property {Array.<opentelemetry.proto.logs.v1.ILogRecord>|null} [logRecords] ScopeLogs logRecords\n                     * @property {string|null} [schemaUrl] ScopeLogs schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ScopeLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a ScopeLogs.\n                     * @implements IScopeLogs\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs=} [properties] Properties to set\n                     */\n                    function ScopeLogs(properties) {\n                        this.logRecords = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ScopeLogs scope.\n                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     */\n                    ScopeLogs.prototype.scope = null;\n\n                    /**\n                     * ScopeLogs logRecords.\n                     * @member {Array.<opentelemetry.proto.logs.v1.ILogRecord>} logRecords\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     */\n                    ScopeLogs.prototype.logRecords = $util.emptyArray;\n\n                    /**\n                     * ScopeLogs schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     */\n                    ScopeLogs.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ScopeLogs instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs instance\n                     */\n                    ScopeLogs.create = function create(properties) {\n                        return new ScopeLogs(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ScopeLogs message. Does not implicitly {@link opentelemetry.proto.logs.v1.ScopeLogs.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs} message ScopeLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeLogs.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.logRecords != null && message.logRecords.length)\n                            for (var i = 0; i < message.logRecords.length; ++i)\n                                $root.opentelemetry.proto.logs.v1.LogRecord.encode(message.logRecords[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ScopeLogs message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.ScopeLogs.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs} message ScopeLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeLogs.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ScopeLogs message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeLogs.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.logRecords && message.logRecords.length))\n                                        message.logRecords = [];\n                                    message.logRecords.push($root.opentelemetry.proto.logs.v1.LogRecord.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ScopeLogs message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeLogs.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ScopeLogs message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ScopeLogs.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.scope != null && message.hasOwnProperty(\"scope\")) {\n                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);\n                            if (error)\n                                return \"scope.\" + error;\n                        }\n                        if (message.logRecords != null && message.hasOwnProperty(\"logRecords\")) {\n                            if (!Array.isArray(message.logRecords))\n                                return \"logRecords: array expected\";\n                            for (var i = 0; i < message.logRecords.length; ++i) {\n                                var error = $root.opentelemetry.proto.logs.v1.LogRecord.verify(message.logRecords[i]);\n                                if (error)\n                                    return \"logRecords.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ScopeLogs message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs\n                     */\n                    ScopeLogs.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.ScopeLogs)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();\n                        if (object.scope != null) {\n                            if (typeof object.scope !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ScopeLogs.scope: object expected\");\n                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);\n                        }\n                        if (object.logRecords) {\n                            if (!Array.isArray(object.logRecords))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: array expected\");\n                            message.logRecords = [];\n                            for (var i = 0; i < object.logRecords.length; ++i) {\n                                if (typeof object.logRecords[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: object expected\");\n                                message.logRecords[i] = $root.opentelemetry.proto.logs.v1.LogRecord.fromObject(object.logRecords[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ScopeLogs message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ScopeLogs} message ScopeLogs\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ScopeLogs.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.logRecords = [];\n                        if (options.defaults) {\n                            object.scope = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);\n                        if (message.logRecords && message.logRecords.length) {\n                            object.logRecords = [];\n                            for (var j = 0; j < message.logRecords.length; ++j)\n                                object.logRecords[j] = $root.opentelemetry.proto.logs.v1.LogRecord.toObject(message.logRecords[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ScopeLogs to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ScopeLogs.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ScopeLogs\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ScopeLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.ScopeLogs\";\n                    };\n\n                    return ScopeLogs;\n                })();\n\n                /**\n                 * SeverityNumber enum.\n                 * @name opentelemetry.proto.logs.v1.SeverityNumber\n                 * @enum {number}\n                 * @property {number} SEVERITY_NUMBER_UNSPECIFIED=0 SEVERITY_NUMBER_UNSPECIFIED value\n                 * @property {number} SEVERITY_NUMBER_TRACE=1 SEVERITY_NUMBER_TRACE value\n                 * @property {number} SEVERITY_NUMBER_TRACE2=2 SEVERITY_NUMBER_TRACE2 value\n                 * @property {number} SEVERITY_NUMBER_TRACE3=3 SEVERITY_NUMBER_TRACE3 value\n                 * @property {number} SEVERITY_NUMBER_TRACE4=4 SEVERITY_NUMBER_TRACE4 value\n                 * @property {number} SEVERITY_NUMBER_DEBUG=5 SEVERITY_NUMBER_DEBUG value\n                 * @property {number} SEVERITY_NUMBER_DEBUG2=6 SEVERITY_NUMBER_DEBUG2 value\n                 * @property {number} SEVERITY_NUMBER_DEBUG3=7 SEVERITY_NUMBER_DEBUG3 value\n                 * @property {number} SEVERITY_NUMBER_DEBUG4=8 SEVERITY_NUMBER_DEBUG4 value\n                 * @property {number} SEVERITY_NUMBER_INFO=9 SEVERITY_NUMBER_INFO value\n                 * @property {number} SEVERITY_NUMBER_INFO2=10 SEVERITY_NUMBER_INFO2 value\n                 * @property {number} SEVERITY_NUMBER_INFO3=11 SEVERITY_NUMBER_INFO3 value\n                 * @property {number} SEVERITY_NUMBER_INFO4=12 SEVERITY_NUMBER_INFO4 value\n                 * @property {number} SEVERITY_NUMBER_WARN=13 SEVERITY_NUMBER_WARN value\n                 * @property {number} SEVERITY_NUMBER_WARN2=14 SEVERITY_NUMBER_WARN2 value\n                 * @property {number} SEVERITY_NUMBER_WARN3=15 SEVERITY_NUMBER_WARN3 value\n                 * @property {number} SEVERITY_NUMBER_WARN4=16 SEVERITY_NUMBER_WARN4 value\n                 * @property {number} SEVERITY_NUMBER_ERROR=17 SEVERITY_NUMBER_ERROR value\n                 * @property {number} SEVERITY_NUMBER_ERROR2=18 SEVERITY_NUMBER_ERROR2 value\n                 * @property {number} SEVERITY_NUMBER_ERROR3=19 SEVERITY_NUMBER_ERROR3 value\n                 * @property {number} SEVERITY_NUMBER_ERROR4=20 SEVERITY_NUMBER_ERROR4 value\n                 * @property {number} SEVERITY_NUMBER_FATAL=21 SEVERITY_NUMBER_FATAL value\n                 * @property {number} SEVERITY_NUMBER_FATAL2=22 SEVERITY_NUMBER_FATAL2 value\n                 * @property {number} SEVERITY_NUMBER_FATAL3=23 SEVERITY_NUMBER_FATAL3 value\n                 * @property {number} SEVERITY_NUMBER_FATAL4=24 SEVERITY_NUMBER_FATAL4 value\n                 */\n                v1.SeverityNumber = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"SEVERITY_NUMBER_UNSPECIFIED\"] = 0;\n                    values[valuesById[1] = \"SEVERITY_NUMBER_TRACE\"] = 1;\n                    values[valuesById[2] = \"SEVERITY_NUMBER_TRACE2\"] = 2;\n                    values[valuesById[3] = \"SEVERITY_NUMBER_TRACE3\"] = 3;\n                    values[valuesById[4] = \"SEVERITY_NUMBER_TRACE4\"] = 4;\n                    values[valuesById[5] = \"SEVERITY_NUMBER_DEBUG\"] = 5;\n                    values[valuesById[6] = \"SEVERITY_NUMBER_DEBUG2\"] = 6;\n                    values[valuesById[7] = \"SEVERITY_NUMBER_DEBUG3\"] = 7;\n                    values[valuesById[8] = \"SEVERITY_NUMBER_DEBUG4\"] = 8;\n                    values[valuesById[9] = \"SEVERITY_NUMBER_INFO\"] = 9;\n                    values[valuesById[10] = \"SEVERITY_NUMBER_INFO2\"] = 10;\n                    values[valuesById[11] = \"SEVERITY_NUMBER_INFO3\"] = 11;\n                    values[valuesById[12] = \"SEVERITY_NUMBER_INFO4\"] = 12;\n                    values[valuesById[13] = \"SEVERITY_NUMBER_WARN\"] = 13;\n                    values[valuesById[14] = \"SEVERITY_NUMBER_WARN2\"] = 14;\n                    values[valuesById[15] = \"SEVERITY_NUMBER_WARN3\"] = 15;\n                    values[valuesById[16] = \"SEVERITY_NUMBER_WARN4\"] = 16;\n                    values[valuesById[17] = \"SEVERITY_NUMBER_ERROR\"] = 17;\n                    values[valuesById[18] = \"SEVERITY_NUMBER_ERROR2\"] = 18;\n                    values[valuesById[19] = \"SEVERITY_NUMBER_ERROR3\"] = 19;\n                    values[valuesById[20] = \"SEVERITY_NUMBER_ERROR4\"] = 20;\n                    values[valuesById[21] = \"SEVERITY_NUMBER_FATAL\"] = 21;\n                    values[valuesById[22] = \"SEVERITY_NUMBER_FATAL2\"] = 22;\n                    values[valuesById[23] = \"SEVERITY_NUMBER_FATAL3\"] = 23;\n                    values[valuesById[24] = \"SEVERITY_NUMBER_FATAL4\"] = 24;\n                    return values;\n                })();\n\n                /**\n                 * LogRecordFlags enum.\n                 * @name opentelemetry.proto.logs.v1.LogRecordFlags\n                 * @enum {number}\n                 * @property {number} LOG_RECORD_FLAGS_DO_NOT_USE=0 LOG_RECORD_FLAGS_DO_NOT_USE value\n                 * @property {number} LOG_RECORD_FLAGS_TRACE_FLAGS_MASK=255 LOG_RECORD_FLAGS_TRACE_FLAGS_MASK value\n                 */\n                v1.LogRecordFlags = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"LOG_RECORD_FLAGS_DO_NOT_USE\"] = 0;\n                    values[valuesById[255] = \"LOG_RECORD_FLAGS_TRACE_FLAGS_MASK\"] = 255;\n                    return values;\n                })();\n\n                v1.LogRecord = (function() {\n\n                    /**\n                     * Properties of a LogRecord.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface ILogRecord\n                     * @property {number|Long|null} [timeUnixNano] LogRecord timeUnixNano\n                     * @property {number|Long|null} [observedTimeUnixNano] LogRecord observedTimeUnixNano\n                     * @property {opentelemetry.proto.logs.v1.SeverityNumber|null} [severityNumber] LogRecord severityNumber\n                     * @property {string|null} [severityText] LogRecord severityText\n                     * @property {opentelemetry.proto.common.v1.IAnyValue|null} [body] LogRecord body\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] LogRecord attributes\n                     * @property {number|null} [droppedAttributesCount] LogRecord droppedAttributesCount\n                     * @property {number|null} [flags] LogRecord flags\n                     * @property {Uint8Array|null} [traceId] LogRecord traceId\n                     * @property {Uint8Array|null} [spanId] LogRecord spanId\n                     * @property {string|null} [eventName] LogRecord eventName\n                     */\n\n                    /**\n                     * Constructs a new LogRecord.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a LogRecord.\n                     * @implements ILogRecord\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord=} [properties] Properties to set\n                     */\n                    function LogRecord(properties) {\n                        this.attributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * LogRecord timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.timeUnixNano = null;\n\n                    /**\n                     * LogRecord observedTimeUnixNano.\n                     * @member {number|Long|null|undefined} observedTimeUnixNano\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.observedTimeUnixNano = null;\n\n                    /**\n                     * LogRecord severityNumber.\n                     * @member {opentelemetry.proto.logs.v1.SeverityNumber|null|undefined} severityNumber\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.severityNumber = null;\n\n                    /**\n                     * LogRecord severityText.\n                     * @member {string|null|undefined} severityText\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.severityText = null;\n\n                    /**\n                     * LogRecord body.\n                     * @member {opentelemetry.proto.common.v1.IAnyValue|null|undefined} body\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.body = null;\n\n                    /**\n                     * LogRecord attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * LogRecord droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * LogRecord flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.flags = null;\n\n                    /**\n                     * LogRecord traceId.\n                     * @member {Uint8Array|null|undefined} traceId\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.traceId = null;\n\n                    /**\n                     * LogRecord spanId.\n                     * @member {Uint8Array|null|undefined} spanId\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.spanId = null;\n\n                    /**\n                     * LogRecord eventName.\n                     * @member {string|null|undefined} eventName\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.eventName = null;\n\n                    /**\n                     * Creates a new LogRecord instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord instance\n                     */\n                    LogRecord.create = function create(properties) {\n                        return new LogRecord(properties);\n                    };\n\n                    /**\n                     * Encodes the specified LogRecord message. Does not implicitly {@link opentelemetry.proto.logs.v1.LogRecord.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord} message LogRecord message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogRecord.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.timeUnixNano);\n                        if (message.severityNumber != null && Object.hasOwnProperty.call(message, \"severityNumber\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.severityNumber);\n                        if (message.severityText != null && Object.hasOwnProperty.call(message, \"severityText\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.severityText);\n                        if (message.body != null && Object.hasOwnProperty.call(message, \"body\"))\n                            $root.opentelemetry.proto.common.v1.AnyValue.encode(message.body, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.droppedAttributesCount);\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.flags);\n                        if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.traceId);\n                        if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.spanId);\n                        if (message.observedTimeUnixNano != null && Object.hasOwnProperty.call(message, \"observedTimeUnixNano\"))\n                            writer.uint32(/* id 11, wireType 1 =*/89).fixed64(message.observedTimeUnixNano);\n                        if (message.eventName != null && Object.hasOwnProperty.call(message, \"eventName\"))\n                            writer.uint32(/* id 12, wireType 2 =*/98).string(message.eventName);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified LogRecord message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.LogRecord.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord} message LogRecord message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogRecord.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a LogRecord message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogRecord.decode = function decode(reader, length, error) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogRecord();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            if (tag === error)\n                                break;\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 11: {\n                                    message.observedTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 2: {\n                                    message.severityNumber = reader.int32();\n                                    break;\n                                }\n                            case 3: {\n                                    message.severityText = reader.string();\n                                    break;\n                                }\n                            case 5: {\n                                    message.body = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 6: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 7: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            case 8: {\n                                    message.flags = reader.fixed32();\n                                    break;\n                                }\n                            case 9: {\n                                    message.traceId = reader.bytes();\n                                    break;\n                                }\n                            case 10: {\n                                    message.spanId = reader.bytes();\n                                    break;\n                                }\n                            case 12: {\n                                    message.eventName = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a LogRecord message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogRecord.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a LogRecord message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    LogRecord.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.observedTimeUnixNano != null && message.hasOwnProperty(\"observedTimeUnixNano\"))\n                            if (!$util.isInteger(message.observedTimeUnixNano) && !(message.observedTimeUnixNano && $util.isInteger(message.observedTimeUnixNano.low) && $util.isInteger(message.observedTimeUnixNano.high)))\n                                return \"observedTimeUnixNano: integer|Long expected\";\n                        if (message.severityNumber != null && message.hasOwnProperty(\"severityNumber\"))\n                            switch (message.severityNumber) {\n                            default:\n                                return \"severityNumber: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                            case 3:\n                            case 4:\n                            case 5:\n                            case 6:\n                            case 7:\n                            case 8:\n                            case 9:\n                            case 10:\n                            case 11:\n                            case 12:\n                            case 13:\n                            case 14:\n                            case 15:\n                            case 16:\n                            case 17:\n                            case 18:\n                            case 19:\n                            case 20:\n                            case 21:\n                            case 22:\n                            case 23:\n                            case 24:\n                                break;\n                            }\n                        if (message.severityText != null && message.hasOwnProperty(\"severityText\"))\n                            if (!$util.isString(message.severityText))\n                                return \"severityText: string expected\";\n                        if (message.body != null && message.hasOwnProperty(\"body\")) {\n                            var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.body);\n                            if (error)\n                                return \"body.\" + error;\n                        }\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                return \"traceId: buffer expected\";\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                return \"spanId: buffer expected\";\n                        if (message.eventName != null && message.hasOwnProperty(\"eventName\"))\n                            if (!$util.isString(message.eventName))\n                                return \"eventName: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a LogRecord message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord\n                     */\n                    LogRecord.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.LogRecord)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.LogRecord();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.observedTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.observedTimeUnixNano = $util.Long.fromValue(object.observedTimeUnixNano)).unsigned = false;\n                            else if (typeof object.observedTimeUnixNano === \"string\")\n                                message.observedTimeUnixNano = parseInt(object.observedTimeUnixNano, 10);\n                            else if (typeof object.observedTimeUnixNano === \"number\")\n                                message.observedTimeUnixNano = object.observedTimeUnixNano;\n                            else if (typeof object.observedTimeUnixNano === \"object\")\n                                message.observedTimeUnixNano = new $util.LongBits(object.observedTimeUnixNano.low >>> 0, object.observedTimeUnixNano.high >>> 0).toNumber();\n                        switch (object.severityNumber) {\n                        default:\n                            if (typeof object.severityNumber === \"number\") {\n                                message.severityNumber = object.severityNumber;\n                                break;\n                            }\n                            break;\n                        case \"SEVERITY_NUMBER_UNSPECIFIED\":\n                        case 0:\n                            message.severityNumber = 0;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE\":\n                        case 1:\n                            message.severityNumber = 1;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE2\":\n                        case 2:\n                            message.severityNumber = 2;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE3\":\n                        case 3:\n                            message.severityNumber = 3;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE4\":\n                        case 4:\n                            message.severityNumber = 4;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG\":\n                        case 5:\n                            message.severityNumber = 5;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG2\":\n                        case 6:\n                            message.severityNumber = 6;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG3\":\n                        case 7:\n                            message.severityNumber = 7;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG4\":\n                        case 8:\n                            message.severityNumber = 8;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO\":\n                        case 9:\n                            message.severityNumber = 9;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO2\":\n                        case 10:\n                            message.severityNumber = 10;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO3\":\n                        case 11:\n                            message.severityNumber = 11;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO4\":\n                        case 12:\n                            message.severityNumber = 12;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN\":\n                        case 13:\n                            message.severityNumber = 13;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN2\":\n                        case 14:\n                            message.severityNumber = 14;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN3\":\n                        case 15:\n                            message.severityNumber = 15;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN4\":\n                        case 16:\n                            message.severityNumber = 16;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR\":\n                        case 17:\n                            message.severityNumber = 17;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR2\":\n                        case 18:\n                            message.severityNumber = 18;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR3\":\n                        case 19:\n                            message.severityNumber = 19;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR4\":\n                        case 20:\n                            message.severityNumber = 20;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL\":\n                        case 21:\n                            message.severityNumber = 21;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL2\":\n                        case 22:\n                            message.severityNumber = 22;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL3\":\n                        case 23:\n                            message.severityNumber = 23;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL4\":\n                        case 24:\n                            message.severityNumber = 24;\n                            break;\n                        }\n                        if (object.severityText != null)\n                            message.severityText = String(object.severityText);\n                        if (object.body != null) {\n                            if (typeof object.body !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.logs.v1.LogRecord.body: object expected\");\n                            message.body = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.body);\n                        }\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.LogRecord.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.LogRecord.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.traceId != null)\n                            if (typeof object.traceId === \"string\")\n                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                            else if (object.traceId.length >= 0)\n                                message.traceId = object.traceId;\n                        if (object.spanId != null)\n                            if (typeof object.spanId === \"string\")\n                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                            else if (object.spanId.length >= 0)\n                                message.spanId = object.spanId;\n                        if (object.eventName != null)\n                            message.eventName = String(object.eventName);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a LogRecord message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.LogRecord} message LogRecord\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    LogRecord.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.attributes = [];\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.severityNumber = options.enums === String ? \"SEVERITY_NUMBER_UNSPECIFIED\" : 0;\n                            object.severityText = \"\";\n                            object.body = null;\n                            object.droppedAttributesCount = 0;\n                            object.flags = 0;\n                            if (options.bytes === String)\n                                object.traceId = \"\";\n                            else {\n                                object.traceId = [];\n                                if (options.bytes !== Array)\n                                    object.traceId = $util.newBuffer(object.traceId);\n                            }\n                            if (options.bytes === String)\n                                object.spanId = \"\";\n                            else {\n                                object.spanId = [];\n                                if (options.bytes !== Array)\n                                    object.spanId = $util.newBuffer(object.spanId);\n                            }\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.observedTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.observedTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.eventName = \"\";\n                        }\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.severityNumber != null && message.hasOwnProperty(\"severityNumber\"))\n                            object.severityNumber = options.enums === String ? $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] === undefined ? message.severityNumber : $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] : message.severityNumber;\n                        if (message.severityText != null && message.hasOwnProperty(\"severityText\"))\n                            object.severityText = message.severityText;\n                        if (message.body != null && message.hasOwnProperty(\"body\"))\n                            object.body = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.body, options);\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                        if (message.observedTimeUnixNano != null && message.hasOwnProperty(\"observedTimeUnixNano\"))\n                            if (typeof message.observedTimeUnixNano === \"number\")\n                                object.observedTimeUnixNano = options.longs === String ? String(message.observedTimeUnixNano) : message.observedTimeUnixNano;\n                            else\n                                object.observedTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.observedTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.observedTimeUnixNano.low >>> 0, message.observedTimeUnixNano.high >>> 0).toNumber() : message.observedTimeUnixNano;\n                        if (message.eventName != null && message.hasOwnProperty(\"eventName\"))\n                            object.eventName = message.eventName;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this LogRecord to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    LogRecord.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for LogRecord\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    LogRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.LogRecord\";\n                    };\n\n                    return LogRecord;\n                })();\n\n                return v1;\n            })();\n\n            return logs;\n        })();\n\n        return proto;\n    })();\n\n    return opentelemetry;\n})();\n\nmodule.exports = $root;\n","/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/subscriptionRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as PubSub from \"./PubSub.js\"\nimport * as Ref from \"./Ref.js\"\nimport type * as Stream from \"./Stream.js\"\nimport type { Subscribable } from \"./Subscribable.js\"\nimport * as Synchronized from \"./SynchronizedRef.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SubscriptionRefTypeId: unique symbol = internal.SubscriptionRefTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SubscriptionRefTypeId = typeof SubscriptionRefTypeId\n\n/**\n * A `SubscriptionRef<A>` is a `Ref` that can be subscribed to in order to\n * receive the current value as well as all changes to the value.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface SubscriptionRef<in out A>\n  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>\n{\n  /** @internal */\n  readonly ref: Ref.Ref<A>\n  /** @internal */\n  readonly pubsub: PubSub.PubSub<A>\n  /** @internal */\n  readonly semaphore: Effect.Semaphore\n  /**\n   * A stream containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: Stream.Stream<A>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SubscriptionRefUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Synchronized.SynchronizedRefUnify<A>\n{\n  SubscriptionRef?: () => Extract<A[Unify.typeSymbol], SubscriptionRef<any>>\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SubscriptionRefUnifyIgnore extends Synchronized.SynchronizedRefUnifyIgnore {\n  SynchronizedRef?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace SubscriptionRef {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [SubscriptionRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A>(self: SubscriptionRef<A>) => Effect.Effect<A> = internal.get\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>\n} = Ref.getAndSet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>\n} = Ref.getAndUpdate\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = Synchronized.getAndUpdateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = Ref.getAndUpdateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n    self: SubscriptionRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = Synchronized.getAndUpdateSomeEffect\n\n/**\n * Creates a new `SubscriptionRef` with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>> = internal.make\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modify: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: SubscriptionRef<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(self: SubscriptionRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifyEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SubscriptionRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, E, R>(\n    self: SubscriptionRef<A>,\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ): Effect.Effect<B, E, R>\n} = internal.modifyEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: SubscriptionRef<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(\n    self: SubscriptionRef<A>,\n    fallback: B,\n    pf: (a: A) => Option.Option<readonly [B, A]>\n  ): Effect.Effect<B>\n} = Ref.modifySome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n    fallback: B,\n    pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    fallback: B,\n    pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): Effect.Effect<B, E, R>\n} = Synchronized.modifySomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<void>\n} = internal.set\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>\n} = Ref.setAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<void>\n} = Ref.update\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>\n} = Synchronized.updateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>\n} = Ref.updateAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = Synchronized.updateAndGetEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>\n} = Ref.updateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<void, E, R>\n} = Synchronized.updateSomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = Ref.updateSomeAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n    self: SubscriptionRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = Synchronized.updateSomeAndGetEffect\n","/**\n * @since 2.0.0\n */\nimport * as Effect from \"./Effect.js\"\nimport { dual } from \"./Function.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport * as Readable from \"./Readable.js\"\nimport * as Stream from \"./Stream.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Subscribable\")\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Subscribable<A, E = never, R = never> extends Readable.Readable<A, E, R> {\n  readonly [TypeId]: TypeId\n  readonly changes: Stream.Stream<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSubscribable = (u: unknown): u is Subscribable<unknown, unknown, unknown> => hasProperty(u, TypeId)\n\nconst Proto: Omit<Subscribable<any>, \"get\" | \"changes\"> = {\n  [Readable.TypeId]: Readable.TypeId,\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = <A, E, R>(options: {\n  readonly get: Effect.Effect<A, E, R>\n  readonly changes: Stream.Stream<A, E, R>\n}): Subscribable<A, E, R> => Object.assign(Object.create(Proto), options)\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E, R, B>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => B): Subscribable<B, E, R>\n} = dual(2, <A, E, R, B>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => B): Subscribable<B, E, R> =>\n  make({\n    get: Effect.map(self.get, f),\n    changes: Stream.map(self.changes, f)\n  }))\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const mapEffect: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E | E2, R | R2>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E, R, B, E2, R2>(\n    self: Subscribable<A, E, R>,\n    f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): Subscribable<B, E | E2, R | R2>\n} = dual(2, <A, E, R, B, E2, R2>(\n  self: Subscribable<A, E, R>,\n  f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n): Subscribable<B, E | E2, R | R2> =>\n  make({\n    get: Effect.flatMap(self.get, f),\n    changes: Stream.mapEffect(self.changes, f)\n  }))\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unwrap = <A, E, R, E1, R1>(\n  effect: Effect.Effect<Subscribable<A, E, R>, E1, R1>\n): Subscribable<A, E | E1, R | R1> =>\n  make({\n    get: Effect.flatMap(effect, (s) => s.get),\n    changes: Stream.unwrap(Effect.map(effect, (s) => s.changes))\n  })\n","import * as Effect from \"../Effect.js\"\nimport * as Effectable from \"../Effectable.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Readable from \"../Readable.js\"\nimport * as Ref from \"../Ref.js\"\nimport type { Stream } from \"../Stream.js\"\nimport * as Subscribable from \"../Subscribable.js\"\nimport type * as SubscriptionRef from \"../SubscriptionRef.js\"\nimport * as Synchronized from \"../SynchronizedRef.js\"\nimport * as circular_ from \"./effect/circular.js\"\nimport * as ref_ from \"./ref.js\"\nimport * as stream from \"./stream.js\"\n\n/** @internal */\nconst SubscriptionRefSymbolKey = \"effect/SubscriptionRef\"\n\n/** @internal */\nexport const SubscriptionRefTypeId: SubscriptionRef.SubscriptionRefTypeId = Symbol.for(\n  SubscriptionRefSymbolKey\n) as SubscriptionRef.SubscriptionRefTypeId\n\nconst subscriptionRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nclass SubscriptionRefImpl<in out A> extends Effectable.Class<A> implements SubscriptionRef.SubscriptionRef<A> {\n  readonly [Readable.TypeId]: Readable.TypeId = Readable.TypeId\n  readonly [Subscribable.TypeId]: Subscribable.TypeId = Subscribable.TypeId\n  readonly [Ref.RefTypeId] = ref_.refVariance\n  readonly [Synchronized.SynchronizedRefTypeId] = circular_.synchronizedVariance\n  readonly [SubscriptionRefTypeId] = subscriptionRefVariance\n  constructor(\n    readonly ref: Ref.Ref<A>,\n    readonly pubsub: PubSub.PubSub<A>,\n    readonly semaphore: Effect.Semaphore\n  ) {\n    super()\n    this.get = Ref.get(this.ref)\n  }\n  commit() {\n    return this.get\n  }\n  readonly get: Effect.Effect<A>\n  get changes(): Stream<A> {\n    return pipe(\n      Ref.get(this.ref),\n      Effect.flatMap((a) =>\n        Effect.map(\n          stream.fromPubSub(this.pubsub, { scoped: true }),\n          (s) =>\n            stream.concat(\n              stream.make(a),\n              s\n            )\n        )\n      ),\n      this.semaphore.withPermits(1),\n      stream.unwrapScoped\n    )\n  }\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B> {\n    return this.modifyEffect((a) => Effect.succeed(f(a)))\n  }\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R> {\n    return pipe(\n      Ref.get(this.ref),\n      Effect.flatMap(f),\n      Effect.flatMap(([b, a]) =>\n        pipe(\n          Ref.set(this.ref, a),\n          Effect.as(b),\n          Effect.zipLeft(PubSub.publish(this.pubsub, a))\n        )\n      ),\n      this.semaphore.withPermits(1)\n    )\n  }\n}\n\n/** @internal */\nexport const get = <A>(self: SubscriptionRef.SubscriptionRef<A>): Effect.Effect<A> => Ref.get(self.ref)\n\n/** @internal */\nexport const make = <A>(value: A): Effect.Effect<SubscriptionRef.SubscriptionRef<A>> =>\n  pipe(\n    Effect.all([\n      PubSub.unbounded<A>(),\n      Ref.make(value),\n      Effect.makeSemaphore(1)\n    ]),\n    Effect.map(([pubsub, ref, semaphore]) => new SubscriptionRefImpl(ref, pubsub, semaphore))\n  )\n\n/** @internal */\nexport const modify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: SubscriptionRef.SubscriptionRef<A>) => Effect.Effect<B>,\n  <A, B>(\n    self: SubscriptionRef.SubscriptionRef<A>,\n    f: (a: A) => readonly [B, A]\n  ) => Effect.Effect<B>\n>(2, <A, B>(\n  self: SubscriptionRef.SubscriptionRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> => self.modify(f))\n\n/** @internal */\nexport const modifyEffect = dual<\n  <B, A, E, R>(\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ) => (self: SubscriptionRef.SubscriptionRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(\n    self: SubscriptionRef.SubscriptionRef<A>,\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ) => Effect.Effect<B, E, R>\n>(2, <A, B, E, R>(\n  self: SubscriptionRef.SubscriptionRef<A>,\n  f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n): Effect.Effect<B, E, R> => self.modifyEffect(f))\n\n/** @internal */\nexport const set = dual<\n  <A>(value: A) => (self: SubscriptionRef.SubscriptionRef<A>) => Effect.Effect<void>,\n  <A>(\n    self: SubscriptionRef.SubscriptionRef<A>,\n    value: A\n  ) => Effect.Effect<void>\n>(2, <A>(\n  self: SubscriptionRef.SubscriptionRef<A>,\n  value: A\n): Effect.Effect<void> =>\n  pipe(\n    Ref.set(self.ref, value),\n    Effect.zipLeft(PubSub.publish(self.pubsub, value)),\n    self.semaphore.withPermits(1)\n  ))\n","/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as circular from \"./internal/effect/circular.js\"\nimport * as ref from \"./internal/ref.js\"\nimport * as internal from \"./internal/synchronizedRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Ref from \"./Ref.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SynchronizedRefTypeId: unique symbol = circular.SynchronizedTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SynchronizedRefTypeId = typeof SynchronizedRefTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface SynchronizedRef<in out A> extends SynchronizedRef.Variance<A>, Ref.Ref<A> {\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SynchronizedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SynchronizedRefUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SynchronizedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Ref.RefUnify<A> {\n  SynchronizedRef?: () => Extract<A[Unify.typeSymbol], SynchronizedRef<any>>\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SynchronizedRefUnifyIgnore extends Ref.RefUnifyIgnore {\n  Ref?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace SynchronizedRef {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [SynchronizedRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(value: A) => Effect.Effect<SynchronizedRef<A>> = circular.makeSynchronized\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A>(self: SynchronizedRef<A>) => Effect.Effect<A> = ref.get\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>\n} = ref.getAndSet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>\n} = ref.getAndUpdate\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = internal.getAndUpdateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = ref.getAndUpdateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n   self: SynchronizedRef<A>,\n   pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = internal.getAndUpdateSomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modify: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: SynchronizedRef<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(self: SynchronizedRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifyEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, E, R>(\n   self: SynchronizedRef<A>,\n   f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ): Effect.Effect<B, E, R>\n} = internal.modifyEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref.Ref<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(\n   self: Ref.Ref<A>,\n   fallback: B,\n   pf: (a: A) => Option.Option<readonly [B, A]>\n  ): Effect.Effect<B>\n} = ref.modifySome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n   fallback: B,\n   pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n   self: SynchronizedRef<A>,\n   fallback: B,\n   pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): Effect.Effect<B, E, R>\n} = internal.modifySomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, value: A): Effect.Effect<void>\n} = ref.set\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>\n} = ref.setAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<void>\n} = ref.update\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>\n} = internal.updateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>\n} = ref.updateAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = internal.updateAndGetEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>\n} = ref.updateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n   self: SynchronizedRef<A>,\n   pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<void, E, R>\n} = internal.updateSomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = ref.updateSomeAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n   self: SynchronizedRef<A>,\n   pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = circular.updateSomeAndGetEffectSynchronized\n\n/**\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: <A>(value: A) => SynchronizedRef<A> = circular.unsafeMakeSynchronized\n","import { clientEnv } from \"@beep/core-env/client\";\n\nimport { WorkerClient } from \"@beep/runtime-client/worker/worker-client\";\nimport { WebSdk } from \"@effect/opentelemetry\";\nimport { FetchHttpClient } from \"@effect/platform\";\nimport type { HttpClient } from \"@effect/platform/HttpClient\";\nimport type * as KeyValueStore from \"@effect/platform/KeyValueStore\";\nimport { BrowserKeyValueStore } from \"@effect/platform-browser\";\nimport { OTLPLogExporter } from \"@opentelemetry/exporter-logs-otlp-http\";\nimport { OTLPMetricExporter } from \"@opentelemetry/exporter-metrics-otlp-proto\";\nimport { OTLPTraceExporter } from \"@opentelemetry/exporter-trace-otlp-http\";\nimport { BatchLogRecordProcessor } from \"@opentelemetry/sdk-logs\";\nimport { PeriodicExportingMetricReader } from \"@opentelemetry/sdk-metrics\";\nimport { BatchSpanProcessor } from \"@opentelemetry/sdk-trace-base\";\n\nimport * as Effect from \"effect/Effect\";\nimport * as Layer from \"effect/Layer\";\nimport * as Logger from \"effect/Logger\";\nimport * as LogLevel from \"effect/LogLevel\";\nimport type * as ManagedRuntime from \"effect/ManagedRuntime\";\n\nimport { NetworkMonitor } from \"../common/network-monitor\";\n\n// ============================================================================\n// Environment constants\n// ============================================================================\n\nconst isDevEnvironment = clientEnv.env === \"dev\";\nconst serviceName = `${clientEnv.appName}-client`;\n\n// ============================================================================\n// Observability\n// ============================================================================\n\n/**\n * Configures the Web OpenTelemetry SDK to export traces and logs via OTLP.\n */\nexport const TelemetryLive = WebSdk.layer(() => ({\n  resource: { serviceName },\n  spanProcessor: new BatchSpanProcessor(new OTLPTraceExporter({ url: clientEnv.otlpTraceExporterUrl })),\n  logRecordProcessor: new BatchLogRecordProcessor(new OTLPLogExporter({ url: clientEnv.otlpLogExporterUrl })),\n  metricReader: new PeriodicExportingMetricReader({\n    exporter: new OTLPMetricExporter({\n      url: clientEnv.otlpMetricExporterUrl,\n    }),\n  }),\n})).pipe(Layer.provideMerge(FetchHttpClient.layer));\n\n/** Provides pretty logging locally and structured logs in production. */\nexport const LoggerLive = isDevEnvironment ? Logger.pretty : Logger.json;\n\n/** Dynamically tunes the minimum log level to suit the environment. */\nexport const LogLevelLive = Logger.minimumLogLevel(isDevEnvironment ? LogLevel.Debug : LogLevel.Info);\n\n/** Shared observability stack for the client runtime. */\nexport const ObservabilityLive = Layer.mergeAll(LoggerLive, TelemetryLive);\n\n// ============================================================================\n// Runtime infrastructure\n// ============================================================================\n\n/** Supplies the Fetch-based HttpClient implementation. */\nexport const HttpClientLive = FetchHttpClient.layer;\n\n/** Observes browser connectivity changes to expose a NetworkMonitor service. */\nexport const NetworkMonitorLive = NetworkMonitor.Default;\n\n/** Provides access to the worker transport used by the runtime. */\nexport const WorkerClientLive = WorkerClient.Default;\n\n/** Converts the provided TanStack QueryClient into an Effect layer. */\n\n// ============================================================================\n// Runtime assembly\n// ============================================================================\n\ntype ClientRuntimeServices = HttpClient | NetworkMonitor | WorkerClient | KeyValueStore.KeyValueStore;\n\nexport type ClientRuntimeLayer = Layer.Layer<ClientRuntimeServices, never, never>;\n\nexport const clientRuntimeLayer = Layer.mergeAll(\n  HttpClientLive,\n  ObservabilityLive,\n  NetworkMonitorLive,\n  WorkerClientLive,\n  BrowserKeyValueStore.layerLocalStorage\n).pipe(Layer.provide(LogLevelLive));\n\n// ============================================================================\n// Runtime helpers\n// ============================================================================\n\nexport type LiveManagedRuntime = ManagedRuntime.ManagedRuntime<Layer.Layer.Success<ClientRuntimeLayer>, never>;\nexport type LiveRuntimeContext = ManagedRuntime.ManagedRuntime.Context<LiveManagedRuntime>;\n\ntype ClientRuntimeEnv = Layer.Layer.Success<ClientRuntimeLayer>;\ntype RunPromiseOptions = Parameters<LiveManagedRuntime[\"runPromise\"]>[1];\ntype RunPromiseExitOptions = Parameters<LiveManagedRuntime[\"runPromiseExit\"]>[1];\n\n/**\n * Runs an Effect within the client runtime, wrapping it in an observability span.\n */\nexport const runClientPromise = <A, E>(\n  runtime: LiveManagedRuntime,\n  effect: Effect.Effect<A, E, ClientRuntimeEnv>,\n  spanName = \"clientRuntime.runPromise\",\n  options?: RunPromiseOptions\n) => runtime.runPromise(Effect.withSpan(effect, spanName), options);\n\n/**\n * Returns a helper function bound to a specific runtime for repeated invocations.\n */\nexport const makeRunClientPromise =\n  (runtime: LiveManagedRuntime, spanName = \"clientRuntime.runPromise\", options?: RunPromiseOptions) =>\n  <A, E>(effect: Effect.Effect<A, E, ClientRuntimeEnv>) =>\n    runClientPromise(runtime, effect, spanName, options);\n\n/**\n * Runs an Effect within the client runtime and returns its Exit value.\n */\nexport const runClientPromiseExit = <A, E>(\n  runtime: LiveManagedRuntime,\n  effect: Effect.Effect<A, E, ClientRuntimeEnv>,\n  spanName = \"clientRuntime.runPromiseExit\",\n  options?: RunPromiseExitOptions\n) => runtime.runPromiseExit(Effect.withSpan(effect, spanName), options);\n\n/**\n * Returns a helper function that captures Exit values from Effects run in the client runtime.\n */\nexport const makeRunClientPromiseExit =\n  (runtime: LiveManagedRuntime, spanName = \"clientRuntime.runPromiseExit\", options?: RunPromiseExitOptions) =>\n  <A, E>(effect: Effect.Effect<A, E, ClientRuntimeEnv>) =>\n    runClientPromiseExit(runtime, effect, spanName, options);\n","import * as Chunk from \"effect/Chunk\";\nimport * as Effect from \"effect/Effect\";\nimport * as Stream from \"effect/Stream\";\nimport * as SubscriptionRef from \"effect/SubscriptionRef\";\n\nexport class NetworkMonitor extends Effect.Service<NetworkMonitor>()(\"NetworkMonitor\", {\n  scoped: Effect.gen(function* () {\n    const latch = yield* Effect.makeLatch(true);\n\n    const ref = yield* SubscriptionRef.make<boolean>(window.navigator.onLine);\n    yield* Stream.async<boolean>((emit) => {\n      const onlineHandler = () => emit(Effect.succeed(Chunk.of(true)));\n      const offlineHandler = () => emit(Effect.succeed(Chunk.of(false)));\n      window.addEventListener(\"online\", onlineHandler);\n      window.addEventListener(\"offline\", offlineHandler);\n    }).pipe(\n      Stream.tap((isOnline) =>\n        (isOnline ? latch.open : latch.close).pipe(Effect.zipRight(SubscriptionRef.update(ref, () => isOnline)))\n      ),\n      Stream.runDrain,\n      Effect.forkScoped\n    );\n\n    return { latch, ref };\n  }),\n  accessors: true,\n}) {}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {\n  IAnyValue,\n  IInstrumentationScope,\n  IKeyValue,\n  Resource,\n} from './internal-types';\nimport { Attributes } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { Resource as ISdkResource } from '@opentelemetry/resources';\n\nexport function createResource(resource: ISdkResource): Resource {\n  const result: Resource = {\n    attributes: toAttributes(resource.attributes),\n    droppedAttributesCount: 0,\n  };\n\n  const schemaUrl = resource.schemaUrl;\n  if (schemaUrl && schemaUrl !== '') result.schemaUrl = schemaUrl;\n\n  return result;\n}\n\nexport function createInstrumentationScope(\n  scope: InstrumentationScope\n): IInstrumentationScope {\n  return {\n    name: scope.name,\n    version: scope.version,\n  };\n}\n\nexport function toAttributes(attributes: Attributes): IKeyValue[] {\n  return Object.keys(attributes).map(key => toKeyValue(key, attributes[key]));\n}\n\nexport function toKeyValue(key: string, value: unknown): IKeyValue {\n  return {\n    key: key,\n    value: toAnyValue(value),\n  };\n}\n\nexport function toAnyValue(value: unknown): IAnyValue {\n  const t = typeof value;\n  if (t === 'string') return { stringValue: value as string };\n  if (t === 'number') {\n    if (!Number.isInteger(value)) return { doubleValue: value as number };\n    return { intValue: value as number };\n  }\n  if (t === 'boolean') return { boolValue: value as boolean };\n  if (value instanceof Uint8Array) return { bytesValue: value };\n  if (Array.isArray(value))\n    return { arrayValue: { values: value.map(toAnyValue) } };\n  if (t === 'object' && value != null)\n    return {\n      kvlistValue: {\n        values: Object.entries(value as object).map(([k, v]) =>\n          toKeyValue(k, v)\n        ),\n      },\n    };\n\n  return {};\n}\n","import * as Cause from \"../Cause.js\"\nimport { dual } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as List from \"../List.js\"\nimport type * as Logger from \"../Logger.js\"\nimport * as core from \"./core.js\"\nimport * as fiberId_ from \"./fiberId.js\"\nimport * as fiberRefs from \"./fiberRefs.js\"\n\n/** @internal */\nexport const test = dual<\n  <Message>(input: Message) => <Output>(self: Logger.Logger<Message, Output>) => Output,\n  <Message, Output>(self: Logger.Logger<Message, Output>, input: Message) => Output\n>(2, (self, input) =>\n  self.log({\n    fiberId: fiberId_.none,\n    logLevel: core.logLevelInfo,\n    message: input,\n    cause: Cause.empty,\n    context: fiberRefs.empty(),\n    spans: List.empty(),\n    annotations: HashMap.empty(),\n    date: new Date()\n  }))\n","import type { HrTime } from \"@opentelemetry/api\"\nimport { ValueType } from \"@opentelemetry/api\"\nimport type * as Resources from \"@opentelemetry/resources\"\nimport type {\n  CollectionResult,\n  DataPoint,\n  Histogram,\n  MetricCollectOptions,\n  MetricData,\n  MetricProducer,\n  MetricReader\n} from \"@opentelemetry/sdk-metrics\"\nimport { AggregationTemporality, DataPointType, InstrumentType } from \"@opentelemetry/sdk-metrics\"\nimport type { InstrumentDescriptor } from \"@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js\"\nimport * as Arr from \"effect/Array\"\nimport type { DurationInput } from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport type { LazyArg } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Metric from \"effect/Metric\"\nimport type * as MetricKey from \"effect/MetricKey\"\nimport * as MetricKeyType from \"effect/MetricKeyType\"\nimport * as MetricState from \"effect/MetricState\"\nimport * as Option from \"effect/Option\"\nimport * as Resource from \"../Resource.js\"\n\nconst sdkName = \"@effect/opentelemetry/Metrics\"\n\ntype MetricDataWithInstrumentDescriptor = MetricData & {\n  readonly descriptor: InstrumentDescriptor\n}\n\n/** @internal */\nexport class MetricProducerImpl implements MetricProducer {\n  constructor(readonly resource: Resources.Resource) {}\n\n  startTimes = new Map<string, HrTime>()\n\n  startTimeFor(name: string, hrTime: HrTime) {\n    if (this.startTimes.has(name)) {\n      return this.startTimes.get(name)!\n    }\n    this.startTimes.set(name, hrTime)\n    return hrTime\n  }\n\n  collect(_options?: MetricCollectOptions): Promise<CollectionResult> {\n    const snapshot = Metric.unsafeSnapshot()\n    const hrTimeNow = currentHrTime()\n    const metricData: Array<MetricData> = []\n    const metricDataByName = new Map<string, MetricData>()\n    const addMetricData = (data: MetricDataWithInstrumentDescriptor) => {\n      metricData.push(data)\n      metricDataByName.set(data.descriptor.name, data)\n    }\n\n    for (let i = 0, len = snapshot.length; i < len; i++) {\n      const { metricKey, metricState } = snapshot[i]\n      const attributes = Arr.reduce(metricKey.tags, {}, (acc: Record<string, string>, label) => {\n        acc[label.key] = label.value\n        return acc\n      })\n      const descriptor = descriptorFromKey(metricKey, attributes)\n      const startTime = this.startTimeFor(descriptor.name, hrTimeNow)\n\n      if (MetricState.isCounterState(metricState)) {\n        const dataPoint: DataPoint<number> = {\n          startTime,\n          endTime: hrTimeNow,\n          attributes,\n          value: Number(metricState.count)\n        }\n        if (metricDataByName.has(descriptor.name)) {\n          metricDataByName.get(descriptor.name)!.dataPoints.push(dataPoint as any)\n        } else {\n          addMetricData({\n            dataPointType: DataPointType.SUM,\n            descriptor,\n            isMonotonic: descriptor.type === InstrumentType.COUNTER,\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            dataPoints: [dataPoint]\n          })\n        }\n      } else if (MetricState.isGaugeState(metricState)) {\n        const dataPoint: DataPoint<number> = {\n          startTime,\n          endTime: hrTimeNow,\n          attributes,\n          value: Number(metricState.value)\n        }\n        if (metricDataByName.has(descriptor.name)) {\n          metricDataByName.get(descriptor.name)!.dataPoints.push(dataPoint as any)\n        } else {\n          addMetricData({\n            dataPointType: DataPointType.GAUGE,\n            descriptor,\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            dataPoints: [dataPoint]\n          })\n        }\n      } else if (MetricState.isHistogramState(metricState)) {\n        const size = metricState.buckets.length\n        const buckets = {\n          boundaries: Arr.allocate(size - 1) as Array<number>,\n          counts: Arr.allocate(size) as Array<number>\n        }\n        let i = 0\n        let prev = 0\n        for (const [boundary, value] of metricState.buckets) {\n          if (i < size - 1) {\n            buckets.boundaries[i] = boundary\n          }\n          buckets.counts[i] = value - prev\n          prev = value\n          i++\n        }\n        const dataPoint: DataPoint<Histogram> = {\n          startTime,\n          endTime: hrTimeNow,\n          attributes,\n          value: {\n            buckets,\n            count: metricState.count,\n            min: metricState.min,\n            max: metricState.max,\n            sum: metricState.sum\n          }\n        }\n\n        if (metricDataByName.has(descriptor.name)) {\n          metricDataByName.get(descriptor.name)!.dataPoints.push(dataPoint as any)\n        } else {\n          addMetricData({\n            dataPointType: DataPointType.HISTOGRAM,\n            descriptor,\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            dataPoints: [dataPoint]\n          })\n        }\n      } else if (MetricState.isFrequencyState(metricState)) {\n        const dataPoints: Array<DataPoint<number>> = []\n        for (const [freqKey, value] of metricState.occurrences) {\n          dataPoints.push({\n            startTime,\n            endTime: hrTimeNow,\n            attributes: {\n              ...attributes,\n              key: freqKey\n            },\n            value\n          })\n        }\n        if (metricDataByName.has(descriptor.name)) {\n          // eslint-disable-next-line no-restricted-syntax\n          metricDataByName.get(descriptor.name)!.dataPoints.push(...dataPoints as any)\n        } else {\n          addMetricData({\n            dataPointType: DataPointType.SUM,\n            descriptor: descriptorFromKey(metricKey, attributes),\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            isMonotonic: true,\n            dataPoints\n          })\n        }\n      } else if (MetricState.isSummaryState(metricState)) {\n        const dataPoints: Array<DataPoint<number>> = [{\n          startTime,\n          endTime: hrTimeNow,\n          attributes: { ...attributes, quantile: \"min\" },\n          value: metricState.min\n        }]\n        for (const [quantile, value] of metricState.quantiles) {\n          dataPoints.push({\n            startTime,\n            endTime: hrTimeNow,\n            attributes: { ...attributes, quantile: quantile.toString() },\n            value: value._tag === \"Some\" ? value.value : 0\n          })\n        }\n        dataPoints.push({\n          startTime,\n          endTime: hrTimeNow,\n          attributes: { ...attributes, quantile: \"max\" },\n          value: metricState.max\n        })\n        const countDataPoint: DataPoint<number> = {\n          startTime,\n          endTime: hrTimeNow,\n          attributes,\n          value: metricState.count\n        }\n        const sumDataPoint: DataPoint<number> = {\n          startTime,\n          endTime: hrTimeNow,\n          attributes,\n          value: metricState.sum\n        }\n\n        if (metricDataByName.has(`${descriptor.name}_quantiles`)) {\n          // eslint-disable-next-line no-restricted-syntax\n          metricDataByName.get(`${descriptor.name}_quantiles`)!.dataPoints.push(...dataPoints as any)\n          metricDataByName.get(`${descriptor.name}_count`)!.dataPoints.push(countDataPoint as any)\n          metricDataByName.get(`${descriptor.name}_sum`)!.dataPoints.push(sumDataPoint as any)\n        } else {\n          addMetricData({\n            dataPointType: DataPointType.SUM,\n            descriptor: descriptorFromKey(metricKey, attributes, \"quantiles\"),\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            isMonotonic: false,\n            dataPoints\n          })\n          addMetricData({\n            dataPointType: DataPointType.SUM,\n            descriptor: {\n              ...descriptorMeta(metricKey, \"count\"),\n              unit: \"1\",\n              type: InstrumentType.COUNTER,\n              valueType: ValueType.INT\n            },\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            isMonotonic: true,\n            dataPoints: [countDataPoint]\n          })\n          addMetricData({\n            dataPointType: DataPointType.SUM,\n            descriptor: {\n              ...descriptorMeta(metricKey, \"sum\"),\n              unit: \"1\",\n              type: InstrumentType.COUNTER,\n              valueType: ValueType.DOUBLE\n            },\n            aggregationTemporality: AggregationTemporality.CUMULATIVE,\n            isMonotonic: true,\n            dataPoints: [sumDataPoint]\n          })\n        }\n      }\n    }\n\n    return Promise.resolve({\n      resourceMetrics: {\n        resource: this.resource,\n        scopeMetrics: [{\n          scope: { name: sdkName },\n          metrics: metricData\n        }]\n      },\n      errors: []\n    })\n  }\n}\n\nconst descriptorMeta = (\n  metricKey: MetricKey.MetricKey.Untyped,\n  suffix?: string\n) => ({\n  name: suffix ? `${metricKey.name}_${suffix}` : metricKey.name,\n  description: Option.getOrElse(metricKey.description, () => \"\"),\n  advice: {}\n})\n\nconst descriptorFromKey = (\n  metricKey: MetricKey.MetricKey.Untyped,\n  tags: Record<string, string>,\n  suffix?: string\n): InstrumentDescriptor => ({\n  ...descriptorMeta(metricKey, suffix),\n  unit: tags.unit ?? tags.time_unit ?? \"1\",\n  type: instrumentTypeFromKey(metricKey),\n  valueType: \"bigint\" in metricKey.keyType && metricKey.keyType.bigint === true ? ValueType.INT : ValueType.DOUBLE\n})\n\nconst instrumentTypeFromKey = (key: MetricKey.MetricKey.Untyped): InstrumentType => {\n  if (MetricKeyType.isHistogramKey(key.keyType)) {\n    return InstrumentType.HISTOGRAM\n  } else if (MetricKeyType.isGaugeKey(key.keyType)) {\n    return InstrumentType.OBSERVABLE_GAUGE\n  } else if (MetricKeyType.isFrequencyKey(key.keyType)) {\n    return InstrumentType.COUNTER\n  } else if (MetricKeyType.isCounterKey(key.keyType) && key.keyType.incremental) {\n    return InstrumentType.COUNTER\n  }\n\n  return InstrumentType.UP_DOWN_COUNTER\n}\n\nconst currentHrTime = (): HrTime => {\n  const now = Date.now()\n  return [Math.floor(now / 1000), (now % 1000) * 1000000]\n}\n\n/** @internal */\nexport const makeProducer = Effect.map(\n  Resource.Resource,\n  (resource): MetricProducer => new MetricProducerImpl(resource)\n)\n\n/** @internal */\nexport const registerProducer = (\n  self: MetricProducer,\n  metricReader: LazyArg<MetricReader | Arr.NonEmptyReadonlyArray<MetricReader>>,\n  options?: {\n    readonly shutdownTimeout?: DurationInput | undefined\n  }\n) =>\n  Effect.acquireRelease(\n    Effect.sync(() => {\n      const reader = metricReader()\n      const readers: Array<MetricReader> = Array.isArray(reader) ? reader : [reader] as any\n      readers.forEach((reader) => reader.setMetricProducer(self))\n      return readers\n    }),\n    (readers) =>\n      Effect.promise(() =>\n        Promise.all(\n          readers.map((reader) => reader.shutdown())\n        )\n      ).pipe(\n        Effect.ignoreLogged,\n        Effect.interruptible,\n        Effect.timeoutOption(options?.shutdownTimeout ?? 3000)\n      )\n  )\n\n/** @internal */\nexport const layer = (evaluate: LazyArg<MetricReader | Arr.NonEmptyReadonlyArray<MetricReader>>, options?: {\n  readonly shutdownTimeout?: DurationInput | undefined\n}) =>\n  Layer.scopedDiscard(Effect.flatMap(\n    makeProducer,\n    (producer) => registerProducer(producer, evaluate, options)\n  ))\n","import * as Effect from \"effect/Effect\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as Stream from \"effect/Stream\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Client from \"../HttpClient.js\"\nimport * as Error from \"../HttpClientError.js\"\nimport * as client from \"./httpClient.js\"\nimport * as internalResponse from \"./httpClientResponse.js\"\n\n/** @internal */\nexport const fetchTagKey = \"@effect/platform/FetchHttpClient/Fetch\"\n/** @internal */\nexport const requestInitTagKey = \"@effect/platform/FetchHttpClient/FetchOptions\"\n\nconst fetch: Client.HttpClient = client.make((request, url, signal, fiber) => {\n  const context = fiber.getFiberRef(FiberRef.currentContext)\n  const fetch: typeof globalThis.fetch = context.unsafeMap.get(fetchTagKey) ?? globalThis.fetch\n  const options: RequestInit = context.unsafeMap.get(requestInitTagKey) ?? {}\n  const headers = options.headers ? Headers.merge(Headers.fromInput(options.headers), request.headers) : request.headers\n  const send = (body: BodyInit | undefined) =>\n    Effect.map(\n      Effect.tryPromise({\n        try: () =>\n          fetch(url, {\n            ...options,\n            method: request.method,\n            headers,\n            body,\n            duplex: request.body._tag === \"Stream\" ? \"half\" : undefined,\n            signal\n          } as any),\n        catch: (cause) =>\n          new Error.RequestError({\n            request,\n            reason: \"Transport\",\n            cause\n          })\n      }),\n      (response) => internalResponse.fromWeb(request, response)\n    )\n  switch (request.body._tag) {\n    case \"Raw\":\n    case \"Uint8Array\":\n      return send(request.body.body as any)\n    case \"FormData\":\n      return send(request.body.formData)\n    case \"Stream\":\n      return Effect.flatMap(Stream.toReadableStreamEffect(request.body.stream), send)\n  }\n  return send(undefined)\n})\n\n/** @internal */\nexport const layer = client.layerMergedContext(Effect.succeed(fetch))\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { OtlpEncodingOptions } from '../common/internal-types';\nimport { ValueType } from '@opentelemetry/api';\nimport {\n  AggregationTemporality,\n  DataPoint,\n  DataPointType,\n  ExponentialHistogram,\n  Histogram,\n  MetricData,\n  ResourceMetrics,\n  ScopeMetrics,\n} from '@opentelemetry/sdk-metrics';\nimport {\n  EAggregationTemporality,\n  IExponentialHistogramDataPoint,\n  IExportMetricsServiceRequest,\n  IHistogramDataPoint,\n  IMetric,\n  INumberDataPoint,\n  IResourceMetrics,\n  IScopeMetrics,\n} from './internal-types';\nimport { Encoder, getOtlpEncoder } from '../common/utils';\nimport {\n  createInstrumentationScope,\n  createResource,\n  toAttributes,\n} from '../common/internal';\n\nexport function toResourceMetrics(\n  resourceMetrics: ResourceMetrics,\n  options?: OtlpEncodingOptions\n): IResourceMetrics {\n  const encoder = getOtlpEncoder(options);\n  const processedResource = createResource(resourceMetrics.resource);\n  return {\n    resource: processedResource,\n    schemaUrl: processedResource.schemaUrl,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder),\n  };\n}\n\nexport function toScopeMetrics(\n  scopeMetrics: ScopeMetrics[],\n  encoder: Encoder\n): IScopeMetrics[] {\n  return Array.from(\n    scopeMetrics.map(metrics => ({\n      scope: createInstrumentationScope(metrics.scope),\n      metrics: metrics.metrics.map(metricData => toMetric(metricData, encoder)),\n      schemaUrl: metrics.scope.schemaUrl,\n    }))\n  );\n}\n\nexport function toMetric(metricData: MetricData, encoder: Encoder): IMetric {\n  const out: IMetric = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit,\n  };\n\n  const aggregationTemporality = toAggregationTemporality(\n    metricData.aggregationTemporality\n  );\n\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData, encoder),\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData, encoder),\n      };\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(\n  dataPoint:\n    | DataPoint<number>\n    | DataPoint<Histogram>\n    | DataPoint<ExponentialHistogram>,\n  valueType: ValueType,\n  encoder: Encoder\n) {\n  const out: INumberDataPoint = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n    timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n  };\n\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value as number;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value as number;\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): INumberDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(\n      dataPoint,\n      metricData.descriptor.valueType,\n      encoder\n    );\n  });\n}\n\nfunction toHistogramDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): IHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as Histogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toExponentialHistogramDataPoints(\n  metricData: MetricData,\n  encoder: Encoder\n): IExponentialHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as ExponentialHistogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts,\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts,\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),\n      timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toAggregationTemporality(\n  temporality: AggregationTemporality\n): EAggregationTemporality {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n    case AggregationTemporality.CUMULATIVE:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n}\n\nexport function createExportMetricsServiceRequest(\n  resourceMetrics: ResourceMetrics[],\n  options?: OtlpEncodingOptions\n): IExportMetricsServiceRequest {\n  return {\n    resourceMetrics: resourceMetrics.map(metrics =>\n      toResourceMetrics(metrics, options)\n    ),\n  };\n}\n","import * as OtelApi from \"@opentelemetry/api\"\nimport * as OtelSemConv from \"@opentelemetry/semantic-conventions\"\nimport * as Cause from \"effect/Cause\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport type { Exit } from \"effect/Exit\"\nimport { dual } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Option from \"effect/Option\"\nimport * as EffectTracer from \"effect/Tracer\"\nimport { Resource } from \"../Resource.js\"\nimport type { OtelTraceFlags, OtelTracer, OtelTracerProvider, OtelTraceState } from \"../Tracer.js\"\nimport { nanosToHrTime, recordToAttributes, unknownToAttributeValue } from \"./utils.js\"\n\nconst OtelSpanTypeId = Symbol.for(\"@effect/opentelemetry/Tracer/OtelSpan\")\n\nconst kindMap = {\n  \"internal\": OtelApi.SpanKind.INTERNAL,\n  \"client\": OtelApi.SpanKind.CLIENT,\n  \"server\": OtelApi.SpanKind.SERVER,\n  \"producer\": OtelApi.SpanKind.PRODUCER,\n  \"consumer\": OtelApi.SpanKind.CONSUMER\n}\n\nconst getOtelParent = (tracer: OtelApi.TraceAPI, otelContext: OtelApi.Context, context: Context.Context<never>) => {\n  const active = tracer.getSpan(otelContext)\n  const otelParent = active ? active.spanContext() : undefined\n  return otelParent\n    ? Option.some(\n      EffectTracer.externalSpan({\n        spanId: otelParent.spanId,\n        traceId: otelParent.traceId,\n        sampled: (otelParent.traceFlags & 1) === 1,\n        context\n      })\n    )\n    : Option.none()\n}\n\n/** @internal */\nexport class OtelSpan implements EffectTracer.Span {\n  readonly [OtelSpanTypeId]: typeof OtelSpanTypeId\n  readonly _tag = \"Span\"\n\n  readonly span: OtelApi.Span\n  readonly spanId: string\n  readonly traceId: string\n  readonly attributes = new Map<string, unknown>()\n  readonly sampled: boolean\n  readonly parent: Option.Option<EffectTracer.AnySpan>\n  status: EffectTracer.SpanStatus\n\n  constructor(\n    contextApi: OtelApi.ContextAPI,\n    traceApi: OtelApi.TraceAPI,\n    tracer: OtelApi.Tracer,\n    readonly name: string,\n    effectParent: Option.Option<EffectTracer.AnySpan>,\n    readonly context: Context.Context<never>,\n    readonly links: Array<EffectTracer.SpanLink>,\n    startTime: bigint,\n    readonly kind: EffectTracer.SpanKind,\n    options?: EffectTracer.SpanOptions\n  ) {\n    this[OtelSpanTypeId] = OtelSpanTypeId\n    const active = contextApi.active()\n    this.parent = effectParent._tag === \"Some\"\n      ? effectParent\n      : (options?.root !== true)\n      ? getOtelParent(traceApi, active, context)\n      : Option.none()\n    this.span = tracer.startSpan(\n      name,\n      {\n        startTime: nanosToHrTime(startTime),\n        links: links.length > 0\n          ? links.map((link) => ({\n            context: makeSpanContext(link.span),\n            attributes: recordToAttributes(link.attributes)\n          }))\n          : undefined as any,\n        kind: kindMap[this.kind]\n      },\n      this.parent._tag === \"Some\"\n        ? populateContext(active, this.parent.value, context)\n        : OtelApi.trace.deleteSpan(active)\n    )\n    const spanContext = this.span.spanContext()\n    this.spanId = spanContext.spanId\n    this.traceId = spanContext.traceId\n    this.status = {\n      _tag: \"Started\",\n      startTime\n    }\n    this.sampled = (spanContext.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED\n  }\n\n  attribute(key: string, value: unknown) {\n    this.span.setAttribute(key, unknownToAttributeValue(value))\n    this.attributes.set(key, value)\n  }\n\n  addLinks(links: ReadonlyArray<EffectTracer.SpanLink>): void {\n    // eslint-disable-next-line no-restricted-syntax\n    this.links.push(...links)\n    this.span.addLinks(links.map((link) => ({\n      context: makeSpanContext(link.span),\n      attributes: recordToAttributes(link.attributes)\n    })))\n  }\n\n  end(endTime: bigint, exit: Exit<unknown, unknown>) {\n    const hrTime = nanosToHrTime(endTime)\n    this.status = {\n      _tag: \"Ended\",\n      endTime,\n      exit,\n      startTime: this.status.startTime\n    }\n\n    if (exit._tag === \"Success\") {\n      this.span.setStatus({ code: OtelApi.SpanStatusCode.OK })\n    } else {\n      if (Cause.isInterruptedOnly(exit.cause)) {\n        this.span.setStatus({\n          code: OtelApi.SpanStatusCode.OK,\n          message: Cause.pretty(exit.cause)\n        })\n        this.span.setAttribute(\"span.label\", \" Interrupted\")\n        this.span.setAttribute(\"status.interrupted\", true)\n      } else {\n        const firstError = Cause.prettyErrors(exit.cause)[0]\n        if (firstError) {\n          firstError.stack = Cause.pretty(exit.cause, { renderErrorCause: true })\n          this.span.recordException(firstError, hrTime)\n          this.span.setStatus({\n            code: OtelApi.SpanStatusCode.ERROR,\n            message: firstError.message\n          })\n        } else {\n          // empty cause means no error\n          this.span.setStatus({ code: OtelApi.SpanStatusCode.OK })\n        }\n      }\n    }\n    this.span.end(hrTime)\n  }\n\n  event(name: string, startTime: bigint, attributes?: Record<string, unknown>) {\n    this.span.addEvent(\n      name,\n      attributes ? recordToAttributes(attributes) : undefined,\n      nanosToHrTime(startTime)\n    )\n  }\n}\n\n/** @internal */\nexport const TracerProvider = Context.GenericTag<OtelTracerProvider, OtelApi.TracerProvider>(\n  \"@effect/opentelemetry/Tracer/OtelTracerProvider\"\n)\n\n/** @internal */\nexport const Tracer = Context.GenericTag<OtelTracer, OtelApi.Tracer>(\"@effect/opentelemetry/Tracer/OtelTracer\")\n\n/** @internal */\nexport const make = Effect.map(Tracer, (tracer) =>\n  EffectTracer.make({\n    span(name, parent, context, links, startTime, kind, options) {\n      return new OtelSpan(\n        OtelApi.context,\n        OtelApi.trace,\n        tracer,\n        name,\n        parent,\n        context,\n        links.slice(),\n        startTime,\n        kind,\n        options\n      )\n    },\n    context(execution, fiber) {\n      const currentSpan = fiber.currentSpan\n\n      if (currentSpan === undefined) {\n        return execution()\n      }\n\n      return OtelApi.context.with(\n        populateContext(OtelApi.context.active(), currentSpan),\n        execution\n      )\n    }\n  }))\n\n/** @internal */\nexport const traceFlagsTag = Context.GenericTag<OtelTraceFlags, OtelApi.TraceFlags>(\n  \"@effect/opentelemetry/Tracer/OtelTraceFlags\"\n)\n\n/** @internal */\nexport const traceStateTag = Context.GenericTag<OtelTraceState, OtelApi.TraceState>(\n  \"@effect/opentelemetry/Tracer/OtelTraceState\"\n)\n\n/** @internal */\nexport const makeExternalSpan = (options: {\n  readonly traceId: string\n  readonly spanId: string\n  readonly traceFlags?: number | undefined\n  readonly traceState?: string | OtelApi.TraceState | undefined\n}): EffectTracer.ExternalSpan => {\n  let context = Context.empty()\n\n  if (options.traceFlags !== undefined) {\n    context = Context.add(context, traceFlagsTag, options.traceFlags)\n  }\n\n  if (typeof options.traceState === \"string\") {\n    context = Option.match(createTraceState(options.traceState), {\n      onNone: () => context,\n      onSome: (traceState) => Context.add(context, traceStateTag, traceState)\n    })\n  } else if (options.traceState) {\n    context = Context.add(context, traceStateTag, options.traceState)\n  }\n\n  return {\n    _tag: \"ExternalSpan\",\n    traceId: options.traceId,\n    spanId: options.spanId,\n    sampled: options.traceFlags !== undefined\n      ? (options.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED\n      : true,\n    context\n  }\n}\n\n/** @internal */\nexport const currentOtelSpan = Effect.flatMap(\n  Effect.currentSpan,\n  (span) => {\n    if (OtelSpanTypeId in span) {\n      return Effect.succeed((span as OtelSpan).span)\n    }\n    return Effect.fail(new Cause.NoSuchElementException())\n  }\n)\n\n/** @internal */\nexport const layerGlobalProvider = Layer.sync(\n  TracerProvider,\n  () => OtelApi.trace.getTracerProvider()\n)\n\n/** @internal */\nexport const layerTracer = Layer.effect(\n  Tracer,\n  Effect.flatMap(\n    Effect.zip(Resource, TracerProvider),\n    ([resource, provider]) =>\n      Effect.sync(() =>\n        provider.getTracer(\n          resource.attributes[OtelSemConv.ATTR_SERVICE_NAME] as string,\n          resource.attributes[OtelSemConv.ATTR_SERVICE_VERSION] as string\n        )\n      )\n  )\n)\n\n/** @internal */\nexport const layerGlobalTracer = layerTracer.pipe(\n  Layer.provide(layerGlobalProvider)\n)\n\n/** @internal */\nexport const layerGlobal = Layer.unwrapEffect(Effect.map(make, Layer.setTracer)).pipe(\n  Layer.provideMerge(layerGlobalTracer)\n)\n\n/** @internal */\nexport const layerWithoutOtelTracer = Layer.unwrapEffect(Effect.map(make, Layer.setTracer))\n\n/** @internal */\nexport const layer = layerWithoutOtelTracer.pipe(\n  Layer.provideMerge(layerTracer)\n)\n\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n\nconst createTraceState = Option.liftThrowable(OtelApi.createTraceState)\n\nconst populateContext = (\n  otelContext: OtelApi.Context,\n  span: EffectTracer.AnySpan,\n  context?: Context.Context<never>\n): OtelApi.Context =>\n  span instanceof OtelSpan ?\n    OtelApi.trace.setSpan(otelContext, span.span) :\n    OtelApi.trace.setSpanContext(otelContext, makeSpanContext(span, context))\n\nconst makeSpanContext = (span: EffectTracer.AnySpan, context?: Context.Context<never>): OtelApi.SpanContext => ({\n  spanId: span.spanId,\n  traceId: span.traceId,\n  isRemote: span._tag === \"ExternalSpan\",\n  traceFlags: Option.getOrElse(\n    context ?\n      extractTraceTag(span, context, traceFlagsTag) :\n      Context.getOption(span.context, traceFlagsTag),\n    () => OtelApi.TraceFlags.SAMPLED\n  ),\n  traceState: Option.getOrUndefined(\n    context ?\n      extractTraceTag(span, context, traceStateTag) :\n      Context.getOption(span.context, traceStateTag)\n  ) as OtelApi.TraceState\n})\n\nconst extractTraceTag = <I, S>(\n  parent: EffectTracer.AnySpan,\n  context: Context.Context<never>,\n  tag: Context.Tag<I, S>\n) =>\n  Option.orElse(\n    Context.getOption(context, tag),\n    () => Context.getOption(parent.context, tag)\n  )\n\n/** @internal */\nexport const withSpanContext = dual<\n  (\n    spanContext: OtelApi.SpanContext\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, EffectTracer.ParentSpan>>,\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    spanContext: OtelApi.SpanContext\n  ) => Effect.Effect<A, E, Exclude<R, EffectTracer.ParentSpan>>\n>(2, <A, E, R>(\n  effect: Effect.Effect<A, E, R>,\n  spanContext: OtelApi.SpanContext\n): Effect.Effect<A, E, Exclude<R, EffectTracer.ParentSpan>> =>\n  Effect.withParentSpan(effect, makeExternalSpan(spanContext)))\n","/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/keyType.js\"\nimport type * as MetricBoundaries from \"./MetricBoundaries.js\"\nimport type * as MetricState from \"./MetricState.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricKeyTypeTypeId: unique symbol = internal.MetricKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricKeyTypeTypeId = typeof MetricKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const CounterKeyTypeTypeId: unique symbol = internal.CounterKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type CounterKeyTypeTypeId = typeof CounterKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FrequencyKeyTypeTypeId: unique symbol = internal.FrequencyKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FrequencyKeyTypeTypeId = typeof FrequencyKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const GaugeKeyTypeTypeId: unique symbol = internal.GaugeKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type GaugeKeyTypeTypeId = typeof GaugeKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const HistogramKeyTypeTypeId: unique symbol = internal.HistogramKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type HistogramKeyTypeTypeId = typeof HistogramKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SummaryKeyTypeTypeId: unique symbol = internal.SummaryKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SummaryKeyTypeTypeId = typeof SummaryKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category modelz\n */\nexport interface MetricKeyType<in In, out Out> extends MetricKeyType.Variance<In, Out>, Equal.Equal, Pipeable {}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricKeyType {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Untyped = MetricKeyType<any, any>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Counter<A extends (number | bigint)> = MetricKeyType<A, MetricState.MetricState.Counter<A>> & {\n    readonly [CounterKeyTypeTypeId]: CounterKeyTypeTypeId\n    readonly incremental: boolean\n    readonly bigint: boolean\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Frequency = MetricKeyType<string, MetricState.MetricState.Frequency> & {\n    readonly [FrequencyKeyTypeTypeId]: FrequencyKeyTypeTypeId\n    readonly preregisteredWords: ReadonlyArray<string>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Gauge<A extends (number | bigint)> = MetricKeyType<A, MetricState.MetricState.Gauge<A>> & {\n    readonly [GaugeKeyTypeTypeId]: GaugeKeyTypeTypeId\n    readonly bigint: boolean\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Histogram = MetricKeyType<number, MetricState.MetricState.Histogram> & {\n    readonly [HistogramKeyTypeTypeId]: HistogramKeyTypeTypeId\n    readonly boundaries: MetricBoundaries.MetricBoundaries\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Summary = MetricKeyType<readonly [number, number], MetricState.MetricState.Summary> & {\n    readonly [SummaryKeyTypeTypeId]: SummaryKeyTypeTypeId\n    readonly maxAge: Duration.Duration\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in In, out Out> {\n    readonly [MetricKeyTypeTypeId]: {\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type InType<Type extends MetricKeyType<any, any>> = [Type] extends [\n    {\n      readonly [MetricKeyTypeTypeId]: {\n        readonly _In: (_: infer In) => void\n      }\n    }\n  ] ? In\n    : never\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type OutType<Type extends MetricKeyType<any, any>> = [Type] extends [\n    {\n      readonly [MetricKeyTypeTypeId]: {\n        readonly _Out: (_: never) => infer Out\n      }\n    }\n  ] ? Out\n    : never\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: <A extends number | bigint>() => MetricKeyType.Counter<A> = internal.counter\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (\n  options?: {\n    readonly preregisteredWords?: ReadonlyArray<string> | undefined\n  } | undefined\n) => MetricKeyType.Frequency = internal.frequency\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: <A extends number | bigint>() => MetricKeyType.Gauge<A> = internal.gauge\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (boundaries: MetricBoundaries.MetricBoundaries) => MetricKeyType.Histogram = internal.histogram\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n  }\n) => MetricKeyType.Summary = internal.summary\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricKeyType: (u: unknown) => u is MetricKeyType<unknown, unknown> = internal.isMetricKeyType\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isCounterKey: (u: unknown) => u is MetricKeyType.Counter<number | bigint> = internal.isCounterKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isFrequencyKey: (u: unknown) => u is MetricKeyType.Frequency = internal.isFrequencyKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isGaugeKey: (u: unknown) => u is MetricKeyType.Gauge<number | bigint> = internal.isGaugeKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHistogramKey: (u: unknown) => u is MetricKeyType.Histogram = internal.isHistogramKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSummaryKey: (u: unknown) => u is MetricKeyType.Summary = internal.isSummaryKey\n","/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/state.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricStateTypeId: unique symbol = internal.MetricStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricStateTypeId = typeof MetricStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const CounterStateTypeId: unique symbol = internal.CounterStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type CounterStateTypeId = typeof CounterStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FrequencyStateTypeId: unique symbol = internal.FrequencyStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FrequencyStateTypeId = typeof FrequencyStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const GaugeStateTypeId: unique symbol = internal.GaugeStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type GaugeStateTypeId = typeof GaugeStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const HistogramStateTypeId: unique symbol = internal.HistogramStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type HistogramStateTypeId = typeof HistogramStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SummaryStateTypeId: unique symbol = internal.SummaryStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SummaryStateTypeId = typeof SummaryStateTypeId\n\n/**\n * A `MetricState` describes the state of a metric. The type parameter of a\n * metric state corresponds to the type of the metric key (`MetricStateType`).\n * This phantom type parameter is used to tie keys to their expected states.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricState {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Untyped extends MetricState<any> {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Counter<in out A extends (number | bigint)>\n    extends MetricState<MetricKeyType.MetricKeyType.Counter<A>>\n  {\n    readonly [CounterStateTypeId]: CounterStateTypeId\n    readonly count: A\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Frequency extends MetricState<MetricKeyType.MetricKeyType.Frequency> {\n    readonly [FrequencyStateTypeId]: FrequencyStateTypeId\n    readonly occurrences: ReadonlyMap<string, number>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Gauge<in out A extends (number | bigint)> extends MetricState<MetricKeyType.MetricKeyType.Gauge<A>> {\n    readonly [GaugeStateTypeId]: GaugeStateTypeId\n    readonly value: A\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Histogram extends MetricState<MetricKeyType.MetricKeyType.Histogram> {\n    readonly [HistogramStateTypeId]: HistogramStateTypeId\n    readonly buckets: ReadonlyArray<readonly [number, number]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Summary extends MetricState<MetricKeyType.MetricKeyType.Summary> {\n    readonly [SummaryStateTypeId]: SummaryStateTypeId\n    readonly error: number\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in A> {\n    readonly [MetricStateTypeId]: {\n      readonly _A: Types.Contravariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: number): MetricState.Counter<number>\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: bigint): MetricState.Counter<bigint>\n} = internal.counter\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (occurrences: ReadonlyMap<string, number>) => MetricState.Frequency = internal.frequency\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: number): MetricState.Gauge<number>\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: bigint): MetricState.Gauge<bigint>\n} = internal.gauge\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (\n  options: {\n    readonly buckets: ReadonlyArray<readonly [number, number]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n) => MetricState.Histogram = internal.histogram\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly error: number\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n) => MetricState.Summary = internal.summary\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricState: (u: unknown) => u is MetricState.Counter<number | bigint> = internal.isMetricState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isCounterState: (u: unknown) => u is MetricState.Counter<number | bigint> = internal.isCounterState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isFrequencyState: (u: unknown) => u is MetricState.Frequency = internal.isFrequencyState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isGaugeState: (u: unknown) => u is MetricState.Gauge<number | bigint> = internal.isGaugeState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHistogramState: (u: unknown) => u is MetricState.Histogram = internal.isHistogramState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSummaryState: (u: unknown) => u is MetricState.Summary = internal.isSummaryState\n","/**\n * @since 1.0.0\n */\nimport type { MetricProducer, MetricReader } from \"@opentelemetry/sdk-metrics\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport type { DurationInput } from \"effect/Duration\"\nimport type * as Effect from \"effect/Effect\"\nimport type { LazyArg } from \"effect/Function\"\nimport type { Layer } from \"effect/Layer\"\nimport type * as Scope from \"effect/Scope\"\nimport * as internal from \"./internal/metrics.js\"\nimport type { Resource } from \"./Resource.js\"\n\n/**\n * @since 1.0.0\n * @category producer\n */\nexport const makeProducer: Effect.Effect<MetricProducer, never, Resource> = internal.makeProducer\n\n/**\n * @since 1.0.0\n * @category producer\n */\nexport const registerProducer: (\n  self: MetricProducer,\n  metricReader: LazyArg<MetricReader | NonEmptyReadonlyArray<MetricReader>>\n) => Effect.Effect<Array<any>, never, Scope.Scope> = internal.registerProducer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layer: (\n  evaluate: LazyArg<MetricReader | NonEmptyReadonlyArray<MetricReader>>,\n  options?: {\n    readonly shutdownTimeout?:\n      | DurationInput\n      | undefined\n  }\n) => Layer<never, never, Resource> = internal.layer\n","/**\n * @since 1.0.0\n */\nimport type * as Otel from \"@opentelemetry/api\"\nimport type { NoSuchElementException } from \"effect/Cause\"\nimport type { Tag } from \"effect/Context\"\nimport type { Effect } from \"effect/Effect\"\nimport type { Layer } from \"effect/Layer\"\nimport type { ExternalSpan, ParentSpan, Tracer as EffectTracer } from \"effect/Tracer\"\nimport * as internal from \"./internal/tracer.js\"\nimport type { Resource } from \"./Resource.js\"\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: Effect<EffectTracer, never, OtelTracer> = internal.make\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeExternalSpan: (\n  options: {\n    readonly traceId: string\n    readonly spanId: string\n    readonly traceFlags?: number | undefined\n    readonly traceState?: string | Otel.TraceState | undefined\n  }\n) => ExternalSpan = internal.makeExternalSpan\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const currentOtelSpan: Effect<Otel.Span, NoSuchElementException> = internal.currentOtelSpan\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWithoutOtelTracer: Layer<never, never, OtelTracer> = internal.layerWithoutOtelTracer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layer: Layer<OtelTracer, never, Resource | OtelTracerProvider> = internal.layer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerGlobal: Layer<OtelTracer, never, Resource> = internal.layerGlobal\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerTracer: Layer<OtelTracer, never, Resource | OtelTracerProvider> = internal.layerTracer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerGlobalTracer: Layer<OtelTracer, never, Resource> = internal.layerGlobalTracer\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface OtelTracerProvider {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const OtelTracerProvider: Tag<OtelTracerProvider, Otel.TracerProvider> = internal.TracerProvider\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface OtelTracer {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const OtelTracer: Tag<OtelTracer, Otel.Tracer> = internal.Tracer\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface OtelTraceFlags {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const OtelTraceFlags: Tag<OtelTraceFlags, Otel.TraceFlags> = internal.traceFlagsTag\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface OtelTraceState {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const OtelTraceState: Tag<OtelTraceState, Otel.TraceState> = internal.traceStateTag\n\n/**\n * Set the effect's parent span from the given opentelemetry `SpanContext`.\n *\n * This is handy when you set up OpenTelemetry outside of Effect and want to\n * attach to a parent span.\n *\n * @since 1.0.0\n * @category propagation\n */\nexport const withSpanContext: {\n  /**\n   * Set the effect's parent span from the given opentelemetry `SpanContext`.\n   *\n   * This is handy when you set up OpenTelemetry outside of Effect and want to\n   * attach to a parent span.\n   *\n   * @since 1.0.0\n   * @category propagation\n   */\n  (spanContext: Otel.SpanContext): <A, E, R>(\n    effect: Effect<A, E, R>\n  ) => Effect<A, E, Exclude<R, ParentSpan>>\n  /**\n   * Set the effect's parent span from the given opentelemetry `SpanContext`.\n   *\n   * This is handy when you set up OpenTelemetry outside of Effect and want to\n   * attach to a parent span.\n   *\n   * @since 1.0.0\n   * @category propagation\n   */\n  <A, E, R>(effect: Effect<A, E, R>, spanContext: Otel.SpanContext): Effect<A, E, Exclude<R, ParentSpan>>\n} = internal.withSpanContext\n","/**\n * @since 1.0.0\n */\nimport type * as KeyValueStore from \"@effect/platform/KeyValueStore\"\nimport type * as Layer from \"effect/Layer\"\nimport * as internal from \"./internal/keyValueStore.js\"\n\n/**\n * Creates a KeyValueStore layer that uses the browser's localStorage api. Values are stored between sessions.\n *\n * @since 1.0.0\n * @category models\n */\nexport const layerLocalStorage: Layer.Layer<KeyValueStore.KeyValueStore> = internal.layerLocalStorage\n\n/**\n * Creates a KeyValueStore layer that uses the browser's sessionStorage api. Values are stored only for the current session.\n *\n * @since 1.0.0\n * @category models\n */\nexport const layerSessionStorage: Layer.Layer<KeyValueStore.KeyValueStore> = internal.layerSessionStorage\n","/**\n * @since 1.0.0\n */\nimport type * as OtelApi from \"@opentelemetry/api\"\nimport * as Resources from \"@opentelemetry/resources\"\nimport * as OtelSemConv from \"@opentelemetry/semantic-conventions\"\nimport * as Arr from \"effect/Array\"\nimport * as Config from \"effect/Config\"\nimport { GenericTag } from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { pipe } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\n\n/**\n * @since 1.0.0\n * @category identifier\n */\nexport interface Resource {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tag\n */\nexport const Resource = GenericTag<Resource, Resources.Resource>(\"@effect/opentelemetry/Resource\")\n\n/**\n * @since 1.0.0\n * @category layer\n */\nexport const layer = (config: {\n  readonly serviceName: string\n  readonly serviceVersion?: string\n  readonly attributes?: OtelApi.Attributes\n}) =>\n  Layer.succeed(\n    Resource,\n    Resources.resourceFromAttributes(configToAttributes(config))\n  )\n\n/**\n * @since 1.0.0\n * @category config\n */\nexport const configToAttributes = (options: {\n  readonly serviceName: string\n  readonly serviceVersion?: string\n  readonly attributes?: OtelApi.Attributes\n}): Record<string, string> => {\n  const attributes: Record<string, string> = {\n    ...(options.attributes ?? undefined),\n    [OtelSemConv.ATTR_SERVICE_NAME]: options.serviceName,\n    [OtelSemConv.ATTR_TELEMETRY_SDK_NAME]: \"@effect/opentelemetry\",\n    [OtelSemConv.ATTR_TELEMETRY_SDK_LANGUAGE]: typeof (globalThis as any).document === \"undefined\"\n      ? OtelSemConv.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS\n      : OtelSemConv.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS\n  }\n  if (options.serviceVersion) {\n    attributes[OtelSemConv.ATTR_SERVICE_VERSION] = options.serviceVersion\n  }\n  return attributes\n}\n\n/**\n * @since 1.0.0\n * @category layer\n */\nexport const layerFromEnv = (\n  additionalAttributes?:\n    | OtelApi.Attributes\n    | undefined\n): Layer.Layer<Resource> =>\n  Layer.effect(\n    Resource,\n    Effect.gen(function*() {\n      const serviceName = yield* pipe(Config.string(\"OTEL_SERVICE_NAME\"), Config.option, Effect.orDie)\n      const attributes = yield* pipe(\n        Config.string(\"OTEL_RESOURCE_ATTRIBUTES\"),\n        Config.withDefault(\"\"),\n        Config.map((s) => {\n          const attrs = s.split(\",\")\n          return Arr.reduce(attrs, {} as OtelApi.Attributes, (acc, attr) => {\n            const parts = attr.split(\"=\")\n            if (parts.length !== 2) {\n              return acc\n            }\n            acc[parts[0].trim()] = parts[1].trim()\n            return acc\n          })\n        }),\n        Effect.orDie\n      )\n      if (serviceName._tag === \"Some\") {\n        attributes[OtelSemConv.ATTR_SERVICE_NAME] = serviceName.value\n      }\n      if (additionalAttributes) {\n        Object.assign(attributes, additionalAttributes)\n      }\n      return Resources.resourceFromAttributes(attributes)\n    })\n  )\n\n/**\n * @since 2.0.0\n * @category layer\n */\nexport const layerEmpty = Layer.succeed(\n  Resource,\n  Resources.emptyResource()\n)\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OTLPExporterNodeConfigBase } from './legacy-node-configuration';\nimport { diag } from '@opentelemetry/api';\nimport { wrapStaticHeadersInFunction } from './shared-configuration';\nimport {\n  getNodeHttpConfigurationDefaults,\n  HttpAgentFactory,\n  mergeOtlpNodeHttpConfigurationWithDefaults,\n  OtlpNodeHttpConfiguration,\n} from './otlp-node-http-configuration';\nimport { httpAgentFactoryFromOptions } from '../index-node-http';\nimport { getNodeHttpConfigurationFromEnvironment } from './otlp-node-http-env-configuration';\n\nfunction convertLegacyAgentOptions(\n  config: OTLPExporterNodeConfigBase\n): HttpAgentFactory | undefined {\n  if (typeof config.httpAgentOptions === 'function') {\n    return config.httpAgentOptions;\n  }\n\n  let legacy = config.httpAgentOptions;\n  if (config.keepAlive != null) {\n    legacy = { keepAlive: config.keepAlive, ...legacy };\n  }\n\n  if (legacy != null) {\n    return httpAgentFactoryFromOptions(legacy);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @deprecated this will be removed in 2.0\n * @param config\n * @param signalIdentifier\n * @param signalResourcePath\n * @param requiredHeaders\n */\nexport function convertLegacyHttpOptions(\n  config: OTLPExporterNodeConfigBase,\n  signalIdentifier: string,\n  signalResourcePath: string,\n  requiredHeaders: Record<string, string>\n): OtlpNodeHttpConfiguration {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((config as any).metadata) {\n    diag.warn('Metadata cannot be set when using http');\n  }\n\n  return mergeOtlpNodeHttpConfigurationWithDefaults(\n    {\n      url: config.url,\n      headers: wrapStaticHeadersInFunction(config.headers),\n      concurrencyLimit: config.concurrencyLimit,\n      timeoutMillis: config.timeoutMillis,\n      compression: config.compression,\n      agentFactory: convertLegacyAgentOptions(config),\n    },\n    getNodeHttpConfigurationFromEnvironment(\n      signalIdentifier,\n      signalResourcePath\n    ),\n    getNodeHttpConfigurationDefaults(requiredHeaders, signalResourcePath)\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as http from 'http';\nimport type * as https from 'https';\nimport * as zlib from 'zlib';\nimport { Readable } from 'stream';\nimport { HttpRequestParameters } from './http-transport-types';\nimport { ExportResponse } from '../export-response';\nimport {\n  isExportRetryable,\n  parseRetryAfterToMills,\n} from '../is-export-retryable';\nimport { OTLPExporterError } from '../types';\n\n/**\n * Sends data using http\n * @param request\n * @param params\n * @param agent\n * @param data\n * @param onDone\n * @param timeoutMillis\n */\nexport function sendWithHttp(\n  request: typeof https.request | typeof http.request,\n  params: HttpRequestParameters,\n  agent: http.Agent | https.Agent,\n  data: Uint8Array,\n  onDone: (response: ExportResponse) => void,\n  timeoutMillis: number\n): void {\n  const parsedUrl = new URL(params.url);\n\n  const options: http.RequestOptions | https.RequestOptions = {\n    hostname: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.pathname,\n    method: 'POST',\n    headers: {\n      ...params.headers(),\n    },\n    agent: agent,\n  };\n\n  const req = request(options, (res: http.IncomingMessage) => {\n    const responseData: Buffer[] = [];\n    res.on('data', chunk => responseData.push(chunk));\n\n    res.on('end', () => {\n      if (res.statusCode && res.statusCode < 299) {\n        onDone({\n          status: 'success',\n          data: Buffer.concat(responseData),\n        });\n      } else if (res.statusCode && isExportRetryable(res.statusCode)) {\n        onDone({\n          status: 'retryable',\n          retryInMillis: parseRetryAfterToMills(res.headers['retry-after']),\n        });\n      } else {\n        const error = new OTLPExporterError(\n          res.statusMessage,\n          res.statusCode,\n          Buffer.concat(responseData).toString()\n        );\n        onDone({\n          status: 'failure',\n          error,\n        });\n      }\n    });\n  });\n\n  req.setTimeout(timeoutMillis, () => {\n    req.destroy();\n    onDone({\n      status: 'failure',\n      error: new Error('Request Timeout'),\n    });\n  });\n\n  req.on('error', (error: Error) => {\n    onDone({\n      status: 'failure',\n      error,\n    });\n  });\n\n  compressAndSend(req, params.compression, data, (error: Error) => {\n    onDone({\n      status: 'failure',\n      error,\n    });\n  });\n}\n\nexport function compressAndSend(\n  req: http.ClientRequest,\n  compression: 'gzip' | 'none',\n  data: Uint8Array,\n  onError: (error: Error) => void\n) {\n  let dataStream = readableFromUint8Array(data);\n\n  if (compression === 'gzip') {\n    req.setHeader('Content-Encoding', 'gzip');\n    dataStream = dataStream\n      .on('error', onError)\n      .pipe(zlib.createGzip())\n      .on('error', onError);\n  }\n\n  dataStream.pipe(req).on('error', onError);\n}\n\nfunction readableFromUint8Array(buff: string | Uint8Array): Readable {\n  const readable = new Readable();\n  readable.push(buff);\n  readable.push(null);\n\n  return readable;\n}\n","import type * as OtelApi from \"@opentelemetry/api\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport * as Inspectable from \"effect/Inspectable\"\n\nconst bigint1e9 = 1_000_000_000n\n\n/** @internal */\nexport const nanosToHrTime = (timestamp: bigint): OtelApi.HrTime => {\n  return [Number(timestamp / bigint1e9), Number(timestamp % bigint1e9)]\n}\n\n/** @internal */\nexport const recordToAttributes = (value: Record<string, unknown>): OtelApi.Attributes =>\n  Object.entries(value).reduce((acc, [key, value]) => {\n    acc[key] = unknownToAttributeValue(value)\n    return acc\n  }, {} as OtelApi.Attributes)\n\n/** @internal */\nexport const unknownToAttributeValue = (value: unknown): OtelApi.AttributeValue => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return value\n  } else if (typeof value === \"bigint\") {\n    return Number(value)\n  }\n  return Inspectable.toStringUnknown(value)\n}\n\n/** @internal */\nexport const isNonEmpty = <A>(a: A | ReadonlyArray<A> | undefined): a is A | NonEmptyReadonlyArray<A> =>\n  a !== undefined && !(Array.isArray(a) && a.length === 0)\n","/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type { DurationInput } from \"./Duration.js\"\nimport type { Effect } from \"./Effect.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport type * as HashMap from \"./HashMap.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as circular from \"./internal/layer/circular.js\"\nimport * as internalCircular from \"./internal/logger-circular.js\"\nimport * as internal from \"./internal/logger.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as List from \"./List.js\"\nimport type * as LogLevel from \"./LogLevel.js\"\nimport type * as LogSpan from \"./LogSpan.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Scope } from \"./Scope.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const LoggerTypeId: unique symbol = internal.LoggerTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type LoggerTypeId = typeof LoggerTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Logger<in Message, out Output> extends Logger.Variance<Message, Output>, Pipeable {\n  log(options: Logger.Options<Message>): Output\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Logger {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in Message, out Output> {\n    readonly [LoggerTypeId]: {\n      readonly _Message: Types.Contravariant<Message>\n      readonly _Output: Types.Covariant<Output>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Options<out Message> {\n    readonly fiberId: FiberId.FiberId\n    readonly logLevel: LogLevel.LogLevel\n    readonly message: Message\n    readonly cause: Cause.Cause<unknown>\n    readonly context: FiberRefs.FiberRefs\n    readonly spans: List.List<LogSpan.LogSpan>\n    readonly annotations: HashMap.HashMap<string, unknown>\n    readonly date: Date\n  }\n}\n\n/**\n * Creates a custom logger that formats log messages according to the provided\n * function.\n *\n * @example\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const logger = Logger.make(({ logLevel, message }) => {\n *   globalThis.console.log(`[${logLevel.label}] ${message}`)\n * })\n *\n * const task1 = Effect.logDebug(\"task1 done\")\n * const task2 = Effect.logDebug(\"task2 done\")\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"start\")\n *   yield* task1\n *   yield* task2\n *   yield* Effect.log(\"done\")\n * }).pipe(\n *   Logger.withMinimumLogLevel(LogLevel.Debug),\n *   Effect.provide(Logger.replace(Logger.defaultLogger, logger))\n * )\n *\n * Effect.runFork(program)\n * // [INFO] start\n * // [DEBUG] task1 done\n * // [DEBUG] task2 done\n * // [INFO] done\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output> =\n  internal.makeLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const add: <B>(logger: Logger<unknown, B>) => Layer.Layer<never> = circular.addLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const addEffect: <A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer.Layer<never, E, R> =\n  circular.addLoggerEffect\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const addScoped: <A, E, R>(\n  effect: Effect<Logger<unknown, A>, E, R>\n) => Layer.Layer<never, E, Exclude<R, Scope>> = circular.addLoggerScoped\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInput: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Message2>(f: (message: Message2) => Message): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, Message, Message2>(self: Logger<Message, Output>, f: (message: Message2) => Message): Logger<Message2, Output>\n} = internal.mapInput\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInputOptions: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Message2>(f: (options: Logger.Options<Message2>) => Logger.Options<Message>): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, Message, Message2>(\n   self: Logger<Message, Output>,\n   f: (options: Logger.Options<Message2>) => Logger.Options<Message>\n  ): Logger<Message2, Output>\n} = internal.mapInputOptions\n\n/**\n * Returns a version of this logger that only logs messages when the log level\n * satisfies the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterLogLevel: {\n  /**\n   * Returns a version of this logger that only logs messages when the log level\n   * satisfies the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>\n  /**\n   * Returns a version of this logger that only logs messages when the log level\n   * satisfies the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>\n} = internal.filterLogLevel\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, Output2>(f: (output: Output) => Output2): <Message>(self: Logger<Message, Output>) => Logger<Message, Output2>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Output, Output2>(self: Logger<Message, Output>, f: (output: Output) => Output2): Logger<Message, Output2>\n} = internal.map\n\n/**\n * Creates a batched logger that groups log messages together and processes them\n * in intervals.\n *\n * @example\n * ```ts\n * import { Console, Effect, Logger } from \"effect\"\n *\n * const LoggerLive = Logger.replaceScoped(\n *   Logger.defaultLogger,\n *   Logger.logfmtLogger.pipe(\n *     Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n *   )\n * )\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"one\")\n *   yield* Effect.log(\"two\")\n *   yield* Effect.log(\"three\")\n * }).pipe(Effect.provide(LoggerLive))\n *\n * Effect.runFork(program)\n * // BATCH [\n * // timestamp=... level=INFO fiber=#0 message=one\n * // timestamp=... level=INFO fiber=#0 message=two\n * // timestamp=... level=INFO fiber=#0 message=three\n * // ]\n * ```\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const batched: {\n  /**\n   * Creates a batched logger that groups log messages together and processes them\n   * in intervals.\n   *\n   * @example\n   * ```ts\n   * import { Console, Effect, Logger } from \"effect\"\n   *\n   * const LoggerLive = Logger.replaceScoped(\n   *   Logger.defaultLogger,\n   *   Logger.logfmtLogger.pipe(\n   *     Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n   *   )\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"one\")\n   *   yield* Effect.log(\"two\")\n   *   yield* Effect.log(\"three\")\n   * }).pipe(Effect.provide(LoggerLive))\n   *\n   * Effect.runFork(program)\n   * // BATCH [\n   * // timestamp=... level=INFO fiber=#0 message=one\n   * // timestamp=... level=INFO fiber=#0 message=two\n   * // timestamp=... level=INFO fiber=#0 message=three\n   * // ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, R>(\n   window: DurationInput,\n   f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>\n  ): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>\n  /**\n   * Creates a batched logger that groups log messages together and processes them\n   * in intervals.\n   *\n   * @example\n   * ```ts\n   * import { Console, Effect, Logger } from \"effect\"\n   *\n   * const LoggerLive = Logger.replaceScoped(\n   *   Logger.defaultLogger,\n   *   Logger.logfmtLogger.pipe(\n   *     Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n   *   )\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"one\")\n   *   yield* Effect.log(\"two\")\n   *   yield* Effect.log(\"three\")\n   * }).pipe(Effect.provide(LoggerLive))\n   *\n   * Effect.runFork(program)\n   * // BATCH [\n   * // timestamp=... level=INFO fiber=#0 message=one\n   * // timestamp=... level=INFO fiber=#0 message=two\n   * // timestamp=... level=INFO fiber=#0 message=three\n   * // ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Output, R>(\n   self: Logger<Message, Output>,\n   window: DurationInput,\n   f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>\n  ): Effect<Logger<Message, void>, never, Scope | R>\n} = fiberRuntime.batchedLogger\n\n/**\n * @since 2.0.0\n * @category console\n */\nexport const withConsoleLog: <M, O>(self: Logger<M, O>) => Logger<M, void> = fiberRuntime.loggerWithConsoleLog\n\n/**\n * Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method\n * based on the log level.\n *\n * @example\n * ```ts\n * import { Logger, Effect } from \"effect\"\n *\n * const loggerLayer = Logger.replace(\n *   Logger.defaultLogger,\n *   Logger.withLeveledConsole(Logger.stringLogger),\n * )\n *\n * Effect.gen(function* () {\n *   yield* Effect.logError(\"an error\")\n *   yield* Effect.logInfo(\"an info\")\n * }).pipe(Effect.provide(loggerLayer))\n * ```\n *\n * @since 3.8.0\n * @category console\n */\nexport const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void> = fiberRuntime.loggerWithLeveledLog\n\n/**\n * @since 2.0.0\n * @category console\n */\nexport const withConsoleError: <M, O>(self: Logger<M, O>) => Logger<M, void> = fiberRuntime.loggerWithConsoleError\n\n/**\n * A logger that does nothing in response to logging events.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const none: Logger<unknown, void> = internal.none\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const remove: <A>(logger: Logger<unknown, A>) => Layer.Layer<never> = circular.removeLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const replace: {\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <B>(that: Logger<unknown, B>): <A>(self: Logger<unknown, A>) => Layer.Layer<never>\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <A, B>(self: Logger<unknown, A>, that: Logger<unknown, B>): Layer.Layer<never>\n} = circular.replaceLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const replaceEffect: {\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, R>\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, R>\n} = circular.replaceLoggerEffect\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const replaceScoped: {\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, Exclude<R, Scope>>\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, Exclude<R, Scope>>\n} = circular.replaceLoggerScoped\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const simple: <A, B>(log: (a: A) => B) => Logger<A, B> = internal.simple\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <A>(value: A) => Logger<unknown, A> = internal.succeed\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const sync: <A>(evaluate: LazyArg<A>) => Logger<unknown, A> = internal.sync\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const test: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Message>(input: Message): <Output>(self: Logger<Message, Output>) => Output\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Message, Output>(self: Logger<Message, Output>, input: Message): Output\n} = internalCircular.test\n\n/**\n * Sets the minimum log level for subsequent logging operations, allowing\n * control over which log messages are displayed based on their severity.\n *\n * @example\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n *\n * Effect.runFork(program)\n * // timestamp=... level=DEBUG fiber=#0 message=message1\n * ```\n *\n * @since 2.0.0\n * @category context\n */\nexport const withMinimumLogLevel: {\n  /**\n   * Sets the minimum log level for subsequent logging operations, allowing\n   * control over which log messages are displayed based on their severity.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Logger, LogLevel } from \"effect\"\n   *\n   * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=DEBUG fiber=#0 message=message1\n   * ```\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Sets the minimum log level for subsequent logging operations, allowing\n   * control over which log messages are displayed based on their severity.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Logger, LogLevel } from \"effect\"\n   *\n   * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=DEBUG fiber=#0 message=message1\n   * ```\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>\n} = circular.withMinimumLogLevel\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nexport const withSpanAnnotations: <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Output> =\n  fiberRuntime.loggerWithSpanAnnotations\n\n/**\n * Combines this logger with the specified logger to produce a new logger that\n * logs to both this logger and that logger.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Combines this logger with the specified logger to produce a new logger that\n   * logs to both this logger and that logger.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>\n  /**\n   * Combines this logger with the specified logger to produce a new logger that\n   * logs to both this logger and that logger.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>\n} = internal.zip\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft: {\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output>\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output>\n} = internal.zipLeft\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight: {\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output2>\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output2>\n} = internal.zipRight\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const defaultLogger: Logger<unknown, void> = fiberRuntime.defaultLogger\n\n/**\n * The `jsonLogger` logger formats log entries as JSON objects, making them easy to\n * integrate with logging systems that consume JSON data.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.json)))\n * // {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const jsonLogger: Logger<unknown, string> = internal.jsonLogger\n\n/**\n * This logger outputs logs in a human-readable format that is easy to read\n * during development or in a production console.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n * // timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const logfmtLogger: Logger<unknown, string> = internal.logfmtLogger\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const stringLogger: Logger<unknown, string> = internal.stringLogger\n\n/**\n * The pretty logger utilizes the capabilities of the console API to generate\n * visually engaging and color-enhanced log outputs. This feature is\n * particularly useful for improving the readability of log messages during\n * development and debugging processes.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n * //         green --v                      v-- bold and cyan\n * // [07:51:54.434] INFO (#0) myspan=1ms: message1\n * //   message2\n * //    v-- bold\n * //   key2: value2\n * //   key1: value1\n * ```\n *\n * @since 3.5.0\n * @category constructors\n */\nexport const prettyLogger: (\n  options?: {\n    readonly colors?: \"auto\" | boolean | undefined\n    readonly stderr?: boolean | undefined\n    readonly formatDate?: ((date: Date) => string) | undefined\n    readonly mode?: \"browser\" | \"tty\" | \"auto\" | undefined\n  }\n) => Logger<unknown, void> = internal.prettyLogger\n\n/**\n * A default version of the pretty logger.\n *\n * @since 3.8.0\n * @category constructors\n */\nexport const prettyLoggerDefault: Logger<unknown, void> = internal.prettyLoggerDefault\n\n/**\n * The structured logger provides detailed log outputs, structured in a way that\n * retains comprehensive traceability of the events, suitable for deeper\n * analysis and troubleshooting.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.structured)))\n * // {\n * //   message: [ 'message1', 'message2' ],\n * //   logLevel: 'INFO',\n * //   timestamp: '2024-07-09T14:05:41.623Z',\n * //   cause: undefined,\n * //   annotations: { key2: 'value2', key1: 'value1' },\n * //   spans: { myspan: 0 },\n * //   fiberId: '#0'\n * // }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const structuredLogger: Logger<\n  unknown,\n  {\n    readonly logLevel: string\n    readonly fiberId: string\n    readonly timestamp: string\n    readonly message: unknown\n    readonly cause: string | undefined\n    readonly annotations: Record<string, unknown>\n    readonly spans: Record<string, number>\n  }\n> = internal.structuredLogger\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const tracerLogger: Logger<unknown, void> = fiberRuntime.tracerLogger\n\n/**\n * The `json` logger formats log entries as JSON objects, making them easy to\n * integrate with logging systems that consume JSON data.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.json)))\n * // {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const json: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.jsonLogger)\n\n/**\n * This logger outputs logs in a human-readable format that is easy to read\n * during development or in a production console.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n * // timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const logFmt: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.logFmtLogger)\n\n/**\n * The pretty logger utilizes the capabilities of the console API to generate\n * visually engaging and color-enhanced log outputs. This feature is\n * particularly useful for improving the readability of log messages during\n * development and debugging processes.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n * //         green --v                      v-- bold and cyan\n * // [07:51:54.434] INFO (#0) myspan=1ms: message1\n * //   message2\n * //    v-- bold\n * //   key2: value2\n * //   key1: value1\n * ```\n *\n * @since 3.5.0\n * @category constructors\n */\nexport const pretty: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.prettyLogger)\n\n/**\n * The structured logger provides detailed log outputs, structured in a way that\n * retains comprehensive traceability of the events, suitable for deeper\n * analysis and troubleshooting.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.structured)))\n * // {\n * //   message: [ 'message1', 'message2' ],\n * //   logLevel: 'INFO',\n * //   timestamp: '2024-07-09T14:05:41.623Z',\n * //   cause: undefined,\n * //   annotations: { key2: 'value2', key1: 'value1' },\n * //   spans: { myspan: 0 },\n * //   fiberId: '#0'\n * // }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const structured: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.structuredLogger)\n\n/**\n * Sets the minimum log level for logging operations, allowing control over\n * which log messages are displayed based on their severity.\n *\n * @example\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"Executing task...\")\n *   yield* Effect.sleep(\"100 millis\")\n *   console.log(\"task done\")\n * })\n *\n * // Logging disabled using a layer\n * Effect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))\n * // task done\n * ```\n *\n * @since 2.0.0\n * @category context\n */\nexport const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never> = circular.minimumLogLevel\n\n/**\n * Returns `true` if the specified value is a `Logger`, otherwise returns `false`.\n *\n * @since 1.0.0\n * @category guards\n */\nexport const isLogger: (u: unknown) => u is Logger<unknown, unknown> = internal.isLogger\n","import * as KeyValueStore from \"@effect/platform/KeyValueStore\"\n\n/** @internal  */\nexport const layerSessionStorage = KeyValueStore.layerStorage(() => sessionStorage)\n\n/** @internal  */\nexport const layerLocalStorage = KeyValueStore.layerStorage(() => localStorage)\n","/**\n * @since 1.0.0\n */\nimport type * as OtelApi from \"@opentelemetry/api\"\nimport type { LoggerProviderConfig, LogRecordProcessor } from \"@opentelemetry/sdk-logs\"\nimport type { MetricReader } from \"@opentelemetry/sdk-metrics\"\nimport type { SpanProcessor, TracerConfig } from \"@opentelemetry/sdk-trace-base\"\nimport { WebTracerProvider } from \"@opentelemetry/sdk-trace-web\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport * as Effect from \"effect/Effect\"\nimport { constant, type LazyArg } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport { isNonEmpty } from \"./internal/utils.js\"\nimport * as Logger from \"./Logger.js\"\nimport * as Metrics from \"./Metrics.js\"\nimport * as Resource from \"./Resource.js\"\nimport * as Tracer from \"./Tracer.js\"\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport interface Configuration {\n  readonly spanProcessor?: SpanProcessor | ReadonlyArray<SpanProcessor> | undefined\n  readonly tracerConfig?: Omit<TracerConfig, \"resource\">\n  readonly metricReader?: MetricReader | ReadonlyArray<MetricReader> | undefined\n  readonly logRecordProcessor?: LogRecordProcessor | ReadonlyArray<LogRecordProcessor> | undefined\n  readonly loggerProviderConfig?: Omit<LoggerProviderConfig, \"resource\"> | undefined\n  readonly resource: {\n    readonly serviceName: string\n    readonly serviceVersion?: string\n    readonly attributes?: OtelApi.Attributes\n  }\n}\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerTracerProvider = (\n  processor: SpanProcessor | NonEmptyReadonlyArray<SpanProcessor>,\n  config?: Omit<TracerConfig, \"resource\">\n): Layer.Layer<Tracer.OtelTracerProvider, never, Resource.Resource> =>\n  Layer.scoped(\n    Tracer.OtelTracerProvider,\n    Effect.flatMap(\n      Resource.Resource,\n      (resource) =>\n        Effect.acquireRelease(\n          Effect.sync(() => {\n            const provider = new WebTracerProvider({\n              ...(config ?? undefined),\n              resource,\n              spanProcessors: Array.isArray(processor) ? (processor as any) : [processor]\n            })\n            return provider\n          }),\n          (provider) => Effect.ignoreLogged(Effect.promise(() => provider.forceFlush().then(() => provider.shutdown())))\n        )\n    )\n  )\n\n/**\n * @since 1.0.0\n * @category layer\n */\nexport const layer: {\n  /**\n   * @since 1.0.0\n   * @category layer\n   */\n  (evaluate: LazyArg<Configuration>): Layer.Layer<Resource.Resource>\n  /**\n   * @since 1.0.0\n   * @category layer\n   */\n  <E, R>(evaluate: Effect.Effect<Configuration, E, R>): Layer.Layer<Resource.Resource, E, R>\n} = (\n  evaluate: LazyArg<Configuration> | Effect.Effect<Configuration, any, any>\n): Layer.Layer<Resource.Resource> =>\n  Layer.unwrapEffect(\n    Effect.map(\n      Effect.isEffect(evaluate)\n        ? evaluate as Effect.Effect<Configuration>\n        : Effect.sync(evaluate),\n      (config) => {\n        const ResourceLive = Resource.layer(config.resource)\n\n        const TracerLive = isNonEmpty(config.spanProcessor)\n          ? Layer.provide(Tracer.layer, layerTracerProvider(config.spanProcessor, config.tracerConfig))\n          : Layer.empty\n\n        const LoggerLive = isNonEmpty(config.logRecordProcessor)\n          ? Layer.provide(\n            Logger.layerLoggerAdd,\n            Logger.layerLoggerProvider(config.logRecordProcessor, config.loggerProviderConfig)\n          )\n          : Layer.empty\n\n        const MetricsLive = isNonEmpty(config.metricReader)\n          ? Metrics.layer(constant(config.metricReader))\n          : Layer.empty\n\n        return Layer.mergeAll(TracerLive, MetricsLive, LoggerLive).pipe(\n          Layer.provideMerge(ResourceLive)\n        )\n      }\n    )\n  )\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ISerializer } from '../../i-serializer';\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { IExportTraceServiceResponse } from '../export-response';\nimport { createExportTraceServiceRequest } from '../internal';\n\nexport const JsonTraceSerializer: ISerializer<\n  ReadableSpan[],\n  IExportTraceServiceResponse\n> = {\n  serializeRequest: (arg: ReadableSpan[]) => {\n    const request = createExportTraceServiceRequest(arg, {\n      useHex: true,\n      useLongBits: false,\n    });\n    const encoder = new TextEncoder();\n    return encoder.encode(JSON.stringify(request));\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    if (arg.length === 0) {\n      return {};\n    }\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(arg)) as IExportTraceServiceResponse;\n  },\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Link } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport type { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport type { Encoder } from '../common/utils';\nimport {\n  createInstrumentationScope,\n  createResource,\n  toAttributes,\n} from '../common/internal';\nimport {\n  EStatusCode,\n  IEvent,\n  IExportTraceServiceRequest,\n  ILink,\n  IResourceSpans,\n  IScopeSpans,\n  ISpan,\n} from './internal-types';\nimport { OtlpEncodingOptions } from '../common/internal-types';\nimport { getOtlpEncoder } from '../common/utils';\n\n// Span flags constants matching the OTLP specification\nconst SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 0x100;\nconst SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 0x200;\n\n/**\n * Builds the 32-bit span flags value combining the low 8-bit W3C TraceFlags\n * with the HAS_IS_REMOTE and IS_REMOTE bits according to the OTLP spec.\n */\nfunction buildSpanFlagsFrom(traceFlags: number, isRemote?: boolean): number {\n  // low 8 bits are W3C TraceFlags (e.g., sampled)\n  let flags = (traceFlags & 0xff) | SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK;\n  if (isRemote) {\n    flags |= SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK;\n  }\n  return flags;\n}\n\nexport function sdkSpanToOtlpSpan(span: ReadableSpan, encoder: Encoder): ISpan {\n  const ctx = span.spanContext();\n  const status = span.status;\n  const parentSpanId = span.parentSpanContext?.spanId\n    ? encoder.encodeSpanContext(span.parentSpanContext?.spanId)\n    : undefined;\n  return {\n    traceId: encoder.encodeSpanContext(ctx.traceId),\n    spanId: encoder.encodeSpanContext(ctx.spanId),\n    parentSpanId: parentSpanId,\n    traceState: ctx.traceState?.serialize(),\n    name: span.name,\n    // Span kind is offset by 1 because the API does not define a value for unset\n    kind: span.kind == null ? 0 : span.kind + 1,\n    startTimeUnixNano: encoder.encodeHrTime(span.startTime),\n    endTimeUnixNano: encoder.encodeHrTime(span.endTime),\n    attributes: toAttributes(span.attributes),\n    droppedAttributesCount: span.droppedAttributesCount,\n    events: span.events.map(event => toOtlpSpanEvent(event, encoder)),\n    droppedEventsCount: span.droppedEventsCount,\n    status: {\n      // API and proto enums share the same values\n      code: status.code as unknown as EStatusCode,\n      message: status.message,\n    },\n    links: span.links.map(link => toOtlpLink(link, encoder)),\n    droppedLinksCount: span.droppedLinksCount,\n    flags: buildSpanFlagsFrom(ctx.traceFlags, span.parentSpanContext?.isRemote),\n  };\n}\n\nexport function toOtlpLink(link: Link, encoder: Encoder): ILink {\n  return {\n    attributes: link.attributes ? toAttributes(link.attributes) : [],\n    spanId: encoder.encodeSpanContext(link.context.spanId),\n    traceId: encoder.encodeSpanContext(link.context.traceId),\n    traceState: link.context.traceState?.serialize(),\n    droppedAttributesCount: link.droppedAttributesCount || 0,\n    flags: buildSpanFlagsFrom(link.context.traceFlags, link.context.isRemote),\n  };\n}\n\nexport function toOtlpSpanEvent(\n  timedEvent: TimedEvent,\n  encoder: Encoder\n): IEvent {\n  return {\n    attributes: timedEvent.attributes\n      ? toAttributes(timedEvent.attributes)\n      : [],\n    name: timedEvent.name,\n    timeUnixNano: encoder.encodeHrTime(timedEvent.time),\n    droppedAttributesCount: timedEvent.droppedAttributesCount || 0,\n  };\n}\n\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function createExportTraceServiceRequest(\n  spans: ReadableSpan[],\n  options?: OtlpEncodingOptions\n): IExportTraceServiceRequest {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resourceSpans: spanRecordsToResourceSpans(spans, encoder),\n  };\n}\n\nfunction createResourceMap(readableSpans: ReadableSpan[]) {\n  const resourceMap: Map<Resource, Map<string, ReadableSpan[]>> = new Map();\n  for (const record of readableSpans) {\n    let ilsMap = resourceMap.get(record.resource);\n\n    if (!ilsMap) {\n      ilsMap = new Map();\n      resourceMap.set(record.resource, ilsMap);\n    }\n\n    // TODO this is duplicated in basic tracer. Consolidate on a common helper in core\n    const instrumentationScopeKey = `${record.instrumentationScope.name}@${\n      record.instrumentationScope.version || ''\n    }:${record.instrumentationScope.schemaUrl || ''}`;\n    let records = ilsMap.get(instrumentationScopeKey);\n\n    if (!records) {\n      records = [];\n      ilsMap.set(instrumentationScopeKey, records);\n    }\n\n    records.push(record);\n  }\n\n  return resourceMap;\n}\n\nfunction spanRecordsToResourceSpans(\n  readableSpans: ReadableSpan[],\n  encoder: Encoder\n): IResourceSpans[] {\n  const resourceMap = createResourceMap(readableSpans);\n  const out: IResourceSpans[] = [];\n\n  const entryIterator = resourceMap.entries();\n  let entry = entryIterator.next();\n  while (!entry.done) {\n    const [resource, ilmMap] = entry.value;\n    const scopeResourceSpans: IScopeSpans[] = [];\n    const ilmIterator = ilmMap.values();\n    let ilmEntry = ilmIterator.next();\n    while (!ilmEntry.done) {\n      const scopeSpans = ilmEntry.value;\n      if (scopeSpans.length > 0) {\n        const spans = scopeSpans.map(readableSpan =>\n          sdkSpanToOtlpSpan(readableSpan, encoder)\n        );\n\n        scopeResourceSpans.push({\n          scope: createInstrumentationScope(scopeSpans[0].instrumentationScope),\n          spans: spans,\n          schemaUrl: scopeSpans[0].instrumentationScope.schemaUrl,\n        });\n      }\n      ilmEntry = ilmIterator.next();\n    }\n    const processedResource = createResource(resource);\n    const transformedSpans: IResourceSpans = {\n      resource: processedResource,\n      scopeSpans: scopeResourceSpans,\n      schemaUrl: processedResource.schemaUrl,\n    };\n\n    out.push(transformedSpans);\n    entry = entryIterator.next();\n  }\n\n  return out;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n","/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport type * as Layer from \"effect/Layer\"\nimport type { HttpClient } from \"./HttpClient.js\"\nimport * as internal from \"./internal/fetchHttpClient.js\"\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class Fetch extends Context.Tag(internal.fetchTagKey)<Fetch, typeof globalThis.fetch>() {}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class RequestInit extends Context.Tag(internal.requestInitTagKey)<RequestInit, globalThis.RequestInit>() {}\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layer: Layer.Layer<HttpClient> = internal.layer\n","/**\n * @since 1.0.0\n */\nimport * as Otel from \"@opentelemetry/sdk-logs\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport * as Arr from \"effect/Array\"\nimport * as Context from \"effect/Context\"\nimport type { DurationInput } from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as FiberId from \"effect/FiberId\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberRefs from \"effect/FiberRefs\"\nimport * as Layer from \"effect/Layer\"\nimport * as Logger from \"effect/Logger\"\nimport * as Tracer from \"effect/Tracer\"\nimport { unknownToAttributeValue } from \"./internal/utils.js\"\nimport { Resource } from \"./Resource.js\"\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class OtelLoggerProvider extends Context.Tag(\"@effect/opentelemetry/Logger/OtelLoggerProvider\")<\n  OtelLoggerProvider,\n  Otel.LoggerProvider\n>() {}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: Effect.Effect<\n  Logger.Logger<unknown, void>,\n  never,\n  OtelLoggerProvider\n> = Effect.gen(function*() {\n  const loggerProvider = yield* OtelLoggerProvider\n  const clock = yield* Effect.clock\n  const otelLogger = loggerProvider.getLogger(\"@effect/opentelemetry\")\n\n  return Logger.make((options) => {\n    const now = options.date.getTime()\n\n    const attributes: Record<string, any> = {\n      fiberId: FiberId.threadName(options.fiberId)\n    }\n\n    const maybeSpan = Context.getOption(\n      FiberRefs.getOrDefault(options.context, FiberRef.currentContext),\n      Tracer.ParentSpan\n    )\n\n    if (maybeSpan._tag === \"Some\") {\n      attributes.spanId = maybeSpan.value.spanId\n      attributes.traceId = maybeSpan.value.traceId\n    }\n\n    for (const [key, value] of options.annotations) {\n      attributes[key] = unknownToAttributeValue(value)\n    }\n    for (const span of options.spans) {\n      attributes[`logSpan.${span.label}`] = `${now - span.startTime}ms`\n    }\n\n    const message = Arr.ensure(options.message).map(unknownToAttributeValue)\n    otelLogger.emit({\n      body: message.length === 1 ? message[0] : message,\n      severityText: options.logLevel.label,\n      severityNumber: options.logLevel.ordinal,\n      timestamp: options.date,\n      observedTimestamp: clock.unsafeCurrentTimeMillis(),\n      attributes\n    })\n  })\n})\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerLoggerAdd: Layer.Layer<\n  never,\n  never,\n  OtelLoggerProvider\n> = Logger.addEffect(make)\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerLoggerReplace: Layer.Layer<\n  never,\n  never,\n  OtelLoggerProvider\n> = Logger.replaceEffect(Logger.defaultLogger, make)\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerLoggerProvider = (\n  processor: Otel.LogRecordProcessor | NonEmptyReadonlyArray<Otel.LogRecordProcessor>,\n  config?: Omit<Otel.LoggerProviderConfig, \"resource\"> & {\n    readonly shutdownTimeout?: DurationInput | undefined\n  }\n): Layer.Layer<OtelLoggerProvider, never, Resource> =>\n  Layer.scoped(\n    OtelLoggerProvider,\n    Effect.flatMap(Resource, (resource) =>\n      Effect.acquireRelease(\n        Effect.sync(() =>\n          new Otel.LoggerProvider({\n            ...(config ?? undefined),\n            processors: Arr.ensure(processor),\n            resource\n          })\n        ),\n        (provider) =>\n          Effect.promise(\n            () => provider.forceFlush().then(() => provider.shutdown())\n          ).pipe(\n            Effect.ignoreLogged,\n            Effect.interruptible,\n            Effect.timeoutOption(config?.shutdownTimeout ?? 3000)\n          )\n      ))\n  )\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Fixed64,\n  IInstrumentationScope,\n  IKeyValue,\n  Resource,\n} from '../common/internal-types';\n\n/** Properties of an ExportMetricsServiceRequest. */\nexport interface IExportMetricsServiceRequest {\n  /** ExportMetricsServiceRequest resourceMetrics */\n  resourceMetrics: IResourceMetrics[];\n}\n\n/** Properties of a ResourceMetrics. */\nexport interface IResourceMetrics {\n  /** ResourceMetrics resource */\n  resource?: Resource;\n\n  /** ResourceMetrics scopeMetrics */\n  scopeMetrics: IScopeMetrics[];\n\n  /** ResourceMetrics schemaUrl */\n  schemaUrl?: string;\n}\n\n/** Properties of an IScopeMetrics. */\nexport interface IScopeMetrics {\n  /** ScopeMetrics scope */\n  scope?: IInstrumentationScope;\n\n  /** ScopeMetrics metrics */\n  metrics: IMetric[];\n\n  /** ScopeMetrics schemaUrl */\n  schemaUrl?: string;\n}\n\n/** Properties of a Metric. */\nexport interface IMetric {\n  /** Metric name */\n  name: string;\n\n  /** Metric description */\n  description?: string;\n\n  /** Metric unit */\n  unit?: string;\n\n  /** Metric gauge */\n  gauge?: IGauge;\n\n  /** Metric sum */\n  sum?: ISum;\n\n  /** Metric histogram */\n  histogram?: IHistogram;\n\n  /** Metric exponentialHistogram */\n  exponentialHistogram?: IExponentialHistogram;\n\n  /** Metric summary */\n  summary?: ISummary;\n}\n\n/** Properties of a Gauge. */\nexport interface IGauge {\n  /** Gauge dataPoints */\n  dataPoints: INumberDataPoint[];\n}\n\n/** Properties of a Sum. */\nexport interface ISum {\n  /** Sum dataPoints */\n  dataPoints: INumberDataPoint[];\n\n  /** Sum aggregationTemporality */\n  aggregationTemporality: EAggregationTemporality;\n\n  /** Sum isMonotonic */\n  isMonotonic?: boolean | null;\n}\n\n/** Properties of a Histogram. */\nexport interface IHistogram {\n  /** Histogram dataPoints */\n  dataPoints: IHistogramDataPoint[];\n\n  /** Histogram aggregationTemporality */\n  aggregationTemporality?: EAggregationTemporality;\n}\n\n/** Properties of an ExponentialHistogram. */\nexport interface IExponentialHistogram {\n  /** ExponentialHistogram dataPoints */\n  dataPoints: IExponentialHistogramDataPoint[];\n\n  /** ExponentialHistogram aggregationTemporality */\n  aggregationTemporality?: EAggregationTemporality;\n}\n\n/** Properties of a Summary. */\nexport interface ISummary {\n  /** Summary dataPoints */\n  dataPoints: ISummaryDataPoint[];\n}\n\n/** Properties of a NumberDataPoint. */\nexport interface INumberDataPoint {\n  /** NumberDataPoint attributes */\n  attributes: IKeyValue[];\n\n  /** NumberDataPoint startTimeUnixNano */\n  startTimeUnixNano?: Fixed64;\n\n  /** NumberDataPoint timeUnixNano */\n  timeUnixNano?: Fixed64;\n\n  /** NumberDataPoint asDouble */\n  asDouble?: number | null;\n\n  /** NumberDataPoint asInt */\n  asInt?: number;\n\n  /** NumberDataPoint exemplars */\n  exemplars?: IExemplar[];\n\n  /** NumberDataPoint flags */\n  flags?: number;\n}\n\n/** Properties of a HistogramDataPoint. */\nexport interface IHistogramDataPoint {\n  /** HistogramDataPoint attributes */\n  attributes?: IKeyValue[];\n\n  /** HistogramDataPoint startTimeUnixNano */\n  startTimeUnixNano?: Fixed64;\n\n  /** HistogramDataPoint timeUnixNano */\n  timeUnixNano?: Fixed64;\n\n  /** HistogramDataPoint count */\n  count?: number;\n\n  /** HistogramDataPoint sum */\n  sum?: number;\n\n  /** HistogramDataPoint bucketCounts */\n  bucketCounts?: number[];\n\n  /** HistogramDataPoint explicitBounds */\n  explicitBounds?: number[];\n\n  /** HistogramDataPoint exemplars */\n  exemplars?: IExemplar[];\n\n  /** HistogramDataPoint flags */\n  flags?: number;\n\n  /** HistogramDataPoint min */\n  min?: number;\n\n  /** HistogramDataPoint max */\n  max?: number;\n}\n\n/** Properties of an ExponentialHistogramDataPoint. */\nexport interface IExponentialHistogramDataPoint {\n  /** ExponentialHistogramDataPoint attributes */\n  attributes?: IKeyValue[];\n\n  /** ExponentialHistogramDataPoint startTimeUnixNano */\n  startTimeUnixNano?: Fixed64;\n\n  /** ExponentialHistogramDataPoint timeUnixNano */\n  timeUnixNano?: Fixed64;\n\n  /** ExponentialHistogramDataPoint count */\n  count?: number;\n\n  /** ExponentialHistogramDataPoint sum */\n  sum?: number;\n\n  /** ExponentialHistogramDataPoint scale */\n  scale?: number;\n\n  /** ExponentialHistogramDataPoint zeroCount */\n  zeroCount?: number;\n\n  /** ExponentialHistogramDataPoint positive */\n  positive?: IBuckets;\n\n  /** ExponentialHistogramDataPoint negative */\n  negative?: IBuckets;\n\n  /** ExponentialHistogramDataPoint flags */\n  flags?: number;\n\n  /** ExponentialHistogramDataPoint exemplars */\n  exemplars?: IExemplar[];\n\n  /** ExponentialHistogramDataPoint min */\n  min?: number;\n\n  /** ExponentialHistogramDataPoint max */\n  max?: number;\n}\n\n/** Properties of a SummaryDataPoint. */\nexport interface ISummaryDataPoint {\n  /** SummaryDataPoint attributes */\n  attributes?: IKeyValue[];\n\n  /** SummaryDataPoint startTimeUnixNano */\n  startTimeUnixNano?: number;\n\n  /** SummaryDataPoint timeUnixNano */\n  timeUnixNano?: string;\n\n  /** SummaryDataPoint count */\n  count?: number;\n\n  /** SummaryDataPoint sum */\n  sum?: number;\n\n  /** SummaryDataPoint quantileValues */\n  quantileValues?: IValueAtQuantile[];\n\n  /** SummaryDataPoint flags */\n  flags?: number;\n}\n\n/** Properties of a ValueAtQuantile. */\nexport interface IValueAtQuantile {\n  /** ValueAtQuantile quantile */\n  quantile?: number;\n\n  /** ValueAtQuantile value */\n  value?: number;\n}\n\n/** Properties of a Buckets. */\nexport interface IBuckets {\n  /** Buckets offset */\n  offset?: number;\n\n  /** Buckets bucketCounts */\n  bucketCounts?: number[];\n}\n\n/** Properties of an Exemplar. */\nexport interface IExemplar {\n  /** Exemplar filteredAttributes */\n  filteredAttributes?: IKeyValue[];\n\n  /** Exemplar timeUnixNano */\n  timeUnixNano?: string;\n\n  /** Exemplar asDouble */\n  asDouble?: number;\n\n  /** Exemplar asInt */\n  asInt?: number;\n\n  /** Exemplar spanId */\n  spanId?: string | Uint8Array;\n\n  /** Exemplar traceId */\n  traceId?: string | Uint8Array;\n}\n\n/**\n * AggregationTemporality defines how a metric aggregator reports aggregated\n * values. It describes how those values relate to the time interval over\n * which they are aggregated.\n */\nexport const enum EAggregationTemporality {\n  /* UNSPECIFIED is the default AggregationTemporality, it MUST not be used. */\n  AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,\n\n  /** DELTA is an AggregationTemporality for a metric aggregator which reports\n  changes since last report time. Successive metrics contain aggregation of\n  values from continuous and non-overlapping intervals.\n\n  The values for a DELTA metric are based only on the time interval\n  associated with one measurement cycle. There is no dependency on\n  previous measurements like is the case for CUMULATIVE metrics.\n\n  For example, consider a system measuring the number of requests that\n  it receives and reports the sum of these requests every second as a\n  DELTA metric:\n\n  1. The system starts receiving at time=t_0.\n  2. A request is received, the system measures 1 request.\n  3. A request is received, the system measures 1 request.\n  4. A request is received, the system measures 1 request.\n  5. The 1 second collection cycle ends. A metric is exported for the\n      number of requests received over the interval of time t_0 to\n      t_0+1 with a value of 3.\n  6. A request is received, the system measures 1 request.\n  7. A request is received, the system measures 1 request.\n  8. The 1 second collection cycle ends. A metric is exported for the\n      number of requests received over the interval of time t_0+1 to\n      t_0+2 with a value of 2. */\n  AGGREGATION_TEMPORALITY_DELTA = 1,\n\n  /** CUMULATIVE is an AggregationTemporality for a metric aggregator which\n  reports changes since a fixed start time. This means that current values\n  of a CUMULATIVE metric depend on all previous measurements since the\n  start time. Because of this, the sender is required to retain this state\n  in some form. If this state is lost or invalidated, the CUMULATIVE metric\n  values MUST be reset and a new fixed start time following the last\n  reported measurement time sent MUST be used.\n\n  For example, consider a system measuring the number of requests that\n  it receives and reports the sum of these requests every second as a\n  CUMULATIVE metric:\n\n  1. The system starts receiving at time=t_0.\n  2. A request is received, the system measures 1 request.\n  3. A request is received, the system measures 1 request.\n  4. A request is received, the system measures 1 request.\n  5. The 1 second collection cycle ends. A metric is exported for the\n      number of requests received over the interval of time t_0 to\n      t_0+1 with a value of 3.\n  6. A request is received, the system measures 1 request.\n  7. A request is received, the system measures 1 request.\n  8. The 1 second collection cycle ends. A metric is exported for the\n      number of requests received over the interval of time t_0 to\n      t_0+2 with a value of 5.\n  9. The system experiences a fault and loses state.\n  10. The system recovers and resumes receiving at time=t_1.\n  11. A request is received, the system measures 1 request.\n  12. The 1 second collection cycle ends. A metric is exported for the\n      number of requests received over the interval of time t_1 to\n      t_0+1 with a value of 1.\n\n  Note: Even though, when reporting changes since last report time, using\n  CUMULATIVE is valid, it is not recommended. This may cause problems for\n  systems that do not use start_time to determine when the aggregation\n  value was reset (e.g. Prometheus). */\n  AGGREGATION_TEMPORALITY_CUMULATIVE = 2,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ISerializer } from '../../i-serializer';\nimport { ReadableLogRecord } from '@opentelemetry/sdk-logs';\nimport { createExportLogsServiceRequest } from '../internal';\nimport { IExportLogsServiceResponse } from '../export-response';\n\n/*\n * @experimental this serializer may receive breaking changes in minor versions, pin this package's version when using this constant\n */\nexport const JsonLogsSerializer: ISerializer<\n  ReadableLogRecord[],\n  IExportLogsServiceResponse\n> = {\n  serializeRequest: (arg: ReadableLogRecord[]) => {\n    const request = createExportLogsServiceRequest(arg, {\n      useHex: true,\n      useLongBits: false,\n    });\n    const encoder = new TextEncoder();\n    return encoder.encode(JSON.stringify(request));\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    if (arg.length === 0) {\n      return {};\n    }\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(arg)) as IExportLogsServiceResponse;\n  },\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//----------------------------------------------------------------------------------------------------------\n// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2\n//----------------------------------------------------------------------------------------------------------\n\n/**\n * ASP.NET Core exception middleware handling result.\n *\n * @example handled\n * @example unhandled\n */\nexport const ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = 'aspnetcore.diagnostics.exception.result' as const;\n\n/**\n * Enum value \"aborted\" for attribute {@link ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT}.\n *\n * Exception handling didn't run because the request was aborted.\n */\nexport const ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = \"aborted\" as const;\n\n/**\n * Enum value \"handled\" for attribute {@link ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT}.\n *\n * Exception was handled by the exception handling middleware.\n */\nexport const ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = \"handled\" as const;\n\n/**\n * Enum value \"skipped\" for attribute {@link ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT}.\n *\n * Exception handling was skipped because the response had started.\n */\nexport const ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = \"skipped\" as const;\n\n/**\n * Enum value \"unhandled\" for attribute {@link ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT}.\n *\n * Exception was not handled by the exception handling middleware.\n */\nexport const ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = \"unhandled\" as const;\n\n/**\n * Full type name of the [`IExceptionHandler`](https://learn.microsoft.com/dotnet/api/microsoft.aspnetcore.diagnostics.iexceptionhandler) implementation that handled the exception.\n *\n * @example Contoso.MyHandler\n */\nexport const ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = 'aspnetcore.diagnostics.handler.type' as const;\n\n/**\n * Rate limiting policy name.\n *\n * @example fixed\n * @example sliding\n * @example token\n */\nexport const ATTR_ASPNETCORE_RATE_LIMITING_POLICY = 'aspnetcore.rate_limiting.policy' as const;\n\n/**\n * Rate-limiting result, shows whether the lease was acquired or contains a rejection reason\n *\n * @example acquired\n * @example request_canceled\n */\nexport const ATTR_ASPNETCORE_RATE_LIMITING_RESULT = 'aspnetcore.rate_limiting.result' as const;\n\n/**\n * Enum value \"acquired\" for attribute {@link ATTR_ASPNETCORE_RATE_LIMITING_RESULT}.\n *\n * Lease was acquired\n */\nexport const ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = \"acquired\" as const;\n\n/**\n * Enum value \"endpoint_limiter\" for attribute {@link ATTR_ASPNETCORE_RATE_LIMITING_RESULT}.\n *\n * Lease request was rejected by the endpoint limiter\n */\nexport const ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = \"endpoint_limiter\" as const;\n\n/**\n * Enum value \"global_limiter\" for attribute {@link ATTR_ASPNETCORE_RATE_LIMITING_RESULT}.\n *\n * Lease request was rejected by the global limiter\n */\nexport const ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = \"global_limiter\" as const;\n\n/**\n * Enum value \"request_canceled\" for attribute {@link ATTR_ASPNETCORE_RATE_LIMITING_RESULT}.\n *\n * Lease request was canceled\n */\nexport const ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = \"request_canceled\" as const;\n\n/**\n * Flag indicating if request was handled by the application pipeline.\n *\n * @example true\n */\nexport const ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = 'aspnetcore.request.is_unhandled' as const;\n\n/**\n * A value that indicates whether the matched route is a fallback route.\n *\n * @example true\n */\nexport const ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = 'aspnetcore.routing.is_fallback' as const;\n\n/**\n * Match result - success or failure\n *\n * @example success\n * @example failure\n */\nexport const ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = 'aspnetcore.routing.match_status' as const;\n\n/**\n * Enum value \"failure\" for attribute {@link ATTR_ASPNETCORE_ROUTING_MATCH_STATUS}.\n *\n * Match failed\n */\nexport const ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = \"failure\" as const;\n\n/**\n * Enum value \"success\" for attribute {@link ATTR_ASPNETCORE_ROUTING_MATCH_STATUS}.\n *\n * Match succeeded\n */\nexport const ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = \"success\" as const;\n\n/**\n * A value that indicates whether the user is authenticated.\n *\n * @example true\n */\nexport const ATTR_ASPNETCORE_USER_IS_AUTHENTICATED = 'aspnetcore.user.is_authenticated' as const;\n\n/**\n * Client address - domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name.\n *\n * @example client.example.com\n * @example 10.1.2.80\n * @example /tmp/my.sock\n *\n * @note When observed from the server side, and when communicating through an intermediary, `client.address` **SHOULD** represent the client address behind any intermediaries,  for example proxies, if it's available.\n */\nexport const ATTR_CLIENT_ADDRESS = 'client.address' as const;\n\n/**\n * Client port number.\n *\n * @example 65123\n *\n * @note When observed from the server side, and when communicating through an intermediary, `client.port` **SHOULD** represent the client port behind any intermediaries,  for example proxies, if it's available.\n */\nexport const ATTR_CLIENT_PORT = 'client.port' as const;\n\n/**\n * The column number in `code.file.path` best representing the operation. It **SHOULD** point within the code unit named in `code.function.name`. This attribute **MUST NOT** be used on the Profile signal since the data is already captured in 'message Line'. This constraint is imposed to prevent redundancy and maintain data integrity.\n *\n * @example 16\n */\nexport const ATTR_CODE_COLUMN_NUMBER = 'code.column.number' as const;\n\n/**\n * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path). This attribute **MUST NOT** be used on the Profile signal since the data is already captured in 'message Function'. This constraint is imposed to prevent redundancy and maintain data integrity.\n *\n * @example \"/usr/local/MyApplication/content_root/app/index.php\"\n */\nexport const ATTR_CODE_FILE_PATH = 'code.file.path' as const;\n\n/**\n * The method or function fully-qualified name without arguments. The value should fit the natural representation of the language runtime, which is also likely the same used within `code.stacktrace` attribute value. This attribute **MUST NOT** be used on the Profile signal since the data is already captured in 'message Function'. This constraint is imposed to prevent redundancy and maintain data integrity.\n *\n * @example com.example.MyHttpService.serveRequest\n * @example GuzzleHttp\\\\Client::transfer\n * @example fopen\n *\n * @note Values and format depends on each language runtime, thus it is impossible to provide an exhaustive list of examples.\n * The values are usually the same (or prefixes of) the ones found in native stack trace representation stored in\n * `code.stacktrace` without information on arguments.\n *\n * Examples:\n *\n *   - Java method: `com.example.MyHttpService.serveRequest`\n *   - Java anonymous class method: `com.mycompany.Main$1.myMethod`\n *   - Java lambda method: `com.mycompany.Main$$Lambda/0x0000748ae4149c00.myMethod`\n *   - PHP function: `GuzzleHttp\\Client::transfer`\n *   - Go function: `github.com/my/repo/pkg.foo.func5`\n *   - Elixir: `OpenTelemetry.Ctx.new`\n *   - Erlang: `opentelemetry_ctx:new`\n *   - Rust: `playground::my_module::my_cool_func`\n *   - C function: `fopen`\n */\nexport const ATTR_CODE_FUNCTION_NAME = 'code.function.name' as const;\n\n/**\n * The line number in `code.file.path` best representing the operation. It **SHOULD** point within the code unit named in `code.function.name`. This attribute **MUST NOT** be used on the Profile signal since the data is already captured in 'message Line'. This constraint is imposed to prevent redundancy and maintain data integrity.\n *\n * @example 42\n */\nexport const ATTR_CODE_LINE_NUMBER = 'code.line.number' as const;\n\n/**\n * A stacktrace as a string in the natural representation for the language runtime. The representation is identical to [`exception.stacktrace`](/docs/exceptions/exceptions-spans.md#stacktrace-representation). This attribute **MUST NOT** be used on the Profile signal since the data is already captured in 'message Location'. This constraint is imposed to prevent redundancy and maintain data integrity.\n *\n * @example \"at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\\\\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\\\\n at com.example.GenerateTrace.main(GenerateTrace.java:5)\\\\n\"\n */\nexport const ATTR_CODE_STACKTRACE = 'code.stacktrace' as const;\n\n/**\n * The name of a collection (table, container) within the database.\n *\n * @example public.users\n * @example customers\n *\n * @note It is **RECOMMENDED** to capture the value as provided by the application\n * without attempting to do any case normalization.\n *\n * The collection name **SHOULD NOT** be extracted from `db.query.text`,\n * when the database system supports query text with multiple collections\n * in non-batch operations.\n *\n * For batch operations, if the individual operations are known to have the same\n * collection name then that collection name **SHOULD** be used.\n */\nexport const ATTR_DB_COLLECTION_NAME = 'db.collection.name' as const;\n\n/**\n * The name of the database, fully qualified within the server address and port.\n *\n * @example customers\n * @example test.users\n *\n * @note If a database system has multiple namespace components, they **SHOULD** be concatenated from the most general to the most specific namespace component, using `|` as a separator between the components. Any missing components (and their associated separators) **SHOULD** be omitted.\n * Semantic conventions for individual database systems **SHOULD** document what `db.namespace` means in the context of that system.\n * It is **RECOMMENDED** to capture the value as provided by the application without attempting to do any case normalization.\n */\nexport const ATTR_DB_NAMESPACE = 'db.namespace' as const;\n\n/**\n * The number of queries included in a batch operation.\n *\n * @example 2\n * @example 3\n * @example 4\n *\n * @note Operations are only considered batches when they contain two or more operations, and so `db.operation.batch.size` **SHOULD** never be `1`.\n */\nexport const ATTR_DB_OPERATION_BATCH_SIZE = 'db.operation.batch.size' as const;\n\n/**\n * The name of the operation or command being executed.\n *\n * @example findAndModify\n * @example HMSET\n * @example SELECT\n *\n * @note It is **RECOMMENDED** to capture the value as provided by the application\n * without attempting to do any case normalization.\n *\n * The operation name **SHOULD NOT** be extracted from `db.query.text`,\n * when the database system supports query text with multiple operations\n * in non-batch operations.\n *\n * If spaces can occur in the operation name, multiple consecutive spaces\n * **SHOULD** be normalized to a single space.\n *\n * For batch operations, if the individual operations are known to have the same operation name\n * then that operation name **SHOULD** be used prepended by `BATCH `,\n * otherwise `db.operation.name` **SHOULD** be `BATCH` or some other database\n * system specific term if more applicable.\n */\nexport const ATTR_DB_OPERATION_NAME = 'db.operation.name' as const;\n\n/**\n * Low cardinality summary of a database query.\n *\n * @example SELECT wuser_table\n * @example INSERT shipping_details SELECT orders\n * @example get user by id\n *\n * @note The query summary describes a class of database queries and is useful\n * as a grouping key, especially when analyzing telemetry for database\n * calls involving complex queries.\n *\n * Summary may be available to the instrumentation through\n * instrumentation hooks or other means. If it is not available, instrumentations\n * that support query parsing **SHOULD** generate a summary following\n * [Generating query summary](/docs/database/database-spans.md#generating-a-summary-of-the-query)\n * section.\n */\nexport const ATTR_DB_QUERY_SUMMARY = 'db.query.summary' as const;\n\n/**\n * The database query being executed.\n *\n * @example SELECT * FROM wuser_table where username = ?\n * @example SET mykey ?\n *\n * @note For sanitization see [Sanitization of `db.query.text`](/docs/database/database-spans.md#sanitization-of-dbquerytext).\n * For batch operations, if the individual operations are known to have the same query text then that query text **SHOULD** be used, otherwise all of the individual query texts **SHOULD** be concatenated with separator `; ` or some other database system specific separator if more applicable.\n * Parameterized query text **SHOULD NOT** be sanitized. Even though parameterized query text can potentially have sensitive data, by using a parameterized query the user is giving a strong signal that any sensitive data will be passed as parameter values, and the benefit to observability of capturing the static part of the query text by default outweighs the risk.\n */\nexport const ATTR_DB_QUERY_TEXT = 'db.query.text' as const;\n\n/**\n * Database response status code.\n *\n * @example 102\n * @example ORA-17002\n * @example 08P01\n * @example 404\n *\n * @note The status code returned by the database. Usually it represents an error code, but may also represent partial success, warning, or differentiate between various types of successful outcomes.\n * Semantic conventions for individual database systems **SHOULD** document what `db.response.status_code` means in the context of that system.\n */\nexport const ATTR_DB_RESPONSE_STATUS_CODE = 'db.response.status_code' as const;\n\n/**\n * The name of a stored procedure within the database.\n *\n * @example GetCustomer\n *\n * @note It is **RECOMMENDED** to capture the value as provided by the application\n * without attempting to do any case normalization.\n *\n * For batch operations, if the individual operations are known to have the same\n * stored procedure name then that stored procedure name **SHOULD** be used.\n */\nexport const ATTR_DB_STORED_PROCEDURE_NAME = 'db.stored_procedure.name' as const;\n\n/**\n * The database management system (DBMS) product as identified by the client instrumentation.\n *\n * @note The actual DBMS may differ from the one identified by the client. For example, when using PostgreSQL client libraries to connect to a CockroachDB, the `db.system.name` is set to `postgresql` based on the instrumentation's best knowledge.\n */\nexport const ATTR_DB_SYSTEM_NAME = 'db.system.name' as const;\n\n/**\n * Enum value \"mariadb\" for attribute {@link ATTR_DB_SYSTEM_NAME}.\n *\n * [MariaDB](https://mariadb.org/)\n */\nexport const DB_SYSTEM_NAME_VALUE_MARIADB = \"mariadb\" as const;\n\n/**\n * Enum value \"microsoft.sql_server\" for attribute {@link ATTR_DB_SYSTEM_NAME}.\n *\n * [Microsoft SQL Server](https://www.microsoft.com/sql-server)\n */\nexport const DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = \"microsoft.sql_server\" as const;\n\n/**\n * Enum value \"mysql\" for attribute {@link ATTR_DB_SYSTEM_NAME}.\n *\n * [MySQL](https://www.mysql.com/)\n */\nexport const DB_SYSTEM_NAME_VALUE_MYSQL = \"mysql\" as const;\n\n/**\n * Enum value \"postgresql\" for attribute {@link ATTR_DB_SYSTEM_NAME}.\n *\n * [PostgreSQL](https://www.postgresql.org/)\n */\nexport const DB_SYSTEM_NAME_VALUE_POSTGRESQL = \"postgresql\" as const;\n\n/**\n * Name of the garbage collector managed heap generation.\n *\n * @example gen0\n * @example gen1\n * @example gen2\n */\nexport const ATTR_DOTNET_GC_HEAP_GENERATION = 'dotnet.gc.heap.generation' as const;\n\n/**\n * Enum value \"gen0\" for attribute {@link ATTR_DOTNET_GC_HEAP_GENERATION}.\n *\n * Generation 0\n */\nexport const DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = \"gen0\" as const;\n\n/**\n * Enum value \"gen1\" for attribute {@link ATTR_DOTNET_GC_HEAP_GENERATION}.\n *\n * Generation 1\n */\nexport const DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = \"gen1\" as const;\n\n/**\n * Enum value \"gen2\" for attribute {@link ATTR_DOTNET_GC_HEAP_GENERATION}.\n *\n * Generation 2\n */\nexport const DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = \"gen2\" as const;\n\n/**\n * Enum value \"loh\" for attribute {@link ATTR_DOTNET_GC_HEAP_GENERATION}.\n *\n * Large Object Heap\n */\nexport const DOTNET_GC_HEAP_GENERATION_VALUE_LOH = \"loh\" as const;\n\n/**\n * Enum value \"poh\" for attribute {@link ATTR_DOTNET_GC_HEAP_GENERATION}.\n *\n * Pinned Object Heap\n */\nexport const DOTNET_GC_HEAP_GENERATION_VALUE_POH = \"poh\" as const;\n\n/**\n * Describes a class of error the operation ended with.\n *\n * @example timeout\n * @example java.net.UnknownHostException\n * @example server_certificate_invalid\n * @example 500\n *\n * @note The `error.type` **SHOULD** be predictable, and **SHOULD** have low cardinality.\n *\n * When `error.type` is set to a type (e.g., an exception type), its\n * canonical class name identifying the type within the artifact **SHOULD** be used.\n *\n * Instrumentations **SHOULD** document the list of errors they report.\n *\n * The cardinality of `error.type` within one instrumentation library **SHOULD** be low.\n * Telemetry consumers that aggregate data from multiple instrumentation libraries and applications\n * should be prepared for `error.type` to have high cardinality at query time when no\n * additional filters are applied.\n *\n * If the operation has completed successfully, instrumentations **SHOULD NOT** set `error.type`.\n *\n * If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),\n * it's **RECOMMENDED** to:\n *\n *   - Use a domain-specific attribute\n *   - Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.\n */\nexport const ATTR_ERROR_TYPE = 'error.type' as const;\n\n/**\n * Enum value \"_OTHER\" for attribute {@link ATTR_ERROR_TYPE}.\n *\n * A fallback error value to be used when the instrumentation doesn't define a custom value.\n */\nexport const ERROR_TYPE_VALUE_OTHER = \"_OTHER\" as const;\n\n/**\n * Indicates that the exception is escaping the scope of the span.\n *\n * @deprecated It's no longer recommended to record exceptions that are handled and do not escape the scope of a span.\n */\nexport const ATTR_EXCEPTION_ESCAPED = 'exception.escaped' as const;\n\n/**\n * The exception message.\n *\n * @example Division by zero\n * @example Can't convert 'int' object to str implicitly\n */\nexport const ATTR_EXCEPTION_MESSAGE = 'exception.message' as const;\n\n/**\n * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.\n *\n * @example \"Exception in thread \"main\" java.lang.RuntimeException: Test exception\\\\n at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\\\\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\\\\n at com.example.GenerateTrace.main(GenerateTrace.java:5)\\\\n\"\n */\nexport const ATTR_EXCEPTION_STACKTRACE = 'exception.stacktrace' as const;\n\n/**\n * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.\n *\n * @example java.net.ConnectException\n * @example OSError\n */\nexport const ATTR_EXCEPTION_TYPE = 'exception.type' as const;\n\n/**\n * HTTP request headers, `<key>` being the normalized HTTP Header name (lowercase), the value being the header values.\n *\n * @example [\"application/json\"]\n * @example [\"1.2.3.4\", \"1.2.3.5\"]\n *\n * @note Instrumentations **SHOULD** require an explicit configuration of which headers are to be captured.\n * Including all request headers can be a security risk - explicit configuration helps avoid leaking sensitive information.\n *\n * The `User-Agent` header is already captured in the `user_agent.original` attribute.\n * Users **MAY** explicitly configure instrumentations to capture them even though it is not recommended.\n *\n * The attribute value **MUST** consist of either multiple header values as an array of strings\n * or a single-item array containing a possibly comma-concatenated string, depending on the way\n * the HTTP library provides access to headers.\n *\n * Examples:\n *\n *   - A header `Content-Type: application/json` **SHOULD** be recorded as the `http.request.header.content-type`\n *     attribute with value `[\"application/json\"]`.\n *   - A header `X-Forwarded-For: 1.2.3.4, 1.2.3.5` **SHOULD** be recorded as the `http.request.header.x-forwarded-for`\n *     attribute with value `[\"1.2.3.4\", \"1.2.3.5\"]` or `[\"1.2.3.4, 1.2.3.5\"]` depending on the HTTP library.\n */\nexport const ATTR_HTTP_REQUEST_HEADER = (key: string) => `http.request.header.${key}`;\n\n/**\n * HTTP request method.\n *\n * @example GET\n * @example POST\n * @example HEAD\n *\n * @note HTTP request method value **SHOULD** be \"known\" to the instrumentation.\n * By default, this convention defines \"known\" methods as the ones listed in [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-methods)\n * and the PATCH method defined in [RFC5789](https://www.rfc-editor.org/rfc/rfc5789.html).\n *\n * If the HTTP request method is not known to instrumentation, it **MUST** set the `http.request.method` attribute to `_OTHER`.\n *\n * If the HTTP instrumentation could end up converting valid HTTP request methods to `_OTHER`, then it **MUST** provide a way to override\n * the list of known HTTP methods. If this override is done via environment variable, then the environment variable **MUST** be named\n * OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS and support a comma-separated list of case-sensitive known HTTP methods\n * (this list **MUST** be a full override of the default known method, it is not a list of known methods in addition to the defaults).\n *\n * HTTP method names are case-sensitive and `http.request.method` attribute value **MUST** match a known HTTP method name exactly.\n * Instrumentations for specific web frameworks that consider HTTP methods to be case insensitive, **SHOULD** populate a canonical equivalent.\n * Tracing instrumentations that do so, **MUST** also set `http.request.method_original` to the original value.\n */\nexport const ATTR_HTTP_REQUEST_METHOD = 'http.request.method' as const;\n\n/**\n * Enum value \"_OTHER\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * Any HTTP method that the instrumentation has no prior knowledge of.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_OTHER = \"_OTHER\" as const;\n\n/**\n * Enum value \"CONNECT\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * CONNECT method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_CONNECT = \"CONNECT\" as const;\n\n/**\n * Enum value \"DELETE\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * DELETE method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_DELETE = \"DELETE\" as const;\n\n/**\n * Enum value \"GET\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * GET method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_GET = \"GET\" as const;\n\n/**\n * Enum value \"HEAD\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * HEAD method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_HEAD = \"HEAD\" as const;\n\n/**\n * Enum value \"OPTIONS\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * OPTIONS method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_OPTIONS = \"OPTIONS\" as const;\n\n/**\n * Enum value \"PATCH\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * PATCH method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_PATCH = \"PATCH\" as const;\n\n/**\n * Enum value \"POST\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * POST method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_POST = \"POST\" as const;\n\n/**\n * Enum value \"PUT\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * PUT method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_PUT = \"PUT\" as const;\n\n/**\n * Enum value \"TRACE\" for attribute {@link ATTR_HTTP_REQUEST_METHOD}.\n *\n * TRACE method.\n */\nexport const HTTP_REQUEST_METHOD_VALUE_TRACE = \"TRACE\" as const;\n\n/**\n * Original HTTP method sent by the client in the request line.\n *\n * @example GeT\n * @example ACL\n * @example foo\n */\nexport const ATTR_HTTP_REQUEST_METHOD_ORIGINAL = 'http.request.method_original' as const;\n\n/**\n * The ordinal number of request resending attempt (for any reason, including redirects).\n *\n * @example 3\n *\n * @note The resend count **SHOULD** be updated each time an HTTP request gets resent by the client, regardless of what was the cause of the resending (e.g. redirection, authorization failure, 503 Server Unavailable, network issues, or any other).\n */\nexport const ATTR_HTTP_REQUEST_RESEND_COUNT = 'http.request.resend_count' as const;\n\n/**\n * HTTP response headers, `<key>` being the normalized HTTP Header name (lowercase), the value being the header values.\n *\n * @example [\"application/json\"]\n * @example [\"abc\", \"def\"]\n *\n * @note Instrumentations **SHOULD** require an explicit configuration of which headers are to be captured.\n * Including all response headers can be a security risk - explicit configuration helps avoid leaking sensitive information.\n *\n * Users **MAY** explicitly configure instrumentations to capture them even though it is not recommended.\n *\n * The attribute value **MUST** consist of either multiple header values as an array of strings\n * or a single-item array containing a possibly comma-concatenated string, depending on the way\n * the HTTP library provides access to headers.\n *\n * Examples:\n *\n *   - A header `Content-Type: application/json` header **SHOULD** be recorded as the `http.request.response.content-type`\n *     attribute with value `[\"application/json\"]`.\n *   - A header `My-custom-header: abc, def` header **SHOULD** be recorded as the `http.response.header.my-custom-header`\n *     attribute with value `[\"abc\", \"def\"]` or `[\"abc, def\"]` depending on the HTTP library.\n */\nexport const ATTR_HTTP_RESPONSE_HEADER = (key: string) => `http.response.header.${key}`;\n\n/**\n * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).\n *\n * @example 200\n */\nexport const ATTR_HTTP_RESPONSE_STATUS_CODE = 'http.response.status_code' as const;\n\n/**\n * The matched route, that is, the path template in the format used by the respective server framework.\n *\n * @example /users/:userID?\n * @example {controller}/{action}/{id?}\n *\n * @note **MUST NOT** be populated when this is not supported by the HTTP server framework as the route attribute should have low-cardinality and the URI path can NOT substitute it.\n * **SHOULD** include the [application root](/docs/http/http-spans.md#http-server-definitions) if there is one.\n */\nexport const ATTR_HTTP_ROUTE = 'http.route' as const;\n\n/**\n * Name of the garbage collector action.\n *\n * @example end of minor GC\n * @example end of major GC\n *\n * @note Garbage collector action is generally obtained via [GarbageCollectionNotificationInfo#getGcAction()](https://docs.oracle.com/en/java/javase/11/docs/api/jdk.management/com/sun/management/GarbageCollectionNotificationInfo.html#getGcAction()).\n */\nexport const ATTR_JVM_GC_ACTION = 'jvm.gc.action' as const;\n\n/**\n * Name of the garbage collector.\n *\n * @example G1 Young Generation\n * @example G1 Old Generation\n *\n * @note Garbage collector name is generally obtained via [GarbageCollectionNotificationInfo#getGcName()](https://docs.oracle.com/en/java/javase/11/docs/api/jdk.management/com/sun/management/GarbageCollectionNotificationInfo.html#getGcName()).\n */\nexport const ATTR_JVM_GC_NAME = 'jvm.gc.name' as const;\n\n/**\n * Name of the memory pool.\n *\n * @example G1 Old Gen\n * @example G1 Eden space\n * @example G1 Survivor Space\n *\n * @note Pool names are generally obtained via [MemoryPoolMXBean#getName()](https://docs.oracle.com/en/java/javase/11/docs/api/java.management/java/lang/management/MemoryPoolMXBean.html#getName()).\n */\nexport const ATTR_JVM_MEMORY_POOL_NAME = 'jvm.memory.pool.name' as const;\n\n/**\n * The type of memory.\n *\n * @example heap\n * @example non_heap\n */\nexport const ATTR_JVM_MEMORY_TYPE = 'jvm.memory.type' as const;\n\n/**\n * Enum value \"heap\" for attribute {@link ATTR_JVM_MEMORY_TYPE}.\n *\n * Heap memory.\n */\nexport const JVM_MEMORY_TYPE_VALUE_HEAP = \"heap\" as const;\n\n/**\n * Enum value \"non_heap\" for attribute {@link ATTR_JVM_MEMORY_TYPE}.\n *\n * Non-heap memory\n */\nexport const JVM_MEMORY_TYPE_VALUE_NON_HEAP = \"non_heap\" as const;\n\n/**\n * Whether the thread is daemon or not.\n */\nexport const ATTR_JVM_THREAD_DAEMON = 'jvm.thread.daemon' as const;\n\n/**\n * State of the thread.\n *\n * @example runnable\n * @example blocked\n */\nexport const ATTR_JVM_THREAD_STATE = 'jvm.thread.state' as const;\n\n/**\n * Enum value \"blocked\" for attribute {@link ATTR_JVM_THREAD_STATE}.\n *\n * A thread that is blocked waiting for a monitor lock is in this state.\n */\nexport const JVM_THREAD_STATE_VALUE_BLOCKED = \"blocked\" as const;\n\n/**\n * Enum value \"new\" for attribute {@link ATTR_JVM_THREAD_STATE}.\n *\n * A thread that has not yet started is in this state.\n */\nexport const JVM_THREAD_STATE_VALUE_NEW = \"new\" as const;\n\n/**\n * Enum value \"runnable\" for attribute {@link ATTR_JVM_THREAD_STATE}.\n *\n * A thread executing in the Java virtual machine is in this state.\n */\nexport const JVM_THREAD_STATE_VALUE_RUNNABLE = \"runnable\" as const;\n\n/**\n * Enum value \"terminated\" for attribute {@link ATTR_JVM_THREAD_STATE}.\n *\n * A thread that has exited is in this state.\n */\nexport const JVM_THREAD_STATE_VALUE_TERMINATED = \"terminated\" as const;\n\n/**\n * Enum value \"timed_waiting\" for attribute {@link ATTR_JVM_THREAD_STATE}.\n *\n * A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.\n */\nexport const JVM_THREAD_STATE_VALUE_TIMED_WAITING = \"timed_waiting\" as const;\n\n/**\n * Enum value \"waiting\" for attribute {@link ATTR_JVM_THREAD_STATE}.\n *\n * A thread that is waiting indefinitely for another thread to perform a particular action is in this state.\n */\nexport const JVM_THREAD_STATE_VALUE_WAITING = \"waiting\" as const;\n\n/**\n * Local address of the network connection - IP address or Unix domain socket name.\n *\n * @example 10.1.2.80\n * @example /tmp/my.sock\n */\nexport const ATTR_NETWORK_LOCAL_ADDRESS = 'network.local.address' as const;\n\n/**\n * Local port number of the network connection.\n *\n * @example 65123\n */\nexport const ATTR_NETWORK_LOCAL_PORT = 'network.local.port' as const;\n\n/**\n * Peer address of the network connection - IP address or Unix domain socket name.\n *\n * @example 10.1.2.80\n * @example /tmp/my.sock\n */\nexport const ATTR_NETWORK_PEER_ADDRESS = 'network.peer.address' as const;\n\n/**\n * Peer port number of the network connection.\n *\n * @example 65123\n */\nexport const ATTR_NETWORK_PEER_PORT = 'network.peer.port' as const;\n\n/**\n * [OSI application layer](https://wikipedia.org/wiki/Application_layer) or non-OSI equivalent.\n *\n * @example amqp\n * @example http\n * @example mqtt\n *\n * @note The value **SHOULD** be normalized to lowercase.\n */\nexport const ATTR_NETWORK_PROTOCOL_NAME = 'network.protocol.name' as const;\n\n/**\n * The actual version of the protocol used for network communication.\n *\n * @example 1.1\n * @example 2\n *\n * @note If protocol version is subject to negotiation (for example using [ALPN](https://www.rfc-editor.org/rfc/rfc7301.html)), this attribute **SHOULD** be set to the negotiated version. If the actual protocol version is not known, this attribute **SHOULD NOT** be set.\n */\nexport const ATTR_NETWORK_PROTOCOL_VERSION = 'network.protocol.version' as const;\n\n/**\n * [OSI transport layer](https://wikipedia.org/wiki/Transport_layer) or [inter-process communication method](https://wikipedia.org/wiki/Inter-process_communication).\n *\n * @example tcp\n * @example udp\n *\n * @note The value **SHOULD** be normalized to lowercase.\n *\n * Consider always setting the transport when setting a port number, since\n * a port number is ambiguous without knowing the transport. For example\n * different processes could be listening on TCP port 12345 and UDP port 12345.\n */\nexport const ATTR_NETWORK_TRANSPORT = 'network.transport' as const;\n\n/**\n * Enum value \"pipe\" for attribute {@link ATTR_NETWORK_TRANSPORT}.\n *\n * Named or anonymous pipe.\n */\nexport const NETWORK_TRANSPORT_VALUE_PIPE = \"pipe\" as const;\n\n/**\n * Enum value \"quic\" for attribute {@link ATTR_NETWORK_TRANSPORT}.\n *\n * QUIC\n */\nexport const NETWORK_TRANSPORT_VALUE_QUIC = \"quic\" as const;\n\n/**\n * Enum value \"tcp\" for attribute {@link ATTR_NETWORK_TRANSPORT}.\n *\n * TCP\n */\nexport const NETWORK_TRANSPORT_VALUE_TCP = \"tcp\" as const;\n\n/**\n * Enum value \"udp\" for attribute {@link ATTR_NETWORK_TRANSPORT}.\n *\n * UDP\n */\nexport const NETWORK_TRANSPORT_VALUE_UDP = \"udp\" as const;\n\n/**\n * Enum value \"unix\" for attribute {@link ATTR_NETWORK_TRANSPORT}.\n *\n * Unix domain socket\n */\nexport const NETWORK_TRANSPORT_VALUE_UNIX = \"unix\" as const;\n\n/**\n * [OSI network layer](https://wikipedia.org/wiki/Network_layer) or non-OSI equivalent.\n *\n * @example ipv4\n * @example ipv6\n *\n * @note The value **SHOULD** be normalized to lowercase.\n */\nexport const ATTR_NETWORK_TYPE = 'network.type' as const;\n\n/**\n * Enum value \"ipv4\" for attribute {@link ATTR_NETWORK_TYPE}.\n *\n * IPv4\n */\nexport const NETWORK_TYPE_VALUE_IPV4 = \"ipv4\" as const;\n\n/**\n * Enum value \"ipv6\" for attribute {@link ATTR_NETWORK_TYPE}.\n *\n * IPv6\n */\nexport const NETWORK_TYPE_VALUE_IPV6 = \"ipv6\" as const;\n\n/**\n * The name of the instrumentation scope - (`InstrumentationScope.Name` in OTLP).\n *\n * @example io.opentelemetry.contrib.mongodb\n */\nexport const ATTR_OTEL_SCOPE_NAME = 'otel.scope.name' as const;\n\n/**\n * The version of the instrumentation scope - (`InstrumentationScope.Version` in OTLP).\n *\n * @example 1.0.0\n */\nexport const ATTR_OTEL_SCOPE_VERSION = 'otel.scope.version' as const;\n\n/**\n * Name of the code, either \"OK\" or \"ERROR\". **MUST NOT** be set if the status code is UNSET.\n */\nexport const ATTR_OTEL_STATUS_CODE = 'otel.status_code' as const;\n\n/**\n * Enum value \"ERROR\" for attribute {@link ATTR_OTEL_STATUS_CODE}.\n *\n * The operation contains an error.\n */\nexport const OTEL_STATUS_CODE_VALUE_ERROR = \"ERROR\" as const;\n\n/**\n * Enum value \"OK\" for attribute {@link ATTR_OTEL_STATUS_CODE}.\n *\n * The operation has been validated by an Application developer or Operator to have completed successfully.\n */\nexport const OTEL_STATUS_CODE_VALUE_OK = \"OK\" as const;\n\n/**\n * Description of the Status if it has a value, otherwise not set.\n *\n * @example resource not found\n */\nexport const ATTR_OTEL_STATUS_DESCRIPTION = 'otel.status_description' as const;\n\n/**\n * Server domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name.\n *\n * @example example.com\n * @example 10.1.2.80\n * @example /tmp/my.sock\n *\n * @note When observed from the client side, and when communicating through an intermediary, `server.address` **SHOULD** represent the server address behind any intermediaries, for example proxies, if it's available.\n */\nexport const ATTR_SERVER_ADDRESS = 'server.address' as const;\n\n/**\n * Server port number.\n *\n * @example 80\n * @example 8080\n * @example 443\n *\n * @note When observed from the client side, and when communicating through an intermediary, `server.port` **SHOULD** represent the server port behind any intermediaries, for example proxies, if it's available.\n */\nexport const ATTR_SERVER_PORT = 'server.port' as const;\n\n/**\n * Logical name of the service.\n *\n * @example shoppingcart\n *\n * @note **MUST** be the same for all instances of horizontally scaled services. If the value was not specified, SDKs **MUST** fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value **MUST** be set to `unknown_service`.\n */\nexport const ATTR_SERVICE_NAME = 'service.name' as const;\n\n/**\n * The version string of the service API or implementation. The format is not defined by these conventions.\n *\n * @example 2.0.0\n * @example a01dbef8a\n */\nexport const ATTR_SERVICE_VERSION = 'service.version' as const;\n\n/**\n * SignalR HTTP connection closure status.\n *\n * @example app_shutdown\n * @example timeout\n */\nexport const ATTR_SIGNALR_CONNECTION_STATUS = 'signalr.connection.status' as const;\n\n/**\n * Enum value \"app_shutdown\" for attribute {@link ATTR_SIGNALR_CONNECTION_STATUS}.\n *\n * The connection was closed because the app is shutting down.\n */\nexport const SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = \"app_shutdown\" as const;\n\n/**\n * Enum value \"normal_closure\" for attribute {@link ATTR_SIGNALR_CONNECTION_STATUS}.\n *\n * The connection was closed normally.\n */\nexport const SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = \"normal_closure\" as const;\n\n/**\n * Enum value \"timeout\" for attribute {@link ATTR_SIGNALR_CONNECTION_STATUS}.\n *\n * The connection was closed due to a timeout.\n */\nexport const SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = \"timeout\" as const;\n\n/**\n * [SignalR transport type](https://github.com/dotnet/aspnetcore/blob/main/src/SignalR/docs/specs/TransportProtocols.md)\n *\n * @example web_sockets\n * @example long_polling\n */\nexport const ATTR_SIGNALR_TRANSPORT = 'signalr.transport' as const;\n\n/**\n * Enum value \"long_polling\" for attribute {@link ATTR_SIGNALR_TRANSPORT}.\n *\n * LongPolling protocol\n */\nexport const SIGNALR_TRANSPORT_VALUE_LONG_POLLING = \"long_polling\" as const;\n\n/**\n * Enum value \"server_sent_events\" for attribute {@link ATTR_SIGNALR_TRANSPORT}.\n *\n * ServerSentEvents protocol\n */\nexport const SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = \"server_sent_events\" as const;\n\n/**\n * Enum value \"web_sockets\" for attribute {@link ATTR_SIGNALR_TRANSPORT}.\n *\n * WebSockets protocol\n */\nexport const SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = \"web_sockets\" as const;\n\n/**\n * The language of the telemetry SDK.\n */\nexport const ATTR_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language' as const;\n\n/**\n * Enum value \"cpp\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_CPP = \"cpp\" as const;\n\n/**\n * Enum value \"dotnet\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = \"dotnet\" as const;\n\n/**\n * Enum value \"erlang\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = \"erlang\" as const;\n\n/**\n * Enum value \"go\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_GO = \"go\" as const;\n\n/**\n * Enum value \"java\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = \"java\" as const;\n\n/**\n * Enum value \"nodejs\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = \"nodejs\" as const;\n\n/**\n * Enum value \"php\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_PHP = \"php\" as const;\n\n/**\n * Enum value \"python\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = \"python\" as const;\n\n/**\n * Enum value \"ruby\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = \"ruby\" as const;\n\n/**\n * Enum value \"rust\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_RUST = \"rust\" as const;\n\n/**\n * Enum value \"swift\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = \"swift\" as const;\n\n/**\n * Enum value \"webjs\" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.\n */\nexport const TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = \"webjs\" as const;\n\n/**\n * The name of the telemetry SDK as defined above.\n *\n * @example opentelemetry\n *\n * @note The OpenTelemetry SDK **MUST** set the `telemetry.sdk.name` attribute to `opentelemetry`.\n * If another SDK, like a fork or a vendor-provided implementation, is used, this SDK **MUST** set the\n * `telemetry.sdk.name` attribute to the fully-qualified class or module name of this SDK's main entry point\n * or another suitable identifier depending on the language.\n * The identifier `opentelemetry` is reserved and **MUST NOT** be used in this case.\n * All custom identifiers **SHOULD** be stable across different versions of an implementation.\n */\nexport const ATTR_TELEMETRY_SDK_NAME = 'telemetry.sdk.name' as const;\n\n/**\n * The version string of the telemetry SDK.\n *\n * @example 1.2.3\n */\nexport const ATTR_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version' as const;\n\n/**\n * The [URI fragment](https://www.rfc-editor.org/rfc/rfc3986#section-3.5) component\n *\n * @example SemConv\n */\nexport const ATTR_URL_FRAGMENT = 'url.fragment' as const;\n\n/**\n * Absolute URL describing a network resource according to [RFC3986](https://www.rfc-editor.org/rfc/rfc3986)\n *\n * @example https://www.foo.bar/search?q=OpenTelemetry#SemConv\n * @example //localhost\n *\n * @note For network calls, URL usually has `scheme://host[:port][path][?query][#fragment]` format, where the fragment\n * is not transmitted over HTTP, but if it is known, it **SHOULD** be included nevertheless.\n *\n * `url.full` **MUST NOT** contain credentials passed via URL in form of `https://username:password@www.example.com/`.\n * In such case username and password **SHOULD** be redacted and attribute's value **SHOULD** be `https://REDACTED:REDACTED@www.example.com/`.\n *\n * `url.full` **SHOULD** capture the absolute URL when it is available (or can be reconstructed).\n *\n * Sensitive content provided in `url.full` **SHOULD** be scrubbed when instrumentations can identify it.\n *\n *\n * Query string values for the following keys **SHOULD** be redacted by default and replaced by the\n * value `REDACTED`:\n *\n *   - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)\n *   - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)\n *   - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)\n *   - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)\n *\n * This list is subject to change over time.\n *\n * When a query string value is redacted, the query string key **SHOULD** still be preserved, e.g.\n * `https://www.example.com/path?color=blue&sig=REDACTED`.\n */\nexport const ATTR_URL_FULL = 'url.full' as const;\n\n/**\n * The [URI path](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) component\n *\n * @example /search\n *\n * @note Sensitive content provided in `url.path` **SHOULD** be scrubbed when instrumentations can identify it.\n */\nexport const ATTR_URL_PATH = 'url.path' as const;\n\n/**\n * The [URI query](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) component\n *\n * @example q=OpenTelemetry\n *\n * @note Sensitive content provided in `url.query` **SHOULD** be scrubbed when instrumentations can identify it.\n *\n *\n * Query string values for the following keys **SHOULD** be redacted by default and replaced by the value `REDACTED`:\n *\n *   - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)\n *   - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)\n *   - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)\n *   - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)\n *\n * This list is subject to change over time.\n *\n * When a query string value is redacted, the query string key **SHOULD** still be preserved, e.g.\n * `q=OpenTelemetry&sig=REDACTED`.\n */\nexport const ATTR_URL_QUERY = 'url.query' as const;\n\n/**\n * The [URI scheme](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) component identifying the used protocol.\n *\n * @example https\n * @example ftp\n * @example telnet\n */\nexport const ATTR_URL_SCHEME = 'url.scheme' as const;\n\n/**\n * Value of the [HTTP User-Agent](https://www.rfc-editor.org/rfc/rfc9110.html#field.user-agent) header sent by the client.\n *\n * @example CERN-LineMode/2.15 libwww/2.17b3\n * @example Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1\n * @example YourApp/1.0.0 grpc-java-okhttp/1.27.2\n */\nexport const ATTR_USER_AGENT_ORIGINAL = 'user_agent.original' as const;\n\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getSharedConfigurationDefaults,\n  mergeOtlpSharedConfigurationWithDefaults,\n  OtlpSharedConfiguration,\n} from './shared-configuration';\nimport { validateAndNormalizeHeaders } from '../util';\n\nexport interface OtlpHttpConfiguration extends OtlpSharedConfiguration {\n  url: string;\n  headers: () => Record<string, string>;\n}\n\nfunction mergeHeaders(\n  userProvidedHeaders: (() => Record<string, string>) | undefined | null,\n  fallbackHeaders: (() => Record<string, string>) | undefined | null,\n  defaultHeaders: () => Record<string, string>\n): () => Record<string, string> {\n  const requiredHeaders = {\n    ...defaultHeaders(),\n  };\n  const headers = {};\n\n  return () => {\n    // add fallback ones first\n    if (fallbackHeaders != null) {\n      Object.assign(headers, fallbackHeaders());\n    }\n\n    // override with user-provided ones\n    if (userProvidedHeaders != null) {\n      Object.assign(headers, userProvidedHeaders());\n    }\n\n    // override required ones.\n    return Object.assign(headers, requiredHeaders);\n  };\n}\n\nfunction validateUserProvidedUrl(url: string | undefined): string | undefined {\n  if (url == null) {\n    return undefined;\n  }\n  try {\n    // NOTE: In non-browser environments, `globalThis.location` will be `undefined`.\n    const base = globalThis.location?.href;\n    return new URL(url, base).href;\n  } catch {\n    throw new Error(\n      `Configuration: Could not parse user-provided export URL: '${url}'`\n    );\n  }\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpHttpConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpHttpConfiguration>,\n  fallbackConfiguration: Partial<OtlpHttpConfiguration>,\n  defaultConfiguration: OtlpHttpConfiguration\n): OtlpHttpConfiguration {\n  return {\n    ...mergeOtlpSharedConfigurationWithDefaults(\n      userProvidedConfiguration,\n      fallbackConfiguration,\n      defaultConfiguration\n    ),\n    headers: mergeHeaders(\n      validateAndNormalizeHeaders(userProvidedConfiguration.headers),\n      fallbackConfiguration.headers,\n      defaultConfiguration.headers\n    ),\n    url:\n      validateUserProvidedUrl(userProvidedConfiguration.url) ??\n      fallbackConfiguration.url ??\n      defaultConfiguration.url,\n  };\n}\n\nexport function getHttpConfigurationDefaults(\n  requiredHeaders: Record<string, string>,\n  signalResourcePath: string\n): OtlpHttpConfiguration {\n  return {\n    ...getSharedConfigurationDefaults(),\n    headers: () => requiredHeaders,\n    url: 'http://localhost:4318/' + signalResourcePath,\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  getHttpConfigurationDefaults,\n  mergeOtlpHttpConfigurationWithDefaults,\n  OtlpHttpConfiguration,\n} from './otlp-http-configuration';\n\n// NOTE: do not change these imports to be actual imports, otherwise they WILL break `@opentelemetry/instrumentation-http`\nimport type * as http from 'http';\nimport type * as https from 'https';\n\nexport type HttpAgentFactory = (\n  protocol: string\n) => http.Agent | https.Agent | Promise<http.Agent> | Promise<https.Agent>;\n\nexport interface OtlpNodeHttpConfiguration extends OtlpHttpConfiguration {\n  /**\n   * Factory function for creating agents.\n   *\n   * @remarks\n   * Prefer using {@link httpAgentFactoryFromOptions} over manually writing a factory function wherever possible.\n   * If using a factory function (`HttpAgentFactory`), **do not import `http.Agent` or `https.Agent`\n   * statically at the top of the file**.\n   * Instead, use dynamic `import()` or `require()` to load the module. This ensures that the `http` or `https`\n   * module is not loaded before `@opentelemetry/instrumentation-http` can instrument it.\n   */\n  agentFactory: HttpAgentFactory;\n}\n\nexport function httpAgentFactoryFromOptions(\n  options: http.AgentOptions | https.AgentOptions\n): HttpAgentFactory {\n  return async protocol => {\n    const module = protocol === 'http:' ? import('http') : import('https');\n    const { Agent } = await module;\n    return new Agent(options);\n  };\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpNodeHttpConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpNodeHttpConfiguration>,\n  fallbackConfiguration: Partial<OtlpNodeHttpConfiguration>,\n  defaultConfiguration: OtlpNodeHttpConfiguration\n): OtlpNodeHttpConfiguration {\n  return {\n    ...mergeOtlpHttpConfigurationWithDefaults(\n      userProvidedConfiguration,\n      fallbackConfiguration,\n      defaultConfiguration\n    ),\n    agentFactory:\n      userProvidedConfiguration.agentFactory ??\n      fallbackConfiguration.agentFactory ??\n      defaultConfiguration.agentFactory,\n  };\n}\n\nexport function getNodeHttpConfigurationDefaults(\n  requiredHeaders: Record<string, string>,\n  signalResourcePath: string\n): OtlpNodeHttpConfiguration {\n  return {\n    ...getHttpConfigurationDefaults(requiredHeaders, signalResourcePath),\n    agentFactory: httpAgentFactoryFromOptions({ keepAlive: true }),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Aggregation,\n  DEFAULT_AGGREGATION,\n  DROP_AGGREGATION,\n  ExplicitBucketHistogramAggregation,\n  ExponentialHistogramAggregation,\n  HISTOGRAM_AGGREGATION,\n  LAST_VALUE_AGGREGATION,\n  SUM_AGGREGATION,\n} from './Aggregation';\n\nexport enum AggregationType {\n  DEFAULT = 0,\n  DROP = 1,\n  SUM = 2,\n  LAST_VALUE = 3,\n  EXPLICIT_BUCKET_HISTOGRAM = 4,\n  EXPONENTIAL_HISTOGRAM = 5,\n}\n\nexport type SumAggregationOption = {\n  type: AggregationType.SUM;\n};\n\nexport type LastValueAggregationOption = {\n  type: AggregationType.LAST_VALUE;\n};\n\nexport type DropAggregationOption = {\n  type: AggregationType.DROP;\n};\n\nexport type DefaultAggregationOption = {\n  type: AggregationType.DEFAULT;\n};\n\nexport type HistogramAggregationOption = {\n  type: AggregationType.EXPLICIT_BUCKET_HISTOGRAM;\n  options?: {\n    recordMinMax?: boolean;\n    boundaries: number[];\n  };\n};\n\nexport type ExponentialHistogramAggregationOption = {\n  type: AggregationType.EXPONENTIAL_HISTOGRAM;\n  options?: {\n    recordMinMax?: boolean;\n    maxSize?: number;\n  };\n};\n\nexport type AggregationOption =\n  | ExponentialHistogramAggregationOption\n  | HistogramAggregationOption\n  | SumAggregationOption\n  | DropAggregationOption\n  | DefaultAggregationOption\n  | LastValueAggregationOption;\n\nexport function toAggregation(option: AggregationOption): Aggregation {\n  switch (option.type) {\n    case AggregationType.DEFAULT:\n      return DEFAULT_AGGREGATION;\n    case AggregationType.DROP:\n      return DROP_AGGREGATION;\n    case AggregationType.SUM:\n      return SUM_AGGREGATION;\n    case AggregationType.LAST_VALUE:\n      return LAST_VALUE_AGGREGATION;\n    case AggregationType.EXPONENTIAL_HISTOGRAM: {\n      const expOption = option as ExponentialHistogramAggregationOption;\n      return new ExponentialHistogramAggregation(\n        expOption.options?.maxSize,\n        expOption.options?.recordMinMax\n      );\n    }\n    case AggregationType.EXPLICIT_BUCKET_HISTOGRAM: {\n      const expOption = option as HistogramAggregationOption;\n      if (expOption.options == null) {\n        return HISTOGRAM_AGGREGATION;\n      } else {\n        return new ExplicitBucketHistogramAggregation(\n          expOption.options?.boundaries,\n          expOption.options?.recordMinMax\n        );\n      }\n    }\n    default:\n      throw new Error('Unsupported Aggregation');\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function isExportRetryable(statusCode: number): boolean {\n  const retryCodes = [429, 502, 503, 504];\n  return retryCodes.includes(statusCode);\n}\n\nexport function parseRetryAfterToMills(\n  retryAfter?: string | undefined | null\n): number | undefined {\n  if (retryAfter == null) {\n    return undefined;\n  }\n\n  const seconds = Number.parseInt(retryAfter, 10);\n  if (Number.isInteger(seconds)) {\n    return seconds > 0 ? seconds * 1000 : -1;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives\n  const delay = new Date(retryAfter).getTime() - Date.now();\n\n  if (delay >= 0) {\n    return delay;\n  }\n  return 0;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag, AttributeValue, Attributes } from '@opentelemetry/api';\n\nexport function sanitizeAttributes(attributes: unknown): Attributes {\n  const out: Attributes = {};\n\n  if (typeof attributes !== 'object' || attributes == null) {\n    return out;\n  }\n\n  for (const [key, val] of Object.entries(attributes)) {\n    if (!isAttributeKey(key)) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      continue;\n    }\n    if (!isAttributeValue(val)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      continue;\n    }\n    if (Array.isArray(val)) {\n      out[key] = val.slice();\n    } else {\n      out[key] = val;\n    }\n  }\n\n  return out;\n}\n\nexport function isAttributeKey(key: unknown): key is string {\n  return typeof key === 'string' && key.length > 0;\n}\n\nexport function isAttributeValue(val: unknown): val is AttributeValue {\n  if (val == null) {\n    return true;\n  }\n\n  if (Array.isArray(val)) {\n    return isHomogeneousAttributeValueArray(val);\n  }\n\n  return isValidPrimitiveAttributeValue(val);\n}\n\nfunction isHomogeneousAttributeValueArray(arr: unknown[]): boolean {\n  let type: string | undefined;\n\n  for (const element of arr) {\n    // null/undefined elements are allowed\n    if (element == null) continue;\n\n    if (!type) {\n      if (isValidPrimitiveAttributeValue(element)) {\n        type = typeof element;\n        continue;\n      }\n      // encountered an invalid primitive\n      return false;\n    }\n\n    if (typeof element === type) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction isValidPrimitiveAttributeValue(val: unknown): boolean {\n  switch (typeof val) {\n    case 'number':\n    case 'boolean':\n    case 'string':\n      return true;\n  }\n\n  return false;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, createContextKey } from '@opentelemetry/api';\n\nconst SUPPRESS_TRACING_KEY = createContextKey(\n  'OpenTelemetry SDK Context Key SUPPRESS_TRACING'\n);\n\nexport function suppressTracing(context: Context): Context {\n  return context.setValue(SUPPRESS_TRACING_KEY, true);\n}\n\nexport function unsuppressTracing(context: Context): Context {\n  return context.deleteValue(SUPPRESS_TRACING_KEY);\n}\n\nexport function isTracingSuppressed(context: Context): boolean {\n  return context.getValue(SUPPRESS_TRACING_KEY) === true;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ReadableLogRecord } from '@opentelemetry/sdk-logs';\nimport {\n  ESeverityNumber,\n  IExportLogsServiceRequest,\n  ILogRecord,\n  IResourceLogs,\n} from './internal-types';\nimport { Resource } from '@opentelemetry/resources';\nimport { Encoder, getOtlpEncoder } from '../common/utils';\nimport {\n  createInstrumentationScope,\n  createResource,\n  toAnyValue,\n  toKeyValue,\n} from '../common/internal';\nimport { SeverityNumber } from '@opentelemetry/api-logs';\nimport { OtlpEncodingOptions, IKeyValue } from '../common/internal-types';\nimport { LogAttributes } from '@opentelemetry/api-logs';\n\nexport function createExportLogsServiceRequest(\n  logRecords: ReadableLogRecord[],\n  options?: OtlpEncodingOptions\n): IExportLogsServiceRequest {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resourceLogs: logRecordsToResourceLogs(logRecords, encoder),\n  };\n}\n\nfunction createResourceMap(\n  logRecords: ReadableLogRecord[]\n): Map<Resource, Map<string, ReadableLogRecord[]>> {\n  const resourceMap: Map<\n    Resource,\n    Map<string, ReadableLogRecord[]>\n  > = new Map();\n\n  for (const record of logRecords) {\n    const {\n      resource,\n      instrumentationScope: { name, version = '', schemaUrl = '' },\n    } = record;\n\n    let ismMap = resourceMap.get(resource);\n    if (!ismMap) {\n      ismMap = new Map();\n      resourceMap.set(resource, ismMap);\n    }\n\n    const ismKey = `${name}@${version}:${schemaUrl}`;\n    let records = ismMap.get(ismKey);\n    if (!records) {\n      records = [];\n      ismMap.set(ismKey, records);\n    }\n    records.push(record);\n  }\n  return resourceMap;\n}\n\nfunction logRecordsToResourceLogs(\n  logRecords: ReadableLogRecord[],\n  encoder: Encoder\n): IResourceLogs[] {\n  const resourceMap = createResourceMap(logRecords);\n  return Array.from(resourceMap, ([resource, ismMap]) => {\n    const processedResource = createResource(resource);\n    return {\n      resource: processedResource,\n      scopeLogs: Array.from(ismMap, ([, scopeLogs]) => {\n        return {\n          scope: createInstrumentationScope(scopeLogs[0].instrumentationScope),\n          logRecords: scopeLogs.map(log => toLogRecord(log, encoder)),\n          schemaUrl: scopeLogs[0].instrumentationScope.schemaUrl,\n        };\n      }),\n      schemaUrl: processedResource.schemaUrl,\n    };\n  });\n}\n\nfunction toLogRecord(log: ReadableLogRecord, encoder: Encoder): ILogRecord {\n  return {\n    timeUnixNano: encoder.encodeHrTime(log.hrTime),\n    observedTimeUnixNano: encoder.encodeHrTime(log.hrTimeObserved),\n    severityNumber: toSeverityNumber(log.severityNumber),\n    severityText: log.severityText,\n    body: toAnyValue(log.body),\n    eventName: log.eventName,\n    attributes: toLogAttributes(log.attributes),\n    droppedAttributesCount: log.droppedAttributesCount,\n    flags: log.spanContext?.traceFlags,\n    traceId: encoder.encodeOptionalSpanContext(log.spanContext?.traceId),\n    spanId: encoder.encodeOptionalSpanContext(log.spanContext?.spanId),\n  };\n}\n\nfunction toSeverityNumber(\n  severityNumber: SeverityNumber | undefined\n): ESeverityNumber | undefined {\n  return severityNumber as number | undefined as ESeverityNumber | undefined;\n}\n\nexport function toLogAttributes(attributes: LogAttributes): IKeyValue[] {\n  return Object.keys(attributes).map(key => toKeyValue(key, attributes[key]));\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as root from '../../generated/root';\nimport { ISerializer } from '../../i-serializer';\nimport { IExportMetricsServiceRequest } from '../internal-types';\nimport { ExportType } from '../../common/protobuf/protobuf-export-type';\nimport { createExportMetricsServiceRequest } from '../internal';\nimport { ResourceMetrics } from '@opentelemetry/sdk-metrics';\nimport { IExportMetricsServiceResponse } from '../export-response';\n\nconst metricsResponseType = root.opentelemetry.proto.collector.metrics.v1\n  .ExportMetricsServiceResponse as ExportType<IExportMetricsServiceResponse>;\n\nconst metricsRequestType = root.opentelemetry.proto.collector.metrics.v1\n  .ExportMetricsServiceRequest as ExportType<IExportMetricsServiceRequest>;\n\nexport const ProtobufMetricsSerializer: ISerializer<\n  ResourceMetrics,\n  IExportMetricsServiceResponse\n> = {\n  serializeRequest: (arg: ResourceMetrics) => {\n    const request = createExportMetricsServiceRequest([arg]);\n    return metricsRequestType.encode(request).finish();\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    return metricsResponseType.decode(arg);\n  },\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nexport function validateKey(key: string): boolean {\n  return VALID_KEY_REGEX.test(key);\n}\n\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nexport function validateValue(value: string): boolean {\n  return (\n    VALID_VALUE_BASE_REGEX.test(value) &&\n    !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nexport function validateKey(key: string): boolean {\n  return VALID_KEY_REGEX.test(key);\n}\n\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nexport function validateValue(value: string): boolean {\n  return (\n    VALID_VALUE_BASE_REGEX.test(value) &&\n    !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue, diag } from '@opentelemetry/api';\nimport { SDK_INFO } from '@opentelemetry/core';\nimport {\n  ATTR_SERVICE_NAME,\n  ATTR_TELEMETRY_SDK_LANGUAGE,\n  ATTR_TELEMETRY_SDK_NAME,\n  ATTR_TELEMETRY_SDK_VERSION,\n} from '@opentelemetry/semantic-conventions';\nimport { Resource } from './Resource';\nimport { defaultServiceName } from './platform';\nimport {\n  DetectedResource,\n  DetectedResourceAttributes,\n  MaybePromise,\n  RawResourceAttribute,\n  ResourceOptions,\n} from './types';\nimport { isPromiseLike } from './utils';\n\nclass ResourceImpl implements Resource {\n  private _rawAttributes: RawResourceAttribute[];\n  private _asyncAttributesPending = false;\n  private _schemaUrl?: string;\n\n  private _memoizedAttributes?: Attributes;\n\n  static FromAttributeList(\n    attributes: [string, MaybePromise<AttributeValue | undefined>][],\n    options?: ResourceOptions\n  ): Resource {\n    const res = new ResourceImpl({}, options);\n    res._rawAttributes = guardedRawAttributes(attributes);\n    res._asyncAttributesPending =\n      attributes.filter(([_, val]) => isPromiseLike(val)).length > 0;\n    return res;\n  }\n\n  constructor(\n    /**\n     * A dictionary of attributes with string keys and values that provide\n     * information about the entity as numbers, strings or booleans\n     * TODO: Consider to add check/validation on attributes.\n     */\n    resource: DetectedResource,\n    options?: ResourceOptions\n  ) {\n    const attributes = resource.attributes ?? {};\n    this._rawAttributes = Object.entries(attributes).map(([k, v]) => {\n      if (isPromiseLike(v)) {\n        // side-effect\n        this._asyncAttributesPending = true;\n      }\n\n      return [k, v];\n    });\n\n    this._rawAttributes = guardedRawAttributes(this._rawAttributes);\n    this._schemaUrl = validateSchemaUrl(options?.schemaUrl);\n  }\n\n  public get asyncAttributesPending(): boolean {\n    return this._asyncAttributesPending;\n  }\n\n  public async waitForAsyncAttributes(): Promise<void> {\n    if (!this.asyncAttributesPending) {\n      return;\n    }\n\n    for (let i = 0; i < this._rawAttributes.length; i++) {\n      const [k, v] = this._rawAttributes[i];\n      this._rawAttributes[i] = [k, isPromiseLike(v) ? await v : v];\n    }\n\n    this._asyncAttributesPending = false;\n  }\n\n  public get attributes(): Attributes {\n    if (this.asyncAttributesPending) {\n      diag.error(\n        'Accessing resource attributes before async attributes settled'\n      );\n    }\n\n    if (this._memoizedAttributes) {\n      return this._memoizedAttributes;\n    }\n\n    const attrs: Attributes = {};\n    for (const [k, v] of this._rawAttributes) {\n      if (isPromiseLike(v)) {\n        diag.debug(`Unsettled resource attribute ${k} skipped`);\n        continue;\n      }\n      if (v != null) {\n        attrs[k] ??= v;\n      }\n    }\n\n    // only memoize output if all attributes are settled\n    if (!this._asyncAttributesPending) {\n      this._memoizedAttributes = attrs;\n    }\n\n    return attrs;\n  }\n\n  public getRawAttributes(): RawResourceAttribute[] {\n    return this._rawAttributes;\n  }\n\n  public get schemaUrl(): string | undefined {\n    return this._schemaUrl;\n  }\n\n  public merge(resource: Resource | null): Resource {\n    if (resource == null) return this;\n\n    // Order is important\n    // Spec states incoming attributes override existing attributes\n    const mergedSchemaUrl = mergeSchemaUrl(this, resource);\n    const mergedOptions: ResourceOptions | undefined = mergedSchemaUrl\n      ? { schemaUrl: mergedSchemaUrl }\n      : undefined;\n\n    return ResourceImpl.FromAttributeList(\n      [...resource.getRawAttributes(), ...this.getRawAttributes()],\n      mergedOptions\n    );\n  }\n}\n\nexport function resourceFromAttributes(\n  attributes: DetectedResourceAttributes,\n  options?: ResourceOptions\n): Resource {\n  return ResourceImpl.FromAttributeList(Object.entries(attributes), options);\n}\n\nexport function resourceFromDetectedResource(\n  detectedResource: DetectedResource,\n  options?: ResourceOptions\n): Resource {\n  return new ResourceImpl(detectedResource, options);\n}\n\nexport function emptyResource(): Resource {\n  return resourceFromAttributes({});\n}\n\nexport function defaultResource(): Resource {\n  return resourceFromAttributes({\n    [ATTR_SERVICE_NAME]: defaultServiceName(),\n    [ATTR_TELEMETRY_SDK_LANGUAGE]: SDK_INFO[ATTR_TELEMETRY_SDK_LANGUAGE],\n    [ATTR_TELEMETRY_SDK_NAME]: SDK_INFO[ATTR_TELEMETRY_SDK_NAME],\n    [ATTR_TELEMETRY_SDK_VERSION]: SDK_INFO[ATTR_TELEMETRY_SDK_VERSION],\n  });\n}\n\nfunction guardedRawAttributes(\n  attributes: RawResourceAttribute[]\n): RawResourceAttribute[] {\n  return attributes.map(([k, v]) => {\n    if (isPromiseLike(v)) {\n      return [\n        k,\n        v.catch(err => {\n          diag.debug(\n            'promise rejection for resource attribute: %s - %s',\n            k,\n            err\n          );\n          return undefined;\n        }),\n      ];\n    }\n    return [k, v];\n  });\n}\n\nfunction validateSchemaUrl(schemaUrl?: string): string | undefined {\n  if (typeof schemaUrl === 'string' || schemaUrl === undefined) {\n    return schemaUrl;\n  }\n\n  diag.warn(\n    'Schema URL must be string or undefined, got %s. Schema URL will be ignored.',\n    schemaUrl\n  );\n\n  return undefined;\n}\n\nfunction mergeSchemaUrl(\n  old: Resource,\n  updating: Resource | null\n): string | undefined {\n  const oldSchemaUrl = old?.schemaUrl;\n  const updatingSchemaUrl = updating?.schemaUrl;\n\n  const isOldEmpty = oldSchemaUrl === undefined || oldSchemaUrl === '';\n  const isUpdatingEmpty =\n    updatingSchemaUrl === undefined || updatingSchemaUrl === '';\n\n  if (isOldEmpty) {\n    return updatingSchemaUrl;\n  }\n\n  if (isUpdatingEmpty) {\n    return oldSchemaUrl;\n  }\n\n  if (oldSchemaUrl === updatingSchemaUrl) {\n    return oldSchemaUrl;\n  }\n\n  diag.warn(\n    'Schema URL merge conflict: old resource has \"%s\", updating resource has \"%s\". Resulting resource will have undefined Schema URL.',\n    oldSchemaUrl,\n    updatingSchemaUrl\n  );\n\n  return undefined;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { MetricProducer } from './MetricProducer';\nimport { CollectionResult, InstrumentType } from './MetricData';\nimport { callWithTimeout, FlatMap } from '../utils';\nimport {\n  CollectionOptions,\n  ForceFlushOptions,\n  ShutdownOptions,\n} from '../types';\nimport {\n  AggregationSelector,\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_SELECTOR,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\nimport { AggregationOption } from '../view/AggregationOption';\nimport { CardinalitySelector } from './CardinalitySelector';\n\nexport interface MetricReaderOptions {\n  /**\n   * Aggregation selector based on metric instrument types. If no views are\n   * configured for a metric instrument, a per-metric-reader aggregation is\n   * selected with this selector.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  aggregationSelector?: AggregationSelector;\n  /**\n   * Aggregation temporality selector based on metric instrument types. If\n   * not configured, cumulative is used for all instruments.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  aggregationTemporalitySelector?: AggregationTemporalitySelector;\n  /**\n   * Cardinality selector based on metric instrument types. If not configured,\n   * a default value is used.\n   *\n   * <p> NOTE: the provided function MUST be pure\n   */\n  cardinalitySelector?: CardinalitySelector;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n}\n\n/**\n * Reads metrics from the SDK. Implementations MUST follow the Metric Reader Specification as well as the requirements\n * listed in this interface. Consider extending {@link MetricReader} to get a specification-compliant base implementation\n * of this interface\n */\nexport interface IMetricReader {\n  /**\n   * Set the {@link MetricProducer} used by this instance. **This should only be called once by the\n   * SDK and should be considered internal.**\n   *\n   * <p> NOTE: implementations MUST throw when called more than once\n   *\n   * @param metricProducer\n   */\n  setMetricProducer(metricProducer: MetricProducer): void;\n\n  /**\n   * Select the {@link AggregationOption} for the given {@link InstrumentType} for this\n   * reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectAggregation(instrumentType: InstrumentType): AggregationOption;\n\n  /**\n   * Select the {@link AggregationTemporality} for the given\n   * {@link InstrumentType} for this reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality;\n\n  /**\n   * Select the cardinality limit for the given {@link InstrumentType} for this\n   * reader.\n   *\n   * <p> NOTE: implementations MUST be pure\n   */\n  selectCardinalityLimit(instrumentType: InstrumentType): number;\n\n  /**\n   * Collect all metrics from the associated {@link MetricProducer}\n   */\n  collect(options?: CollectionOptions): Promise<CollectionResult>;\n\n  /**\n   * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation MAY continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  shutdown(options?: ShutdownOptions): Promise<void>;\n\n  /**\n   * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation MAY continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  forceFlush(options?: ForceFlushOptions): Promise<void>;\n}\n\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport abstract class MetricReader implements IMetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  private _shutdown = false;\n  // Additional MetricProducers which will be combined with the SDK's output\n  private _metricProducers: MetricProducer[];\n  // MetricProducer used by this instance which produces metrics from the SDK\n  private _sdkMetricProducer?: MetricProducer;\n  private readonly _aggregationTemporalitySelector: AggregationTemporalitySelector;\n  private readonly _aggregationSelector: AggregationSelector;\n  private readonly _cardinalitySelector?: CardinalitySelector;\n\n  constructor(options?: MetricReaderOptions) {\n    this._aggregationSelector =\n      options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;\n    this._aggregationTemporalitySelector =\n      options?.aggregationTemporalitySelector ??\n      DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n    this._metricProducers = options?.metricProducers ?? [];\n    this._cardinalitySelector = options?.cardinalitySelector;\n  }\n\n  setMetricProducer(metricProducer: MetricProducer) {\n    if (this._sdkMetricProducer) {\n      throw new Error(\n        'MetricReader can not be bound to a MeterProvider again.'\n      );\n    }\n    this._sdkMetricProducer = metricProducer;\n    this.onInitialized();\n  }\n\n  selectAggregation(instrumentType: InstrumentType): AggregationOption {\n    return this._aggregationSelector(instrumentType);\n  }\n\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n\n  selectCardinalityLimit(instrumentType: InstrumentType): number {\n    return this._cardinalitySelector\n      ? this._cardinalitySelector(instrumentType)\n      : 2000; // default value if no selector is provided\n  }\n\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  protected onInitialized(): void {\n    // Default implementation is empty.\n  }\n\n  /**\n   * Handle a shutdown signal by the SDK.\n   *\n   * <p> For push exporters, this should shut down any intervals and close any open connections.\n   * @protected\n   */\n  protected abstract onShutdown(): Promise<void>;\n\n  /**\n   * Handle a force flush signal by the SDK.\n   *\n   * <p> In all scenarios metrics should be collected via {@link collect()}.\n   * <p> For push exporters, this should collect and report metrics.\n   * @protected\n   */\n  protected abstract onForceFlush(): Promise<void>;\n\n  async collect(options?: CollectionOptions): Promise<CollectionResult> {\n    if (this._sdkMetricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n\n    const [sdkCollectionResults, ...additionalCollectionResults] =\n      await Promise.all([\n        this._sdkMetricProducer.collect({\n          timeoutMillis: options?.timeoutMillis,\n        }),\n        ...this._metricProducers.map(producer =>\n          producer.collect({\n            timeoutMillis: options?.timeoutMillis,\n          })\n        ),\n      ]);\n\n    // Merge the results, keeping the SDK's Resource\n    const errors = sdkCollectionResults.errors.concat(\n      FlatMap(additionalCollectionResults, result => result.errors)\n    );\n    const resource = sdkCollectionResults.resourceMetrics.resource;\n    const scopeMetrics =\n      sdkCollectionResults.resourceMetrics.scopeMetrics.concat(\n        FlatMap(\n          additionalCollectionResults,\n          result => result.resourceMetrics.scopeMetrics\n        )\n      );\n    return {\n      resourceMetrics: {\n        resource,\n        scopeMetrics,\n      },\n      errors,\n    };\n  }\n\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n\n    this._shutdown = true;\n  }\n\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BaggageEntry,\n  Context,\n  propagation,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n} from '@opentelemetry/api';\n\nimport { isTracingSuppressed } from '../../trace/suppress-tracing';\nimport {\n  BAGGAGE_HEADER,\n  BAGGAGE_ITEMS_SEPARATOR,\n  BAGGAGE_MAX_NAME_VALUE_PAIRS,\n  BAGGAGE_MAX_PER_NAME_VALUE_PAIRS,\n} from '../constants';\nimport { getKeyPairs, parsePairKeyValue, serializeKeyPairs } from '../utils';\n\n/**\n * Propagates {@link Baggage} through Context format propagation.\n *\n * Based on the Baggage specification:\n * https://w3c.github.io/baggage/\n */\nexport class W3CBaggagePropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    const baggage = propagation.getBaggage(context);\n    if (!baggage || isTracingSuppressed(context)) return;\n    const keyPairs = getKeyPairs(baggage)\n      .filter((pair: string) => {\n        return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;\n      })\n      .slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);\n    const headerValue = serializeKeyPairs(keyPairs);\n    if (headerValue.length > 0) {\n      setter.set(carrier, BAGGAGE_HEADER, headerValue);\n    }\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const headerValue = getter.get(carrier, BAGGAGE_HEADER);\n    const baggageString = Array.isArray(headerValue)\n      ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR)\n      : headerValue;\n    if (!baggageString) return context;\n    const baggage: Record<string, BaggageEntry> = {};\n    if (baggageString.length === 0) {\n      return context;\n    }\n    const pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);\n    pairs.forEach(entry => {\n      const keyPair = parsePairKeyValue(entry);\n      if (keyPair) {\n        const baggageEntry: BaggageEntry = { value: keyPair.value };\n        if (keyPair.metadata) {\n          baggageEntry.metadata = keyPair.metadata;\n        }\n        baggage[keyPair.key] = baggageEntry;\n      }\n    });\n    if (Object.entries(baggage).length === 0) {\n      return context;\n    }\n    return propagation.setBaggage(context, propagation.createBaggage(baggage));\n  }\n\n  fields(): string[] {\n    return [BAGGAGE_HEADER];\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  Attributes,\n  AttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationScope,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport {\n  ATTR_EXCEPTION_MESSAGE,\n  ATTR_EXCEPTION_STACKTRACE,\n  ATTR_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { ExceptionEventName } from './enums';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { SpanLimits } from './types';\n\n/**\n * This type provides the properties of @link{ReadableSpan} at the same time\n * of the Span API\n */\nexport type Span = APISpan & ReadableSpan;\n\ninterface SpanOptions {\n  resource: Resource;\n  scope: InstrumentationScope;\n  context: Context;\n  spanContext: SpanContext;\n  name: string;\n  kind: SpanKind;\n  parentSpanContext?: SpanContext;\n  links?: Link[];\n  startTime?: TimeInput;\n  attributes?: Attributes;\n  spanLimits: SpanLimits;\n  spanProcessor: SpanProcessor;\n}\n\n/**\n * This class represents a span.\n */\nexport class SpanImpl implements Span {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanContext?: SpanContext;\n  readonly attributes: Attributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new SpanImpl instance.\n   */\n  constructor(opts: SpanOptions) {\n    const now = Date.now();\n\n    this._spanContext = opts.spanContext;\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = opts.startTime != null;\n    this._spanLimits = opts.spanLimits;\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n    this._spanProcessor = opts.spanProcessor;\n\n    this.name = opts.name;\n    this.parentSpanContext = opts.parentSpanContext;\n    this.kind = opts.kind;\n    this.links = opts.links || [];\n    this.startTime = this._getTime(opts.startTime ?? now);\n    this.resource = opts.resource;\n    this.instrumentationScope = opts.scope;\n\n    if (opts.attributes != null) {\n      this.setAttributes(opts.attributes);\n    }\n\n    this._spanProcessor.onStart(this, opts.context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: AttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    const { attributeCountLimit } = this._spanLimits;\n\n    if (\n      attributeCountLimit !== undefined &&\n      Object.keys(this.attributes).length >= attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: Attributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: Attributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n\n    const { eventCountLimit } = this._spanLimits;\n\n    if (eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n\n    if (\n      eventCountLimit !== undefined &&\n      this.events.length >= eventCountLimit\n    ) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: Attributes = {};\n    if (typeof exception === 'string') {\n      attributes[ATTR_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[ATTR_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[ATTR_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[ATTR_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (attributes[ATTR_EXCEPTION_TYPE] || attributes[ATTR_EXCEPTION_MESSAGE]) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      const error = new Error(\n        `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n\n      diag.warn(\n        `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,\n        error\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: AttributeValue): AttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { otperformance as performance } from '../platform';\nimport { TimeOriginLegacy } from './types';\n\nconst NANOSECOND_DIGITS = 9;\nconst NANOSECOND_DIGITS_IN_MILLIS = 6;\nconst MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);\nconst SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n\n/**\n * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).\n * @param epochMillis\n */\nexport function millisToHrTime(epochMillis: number): api.HrTime {\n  const epochSeconds = epochMillis / 1000;\n  // Decimals only.\n  const seconds = Math.trunc(epochSeconds);\n  // Round sub-nanosecond accuracy to nanosecond.\n  const nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS);\n  return [seconds, nanos];\n}\n\nexport function getTimeOrigin(): number {\n  let timeOrigin = performance.timeOrigin;\n  if (typeof timeOrigin !== 'number') {\n    const perf: TimeOriginLegacy = performance as unknown as TimeOriginLegacy;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n  return timeOrigin;\n}\n\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nexport function hrTime(performanceNow?: number): api.HrTime {\n  const timeOrigin = millisToHrTime(getTimeOrigin());\n  const now = millisToHrTime(\n    typeof performanceNow === 'number' ? performanceNow : performance.now()\n  );\n\n  return addHrTimes(timeOrigin, now);\n}\n\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nexport function timeInputToHrTime(time: api.TimeInput): api.HrTime {\n  // process.hrtime\n  if (isTimeInputHrTime(time)) {\n    return time as api.HrTime;\n  } else if (typeof time === 'number') {\n    // Must be a performance.now() if it's smaller than process start time.\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      // epoch milliseconds or performance.timeOrigin\n      return millisToHrTime(time);\n    }\n  } else if (time instanceof Date) {\n    return millisToHrTime(time.getTime());\n  } else {\n    throw TypeError('Invalid input type');\n  }\n}\n\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nexport function hrTimeDuration(\n  startTime: api.HrTime,\n  endTime: api.HrTime\n): api.HrTime {\n  let seconds = endTime[0] - startTime[0];\n  let nanos = endTime[1] - startTime[1];\n\n  // overflow\n  if (nanos < 0) {\n    seconds -= 1;\n    // negate\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n\n  return [seconds, nanos];\n}\n\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param time\n */\nexport function hrTimeToTimeStamp(time: api.HrTime): string {\n  const precision = NANOSECOND_DIGITS;\n  const tmp = `${'0'.repeat(precision)}${time[1]}Z`;\n  const nanoString = tmp.substring(tmp.length - precision - 1);\n  const date = new Date(time[0] * 1000).toISOString();\n  return date.replace('000Z', nanoString);\n}\n\n/**\n * Convert hrTime to nanoseconds.\n * @param time\n */\nexport function hrTimeToNanoseconds(time: api.HrTime): number {\n  return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\n\n/**\n * Convert hrTime to milliseconds.\n * @param time\n */\nexport function hrTimeToMilliseconds(time: api.HrTime): number {\n  return time[0] * 1e3 + time[1] / 1e6;\n}\n\n/**\n * Convert hrTime to microseconds.\n * @param time\n */\nexport function hrTimeToMicroseconds(time: api.HrTime): number {\n  return time[0] * 1e6 + time[1] / 1e3;\n}\n\n/**\n * check if time is HrTime\n * @param value\n */\nexport function isTimeInputHrTime(value: unknown): value is api.HrTime {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    typeof value[0] === 'number' &&\n    typeof value[1] === 'number'\n  );\n}\n\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nexport function isTimeInput(\n  value: unknown\n): value is api.HrTime | number | Date {\n  return (\n    isTimeInputHrTime(value) ||\n    typeof value === 'number' ||\n    value instanceof Date\n  );\n}\n\n/**\n * Given 2 HrTime formatted times, return their sum as an HrTime.\n */\nexport function addHrTimes(time1: api.HrTime, time2: api.HrTime): api.HrTime {\n  const out = [time1[0] + time2[0], time1[1] + time2[1]] as api.HrTime;\n\n  // Nanoseconds\n  if (out[1] >= SECOND_TO_NANOSECONDS) {\n    out[1] -= SECOND_TO_NANOSECONDS;\n    out[0] += 1;\n  }\n\n  return out;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BasicTracerProvider,\n  SDKRegistrationConfig,\n  TracerConfig,\n} from '@opentelemetry/sdk-trace-base';\nimport { StackContextManager } from './StackContextManager';\nimport {\n  trace,\n  context,\n  ContextManager,\n  propagation,\n  TextMapPropagator,\n} from '@opentelemetry/api';\nimport {\n  CompositePropagator,\n  W3CBaggagePropagator,\n  W3CTraceContextPropagator,\n} from '@opentelemetry/core';\n\nfunction setupContextManager(\n  contextManager: ContextManager | null | undefined\n) {\n  // null means 'do not register'\n  if (contextManager === null) {\n    return;\n  }\n\n  // undefined means 'register default'\n  if (contextManager === undefined) {\n    const defaultContextManager = new StackContextManager();\n    defaultContextManager.enable();\n    context.setGlobalContextManager(defaultContextManager);\n    return;\n  }\n\n  contextManager.enable();\n  context.setGlobalContextManager(contextManager);\n}\n\nfunction setupPropagator(propagator: TextMapPropagator | null | undefined) {\n  // null means 'do not register'\n  if (propagator === null) {\n    return;\n  }\n\n  // undefined means 'register default'\n  if (propagator === undefined) {\n    propagation.setGlobalPropagator(\n      new CompositePropagator({\n        propagators: [\n          new W3CTraceContextPropagator(),\n          new W3CBaggagePropagator(),\n        ],\n      })\n    );\n    return;\n  }\n\n  propagation.setGlobalPropagator(propagator);\n}\n\n/**\n * WebTracerConfig provides an interface for configuring a Web Tracer.\n */\nexport type WebTracerConfig = TracerConfig;\n\n/**\n * This class represents a web tracer with {@link StackContextManager}\n */\nexport class WebTracerProvider extends BasicTracerProvider {\n  /**\n   * Constructs a new Tracer instance.\n   * @param config Web Tracer config\n   */\n  constructor(config: WebTracerConfig = {}) {\n    super(config);\n  }\n\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n  register(config: SDKRegistrationConfig = {}): void {\n    trace.setGlobalTracerProvider(this);\n    setupPropagator(config.propagator);\n    setupContextManager(config.contextManager);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  SpanContext,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n  trace,\n  TraceFlags,\n} from '@opentelemetry/api';\nimport { isTracingSuppressed } from './suppress-tracing';\nimport { TraceState } from './TraceState';\n\nexport const TRACE_PARENT_HEADER = 'traceparent';\nexport const TRACE_STATE_HEADER = 'tracestate';\n\nconst VERSION = '00';\nconst VERSION_PART = '(?!ff)[\\\\da-f]{2}';\nconst TRACE_ID_PART = '(?![0]{32})[\\\\da-f]{32}';\nconst PARENT_ID_PART = '(?![0]{16})[\\\\da-f]{16}';\nconst FLAGS_PART = '[\\\\da-f]{2}';\nconst TRACE_PARENT_REGEX = new RegExp(\n  `^\\\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\\\s?$`\n);\n\n/**\n * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}\n * @param traceParent - A meta property that comes from server.\n *     It should be dynamically generated server side to have the server's request trace Id,\n *     a parent span Id that was set on the server's request span,\n *     and the trace flags to indicate the server's sampling decision\n *     (01 = sampled, 00 = not sampled).\n *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'\n *     For more information see {@link https://www.w3.org/TR/trace-context/}\n */\nexport function parseTraceParent(traceParent: string): SpanContext | null {\n  const match = TRACE_PARENT_REGEX.exec(traceParent);\n  if (!match) return null;\n\n  // According to the specification the implementation should be compatible\n  // with future versions. If there are more parts, we only reject it if it's using version 00\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n  if (match[1] === '00' && match[5]) return null;\n\n  return {\n    traceId: match[2],\n    spanId: match[3],\n    traceFlags: parseInt(match[4], 16),\n  };\n}\n\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n *\n * Based on the Trace Context specification:\n * https://www.w3.org/TR/trace-context/\n */\nexport class W3CTraceContextPropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    const spanContext = trace.getSpanContext(context);\n    if (\n      !spanContext ||\n      isTracingSuppressed(context) ||\n      !isSpanContextValid(spanContext)\n    )\n      return;\n\n    const traceParent = `${VERSION}-${spanContext.traceId}-${\n      spanContext.spanId\n    }-0${Number(spanContext.traceFlags || TraceFlags.NONE).toString(16)}`;\n\n    setter.set(carrier, TRACE_PARENT_HEADER, traceParent);\n    if (spanContext.traceState) {\n      setter.set(\n        carrier,\n        TRACE_STATE_HEADER,\n        spanContext.traceState.serialize()\n      );\n    }\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);\n    if (!traceParentHeader) return context;\n    const traceParent = Array.isArray(traceParentHeader)\n      ? traceParentHeader[0]\n      : traceParentHeader;\n    if (typeof traceParent !== 'string') return context;\n    const spanContext = parseTraceParent(traceParent);\n    if (!spanContext) return context;\n\n    spanContext.isRemote = true;\n\n    const traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);\n    if (traceStateHeader) {\n      // If more than one `tracestate` header is found, we merge them into a\n      // single header.\n      const state = Array.isArray(traceStateHeader)\n        ? traceStateHeader.join(',')\n        : traceStateHeader;\n      spanContext.traceState = new TraceState(\n        typeof state === 'string' ? state : undefined\n      );\n    }\n    return trace.setSpanContext(context, spanContext);\n  }\n\n  fields(): string[] {\n    return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Baggage,\n  BaggageEntryMetadata,\n  baggageEntryMetadataFromString,\n} from '@opentelemetry/api';\nimport {\n  BAGGAGE_ITEMS_SEPARATOR,\n  BAGGAGE_PROPERTIES_SEPARATOR,\n  BAGGAGE_KEY_PAIR_SEPARATOR,\n  BAGGAGE_MAX_TOTAL_LENGTH,\n} from './constants';\n\ntype ParsedBaggageKeyValue = {\n  key: string;\n  value: string;\n  metadata: BaggageEntryMetadata | undefined;\n};\n\nexport function serializeKeyPairs(keyPairs: string[]): string {\n  return keyPairs.reduce((hValue: string, current: string) => {\n    const value = `${hValue}${\n      hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : ''\n    }${current}`;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\n\nexport function getKeyPairs(baggage: Baggage): string[] {\n  return baggage.getAllEntries().map(([key, value]) => {\n    let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;\n\n    // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n\n    return entry;\n  });\n}\n\nexport function parsePairKeyValue(\n  entry: string\n): ParsedBaggageKeyValue | undefined {\n  const valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);\n  if (valueProps.length <= 0) return;\n  const keyPairPart = valueProps.shift();\n  if (!keyPairPart) return;\n  const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0) return;\n  const key = decodeURIComponent(\n    keyPairPart.substring(0, separatorIndex).trim()\n  );\n  const value = decodeURIComponent(\n    keyPairPart.substring(separatorIndex + 1).trim()\n  );\n  let metadata;\n  if (valueProps.length > 0) {\n    metadata = baggageEntryMetadataFromString(\n      valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR)\n    );\n  }\n  return { key, value, metadata };\n}\n\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\nexport function parseKeyPairsIntoRecord(\n  value?: string\n): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  if (typeof value === 'string' && value.length > 0) {\n    value.split(BAGGAGE_ITEMS_SEPARATOR).forEach(entry => {\n      const keyPair = parsePairKeyValue(entry);\n\n      if (keyPair !== undefined && keyPair.value.length > 0) {\n        result[keyPair.key] = keyPair.value;\n      }\n    });\n  }\n\n  return result;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OtlpEncodingOptions, Fixed64, LongBits } from './internal-types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport { hexToBinary } from './hex-to-binary';\n\nexport function hrTimeToNanos(hrTime: HrTime): bigint {\n  const NANOSECONDS = BigInt(1_000_000_000);\n  return (\n    BigInt(Math.trunc(hrTime[0])) * NANOSECONDS + BigInt(Math.trunc(hrTime[1]))\n  );\n}\n\nexport function toLongBits(value: bigint): LongBits {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\n\nexport function encodeAsLongBits(hrTime: HrTime): LongBits {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\n\nexport function encodeAsString(hrTime: HrTime): string {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\n\nconst encodeTimestamp =\n  typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\n\nexport type HrTimeEncodeFunction = (hrTime: HrTime) => Fixed64;\nexport type SpanContextEncodeFunction = (\n  spanContext: string\n) => string | Uint8Array;\nexport type OptionalSpanContextEncodeFunction = (\n  spanContext: string | undefined\n) => string | Uint8Array | undefined;\n\nexport interface Encoder {\n  encodeHrTime: HrTimeEncodeFunction;\n  encodeSpanContext: SpanContextEncodeFunction;\n  encodeOptionalSpanContext: OptionalSpanContextEncodeFunction;\n}\n\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nfunction optionalHexToBinary(str: string | undefined): Uint8Array | undefined {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\n\nconst DEFAULT_ENCODER: Encoder = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary,\n};\n\nexport function getOtlpEncoder(options?: OtlpEncodingOptions): Encoder {\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n\n  const useLongBits = options.useLongBits ?? true;\n  const useHex = options.useHex ?? false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary,\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Configuration shared across all OTLP exporters\n *\n * Implementation note: anything added here MUST be\n * - platform-agnostic\n * - signal-agnostic\n * - transport-agnostic\n */\nexport interface OtlpSharedConfiguration {\n  timeoutMillis: number;\n  concurrencyLimit: number;\n  compression: 'gzip' | 'none';\n}\n\nexport function validateTimeoutMillis(timeoutMillis: number) {\n  if (Number.isFinite(timeoutMillis) && timeoutMillis > 0) {\n    return timeoutMillis;\n  }\n  throw new Error(\n    `Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '${timeoutMillis}')`\n  );\n}\n\nexport function wrapStaticHeadersInFunction(\n  headers: Record<string, string> | undefined\n): (() => Record<string, string>) | undefined {\n  if (headers == null) {\n    return undefined;\n  }\n\n  return () => headers;\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpSharedConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpSharedConfiguration>,\n  fallbackConfiguration: Partial<OtlpSharedConfiguration>,\n  defaultConfiguration: OtlpSharedConfiguration\n): OtlpSharedConfiguration {\n  return {\n    timeoutMillis: validateTimeoutMillis(\n      userProvidedConfiguration.timeoutMillis ??\n        fallbackConfiguration.timeoutMillis ??\n        defaultConfiguration.timeoutMillis\n    ),\n    concurrencyLimit:\n      userProvidedConfiguration.concurrencyLimit ??\n      fallbackConfiguration.concurrencyLimit ??\n      defaultConfiguration.concurrencyLimit,\n    compression:\n      userProvidedConfiguration.compression ??\n      fallbackConfiguration.compression ??\n      defaultConfiguration.compression,\n  };\n}\n\nexport function getSharedConfigurationDefaults(): OtlpSharedConfiguration {\n  return {\n    timeoutMillis: 10000,\n    concurrencyLimit: 30,\n    compression: 'none',\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue } from '../common/Attributes';\nimport { Context } from '../context/types';\nimport { BatchObservableResult, ObservableResult } from './ObservableResult';\n\n/**\n * Advisory options influencing aggregation configuration parameters.\n * @experimental\n */\nexport interface MetricAdvice {\n  /**\n   * Hint the explicit bucket boundaries for SDK if the metric is been\n   * aggregated with a HistogramAggregator.\n   */\n  explicitBucketBoundaries?: number[];\n}\n\n/**\n * Options needed for metric creation\n */\nexport interface MetricOptions {\n  /**\n   * The description of the Metric.\n   * @default ''\n   */\n  description?: string;\n\n  /**\n   * The unit of the Metric values.\n   * @default ''\n   */\n  unit?: string;\n\n  /**\n   * Indicates the type of the recorded value.\n   * @default {@link ValueType.DOUBLE}\n   */\n  valueType?: ValueType;\n\n  /**\n   * The advice influencing aggregation configuration parameters.\n   * @experimental\n   */\n  advice?: MetricAdvice;\n}\n\n/** The Type of value. It describes how the data is reported. */\nexport enum ValueType {\n  INT,\n  DOUBLE,\n}\n\n/**\n * Counter is the most common synchronous instrument. This instrument supports\n * an `Add(increment)` function for reporting a sum, and is restricted to\n * non-negative increments. The default aggregation is Sum, as for any additive\n * instrument.\n *\n * Example uses for Counter:\n * <ol>\n *   <li> count the number of bytes received. </li>\n *   <li> count the number of requests completed. </li>\n *   <li> count the number of accounts created. </li>\n *   <li> count the number of checkpoints run. </li>\n *   <li> count the number of 5xx errors. </li>\n * <ol>\n */\nexport interface Counter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs must not be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface UpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Gauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Histogram<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\n/**\n * @deprecated please use {@link Attributes}\n */\nexport type MetricAttributes = Attributes;\n\n/**\n * @deprecated please use {@link AttributeValue}\n */\nexport type MetricAttributeValue = AttributeValue;\n\n/**\n * The observable callback for Observable instruments.\n */\nexport type ObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: ObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\n/**\n * The observable callback for a batch of Observable instruments.\n */\nexport type BatchObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: BatchObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\nexport interface Observable<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Sets up a function that will be called whenever a metric collection is initiated.\n   *\n   * If the function is already in the list of callbacks for this Observable, the function is not added a second time.\n   */\n  addCallback(callback: ObservableCallback<AttributesTypes>): void;\n\n  /**\n   * Removes a callback previously registered with {@link Observable.addCallback}.\n   */\n  removeCallback(callback: ObservableCallback<AttributesTypes>): void;\n}\n\nexport type ObservableCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableUpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableGauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OTLPExporterConfigBase } from '@opentelemetry/otlp-exporter-base';\nimport {\n  AggregationTemporality,\n  AggregationSelector,\n} from '@opentelemetry/sdk-metrics';\n\nexport interface OTLPMetricExporterOptions extends OTLPExporterConfigBase {\n  temporalityPreference?:\n    | AggregationTemporalityPreference\n    | AggregationTemporality;\n  aggregationPreference?: AggregationSelector;\n}\n\nexport enum AggregationTemporalityPreference {\n  DELTA,\n  CUMULATIVE,\n  LOWMEMORY,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples no traces. */\nexport class AlwaysOffSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOffSampler';\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ExponentMapping } from './ExponentMapping';\nimport { LogarithmMapping } from './LogarithmMapping';\nimport { MappingError, Mapping } from './types';\n\nconst MIN_SCALE = -10;\nconst MAX_SCALE = 20;\nconst PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => {\n  if (i > 10) {\n    return new LogarithmMapping(i - 10);\n  }\n  return new ExponentMapping(i - 10);\n});\n\n/**\n * getMapping returns an appropriate mapping for the given scale. For scales -10\n * to 0 the underlying type will be ExponentMapping. For scales 1 to 20 the\n * underlying type will be LogarithmMapping.\n * @param scale a number in the range [-10, 20]\n * @returns {Mapping}\n */\nexport function getMapping(scale: number): Mapping {\n  if (scale > MAX_SCALE || scale < MIN_SCALE) {\n    throw new MappingError(\n      `expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`\n    );\n  }\n  // mappings are offset by 10. scale -10 is at position 0 and scale 20 is at 30\n  return PREBUILT_MAPPINGS[scale + 10];\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Baggage } from './types';\n\n/**\n * Baggage key\n */\nconst BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');\n\n/**\n * Retrieve the current baggage from the given context\n *\n * @param {Context} Context that manage all context values\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getBaggage(context: Context): Baggage | undefined {\n  return (context.getValue(BAGGAGE_KEY) as Baggage) || undefined;\n}\n\n/**\n * Retrieve the current baggage from the active/current context\n *\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getActiveBaggage(): Baggage | undefined {\n  return getBaggage(ContextAPI.getInstance().active());\n}\n\n/**\n * Store a baggage in the given context\n *\n * @param {Context} Context that manage all context values\n * @param {Baggage} baggage that will be set in the actual context\n */\nexport function setBaggage(context: Context, baggage: Baggage): Context {\n  return context.setValue(BAGGAGE_KEY, baggage);\n}\n\n/**\n * Delete the baggage stored in the given context\n *\n * @param {Context} Context that manage all context values\n */\nexport function deleteBaggage(context: Context): Context {\n  return context.deleteValue(BAGGAGE_KEY);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { W3CBaggagePropagator } from './baggage/propagation/W3CBaggagePropagator';\nexport { AnchoredClock } from './common/anchored-clock';\nexport type { Clock } from './common/anchored-clock';\nexport { isAttributeValue, sanitizeAttributes } from './common/attributes';\nexport {\n  globalErrorHandler,\n  setGlobalErrorHandler,\n} from './common/global-error-handler';\nexport { loggingErrorHandler } from './common/logging-error-handler';\nexport {\n  addHrTimes,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  hrTimeToMicroseconds,\n  hrTimeToMilliseconds,\n  hrTimeToNanoseconds,\n  hrTimeToTimeStamp,\n  isTimeInput,\n  isTimeInputHrTime,\n  millisToHrTime,\n  timeInputToHrTime,\n} from './common/time';\nexport type { ErrorHandler, InstrumentationScope } from './common/types';\nexport { ExportResultCode } from './ExportResult';\nexport type { ExportResult } from './ExportResult';\nexport { parseKeyPairsIntoRecord } from './baggage/utils';\nexport {\n  SDK_INFO,\n  _globalThis,\n  getStringFromEnv,\n  getBooleanFromEnv,\n  getNumberFromEnv,\n  getStringListFromEnv,\n  otperformance,\n  unrefTimer,\n} from './platform';\nexport { CompositePropagator } from './propagation/composite';\nexport type { CompositePropagatorConfig } from './propagation/composite';\nexport {\n  TRACE_PARENT_HEADER,\n  TRACE_STATE_HEADER,\n  W3CTraceContextPropagator,\n  parseTraceParent,\n} from './trace/W3CTraceContextPropagator';\nexport {\n  RPCType,\n  deleteRPCMetadata,\n  getRPCMetadata,\n  setRPCMetadata,\n} from './trace/rpc-metadata';\nexport type { RPCMetadata } from './trace/rpc-metadata';\nexport {\n  isTracingSuppressed,\n  suppressTracing,\n  unsuppressTracing,\n} from './trace/suppress-tracing';\nexport { TraceState } from './trace/TraceState';\nexport { merge } from './utils/merge';\nexport { TimeoutError, callWithTimeout } from './utils/timeout';\nexport { isUrlIgnored, urlMatches } from './utils/url';\nexport { BindOnceFuture } from './utils/callback';\nexport { diagLogLevelFromString } from './utils/configuration';\nimport { _export } from './internal/exporter';\nexport const internal = {\n  _export,\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getStringFromEnv, parseKeyPairsIntoRecord } from '@opentelemetry/core';\nimport { diag } from '@opentelemetry/api';\nimport { getSharedConfigurationFromEnvironment } from './shared-env-configuration';\nimport { wrapStaticHeadersInFunction } from './shared-configuration';\nimport { OtlpNodeHttpConfiguration } from './otlp-node-http-configuration';\n\nfunction getStaticHeadersFromEnv(\n  signalIdentifier: string\n): Record<string, string> | undefined {\n  const signalSpecificRawHeaders = getStringFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_HEADERS`\n  );\n  const nonSignalSpecificRawHeaders = getStringFromEnv(\n    'OTEL_EXPORTER_OTLP_HEADERS'\n  );\n\n  const signalSpecificHeaders = parseKeyPairsIntoRecord(\n    signalSpecificRawHeaders\n  );\n  const nonSignalSpecificHeaders = parseKeyPairsIntoRecord(\n    nonSignalSpecificRawHeaders\n  );\n\n  if (\n    Object.keys(signalSpecificHeaders).length === 0 &&\n    Object.keys(nonSignalSpecificHeaders).length === 0\n  ) {\n    return undefined;\n  }\n\n  // headers are combined instead of overwritten, with the specific headers taking precedence over\n  // the non-specific ones.\n  return Object.assign(\n    {},\n    parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders),\n    parseKeyPairsIntoRecord(signalSpecificRawHeaders)\n  );\n}\n\nfunction appendRootPathToUrlIfNeeded(url: string): string | undefined {\n  try {\n    const parsedUrl = new URL(url);\n    // This will automatically append '/' if there's no root path.\n    return parsedUrl.toString();\n  } catch {\n    diag.warn(\n      `Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`\n    );\n    return undefined;\n  }\n}\n\nfunction appendResourcePathToUrl(\n  url: string,\n  path: string\n): string | undefined {\n  try {\n    // just try to parse, if it fails we catch and warn.\n    new URL(url);\n  } catch {\n    diag.warn(\n      `Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`\n    );\n    return undefined;\n  }\n\n  if (!url.endsWith('/')) {\n    url = url + '/';\n  }\n  url += path;\n\n  try {\n    // just try to parse, if it fails we catch and warn.\n    new URL(url);\n  } catch {\n    diag.warn(\n      `Configuration: Provided URL appended with '${path}' is not a valid URL, using 'undefined' instead of '${url}'`\n    );\n    return undefined;\n  }\n\n  return url;\n}\n\nfunction getNonSpecificUrlFromEnv(\n  signalResourcePath: string\n): string | undefined {\n  const envUrl = getStringFromEnv('OTEL_EXPORTER_OTLP_ENDPOINT');\n  if (envUrl === undefined) {\n    return undefined;\n  }\n  return appendResourcePathToUrl(envUrl, signalResourcePath);\n}\n\nfunction getSpecificUrlFromEnv(signalIdentifier: string): string | undefined {\n  const envUrl = getStringFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_ENDPOINT`\n  );\n  if (envUrl === undefined) {\n    return undefined;\n  }\n  return appendRootPathToUrlIfNeeded(envUrl);\n}\n\n/**\n * Reads and returns configuration from the environment\n *\n * @param signalIdentifier all caps part in environment variables that identifies the signal (e.g.: METRICS, TRACES, LOGS)\n * @param signalResourcePath signal resource path to append if necessary (e.g.: v1/metrics, v1/traces, v1/logs)\n */\nexport function getNodeHttpConfigurationFromEnvironment(\n  signalIdentifier: string,\n  signalResourcePath: string\n): Partial<OtlpNodeHttpConfiguration> {\n  return {\n    ...getSharedConfigurationFromEnvironment(signalIdentifier),\n    url:\n      getSpecificUrlFromEnv(signalIdentifier) ??\n      getNonSpecificUrlFromEnv(signalResourcePath),\n    headers: wrapStaticHeadersInFunction(\n      getStaticHeadersFromEnv(signalIdentifier)\n    ),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context } from '@opentelemetry/api';\nimport { ExportResult } from '../ExportResult';\nimport { suppressTracing } from '../trace/suppress-tracing';\n\nexport interface Exporter<T> {\n  export(arg: T, resultCallback: (result: ExportResult) => void): void;\n}\n\n/**\n * @internal\n * Shared functionality used by Exporters while exporting data, including suppression of Traces.\n */\nexport function _export<T>(\n  exporter: Exporter<T>,\n  arg: T\n): Promise<ExportResult> {\n  return new Promise(resolve => {\n    // prevent downstream exporter calls from generating spans\n    context.with(suppressTracing(context.active()), () => {\n      exporter.export(arg, (result: ExportResult) => {\n        resolve(result);\n      });\n    });\n  });\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getStringFromEnv } from '@opentelemetry/core';\nimport {\n  AggregationTemporality,\n  AggregationTemporalitySelector,\n  InstrumentType,\n  PushMetricExporter,\n  ResourceMetrics,\n  AggregationSelector,\n  AggregationOption,\n  AggregationType,\n} from '@opentelemetry/sdk-metrics';\nimport {\n  AggregationTemporalityPreference,\n  OTLPMetricExporterOptions,\n} from './OTLPMetricExporterOptions';\nimport {\n  IOtlpExportDelegate,\n  OTLPExporterBase,\n} from '@opentelemetry/otlp-exporter-base';\nimport { diag } from '@opentelemetry/api';\n\nexport const CumulativeTemporalitySelector: AggregationTemporalitySelector =\n  () => AggregationTemporality.CUMULATIVE;\n\nexport const DeltaTemporalitySelector: AggregationTemporalitySelector = (\n  instrumentType: InstrumentType\n) => {\n  switch (instrumentType) {\n    case InstrumentType.COUNTER:\n    case InstrumentType.OBSERVABLE_COUNTER:\n    case InstrumentType.GAUGE:\n    case InstrumentType.HISTOGRAM:\n    case InstrumentType.OBSERVABLE_GAUGE:\n      return AggregationTemporality.DELTA;\n    case InstrumentType.UP_DOWN_COUNTER:\n    case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:\n      return AggregationTemporality.CUMULATIVE;\n  }\n};\n\nexport const LowMemoryTemporalitySelector: AggregationTemporalitySelector = (\n  instrumentType: InstrumentType\n) => {\n  switch (instrumentType) {\n    case InstrumentType.COUNTER:\n    case InstrumentType.HISTOGRAM:\n      return AggregationTemporality.DELTA;\n    case InstrumentType.GAUGE:\n    case InstrumentType.UP_DOWN_COUNTER:\n    case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:\n    case InstrumentType.OBSERVABLE_COUNTER:\n    case InstrumentType.OBSERVABLE_GAUGE:\n      return AggregationTemporality.CUMULATIVE;\n  }\n};\n\nfunction chooseTemporalitySelectorFromEnvironment() {\n  const configuredTemporality = (\n    getStringFromEnv('OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE') ??\n    'cumulative'\n  ).toLowerCase();\n\n  if (configuredTemporality === 'cumulative') {\n    return CumulativeTemporalitySelector;\n  }\n  if (configuredTemporality === 'delta') {\n    return DeltaTemporalitySelector;\n  }\n  if (configuredTemporality === 'lowmemory') {\n    return LowMemoryTemporalitySelector;\n  }\n\n  diag.warn(\n    `OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE is set to '${configuredTemporality}', but only 'cumulative' and 'delta' are allowed. Using default ('cumulative') instead.`\n  );\n  return CumulativeTemporalitySelector;\n}\n\nfunction chooseTemporalitySelector(\n  temporalityPreference?:\n    | AggregationTemporalityPreference\n    | AggregationTemporality\n): AggregationTemporalitySelector {\n  // Directly passed preference has priority.\n  if (temporalityPreference != null) {\n    if (temporalityPreference === AggregationTemporalityPreference.DELTA) {\n      return DeltaTemporalitySelector;\n    } else if (\n      temporalityPreference === AggregationTemporalityPreference.LOWMEMORY\n    ) {\n      return LowMemoryTemporalitySelector;\n    }\n    return CumulativeTemporalitySelector;\n  }\n\n  return chooseTemporalitySelectorFromEnvironment();\n}\n\nconst DEFAULT_AGGREGATION = Object.freeze({\n  type: AggregationType.DEFAULT,\n});\n\nfunction chooseAggregationSelector(\n  config: OTLPMetricExporterOptions | undefined\n): AggregationSelector {\n  return config?.aggregationPreference ?? (() => DEFAULT_AGGREGATION);\n}\n\nexport class OTLPMetricExporterBase\n  extends OTLPExporterBase<ResourceMetrics>\n  implements PushMetricExporter\n{\n  private readonly _aggregationTemporalitySelector: AggregationTemporalitySelector;\n  private readonly _aggregationSelector: AggregationSelector;\n\n  constructor(\n    delegate: IOtlpExportDelegate<ResourceMetrics>,\n    config?: OTLPMetricExporterOptions\n  ) {\n    super(delegate);\n    this._aggregationSelector = chooseAggregationSelector(config);\n    this._aggregationTemporalitySelector = chooseTemporalitySelector(\n      config?.temporalityPreference\n    );\n  }\n\n  selectAggregation(instrumentType: InstrumentType): AggregationOption {\n    return this._aggregationSelector(instrumentType);\n  }\n\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OTLPMetricExporterOptions } from '@opentelemetry/exporter-metrics-otlp-http';\nimport { OTLPMetricExporterBase } from '@opentelemetry/exporter-metrics-otlp-http';\nimport { OTLPExporterNodeConfigBase } from '@opentelemetry/otlp-exporter-base';\nimport { ProtobufMetricsSerializer } from '@opentelemetry/otlp-transformer';\nimport { VERSION } from '../../version';\nimport {\n  convertLegacyHttpOptions,\n  createOtlpHttpExportDelegate,\n} from '@opentelemetry/otlp-exporter-base/node-http';\n\nexport class OTLPMetricExporter extends OTLPMetricExporterBase {\n  constructor(config?: OTLPExporterNodeConfigBase & OTLPMetricExporterOptions) {\n    super(\n      createOtlpHttpExportDelegate(\n        convertLegacyHttpOptions(config ?? {}, 'METRICS', 'v1/metrics', {\n          'User-Agent': `OTel-OTLP-Exporter-JavaScript/${VERSION}`,\n          'Content-Type': 'application/x-protobuf',\n        }),\n        ProtobufMetricsSerializer\n      ),\n      config\n    );\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  ExponentialHistogram,\n} from './types';\nimport {\n  DataPointType,\n  ExponentialHistogramMetricData,\n  InstrumentType,\n} from '../export/MetricData';\nimport { diag, HrTime } from '@opentelemetry/api';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { Mapping } from './exponential-histogram/mapping/types';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n\n/**\n * Internal value type for ExponentialHistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram extends ExponentialHistogram {\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n  sum: number;\n}\n\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nclass HighLow {\n  static combine(h1: HighLow, h2: HighLow): HighLow {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  }\n  constructor(\n    public low: number,\n    public high: number\n  ) {}\n}\n\nconst MAX_SCALE = 20;\nconst DEFAULT_MAX_SIZE = 160;\nconst MIN_MAX_SIZE = 2;\n\nexport class ExponentialHistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _maxSize = DEFAULT_MAX_SIZE,\n    private _recordMinMax = true,\n    private _sum = 0,\n    private _count = 0,\n    private _zeroCount = 0,\n    private _min = Number.POSITIVE_INFINITY,\n    private _max = Number.NEGATIVE_INFINITY,\n    private _positive = new Buckets(),\n    private _negative = new Buckets(),\n    private _mapping: Mapping = getMapping(MAX_SCALE)\n  ) {\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \\\n                changing to the minimum size of: ${MIN_MAX_SIZE}`);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  record(value: number) {\n    this.updateByIncrement(value, 1);\n  }\n\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  toPointValue(): InternalHistogram {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts(),\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts(),\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount,\n    };\n  }\n\n  /**\n   * @returns {Number} The sum of values recorded by this accumulation\n   */\n  get sum(): number {\n    return this._sum;\n  }\n\n  /**\n   * @returns {Number} The minimum value recorded by this accumulation\n   */\n  get min(): number {\n    return this._min;\n  }\n\n  /**\n   * @returns {Number} The maximum value recorded by this accumulation\n   */\n  get max(): number {\n    return this._max;\n  }\n\n  /**\n   * @returns {Number} The count of values recorded by this accumulation\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @returns {Number} The number of 0 values recorded by this accumulation\n   */\n  get zeroCount(): number {\n    return this._zeroCount;\n  }\n\n  /**\n   * @returns {Number} The scale used by this accumulation\n   */\n  get scale(): number {\n    if (this._count === this._zeroCount) {\n      // all zeros! scale doesn't matter, use zero\n      return 0;\n    }\n    return this._mapping.scale;\n  }\n\n  /**\n   * positive holds the positive values\n   * @returns {Buckets}\n   */\n  get positive(): Buckets {\n    return this._positive;\n  }\n\n  /**\n   * negative holds the negative values by their absolute value\n   * @returns {Buckets}\n   */\n  get negative(): Buckets {\n    return this._negative;\n  }\n\n  /**\n   * updateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  updateByIncrement(value: number, increment: number) {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n\n    this._count += increment;\n\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n\n    this._sum += value * increment;\n\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  }\n\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  merge(previous: ExponentialHistogramAccumulation) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n\n    const minScale = this._minScale(previous);\n\n    this._downscale(this.scale - minScale);\n\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  }\n\n  /**\n   * diff subtracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  diff(other: ExponentialHistogramAccumulation) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n\n    const minScale = this._minScale(other);\n\n    this._downscale(this.scale - minScale);\n\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  }\n\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  clone(): ExponentialHistogramAccumulation {\n    return new ExponentialHistogramAccumulation(\n      this.startTime,\n      this._maxSize,\n      this._recordMinMax,\n      this._sum,\n      this._count,\n      this._zeroCount,\n      this._min,\n      this._max,\n      this.positive.clone(),\n      this.negative.clone(),\n      this._mapping\n    );\n  }\n\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  private _updateBuckets(buckets: Buckets, value: number, increment: number) {\n    let index = this._mapping.mapToIndex(value);\n\n    // rescale the mapping if needed\n    let rescalingNeeded = false;\n    let high = 0;\n    let low = 0;\n\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (\n      index < buckets.indexStart &&\n      buckets.indexEnd - index >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (\n      index > buckets.indexEnd &&\n      index - buckets.indexStart >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      const change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n\n    this._incrementIndexBy(buckets, index, increment);\n  }\n\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  private _incrementIndexBy(\n    buckets: Buckets,\n    index: number,\n    increment: number\n  ) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n\n    if (buckets.length === 0) {\n      buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;\n    }\n\n    if (index < buckets.indexStart) {\n      const span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      const span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n\n    let bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  }\n\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  private _grow(buckets: Buckets, needed: number) {\n    const size = buckets.backing.length;\n    const bias = buckets.indexBase - buckets.indexStart;\n    const oldPositiveLimit = size - bias;\n    let newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    const newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  }\n\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  private _changeScale(high: number, low: number): number {\n    let change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  }\n\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  private _downscale(change: number) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(`impossible change of scale: ${this.scale}`);\n    }\n    const newScale = this._mapping.scale - change;\n\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n\n    this._mapping = getMapping(newScale);\n  }\n\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  private _minScale(other: ExponentialHistogramAccumulation): number {\n    const minScale = Math.min(this.scale, other.scale);\n\n    const highLowPos = HighLow.combine(\n      this._highLowAtScale(this.positive, this.scale, minScale),\n      this._highLowAtScale(other.positive, other.scale, minScale)\n    );\n\n    const highLowNeg = HighLow.combine(\n      this._highLowAtScale(this.negative, this.scale, minScale),\n      this._highLowAtScale(other.negative, other.scale, minScale)\n    );\n\n    return Math.min(\n      minScale - this._changeScale(highLowPos.high, highLowPos.low),\n      minScale - this._changeScale(highLowNeg.high, highLowNeg.low)\n    );\n  }\n\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  private _highLowAtScale(\n    buckets: Buckets,\n    currentScale: number,\n    newScale: number\n  ): HighLow {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    const shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  }\n\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  private _mergeBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(\n        ours,\n        (theirOffset + i) >> theirChange,\n        theirs.at(i)\n      );\n    }\n  }\n\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  private _diffBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      const ourIndex = (theirOffset + i) >> theirChange;\n      let bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n\n    ours.trim();\n  }\n}\n\n/**\n * Aggregator for ExponentialHistogramAccumulations\n */\nexport class ExponentialHistogramAggregator\n  implements Aggregator<ExponentialHistogramAccumulation>\n{\n  public kind: AggregatorKind.EXPONENTIAL_HISTOGRAM =\n    AggregatorKind.EXPONENTIAL_HISTOGRAM;\n\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    readonly _maxSize: number,\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new ExponentialHistogramAccumulation(\n      startTime,\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  merge(\n    previous: ExponentialHistogramAccumulation,\n    delta: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = delta.clone();\n    result.merge(previous);\n\n    return result;\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: ExponentialHistogramAccumulation,\n    current: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = current.clone();\n    result.diff(previous);\n\n    return result;\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<ExponentialHistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<ExponentialHistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts,\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts,\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount,\n          },\n        };\n      }),\n    };\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * AggregationTemporality indicates the way additive quantities are expressed.\n */\nexport enum AggregationTemporality {\n  DELTA,\n  CUMULATIVE,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Error that is thrown on timeouts.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message);\n\n    // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:\n    // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\n/**\n * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise\n * rejects, and resolves if the specified promise resolves.\n *\n * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.\n *\n * @param promise promise to use with timeout.\n * @param timeout the timeout in milliseconds until the returned promise is rejected.\n */\nexport function callWithTimeout<T>(\n  promise: Promise<T>,\n  timeout: number\n): Promise<T> {\n  let timeoutHandle: ReturnType<typeof setTimeout>;\n\n  const timeoutPromise = new Promise<never>(function timeoutFunction(\n    _resolve,\n    reject\n  ) {\n    timeoutHandle = setTimeout(function timeoutHandler() {\n      reject(new TimeoutError('Operation timed out.'));\n    }, timeout);\n  });\n\n  return Promise.race([promise, timeoutPromise]).then(\n    result => {\n      clearTimeout(timeoutHandle);\n      return result;\n    },\n    reason => {\n      clearTimeout(timeoutHandle);\n      throw reason;\n    }\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\n\n/**\n * Parses headers from config leaving only those that have defined values\n * @param partialHeaders\n */\nexport function validateAndNormalizeHeaders(\n  partialHeaders: (() => Record<string, string>) | undefined\n): () => Record<string, string> {\n  return () => {\n    const headers: Record<string, string> = {};\n    Object.entries(partialHeaders?.() ?? {}).forEach(([key, value]) => {\n      if (typeof value !== 'undefined') {\n        headers[key] = String(value);\n      } else {\n        diag.warn(\n          `Header \"${key}\" has invalid value (${value}) and will be ignored`\n        );\n      }\n    });\n    return headers;\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag, Exception } from '@opentelemetry/api';\nimport { ErrorHandler } from './types';\n\n/**\n * Returns a function that logs an error using the provided logger, or a\n * console logger if one was not provided.\n */\nexport function loggingErrorHandler(): ErrorHandler {\n  return (ex: Exception) => {\n    diag.error(stringifyException(ex));\n  };\n}\n\n/**\n * Converts an exception into a string representation\n * @param {Exception} ex\n */\nfunction stringifyException(ex: Exception | string): string {\n  if (typeof ex === 'string') {\n    return ex;\n  } else {\n    return JSON.stringify(flattenException(ex));\n  }\n}\n\n/**\n * Flattens an exception into key-value pairs by traversing the prototype chain\n * and coercing values to strings. Duplicate properties will not be overwritten;\n * the first insert wins.\n */\nfunction flattenException(ex: Exception): Record<string, string> {\n  const result = {} as Record<string, string>;\n  let current = ex;\n\n  while (current !== null) {\n    Object.getOwnPropertyNames(current).forEach(propertyName => {\n      if (result[propertyName]) return;\n      const value = current[propertyName as keyof typeof current];\n      if (value) {\n        result[propertyName] = String(value);\n      }\n    });\n    current = Object.getPrototypeOf(current);\n  }\n\n  return result;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Sum,\n  AggregatorKind,\n  Aggregator,\n  Accumulation,\n  AccumulationRecord,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { DataPointType, SumMetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport class SumAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    public monotonic: boolean,\n    private _current = 0,\n    public reset = false\n  ) {}\n\n  record(value: number): void {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): Sum {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a Sum from individual measurements. */\nexport class SumAggregator implements Aggregator<SumAccumulation> {\n  public kind: AggregatorKind.SUM = AggregatorKind.SUM;\n\n  constructor(public monotonic: boolean) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  merge(previous: SumAccumulation, delta: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(\n        delta.startTime,\n        this.monotonic,\n        deltaPv,\n        delta.reset\n      );\n    }\n    return new SumAccumulation(\n      previous.startTime,\n      this.monotonic,\n      prevPv + deltaPv\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous: SumAccumulation, current: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(\n        current.startTime,\n        this.monotonic,\n        currPv,\n        true\n      );\n    }\n    return new SumAccumulation(\n      current.startTime,\n      this.monotonic,\n      currPv - prevPv\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<SumAccumulation>[],\n    endTime: HrTime\n  ): Maybe<SumMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n      isMonotonic: this.monotonic,\n    };\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  LastValue,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport { DataPointType, GaugeMetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport class LastValueAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _current = 0,\n    public sampleTime: HrTime = [0, 0]\n  ) {}\n\n  record(value: number): void {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): LastValue {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nexport class LastValueAggregator implements Aggregator<LastValueAccumulation> {\n  public kind: AggregatorKind.LAST_VALUE = AggregatorKind.LAST_VALUE;\n\n  createAccumulation(startTime: HrTime) {\n    return new LastValueAccumulation(startTime);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  merge(\n    previous: LastValueAccumulation,\n    delta: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(delta.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? delta\n        : previous;\n    return new LastValueAccumulation(\n      previous.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  diff(\n    previous: LastValueAccumulation,\n    current: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(current.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? current\n        : previous;\n    return new LastValueAccumulation(\n      current.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<LastValueAccumulation>[],\n    endTime: HrTime\n  ): Maybe<GaugeMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n    };\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { TextMapPropagator } from './TextMapPropagator';\n\n/**\n * No-op implementations of {@link TextMapPropagator}.\n */\nexport class NoopTextMapPropagator implements TextMapPropagator {\n  /** Noop inject function does nothing */\n  inject(_context: Context, _carrier: unknown): void {}\n  /** Noop extract function does nothing and returns the input context */\n  extract(context: Context, _carrier: unknown): Context {\n    return context;\n  }\n  fields(): string[] {\n    return [];\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { InstrumentType } from './MetricData';\nimport { AggregationOption, AggregationType } from '../view/AggregationOption';\n\n/**\n * Aggregation selector based on metric instrument types.\n */\nexport type AggregationSelector = (\n  instrumentType: InstrumentType\n) => AggregationOption;\n\n/**\n * Aggregation temporality selector based on metric instrument types.\n */\nexport type AggregationTemporalitySelector = (\n  instrumentType: InstrumentType\n) => AggregationTemporality;\n\nexport const DEFAULT_AGGREGATION_SELECTOR: AggregationSelector =\n  _instrumentType => {\n    return {\n      type: AggregationType.DEFAULT,\n    };\n  };\n\nexport const DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR: AggregationTemporalitySelector =\n  _instrumentType => AggregationTemporality.CUMULATIVE;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getNumberFromEnv } from '@opentelemetry/core';\nimport { LogRecordLimits } from './types';\n\nexport function loadDefaultConfig() {\n  return {\n    forceFlushTimeoutMillis: 30000,\n    logRecordLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n        Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n    },\n    includeTraceContext: true,\n  };\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param logRecordLimits User provided limits configuration\n */\nexport function reconfigureLimits(\n  logRecordLimits: LogRecordLimits\n): Required<LogRecordLimits> {\n  return {\n    /**\n     * Reassign log record attribute count limit to use first non null value defined by user or use default value\n     */\n    attributeCountLimit:\n      logRecordLimits.attributeCountLimit ??\n      getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT') ??\n      getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ??\n      128,\n    /**\n     * Reassign log record attribute value length limit to use first non null value defined by user or use default value\n     */\n    attributeValueLengthLimit:\n      logRecordLimits.attributeValueLengthLimit ??\n      getNumberFromEnv('OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n      getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n      Infinity,\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, Attributes } from '@opentelemetry/api';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { MetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\n/** The kind of aggregator. */\nexport enum AggregatorKind {\n  DROP,\n  SUM,\n  LAST_VALUE,\n  HISTOGRAM,\n  EXPONENTIAL_HISTOGRAM,\n}\n\n/** DataPoint value type for SumAggregation. */\nexport type Sum = number;\n\n/** DataPoint value type for LastValueAggregation. */\nexport type LastValue = number;\n\n/** DataPoint value type for HistogramAggregation. */\nexport interface Histogram {\n  /**\n   * Buckets are implemented using two different arrays:\n   *  - boundaries: contains every finite bucket boundary, which are inclusive upper bounds\n   *  - counts: contains event counts for each bucket\n   *\n   * Note that we'll always have n+1 buckets, where n is the number of boundaries.\n   * This is because we need to count events that are higher than the upper boundary.\n   *\n   * Example: if we measure the values: [5, 30, 5, 40, 5, 15, 15, 15, 25]\n   *  with the boundaries [ 10, 20, 30 ], we will have the following state:\n   *\n   * buckets: {\n   *\tboundaries: [10, 20, 30],\n   *\tcounts: [3, 3, 2, 1],\n   * }\n   */\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum?: number;\n  count: number;\n  min?: number;\n  max?: number;\n}\n\n/** DataPoint value type for ExponentialHistogramAggregation. */\nexport interface ExponentialHistogram {\n  count: number;\n  sum?: number;\n  scale: number;\n  zeroCount: number;\n  positive: {\n    offset: number;\n    bucketCounts: number[];\n  };\n  negative: {\n    offset: number;\n    bucketCounts: number[];\n  };\n  min?: number;\n  max?: number;\n}\n\n/**\n * An Aggregator accumulation state.\n */\nexport interface Accumulation {\n  setStartTime(startTime: HrTime): void;\n  record(value: number): void;\n}\n\nexport type AccumulationRecord<T> = [Attributes, T];\n\n/**\n * Base interface for aggregators. Aggregators are responsible for holding\n * aggregated values and taking a snapshot of these values upon export.\n */\nexport interface Aggregator<T> {\n  /** The kind of the aggregator. */\n  kind: AggregatorKind;\n\n  /**\n   * Create a clean state of accumulation.\n   */\n  createAccumulation(startTime: HrTime): T;\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * This should always assume that the accumulations do not overlap and merge together for a new\n   * cumulative report.\n   *\n   * @param previous the previously captured accumulation\n   * @param delta the newly captured (delta) accumulation\n   * @returns the result of the merge of the given accumulations\n   */\n  merge(previous: T, delta: T): T;\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * @param previous the previously captured accumulation\n   * @param current the newly captured (cumulative) accumulation\n   * @returns The resulting delta accumulation\n   */\n  diff(previous: T, current: T): T;\n\n  /**\n   * Returns the {@link MetricData} that this {@link Aggregator} will produce.\n   *\n   * @param descriptor the metric descriptor.\n   * @param aggregationTemporality the temporality of the resulting {@link MetricData}\n   * @param accumulationByAttributes the array of attributes and accumulation pairs.\n   * @param endTime the end time of the metric data.\n   * @return the {@link MetricData} that this {@link Aggregator} will produce.\n   */\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<T>[],\n    endTime: HrTime\n  ): Maybe<MetricData>;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport * as api from '@opentelemetry/api';\nimport {\n  timeInputToHrTime,\n  isAttributeValue,\n  InstrumentationScope,\n} from '@opentelemetry/core';\nimport type { Resource } from '@opentelemetry/resources';\n\nimport type { ReadableLogRecord } from './export/ReadableLogRecord';\nimport type { LogRecordLimits } from './types';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\n\nexport class LogRecordImpl implements ReadableLogRecord {\n  readonly hrTime: api.HrTime;\n  readonly hrTimeObserved: api.HrTime;\n  readonly spanContext?: api.SpanContext;\n  readonly resource: Resource;\n  readonly instrumentationScope: InstrumentationScope;\n  readonly attributes: logsAPI.LogAttributes = {};\n  private _severityText?: string;\n  private _severityNumber?: logsAPI.SeverityNumber;\n  private _body?: logsAPI.LogBody;\n  private _eventName?: string;\n  private totalAttributesCount: number = 0;\n\n  private _isReadonly: boolean = false;\n  private readonly _logRecordLimits: Required<LogRecordLimits>;\n\n  set severityText(severityText: string | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._severityText = severityText;\n  }\n  get severityText(): string | undefined {\n    return this._severityText;\n  }\n\n  set severityNumber(severityNumber: logsAPI.SeverityNumber | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._severityNumber = severityNumber;\n  }\n  get severityNumber(): logsAPI.SeverityNumber | undefined {\n    return this._severityNumber;\n  }\n\n  set body(body: logsAPI.LogBody | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._body = body;\n  }\n  get body(): logsAPI.LogBody | undefined {\n    return this._body;\n  }\n\n  get eventName(): string | undefined {\n    return this._eventName;\n  }\n  set eventName(eventName: string | undefined) {\n    if (this._isLogRecordReadonly()) {\n      return;\n    }\n    this._eventName = eventName;\n  }\n\n  get droppedAttributesCount(): number {\n    return this.totalAttributesCount - Object.keys(this.attributes).length;\n  }\n\n  constructor(\n    _sharedState: LoggerProviderSharedState,\n    instrumentationScope: InstrumentationScope,\n    logRecord: logsAPI.LogRecord\n  ) {\n    const {\n      timestamp,\n      observedTimestamp,\n      eventName,\n      severityNumber,\n      severityText,\n      body,\n      attributes = {},\n      context,\n    } = logRecord;\n\n    const now = Date.now();\n    this.hrTime = timeInputToHrTime(timestamp ?? now);\n    this.hrTimeObserved = timeInputToHrTime(observedTimestamp ?? now);\n\n    if (context) {\n      const spanContext = api.trace.getSpanContext(context);\n      if (spanContext && api.isSpanContextValid(spanContext)) {\n        this.spanContext = spanContext;\n      }\n    }\n    this.severityNumber = severityNumber;\n    this.severityText = severityText;\n    this.body = body;\n    this.resource = _sharedState.resource;\n    this.instrumentationScope = instrumentationScope;\n    this._logRecordLimits = _sharedState.logRecordLimits;\n    this._eventName = eventName;\n    this.setAttributes(attributes);\n  }\n\n  public setAttribute(key: string, value?: logsAPI.AnyValue) {\n    if (this._isLogRecordReadonly()) {\n      return this;\n    }\n    if (value === null) {\n      return this;\n    }\n    if (key.length === 0) {\n      api.diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (\n      !isAttributeValue(value) &&\n      !(\n        typeof value === 'object' &&\n        !Array.isArray(value) &&\n        Object.keys(value).length > 0\n      )\n    ) {\n      api.diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n    this.totalAttributesCount += 1;\n    if (\n      Object.keys(this.attributes).length >=\n        this._logRecordLimits.attributeCountLimit &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      // This logic is to create drop message at most once per LogRecord to prevent excessive logging.\n      if (this.droppedAttributesCount === 1) {\n        api.diag.warn('Dropping extra attributes.');\n      }\n      return this;\n    }\n    if (isAttributeValue(value)) {\n      this.attributes[key] = this._truncateToSize(value);\n    } else {\n      this.attributes[key] = value;\n    }\n    return this;\n  }\n\n  public setAttributes(attributes: logsAPI.LogAttributes) {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  public setBody(body: logsAPI.LogBody) {\n    this.body = body;\n    return this;\n  }\n\n  public setEventName(eventName: string) {\n    this.eventName = eventName;\n    return this;\n  }\n\n  public setSeverityNumber(severityNumber: logsAPI.SeverityNumber) {\n    this.severityNumber = severityNumber;\n    return this;\n  }\n\n  public setSeverityText(severityText: string) {\n    this.severityText = severityText;\n    return this;\n  }\n\n  /**\n   * @internal\n   * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.\n   * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.\n   */\n  _makeReadonly() {\n    this._isReadonly = true;\n  }\n\n  private _truncateToSize(value: api.AttributeValue): api.AttributeValue {\n    const limit = this._logRecordLimits.attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      api.diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  private _isLogRecordReadonly(): boolean {\n    if (this._isReadonly) {\n      api.diag.warn('Can not execute the operation on emitted log record');\n    }\n    return this._isReadonly;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  Aggregator,\n  SumAggregator,\n  DropAggregator,\n  LastValueAggregator,\n  HistogramAggregator,\n  ExponentialHistogramAggregator,\n} from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\nimport { InstrumentType } from '../export/MetricData';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport interface Aggregation {\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>>;\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation implements Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n\n */\nexport class HistogramAggregation implements Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator(\n    [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000],\n    true\n  );\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation implements Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    boundaries: number[],\n    private readonly _recordMinMax = true\n  ) {\n    if (boundaries == null) {\n      throw new Error(\n        'ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array'\n      );\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\nexport class ExponentialHistogramAggregation implements Aggregation {\n  constructor(\n    private readonly _maxSize = 160,\n    private readonly _recordMinMax = true\n  ) {}\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new ExponentialHistogramAggregator(\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation implements Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.GAUGE:\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        if (instrument.advice.explicitBucketBoundaries) {\n          return new ExplicitBucketHistogramAggregation(\n            instrument.advice.explicitBucketBoundaries\n          );\n        }\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nexport const DROP_AGGREGATION = new DropAggregation();\nexport const SUM_AGGREGATION = new SumAggregation();\nexport const LAST_VALUE_AGGREGATION = new LastValueAggregation();\nexport const HISTOGRAM_AGGREGATION = new HistogramAggregation();\nexport const EXPONENTIAL_HISTOGRAM_AGGREGATION =\n  new ExponentialHistogramAggregation();\nexport const DEFAULT_AGGREGATION = new DefaultAggregation();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTE: do not change these type imports to actual imports. Doing so WILL break `@opentelemetry/instrumentation-http`,\n// as they'd be imported before the http/https modules can be wrapped.\nimport type * as https from 'https';\nimport type * as http from 'http';\nimport { ExportResponse } from '../export-response';\nimport { IExporterTransport } from '../exporter-transport';\nimport { sendWithHttp } from './http-transport-utils';\nimport { NodeHttpRequestParameters } from './node-http-transport-types';\n\ninterface Utils {\n  agent: http.Agent | https.Agent;\n  request: typeof http.request | typeof https.request;\n}\n\nclass HttpExporterTransport implements IExporterTransport {\n  private _utils: Utils | null = null;\n\n  constructor(private _parameters: NodeHttpRequestParameters) {}\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const { agent, request } = await this._loadUtils();\n\n    return new Promise<ExportResponse>(resolve => {\n      sendWithHttp(\n        request,\n        this._parameters,\n        agent,\n        data,\n        result => {\n          resolve(result);\n        },\n        timeoutMillis\n      );\n    });\n  }\n\n  shutdown() {\n    // intentionally left empty, nothing to do.\n  }\n\n  private async _loadUtils(): Promise<Utils> {\n    let utils = this._utils;\n\n    if (utils === null) {\n      const protocol = new URL(this._parameters.url).protocol;\n      const [agent, request] = await Promise.all([\n        this._parameters.agentFactory(protocol),\n        requestFunctionFactory(protocol),\n      ]);\n      utils = this._utils = { agent, request };\n    }\n\n    return utils;\n  }\n}\n\nasync function requestFunctionFactory(\n  protocol: string\n): Promise<typeof http.request | typeof https.request> {\n  const module = protocol === 'http:' ? import('http') : import('https');\n  const { request } = await module;\n  return request;\n}\n\nexport function createHttpExporterTransport(\n  parameters: NodeHttpRequestParameters\n): IExporterTransport {\n  return new HttpExporterTransport(parameters);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNumberFromEnv, getStringFromEnv } from '@opentelemetry/core';\nimport { OtlpSharedConfiguration } from './shared-configuration';\nimport { diag } from '@opentelemetry/api';\n\nfunction parseAndValidateTimeoutFromEnv(\n  timeoutEnvVar: string\n): number | undefined {\n  const envTimeout = getNumberFromEnv(timeoutEnvVar);\n  if (envTimeout != null) {\n    if (Number.isFinite(envTimeout) && envTimeout > 0) {\n      return envTimeout;\n    }\n    diag.warn(\n      `Configuration: ${timeoutEnvVar} is invalid, expected number greater than 0 (actual: ${envTimeout})`\n    );\n  }\n\n  return undefined;\n}\n\nfunction getTimeoutFromEnv(signalIdentifier: string) {\n  const specificTimeout = parseAndValidateTimeoutFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_TIMEOUT`\n  );\n  const nonSpecificTimeout = parseAndValidateTimeoutFromEnv(\n    'OTEL_EXPORTER_OTLP_TIMEOUT'\n  );\n\n  return specificTimeout ?? nonSpecificTimeout;\n}\n\nfunction parseAndValidateCompressionFromEnv(\n  compressionEnvVar: string\n): 'none' | 'gzip' | undefined {\n  const compression = getStringFromEnv(compressionEnvVar)?.trim();\n\n  if (compression == null || compression === 'none' || compression === 'gzip') {\n    return compression;\n  }\n\n  diag.warn(\n    `Configuration: ${compressionEnvVar} is invalid, expected 'none' or 'gzip' (actual: '${compression}')`\n  );\n  return undefined;\n}\n\nfunction getCompressionFromEnv(\n  signalIdentifier: string\n): 'none' | 'gzip' | undefined {\n  const specificCompression = parseAndValidateCompressionFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_COMPRESSION`\n  );\n  const nonSpecificCompression = parseAndValidateCompressionFromEnv(\n    'OTEL_EXPORTER_OTLP_COMPRESSION'\n  );\n\n  return specificCompression ?? nonSpecificCompression;\n}\n\nexport function getSharedConfigurationFromEnvironment(\n  signalIdentifier: string\n): Partial<OtlpSharedConfiguration> {\n  return {\n    timeoutMillis: getTimeoutFromEnv(signalIdentifier),\n    compression: getCompressionFromEnv(signalIdentifier),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * based on lodash in order to support esm builds without esModuleInterop.\n * lodash is using MIT License.\n **/\n\nconst objectTag = '[object Object]';\nconst nullTag = '[object Null]';\nconst undefinedTag = '[object Undefined]';\nconst funcProto = Function.prototype;\nconst funcToString = funcProto.toString;\nconst objectCtorString = funcToString.call(Object);\nconst getPrototypeOf = Object.getPrototypeOf;\nconst objectProto = Object.prototype;\nconst hasOwnProperty = objectProto.hasOwnProperty;\nconst symToStringTag = Symbol ? Symbol.toStringTag : undefined;\nconst nativeObjectToString = objectProto.toString;\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nexport function isPlainObject(value: any) {\n  if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {\n    return false;\n  }\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return (\n    typeof Ctor == 'function' &&\n    Ctor instanceof Ctor &&\n    funcToString.call(Ctor) === objectCtorString\n  );\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value: any) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value: any) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return symToStringTag && symToStringTag in Object(value)\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value: any) {\n  const isOwn = hasOwnProperty.call(value, symToStringTag as any),\n    tag = value[symToStringTag as any];\n  let unmasked = false;\n\n  try {\n    value[symToStringTag as any] = undefined;\n    unmasked = true;\n  } catch {\n    // silence\n  }\n\n  const result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag as any] = tag;\n    } else {\n      delete value[symToStringTag as any];\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value: any) {\n  return nativeObjectToString.call(value);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { MetricReader } from './MetricReader';\nimport { PushMetricExporter } from './MetricExporter';\nimport { callWithTimeout, TimeoutError } from '../utils';\nimport { MetricProducer } from './MetricProducer';\n\nexport type PeriodicExportingMetricReaderOptions = {\n  /**\n   * The backing exporter for the metric reader.\n   */\n  exporter: PushMetricExporter;\n  /**\n   * An internal milliseconds for the metric reader to initiate metric\n   * collection.\n   */\n  exportIntervalMillis?: number;\n  /**\n   * Milliseconds for the async observable callback to timeout.\n   */\n  exportTimeoutMillis?: number;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n};\n\n/**\n * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to\n * the configured {@link PushMetricExporter}\n */\nexport class PeriodicExportingMetricReader extends MetricReader {\n  private _interval?: ReturnType<typeof setInterval>;\n  private _exporter: PushMetricExporter;\n  private readonly _exportInterval: number;\n  private readonly _exportTimeout: number;\n\n  constructor(options: PeriodicExportingMetricReaderOptions) {\n    super({\n      aggregationSelector: options.exporter.selectAggregation?.bind(\n        options.exporter\n      ),\n      aggregationTemporalitySelector:\n        options.exporter.selectAggregationTemporality?.bind(options.exporter),\n      metricProducers: options.metricProducers,\n    });\n\n    if (\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis <= 0\n    ) {\n      throw Error('exportIntervalMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportTimeoutMillis <= 0\n    ) {\n      throw Error('exportTimeoutMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis < options.exportTimeoutMillis\n    ) {\n      throw Error(\n        'exportIntervalMillis must be greater than or equal to exportTimeoutMillis'\n      );\n    }\n\n    this._exportInterval = options.exportIntervalMillis ?? 60000;\n    this._exportTimeout = options.exportTimeoutMillis ?? 30000;\n    this._exporter = options.exporter;\n  }\n\n  private async _runOnce(): Promise<void> {\n    try {\n      await callWithTimeout(this._doRun(), this._exportTimeout);\n    } catch (err) {\n      if (err instanceof TimeoutError) {\n        api.diag.error(\n          'Export took longer than %s milliseconds and timed out.',\n          this._exportTimeout\n        );\n        return;\n      }\n\n      globalErrorHandler(err);\n    }\n  }\n\n  private async _doRun(): Promise<void> {\n    const { resourceMetrics, errors } = await this.collect({\n      timeoutMillis: this._exportTimeout,\n    });\n\n    if (errors.length > 0) {\n      api.diag.error(\n        'PeriodicExportingMetricReader: metrics collection errors',\n        ...errors\n      );\n    }\n\n    if (resourceMetrics.resource.asyncAttributesPending) {\n      try {\n        await resourceMetrics.resource.waitForAsyncAttributes?.();\n      } catch (e) {\n        api.diag.debug('Error while resolving async portion of resource: ', e);\n        globalErrorHandler(e);\n      }\n    }\n\n    if (resourceMetrics.scopeMetrics.length === 0) {\n      return;\n    }\n\n    const result = await internal._export(this._exporter, resourceMetrics);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw new Error(\n        `PeriodicExportingMetricReader: metrics export failed (error ${result.error})`\n      );\n    }\n  }\n\n  protected override onInitialized(): void {\n    // start running the interval as soon as this reader is initialized and keep handle for shutdown.\n    this._interval = setInterval(() => {\n      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.\n      void this._runOnce();\n    }, this._exportInterval);\n    unrefTimer(this._interval);\n  }\n\n  protected async onForceFlush(): Promise<void> {\n    await this._runOnce();\n    await this._exporter.forceFlush();\n  }\n\n  protected async onShutdown(): Promise<void> {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    await this.onForceFlush();\n    await this._exporter.shutdown();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from './exporter-transport';\nimport { ExportResponse } from './export-response';\n\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\n\nclass RetryingTransport implements IExporterTransport {\n  constructor(private _transport: IExporterTransport) {}\n\n  private retry(\n    data: Uint8Array,\n    timeoutMillis: number,\n    inMillis: number\n  ): Promise<ExportResponse> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(\n        Math.min(nextBackoff, MAX_BACKOFF) + getJitter(),\n        0\n      );\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        return result;\n      }\n\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n\n    return result;\n  }\n\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options: {\n  // Underlying transport to wrap.\n  transport: IExporterTransport;\n}): IExporterTransport {\n  return new RetryingTransport(options.transport);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger } from '@opentelemetry/api-logs';\nimport { Resource } from '@opentelemetry/resources';\nimport { LogRecordProcessor } from '../LogRecordProcessor';\nimport { LogRecordLimits } from '../types';\nimport { NoopLogRecordProcessor } from '../export/NoopLogRecordProcessor';\nimport { MultiLogRecordProcessor } from '../MultiLogRecordProcessor';\n\nexport class LoggerProviderSharedState {\n  readonly loggers: Map<string, Logger> = new Map();\n  activeProcessor: LogRecordProcessor;\n  readonly registeredLogRecordProcessors: LogRecordProcessor[] = [];\n\n  constructor(\n    readonly resource: Resource,\n    readonly forceFlushTimeoutMillis: number,\n    readonly logRecordLimits: Required<LogRecordLimits>,\n    readonly processors: LogRecordProcessor[]\n  ) {\n    if (processors.length > 0) {\n      this.registeredLogRecordProcessors = processors;\n      this.activeProcessor = new MultiLogRecordProcessor(\n        this.registeredLogRecordProcessors,\n        this.forceFlushTimeoutMillis\n      );\n    } else {\n      this.activeProcessor = new NoopLogRecordProcessor();\n    }\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\nimport {\n  OTLPExporterNodeConfigBase,\n  OTLPExporterBase,\n} from '@opentelemetry/otlp-exporter-base';\nimport { VERSION } from '../../version';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\nimport {\n  convertLegacyHttpOptions,\n  createOtlpHttpExportDelegate,\n} from '@opentelemetry/otlp-exporter-base/node-http';\n\n/**\n * Collector Trace Exporter for Node\n */\nexport class OTLPTraceExporter\n  extends OTLPExporterBase<ReadableSpan[]>\n  implements SpanExporter\n{\n  constructor(config: OTLPExporterNodeConfigBase = {}) {\n    super(\n      createOtlpHttpExportDelegate(\n        convertLegacyHttpOptions(config, 'TRACES', 'v1/traces', {\n          'User-Agent': `OTel-OTLP-Exporter-JavaScript/${VERSION}`,\n          'Content-Type': 'application/json',\n        }),\n        JsonTraceSerializer\n      )\n    );\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {\n  ReadableLogRecord,\n  LogRecordExporter,\n} from '@opentelemetry/sdk-logs';\nimport type { OTLPExporterNodeConfigBase } from '@opentelemetry/otlp-exporter-base';\nimport { OTLPExporterBase } from '@opentelemetry/otlp-exporter-base';\nimport { JsonLogsSerializer } from '@opentelemetry/otlp-transformer';\nimport { VERSION } from '../../version';\nimport {\n  convertLegacyHttpOptions,\n  createOtlpHttpExportDelegate,\n} from '@opentelemetry/otlp-exporter-base/node-http';\n\n/**\n * Collector Logs Exporter for Node\n */\nexport class OTLPLogExporter\n  extends OTLPExporterBase<ReadableLogRecord[]>\n  implements LogRecordExporter\n{\n  constructor(config: OTLPExporterNodeConfigBase = {}) {\n    super(\n      createOtlpHttpExportDelegate(\n        convertLegacyHttpOptions(config, 'LOGS', 'v1/logs', {\n          'User-Agent': `OTel-OTLP-Exporter-JavaScript/${VERSION}`,\n          'Content-Type': 'application/json',\n        }),\n        JsonLogsSerializer\n      )\n    );\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const BAGGAGE_KEY_PAIR_SEPARATOR = '=';\nexport const BAGGAGE_PROPERTIES_SEPARATOR = ';';\nexport const BAGGAGE_ITEMS_SEPARATOR = ',';\n\n// Name of the http header used to propagate the baggage\nexport const BAGGAGE_HEADER = 'baggage';\n// Maximum number of name-value pairs allowed by w3c spec\nexport const BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;\n// Maximum number of bytes per a single name-value pair allowed by w3c spec\nexport const BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;\n// Maximum total length of all name-value pairs allowed by w3c spec\nexport const BAGGAGE_MAX_TOTAL_LENGTH = 8192;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport type { InstrumentationScope } from '@opentelemetry/core';\nimport { context } from '@opentelemetry/api';\n\nimport { LogRecordImpl } from './LogRecordImpl';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\n\nexport class Logger implements logsAPI.Logger {\n  constructor(\n    public readonly instrumentationScope: InstrumentationScope,\n    private _sharedState: LoggerProviderSharedState\n  ) {}\n\n  public emit(logRecord: logsAPI.LogRecord): void {\n    const currentContext = logRecord.context || context.active();\n    /**\n     * If a Logger was obtained with include_trace_context=true,\n     * the LogRecords it emits MUST automatically include the Trace Context from the active Context,\n     * if Context has not been explicitly set.\n     */\n    const logRecordInstance = new LogRecordImpl(\n      this._sharedState,\n      this.instrumentationScope,\n      {\n        context: currentContext,\n        ...logRecord,\n      }\n    );\n    /**\n     * the explicitly passed Context,\n     * the current Context, or an empty Context if the Logger was obtained with include_trace_context=false\n     */\n    this._sharedState.activeProcessor.onEmit(logRecordInstance, currentContext);\n    /**\n     * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.\n     * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.\n     */\n    logRecordInstance._makeReadonly();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { getNumberFromEnv, getStringFromEnv } from '@opentelemetry/core';\nimport { Sampler } from './Sampler';\nimport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nimport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nimport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nimport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\n\nconst enum TracesSamplerValues {\n  AlwaysOff = 'always_off',\n  AlwaysOn = 'always_on',\n  ParentBasedAlwaysOff = 'parentbased_always_off',\n  ParentBasedAlwaysOn = 'parentbased_always_on',\n  ParentBasedTraceIdRatio = 'parentbased_traceidratio',\n  TraceIdRatio = 'traceidratio',\n}\n\nconst DEFAULT_RATIO = 1;\n\n/**\n * Load default configuration. For fields with primitive values, any user-provided\n * value will override the corresponding default value. For fields with\n * non-primitive values (like `spanLimits`), the user-provided value will be\n * used to extend the default value.\n */\n\n// object needs to be wrapped in this function and called when needed otherwise\n// envs are parsed before tests are ran - causes tests using these envs to fail\nexport function loadDefaultConfig() {\n  return {\n    sampler: buildSamplerFromEnv(),\n    forceFlushTimeoutMillis: 30000,\n    generalLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n    },\n    spanLimits: {\n      attributeValueLengthLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? Infinity,\n      attributeCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ?? 128,\n      linkCountLimit: getNumberFromEnv('OTEL_SPAN_LINK_COUNT_LIMIT') ?? 128,\n      eventCountLimit: getNumberFromEnv('OTEL_SPAN_EVENT_COUNT_LIMIT') ?? 128,\n      attributePerEventCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT') ?? 128,\n      attributePerLinkCountLimit:\n        getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT') ?? 128,\n    },\n  };\n}\n\n/**\n * Based on environment, builds a sampler, complies with specification.\n */\nexport function buildSamplerFromEnv(): Sampler {\n  const sampler =\n    getStringFromEnv('OTEL_TRACES_SAMPLER') ??\n    TracesSamplerValues.ParentBasedAlwaysOn;\n  switch (sampler) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler({\n        root: new AlwaysOffSampler(),\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv());\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler({\n        root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv()),\n      });\n    default:\n      diag.error(\n        `OTEL_TRACES_SAMPLER value \"${sampler}\" invalid, defaulting to \"${TracesSamplerValues.ParentBasedAlwaysOn}\".`\n      );\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n  }\n}\n\nfunction getSamplerProbabilityFromEnv(): number | undefined {\n  const probability = getNumberFromEnv('OTEL_TRACES_SAMPLER_ARG');\n  if (probability == null) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  if (probability < 0 || probability > 1) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${probability} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  return probability;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { IOtlpResponseHandler } from './response-handler';\n\nfunction isPartialSuccessResponse(\n  response: unknown\n): response is { partialSuccess: never } {\n  return Object.prototype.hasOwnProperty.call(response, 'partialSuccess');\n}\n\n/**\n * Default response handler that logs a partial success to the console.\n */\nexport function createLoggingPartialSuccessResponseHandler<\n  T,\n>(): IOtlpResponseHandler<T> {\n  return {\n    handleResponse(response: T) {\n      // Partial success MUST never be an empty object according the specification\n      // see https://opentelemetry.io/docs/specs/otlp/#partial-success\n      if (\n        response == null ||\n        !isPartialSuccessResponse(response) ||\n        response.partialSuccess == null ||\n        Object.keys(response.partialSuccess).length === 0\n      ) {\n        return;\n      }\n      diag.warn(\n        'Received Partial Success response:',\n        JSON.stringify(response.partialSuccess)\n      );\n    },\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { isPlainObject } from './lodash.merge';\n\nconst MAX_LEVEL = 20;\n\ninterface ObjectInto {\n  obj: any;\n  key: string;\n}\n\n/**\n * Merges objects together\n * @param args - objects / values to be merged\n */\nexport function merge(...args: any[]): any {\n  let result: any = args.shift();\n  const objects: WeakMap<any, ObjectInto[]> | undefined = new WeakMap<\n    any,\n    ObjectInto[]\n  >();\n  while (args.length > 0) {\n    result = mergeTwoObjects(result, args.shift(), 0, objects);\n  }\n\n  return result;\n}\n\nfunction takeValue(value: any): any {\n  if (isArray(value)) {\n    return value.slice();\n  }\n  return value;\n}\n\n/**\n * Merges two objects\n * @param one - first object\n * @param two - second object\n * @param level - current deep level\n * @param objects - objects holder that has been already referenced - to prevent\n * cyclic dependency\n */\nfunction mergeTwoObjects(\n  one: any,\n  two: any,\n  level = 0,\n  objects: WeakMap<any, ObjectInto[]>\n): any {\n  let result: any;\n  if (level > MAX_LEVEL) {\n    return undefined;\n  }\n  level++;\n  if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {\n    result = takeValue(two);\n  } else if (isArray(one)) {\n    result = one.slice();\n    if (isArray(two)) {\n      for (let i = 0, j = two.length; i < j; i++) {\n        result.push(takeValue(two[i]));\n      }\n    } else if (isObject(two)) {\n      const keys = Object.keys(two);\n      for (let i = 0, j = keys.length; i < j; i++) {\n        const key = keys[i];\n        result[key] = takeValue(two[key]);\n      }\n    }\n  } else if (isObject(one)) {\n    if (isObject(two)) {\n      if (!shouldMerge(one, two)) {\n        return two;\n      }\n      result = Object.assign({}, one);\n      const keys = Object.keys(two);\n\n      for (let i = 0, j = keys.length; i < j; i++) {\n        const key = keys[i];\n        const twoValue = two[key];\n\n        if (isPrimitive(twoValue)) {\n          if (typeof twoValue === 'undefined') {\n            delete result[key];\n          } else {\n            // result[key] = takeValue(twoValue);\n            result[key] = twoValue;\n          }\n        } else {\n          const obj1 = result[key];\n          const obj2 = twoValue;\n\n          if (\n            wasObjectReferenced(one, key, objects) ||\n            wasObjectReferenced(two, key, objects)\n          ) {\n            delete result[key];\n          } else {\n            if (isObject(obj1) && isObject(obj2)) {\n              const arr1 = objects.get(obj1) || [];\n              const arr2 = objects.get(obj2) || [];\n              arr1.push({ obj: one, key });\n              arr2.push({ obj: two, key });\n              objects.set(obj1, arr1);\n              objects.set(obj2, arr2);\n            }\n\n            result[key] = mergeTwoObjects(\n              result[key],\n              twoValue,\n              level,\n              objects\n            );\n          }\n        }\n      }\n    } else {\n      result = two;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Function to check if object has been already reference\n * @param obj\n * @param key\n * @param objects\n */\nfunction wasObjectReferenced(\n  obj: any,\n  key: string,\n  objects: WeakMap<any, ObjectInto[]>\n): boolean {\n  const arr = objects.get(obj[key]) || [];\n  for (let i = 0, j = arr.length; i < j; i++) {\n    const info = arr[i];\n    if (info.key === key && info.obj === obj) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isArray(value: any): boolean {\n  return Array.isArray(value);\n}\n\nfunction isFunction(value: any): boolean {\n  return typeof value === 'function';\n}\n\nfunction isObject(value: any): boolean {\n  return (\n    !isPrimitive(value) &&\n    !isArray(value) &&\n    !isFunction(value) &&\n    typeof value === 'object'\n  );\n}\n\nfunction isPrimitive(value: any): boolean {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'undefined' ||\n    value instanceof Date ||\n    value instanceof RegExp ||\n    value === null\n  );\n}\n\nfunction shouldMerge(one: any, two: any): boolean {\n  if (!isPlainObject(one) || !isPlainObject(two)) {\n    return false;\n  }\n\n  return true;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\n\nexport type Maybe<T> = T | undefined;\n\nexport function isNotNullish<T>(item: Maybe<T>): item is T {\n  return item !== undefined && item !== null;\n}\n\n/**\n * Converting the unordered attributes into unique identifier string.\n * @param attributes user provided unordered Attributes.\n */\nexport function hashAttributes(attributes: Attributes): string {\n  let keys = Object.keys(attributes);\n  if (keys.length === 0) return '';\n\n  // Return a string that is stable on key orders.\n  keys = keys.sort();\n  return JSON.stringify(keys.map(key => [key, attributes[key]]));\n}\n\n/**\n * Converting the instrumentation scope object to a unique identifier string.\n * @param instrumentationScope\n */\nexport function instrumentationScopeId(\n  instrumentationScope: InstrumentationScope\n): string {\n  return `${instrumentationScope.name}:${instrumentationScope.version ?? ''}:${\n    instrumentationScope.schemaUrl ?? ''\n  }`;\n}\n\n/**\n * Error that is thrown on timeouts.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message);\n\n    // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:\n    // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\n/**\n * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise\n * rejects, and resolves if the specified promise resolves.\n *\n * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.\n *\n * @param promise promise to use with timeout.\n * @param timeout the timeout in milliseconds until the returned promise is rejected.\n */\nexport function callWithTimeout<T>(\n  promise: Promise<T>,\n  timeout: number\n): Promise<T> {\n  let timeoutHandle: ReturnType<typeof setTimeout>;\n\n  const timeoutPromise = new Promise<never>(function timeoutFunction(\n    _resolve,\n    reject\n  ) {\n    timeoutHandle = setTimeout(function timeoutHandler() {\n      reject(new TimeoutError('Operation timed out.'));\n    }, timeout);\n  });\n\n  return Promise.race([promise, timeoutPromise]).then(\n    result => {\n      clearTimeout(timeoutHandle);\n      return result;\n    },\n    reason => {\n      clearTimeout(timeoutHandle);\n      throw reason;\n    }\n  );\n}\n\nexport interface PromiseAllSettledFulfillResult<T> {\n  status: 'fulfilled';\n  value: T;\n}\n\nexport interface PromiseAllSettledRejectionResult {\n  status: 'rejected';\n  reason: unknown;\n}\n\nexport type PromiseAllSettledResult<T> =\n  | PromiseAllSettledFulfillResult<T>\n  | PromiseAllSettledRejectionResult;\n\n/**\n * Node.js v12.9 lower and browser compatible `Promise.allSettled`.\n */\nexport async function PromiseAllSettled<T>(\n  promises: Promise<T>[]\n): Promise<PromiseAllSettledResult<T>[]> {\n  return Promise.all(\n    promises.map<Promise<PromiseAllSettledResult<T>>>(async p => {\n      try {\n        const ret = await p;\n        return {\n          status: 'fulfilled',\n          value: ret,\n        };\n      } catch (e) {\n        return {\n          status: 'rejected',\n          reason: e,\n        };\n      }\n    })\n  );\n}\n\nexport function isPromiseAllSettledRejectionResult(\n  it: PromiseAllSettledResult<unknown>\n): it is PromiseAllSettledRejectionResult {\n  return it.status === 'rejected';\n}\n\n/**\n * Node.js v11.0 lower and browser compatible `Array.prototype.flatMap`.\n */\nexport function FlatMap<T, R>(arr: T[], fn: (it: T) => R[]): R[] {\n  const result: R[] = [];\n  arr.forEach(it => {\n    result.push(...fn(it));\n  });\n  return result;\n}\n\nexport function setEquals(lhs: Set<unknown>, rhs: Set<unknown>): boolean {\n  if (lhs.size !== rhs.size) {\n    return false;\n  }\n  for (const item of lhs) {\n    if (!rhs.has(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Binary search the sorted array to the find upper bound for the value.\n * @param arr\n * @param value\n * @returns\n */\nexport function binarySearchUB(arr: number[], value: number): number {\n  let lo = 0;\n  let hi = arr.length - 1;\n  let ret = arr.length;\n\n  while (hi >= lo) {\n    const mid = lo + Math.trunc((hi - lo) / 2);\n    if (arr[mid] < value) {\n      lo = mid + 1;\n    } else {\n      ret = mid;\n      hi = mid - 1;\n    }\n  }\n\n  return ret;\n}\n\nexport function equalsCaseInsensitive(lhs: string, rhs: string): boolean {\n  return lhs.toLowerCase() === rhs.toLowerCase();\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TracerProvider, Tracer as ApiTracer } from '@opentelemetry/api';\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource, Resource } from '@opentelemetry/resources';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { TracerConfig } from './types';\nimport { reconfigureLimits } from './utility';\n\nexport enum ForceFlushState {\n  'resolved',\n  'timeout',\n  'error',\n  'unresolved',\n}\n\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider implements TracerProvider {\n  private readonly _config: TracerConfig;\n  private readonly _tracers: Map<string, Tracer> = new Map();\n  private readonly _resource: Resource;\n  private readonly _activeSpanProcessor: MultiSpanProcessor;\n\n  constructor(config: TracerConfig = {}) {\n    const mergedConfig = merge(\n      {},\n      loadDefaultConfig(),\n      reconfigureLimits(config)\n    );\n    this._resource = mergedConfig.resource ?? defaultResource();\n\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this._resource,\n    });\n\n    const spanProcessors: SpanProcessor[] = [];\n\n    if (config.spanProcessors?.length) {\n      spanProcessors.push(...config.spanProcessors);\n    }\n\n    this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n  }\n\n  getTracer(\n    name: string,\n    version?: string,\n    options?: { schemaUrl?: string }\n  ): ApiTracer {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(\n        key,\n        new Tracer(\n          { name, version, schemaUrl: options?.schemaUrl },\n          this._config,\n          this._resource,\n          this._activeSpanProcessor\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key)!;\n  }\n\n  forceFlush(): Promise<void> {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._activeSpanProcessor['_spanProcessors'].map(\n      (spanProcessor: SpanProcessor) => {\n        return new Promise(resolve => {\n          let state: ForceFlushState;\n          const timeoutInterval = setTimeout(() => {\n            resolve(\n              new Error(\n                `Span processor did not completed within timeout period of ${timeout} ms`\n              )\n            );\n            state = ForceFlushState.timeout;\n          }, timeout);\n\n          spanProcessor\n            .forceFlush()\n            .then(() => {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            })\n            .catch(error => {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n        });\n      }\n    );\n\n    return new Promise<void>((resolve, reject) => {\n      Promise.all(promises)\n        .then(results => {\n          const errors = results.filter(\n            result => result !== ForceFlushState.resolved\n          );\n          if (errors.length > 0) {\n            reject(errors);\n          } else {\n            resolve();\n          }\n        })\n        .catch(error => reject([error]));\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this._activeSpanProcessor.shutdown();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\nimport { IExporterTransport } from './exporter-transport';\nimport { IExportPromiseHandler } from './bounded-queue-export-promise-handler';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { OTLPExporterError } from './types';\nimport { IOtlpResponseHandler } from './response-handler';\nimport { createLoggingPartialSuccessResponseHandler } from './logging-response-handler';\nimport { diag, DiagLogger } from '@opentelemetry/api';\n\n/**\n * Internally shared export logic for OTLP.\n */\nexport interface IOtlpExportDelegate<Internal> {\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void;\n  forceFlush(): Promise<void>;\n  shutdown(): Promise<void>;\n}\n\nclass OTLPExportDelegate<Internal, Response>\n  implements IOtlpExportDelegate<Internal>\n{\n  private _diagLogger: DiagLogger;\n  constructor(\n    private _transport: IExporterTransport,\n    private _serializer: ISerializer<Internal, Response>,\n    private _responseHandler: IOtlpResponseHandler<Response>,\n    private _promiseQueue: IExportPromiseHandler,\n    private _timeout: number\n  ) {\n    this._diagLogger = diag.createComponentLogger({\n      namespace: 'OTLPExportDelegate',\n    });\n  }\n\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._diagLogger.debug('items to be sent', internalRepresentation);\n\n    // don't do any work if too many exports are in progress.\n    if (this._promiseQueue.hasReachedLimit()) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Concurrent export limit reached'),\n      });\n      return;\n    }\n\n    const serializedRequest = this._serializer.serializeRequest(\n      internalRepresentation\n    );\n\n    if (serializedRequest == null) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Nothing to send'),\n      });\n      return;\n    }\n\n    this._promiseQueue.pushPromise(\n      this._transport.send(serializedRequest, this._timeout).then(\n        response => {\n          if (response.status === 'success') {\n            if (response.data != null) {\n              try {\n                this._responseHandler.handleResponse(\n                  this._serializer.deserializeResponse(response.data)\n                );\n              } catch (e) {\n                this._diagLogger.warn(\n                  'Export succeeded but could not deserialize response - is the response specification compliant?',\n                  e,\n                  response.data\n                );\n              }\n            }\n            // No matter the response, we can consider the export still successful.\n            resultCallback({\n              code: ExportResultCode.SUCCESS,\n            });\n            return;\n          } else if (response.status === 'failure' && response.error) {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: response.error,\n            });\n            return;\n          } else if (response.status === 'retryable') {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError(\n                'Export failed with retryable status'\n              ),\n            });\n          } else {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError('Export failed with unknown error'),\n            });\n          }\n        },\n        reason =>\n          resultCallback({\n            code: ExportResultCode.FAILED,\n            error: reason,\n          })\n      )\n    );\n  }\n\n  forceFlush(): Promise<void> {\n    return this._promiseQueue.awaitAll();\n  }\n\n  async shutdown(): Promise<void> {\n    this._diagLogger.debug('shutdown started');\n    await this.forceFlush();\n    this._transport.shutdown();\n  }\n}\n\n/**\n * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all\n * signals.\n */\nexport function createOtlpExportDelegate<Internal, Response>(\n  components: {\n    transport: IExporterTransport;\n    serializer: ISerializer<Internal, Response>;\n    promiseHandler: IExportPromiseHandler;\n  },\n  settings: { timeout: number }\n): IOtlpExportDelegate<Internal> {\n  return new OTLPExportDelegate(\n    components.transport,\n    components.serializer,\n    createLoggingPartialSuccessResponseHandler(),\n    components.promiseHandler,\n    settings.timeout\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, Attributes, ValueType } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { Histogram, ExponentialHistogram } from '../aggregator/types';\n\n/**\n * Supported types of metric instruments.\n */\nexport enum InstrumentType {\n  COUNTER = 'COUNTER',\n  GAUGE = 'GAUGE',\n  HISTOGRAM = 'HISTOGRAM',\n  UP_DOWN_COUNTER = 'UP_DOWN_COUNTER',\n  OBSERVABLE_COUNTER = 'OBSERVABLE_COUNTER',\n  OBSERVABLE_GAUGE = 'OBSERVABLE_GAUGE',\n  OBSERVABLE_UP_DOWN_COUNTER = 'OBSERVABLE_UP_DOWN_COUNTER',\n}\n\nexport interface MetricDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  readonly valueType: ValueType;\n}\n\n/**\n * Basic metric data fields.\n */\ninterface BaseMetricData {\n  readonly descriptor: MetricDescriptor;\n  readonly aggregationTemporality: AggregationTemporality;\n  /**\n   * DataPointType of the metric instrument.\n   */\n  readonly dataPointType: DataPointType;\n}\n\n/**\n * Represents a metric data aggregated by either a LastValueAggregation or\n * SumAggregation.\n */\nexport interface SumMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.SUM;\n  readonly dataPoints: DataPoint<number>[];\n  readonly isMonotonic: boolean;\n}\n\nexport interface GaugeMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.GAUGE;\n  readonly dataPoints: DataPoint<number>[];\n}\n\n/**\n * Represents a metric data aggregated by a HistogramAggregation.\n */\nexport interface HistogramMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.HISTOGRAM;\n  readonly dataPoints: DataPoint<Histogram>[];\n}\n\n/**\n * Represents a metric data aggregated by a ExponentialHistogramAggregation.\n */\nexport interface ExponentialHistogramMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM;\n  readonly dataPoints: DataPoint<ExponentialHistogram>[];\n}\n\n/**\n * Represents an aggregated metric data.\n */\nexport type MetricData =\n  | SumMetricData\n  | GaugeMetricData\n  | HistogramMetricData\n  | ExponentialHistogramMetricData;\n\nexport interface ScopeMetrics {\n  scope: InstrumentationScope;\n  metrics: MetricData[];\n}\n\nexport interface ResourceMetrics {\n  resource: Resource;\n  scopeMetrics: ScopeMetrics[];\n}\n\n/**\n * Represents the collection result of the metrics. If there are any\n * non-critical errors in the collection, like throwing in a single observable\n * callback, these errors are aggregated in the {@link CollectionResult.errors}\n * array and other successfully collected metrics are returned.\n */\nexport interface CollectionResult {\n  /**\n   * Collected metrics.\n   */\n  resourceMetrics: ResourceMetrics;\n  /**\n   * Arbitrary JavaScript exception values.\n   */\n  errors: unknown[];\n}\n\n/**\n * The aggregated point data type.\n */\nexport enum DataPointType {\n  /**\n   * A histogram data point contains a histogram statistics of collected\n   * values with a list of explicit bucket boundaries and statistics such\n   * as min, max, count, and sum of all collected values.\n   */\n  HISTOGRAM,\n  /**\n   * An exponential histogram data point contains a histogram statistics of\n   * collected values where bucket boundaries are automatically calculated\n   * using an exponential function, and statistics such as min, max, count,\n   * and sum of all collected values.\n   */\n  EXPONENTIAL_HISTOGRAM,\n  /**\n   * A gauge metric data point has only a single numeric value.\n   */\n  GAUGE,\n  /**\n   * A sum metric data point has a single numeric value and a\n   * monotonicity-indicator.\n   */\n  SUM,\n}\n\n/**\n * Represents an aggregated point data with start time, end time and their\n * associated attributes and points.\n */\nexport interface DataPoint<T> {\n  /**\n   * The start epoch timestamp of the DataPoint, usually the time when\n   * the metric was created when the preferred AggregationTemporality is\n   * CUMULATIVE, or last collection time otherwise.\n   */\n  readonly startTime: HrTime;\n  /**\n   * The end epoch timestamp when data were collected, usually it represents\n   * the moment when `MetricReader.collect` was called.\n   */\n  readonly endTime: HrTime;\n  /**\n   * The attributes associated with this DataPoint.\n   */\n  readonly attributes: Attributes;\n  /**\n   * The value for this DataPoint. The type of the value is indicated by the\n   * {@link DataPointType}.\n   */\n  readonly value: T;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  TextMapGetter,\n  TextMapPropagator,\n  diag,\n  TextMapSetter,\n} from '@opentelemetry/api';\n\n/** Configuration object for composite propagator */\nexport interface CompositePropagatorConfig {\n  /**\n   * List of propagators to run. Propagators run in the\n   * list order. If a propagator later in the list writes the same context\n   * key as a propagator earlier in the list, the later on will \"win\".\n   */\n  propagators?: TextMapPropagator[];\n}\n\n/** Combines multiple propagators into a single propagator. */\nexport class CompositePropagator implements TextMapPropagator {\n  private readonly _propagators: TextMapPropagator[];\n  private readonly _fields: string[];\n\n  /**\n   * Construct a composite propagator from a list of propagators.\n   *\n   * @param [config] Configuration object for composite propagator\n   */\n  constructor(config: CompositePropagatorConfig = {}) {\n    this._propagators = config.propagators ?? [];\n\n    this._fields = Array.from(\n      new Set(\n        this._propagators\n          // older propagators may not have fields function, null check to be sure\n          .map(p => (typeof p.fields === 'function' ? p.fields() : []))\n          .reduce((x, y) => x.concat(y), [])\n      )\n    );\n  }\n\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same carrier key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to inject\n   * @param carrier Carrier into which context will be injected\n   */\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    for (const propagator of this._propagators) {\n      try {\n        propagator.inject(context, carrier, setter);\n      } catch (err) {\n        diag.warn(\n          `Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Run each of the configured propagators with the given context and carrier.\n   * Propagators are run in the order they are configured, so if multiple\n   * propagators write the same context key, the propagator later in the list\n   * will \"win\".\n   *\n   * @param context Context to add values to\n   * @param carrier Carrier from which to extract context\n   */\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    return this._propagators.reduce((ctx, propagator) => {\n      try {\n        return propagator.extract(ctx, carrier, getter);\n      } catch (err) {\n        diag.warn(\n          `Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`\n        );\n      }\n      return ctx;\n    }, context);\n  }\n\n  fields(): string[] {\n    // return a new array so our fields cannot be modified\n    return this._fields.slice();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This file contains a copy of unstable semantic convention definitions\n * used by this package.\n * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv\n */\n\n/**\n * The name of the runtime of this process.\n *\n * @example OpenJDK Runtime Environment\n *\n * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.\n */\nexport const ATTR_PROCESS_RUNTIME_NAME = 'process.runtime.name' as const;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { buildSamplerFromEnv, loadDefaultConfig } from './config';\nimport { Sampler } from './Sampler';\nimport { SpanLimits, TracerConfig, GeneralLimits } from './types';\nimport { getNumberFromEnv } from '@opentelemetry/core';\n\nexport const DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;\nexport const DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;\n\n/**\n * Function to merge Default configuration (as specified in './config') with\n * user provided configurations.\n */\nexport function mergeConfig(userConfig: TracerConfig): TracerConfig & {\n  sampler: Sampler;\n  spanLimits: SpanLimits;\n  generalLimits: GeneralLimits;\n} {\n  const perInstanceDefaults: Partial<TracerConfig> = {\n    sampler: buildSamplerFromEnv(),\n  };\n\n  const DEFAULT_CONFIG = loadDefaultConfig();\n\n  const target = Object.assign(\n    {},\n    DEFAULT_CONFIG,\n    perInstanceDefaults,\n    userConfig\n  );\n\n  target.generalLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.generalLimits,\n    userConfig.generalLimits || {}\n  );\n\n  target.spanLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.spanLimits,\n    userConfig.spanLimits || {}\n  );\n\n  return target;\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param userConfig User provided tracer configuration\n */\nexport function reconfigureLimits(userConfig: TracerConfig): TracerConfig {\n  const spanLimits = Object.assign({}, userConfig.spanLimits);\n\n  /**\n   * Reassign span attribute count limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeCountLimit =\n    userConfig.spanLimits?.attributeCountLimit ??\n    userConfig.generalLimits?.attributeCountLimit ??\n    getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ??\n    getNumberFromEnv('OTEL_ATTRIBUTE_COUNT_LIMIT') ??\n    DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n\n  /**\n   * Reassign span attribute value length limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeValueLengthLimit =\n    userConfig.spanLimits?.attributeValueLengthLimit ??\n    userConfig.generalLimits?.attributeValueLengthLimit ??\n    getNumberFromEnv('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n    getNumberFromEnv('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??\n    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n\n  return Object.assign({}, userConfig, { spanLimits });\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler implements Sampler {\n  private _upperBound: number;\n\n  constructor(private readonly _ratio = 0) {\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n\n  shouldSample(context: unknown, traceId: string): SamplingResult {\n    return {\n      decision:\n        isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound\n          ? SamplingDecision.RECORD_AND_SAMPLED\n          : SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n\n  private _normalize(ratio: number): number {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n\n  private _accumulate(traceId: string): number {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { MetricData, MetricDescriptor } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregatorKind, Aggregator, AccumulationRecord } from './types';\n\n/** Basic aggregator for None which keeps no recorded value. */\nexport class DropAggregator implements Aggregator<undefined> {\n  kind: AggregatorKind.DROP = AggregatorKind.DROP;\n\n  createAccumulation() {\n    return undefined;\n  }\n\n  merge(_previous: undefined, _delta: undefined) {\n    return undefined;\n  }\n\n  diff(_previous: undefined, _current: undefined) {\n    return undefined;\n  }\n\n  toMetricData(\n    _descriptor: MetricDescriptor,\n    _aggregationTemporality: AggregationTemporality,\n    _accumulationByAttributes: AccumulationRecord<undefined>[],\n    _endTime: HrTime\n  ): Maybe<MetricData> {\n    return undefined;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The functions and constants in this file allow us to interact\n * with the internal representation of an IEEE 64-bit floating point\n * number. We need to work with all 64-bits, thus, care needs to be\n * taken when working with Javascript's bitwise operators (<<, >>, &,\n * |, etc) as they truncate operands to 32-bits. In order to work around\n * this we work with the 64-bits as two 32-bit halves, perform bitwise\n * operations on them independently, and combine the results (if needed).\n */\n\nexport const SIGNIFICAND_WIDTH = 52;\n\n/**\n * EXPONENT_MASK is set to 1 for the hi 32-bits of an IEEE 754\n * floating point exponent: 0x7ff00000.\n */\nconst EXPONENT_MASK = 0x7ff00000;\n\n/**\n * SIGNIFICAND_MASK is the mask for the significand portion of the hi 32-bits\n * of an IEEE 754 double-precision floating-point value: 0xfffff\n */\nconst SIGNIFICAND_MASK = 0xfffff;\n\n/**\n * EXPONENT_BIAS is the exponent bias specified for encoding\n * the IEEE 754 double-precision floating point exponent: 1023\n */\nconst EXPONENT_BIAS = 1023;\n\n/**\n * MIN_NORMAL_EXPONENT is the minimum exponent of a normalized\n * floating point: -1022.\n */\nexport const MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;\n\n/**\n * MAX_NORMAL_EXPONENT is the maximum exponent of a normalized\n * floating point: 1023.\n */\nexport const MAX_NORMAL_EXPONENT = EXPONENT_BIAS;\n\n/**\n * MIN_VALUE is the smallest normal number\n */\nexport const MIN_VALUE = Math.pow(2, -1022);\n\n/**\n * getNormalBase2 extracts the normalized base-2 fractional exponent.\n * This returns k for the equation f x 2**k where f is\n * in the range [1, 2).  Note that this function is not called for\n * subnormal numbers.\n * @param {number} value - the value to determine normalized base-2 fractional\n *    exponent for\n * @returns {number} the normalized base-2 exponent\n */\nexport function getNormalBase2(value: number): number {\n  const dv = new DataView(new ArrayBuffer(8));\n  dv.setFloat64(0, value);\n  // access the raw 64-bit float as 32-bit uints\n  const hiBits = dv.getUint32(0);\n  const expBits = (hiBits & EXPONENT_MASK) >> 20;\n  return expBits - EXPONENT_BIAS;\n}\n\n/**\n * GetSignificand returns the 52 bit (unsigned) significand as a signed value.\n * @param {number} value - the floating point number to extract the significand from\n * @returns {number} The 52-bit significand\n */\nexport function getSignificand(value: number): number {\n  const dv = new DataView(new ArrayBuffer(8));\n  dv.setFloat64(0, value);\n  // access the raw 64-bit float as two 32-bit uints\n  const hiBits = dv.getUint32(0);\n  const loBits = dv.getUint32(4);\n  // extract the significand bits from the hi bits and left shift 32 places note:\n  // we can't use the native << operator as it will truncate the result to 32-bits\n  const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);\n  // combine the hi and lo bits and return\n  return significandHiBits + loBits;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IdGenerator } from '../../IdGenerator';\n\nconst SPAN_ID_BYTES = 8;\nconst TRACE_ID_BYTES = 16;\n\nexport class RandomIdGenerator implements IdGenerator {\n  /**\n   * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex\n   * characters corresponding to 128 bits.\n   */\n  generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n\n  /**\n   * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex\n   * characters corresponding to 64 bits.\n   */\n  generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n}\n\nconst SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);\nfunction getIdGenerator(bytes: number): () => string {\n  return function generateId() {\n    for (let i = 0; i < bytes / 4; i++) {\n      // unsigned right shift drops decimal part of the number\n      // it is required because if a number between 2**32 and 2**32 - 1 is generated, an out of range error is thrown by writeUInt32BE\n      SHARED_BUFFER.writeUInt32BE((Math.random() * 2 ** 32) >>> 0, i * 4);\n    }\n\n    // If buffer is all 0, set the last byte to 1 to guarantee a valid w3c id is generated\n    for (let i = 0; i < bytes; i++) {\n      if (SHARED_BUFFER[i] > 0) {\n        break;\n      } else if (i === bytes - 1) {\n        SHARED_BUFFER[bytes - 1] = 1;\n      }\n    }\n\n    return SHARED_BUFFER.toString('hex', 0, bytes);\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { callWithTimeout } from '@opentelemetry/core';\nimport type { Context } from '@opentelemetry/api';\nimport type { LogRecordProcessor } from './LogRecordProcessor';\nimport type { SdkLogRecord } from './export/SdkLogRecord';\n\n/**\n * Implementation of the {@link LogRecordProcessor} that simply forwards all\n * received events to a list of {@link LogRecordProcessor}s.\n */\nexport class MultiLogRecordProcessor implements LogRecordProcessor {\n  constructor(\n    public readonly processors: LogRecordProcessor[],\n    public readonly forceFlushTimeoutMillis: number\n  ) {}\n\n  public async forceFlush(): Promise<void> {\n    const timeout = this.forceFlushTimeoutMillis;\n    await Promise.all(\n      this.processors.map(processor =>\n        callWithTimeout(processor.forceFlush(), timeout)\n      )\n    );\n  }\n\n  public onEmit(logRecord: SdkLogRecord, context?: Context): void {\n    this.processors.forEach(processors =>\n      processors.onEmit(logRecord, context)\n    );\n  }\n\n  public async shutdown(): Promise<void> {\n    await Promise.all(this.processors.map(processor => processor.shutdown()));\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport { NOOP_LOGGER } from '@opentelemetry/api-logs';\nimport { defaultResource } from '@opentelemetry/resources';\nimport { BindOnceFuture, merge } from '@opentelemetry/core';\n\nimport type { LoggerProviderConfig } from './types';\nimport { Logger } from './Logger';\nimport { loadDefaultConfig, reconfigureLimits } from './config';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\n\nexport const DEFAULT_LOGGER_NAME = 'unknown';\n\nexport class LoggerProvider implements logsAPI.LoggerProvider {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private readonly _sharedState: LoggerProviderSharedState;\n\n  constructor(config: LoggerProviderConfig = {}) {\n    const mergedConfig = merge({}, loadDefaultConfig(), config);\n    const resource = config.resource ?? defaultResource();\n    this._sharedState = new LoggerProviderSharedState(\n      resource,\n      mergedConfig.forceFlushTimeoutMillis,\n      reconfigureLimits(mergedConfig.logRecordLimits),\n      config?.processors ?? []\n    );\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n  }\n\n  /**\n   * Get a logger with the configuration of the LoggerProvider.\n   */\n  public getLogger(\n    name: string,\n    version?: string,\n    options?: logsAPI.LoggerOptions\n  ): logsAPI.Logger {\n    if (this._shutdownOnce.isCalled) {\n      diag.warn('A shutdown LoggerProvider cannot provide a Logger');\n      return NOOP_LOGGER;\n    }\n\n    if (!name) {\n      diag.warn('Logger requested without instrumentation scope name.');\n    }\n    const loggerName = name || DEFAULT_LOGGER_NAME;\n    const key = `${loggerName}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._sharedState.loggers.has(key)) {\n      this._sharedState.loggers.set(\n        key,\n        new Logger(\n          { name: loggerName, version, schemaUrl: options?.schemaUrl },\n          this._sharedState\n        )\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._sharedState.loggers.get(key)!;\n  }\n\n  /**\n   * Notifies all registered LogRecordProcessor to flush any buffered data.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  public forceFlush(): Promise<void> {\n    // do not flush after shutdown\n    if (this._shutdownOnce.isCalled) {\n      diag.warn('invalid attempt to force flush after LoggerProvider shutdown');\n      return this._shutdownOnce.promise;\n    }\n    return this._sharedState.activeProcessor.forceFlush();\n  }\n\n  /**\n   * Flush all buffered data and shut down the LoggerProvider and all registered\n   * LogRecordProcessor.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  public shutdown(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      diag.warn('shutdown may only be called once per LoggerProvider');\n      return this._shutdownOnce.promise;\n    }\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._sharedState.activeProcessor.shutdown();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface IExportPromiseHandler {\n  pushPromise(promise: Promise<void>): void;\n  hasReachedLimit(): boolean;\n  awaitAll(): Promise<void>;\n}\n\nclass BoundedQueueExportPromiseHandler implements IExportPromiseHandler {\n  private readonly _concurrencyLimit: number;\n  private _sendingPromises: Promise<unknown>[] = [];\n\n  /**\n   * @param concurrencyLimit maximum promises allowed in a queue at the same time.\n   */\n  constructor(concurrencyLimit: number) {\n    this._concurrencyLimit = concurrencyLimit;\n  }\n\n  public pushPromise(promise: Promise<void>): void {\n    if (this.hasReachedLimit()) {\n      throw new Error('Concurrency Limit reached');\n    }\n\n    this._sendingPromises.push(promise);\n    const popPromise = () => {\n      const index = this._sendingPromises.indexOf(promise);\n      void this._sendingPromises.splice(index, 1);\n    };\n    promise.then(popPromise, popPromise);\n  }\n\n  public hasReachedLimit(): boolean {\n    return this._sendingPromises.length >= this._concurrencyLimit;\n  }\n\n  public async awaitAll(): Promise<void> {\n    await Promise.all(this._sendingPromises);\n  }\n}\n\n/**\n * Promise queue for keeping track of export promises. Finished promises will be auto-dequeued.\n * Allows for awaiting all promises in the queue.\n */\nexport function createBoundedQueueExportPromiseHandler(options: {\n  concurrencyLimit: number;\n}): IExportPromiseHandler {\n  return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Note: other languages provide this as a built in function. This is\n * a naive, but functionally correct implementation. This is used sparingly,\n * when creating a new mapping in a running application.\n *\n * ldexp returns frac  2**exp. With the following special cases:\n *   ldexp(0, exp) = 0\n *   ldexp(Inf, exp) = Inf\n *   ldexp(NaN, exp) = NaN\n * @param frac\n * @param exp\n * @returns {number}\n */\nexport function ldexp(frac: number, exp: number): number {\n  if (\n    frac === 0 ||\n    frac === Number.POSITIVE_INFINITY ||\n    frac === Number.NEGATIVE_INFINITY ||\n    Number.isNaN(frac)\n  ) {\n    return frac;\n  }\n  return frac * Math.pow(2, exp);\n}\n\n/**\n * Computes the next power of two that is greater than or equal to v.\n * This implementation more efficient than, but functionally equivalent\n * to Math.pow(2, Math.ceil(Math.log(x)/Math.log(2))).\n * @param v\n * @returns {number}\n */\nexport function nextGreaterSquare(v: number): number {\n  // The following expression computes the least power-of-two\n  // that is >= v.  There are a number of tricky ways to\n  // do this, see https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2\n  v--;\n  v |= v >> 1;\n  v |= v >> 2;\n  v |= v >> 4;\n  v |= v >> 8;\n  v |= v >> 16;\n  v++;\n  return v;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction intValue(charCode: number): number {\n  // 0-9\n  if (charCode >= 48 && charCode <= 57) {\n    return charCode - 48;\n  }\n\n  // a-f\n  if (charCode >= 97 && charCode <= 102) {\n    return charCode - 87;\n  }\n\n  // A-F\n  return charCode - 55;\n}\n\nexport function hexToBinary(hexStr: string): Uint8Array {\n  const buf = new Uint8Array(hexStr.length / 2);\n  let offset = 0;\n\n  for (let i = 0; i < hexStr.length; i += 2) {\n    const hi = intValue(hexStr.charCodeAt(i));\n    const lo = intValue(hexStr.charCodeAt(i + 1));\n    buf[offset++] = (hi << 4) | lo;\n  }\n\n  return buf;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { inspect } from 'util';\n\n/**\n * Retrieves a number from an environment variable.\n * - Returns `undefined` if the environment variable is empty, unset, contains only whitespace, or is not a number.\n * - Returns a number in all other cases.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {number | undefined} - The number value or `undefined`.\n */\nexport function getNumberFromEnv(key: string): number | undefined {\n  const raw = process.env[key];\n  if (raw == null || raw.trim() === '') {\n    return undefined;\n  }\n\n  const value = Number(raw);\n  if (isNaN(value)) {\n    diag.warn(\n      `Unknown value ${inspect(raw)} for ${key}, expected a number, using defaults`\n    );\n    return undefined;\n  }\n\n  return value;\n}\n\n/**\n * Retrieves a string from an environment variable.\n * - Returns `undefined` if the environment variable is empty, unset, or contains only whitespace.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {string | undefined} - The string value or `undefined`.\n */\nexport function getStringFromEnv(key: string): string | undefined {\n  const raw = process.env[key];\n  if (raw == null || raw.trim() === '') {\n    return undefined;\n  }\n  return raw;\n}\n\n/**\n * Retrieves a boolean value from an environment variable.\n * - Trims leading and trailing whitespace and ignores casing.\n * - Returns `false` if the environment variable is empty, unset, or contains only whitespace.\n * - Returns `false` for strings that cannot be mapped to a boolean.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {boolean} - The boolean value or `false` if the environment variable is unset empty, unset, or contains only whitespace.\n */\nexport function getBooleanFromEnv(key: string): boolean {\n  const raw = process.env[key]?.trim().toLowerCase();\n  if (raw == null || raw === '') {\n    // NOTE: falling back to `false` instead of `undefined` as required by the specification.\n    // If you have a use-case that requires `undefined`, consider using `getStringFromEnv()` and applying the necessary\n    // normalizations in the consuming code.\n    return false;\n  }\n  if (raw === 'true') {\n    return true;\n  } else if (raw === 'false') {\n    return false;\n  } else {\n    diag.warn(\n      `Unknown value ${inspect(raw)} for ${key}, expected 'true' or 'false', falling back to 'false' (default)`\n    );\n    return false;\n  }\n}\n\n/**\n * Retrieves a list of strings from an environment variable.\n * - Uses ',' as the delimiter.\n * - Trims leading and trailing whitespace from each entry.\n * - Excludes empty entries.\n * - Returns `undefined` if the environment variable is empty or contains only whitespace.\n * - Returns an empty array if all entries are empty or whitespace.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {string[] | undefined} - The list of strings or `undefined`.\n */\nexport function getStringListFromEnv(key: string): string[] | undefined {\n  return getStringFromEnv(key)\n    ?.split(',')\n    .map(v => v.trim())\n    .filter(s => s !== '');\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceFlags,\n  trace,\n} from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\nimport { Sampler, SamplingResult } from '../Sampler';\n\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler implements Sampler {\n  private _root: Sampler;\n  private _remoteParentSampled: Sampler;\n  private _remoteParentNotSampled: Sampler;\n  private _localParentSampled: Sampler;\n  private _localParentNotSampled: Sampler;\n\n  constructor(config: ParentBasedSamplerConfig) {\n    this._root = config.root;\n\n    if (!this._root) {\n      globalErrorHandler(\n        new Error('ParentBasedSampler must have a root sampler configured')\n      );\n      this._root = new AlwaysOnSampler();\n    }\n\n    this._remoteParentSampled =\n      config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled =\n      config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled =\n      config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled =\n      config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult {\n    const parentContext = trace.getSpanContext(context);\n\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(\n          context,\n          traceId,\n          spanName,\n          spanKind,\n          attributes,\n          links\n        );\n      }\n      return this._remoteParentNotSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    return this._localParentNotSampled.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n  }\n\n  toString(): string {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}\n\ninterface ParentBasedSamplerConfig {\n  /** Sampler called for spans with no parent */\n  root: Sampler;\n  /** Sampler called for spans with a remote parent which was sampled. Default AlwaysOn */\n  remoteParentSampled?: Sampler;\n  /** Sampler called for spans with a remote parent which was not sampled. Default AlwaysOff */\n  remoteParentNotSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was sampled. Default AlwaysOn */\n  localParentSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was not sampled. Default AlwaysOff */\n  localParentNotSampled?: Sampler;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagAPI } from '../api/diag';\nimport { BaggageImpl } from './internal/baggage-impl';\nimport { baggageEntryMetadataSymbol } from './internal/symbol';\nimport { Baggage, BaggageEntry, BaggageEntryMetadata } from './types';\n\nconst diag = DiagAPI.instance();\n\n/**\n * Create a new Baggage with optional entries\n *\n * @param entries An array of baggage entries the new baggage should contain\n */\nexport function createBaggage(\n  entries: Record<string, BaggageEntry> = {}\n): Baggage {\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n\n/**\n * Create a serializable BaggageEntryMetadata object from a string.\n *\n * @param str string metadata. Format is currently not defined by the spec and has no special meaning.\n *\n */\nexport function baggageEntryMetadataFromString(\n  str: string\n): BaggageEntryMetadata {\n  if (typeof str !== 'string') {\n    diag.error(\n      `Cannot create baggage metadata from unknown type: ${typeof str}`\n    );\n    str = '';\n  }\n\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString() {\n      return str;\n    },\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '@opentelemetry/api';\nimport { loggingErrorHandler } from './logging-error-handler';\nimport { ErrorHandler } from './types';\n\n/** The global error handler delegate */\nlet delegateHandler = loggingErrorHandler();\n\n/**\n * Set the global error handler\n * @param {ErrorHandler} handler\n */\nexport function setGlobalErrorHandler(handler: ErrorHandler): void {\n  delegateHandler = handler;\n}\n\n/**\n * Return the global error handler\n * @param {Exception} ex\n */\nexport function globalErrorHandler(ex: Exception): void {\n  try {\n    delegateHandler(ex);\n  } catch {} // eslint-disable-line no-empty\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { validateKey, validateValue } from '../internal/validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceState implements api.TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceState {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceState {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceState {\n    const traceState = new TraceState();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  InstrumentationScope,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { SpanImpl } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Sampler } from './Sampler';\nimport { IdGenerator } from './IdGenerator';\nimport { RandomIdGenerator } from './platform';\nimport { Resource } from '@opentelemetry/resources';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly instrumentationScope: InstrumentationScope;\n\n  private readonly _resource: Resource;\n  private readonly _spanProcessor: SpanProcessor;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationScope: InstrumentationScope,\n    config: TracerConfig,\n    resource: Resource,\n    spanProcessor: SpanProcessor\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this._resource = resource;\n    this._spanProcessor = spanProcessor;\n    this.instrumentationScope = instrumentationScope;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      const nonRecordingSpan = api.trace.wrapSpanContext(\n        api.INVALID_SPAN_CONTEXT\n      );\n      return nonRecordingSpan;\n    }\n\n    const parentSpanContext = parentSpan?.spanContext();\n    const spanId = this._idGenerator.generateSpanId();\n    let validParentSpanContext;\n    let traceId;\n    let traceState;\n    if (\n      !parentSpanContext ||\n      !api.trace.isSpanContextValid(parentSpanContext)\n    ) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      validParentSpanContext = parentSpanContext;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    traceState = samplingResult.traceState ?? traceState;\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug(\n        'Recording is off, propagating context in a non-recording span'\n      );\n      const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(\n      Object.assign(attributes, samplingResult.attributes)\n    );\n\n    const span = new SpanImpl({\n      resource: this._resource,\n      scope: this.instrumentationScope,\n      context,\n      spanContext,\n      name,\n      kind: spanKind,\n      links,\n      parentSpanContext: validParentSpanContext,\n      attributes: initAttributes,\n      startTime: options.startTime,\n      spanProcessor: this._spanProcessor,\n      spanLimits: this._spanLimits,\n    });\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getNumberFromEnv,\n  globalErrorHandler,\n  suppressTracing,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_EXPORT_BATCH_SIZE') ?? 512);\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : (getNumberFromEnv('OTEL_BSP_MAX_QUEUE_SIZE') ?? 2048);\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : (getNumberFromEnv('OTEL_BSP_SCHEDULE_DELAY') ?? 5000);\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : (getNumberFromEnv('OTEL_BSP_EXPORT_TIMEOUT') ?? 30000);\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans: ReadableSpan[];\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n\n        let pendingResources: Array<Promise<void>> | null = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (\n            span.resource.asyncAttributesPending &&\n            span.resource.waitForAsyncAttributes\n          ) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  Link,\n  Attributes,\n  SpanKind,\n  TraceState,\n} from '@opentelemetry/api';\n\n/**\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<Attributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n\n/**\n * This interface represent a sampler. Sampling is a mechanism to control the\n * noise and overhead introduced by OpenTelemetry by reducing the number of\n * samples of traces collected and sent to the backend.\n */\nexport interface Sampler {\n  /**\n   * Checks whether span needs to be created and tracked.\n   *\n   * @param context Parent Context which may contain a span.\n   * @param traceId of the span to be created. It can be different from the\n   *     traceId in the {@link SpanContext}. Typically in situations when the\n   *     span to be created starts a new trace.\n   * @param spanName of the span to be created.\n   * @param spanKind of the span to be created.\n   * @param attributes Initial set of Attributes for the Span being constructed.\n   * @param links Collection of links that will be associated with the Span to\n   *     be created. Typically useful for batch operations.\n   * @returns a {@link SamplingResult}.\n   */\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: Attributes,\n    links: Link[]\n  ): SamplingResult;\n\n  /** Returns the sampler name or short description with the configuration. */\n  toString(): string;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes } from './attributes';\nimport { TraceState } from './trace_state';\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { NoopTextMapPropagator } from '../propagation/NoopTextMapPropagator';\nimport {\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n} from '../propagation/TextMapPropagator';\nimport {\n  getBaggage,\n  getActiveBaggage,\n  setBaggage,\n  deleteBaggage,\n} from '../baggage/context-helpers';\nimport { createBaggage } from '../baggage/utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'propagation';\nconst NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Propagation API\n */\nexport class PropagationAPI {\n  private static _instance?: PropagationAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Propagator API */\n  public static getInstance(): PropagationAPI {\n    if (!this._instance) {\n      this._instance = new PropagationAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current propagator.\n   *\n   * @returns true if the propagator was successfully registered, else false\n   */\n  public setGlobalPropagator(propagator: TextMapPropagator): boolean {\n    return registerGlobal(API_NAME, propagator, DiagAPI.instance());\n  }\n\n  /**\n   * Inject context into a carrier to be propagated inter-process\n   *\n   * @param context Context carrying tracing data to inject\n   * @param carrier carrier to inject context into\n   * @param setter Function used to set values on the carrier\n   */\n  public inject<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier> = defaultTextMapSetter\n  ): void {\n    return this._getGlobalPropagator().inject(context, carrier, setter);\n  }\n\n  /**\n   * Extract context from a carrier\n   *\n   * @param context Context which the newly created context will inherit from\n   * @param carrier Carrier to extract context from\n   * @param getter Function used to extract keys from a carrier\n   */\n  public extract<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier> = defaultTextMapGetter\n  ): Context {\n    return this._getGlobalPropagator().extract(context, carrier, getter);\n  }\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  public fields(): string[] {\n    return this._getGlobalPropagator().fields();\n  }\n\n  /** Remove the global propagator */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n\n  public createBaggage = createBaggage;\n\n  public getBaggage = getBaggage;\n\n  public getActiveBaggage = getActiveBaggage;\n\n  public setBaggage = setBaggage;\n\n  public deleteBaggage = deleteBaggage;\n\n  private _getGlobalPropagator(): TextMapPropagator {\n    return getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, ContextManager, ROOT_CONTEXT } from '@opentelemetry/api';\n\n/**\n * Stack Context Manager for managing the state in web\n * it doesn't fully support the async calls though\n */\nexport class StackContextManager implements ContextManager {\n  /**\n   * whether the context manager is enabled or not\n   */\n  private _enabled = false;\n\n  /**\n   * Keeps the reference to current context\n   */\n  public _currentContext = ROOT_CONTEXT;\n\n  /**\n   *\n   * @param context\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  private _bindFunction<T extends Function>(\n    context = ROOT_CONTEXT,\n    target: T\n  ): T {\n    const manager = this;\n    const contextWrapper = function (this: unknown, ...args: unknown[]) {\n      return manager.with(context, () => target.apply(this, args));\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length,\n    });\n    return contextWrapper as unknown as T;\n  }\n\n  /**\n   * Returns the active context\n   */\n  active(): Context {\n    return this._currentContext;\n  }\n\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  bind<T>(context: Context, target: T): T {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    }\n    return target;\n  }\n\n  /**\n   * Disable the context manager (clears the current context)\n   */\n  disable(): this {\n    this._currentContext = ROOT_CONTEXT;\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  enable(): this {\n    if (this._enabled) {\n      return this;\n    }\n    this._enabled = true;\n    this._currentContext = ROOT_CONTEXT;\n    return this;\n  }\n\n  /**\n   * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.\n   * The context will be set as active\n   * @param context\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context | null,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    const previousContext = this._currentContext;\n    this._currentContext = context || ROOT_CONTEXT;\n\n    try {\n      return fn.call(thisArg, ...args);\n    } finally {\n      this._currentContext = previousContext;\n    }\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class Buckets {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  constructor(\n    public backing = new BucketsBacking(),\n    public indexBase = 0,\n    public indexStart = 0,\n    public indexEnd = 0\n  ) {}\n\n  /**\n   * Offset is the bucket index of the smallest entry in the counts array\n   * @returns {number}\n   */\n  get offset(): number {\n    return this.indexStart;\n  }\n\n  /**\n   * Buckets is a view into the backing array.\n   * @returns {number}\n   */\n  get length(): number {\n    if (this.backing.length === 0) {\n      return 0;\n    }\n\n    if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n      return 0;\n    }\n\n    return this.indexEnd - this.indexStart + 1;\n  }\n\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  counts(): number[] {\n    return Array.from({ length: this.length }, (_, i) => this.at(i));\n  }\n\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  at(position: number): number {\n    const bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n\n    position -= bias;\n    return this.backing.countAt(position);\n  }\n\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  incrementBucket(bucketIndex: number, increment: number) {\n    this.backing.increment(bucketIndex, increment);\n  }\n\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  decrementBucket(bucketIndex: number, decrement: number) {\n    this.backing.decrement(bucketIndex, decrement);\n  }\n\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  trim() {\n    for (let i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n\n    this._rotate();\n  }\n\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  downscale(by: number) {\n    this._rotate();\n\n    const size = 1 + this.indexEnd - this.indexStart;\n    const each = 1 << by;\n    let inpos = 0;\n    let outpos = 0;\n\n    for (let pos = this.indexStart; pos <= this.indexEnd; ) {\n      let mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (let i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  clone(): Buckets {\n    return new Buckets(\n      this.backing.clone(),\n      this.indexBase,\n      this.indexStart,\n      this.indexEnd\n    );\n  }\n\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  private _rotate() {\n    const bias = this.indexBase - this.indexStart;\n\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  private _relocateBucket(dest: number, src: number) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  }\n}\n\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nclass BucketsBacking {\n  constructor(private _counts = [0]) {}\n\n  /**\n   * length returns the physical size of the backing array, which\n   * is >= buckets.length()\n   */\n  get length(): number {\n    return this._counts.length;\n  }\n\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  countAt(pos: number): number {\n    return this._counts[pos];\n  }\n\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  growTo(newSize: number, oldPositiveLimit: number, newPositiveLimit: number) {\n    const tmp = new Array<number>(newSize).fill(0);\n    tmp.splice(\n      newPositiveLimit,\n      this._counts.length - oldPositiveLimit,\n      ...this._counts.slice(oldPositiveLimit)\n    );\n    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));\n    this._counts = tmp;\n  }\n\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  reverse(from: number, limit: number) {\n    const num = Math.floor((from + limit) / 2) - from;\n    for (let i = 0; i < num; i++) {\n      const tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  }\n\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  emptyBucket(src: number): number {\n    const tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  }\n\n  /**\n   * increments a bucket by `increment`\n   */\n  increment(bucketIndex: number, increment: number) {\n    this._counts[bucketIndex] += increment;\n  }\n\n  /**\n   * decrements a bucket by `decrement`\n   */\n  decrement(bucketIndex: number, decrement: number) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  }\n\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  clone(): BucketsBacking {\n    return new BucketsBacking([...this._counts]);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Deferred } from './promise';\n\n/**\n * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.\n */\nexport class BindOnceFuture<\n  R,\n  This = unknown,\n  T extends (this: This, ...args: unknown[]) => R = () => R,\n> {\n  private _isCalled = false;\n  private _deferred = new Deferred<R>();\n  constructor(\n    private _callback: T,\n    private _that: This\n  ) {}\n\n  get isCalled() {\n    return this._isCalled;\n  }\n\n  get promise() {\n    return this._deferred.promise;\n  }\n\n  call(...args: Parameters<T>): Promise<R> {\n    if (!this._isCalled) {\n      this._isCalled = true;\n      try {\n        Promise.resolve(this._callback.call(this._that, ...args)).then(\n          val => this._deferred.resolve(val),\n          err => this._deferred.reject(err)\n        );\n      } catch (err) {\n        this._deferred.reject(err);\n      }\n    }\n    return this._deferred.promise;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n} from './types';\nimport {\n  DataPointType,\n  HistogramMetricData,\n  InstrumentType,\n} from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { binarySearchUB, Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\n/**\n * Internal value type for HistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram {\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n}\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): InternalHistogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private readonly _boundaries: number[],\n    private _recordMinMax = true,\n    private _current: InternalHistogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    const idx = binarySearchUB(this._boundaries, value);\n    this._current.buckets.counts[idx] += 1;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): InternalHistogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    private readonly _boundaries: number[],\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new HistogramAccumulation(\n      startTime,\n      this._boundaries,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(\n    previous: HistogramAccumulation,\n    delta: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(\n      previous.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: mergedCounts,\n        },\n        count: previousValue.count + deltaValue.count,\n        sum: previousValue.sum + deltaValue.sum,\n        hasMinMax:\n          this._recordMinMax &&\n          (previousValue.hasMinMax || deltaValue.hasMinMax),\n        min: min,\n        max: max,\n      }\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: HistogramAccumulation,\n    current: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(\n      current.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: diffedCounts,\n        },\n        count: currentValue.count - previousValue.count,\n        sum: currentValue.sum - previousValue.sum,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity,\n      }\n    );\n  }\n\n  toMetricData(\n    descriptor: InstrumentDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count,\n          },\n        };\n      }),\n    };\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * ExponentMapping implements exponential mapping functions for\n * scales <=0. For scales > 0 LogarithmMapping should be used.\n */\nexport class ExponentMapping implements Mapping {\n  private readonly _shift: number;\n\n  constructor(scale: number) {\n    this._shift = -scale;\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value < ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex();\n    }\n\n    const exp = ieee754.getNormalBase2(value);\n\n    // In case the value is an exact power of two, compute a\n    // correction of -1. Note, we are using a custom _rightShift\n    // to accommodate a 52-bit argument, which the native bitwise\n    // operators do not support\n    const correction = this._rightShift(\n      ieee754.getSignificand(value) - 1,\n      ieee754.SIGNIFICAND_WIDTH\n    );\n\n    return (exp + correction) >> this._shift;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index < minIndex) {\n      throw new MappingError(\n        `underflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index > maxIndex) {\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    return util.ldexp(1, index << this._shift);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    if (this._shift === 0) {\n      return 0;\n    }\n    return -this._shift;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;\n    if (this._shift < 2) {\n      index--;\n    }\n\n    return index;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ieee754.MAX_NORMAL_EXPONENT >> this._shift;\n  }\n\n  private _rightShift(value: number, shift: number): number {\n    return Math.floor(value * Math.pow(2, -shift));\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nexport class LogarithmMapping implements Mapping {\n  private readonly _scale: number;\n  private readonly _scaleFactor: number;\n  private readonly _inverseFactor: number;\n\n  constructor(scale: number) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      const exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    const index = Math.floor(Math.log(value) * this._scaleFactor);\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\n        `overflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n\n    return Math.exp(index * this._inverseFactor);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    return this._scale;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ((ieee754.MAX_NORMAL_EXPONENT + 1) << this._scale) - 1;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Baggage, BaggageEntry } from '../types';\n\nexport class BaggageImpl implements Baggage {\n  private _entries: Map<string, BaggageEntry>;\n\n  constructor(entries?: Map<string, BaggageEntry>) {\n    this._entries = entries ? new Map(entries) : new Map();\n  }\n\n  getEntry(key: string): BaggageEntry | undefined {\n    const entry = this._entries.get(key);\n    if (!entry) {\n      return undefined;\n    }\n\n    return Object.assign({}, entry);\n  }\n\n  getAllEntries(): [string, BaggageEntry][] {\n    return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);\n  }\n\n  setEntry(key: string, entry: BaggageEntry): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  }\n\n  removeEntry(key: string): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  }\n\n  removeEntries(...keys: string[]): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    for (const key of keys) {\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  }\n\n  clear(): BaggageImpl {\n    return new BaggageImpl();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport {\n  ExportResult,\n  ExportResultCode,\n  getNumberFromEnv,\n  globalErrorHandler,\n  unrefTimer,\n  BindOnceFuture,\n  internal,\n  callWithTimeout,\n} from '@opentelemetry/core';\n\nimport type { BufferConfig } from '../types';\nimport type { SdkLogRecord } from './SdkLogRecord';\nimport type { LogRecordExporter } from './LogRecordExporter';\nimport type { LogRecordProcessor } from '../LogRecordProcessor';\n\nexport abstract class BatchLogRecordProcessorBase<T extends BufferConfig>\n  implements LogRecordProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _finishedLogRecords: SdkLogRecord[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n\n  constructor(\n    private readonly _exporter: LogRecordExporter,\n    config?: T\n  ) {\n    this._maxExportBatchSize =\n      config?.maxExportBatchSize ??\n      getNumberFromEnv('OTEL_BLRP_MAX_EXPORT_BATCH_SIZE') ??\n      512;\n    this._maxQueueSize =\n      config?.maxQueueSize ??\n      getNumberFromEnv('OTEL_BLRP_MAX_QUEUE_SIZE') ??\n      2048;\n    this._scheduledDelayMillis =\n      config?.scheduledDelayMillis ??\n      getNumberFromEnv('OTEL_BLRP_SCHEDULE_DELAY') ??\n      5000;\n    this._exportTimeoutMillis =\n      config?.exportTimeoutMillis ??\n      getNumberFromEnv('OTEL_BLRP_EXPORT_TIMEOUT') ??\n      30000;\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchLogRecordProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  public onEmit(logRecord: SdkLogRecord): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    this._addToBuffer(logRecord);\n  }\n\n  public forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  public shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private async _shutdown(): Promise<void> {\n    this.onShutdown();\n    await this._flushAll();\n    await this._exporter.shutdown();\n  }\n\n  /** Add a LogRecord in the buffer. */\n  private _addToBuffer(logRecord: SdkLogRecord) {\n    if (this._finishedLogRecords.length >= this._maxQueueSize) {\n      return;\n    }\n    this._finishedLogRecords.push(logRecord);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all LogRecords to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      const batchCount = Math.ceil(\n        this._finishedLogRecords.length / this._maxExportBatchSize\n      );\n      for (let i = 0; i < batchCount; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedLogRecords.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      callWithTimeout(\n        this._export(\n          this._finishedLogRecords.splice(0, this._maxExportBatchSize)\n        ),\n        this._exportTimeoutMillis\n      )\n        .then(() => resolve())\n        .catch(reject);\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._timer !== undefined) {\n      return;\n    }\n    this._timer = setTimeout(() => {\n      this._flushOneBatch()\n        .then(() => {\n          if (this._finishedLogRecords.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          globalErrorHandler(e);\n        });\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  private _export(logRecords: SdkLogRecord[]): Promise<void> {\n    const doExport = () =>\n      internal\n        ._export(this._exporter, logRecords)\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `BatchLogRecordProcessor: log record export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(globalErrorHandler);\n\n    const pendingResources = logRecords\n      .map(logRecord => logRecord.resource)\n      .filter(resource => resource.asyncAttributesPending);\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (pendingResources.length === 0) {\n      return doExport();\n    } else {\n      return Promise.all(\n        pendingResources.map(resource => resource.waitForAsyncAttributes?.())\n      ).then(doExport, globalErrorHandler);\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n","import React from \"react\";\nimport type { LiveManagedRuntime } from \"./live-layer\";\n\nexport const RuntimeContext = React.createContext<LiveManagedRuntime | null>(null);\n","\"use client\";\nimport * as ManagedRuntime from \"effect/ManagedRuntime\";\nimport { NuqsAdapter } from \"nuqs/adapters/next/app\";\nimport React from \"react\";\nimport type { LiveManagedRuntime } from \"./services/runtime/live-layer\";\nimport { clientRuntimeLayer } from \"./services/runtime/live-layer\";\nimport { RuntimeProvider } from \"./services/runtime/runtime-provider\";\n\ntype BeepProviderProps = {\n  children: React.ReactNode;\n};\n\nexport const BeepProvider: React.FC<BeepProviderProps> = ({ children }) => {\n  const runtime: LiveManagedRuntime = React.useMemo(() => ManagedRuntime.make(clientRuntimeLayer), []);\n\n  return (\n    <RuntimeProvider runtime={runtime}>\n      <NuqsAdapter>{children}</NuqsAdapter>\n    </RuntimeProvider>\n  );\n};\n","\"use client\";\nimport { constVoid } from \"effect/Function\";\nimport React from \"react\";\nimport type { LiveManagedRuntime } from \"./live-layer\";\nimport { RuntimeContext } from \"./runtime-context\";\n\nexport const RuntimeProvider: React.FC<{\n  children: React.ReactNode;\n  runtime: LiveManagedRuntime;\n}> = ({ children, runtime }) => {\n  const mountRef = React.useRef(false);\n\n  React.useEffect(() => {\n    if (!mountRef.current) {\n      mountRef.current = true;\n      return constVoid;\n    }\n\n    return () => {\n      void runtime.dispose();\n    };\n  }, [runtime]);\n\n  return <RuntimeContext.Provider value={runtime}>{children}</RuntimeContext.Provider>;\n};\n","import type * as Effect from \"../Effect.js\"\nimport * as Effectable from \"../Effectable.js\"\nimport type { Exit } from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport type * as Layer from \"../Layer.js\"\nimport type * as M from \"../ManagedRuntime.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as Runtime from \"../Runtime.js\"\nimport * as Scope from \"../Scope.js\"\nimport type { Mutable } from \"../Types.js\"\nimport * as core from \"./core.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as internalLayer from \"./layer.js\"\nimport * as circular from \"./managedRuntime/circular.js\"\nimport * as internalRuntime from \"./runtime.js\"\n\ninterface ManagedRuntimeImpl<R, E> extends M.ManagedRuntime<R, E> {\n  readonly scope: Scope.CloseableScope\n  cachedRuntime: Runtime.Runtime<R> | undefined\n}\n\n/** @internal */\nexport const isManagedRuntime = (u: unknown): u is M.ManagedRuntime<unknown, unknown> => hasProperty(u, circular.TypeId)\n\nfunction provide<R, ER, A, E>(\n  managed: ManagedRuntimeImpl<R, ER>,\n  effect: Effect.Effect<A, E, R>\n): Effect.Effect<A, E | ER> {\n  return core.flatMap(\n    managed.runtimeEffect,\n    (rt) =>\n      core.withFiberRuntime((fiber) => {\n        fiber.setFiberRefs(rt.fiberRefs)\n        fiber.currentRuntimeFlags = rt.runtimeFlags\n        return core.provideContext(effect, rt.context)\n      })\n  )\n}\n\nconst ManagedRuntimeProto = {\n  ...Effectable.CommitPrototype,\n  [circular.TypeId]: circular.TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  commit(this: ManagedRuntimeImpl<unknown, unknown>) {\n    return this.runtimeEffect\n  }\n}\n\n/** @internal */\nexport const make = <R, ER>(\n  layer: Layer.Layer<R, ER, never>,\n  memoMap?: Layer.MemoMap\n): M.ManagedRuntime<R, ER> => {\n  memoMap = memoMap ?? internalLayer.unsafeMakeMemoMap()\n  const scope = internalRuntime.unsafeRunSyncEffect(fiberRuntime.scopeMake())\n  let buildFiber: Fiber.RuntimeFiber<Runtime.Runtime<R>, ER> | undefined\n  const runtimeEffect = core.withFiberRuntime<Runtime.Runtime<R>, ER>((fiber) => {\n    if (!buildFiber) {\n      buildFiber = internalRuntime.unsafeForkEffect(\n        core.tap(\n          Scope.extend(\n            internalLayer.toRuntimeWithMemoMap(layer, memoMap),\n            scope\n          ),\n          (rt) => {\n            self.cachedRuntime = rt\n          }\n        ),\n        { scope, scheduler: fiber.currentScheduler }\n      )\n    }\n    return core.flatten(buildFiber.await)\n  })\n  const self: ManagedRuntimeImpl<R, ER> = Object.assign(Object.create(ManagedRuntimeProto), {\n    memoMap,\n    scope,\n    runtimeEffect,\n    cachedRuntime: undefined,\n    runtime() {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeRunPromiseEffect(self.runtimeEffect) :\n        Promise.resolve(self.cachedRuntime)\n    },\n    dispose(): Promise<void> {\n      return internalRuntime.unsafeRunPromiseEffect(self.disposeEffect)\n    },\n    disposeEffect: core.suspend(() => {\n      ;(self as Mutable<ManagedRuntimeImpl<R, ER>>).runtimeEffect = core.die(\"ManagedRuntime disposed\")\n      self.cachedRuntime = undefined\n      return Scope.close(self.scope, core.exitVoid)\n    }),\n    runFork<A, E>(effect: Effect.Effect<A, E, R>, options?: Runtime.RunForkOptions): Fiber.RuntimeFiber<A, E | ER> {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeForkEffect(provide(self, effect), options) :\n        internalRuntime.unsafeFork(self.cachedRuntime)(effect, options)\n    },\n    runSyncExit<A, E>(effect: Effect.Effect<A, E, R>): Exit<A, E | ER> {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeRunSyncExitEffect(provide(self, effect)) :\n        internalRuntime.unsafeRunSyncExit(self.cachedRuntime)(effect)\n    },\n    runSync<A, E>(effect: Effect.Effect<A, E, R>): A {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeRunSyncEffect(provide(self, effect)) :\n        internalRuntime.unsafeRunSync(self.cachedRuntime)(effect)\n    },\n    runPromiseExit<A, E>(effect: Effect.Effect<A, E, R>, options?: {\n      readonly signal?: AbortSignal | undefined\n    }): Promise<Exit<A, E | ER>> {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeRunPromiseExitEffect(provide(self, effect), options) :\n        internalRuntime.unsafeRunPromiseExit(self.cachedRuntime)(effect, options)\n    },\n    runCallback<A, E>(\n      effect: Effect.Effect<A, E, R>,\n      options?: Runtime.RunCallbackOptions<A, E | ER> | undefined\n    ): Runtime.Cancel<A, E | ER> {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeRunCallback(internalRuntime.defaultRuntime)(provide(self, effect), options) :\n        internalRuntime.unsafeRunCallback(self.cachedRuntime)(effect, options)\n    },\n    runPromise<A, E>(effect: Effect.Effect<A, E, R>, options?: {\n      readonly signal?: AbortSignal | undefined\n    }): Promise<A> {\n      return self.cachedRuntime === undefined ?\n        internalRuntime.unsafeRunPromiseEffect(provide(self, effect), options) :\n        internalRuntime.unsafeRunPromise(self.cachedRuntime)(effect, options)\n    }\n  })\n  return self\n}\n","export const debugEnabled: boolean = isDebugEnabled()\n\nexport function debug(message: string, ...args: any[]): void {\n  if (!debugEnabled) {\n    return\n  }\n  const msg = sprintf(message, ...args)\n  performance.mark(msg)\n  try {\n    // Handle React Devtools not being able to console.log('%s', null)\n    console.log(message, ...args)\n  } catch {\n    console.log(msg)\n  }\n}\n\nexport function warn(message: string, ...args: any[]): void {\n  if (!debugEnabled) {\n    return\n  }\n  console.warn(message, ...args)\n}\n\nexport function sprintf(base: string, ...args: any[]): string {\n  return base.replace(/%[sfdO]/g, match => {\n    const arg = args.shift()\n    return match === '%O' && arg\n      ? JSON.stringify(arg).replace(/\"([^\"]+)\":/g, '$1:')\n      : String(arg)\n  })\n}\n\nfunction isDebugEnabled(): boolean {\n  // Check if localStorage is available.\n  // It may be unavailable in some environments,\n  // like Safari in private browsing mode.\n  // See https://github.com/47ng/nuqs/pull/588\n  try {\n    const test = 'nuqs-localStorage-test'\n    if (typeof localStorage === 'undefined') {\n      return false\n    }\n    localStorage.setItem(test, test)\n    const isStorageAvailable = localStorage.getItem(test) === test\n    localStorage.removeItem(test)\n    return (\n      isStorageAvailable &&\n      (localStorage.getItem('debug') || '').includes('nuqs')\n    )\n  } catch {\n    return false\n  }\n}\n","import { debug } from '../debug'\nimport { debounceController } from './debounce'\nimport { globalThrottleQueue } from './throttle'\n\nlet mutex = 0\n\nexport function setQueueResetMutex(value = 1): void {\n  mutex = value\n}\n\nexport function spinQueueResetMutex(): void {\n  // Don't let values become too negatively large and wrap around\n  mutex = Math.max(0, mutex - 1)\n  if (mutex > 0) {\n    return\n  }\n  resetQueues()\n}\n\nexport function resetQueues(): void {\n  debug('[nuqs] Aborting queues')\n  debounceController.abortAll()\n  const abortedKeys = globalThrottleQueue.abort()\n  abortedKeys.forEach(key => debounceController.queuedQuerySync.emit(key))\n}\n","import { debug } from '../../lib/debug'\nimport type { Emitter } from '../../lib/emitter'\nimport { error } from '../../lib/errors'\nimport { resetQueues, spinQueueResetMutex } from '../../lib/queues/reset'\n\nexport type SearchParamsSyncEmitterEvents = { update: URLSearchParams }\n\nexport const historyUpdateMarker = '__nuqs__'\n\ndeclare global {\n  interface History {\n    nuqs?: {\n      version: string\n      adapters: string[]\n    }\n  }\n}\n\nexport function getSearchParams(url: string | URL): URLSearchParams {\n  if (url instanceof URL) {\n    return url.searchParams\n  }\n  if (url.startsWith('?')) {\n    return new URLSearchParams(url)\n  }\n  try {\n    return new URL(url, location.origin).searchParams\n  } catch {\n    return new URLSearchParams(url)\n  }\n}\n\nexport function shouldPatchHistory(adapter: string): boolean {\n  if (typeof history === 'undefined') {\n    return false\n  }\n  if (\n    history.nuqs?.version &&\n    history.nuqs.version !== '0.0.0-inject-version-here'\n  ) {\n    console.error(\n      error(409),\n      history.nuqs.version,\n      `0.0.0-inject-version-here`,\n      adapter\n    )\n    return false\n  }\n  if (history.nuqs?.adapters?.includes(adapter)) {\n    return false\n  }\n  return true\n}\n\nexport function markHistoryAsPatched(adapter: string): void {\n  history.nuqs = history.nuqs ?? {\n    // This will be replaced by the prepack script\n    version: '0.0.0-inject-version-here',\n    adapters: []\n  }\n  history.nuqs.adapters.push(adapter)\n}\n\nexport function patchHistory(\n  emitter: Emitter<SearchParamsSyncEmitterEvents>,\n  adapter: string\n): void {\n  if (!shouldPatchHistory(adapter)) {\n    return\n  }\n  let lastSearchSeen = typeof location === 'object' ? location.search : ''\n\n  emitter.on('update', search => {\n    const searchString = search.toString()\n    lastSearchSeen = searchString.length ? '?' + searchString : ''\n  })\n\n  window.addEventListener('popstate', () => {\n    lastSearchSeen = location.search\n    resetQueues()\n  })\n\n  debug(\n    '[nuqs %s] Patching history (%s adapter)',\n    '0.0.0-inject-version-here',\n    adapter\n  )\n  function sync(url: URL | string) {\n    spinQueueResetMutex()\n    try {\n      const newSearch = new URL(url, location.origin).search\n      if (newSearch === lastSearchSeen) {\n        return\n      }\n    } catch {}\n    try {\n      emitter.emit('update', getSearchParams(url))\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  const originalPushState = history.pushState\n  const originalReplaceState = history.replaceState\n  history.pushState = function nuqs_pushState(state, marker, url) {\n    originalPushState.call(history, state, '', url)\n    if (url && marker !== historyUpdateMarker) {\n      sync(url)\n    }\n  }\n  history.replaceState = function nuqs_replaceState(state, marker, url) {\n    originalReplaceState.call(history, state, '', url)\n    if (url && marker !== historyUpdateMarker) {\n      sync(url)\n    }\n  }\n  markHistoryAsPatched(adapter)\n}\n","import type { LimitUrlUpdates } from '../../defs'\n\n// 50ms between calls to the history API seems to satisfy Chrome and Firefox.\n// Safari remains annoying with at most 100 calls in 30 seconds.\n// edit: Safari 17 now allows 100 calls per 10 seconds, a bit better.\nfunction getDefaultThrottle() {\n  if (typeof window === 'undefined') return 50\n  // https://stackoverflow.com/questions/7944460/detect-safari-browser\n  // @ts-expect-error\n  const isSafari = Boolean(window.GestureEvent)\n  if (!isSafari) {\n    return 50\n  }\n  try {\n    const match = navigator.userAgent?.match(/version\\/([\\d\\.]+) safari/i)\n    return parseFloat(match![1]!) >= 17 ? 120 : 320\n  } catch {\n    return 320\n  }\n}\n\nexport function throttle(timeMs: number): LimitUrlUpdates {\n  return { method: 'throttle', timeMs }\n}\n\nexport function debounce(timeMs: number): LimitUrlUpdates {\n  return { method: 'debounce', timeMs }\n}\n\nexport const defaultRateLimit: LimitUrlUpdates = throttle(getDefaultThrottle())\n","/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport * as internal from \"./internal/managedRuntime.js\"\nimport * as circular from \"./internal/managedRuntime/circular.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as Runtime from \"./Runtime.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 3.9.0\n * @category symbol\n */\nexport const TypeId: unique symbol = circular.TypeId as TypeId\n\n/**\n * @since 3.9.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * Checks if the provided argument is a `ManagedRuntime`.\n *\n * @since 3.9.0\n * @category guards\n */\nexport const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown> = internal.isManagedRuntime\n\n/**\n * @since 3.4.0\n */\nexport declare namespace ManagedRuntime {\n  /**\n   * @category type-level\n   * @since 3.4.0\n   */\n  export type Context<T extends ManagedRuntime<never, any>> = [T] extends [ManagedRuntime<infer R, infer _E>] ? R\n    : never\n  /**\n   * @category type-level\n   * @since 3.4.0\n   */\n  export type Error<T extends ManagedRuntime<never, any>> = [T] extends [ManagedRuntime<infer _R, infer E>] ? E : never\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface ManagedRuntime<in R, out ER> extends Effect.Effect<Runtime.Runtime<R>, ER> {\n  readonly [TypeId]: TypeId\n  readonly memoMap: Layer.MemoMap\n  readonly runtimeEffect: Effect.Effect<Runtime.Runtime<R>, ER>\n  readonly runtime: () => Promise<Runtime.Runtime<R>>\n\n  /**\n   * Executes the effect using the provided Scheduler or using the global\n   * Scheduler if not provided\n   */\n  readonly runFork: <A, E>(\n    self: Effect.Effect<A, E, R>,\n    options?: Runtime.RunForkOptions\n  ) => Fiber.RuntimeFiber<A, E | ER>\n\n  /**\n   * Executes the effect synchronously returning the exit.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runSyncExit: <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, ER | E>\n\n  /**\n   * Executes the effect synchronously throwing in case of errors or async boundaries.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runSync: <A, E>(effect: Effect.Effect<A, E, R>) => A\n\n  /**\n   * Executes the effect asynchronously, eventually passing the exit value to\n   * the specified callback.\n   *\n   * This method is effectful and should only be invoked at the edges of your\n   * program.\n   */\n  readonly runCallback: <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    options?: Runtime.RunCallbackOptions<A, E | ER> | undefined\n  ) => Runtime.Cancel<A, E | ER>\n\n  /**\n   * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n   * with the value of the effect once the effect has been executed, or will be\n   * rejected with the first error or exception throw by the effect.\n   *\n   * This method is effectful and should only be used at the edges of your\n   * program.\n   */\n  readonly runPromise: <A, E>(effect: Effect.Effect<A, E, R>, options?: {\n    readonly signal?: AbortSignal | undefined\n  }) => Promise<A>\n\n  /**\n   * Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\n   * with the `Exit` state of the effect once the effect has been executed.\n   *\n   * This method is effectful and should only be used at the edges of your\n   * program.\n   */\n  readonly runPromiseExit: <A, E>(effect: Effect.Effect<A, E, R>, options?: {\n    readonly signal?: AbortSignal | undefined\n  }) => Promise<Exit.Exit<A, ER | E>>\n\n  /**\n   * Dispose of the resources associated with the runtime.\n   */\n  readonly dispose: () => Promise<void>\n\n  /**\n   * Dispose of the resources associated with the runtime.\n   */\n  readonly disposeEffect: Effect.Effect<void, never, never>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ManagedRuntimeUnify<this>\n  readonly [Unify.ignoreSymbol]?: ManagedRuntimeUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface ManagedRuntimeUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  ManagedRuntime?: () => Extract<A[Unify.typeSymbol], ManagedRuntime<any, any>>\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface ManagedRuntimeUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * Convert a Layer into an ManagedRuntime, that can be used to run Effect's using\n * your services.\n *\n * @since 2.0.0\n * @category runtime class\n * @example\n * ```ts\n * import { Console, Effect, Layer, ManagedRuntime } from \"effect\"\n *\n * class Notifications extends Effect.Tag(\"Notifications\")<\n *   Notifications,\n *   { readonly notify: (message: string) => Effect.Effect<void> }\n * >() {\n *   static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })\n * }\n *\n * async function main() {\n *   const runtime = ManagedRuntime.make(Notifications.Live)\n *   await runtime.runPromise(Notifications.notify(\"Hello, world!\"))\n *   await runtime.dispose()\n * }\n *\n * main()\n * ```\n */\nexport const make: <R, E>(\n  layer: Layer.Layer<R, E, never>,\n  memoMap?: Layer.MemoMap | undefined\n) => ManagedRuntime<R, E> = internal.make\n","import { useRouter, useSearchParams } from 'next/navigation.js'\nimport { startTransition, useCallback, useEffect, useOptimistic } from 'react'\nimport { debug } from '../../lib/debug'\nimport { resetQueues } from '../../lib/queues/reset'\nimport { renderQueryString } from '../../lib/url-encoding'\nimport type { AdapterInterface, UpdateUrlFunction } from '../lib/defs'\nimport { markHistoryAsPatched, shouldPatchHistory } from '../lib/patch-history'\n\n// See: https://github.com/47ng/nuqs/issues/603#issuecomment-2317057128\n// and https://github.com/47ng/nuqs/discussions/960#discussioncomment-12699171\nconst NUM_HISTORY_CALLS_PER_UPDATE = 3\n\nlet mutex = 0\n\nfunction onPopState() {\n  mutex = 0\n  resetQueues()\n}\n\nfunction onHistoryStateUpdate() {\n  mutex--\n  if (mutex <= 0) {\n    mutex = 0 // Don't let values become too negatively large and wrap around\n    // Doing this after the end of the current render work because of the error:\n    // \"useInsertionEffect cannot schedule updates\"\n    // (resetting the queue causes the useSyncExternalStore of queued queries\n    // to be marked for rendering)\n    // The useInsertionEffect in question is the one in the Next.js app router core\n    //  dealing with history API calls.\n    queueMicrotask(resetQueues)\n  }\n}\n\nfunction patchHistory() {\n  if (!shouldPatchHistory('next/app')) {\n    return\n  }\n  const originalReplaceState = history.replaceState\n  const originalPushState = history.pushState\n  history.replaceState = function nuqs_replaceState(state, title, url) {\n    onHistoryStateUpdate()\n    return originalReplaceState.call(history, state, title, url)\n  }\n  history.pushState = function nuqs_pushState(state, title, url) {\n    onHistoryStateUpdate()\n    return originalPushState.call(history, state, title, url)\n  }\n  markHistoryAsPatched('next/app')\n}\n\n// Detect user navigation (clicking links, router calls)\n// and reset the queues when that happens.\nexport function NavigationSpy() {\n  useEffect(() => {\n    patchHistory()\n    window.addEventListener('popstate', onPopState)\n    return () => window.removeEventListener('popstate', onPopState)\n  }, [])\n  return null\n}\n\nexport function useNuqsNextAppRouterAdapter(): AdapterInterface {\n  const router = useRouter()\n  const searchParams = useSearchParams()\n  const [optimisticSearchParams, setOptimisticSearchParams] =\n    useOptimistic<URLSearchParams>(searchParams)\n  const updateUrl: UpdateUrlFunction = useCallback((search, options) => {\n    startTransition(() => {\n      if (!options.shallow) {\n        setOptimisticSearchParams(search)\n      }\n      const url = renderURL(search)\n      debug('[nuqs next/app] Updating url: %s', url)\n      // First, update the URL locally without triggering a network request,\n      // this allows keeping a reactive URL if the network is slow.\n      const updateMethod =\n        options.history === 'push' ? history.pushState : history.replaceState\n      mutex = NUM_HISTORY_CALLS_PER_UPDATE\n      updateMethod.call(\n        history,\n        // In next@14.1.0, useSearchParams becomes reactive to shallow updates,\n        // but only if passing `null` as the history state.\n        null,\n        '',\n        url\n      )\n      if (options.scroll) {\n        window.scrollTo(0, 0)\n      }\n      if (!options.shallow) {\n        // Call the Next.js router to perform a network request\n        // and re-render server components.\n        router.replace(url, {\n          scroll: false\n        })\n      }\n    })\n  }, [])\n  return {\n    searchParams: optimisticSearchParams,\n    updateUrl,\n    rateLimitFactor: NUM_HISTORY_CALLS_PER_UPDATE,\n    autoResetQueueOnUpdate: false\n  }\n}\n\nfunction renderURL(search: URLSearchParams) {\n  const { origin, pathname, hash } = location\n  return origin + pathname + renderQueryString(search) + hash\n}\n","import {\n  createElement,\n  Suspense,\n  type ReactElement,\n  type ReactNode\n} from 'react'\nimport { createAdapterProvider, type AdapterProps } from '../lib/context'\nimport { NavigationSpy, useNuqsNextAppRouterAdapter } from './impl.app'\n\nconst Provider = createAdapterProvider(useNuqsNextAppRouterAdapter)\n\nexport function NuqsAdapter({\n  children,\n  ...adapterProps\n}: AdapterProps & {\n  children: ReactNode\n}): ReactElement {\n  return createElement(Provider, {\n    ...adapterProps,\n    children: [\n      createElement(Suspense, {\n        key: 'nuqs-adapter-suspense-navspy',\n        children: createElement(NavigationSpy)\n      }),\n      children\n    ]\n  })\n}\n","export type Query = string | Array<string>\n\nexport function isAbsentFromUrl(query: Query | null): query is null | [] {\n  return query === null || (Array.isArray(query) && query.length === 0)\n}\n\nexport function write(\n  serialized: Query,\n  key: string,\n  searchParams: URLSearchParams\n): URLSearchParams {\n  if (typeof serialized === 'string') {\n    searchParams.set(key, serialized)\n  } else {\n    searchParams.delete(key)\n    for (const v of serialized) {\n      searchParams.append(key, v)\n    }\n    // if we get here with an empty iterable, no values were appended\n    // however, an empty iterable here means we explicitly want to set the key\n    // because for default values, we don't call write at all\n    if (!searchParams.has(key)) {\n      searchParams.set(key, '')\n    }\n  }\n  return searchParams\n}\n","export const errors = {\n  303: 'Multiple adapter contexts detected. This might happen in monorepos.',\n  404: 'nuqs requires an adapter to work with your framework.',\n  409: 'Multiple versions of the library are loaded. This may lead to unexpected behavior. Currently using `%s`, but `%s` (via the %s adapter) was about to load on top.',\n  414: 'Max safe URL length exceeded. Some browsers may not be able to accept this URL. Consider limiting the amount of state stored in the URL.',\n  422: 'Invalid options combination: `limitUrlUpdates: debounce` should be used in SSR scenarios, with `shallow: false`',\n  429: 'URL update rate-limited by the browser. Consider increasing `throttleMs` for key(s) `%s`. %O',\n  500: \"Empty search params cache. Search params can't be accessed in Layouts.\",\n  501: 'Search params cache already populated. Have you called `parse` twice?'\n} as const\n\nexport function error(code: keyof typeof errors) {\n  return `[nuqs] ${errors[code]}\n  See https://nuqs.dev/NUQS-${code}`\n}\n","export type Emitter<Events extends Record<string, unknown>> = {\n  on<Key extends keyof Events>(\n    type: Key,\n    handler: (event: Events[Key]) => any\n  ): () => void\n  off<Key extends keyof Events>(\n    type: Key,\n    handler?: (event: Events[Key]) => any\n  ): void\n  emit<Key extends keyof Events>(\n    type: Key,\n    event?: Events[Key] extends undefined ? never : Events[Key]\n  ): void\n}\n\nexport function createEmitter<\n  Events extends Record<string, unknown>\n>(): Emitter<Events> {\n  const all: Map<\n    keyof Events,\n    Array<(event: Events[keyof Events]) => any>\n  > = new Map()\n  return {\n    on<Key extends keyof Events>(\n      type: Key,\n      handler: (event: Events[Key]) => any\n    ): () => void {\n      const handlers = all.get(type) || []\n      handlers.push(handler as (event: Events[keyof Events]) => any)\n      all.set(type, handlers)\n      return () => this.off(type, handler)\n    },\n    off<Key extends keyof Events>(\n      type: Key,\n      handler: (event: Events[Key]) => any\n    ): void {\n      const handlers = all.get(type)\n      if (handlers) {\n        all.set(\n          type,\n          handlers.filter(h => h !== handler)\n        )\n      }\n    },\n    emit<Key extends keyof Events>(\n      type: Key,\n      event?: Events[Key] extends undefined ? never : Events[Key]\n    ): void {\n      const handlers = all.get(type)\n      handlers?.forEach(handler => handler(event as Events[keyof Events]))\n    }\n  }\n}\n","import { error } from './errors'\n\nexport function renderQueryString(search: URLSearchParams): string {\n  if (search.size === 0) {\n    return ''\n  }\n  const query: string[] = []\n  for (const [key, value] of search.entries()) {\n    // Replace disallowed characters in keys,\n    // see https://github.com/47ng/nuqs/issues/599\n    const safeKey = key\n      .replace(/#/g, '%23')\n      .replace(/&/g, '%26')\n      .replace(/\\+/g, '%2B')\n      .replace(/=/g, '%3D')\n      .replace(/\\?/g, '%3F')\n    query.push(`${safeKey}=${encodeQueryValue(value)}`)\n  }\n  const queryString = '?' + query.join('&')\n  warnIfURLIsTooLong(queryString)\n  return queryString\n}\n\nexport function encodeQueryValue(input: string): string {\n  return (\n    input\n      // Encode existing % signs first to avoid appearing\n      // as an incomplete escape sequence:\n      .replace(/%/g, '%25')\n      // Note: spaces are encoded as + in RFC 3986,\n      // so we pre-encode existing + signs to avoid confusion\n      // before converting spaces to + signs.\n      .replace(/\\+/g, '%2B')\n      .replace(/ /g, '+')\n      // Encode other URI-reserved characters\n      .replace(/#/g, '%23')\n      .replace(/&/g, '%26')\n      // Encode characters that break URL detection on some platforms\n      // and would drop the tail end of the querystring:\n      .replace(/\"/g, '%22')\n      .replace(/'/g, '%27')\n      .replace(/`/g, '%60')\n      .replace(/</g, '%3C')\n      .replace(/>/g, '%3E')\n      // Encode invisible ASCII control characters\n      .replace(/[\\x00-\\x1F]/g, char => encodeURIComponent(char))\n  )\n}\n\n// Note: change error documentation (NUQS-414) when changing this value.\nexport const URL_MAX_LENGTH = 2000\n\nexport function warnIfURLIsTooLong(queryString: string): void {\n  if (process.env.NODE_ENV === 'production') {\n    return\n  }\n  if (typeof location === 'undefined') {\n    return\n  }\n  const url = new URL(location.href)\n  url.search = queryString\n  if (url.href.length > URL_MAX_LENGTH) {\n    console.warn(error(414))\n  }\n}\n","// Source:\n// https://www.bennadel.com/blog/4195-using-abortcontroller-to-debounce-settimeout-calls-in-javascript.htm\n\nexport function timeout(\n  callback: () => void,\n  ms: number,\n  signal: AbortSignal\n): void {\n  function onTick() {\n    callback()\n    signal.removeEventListener('abort', onAbort)\n  }\n  const id = setTimeout(onTick, ms)\n  function onAbort() {\n    clearTimeout(id)\n    signal.removeEventListener('abort', onAbort)\n  }\n  signal.addEventListener('abort', onAbort)\n}\n","import {\n  createContext,\n  createElement,\n  useContext,\n  type Context,\n  type ProviderProps,\n  type ReactElement,\n  type ReactNode\n} from 'react'\nimport type { Options } from '../../defs'\nimport { debugEnabled } from '../../lib/debug'\nimport { error } from '../../lib/errors'\nimport type { AdapterInterface, UseAdapterHook } from './defs'\n\nexport type AdapterProps = {\n  defaultOptions?: Partial<\n    Pick<Options, 'shallow' | 'clearOnDefault' | 'scroll' | 'limitUrlUpdates'>\n  >\n  processUrlSearchParams?: (search: URLSearchParams) => URLSearchParams\n}\n\nexport type AdapterContext = AdapterProps & {\n  useAdapter: UseAdapterHook\n}\n\nexport const context: Context<AdapterContext> = createContext<AdapterContext>({\n  useAdapter() {\n    throw new Error(error(404))\n  }\n})\ncontext.displayName = 'NuqsAdapterContext'\n\ndeclare global {\n  interface Window {\n    __NuqsAdapterContext?: typeof context\n  }\n}\n\nif (debugEnabled && typeof window !== 'undefined') {\n  if (window.__NuqsAdapterContext && window.__NuqsAdapterContext !== context) {\n    console.error(error(303))\n  }\n  window.__NuqsAdapterContext = context\n}\n\nexport type AdapterProvider = (\n  props: AdapterProps & {\n    children: ReactNode\n  }\n) => ReactElement<ProviderProps<AdapterContext>>\n\n/**\n * Create a custom adapter (context provider) for nuqs to work with your framework / router.\n *\n * Adapters are based on React Context,\n *\n * @param useAdapter\n * @returns\n */\nexport function createAdapterProvider(\n  useAdapter: UseAdapterHook\n): AdapterProvider {\n  return ({ children, defaultOptions, processUrlSearchParams, ...props }) =>\n    createElement(\n      context.Provider,\n      {\n        ...props,\n        value: { useAdapter, defaultOptions, processUrlSearchParams }\n      },\n      children\n    )\n}\n\nexport function useAdapter(watchKeys: string[]): AdapterInterface {\n  const value = useContext(context)\n  if (!('useAdapter' in value)) {\n    throw new Error(error(404))\n  }\n  return value.useAdapter(watchKeys)\n}\n\nexport const useAdapterDefaultOptions = (): AdapterProps['defaultOptions'] =>\n  useContext(context).defaultOptions\n\nexport const useAdapterProcessUrlSearchParams =\n  (): AdapterProps['processUrlSearchParams'] =>\n    useContext(context).processUrlSearchParams\n","export type Resolvers<T> = {\n  promise: Promise<T>\n  resolve: (value: T | PromiseLike<T>) => void\n  reject: (reason?: any) => void\n}\n\nexport function withResolvers<T>(): Resolvers<T> {\n  const P = Promise<T>\n  if (Promise.hasOwnProperty('withResolvers')) {\n    return Promise.withResolvers<T>()\n  }\n  // todo: Remove this once Promise.withResolvers is Baseline GA (September 2026)\n  let resolve: (value: T | PromiseLike<T>) => void = () => {}\n  let reject: () => void = () => {}\n  const promise = new P((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { promise, resolve, reject }\n}\n","export function compose(\n  fns: React.TransitionStartFunction[],\n  final: () => void\n): void {\n  // Build a nested callback chain iteratively (avoids recursion helper)\n  let next = final\n  for (let i = fns.length - 1; i >= 0; i--) {\n    const fn = fns[i]\n    if (!fn) continue\n    const prev = next\n    next = () => fn(prev)\n  }\n  next()\n}\n","import type { AdapterInterface, AdapterOptions } from '../../adapters/lib/defs'\nimport type { Options } from '../../defs'\nimport { compose } from '../compose'\nimport { debug } from '../debug'\nimport { error } from '../errors'\nimport { write, type Query } from '../search-params'\nimport { timeout } from '../timeout'\nimport { withResolvers, type Resolvers } from '../with-resolvers'\nimport { defaultRateLimit } from './rate-limiting'\n\ntype UpdateMap = Map<string, Query | null>\ntype TransitionSet = Set<React.TransitionStartFunction>\nexport type UpdateQueueAdapterContext = Pick<\n  AdapterInterface,\n  | 'updateUrl'\n  | 'getSearchParamsSnapshot'\n  | 'rateLimitFactor'\n  | 'autoResetQueueOnUpdate'\n>\n\nexport type UpdateQueuePushArgs = {\n  key: string\n  query: Query | null\n  options: AdapterOptions & Pick<Options, 'startTransition'>\n}\n\nexport function getSearchParamsSnapshotFromLocation(): URLSearchParams {\n  return new URLSearchParams(location.search)\n}\n\nexport class ThrottledQueue {\n  updateMap: UpdateMap = new Map()\n  options: Required<AdapterOptions> = {\n    history: 'replace',\n    scroll: false,\n    shallow: true\n  }\n  timeMs: number = defaultRateLimit.timeMs\n  transitions: TransitionSet = new Set()\n  resolvers: Resolvers<URLSearchParams> | null = null\n  controller: AbortController | null = null\n  lastFlushedAt = 0\n  resetQueueOnNextPush = false\n\n  push(\n    { key, query, options }: UpdateQueuePushArgs,\n    timeMs: number = defaultRateLimit.timeMs\n  ): void {\n    if (this.resetQueueOnNextPush) {\n      this.reset()\n      this.resetQueueOnNextPush = false\n    }\n    debug('[nuqs gtq] Enqueueing %s=%s %O', key, query, options)\n    // Enqueue update\n    this.updateMap.set(key, query)\n    if (options.history === 'push') {\n      this.options.history = 'push'\n    }\n    if (options.scroll) {\n      this.options.scroll = true\n    }\n    if (options.shallow === false) {\n      this.options.shallow = false\n    }\n    if (options.startTransition) {\n      this.transitions.add(options.startTransition)\n    }\n    // Keep the maximum finite throttle value (or set if previous was Infinity)\n    if (!Number.isFinite(this.timeMs) || timeMs > this.timeMs) {\n      this.timeMs = timeMs\n    }\n  }\n\n  getQueuedQuery(key: string): Query | null | undefined {\n    return this.updateMap.get(key)\n  }\n\n  getPendingPromise({\n    getSearchParamsSnapshot = getSearchParamsSnapshotFromLocation\n  }: UpdateQueueAdapterContext): Promise<URLSearchParams> {\n    return this.resolvers?.promise ?? Promise.resolve(getSearchParamsSnapshot())\n  }\n\n  flush(\n    {\n      getSearchParamsSnapshot = getSearchParamsSnapshotFromLocation,\n      rateLimitFactor = 1,\n      ...adapter\n    }: UpdateQueueAdapterContext,\n    processUrlSearchParams?: (search: URLSearchParams) => URLSearchParams\n  ): Promise<URLSearchParams> {\n    this.controller ??= new AbortController()\n    if (!Number.isFinite(this.timeMs)) {\n      debug('[nuqs gtq] Skipping flush due to throttleMs=Infinity')\n      return Promise.resolve(getSearchParamsSnapshot())\n    }\n    if (this.resolvers) {\n      // Flush already scheduled\n      return this.resolvers.promise\n    }\n    this.resolvers = withResolvers<URLSearchParams>()\n    const flushNow = () => {\n      this.lastFlushedAt = performance.now()\n      const [search, error] = this.applyPendingUpdates(\n        {\n          ...adapter,\n          autoResetQueueOnUpdate: adapter.autoResetQueueOnUpdate ?? true,\n          getSearchParamsSnapshot\n        },\n        processUrlSearchParams\n      )\n      if (error === null) {\n        this.resolvers!.resolve(search)\n        this.resetQueueOnNextPush = true\n      } else {\n        this.resolvers!.reject(search)\n      }\n      this.resolvers = null\n    }\n    // We run the logic on the next event loop tick to allow\n    // multiple query updates to batch in the same event loop tick\n    // and possibly set their own throttleMs value.\n    const runOnNextTick = () => {\n      const now = performance.now()\n      const timeSinceLastFlush = now - this.lastFlushedAt\n      const timeMs = this.timeMs\n      const flushInMs =\n        rateLimitFactor * Math.max(0, timeMs - timeSinceLastFlush)\n      debug(\n        `[nuqs gtq] Scheduling flush in %f ms. Throttled at %f ms (x%f)`,\n        flushInMs,\n        timeMs,\n        rateLimitFactor\n      )\n      if (flushInMs === 0) {\n        // Since we're already in the \"next tick\" from queued updates,\n        // no need to do setTimeout(0) here.\n        flushNow()\n      } else {\n        timeout(flushNow, flushInMs, this.controller!.signal)\n      }\n    }\n    timeout(runOnNextTick, 0, this.controller.signal)\n    return this.resolvers.promise\n  }\n\n  abort(): string[] {\n    this.controller?.abort()\n    this.controller = new AbortController()\n    // todo: Better abort handling\n    this.resolvers?.resolve(new URLSearchParams())\n    this.resolvers = null\n    return this.reset()\n  }\n\n  reset(): string[] {\n    const queuedKeys = Array.from(this.updateMap.keys())\n    debug(\n      '[nuqs gtq] Resetting queue %s',\n      JSON.stringify(Object.fromEntries(this.updateMap))\n    )\n    this.updateMap.clear()\n    this.transitions.clear()\n    this.options = {\n      history: 'replace',\n      scroll: false,\n      shallow: true\n    }\n    this.timeMs = defaultRateLimit.timeMs\n    return queuedKeys\n  }\n\n  applyPendingUpdates(\n    adapter: Required<Omit<UpdateQueueAdapterContext, 'rateLimitFactor'>>,\n    processUrlSearchParams?: (search: URLSearchParams) => URLSearchParams\n  ): [URLSearchParams, null | unknown] {\n    const { updateUrl, getSearchParamsSnapshot } = adapter\n    let search = getSearchParamsSnapshot()\n    debug(\n      `[nuqs gtq] Applying %d pending update(s) on top of %s`,\n      this.updateMap.size,\n      search.toString()\n    )\n    if (this.updateMap.size === 0) {\n      return [search, null]\n    }\n    // Work on a copy and clear the queue immediately\n    const items = Array.from(this.updateMap.entries())\n    const options = { ...this.options }\n    const transitions = Array.from(this.transitions)\n    // Let the adapters choose whether to reset, as it depends on how they\n    // handle concurrent rendering (see the life-and-death.cy.ts e2e test).\n    if (adapter.autoResetQueueOnUpdate) {\n      this.reset()\n    }\n    debug('[nuqs gtq] Flushing queue %O with options %O', items, options)\n    for (const [key, value] of items) {\n      if (value === null) {\n        search.delete(key)\n      } else {\n        search = write(value, key, search)\n      }\n    }\n    if (processUrlSearchParams) {\n      search = processUrlSearchParams(search)\n    }\n    try {\n      compose(transitions, () => {\n        updateUrl(search, options)\n      })\n      return [search, null]\n    } catch (err) {\n      // This may fail due to rate-limiting of history methods,\n      // for example Safari only allows 100 updates in a 30s window.\n      console.error(error(429), items.map(([key]) => key).join(), err)\n      return [search, err]\n    }\n  }\n}\n\nexport const globalThrottleQueue: ThrottledQueue = new ThrottledQueue()\n","import { useCallback, useRef, useSyncExternalStore } from 'react'\n\n/**\n * Like `useSyncExternalStore`, but for subscribing to multiple keys.\n *\n * Each key becomes the key of the returned object,\n * and the value is the result of calling `getKeySnapshot` with that key.\n *\n * @param keys - A list of keys to subscribe to.\n * @param subscribeKey - A function that takes a key and a callback,\n * subscribes to an external store using that key (calling the callback when\n * state changes occur), and returns a function to unsubscribe from that key.\n * @param getKeySnapshot - A function that takes a key and returns the snapshot for that key.\n * It will be called on the server and on the client, so it needs to handle both\n * environments.\n */\nexport function useSyncExternalStores<T>(\n  keys: string[],\n  subscribeKey: (key: string, callback: () => void) => () => void,\n  getKeySnapshot: (key: string) => T\n): Record<string, T> {\n  const snapshot = useCallback((): [string, Record<string, T>] => {\n    const record = Object.fromEntries(\n      keys.map(key => [key, getKeySnapshot(key)])\n    )\n    const cacheKey = JSON.stringify(record)\n    return [cacheKey, record]\n  }, [keys.join(','), getKeySnapshot])\n  const cacheRef = useRef<null | [string, Record<string, T>]>(null)\n  // Initialize the cache with the initial snapshot\n  if (cacheRef.current === null) {\n    cacheRef.current = snapshot()\n  }\n  const subscribe = useCallback(\n    (callback: () => void) => {\n      const off = keys.map(key => subscribeKey(key, callback))\n      return () => off.forEach(unsubscribe => unsubscribe())\n    },\n    [keys.join(','), subscribeKey]\n  )\n  return useSyncExternalStore<Record<string, T>>(\n    subscribe,\n    () => {\n      const [cacheKey, record] = snapshot()\n      if (cacheRef.current![0] === cacheKey) {\n        return cacheRef.current![1]!\n      }\n      cacheRef.current = [cacheKey, record]\n      return record\n    },\n    () => cacheRef.current![1]!\n  )\n}\n","import { debug } from '../debug'\nimport { createEmitter, type Emitter } from '../emitter'\nimport type { Query } from '../search-params'\nimport { timeout } from '../timeout'\nimport { withResolvers, type Resolvers } from '../with-resolvers'\nimport {\n  getSearchParamsSnapshotFromLocation,\n  globalThrottleQueue,\n  ThrottledQueue,\n  type UpdateQueueAdapterContext,\n  type UpdateQueuePushArgs\n} from './throttle'\nimport { useSyncExternalStores } from './useSyncExternalStores'\n\nexport class DebouncedPromiseQueue<ValueType, OutputType> {\n  callback: (value: ValueType) => Promise<OutputType>\n  resolvers: Resolvers<OutputType> = withResolvers<OutputType>()\n  controller: AbortController = new AbortController()\n  queuedValue: ValueType | undefined = undefined\n\n  constructor(callback: (value: ValueType) => Promise<OutputType>) {\n    this.callback = callback\n  }\n\n  abort(): void {\n    this.controller.abort()\n    this.queuedValue = undefined\n  }\n\n  push(value: ValueType, timeMs: number): Promise<OutputType> {\n    this.queuedValue = value\n    this.controller.abort()\n    this.controller = new AbortController()\n    timeout(\n      () => {\n        // Keep the resolvers in a separate variable to reset the queue\n        // while the callback is pending, so that the next push can be\n        // assigned to a new Promise (and not dropped).\n        const outputResolvers = this.resolvers\n        try {\n          debug('[nuqs dq] Flushing debounce queue', value)\n          const callbackPromise = this.callback(value)\n          debug('[nuqs dq] Reset debounce queue %O', this.queuedValue)\n          this.queuedValue = undefined\n          this.resolvers = withResolvers<OutputType>()\n          callbackPromise\n            .then(output => outputResolvers.resolve(output))\n            .catch(error => outputResolvers.reject(error))\n        } catch (error) {\n          this.queuedValue = undefined\n          outputResolvers.reject(error)\n        }\n      },\n      timeMs,\n      this.controller.signal\n    )\n    return this.resolvers.promise\n  }\n}\n\n// --\n\ntype DebouncedUpdateQueue = DebouncedPromiseQueue<\n  Omit<UpdateQueuePushArgs, 'timeMs'>,\n  URLSearchParams\n>\n\nexport class DebounceController {\n  throttleQueue: ThrottledQueue\n  queues: Map<string, DebouncedUpdateQueue> = new Map()\n  queuedQuerySync: Emitter<Record<string, undefined>> = createEmitter()\n\n  constructor(throttleQueue: ThrottledQueue = new ThrottledQueue()) {\n    this.throttleQueue = throttleQueue\n  }\n\n  useQueuedQueries(keys: string[]): Record<string, Query | null | undefined> {\n    return useSyncExternalStores(\n      keys,\n      (key, callback) => this.queuedQuerySync.on(key, callback),\n      (key: string) => this.getQueuedQuery(key)\n    )\n  }\n\n  push(\n    update: Omit<UpdateQueuePushArgs, 'timeMs'>,\n    timeMs: number,\n    adapter: UpdateQueueAdapterContext\n  ): Promise<URLSearchParams> {\n    if (!Number.isFinite(timeMs)) {\n      const getSnapshot =\n        adapter.getSearchParamsSnapshot ?? getSearchParamsSnapshotFromLocation\n      return Promise.resolve(getSnapshot())\n    }\n    const key = update.key\n    if (!this.queues.has(key)) {\n      debug('[nuqs dqc] Creating debounce queue for `%s`', key)\n      const queue = new DebouncedPromiseQueue<\n        Omit<UpdateQueuePushArgs, 'timeMs'>,\n        URLSearchParams\n      >(update => {\n        this.throttleQueue.push(update)\n        return this.throttleQueue.flush(adapter).finally(() => {\n          const queuedValue = this.queues.get(update.key)?.queuedValue\n          if (queuedValue === undefined) {\n            debug('[nuqs dqc] Cleaning up empty queue for `%s`', update.key)\n            this.queues.delete(update.key)\n          }\n          this.queuedQuerySync.emit(update.key)\n        })\n      })\n      this.queues.set(key, queue)\n    }\n    debug('[nuqs dqc] Enqueueing debounce update %O', update)\n    const promise = this.queues.get(key)!.push(update, timeMs)\n    this.queuedQuerySync.emit(key)\n    return promise\n  }\n\n  abort(\n    key: string\n  ): (promise: Promise<URLSearchParams>) => Promise<URLSearchParams> {\n    const queue = this.queues.get(key)\n    if (!queue) {\n      return passThrough => passThrough\n    }\n    debug(\n      '[nuqs dqc] Aborting debounce queue %s=%s',\n      key,\n      queue.queuedValue?.query\n    )\n    this.queues.delete(key)\n    queue.abort() // Don't run to completion\n    this.queuedQuerySync.emit(key)\n    return promise => {\n      promise.then(queue.resolvers.resolve, queue.resolvers.reject)\n      // Don't chain: keep reference equality\n      return promise\n    }\n  }\n\n  abortAll(): void {\n    for (const [key, queue] of this.queues.entries()) {\n      debug(\n        '[nuqs dqc] Aborting debounce queue %s=%s',\n        key,\n        queue.queuedValue?.query\n      )\n      queue.abort()\n      // todo: Better abort handling\n      queue.resolvers.resolve(new URLSearchParams()) // Don't leave the Promise pending\n      this.queuedQuerySync.emit(key)\n    }\n    this.queues.clear()\n  }\n\n  getQueuedQuery(key: string): Query | null | undefined {\n    // The debounced queued values are more likely to be up-to-date\n    // than any updates pending in the throttle queue, which comes last\n    // in the update chain.\n    const debouncedQueued = this.queues.get(key)?.queuedValue?.query\n    if (debouncedQueued !== undefined) {\n      return debouncedQueued\n    }\n    return this.throttleQueue.getQueuedQuery(key)\n  }\n}\n\nexport const debounceController: DebounceController = new DebounceController(\n  globalThrottleQueue\n)\n","/**\n * @license React\n * scheduler.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  a: for (; 0 < index; ) {\n    var parentIndex = (index - 1) >>> 1,\n      parent = heap[parentIndex];\n    if (0 < compare(parent, node))\n      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);\n    else break a;\n  }\n}\nfunction peek(heap) {\n  return 0 === heap.length ? null : heap[0];\n}\nfunction pop(heap) {\n  if (0 === heap.length) return null;\n  var first = heap[0],\n    last = heap.pop();\n  if (last !== first) {\n    heap[0] = last;\n    a: for (\n      var index = 0, length = heap.length, halfLength = length >>> 1;\n      index < halfLength;\n\n    ) {\n      var leftIndex = 2 * (index + 1) - 1,\n        left = heap[leftIndex],\n        rightIndex = leftIndex + 1,\n        right = heap[rightIndex];\n      if (0 > compare(left, last))\n        rightIndex < length && 0 > compare(right, left)\n          ? ((heap[index] = right),\n            (heap[rightIndex] = last),\n            (index = rightIndex))\n          : ((heap[index] = left),\n            (heap[leftIndex] = last),\n            (index = leftIndex));\n      else if (rightIndex < length && 0 > compare(right, last))\n        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);\n      else break a;\n    }\n  }\n  return first;\n}\nfunction compare(a, b) {\n  var diff = a.sortIndex - b.sortIndex;\n  return 0 !== diff ? diff : a.id - b.id;\n}\nexports.unstable_now = void 0;\nif (\"object\" === typeof performance && \"function\" === typeof performance.now) {\n  var localPerformance = performance;\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date,\n    initialTime = localDate.now();\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n}\nvar taskQueue = [],\n  timerQueue = [],\n  taskIdCounter = 1,\n  currentTask = null,\n  currentPriorityLevel = 3,\n  isPerformingWork = !1,\n  isHostCallbackScheduled = !1,\n  isHostTimeoutScheduled = !1,\n  needsPaint = !1,\n  localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n  localClearTimeout = \"function\" === typeof clearTimeout ? clearTimeout : null,\n  localSetImmediate = \"undefined\" !== typeof setImmediate ? setImmediate : null;\nfunction advanceTimers(currentTime) {\n  for (var timer = peek(timerQueue); null !== timer; ) {\n    if (null === timer.callback) pop(timerQueue);\n    else if (timer.startTime <= currentTime)\n      pop(timerQueue),\n        (timer.sortIndex = timer.expirationTime),\n        push(taskQueue, timer);\n    else break;\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = !1;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled)\n    if (null !== peek(taskQueue))\n      (isHostCallbackScheduled = !0),\n        isMessageLoopRunning ||\n          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    else {\n      var firstTimer = peek(timerQueue);\n      null !== firstTimer &&\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n}\nvar isMessageLoopRunning = !1,\n  taskTimeoutID = -1,\n  frameInterval = 5,\n  startTime = -1;\nfunction shouldYieldToHost() {\n  return needsPaint\n    ? !0\n    : exports.unstable_now() - startTime < frameInterval\n      ? !1\n      : !0;\n}\nfunction performWorkUntilDeadline() {\n  needsPaint = !1;\n  if (isMessageLoopRunning) {\n    var currentTime = exports.unstable_now();\n    startTime = currentTime;\n    var hasMoreWork = !0;\n    try {\n      a: {\n        isHostCallbackScheduled = !1;\n        isHostTimeoutScheduled &&\n          ((isHostTimeoutScheduled = !1),\n          localClearTimeout(taskTimeoutID),\n          (taskTimeoutID = -1));\n        isPerformingWork = !0;\n        var previousPriorityLevel = currentPriorityLevel;\n        try {\n          b: {\n            advanceTimers(currentTime);\n            for (\n              currentTask = peek(taskQueue);\n              null !== currentTask &&\n              !(\n                currentTask.expirationTime > currentTime && shouldYieldToHost()\n              );\n\n            ) {\n              var callback = currentTask.callback;\n              if (\"function\" === typeof callback) {\n                currentTask.callback = null;\n                currentPriorityLevel = currentTask.priorityLevel;\n                var continuationCallback = callback(\n                  currentTask.expirationTime <= currentTime\n                );\n                currentTime = exports.unstable_now();\n                if (\"function\" === typeof continuationCallback) {\n                  currentTask.callback = continuationCallback;\n                  advanceTimers(currentTime);\n                  hasMoreWork = !0;\n                  break b;\n                }\n                currentTask === peek(taskQueue) && pop(taskQueue);\n                advanceTimers(currentTime);\n              } else pop(taskQueue);\n              currentTask = peek(taskQueue);\n            }\n            if (null !== currentTask) hasMoreWork = !0;\n            else {\n              var firstTimer = peek(timerQueue);\n              null !== firstTimer &&\n                requestHostTimeout(\n                  handleTimeout,\n                  firstTimer.startTime - currentTime\n                );\n              hasMoreWork = !1;\n            }\n          }\n          break a;\n        } finally {\n          (currentTask = null),\n            (currentPriorityLevel = previousPriorityLevel),\n            (isPerformingWork = !1);\n        }\n        hasMoreWork = void 0;\n      }\n    } finally {\n      hasMoreWork\n        ? schedulePerformWorkUntilDeadline()\n        : (isMessageLoopRunning = !1);\n    }\n  }\n}\nvar schedulePerformWorkUntilDeadline;\nif (\"function\" === typeof localSetImmediate)\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\nelse if (\"undefined\" !== typeof MessageChannel) {\n  var channel = new MessageChannel(),\n    port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\nexports.unstable_IdlePriority = 5;\nexports.unstable_ImmediatePriority = 1;\nexports.unstable_LowPriority = 4;\nexports.unstable_NormalPriority = 3;\nexports.unstable_Profiling = null;\nexports.unstable_UserBlockingPriority = 2;\nexports.unstable_cancelCallback = function (task) {\n  task.callback = null;\n};\nexports.unstable_forceFrameRate = function (fps) {\n  0 > fps || 125 < fps\n    ? console.error(\n        \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n      )\n    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n};\nexports.unstable_getCurrentPriorityLevel = function () {\n  return currentPriorityLevel;\n};\nexports.unstable_next = function (eventHandler) {\n  switch (currentPriorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n      var priorityLevel = 3;\n      break;\n    default:\n      priorityLevel = currentPriorityLevel;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_requestPaint = function () {\n  needsPaint = !0;\n};\nexports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      break;\n    default:\n      priorityLevel = 3;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_scheduleCallback = function (\n  priorityLevel,\n  callback,\n  options\n) {\n  var currentTime = exports.unstable_now();\n  \"object\" === typeof options && null !== options\n    ? ((options = options.delay),\n      (options =\n        \"number\" === typeof options && 0 < options\n          ? currentTime + options\n          : currentTime))\n    : (options = currentTime);\n  switch (priorityLevel) {\n    case 1:\n      var timeout = -1;\n      break;\n    case 2:\n      timeout = 250;\n      break;\n    case 5:\n      timeout = 1073741823;\n      break;\n    case 4:\n      timeout = 1e4;\n      break;\n    default:\n      timeout = 5e3;\n  }\n  timeout = options + timeout;\n  priorityLevel = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: options,\n    expirationTime: timeout,\n    sortIndex: -1\n  };\n  options > currentTime\n    ? ((priorityLevel.sortIndex = options),\n      push(timerQueue, priorityLevel),\n      null === peek(taskQueue) &&\n        priorityLevel === peek(timerQueue) &&\n        (isHostTimeoutScheduled\n          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n          : (isHostTimeoutScheduled = !0),\n        requestHostTimeout(handleTimeout, options - currentTime)))\n    : ((priorityLevel.sortIndex = timeout),\n      push(taskQueue, priorityLevel),\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0),\n        isMessageLoopRunning ||\n          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));\n  return priorityLevel;\n};\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = function (callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n","import * as Effect from \"effect/Effect\"\nimport * as Equal from \"effect/Equal\"\nimport * as Exit from \"effect/Exit\"\nimport { pipe } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Option from \"effect/Option\"\nimport * as Queue from \"effect/Queue\"\nimport * as Stream from \"effect/Stream\"\nimport type * as Atom from \"../Atom.js\"\nimport type * as Registry from \"../Registry.js\"\nimport * as Result from \"../Result.js\"\n\nconst constImmediate = { immediate: true }\nfunction constListener(_: any) {}\n\n/** @internal */\nexport const TypeId: Registry.TypeId = \"~effect-atom/atom/Registry\"\n\n/** @internal */\nexport const make = (options?: {\n  readonly initialValues?: Iterable<readonly [Atom.Atom<any>, any]> | undefined\n  readonly scheduleTask?: ((f: () => void) => void) | undefined\n  readonly timeoutResolution?: number | undefined\n  readonly defaultIdleTTL?: number | undefined\n}): Registry.Registry =>\n  new RegistryImpl(\n    options?.initialValues,\n    options?.scheduleTask,\n    options?.timeoutResolution,\n    options?.defaultIdleTTL\n  )\n\nconst SerializableTypeId: Atom.SerializableTypeId = \"~effect-atom/atom/Atom/Serializable\"\nconst atomKey = <A>(atom: Atom.Atom<A>): Atom.Atom<A> | string =>\n  SerializableTypeId in atom ? (atom as Atom.Serializable)[SerializableTypeId].key : atom\n\nclass RegistryImpl implements Registry.Registry {\n  readonly [TypeId]: Registry.TypeId\n  readonly timeoutResolution: number\n\n  constructor(\n    initialValues?: Iterable<readonly [Atom.Atom<any>, any]>,\n    readonly scheduleTask = (cb: () => void): void => queueMicrotask(cb),\n    timeoutResolution?: number,\n    readonly defaultIdleTTL?: number\n  ) {\n    this[TypeId] = TypeId\n    if (timeoutResolution === undefined && defaultIdleTTL !== undefined) {\n      this.timeoutResolution = Math.round(defaultIdleTTL / 2)\n    } else {\n      this.timeoutResolution = timeoutResolution ?? 1000\n    }\n    if (initialValues !== undefined) {\n      for (const [atom, value] of initialValues) {\n        this.ensureNode(atom).setValue(value)\n      }\n    }\n  }\n\n  readonly nodes = new Map<Atom.Atom<any> | string, Node<any>>()\n  readonly preloadedSerializable = new Map<string, unknown>()\n  readonly timeoutBuckets = new Map<number, readonly [nodes: Set<Node<any>>, handle: number]>()\n  readonly nodeTimeoutBucket = new Map<Node<any>, number>()\n  disposed = false\n\n  getNodes() {\n    return this.nodes\n  }\n\n  get<A>(atom: Atom.Atom<A>): A {\n    return this.ensureNode(atom).value()\n  }\n\n  set<R, W>(atom: Atom.Writable<R, W>, value: W): void {\n    atom.write(this.ensureNode(atom).writeContext, value)\n  }\n\n  setSerializable(key: string, encoded: unknown): void {\n    this.preloadedSerializable.set(key, encoded)\n  }\n\n  modify<R, W, A>(atom: Atom.Writable<R, W>, f: (_: R) => [returnValue: A, nextValue: W]): A {\n    const node = this.ensureNode(atom)\n    const result = f(node.value())\n    atom.write(node.writeContext, result[1])\n    return result[0]\n  }\n\n  update<R, W>(atom: Atom.Writable<R, W>, f: (_: R) => W): void {\n    const node = this.ensureNode(atom)\n    atom.write(node.writeContext, f(node.value()))\n  }\n\n  refresh = <A>(atom: Atom.Atom<A>): void => {\n    if (atom.refresh !== undefined) {\n      atom.refresh(this.refresh)\n    } else {\n      this.invalidateAtom(atom)\n    }\n  }\n\n  subscribe<A>(atom: Atom.Atom<A>, f: (_: A) => void, options?: { readonly immediate?: boolean }): () => void {\n    const node = this.ensureNode(atom)\n    if (options?.immediate) {\n      f(node.value())\n    }\n    const remove = node.subscribe(function() {\n      f(node._value)\n    })\n    return () => {\n      remove()\n      if (node.canBeRemoved) {\n        this.scheduleNodeRemoval(node)\n      }\n    }\n  }\n\n  mount<A>(atom: Atom.Atom<A>) {\n    return this.subscribe(atom, constListener, constImmediate)\n  }\n\n  atomHasTtl(atom: Atom.Atom<any>): boolean {\n    return !atom.keepAlive && atom.idleTTL !== 0 && (atom.idleTTL !== undefined || this.defaultIdleTTL !== undefined)\n  }\n\n  ensureNode<A>(atom: Atom.Atom<A>): Node<A> {\n    const key = atomKey(atom)\n    let node = this.nodes.get(key)\n    if (node === undefined) {\n      node = this.createNode(atom)\n      this.nodes.set(key, node)\n    } else if (this.atomHasTtl(atom)) {\n      this.removeNodeTimeout(node)\n    }\n    if (typeof key === \"string\" && this.preloadedSerializable.has(key)) {\n      const encoded = this.preloadedSerializable.get(key)\n      this.preloadedSerializable.delete(key)\n      const decoded = (atom as any as Atom.Serializable)[SerializableTypeId].decode(encoded)\n      node.setValue(decoded)\n    }\n    return node\n  }\n\n  createNode<A>(atom: Atom.Atom<A>): Node<A> {\n    if (this.disposed) {\n      throw new Error(`Cannot access Atom ${atom}: registry is disposed`)\n    }\n\n    if (!atom.keepAlive) {\n      this.scheduleAtomRemoval(atom)\n    }\n    return new Node(this, atom)\n  }\n\n  invalidateAtom = <A>(atom: Atom.Atom<A>): void => {\n    this.ensureNode(atom).invalidate()\n  }\n\n  scheduleAtomRemoval(atom: Atom.Atom<any>): void {\n    this.scheduleTask(() => {\n      const node = this.nodes.get(atomKey(atom))\n      if (node !== undefined && node.canBeRemoved) {\n        this.removeNode(node)\n      }\n    })\n  }\n\n  scheduleNodeRemoval(node: Node<any>): void {\n    this.scheduleTask(() => {\n      if (node.canBeRemoved) {\n        this.removeNode(node)\n      }\n    })\n  }\n\n  removeNode(node: Node<any>): void {\n    if (this.atomHasTtl(node.atom)) {\n      this.setNodeTimeout(node)\n    } else {\n      this.nodes.delete(atomKey(node.atom))\n      node.remove()\n    }\n  }\n\n  setNodeTimeout(node: Node<any>): void {\n    if (this.nodeTimeoutBucket.has(node)) {\n      return\n    }\n\n    let idleTTL = node.atom.idleTTL ?? this.defaultIdleTTL!\n    if (this.#currentSweepTTL !== null) {\n      idleTTL -= this.#currentSweepTTL\n      if (idleTTL <= 0) {\n        this.nodes.delete(atomKey(node.atom))\n        node.remove()\n        return\n      }\n    }\n    const ttl = Math.ceil(idleTTL! / this.timeoutResolution) * this.timeoutResolution\n    const timestamp = Date.now() + ttl\n    const bucket = timestamp - (timestamp % this.timeoutResolution) + this.timeoutResolution\n\n    let entry = this.timeoutBuckets.get(bucket)\n    if (entry === undefined) {\n      entry = [\n        new Set<Node<any>>(),\n        setTimeout(() => this.sweepBucket(bucket), bucket - Date.now())\n      ]\n      this.timeoutBuckets.set(bucket, entry)\n    }\n    entry[0].add(node)\n    this.nodeTimeoutBucket.set(node, bucket)\n  }\n\n  removeNodeTimeout(node: Node<any>): void {\n    const bucket = this.nodeTimeoutBucket.get(node)\n    if (bucket === undefined) {\n      return\n    }\n    this.nodeTimeoutBucket.delete(node)\n    this.scheduleNodeRemoval(node)\n\n    const [nodes, handle] = this.timeoutBuckets.get(bucket)!\n    nodes.delete(node)\n    if (nodes.size === 0) {\n      clearTimeout(handle)\n      this.timeoutBuckets.delete(bucket)\n    }\n  }\n\n  #currentSweepTTL: number | null = null\n  sweepBucket(bucket: number): void {\n    const nodes = this.timeoutBuckets.get(bucket)![0]\n    this.timeoutBuckets.delete(bucket)\n\n    nodes.forEach((node) => {\n      if (!node.canBeRemoved) {\n        return\n      }\n      this.nodeTimeoutBucket.delete(node)\n      this.nodes.delete(atomKey(node.atom))\n      this.#currentSweepTTL = node.atom.idleTTL ?? this.defaultIdleTTL!\n      node.remove()\n      this.#currentSweepTTL = null\n    })\n  }\n\n  reset(): void {\n    this.timeoutBuckets.forEach(([, handle]) => clearTimeout(handle))\n    this.timeoutBuckets.clear()\n    this.nodeTimeoutBucket.clear()\n\n    this.nodes.forEach((node) => node.remove())\n    this.nodes.clear()\n  }\n\n  dispose(): void {\n    this.disposed = true\n    this.reset()\n  }\n}\n\nconst enum NodeFlags {\n  alive = 1 << 0,\n  initialized = 1 << 1,\n  waitingForValue = 1 << 2\n}\n\nconst enum NodeState {\n  uninitialized = NodeFlags.alive | NodeFlags.waitingForValue,\n  stale = NodeFlags.alive | NodeFlags.initialized | NodeFlags.waitingForValue,\n  valid = NodeFlags.alive | NodeFlags.initialized,\n  removed = 0\n}\n\nclass Node<A> {\n  constructor(\n    readonly registry: RegistryImpl,\n    readonly atom: Atom.Atom<A>\n  ) {\n    this.writeContext = new WriteContextImpl(registry, this)\n  }\n\n  state: NodeState = NodeState.uninitialized\n  lifetime: Lifetime<A> | undefined\n  writeContext: WriteContextImpl<A>\n\n  parents: Array<Node<any>> = []\n  previousParents: Array<Node<any>> | undefined\n  children: Array<Node<any>> = []\n  listeners: Array<() => void> = []\n  skipInvalidation = false\n\n  get canBeRemoved(): boolean {\n    return !this.atom.keepAlive && this.listeners.length === 0 && this.children.length === 0 &&\n      this.state !== 0\n  }\n\n  _value: A = undefined as any\n  value(): A {\n    if ((this.state & NodeFlags.waitingForValue) !== 0) {\n      this.lifetime = makeLifetime(this)\n      const value = this.atom.read(this.lifetime)\n      if ((this.state & NodeFlags.waitingForValue) !== 0) {\n        this.setValue(value)\n      }\n\n      if (this.previousParents) {\n        const parents = this.previousParents\n        this.previousParents = undefined\n        for (let i = 0; i < parents.length; i++) {\n          parents[i].removeChild(this)\n          if (parents[i].canBeRemoved) {\n            this.registry.scheduleNodeRemoval(parents[i])\n          }\n        }\n      }\n    }\n\n    return this._value\n  }\n\n  valueOption(): Option.Option<A> {\n    if ((this.state & NodeFlags.initialized) === 0) {\n      return Option.none()\n    }\n    return Option.some(this._value)\n  }\n\n  setValue(value: A): void {\n    if ((this.state & NodeFlags.initialized) === 0) {\n      this.state = NodeState.valid\n      this._value = value\n\n      if (batchState.phase === BatchPhase.collect) {\n        batchState.notify.add(this)\n      } else {\n        this.notify()\n      }\n\n      return\n    }\n\n    this.state = NodeState.valid\n    if (Equal.equals(this._value, value)) {\n      return\n    }\n\n    this._value = value\n    if (this.skipInvalidation) {\n      this.skipInvalidation = false\n    } else {\n      this.invalidateChildren()\n    }\n\n    if (this.listeners.length > 0) {\n      if (batchState.phase === BatchPhase.collect) {\n        batchState.notify.add(this)\n      } else {\n        this.notify()\n      }\n    }\n  }\n\n  addParent(parent: Node<any>): void {\n    this.parents.push(parent)\n    if (this.previousParents !== undefined) {\n      const index = this.previousParents.indexOf(parent)\n      if (index !== -1) {\n        this.previousParents[index] = this.previousParents[this.previousParents.length - 1]\n        if (this.previousParents.pop() === undefined) {\n          this.previousParents = undefined\n        }\n      }\n    }\n\n    if (parent.children.indexOf(this) === -1) {\n      parent.children.push(this)\n    }\n  }\n\n  removeChild(child: Node<any>): void {\n    const index = this.children.indexOf(child)\n    if (index !== -1) {\n      this.children[index] = this.children[this.children.length - 1]\n      this.children.pop()\n    }\n  }\n\n  invalidate(): void {\n    if (this.state === NodeState.valid) {\n      this.state = NodeState.stale\n      this.disposeLifetime()\n    }\n\n    if (batchState.phase === BatchPhase.collect) {\n      batchState.stale.push(this)\n    } else if (this.atom.lazy && this.listeners.length === 0 && !childrenAreActive(this.children)) {\n      this.invalidateChildren()\n      this.skipInvalidation = true\n    } else {\n      this.value()\n    }\n  }\n\n  invalidateChildren(): void {\n    if (this.children.length === 0) {\n      return\n    }\n\n    const children = this.children\n    this.children = []\n    for (let i = 0; i < children.length; i++) {\n      children[i].invalidate()\n    }\n  }\n\n  notify(): void {\n    for (let i = 0; i < this.listeners.length; i++) {\n      this.listeners[i]()\n    }\n\n    if (batchState.phase === BatchPhase.commit) {\n      batchState.notify.delete(this)\n    }\n  }\n\n  disposeLifetime(): void {\n    if (this.lifetime !== undefined) {\n      this.lifetime.dispose()\n      this.lifetime = undefined\n    }\n\n    if (this.parents.length !== 0) {\n      this.previousParents = this.parents\n      this.parents = []\n    }\n  }\n\n  remove() {\n    this.state = NodeState.removed\n    this.listeners = []\n\n    if (this.lifetime === undefined) {\n      return\n    }\n\n    this.disposeLifetime()\n\n    if (this.previousParents === undefined) {\n      return\n    }\n\n    const parents = this.previousParents\n    this.previousParents = undefined\n    for (let i = 0; i < parents.length; i++) {\n      parents[i].removeChild(this)\n      if (parents[i].canBeRemoved) {\n        this.registry.removeNode(parents[i])\n      }\n    }\n  }\n\n  subscribe(listener: () => void): () => void {\n    this.listeners.push(listener)\n    return () => {\n      const index = this.listeners.indexOf(listener)\n      if (index !== -1) {\n        this.listeners[index] = this.listeners[this.listeners.length - 1]\n        this.listeners.pop()\n      }\n    }\n  }\n}\n\nfunction childrenAreActive(children: Array<Node<any>>): boolean {\n  if (children.length === 0) {\n    return false\n  }\n  let current: Array<Node<any>> | undefined = children\n  let stack: Array<Array<Node<any>>> | undefined\n  let stackIndex = 0\n  while (current !== undefined) {\n    for (let i = 0, len = current.length; i < len; i++) {\n      const child = current[i]\n      if (!child.atom.lazy || child.listeners.length > 0) {\n        return true\n      } else if (child.children.length > 0) {\n        if (stack === undefined) {\n          stack = [child.children]\n        } else {\n          stack.push(child.children)\n        }\n      }\n    }\n    current = stack?.[stackIndex++]\n  }\n  return false\n}\n\ninterface Lifetime<A> extends Atom.Context {\n  isFn: boolean\n  readonly node: Node<A>\n  finalizers: Array<() => void> | undefined\n  disposed: boolean\n  readonly dispose: () => void\n}\n\nconst disposedError = (atom: Atom.Atom<any>): Error => new Error(`Cannot use context of disposed Atom: ${atom}`)\n\nconst LifetimeProto: Omit<Lifetime<any>, \"node\" | \"finalizers\" | \"disposed\" | \"isFn\"> = {\n  get registry(): RegistryImpl {\n    return (this as Lifetime<any>).node.registry\n  },\n\n  addFinalizer(this: Lifetime<any>, f: () => void): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.finalizers ??= []\n    this.finalizers.push(f)\n  },\n\n  get<A>(this: Lifetime<any>, atom: Atom.Atom<A>): A {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    const parent = this.node.registry.ensureNode(atom)\n    this.node.addParent(parent)\n    return parent.value()\n  },\n\n  result<A, E>(this: Lifetime<any>, atom: Atom.Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E> {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    } else if (this.isFn) {\n      return this.resultOnce(atom)\n    }\n    const result = this.get(atom)\n    if (options?.suspendOnWaiting && result.waiting) {\n      return Effect.never\n    }\n    switch (result._tag) {\n      case \"Initial\": {\n        return Effect.never\n      }\n      case \"Failure\": {\n        return Exit.failCause(result.cause)\n      }\n      case \"Success\": {\n        return Effect.succeed(result.value)\n      }\n    }\n  },\n\n  resultOnce<A, E>(this: Lifetime<any>, atom: Atom.Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E> {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    return Effect.async<A, E>((resume) => {\n      const result = this.once(atom)\n      if (result._tag !== \"Initial\" && !(options?.suspendOnWaiting && result.waiting)) {\n        return resume(Result.toExit(result) as any)\n      }\n      const cancel = this.node.registry.subscribe(atom, (result) => {\n        if (result._tag === \"Initial\" || (options?.suspendOnWaiting && result.waiting)) return\n        cancel()\n        resume(Result.toExit(result) as any)\n      }, { immediate: false })\n      return Effect.sync(cancel)\n    })\n  },\n\n  some<A>(this: Lifetime<any>, atom: Atom.Atom<Option.Option<A>>): Effect.Effect<A> {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    } else if (this.isFn) {\n      return this.someOnce(atom)\n    }\n    const result = this.get(atom)\n    return result._tag === \"None\" ? Effect.never : Effect.succeed(result.value)\n  },\n\n  someOnce<A>(this: Lifetime<any>, atom: Atom.Atom<Option.Option<A>>): Effect.Effect<A> {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    return Effect.async<A>((resume) => {\n      const result = this.once(atom)\n      if (Option.isSome(result)) {\n        return resume(Effect.succeed(result.value))\n      }\n      const cancel = this.node.registry.subscribe(atom, (result) => {\n        if (Option.isNone(result)) return\n        cancel()\n        resume(Effect.succeed(result.value))\n      }, { immediate: false })\n      return Effect.sync(cancel)\n    })\n  },\n\n  once<A>(this: Lifetime<any>, atom: Atom.Atom<A>): A {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    return this.node.registry.get(atom)\n  },\n\n  self<A>(this: Lifetime<any>): Option.Option<A> {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    return this.node.valueOption() as any\n  },\n\n  refresh<A>(this: Lifetime<any>, atom: Atom.Atom<A>): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.node.registry.refresh(atom)\n  },\n\n  refreshSelf(this: Lifetime<any>): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.node.invalidate()\n  },\n\n  mount<A>(this: Lifetime<any>, atom: Atom.Atom<A>): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.addFinalizer(this.node.registry.mount(atom))\n  },\n\n  subscribe<A>(this: Lifetime<any>, atom: Atom.Atom<A>, f: (_: A) => void, options?: {\n    readonly immediate?: boolean\n  }): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.addFinalizer(this.node.registry.subscribe(atom, f, options))\n  },\n\n  setSelf<A>(this: Lifetime<any>, a: A): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.node.setValue(a as any)\n  },\n\n  set<R, W>(this: Lifetime<any>, atom: Atom.Writable<R, W>, value: W): void {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n    this.node.registry.set(atom, value)\n  },\n\n  stream<A>(this: Lifetime<any>, atom: Atom.Atom<A>, options?: {\n    readonly withoutInitialValue?: boolean\n    readonly bufferSize?: number\n  }) {\n    if (this.disposed) {\n      throw disposedError(this.node.atom)\n    }\n\n    return pipe(\n      Effect.acquireRelease(\n        Queue.bounded<A>(options?.bufferSize ?? 16),\n        Queue.shutdown\n      ),\n      Effect.tap((queue) =>\n        Effect.acquireRelease(\n          Effect.sync(() => {\n            return this.node.registry.subscribe(atom, (_) => {\n              Queue.unsafeOffer(queue, _)\n            }, { immediate: options?.withoutInitialValue !== true })\n          }),\n          (cancel) => Effect.sync(cancel)\n        )\n      ),\n      Effect.map((queue) => Stream.fromQueue(queue)),\n      Stream.unwrapScoped\n    )\n  },\n\n  streamResult<A, E>(this: Lifetime<any>, atom: Atom.Atom<Result.Result<A, E>>, options?: {\n    readonly withoutInitialValue?: boolean\n    readonly bufferSize?: number\n  }): Stream.Stream<A, E> {\n    return pipe(\n      this.stream(atom, options),\n      Stream.filter(Result.isNotInitial),\n      Stream.flatMap((result) =>\n        result._tag === \"Success\" ? Stream.succeed(result.value) : Stream.failCause(result.cause)\n      )\n    )\n  },\n\n  dispose(this: Lifetime<any>): void {\n    this.disposed = true\n    if (this.finalizers === undefined) {\n      return\n    }\n\n    const finalizers = this.finalizers\n    this.finalizers = undefined\n    for (let i = finalizers.length - 1; i >= 0; i--) {\n      finalizers[i]()\n    }\n  }\n}\n\nconst makeLifetime = <A>(node: Node<A>): Lifetime<A> => {\n  function get<A>(atom: Atom.Atom<A>): A {\n    if (get.disposed) {\n      throw disposedError(atom)\n    } else if (get.isFn) {\n      return node.registry.get(atom)\n    }\n    const parent = node.registry.ensureNode(atom)\n    node.addParent(parent)\n    return parent.value()\n  }\n  Object.setPrototypeOf(get, LifetimeProto)\n  get.isFn = false\n  get.disposed = false\n  get.finalizers = undefined\n  get.node = node\n  return get as any\n}\n\nclass WriteContextImpl<A> implements Atom.WriteContext<A> {\n  constructor(\n    readonly registry: RegistryImpl,\n    readonly node: Node<A>\n  ) {}\n  get<A>(atom: Atom.Atom<A>): A {\n    return this.registry.get(atom)\n  }\n  set<R, W>(atom: Atom.Writable<R, W>, value: W) {\n    return this.registry.set(atom, value)\n  }\n  setSelf(value: any) {\n    return this.node.setValue(value)\n  }\n  refreshSelf() {\n    return this.node.invalidate()\n  }\n}\n\n// -----------------------------------------------------------------------------\n// batching\n// -----------------------------------------------------------------------------\n\n/** @internal */\nexport const enum BatchPhase {\n  disabled,\n  collect,\n  commit\n}\n\n/** @internal */\nexport const batchState = globalValue(\"@effect-atom/atom/Registry/batchState\", () => ({\n  phase: BatchPhase.disabled,\n  depth: 0,\n  stale: [] as Array<Node<any>>,\n  notify: new Set<Node<any>>()\n}))\n\n/** @internal */\nexport function batch(f: () => void): void {\n  batchState.phase = BatchPhase.collect\n  batchState.depth++\n  try {\n    f()\n    if (batchState.depth === 1) {\n      for (let i = 0; i < batchState.stale.length; i++) {\n        batchRebuildNode(batchState.stale[i])\n      }\n      batchState.phase = BatchPhase.commit\n      for (const node of batchState.notify) {\n        node.notify()\n      }\n      batchState.notify.clear()\n    }\n  } finally {\n    batchState.depth--\n    if (batchState.depth === 0) {\n      batchState.phase = BatchPhase.disabled\n      batchState.stale = []\n    }\n  }\n}\n\nfunction batchRebuildNode(node: Node<any>) {\n  if (node.state === NodeState.valid) {\n    return\n  }\n\n  for (let i = 0; i < node.parents.length; i++) {\n    const parent = node.parents[i]\n    if (parent.state !== NodeState.valid) {\n      batchRebuildNode(parent)\n    }\n  }\n\n  // @ts-ignore\n  if (node.state !== NodeState.valid) {\n    node.value()\n  }\n}\n","/**\n * @since 1.0.0\n */\n/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport * as Cause from \"effect/Cause\"\nimport * as Equal from \"effect/Equal\"\nimport * as Exit from \"effect/Exit\"\nimport type { LazyArg } from \"effect/Function\"\nimport { constTrue, dual, identity } from \"effect/Function\"\nimport * as Hash from \"effect/Hash\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport type { Predicate, Refinement } from \"effect/Predicate\"\nimport { hasProperty, isIterable } from \"effect/Predicate\"\nimport * as Schema_ from \"effect/Schema\"\nimport type * as Types from \"effect/Types\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId = Symbol.for(\"@effect-atom/atom/Result\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Result<A, E = never> = Initial<A, E> | Success<A, E> | Failure<A, E>\n\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isResult = (u: unknown): u is Result<unknown, unknown> => hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace Result {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Proto<A, E> extends Pipeable {\n    readonly [TypeId]: {\n      readonly E: (_: never) => E\n      readonly A: (_: never) => A\n    }\n    readonly waiting: boolean\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export type Success<R> = R extends Result<infer A, infer _> ? A : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type Failure<R> = R extends Result<infer _, infer E> ? E : never\n}\n\n/**\n * @since 1.0.0\n */\nexport type With<R extends Result<any, any>, A, E> = R extends Initial<infer _A, infer _E> ? Initial<A, E>\n  : R extends Success<infer _A, infer _E> ? Success<A, E>\n  : R extends Failure<infer _A, infer _E> ? Failure<A, E>\n  : never\n\nconst ResultProto = {\n  [TypeId]: {\n    E: identity,\n    A: identity\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  [Equal.symbol](this: Result<any, any>, that: Result<any, any>): boolean {\n    if (this._tag !== that._tag && this.waiting !== that.waiting) {\n      return false\n    }\n    switch (this._tag) {\n      case \"Initial\":\n        return true\n      case \"Success\":\n        return Equal.equals(this.value, (that as Success<any, any>).value)\n      case \"Failure\":\n        return Equal.equals(this.cause, (that as Failure<any, any>).cause)\n    }\n  },\n  [Hash.symbol](this: Result<any, any>): number {\n    const tagHash = Hash.string(`${this._tag}:${this.waiting}`)\n    if (this._tag === \"Initial\") {\n      return Hash.cached(this, tagHash)\n    }\n    return Hash.cached(\n      this,\n      Hash.combine(tagHash)(this._tag === \"Success\" ? Hash.hash(this.value) : Hash.hash(this.cause))\n    )\n  }\n}\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isWaiting = <A, E>(result: Result<A, E>): boolean => result.waiting\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Initial<A, E = never> extends Result.Proto<A, E> {\n  readonly _tag: \"Initial\"\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromExit = <A, E>(exit: Exit.Exit<A, E>): Success<A, E> | Failure<A, E> =>\n  exit._tag === \"Success\" ? success(exit.value) : failure(exit.cause)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromExitWithPrevious = <A, E>(\n  exit: Exit.Exit<A, E>,\n  previous: Option.Option<Result<A, E>>\n): Success<A, E> | Failure<A, E> =>\n  exit._tag === \"Success\" ? success(exit.value) : failureWithPrevious(exit.cause, { previous })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const waitingFrom = <A, E>(previous: Option.Option<Result<A, E>>): Result<A, E> => {\n  if (previous._tag === \"None\") {\n    return initial(true)\n  }\n  return waiting(previous.value)\n}\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isInitial = <A, E>(result: Result<A, E>): result is Initial<A, E> => result._tag === \"Initial\"\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isNotInitial = <A, E>(result: Result<A, E>): result is Success<A, E> | Failure<A, E> =>\n  result._tag !== \"Initial\"\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const initial = <A = never, E = never>(waiting = false): Initial<A, E> => {\n  const result = Object.create(ResultProto)\n  result._tag = \"Initial\"\n  result.waiting = waiting\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Success<A, E = never> extends Result.Proto<A, E> {\n  readonly _tag: \"Success\"\n  readonly value: A\n  readonly timestamp: number\n}\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isSuccess = <A, E>(result: Result<A, E>): result is Success<A, E> => result._tag === \"Success\"\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const success = <A, E = never>(value: A, options?: {\n  readonly waiting?: boolean | undefined\n  readonly timestamp?: number | undefined\n}): Success<A, E> => {\n  const result = Object.create(ResultProto)\n  result._tag = \"Success\"\n  result.value = value\n  result.waiting = options?.waiting ?? false\n  result.timestamp = options?.timestamp ?? Date.now()\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Failure<A, E = never> extends Result.Proto<A, E> {\n  readonly _tag: \"Failure\"\n  readonly cause: Cause.Cause<E>\n  readonly previousSuccess: Option.Option<Success<A, E>>\n}\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isFailure = <A, E>(result: Result<A, E>): result is Failure<A, E> => result._tag === \"Failure\"\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isInterrupted = <A, E>(result: Result<A, E>): result is Failure<A, E> =>\n  result._tag === \"Failure\" && Cause.isInterruptedOnly(result.cause)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const failure = <E, A = never>(\n  cause: Cause.Cause<E>,\n  options?: {\n    readonly previousSuccess?: Option.Option<Success<A, E>> | undefined\n    readonly waiting?: boolean | undefined\n  }\n): Failure<A, E> => {\n  const result = Object.create(ResultProto)\n  result._tag = \"Failure\"\n  result.cause = cause\n  result.previousSuccess = options?.previousSuccess ?? Option.none()\n  result.waiting = options?.waiting ?? false\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const failureWithPrevious = <A, E>(\n  cause: Cause.Cause<E>,\n  options: {\n    readonly previous: Option.Option<Result<A, E>>\n    readonly waiting?: boolean | undefined\n  }\n): Failure<A, E> =>\n  failure(cause, {\n    previousSuccess: Option.flatMap(options.previous, (result) =>\n      isSuccess(result)\n        ? Option.some(result)\n        : isFailure(result)\n        ? result.previousSuccess\n        : Option.none()),\n    waiting: options.waiting\n  })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = <E, A = never>(error: E, options?: {\n  readonly previousSuccess?: Option.Option<Success<A, E>> | undefined\n  readonly waiting?: boolean | undefined\n}): Failure<A, E> => failure(Cause.fail(error), options)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const failWithPrevious = <A, E>(\n  error: E,\n  options: {\n    readonly previous: Option.Option<Result<A, E>>\n    readonly waiting?: boolean | undefined\n  }\n): Failure<A, E> => failureWithPrevious(Cause.fail(error), options)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const waiting = <R extends Result<any, any>>(self: R, options?: {\n  readonly touch?: boolean | undefined\n}): R => {\n  if (self.waiting) {\n    return options?.touch ? touch(self) : self\n  }\n  const result = Object.assign(Object.create(ResultProto), self)\n  result.waiting = true\n  if (options?.touch && isSuccess(result)) {\n    ;(result as any).timestamp = Date.now()\n  }\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const touch = <A extends Result<any, any>>(result: A): A => {\n  if (isSuccess(result)) {\n    return success(result.value, { waiting: result.waiting }) as A\n  }\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const replacePrevious = <R extends Result<any, any>, XE, A>(\n  self: R,\n  previous: Option.Option<Result<A, XE>>\n): With<R, A, Result.Failure<R>> => {\n  if (self._tag === \"Failure\") {\n    return failureWithPrevious(self.cause, { previous, waiting: self.waiting }) as any\n  }\n  return self as any\n}\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const value = <A, E>(self: Result<A, E>): Option.Option<A> => {\n  if (self._tag === \"Success\") {\n    return Option.some(self.value)\n  } else if (self._tag === \"Failure\") {\n    return Option.map(self.previousSuccess, (s) => s.value)\n  }\n  return Option.none()\n}\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const getOrElse: {\n  <B>(orElse: LazyArg<B>): <A, E>(self: Result<A, E>) => A | B\n  <A, E, B>(self: Result<A, E>, orElse: LazyArg<B>): A | B\n} = dual(2, <A, E, B>(self: Result<A, E>, orElse: LazyArg<B>): A | B => Option.getOrElse(value(self), orElse))\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const getOrThrow = <A, E>(self: Result<A, E>): A =>\n  Option.getOrThrowWith(value(self), () => new Cause.NoSuchElementException(\"Result.getOrThrow: no value found\"))\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const cause = <A, E>(self: Result<A, E>): Option.Option<Cause.Cause<E>> =>\n  self._tag === \"Failure\" ? Option.some(self.cause) : Option.none()\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const error = <A, E>(self: Result<A, E>): Option.Option<E> =>\n  self._tag === \"Failure\" ? Cause.failureOption(self.cause) : Option.none()\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toExit = <A, E>(\n  self: Result<A, E>\n): Exit.Exit<A, E | Cause.NoSuchElementException> => {\n  switch (self._tag) {\n    case \"Success\": {\n      return Exit.succeed(self.value)\n    }\n    case \"Failure\": {\n      return Exit.failCause(self.cause)\n    }\n    default: {\n      return Exit.fail(new Cause.NoSuchElementException())\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const map: {\n  <A, B>(f: (a: A) => B): <E>(self: Result<A, E>) => Result<B, E>\n  <E, A, B>(self: Result<A, E>, f: (a: A) => B): Result<B, E>\n} = dual(2, <E, A, B>(self: Result<A, E>, f: (a: A) => B): Result<B, E> => {\n  switch (self._tag) {\n    case \"Initial\":\n      return self as any as Result<B, E>\n    case \"Failure\":\n      return failure(self.cause, {\n        previousSuccess: Option.map(self.previousSuccess, (s) => success(f(s.value), s)),\n        waiting: self.waiting\n      })\n    case \"Success\":\n      return success(f(self.value), self)\n  }\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const match: {\n  <A, E, X, Y, Z>(options: {\n    readonly onInitial: (_: Initial<A, E>) => X\n    readonly onFailure: (_: Failure<A, E>) => Y\n    readonly onSuccess: (_: Success<A, E>) => Z\n  }): (self: Result<A, E>) => X | Y | Z\n  <A, E, X, Y, Z>(self: Result<A, E>, options: {\n    readonly onInitial: (_: Initial<A, E>) => X\n    readonly onFailure: (_: Failure<A, E>) => Y\n    readonly onSuccess: (_: Success<A, E>) => Z\n  }): X | Y | Z\n} = dual(2, <A, E, X, Y, Z>(self: Result<A, E>, options: {\n  readonly onInitial: (_: Initial<A, E>) => X\n  readonly onFailure: (_: Failure<A, E>) => Y\n  readonly onSuccess: (_: Success<A, E>) => Z\n}): X | Y | Z => {\n  switch (self._tag) {\n    case \"Initial\":\n      return options.onInitial(self)\n    case \"Failure\":\n      return options.onFailure(self)\n    case \"Success\":\n      return options.onSuccess(self)\n  }\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const matchWithError: {\n  <A, E, W, X, Y, Z>(options: {\n    readonly onInitial: (_: Initial<A, E>) => W\n    readonly onError: (error: E, _: Failure<A, E>) => X\n    readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y\n    readonly onSuccess: (_: Success<A, E>) => Z\n  }): (self: Result<A, E>) => W | X | Y | Z\n  <A, E, W, X, Y, Z>(self: Result<A, E>, options: {\n    readonly onInitial: (_: Initial<A, E>) => W\n    readonly onError: (error: E, _: Failure<A, E>) => X\n    readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y\n    readonly onSuccess: (_: Success<A, E>) => Z\n  }): W | X | Y | Z\n} = dual(2, <A, E, W, X, Y, Z>(self: Result<A, E>, options: {\n  readonly onInitial: (_: Initial<A, E>) => W\n  readonly onError: (error: E, _: Failure<A, E>) => X\n  readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y\n  readonly onSuccess: (_: Success<A, E>) => Z\n}): W | X | Y | Z => {\n  switch (self._tag) {\n    case \"Initial\":\n      return options.onInitial(self)\n    case \"Failure\": {\n      const e = Cause.failureOrCause(self.cause)\n      if (e._tag === \"Right\") {\n        return options.onDefect(Cause.squash(e.right), self)\n      }\n      return options.onError(e.left, self)\n    }\n    case \"Success\":\n      return options.onSuccess(self)\n  }\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const matchWithWaiting: {\n  <A, E, W, X, Y, Z>(options: {\n    readonly onWaiting: (_: Result<A, E>) => W\n    readonly onError: (error: E, _: Failure<A, E>) => X\n    readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y\n    readonly onSuccess: (_: Success<A, E>) => Z\n  }): (self: Result<A, E>) => W | X | Y | Z\n  <A, E, W, X, Y, Z>(self: Result<A, E>, options: {\n    readonly onWaiting: (_: Result<A, E>) => W\n    readonly onError: (error: E, _: Failure<A, E>) => X\n    readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y\n    readonly onSuccess: (_: Success<A, E>) => Z\n  }): W | X | Y | Z\n} = dual(2, <A, E, W, X, Y, Z>(self: Result<A, E>, options: {\n  readonly onWaiting: (_: Result<A, E>) => W\n  readonly onError: (error: E, _: Failure<A, E>) => X\n  readonly onDefect: (defect: unknown, _: Failure<A, E>) => Y\n  readonly onSuccess: (_: Success<A, E>) => Z\n}): W | X | Y | Z => {\n  if (self.waiting) {\n    return options.onWaiting(self)\n  }\n  switch (self._tag) {\n    case \"Initial\":\n      return options.onWaiting(self)\n    case \"Failure\": {\n      const e = Cause.failureOrCause(self.cause)\n      if (e._tag === \"Right\") {\n        return options.onDefect(Cause.squash(e.right), self)\n      }\n      return options.onError(e.left, self)\n    }\n    case \"Success\":\n      return options.onSuccess(self)\n  }\n})\n\n/**\n * Combines multiple results into a single result. Also works with non-result\n * values.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const all = <const Arg extends Iterable<any> | Record<string, any>>(\n  results: Arg\n): Result<\n  [Arg] extends [ReadonlyArray<any>] ? {\n      -readonly [K in keyof Arg]: [Arg[K]] extends [Result<infer _A, infer _E>] ? _A : Arg[K]\n    }\n    : [Arg] extends [Iterable<infer _A>] ? _A extends Result<infer _AA, infer _E> ? _AA : _A\n    : [Arg] extends [Record<string, any>] ? {\n        -readonly [K in keyof Arg]: [Arg[K]] extends [Result<infer _A, infer _E>] ? _A : Arg[K]\n      }\n    : never,\n  [Arg] extends [ReadonlyArray<any>] ? Result.Failure<Arg[number]>\n    : [Arg] extends [Iterable<infer _A>] ? Result.Failure<_A>\n    : [Arg] extends [Record<string, any>] ? Result.Failure<Arg[keyof Arg]>\n    : never\n> => {\n  const isIter = isIterable(results)\n  const entries = isIter\n    ? Array.from(results, (result, i) => [i, result] as const)\n    : Object.entries(results)\n  const successes: any = isIter ? [] : {}\n  let waiting = false\n  for (let i = 0; i < entries.length; i++) {\n    const [key, result] = entries[i]\n    if (!isResult(result)) {\n      successes[key] = result\n      continue\n    } else if (!isSuccess(result)) {\n      return result as any\n    }\n    successes[key] = result.value\n    if (result.waiting) {\n      waiting = true\n    }\n  }\n  return success(successes, { waiting }) as any\n}\n\n/**\n * @since 1.0.0\n * @category Builder\n */\nexport const builder = <A extends Result<any, any>>(self: A): Builder<\n  never,\n  A extends Success<infer _A, infer _E> ? _A : never,\n  A extends Failure<infer _A, infer _E> ? _E : never,\n  A extends Initial<infer _A, infer _E> ? true : never\n> => new BuilderImpl(self) as any\n\n/**\n * @since 1.0.0\n * @category Builder\n */\nexport type Builder<Out, A, E, I> =\n  & Pipeable\n  & {\n    onWaiting<B>(f: (result: Result<A, E>) => B): Builder<Out | B, A, E, I>\n    onDefect<B>(f: (defect: unknown, result: Failure<A, E>) => B): Builder<Out | B, A, E, I>\n    orElse<B>(orElse: LazyArg<B>): Out | B\n    orNull(): Out | null\n    render(): [A | I] extends [never] ? Out : Out | null\n  }\n  & ([I] extends [never] ? {} :\n    {\n      onInitial<B>(f: (result: Initial<A, E>) => B): Builder<Out | B, A, E, never>\n      onInitialOrWaiting<B>(f: (result: Result<A, E>) => B): Builder<Out | B, A, E, never>\n    })\n  & ([A] extends [never] ? {} :\n    {\n      onSuccess<B>(f: (value: A, result: Success<A, E>) => B): Builder<Out | B, never, E, I>\n    })\n  & ([E] extends [never] ? {} : {\n    onFailure<B>(f: (cause: Cause.Cause<E>, result: Failure<A, E>) => B): Builder<Out | B, A, never, I>\n\n    onError<B>(f: (error: E, result: Failure<A, E>) => B): Builder<Out | B, A, never, I>\n\n    onErrorIf<B extends E, C>(\n      refinement: Refinement<E, B>,\n      f: (error: B, result: Failure<A, E>) => C\n    ): Builder<Out | C, A, Types.EqualsWith<E, B, E, Exclude<E, B>>, I>\n    onErrorIf<C>(\n      predicate: Predicate<E>,\n      f: (error: E, result: Failure<A, E>) => C\n    ): Builder<Out | C, A, E, I>\n\n    onErrorTag<const Tags extends ReadonlyArray<Types.Tags<E>>, B>(\n      tags: Tags,\n      f: (error: Types.ExtractTag<E, Tags[number]>, result: Failure<A, E>) => B\n    ): Builder<Out | B, A, Types.ExcludeTag<E, Tags[number]>, I>\n    onErrorTag<const Tag extends Types.Tags<E>, B>(\n      tag: Tag,\n      f: (error: Types.ExtractTag<E, Tag>, result: Failure<A, E>) => B\n    ): Builder<Out | B, A, Types.ExcludeTag<E, Tag>, I>\n  })\n\nclass BuilderImpl<Out, A, E> {\n  constructor(readonly result: Result<A, E>) {}\n  public output = Option.none<Out>()\n\n  when<B extends Result<A, E>, C>(\n    refinement: Refinement<Result<A, E>, B>,\n    f: (result: B) => Option.Option<C>\n  ): any\n  when<C>(\n    refinement: Predicate<Result<A, E>>,\n    f: (result: Result<A, E>) => Option.Option<C>\n  ): any\n  when<C>(\n    refinement: Predicate<Result<A, E>>,\n    f: (result: Result<A, E>) => Option.Option<C>\n  ): any {\n    if (Option.isNone(this.output) && refinement(this.result)) {\n      const b = f(this.result)\n      if (Option.isSome(b)) {\n        ;(this as any).output = b\n      }\n    }\n    return this\n  }\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  onWaiting<B>(f: (result: Result<A, E>) => B): BuilderImpl<Out | B, A, E> {\n    return this.when((r) => r.waiting, (r) => Option.some(f(r)))\n  }\n\n  onInitialOrWaiting<B>(f: (result: Result<A, E>) => B): BuilderImpl<Out | B, A, E> {\n    return this.when((r) => isInitial(r) || r.waiting, (r) => Option.some(f(r)))\n  }\n\n  onInitial<B>(f: (result: Initial<A, E>) => B): BuilderImpl<Out | B, A, E> {\n    return this.when(isInitial, (r) => Option.some(f(r)))\n  }\n\n  onSuccess<B>(f: (value: A, result: Success<A, E>) => B): BuilderImpl<Out | B, never, E> {\n    return this.when(isSuccess, (r) => Option.some(f(r.value, r)))\n  }\n\n  onFailure<B>(f: (cause: Cause.Cause<E>, result: Failure<A, E>) => B): BuilderImpl<Out | B, A, never> {\n    return this.when(isFailure, (r) => Option.some(f(r.cause, r)))\n  }\n\n  onError<B>(f: (error: E, result: Failure<A, E>) => B): BuilderImpl<Out | B, A, never> {\n    return this.onErrorIf(constTrue, f) as any\n  }\n\n  onErrorIf<C, B extends E = E>(\n    refinement: Refinement<E, B> | Predicate<E>,\n    f: (error: B, result: Failure<A, E>) => C\n  ): BuilderImpl<Out | C, A, Types.EqualsWith<E, B, E, Exclude<E, B>>> {\n    return this.when(isFailure, (result) =>\n      Cause.failureOption(result.cause).pipe(\n        Option.filter(refinement),\n        Option.map((error) => f(error as B, result))\n      ))\n  }\n\n  onErrorTag<B>(\n    tag: string | ReadonlyArray<string>,\n    f: (error: Types.ExtractTag<E, any>, result: Failure<A, E>) => B\n  ): BuilderImpl<Out | B, A, Types.ExcludeTag<E, any>> {\n    return this.onErrorIf(\n      (e) => hasProperty(e, \"_tag\") && (Array.isArray(tag) ? tag.includes(e._tag) : e._tag === tag),\n      f\n    ) as any\n  }\n\n  onDefect<B>(f: (defect: unknown, result: Failure<A, E>) => B): BuilderImpl<Out | B, A, E> {\n    return this.when(isFailure, (result) =>\n      Cause.dieOption(result.cause).pipe(\n        Option.map((defect) => f(defect, result))\n      ))\n  }\n\n  orElse<B>(orElse: LazyArg<B>): Out | B {\n    return Option.getOrElse(this.output, orElse)\n  }\n\n  orNull(): Out | null {\n    return Option.getOrNull(this.output)\n  }\n\n  render(): Out | null {\n    if (Option.isSome(this.output)) {\n      return this.output.value\n    } else if (isFailure(this.result)) {\n      throw Cause.squash(this.result.cause)\n    }\n    return null\n  }\n}\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport type PartialEncoded<A, E> = {\n  readonly _tag: \"Initial\"\n  readonly waiting: boolean\n} | {\n  readonly _tag: \"Success\"\n  readonly waiting: boolean\n  readonly timestamp: number\n  readonly value: A\n} | {\n  readonly _tag: \"Failure\"\n  readonly waiting: boolean\n  readonly previousValue: Option.Option<A>\n  readonly cause: Cause.Cause<E>\n}\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport type Encoded<A, E> = {\n  readonly _tag: \"Initial\"\n  readonly waiting: boolean\n} | {\n  readonly _tag: \"Success\"\n  readonly waiting: boolean\n  readonly timestamp: number\n  readonly value: A\n} | {\n  readonly _tag: \"Failure\"\n  readonly waiting: boolean\n  readonly previousValue: Schema_.OptionEncoded<A>\n  readonly cause: Schema_.CauseEncoded<E, unknown>\n}\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const schemaFromSelf: Schema_.Schema<Result<any, any>> = Schema_.declare(isResult, {\n  identifier: \"Result\"\n})\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const Schema = <\n  Success extends Schema_.Schema.All = typeof Schema_.Never,\n  Error extends Schema_.Schema.All = typeof Schema_.Never\n>(\n  options: {\n    readonly success?: Success | undefined\n    readonly error?: Error | undefined\n  }\n): Schema_.transform<\n  Schema_.Schema<\n    PartialEncoded<Success[\"Type\"], Error[\"Type\"]>,\n    Encoded<Success[\"Encoded\"], Error[\"Encoded\"]>,\n    Success[\"Context\"] | Error[\"Context\"]\n  >,\n  Schema_.Schema<Result<Success[\"Type\"], Error[\"Type\"]>>\n> => {\n  const success_: Success = options.success ?? Schema_.Never as any\n  const error: Error = options.error ?? Schema_.Never as any\n  const Success = Schema_.TaggedStruct(\"Success\", {\n    waiting: Schema_.Boolean,\n    timestamp: Schema_.Number,\n    value: success_\n  })\n  return Schema_.transform(\n    Schema_.Union(\n      Schema_.TaggedStruct(\"Initial\", {\n        waiting: Schema_.Boolean\n      }),\n      Success,\n      Schema_.TaggedStruct(\"Failure\", {\n        waiting: Schema_.Boolean,\n        previousSuccess: Schema_.Option(Success as any),\n        cause: Schema_.Cause({\n          error,\n          defect: Schema_.Defect\n        })\n      })\n    ) as Schema_.Schema<\n      PartialEncoded<Success[\"Type\"], Error[\"Type\"]>,\n      Encoded<Success[\"Encoded\"], Error[\"Encoded\"]>,\n      Success[\"Context\"] | Error[\"Context\"]\n    >,\n    schemaFromSelf,\n    {\n      strict: false,\n      decode: (e) =>\n        e._tag === \"Initial\"\n          ? initial(e.waiting)\n          : e._tag === \"Success\"\n          ? success(e.value, e)\n          : failure(e.cause, e),\n      encode: identity\n    }\n  ) as any\n}\n","/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { dual } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport type * as Atom from \"./Atom.js\"\nimport type { Registry } from \"./index.js\"\nimport * as internal from \"./internal/registry.js\"\nimport * as Result from \"./Result.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: TypeId = \"~effect-atom/atom/Registry\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = \"~effect-atom/atom/Registry\"\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isRegistry = (u: unknown): u is Registry => hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Registry {\n  readonly [TypeId]: TypeId\n  readonly getNodes: () => ReadonlyMap<Atom.Atom<any> | string, Node<any>>\n  readonly get: <A>(atom: Atom.Atom<A>) => A\n  readonly mount: <A>(atom: Atom.Atom<A>) => () => void\n  readonly refresh: <A>(atom: Atom.Atom<A>) => void\n  readonly set: <R, W>(atom: Atom.Writable<R, W>, value: W) => void\n  readonly setSerializable: (key: string, encoded: unknown) => void\n  readonly modify: <R, W, A>(atom: Atom.Writable<R, W>, f: (_: R) => [returnValue: A, nextValue: W]) => A\n  readonly update: <R, W>(atom: Atom.Writable<R, W>, f: (_: R) => W) => void\n  readonly subscribe: <A>(atom: Atom.Atom<A>, f: (_: A) => void, options?: {\n    readonly immediate?: boolean\n  }) => () => void\n  readonly reset: () => void\n  readonly dispose: () => void\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\ninterface Node<A> {\n  readonly atom: Atom.Atom<A>\n  readonly value: () => A\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: (\n  options?: {\n    readonly initialValues?: Iterable<readonly [Atom.Atom<any>, any]> | undefined\n    readonly scheduleTask?: ((f: () => void) => void) | undefined\n    readonly timeoutResolution?: number | undefined\n    readonly defaultIdleTTL?: number | undefined\n  } | undefined\n) => Registry = internal.make\n\n/**\n * @since 1.0.0\n * @category Tags\n */\nexport class AtomRegistry extends Context.Tag(\"@effect/atom/Registry/CurrentRegistry\")<\n  AtomRegistry,\n  Registry\n>() {}\n\n/**\n * @since 1.0.0\n * @category Layers\n */\nexport const layerOptions = (options?: {\n  readonly initialValues?: Iterable<readonly [Atom.Atom<any>, any]> | undefined\n  readonly scheduleTask?: ((f: () => void) => void) | undefined\n  readonly timeoutResolution?: number | undefined\n  readonly defaultIdleTTL?: number | undefined\n}): Layer.Layer<AtomRegistry> =>\n  Layer.scoped(\n    AtomRegistry,\n    Effect.gen(function*() {\n      const scope = yield* Effect.scope\n      const scheduler = yield* FiberRef.get(FiberRef.currentScheduler)\n      const registry = internal.make({\n        ...options,\n        scheduleTask: options?.scheduleTask ?? ((f) => scheduler.scheduleTask(f, 0))\n      })\n      yield* Scope.addFinalizer(scope, Effect.sync(() => registry.dispose()))\n      return registry\n    })\n  )\n\n/**\n * @since 1.0.0\n * @category Layers\n */\nexport const layer: Layer.Layer<Registry.AtomRegistry> = layerOptions()\n\n// -----------------------------------------------------------------------------\n// conversions\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const toStream: {\n  <A>(atom: Atom.Atom<A>): (self: Registry) => Stream.Stream<A>\n  <A>(self: Registry, atom: Atom.Atom<A>): Stream.Stream<A>\n} = dual(\n  2,\n  <A>(self: Registry, atom: Atom.Atom<A>) =>\n    Stream.unwrapScoped(\n      Effect.contextWithEffect((context: Context.Context<Scope.Scope>) => {\n        const scope = Context.get(context, Scope.Scope)\n        return Mailbox.make<A>().pipe(\n          Effect.tap((mailbox) => {\n            const cancel = self.subscribe(atom, (value) => mailbox.unsafeOffer(value), {\n              immediate: true\n            })\n            return Scope.addFinalizer(\n              scope,\n              Effect.suspend(() => {\n                cancel()\n                return mailbox.shutdown\n              })\n            )\n          }),\n          Effect.uninterruptible,\n          Effect.map((mailbox) => Mailbox.toStream(mailbox))\n        )\n      })\n    )\n)\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const toStreamResult: {\n  <A, E>(atom: Atom.Atom<Result.Result<A, E>>): (self: Registry) => Stream.Stream<A, E>\n  <A, E>(self: Registry, atom: Atom.Atom<Result.Result<A, E>>): Stream.Stream<A, E>\n} = dual(\n  2,\n  <A, E>(self: Registry, atom: Atom.Atom<Result.Result<A, E>>): Stream.Stream<A, E> =>\n    toStream(self, atom).pipe(\n      Stream.filter(Result.isNotInitial),\n      Stream.mapEffect((result) =>\n        result._tag === \"Success\" ? Effect.succeed(result.value) : Effect.failCause(result.cause)\n      )\n    )\n)\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const getResult: {\n  <A, E>(atom: Atom.Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): (self: Registry) => Effect.Effect<A, E>\n  <A, E>(self: Registry, atom: Atom.Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E>\n} = dual(\n  (args) => isRegistry(args[0]),\n  <A, E>(self: Registry, atom: Atom.Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E> => {\n    const suspendOnWaiting = options?.suspendOnWaiting ?? false\n    return Effect.async((resume) => {\n      const result = self.get(atom)\n      if (result._tag !== \"Initial\" && !(suspendOnWaiting && result.waiting)) {\n        return resume(Result.toExit(result) as any)\n      }\n      const cancel = self.subscribe(atom, (value) => {\n        if (value._tag !== \"Initial\" && !(suspendOnWaiting && value.waiting)) {\n          resume(Result.toExit(value) as any)\n          cancel()\n        }\n      })\n      return Effect.sync(cancel)\n    })\n  }\n)\n","/**\n * @since 1.0.0\n */\n\"use client\"\nimport type * as Atom from \"@effect-atom/atom/Atom\"\nimport * as Registry from \"@effect-atom/atom/Registry\"\nimport * as React from \"react\"\nimport * as Scheduler from \"scheduler\"\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport function scheduleTask(f: () => void): void {\n  Scheduler.unstable_scheduleCallback(Scheduler.unstable_LowPriority, f)\n}\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport const RegistryContext = React.createContext<Registry.Registry>(Registry.make({\n  scheduleTask,\n  defaultIdleTTL: 400\n}))\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport const RegistryProvider = (options: {\n  readonly children?: React.ReactNode | undefined\n  readonly initialValues?: Iterable<readonly [Atom.Atom<any>, any]> | undefined\n  readonly scheduleTask?: ((f: () => void) => void) | undefined\n  readonly timeoutResolution?: number | undefined\n  readonly defaultIdleTTL?: number | undefined\n}) => {\n  const ref = React.useRef<{\n    readonly registry: Registry.Registry\n    timeout?: number | undefined\n  }>(null)\n  if (ref.current === null) {\n    ref.current = {\n      registry: Registry.make({\n        scheduleTask: options.scheduleTask ?? scheduleTask,\n        initialValues: options.initialValues,\n        timeoutResolution: options.timeoutResolution,\n        defaultIdleTTL: options.defaultIdleTTL\n      })\n    }\n  }\n  React.useEffect(() => {\n    if (ref.current?.timeout !== undefined) {\n      clearTimeout(ref.current.timeout)\n    }\n    return () => {\n      ref.current!.timeout = setTimeout(() => {\n        ref.current?.registry.dispose()\n        ref.current = null\n      }, 500)\n    }\n  }, [ref])\n  return React.createElement(RegistryContext.Provider, { value: ref.current.registry }, options?.children)\n}\n","/**\n * @since 1.0.0\n */\n/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport * as Reactivity from \"@effect/experimental/Reactivity\"\nimport * as KeyValueStore from \"@effect/platform/KeyValueStore\"\nimport * as Arr from \"effect/Array\"\nimport { NoSuchElementException } from \"effect/Cause\"\nimport * as Cause from \"effect/Cause\"\nimport * as Channel from \"effect/Channel\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as EffectContext from \"effect/Context\"\nimport * as Duration from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport * as Exit from \"effect/Exit\"\nimport * as Fiber from \"effect/Fiber\"\nimport * as FiberId from \"effect/FiberId\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport type { LazyArg } from \"effect/Function\"\nimport { constant, constVoid, dual, pipe } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Layer from \"effect/Layer\"\nimport * as MutableHashMap from \"effect/MutableHashMap\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport { hasProperty, isObject } from \"effect/Predicate\"\nimport type { ReadonlyRecord } from \"effect/Record\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Schema from \"effect/Schema\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Subscribable from \"effect/Subscribable\"\nimport * as SubscriptionRef from \"effect/SubscriptionRef\"\nimport type { NoInfer } from \"effect/Types\"\nimport * as internalRegistry from \"./internal/registry.js\"\nimport { runCallbackSync } from \"./internal/runtime.js\"\nimport * as Registry from \"./Registry.js\"\nimport { AtomRegistry as AtomRegistry } from \"./Registry.js\"\nimport * as Result from \"./Result.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: TypeId = \"~effect-atom/atom/Atom\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = \"~effect-atom/atom/Atom\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Atom<A> extends Pipeable, Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly keepAlive: boolean\n  readonly lazy: boolean\n  readonly read: (get: Context) => A\n  readonly refresh?: (f: <A>(atom: Atom<A>) => void) => void\n  readonly label?: readonly [name: string, stack: string]\n  readonly idleTTL?: number\n}\n\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isAtom = (u: unknown): u is Atom<any> => hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n */\nexport type Type<T extends Atom<any>> = T extends Atom<infer A> ? A : never\n\n/**\n * @since 1.0.0\n */\nexport type Success<T extends Atom<any>> = T extends Atom<Result.Result<infer A, infer _>> ? A : never\n\n/**\n * @since 1.0.0\n */\nexport type PullSuccess<T extends Atom<any>> = T extends Atom<PullResult<infer A, infer _>> ? A : never\n\n/**\n * @since 1.0.0\n */\nexport type Failure<T extends Atom<any>> = T extends Atom<Result.Result<infer _, infer E>> ? E : never\n\n/**\n * @since 1.0.0\n */\nexport type WithoutSerializable<T extends Atom<any>> = T extends Writable<infer R, infer W> ? Writable<R, W>\n  : Atom<Type<T>>\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const WritableTypeId: WritableTypeId = \"~effect-atom/atom/Atom/Writable\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type WritableTypeId = \"~effect-atom/atom/Atom/Writable\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Writable<R, W = R> extends Atom<R> {\n  readonly [WritableTypeId]: WritableTypeId\n  readonly write: (ctx: WriteContext<R>, value: W) => void\n}\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport interface Context {\n  <A>(atom: Atom<A>): A\n  get<A>(this: Context, atom: Atom<A>): A\n  result<A, E>(this: Context, atom: Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E>\n  resultOnce<A, E>(this: Context, atom: Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E>\n  once<A>(this: Context, atom: Atom<A>): A\n  addFinalizer(this: Context, f: () => void): void\n  mount<A>(this: Context, atom: Atom<A>): void\n  refresh<A>(this: Context, atom: Atom<A>): void\n  refreshSelf(this: Context): void\n  self<A>(this: Context): Option.Option<A>\n  setSelf<A>(this: Context, a: A): void\n  set<R, W>(this: Context, atom: Writable<R, W>, value: W): void\n  some<A>(this: Context, atom: Atom<Option.Option<A>>): Effect.Effect<A>\n  someOnce<A>(this: Context, atom: Atom<Option.Option<A>>): Effect.Effect<A>\n  stream<A>(this: Context, atom: Atom<A>, options?: {\n    readonly withoutInitialValue?: boolean\n    readonly bufferSize?: number\n  }): Stream.Stream<A>\n  streamResult<A, E>(this: Context, atom: Atom<Result.Result<A, E>>, options?: {\n    readonly withoutInitialValue?: boolean\n    readonly bufferSize?: number\n  }): Stream.Stream<A, E>\n  subscribe<A>(this: Context, atom: Atom<A>, f: (_: A) => void, options?: {\n    readonly immediate?: boolean\n  }): void\n  readonly registry: Registry.Registry\n}\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport interface WriteContext<A> {\n  get<T>(this: WriteContext<A>, atom: Atom<T>): T\n  refreshSelf(this: WriteContext<A>): void\n  setSelf(this: WriteContext<A>, a: A): void\n  set<R, W>(this: WriteContext<A>, atom: Writable<R, W>, value: W): void\n}\n\nconst AtomProto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  toJSON(this: Atom<any>) {\n    return {\n      _id: \"Atom\",\n      keepAlive: this.keepAlive,\n      lazy: this.lazy,\n      label: this.label\n    }\n  },\n  toString() {\n    return Inspectable.format(this)\n  },\n  [Inspectable.NodeInspectSymbol](this: Atom<any>) {\n    return this.toJSON()\n  }\n} as const\n\nconst RuntimeProto = {\n  ...AtomProto,\n  atom(this: AtomRuntime<any, any>, arg: any, options?: { readonly initialValue?: unknown }) {\n    const read = makeRead(arg, options)\n    return readable((get) => {\n      const previous = get.self<Result.Result<any, any>>()\n      const runtimeResult = get(this)\n      if (runtimeResult._tag !== \"Success\") {\n        return Result.replacePrevious(runtimeResult, previous)\n      }\n      return read(get, runtimeResult.value)\n    })\n  },\n\n  fn(this: AtomRuntime<any, any>, arg: any, options?: {\n    readonly initialValue?: unknown\n    readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined\n    readonly concurrent?: boolean | undefined\n  }) {\n    if (arguments.length === 0) {\n      return (arg: any, options?: {}) => makeFnRuntime(this, arg, options)\n    }\n    return makeFnRuntime(this, arg, options)\n  },\n\n  pull(this: AtomRuntime<any, any>, arg: any, options?: {\n    readonly disableAccumulation?: boolean\n    readonly initialValue?: ReadonlyArray<any>\n  }) {\n    const pullSignal = state(0)\n    const pullAtom = readable((get) => {\n      const previous = get.self<Result.Result<any, any>>()\n      const runtimeResult = get(this)\n      if (runtimeResult._tag !== \"Success\") {\n        return Result.replacePrevious(runtimeResult, previous)\n      }\n      return makeEffect(\n        get,\n        makeStreamPullEffect(get, pullSignal, arg, options),\n        Result.initial(true),\n        runtimeResult.value\n      )\n    })\n    return makeStreamPull(pullSignal, pullAtom)\n  },\n\n  subscriptionRef(this: AtomRuntime<any, any>, ref: any) {\n    return makeSubRef(\n      readable((get) => {\n        const previous = get.self<Result.Result<any, any>>()\n        const runtimeResult = get(this)\n        if (runtimeResult._tag !== \"Success\") {\n          return Result.replacePrevious(runtimeResult, previous)\n        }\n        const value = typeof ref === \"function\" ? ref(get) : ref\n        return SubscriptionRef.SubscriptionRefTypeId in value\n          ? value\n          : makeEffect(get, value, Result.initial(true), runtimeResult.value)\n      }),\n      (get, ref) => {\n        const runtime = Result.getOrThrow(get(this))\n        return readSubscribable(get, ref, runtime)\n      }\n    )\n  },\n\n  subscribable(this: AtomRuntime<any, any>, arg: any) {\n    return makeSubscribable(\n      readable((get) => {\n        const previous = get.self<Result.Result<any, any>>()\n        const runtimeResult = get(this)\n        if (runtimeResult._tag !== \"Success\") {\n          return Result.replacePrevious(runtimeResult, previous)\n        }\n        const value = typeof arg === \"function\" ? arg(get) : arg\n        return Subscribable.isSubscribable(value) ?\n          value as Subscribable.Subscribable<any, any>\n          : makeEffect(get, value, Result.initial(true), runtimeResult.value)\n      }),\n      (get, ref) => {\n        const runtime = Result.getOrThrow(get(this))\n        return readSubscribable(get, ref, runtime)\n      }\n    )\n  }\n}\n\nconst makeFnRuntime = (\n  self: AtomRuntime<any, any>,\n  arg: (\n    arg: any,\n    get: FnContext\n  ) =>\n    | Effect.Effect<any, any, Scope.Scope | AtomRegistry>\n    | Stream.Stream<any, any, AtomRegistry>,\n  options?: {\n    readonly initialValue?: unknown\n    readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined\n  }\n) => {\n  const [read, write, argAtom] = makeResultFn(\n    options?.reactivityKeys ?\n      ((a: any, get: FnContext) => {\n        const effect = arg(a, get)\n        return Effect.isEffect(effect)\n          ? Reactivity.mutation(effect, options.reactivityKeys!)\n          : Stream.ensuring(effect, Reactivity.invalidate(options.reactivityKeys!))\n      }) as any :\n      arg,\n    options\n  )\n  return writable((get) => {\n    get.get(argAtom)\n    const previous = get.self<Result.Result<any, any>>()\n    const runtimeResult = get.get(self)\n    if (runtimeResult._tag !== \"Success\") {\n      return Result.replacePrevious(runtimeResult, previous)\n    }\n    return read(get, runtimeResult.value)\n  }, write)\n}\n\nconst WritableProto = {\n  ...AtomProto,\n  [WritableTypeId]: WritableTypeId\n} as const\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isWritable = <R, W>(atom: Atom<R>): atom is Writable<R, W> => WritableTypeId in atom\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const readable = <A>(\n  read: (get: Context) => A,\n  refresh?: (f: <A>(atom: Atom<A>) => void) => void\n): Atom<A> => {\n  const self = Object.create(AtomProto)\n  self.keepAlive = false\n  self.lazy = true\n  self.read = read\n  self.refresh = refresh\n  return self\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const writable = <R, W>(\n  read: (get: Context) => R,\n  write: (ctx: WriteContext<R>, value: W) => void,\n  refresh?: (f: <A>(atom: Atom<A>) => void) => void\n): Writable<R, W> => {\n  const self = Object.create(WritableProto)\n  self.keepAlive = false\n  self.lazy = true\n  self.read = read\n  self.write = write\n  self.refresh = refresh\n  return self\n}\n\nfunction constSetSelf<A>(ctx: WriteContext<A>, value: A) {\n  ctx.setSelf(value)\n}\n\n// -----------------------------------------------------------------------------\n// constructors\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: {\n  <A, E>(create: (get: Context) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): Atom<Result.Result<A, E>>\n  <A, E>(effect: Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): Atom<Result.Result<A, E>>\n  <A, E>(create: (get: Context) => Stream.Stream<A, E, AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): Atom<Result.Result<A, E>>\n  <A, E>(stream: Stream.Stream<A, E, AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): Atom<Result.Result<A, E>>\n  <A>(create: (get: Context) => A): Atom<A>\n  <A>(initialValue: A): Writable<A>\n} = (arg: any, options?: { readonly initialValue?: unknown }) => {\n  const readOrAtom = makeRead(arg, options)\n  if (TypeId in readOrAtom) {\n    return readOrAtom as any\n  }\n  return readable(readOrAtom)\n}\n\n// -----------------------------------------------------------------------------\n// constructors - effect\n// -----------------------------------------------------------------------------\n\nconst isDataType = (u: object): u is Option.Option<unknown> | Either.Either<unknown, unknown> =>\n  Option.TypeId in u ||\n  Either.TypeId in u\n\nconst makeRead: {\n  <A, E>(effect: Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): (get: Context, runtime?: Runtime.Runtime<any>) => Result.Result<A, E>\n  <A, E>(create: (get: Context) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): (get: Context, runtime?: Runtime.Runtime<any>) => Result.Result<A, E>\n  <A, E>(stream: Stream.Stream<A, E, AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): (get: Context, runtime?: Runtime.Runtime<any>) => Result.Result<A, E>\n  <A, E>(create: (get: Context) => Stream.Stream<A, E, AtomRegistry>, options?: {\n    readonly initialValue?: A\n  }): (get: Context, runtime?: Runtime.Runtime<any>) => Result.Result<A, E>\n  <A>(create: (get: Context) => A): (get: Context, runtime?: Runtime.Runtime<any>) => A\n  <A>(initialValue: A): Writable<A>\n} = <A, E>(\n  arg:\n    | Effect.Effect<A, E, Scope.Scope | AtomRegistry>\n    | ((get: Context) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>)\n    | Stream.Stream<A, E, AtomRegistry>\n    | ((get: Context) => Stream.Stream<A, E, AtomRegistry>)\n    | ((get: Context) => A)\n    | A,\n  options?: { readonly initialValue?: unknown }\n) => {\n  if (typeof arg === \"function\" && !Effect.isEffect(arg) && !(Stream.StreamTypeId in arg)) {\n    const create = arg as (get: Context) => any\n    return function(get: Context, providedRuntime?: Runtime.Runtime<any>) {\n      const value = create(get)\n      if (isObject(value)) {\n        if (isDataType(value)) {\n          return value\n        } else if (Effect.EffectTypeId in value) {\n          return effect(get, value as any, options, providedRuntime)\n        } else if (Stream.StreamTypeId in value) {\n          return stream(get, value as any, options, providedRuntime)\n        }\n      }\n      return value\n    }\n  } else if (isObject(arg)) {\n    if (isDataType(arg)) {\n      return state(arg)\n    } else if (Effect.EffectTypeId in arg) {\n      return function(get: Context, providedRuntime?: Runtime.Runtime<any>) {\n        return effect(get, arg as any, options, providedRuntime)\n      }\n    } else if (Stream.StreamTypeId in arg) {\n      return function(get: Context, providedRuntime?: Runtime.Runtime<any>) {\n        return stream(get, arg as any, options, providedRuntime)\n      }\n    }\n  }\n\n  return state(arg) as any\n}\n\nconst state = <A>(\n  initialValue: A\n): Writable<A> =>\n  writable(function(_get) {\n    return initialValue\n  }, constSetSelf)\n\nconst effect = <A, E>(\n  get: Context,\n  effect: Effect.Effect<A, E, Scope.Scope | AtomRegistry>,\n  options?: { readonly initialValue?: A; readonly uninterruptible?: boolean },\n  runtime?: Runtime.Runtime<any>\n): Result.Result<A, E> => {\n  const initialValue = options?.initialValue !== undefined\n    ? Result.success<A, E>(options.initialValue)\n    : Result.initial<A, E>()\n  return makeEffect(get, effect, initialValue, runtime, options?.uninterruptible)\n}\n\nfunction makeEffect<A, E>(\n  ctx: Context,\n  effect: Effect.Effect<A, E, Scope.Scope | AtomRegistry>,\n  initialValue: Result.Result<A, E>,\n  runtime = Runtime.defaultRuntime,\n  uninterruptible = false\n): Result.Result<A, E> {\n  const previous = ctx.self<Result.Result<A, E>>()\n\n  const scope = Effect.runSync(Scope.make())\n  ctx.addFinalizer(() => {\n    Effect.runFork(Scope.close(scope, Exit.void))\n  })\n  const contextMap = new Map(runtime.context.unsafeMap)\n  contextMap.set(Scope.Scope.key, scope)\n  contextMap.set(AtomRegistry.key, ctx.registry)\n  const scopedRuntime = Runtime.make({\n    context: EffectContext.unsafeMake(contextMap),\n    fiberRefs: runtime.fiberRefs,\n    runtimeFlags: runtime.runtimeFlags\n  })\n  let syncResult: Result.Result<A, E> | undefined\n  let isAsync = false\n  const cancel = runCallbackSync(scopedRuntime)(\n    effect,\n    function(exit) {\n      syncResult = Result.fromExitWithPrevious(exit, previous)\n      if (isAsync) {\n        ctx.setSelf(syncResult)\n      }\n    },\n    uninterruptible\n  )\n  isAsync = true\n  if (cancel !== undefined) {\n    ctx.addFinalizer(cancel)\n  }\n  if (syncResult !== undefined) {\n    return syncResult\n  } else if (previous._tag === \"Some\") {\n    return Result.waitingFrom(previous)\n  }\n  return Result.waiting(initialValue)\n}\n\n// -----------------------------------------------------------------------------\n// context\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface AtomRuntime<R, ER = never> extends Atom<Result.Result<Runtime.Runtime<R>, ER>> {\n  readonly factory: RuntimeFactory\n\n  readonly layer: Atom<Layer.Layer<R, ER>>\n\n  readonly atom: {\n    <A, E>(\n      create: (get: Context) => Effect.Effect<A, E, Scope.Scope | R | AtomRegistry | Reactivity.Reactivity>,\n      options?: {\n        readonly initialValue?: A\n      }\n    ): Atom<Result.Result<A, E | ER>>\n    <A, E>(effect: Effect.Effect<A, E, Scope.Scope | R | AtomRegistry | Reactivity.Reactivity>, options?: {\n      readonly initialValue?: A\n    }): Atom<Result.Result<A, E | ER>>\n    <A, E>(create: (get: Context) => Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>, options?: {\n      readonly initialValue?: A\n    }): Atom<Result.Result<A, E | ER>>\n    <A, E>(stream: Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>, options?: {\n      readonly initialValue?: A\n    }): Atom<Result.Result<A, E | ER>>\n  }\n\n  readonly fn: {\n    <Arg>(): {\n      <E, A>(\n        fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry | Reactivity.Reactivity | R>,\n        options?: {\n          readonly initialValue?: A | undefined\n          readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined\n          readonly concurrent?: boolean | undefined\n        }\n      ): AtomResultFn<Arg, A, E | ER>\n      <E, A>(\n        fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>,\n        options?: {\n          readonly initialValue?: A | undefined\n          readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined\n          readonly concurrent?: boolean | undefined\n        }\n      ): AtomResultFn<Arg, A, E | ER | NoSuchElementException>\n    }\n    <E, A, Arg = void>(\n      fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry | Reactivity.Reactivity | R>,\n      options?: {\n        readonly initialValue?: A | undefined\n        readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined\n        readonly concurrent?: boolean | undefined\n      }\n    ): AtomResultFn<Arg, A, E | ER>\n    <E, A, Arg = void>(\n      fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry | Reactivity.Reactivity | R>,\n      options?: {\n        readonly initialValue?: A | undefined\n        readonly reactivityKeys?: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>> | undefined\n        readonly concurrent?: boolean | undefined\n      }\n    ): AtomResultFn<Arg, A, E | ER | NoSuchElementException>\n  }\n\n  readonly pull: <A, E>(\n    create:\n      | ((get: Context) => Stream.Stream<A, E, R | AtomRegistry | Reactivity.Reactivity>)\n      | Stream.Stream<A, E, R | AtomRegistry | Reactivity.Reactivity>,\n    options?: {\n      readonly disableAccumulation?: boolean\n      readonly initialValue?: ReadonlyArray<A>\n    }\n  ) => Writable<PullResult<A, E | ER>, void>\n\n  readonly subscriptionRef: <A, E>(\n    create:\n      | Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, R | AtomRegistry | Reactivity.Reactivity>\n      | ((\n        get: Context\n      ) => Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, R | AtomRegistry | Reactivity.Reactivity>)\n  ) => Writable<Result.Result<A, E>, A>\n\n  readonly subscribable: <A, E, E1 = never>(\n    create:\n      | Effect.Effect<Subscribable.Subscribable<A, E, R>, E1, R | AtomRegistry | Reactivity.Reactivity>\n      | ((\n        get: Context\n      ) => Effect.Effect<Subscribable.Subscribable<A, E, R>, E1, R | AtomRegistry | Reactivity.Reactivity>)\n  ) => Atom<Result.Result<A, E | E1>>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface RuntimeFactory {\n  <R, E>(\n    create:\n      | Layer.Layer<R, E, AtomRegistry | Reactivity.Reactivity>\n      | ((get: Context) => Layer.Layer<R, E, AtomRegistry | Reactivity.Reactivity>)\n  ): AtomRuntime<R, E>\n  readonly memoMap: Layer.MemoMap\n  readonly addGlobalLayer: <A, E>(layer: Layer.Layer<A, E, AtomRegistry | Reactivity.Reactivity>) => void\n\n  /**\n   * Uses the `Reactivity` service from the runtime to refresh the atom whenever\n   * the keys change.\n   */\n  readonly withReactivity: (\n    keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>\n  ) => <A extends Atom<any>>(atom: A) => A\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const context: (options: {\n  readonly memoMap: Layer.MemoMap\n}) => RuntimeFactory = (options) => {\n  let globalLayer: Layer.Layer<any, any, AtomRegistry> = Reactivity.layer\n  function factory<E, R>(\n    create:\n      | Layer.Layer<R, E, AtomRegistry | Reactivity.Reactivity>\n      | ((get: Context) => Layer.Layer<R, E, AtomRegistry | Reactivity.Reactivity>)\n  ): AtomRuntime<R, E> {\n    const self = Object.create(RuntimeProto)\n    self.keepAlive = false\n    self.lazy = true\n    self.refresh = undefined\n    self.factory = factory\n\n    const layerAtom = keepAlive(\n      typeof create === \"function\"\n        ? readable((get) => Layer.provideMerge(create(get), globalLayer))\n        : readable(() => Layer.provideMerge(create, globalLayer))\n    )\n    self.layer = layerAtom\n\n    self.read = function read(get: Context) {\n      const layer = get(layerAtom)\n      const build = Effect.flatMap(\n        Effect.flatMap(Effect.scope, (scope) => Layer.buildWithMemoMap(layer, options.memoMap, scope)),\n        (context) => Effect.provide(Effect.runtime<R>(), context)\n      )\n      return effect(get, build, { uninterruptible: true })\n    }\n\n    return self\n  }\n  factory.memoMap = options.memoMap\n  factory.addGlobalLayer = (layer: Layer.Layer<any, any, AtomRegistry | Reactivity.Reactivity>) => {\n    globalLayer = Layer.provideMerge(globalLayer, Layer.provide(layer, Reactivity.layer))\n  }\n  const reactivityAtom = make(\n    Effect.scopeWith((scope) => Layer.buildWithMemoMap(Reactivity.layer, options.memoMap, scope)).pipe(\n      Effect.map(EffectContext.get(Reactivity.Reactivity))\n    )\n  )\n  factory.withReactivity =\n    (keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>) =>\n    <A extends Atom<any>>(atom: A): A =>\n      transform(atom, (get) => {\n        const reactivity = Result.getOrThrow(get(reactivityAtom))\n        get.addFinalizer(reactivity.unsafeRegister(keys, () => {\n          get.refresh(atom)\n        }))\n        get.subscribe(atom, (value) => get.setSelf(value))\n        return get.once(atom)\n      }) as any as A\n  return factory\n}\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport const defaultMemoMap: Layer.MemoMap = globalValue(\n  \"@effect-atom/atom/Atom/defaultMemoMap\",\n  () => Effect.runSync(Layer.makeMemoMap)\n)\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport const runtime: RuntimeFactory = globalValue(\n  \"@effect-atom/atom/Atom/defaultContext\",\n  () => context({ memoMap: defaultMemoMap })\n)\n\n/**\n * An alias to `Rx.runtime.withReactivity`, for refreshing an atom whenever the\n * keys change in the `Reactivity` service.\n *\n * @since 1.0.0\n * @category Reactivity\n */\nexport const withReactivity: (\n  keys: ReadonlyArray<unknown> | ReadonlyRecord<string, ReadonlyArray<unknown>>\n) => <A extends Atom<any>>(atom: A) => A = runtime.withReactivity\n\n// -----------------------------------------------------------------------------\n// constructors - stream\n// -----------------------------------------------------------------------------\n\nconst stream = <A, E>(\n  get: Context,\n  stream: Stream.Stream<A, E, AtomRegistry>,\n  options?: { readonly initialValue?: A },\n  runtime?: Runtime.Runtime<any>\n): Result.Result<A, E | NoSuchElementException> => {\n  const initialValue = options?.initialValue !== undefined\n    ? Result.success<A, E>(options.initialValue)\n    : Result.initial<A, E>()\n  return makeStream(get, stream, initialValue, runtime)\n}\n\nfunction makeStream<A, E>(\n  ctx: Context,\n  stream: Stream.Stream<A, E, AtomRegistry>,\n  initialValue: Result.Result<A, E | NoSuchElementException>,\n  runtime = Runtime.defaultRuntime\n): Result.Result<A, E | NoSuchElementException> {\n  const previous = ctx.self<Result.Result<A, E | NoSuchElementException>>()\n\n  const writer: Channel.Channel<never, Chunk.Chunk<A>, never, E> = Channel.readWithCause({\n    onInput(input: Chunk.Chunk<A>) {\n      return Channel.suspend(() => {\n        const last = Chunk.last(input)\n        if (last._tag === \"Some\") {\n          ctx.setSelf(Result.success(last.value, {\n            waiting: true\n          }))\n        }\n        return writer\n      })\n    },\n    onFailure(cause: Cause.Cause<E>) {\n      return Channel.sync(() => {\n        ctx.setSelf(Result.failureWithPrevious(cause, {\n          previous: ctx.self<Result.Result<A, E | NoSuchElementException>>()\n        }))\n      })\n    },\n    onDone(_done: unknown) {\n      return Channel.sync(() => {\n        pipe(\n          ctx.self<Result.Result<A, E | NoSuchElementException>>(),\n          Option.flatMap(Result.value),\n          Option.match({\n            onNone: () =>\n              ctx.setSelf(\n                Result.failWithPrevious(new NoSuchElementException(), {\n                  previous: ctx.self<Result.Result<A, E | NoSuchElementException>>()\n                })\n              ),\n            onSome: (a) => ctx.setSelf(Result.success(a))\n          })\n        )\n      })\n    }\n  })\n\n  const registryRuntime = Runtime.make({\n    context: EffectContext.add(runtime.context, AtomRegistry, ctx.registry),\n    fiberRefs: runtime.fiberRefs,\n    runtimeFlags: runtime.runtimeFlags\n  })\n\n  const cancel = runCallbackSync(registryRuntime)(\n    Channel.runDrain(Channel.pipeTo(Stream.toChannel(stream), writer)),\n    constVoid,\n    false\n  )\n  if (cancel !== undefined) {\n    ctx.addFinalizer(cancel)\n  }\n\n  if (previous._tag === \"Some\") {\n    return Result.waitingFrom(previous)\n  }\n  return Result.waiting(initialValue)\n}\n\n// -----------------------------------------------------------------------------\n// constructors - subscription ref\n// -----------------------------------------------------------------------------\n\n/** @internal */\nconst readSubscribable = (\n  get: Context,\n  sub:\n    | Subscribable.Subscribable<any, any>\n    | Result.Result<Subscribable.Subscribable<any, any>, any>,\n  runtime = Runtime.defaultRuntime\n) => {\n  if (Subscribable.TypeId in sub) {\n    get.addFinalizer(\n      sub.changes.pipe(\n        Stream.runForEach((value) => {\n          get.setSelf(value)\n          return Effect.void\n        }),\n        Runtime.runCallback(runtime)\n      )\n    )\n    return Runtime.runSync(runtime)(sub.get)\n  } else if (sub._tag !== \"Success\") {\n    return sub\n  }\n  return makeStream(get, sub.value.changes, Result.initial(true), runtime)\n}\n\nconst makeSubRef = (\n  refAtom: Atom<SubscriptionRef.SubscriptionRef<any> | Result.Result<SubscriptionRef.SubscriptionRef<any>, any>>,\n  read: (\n    get: Context,\n    ref: SubscriptionRef.SubscriptionRef<any> | Result.Success<SubscriptionRef.SubscriptionRef<any>, any>\n  ) => any\n) => {\n  function write(ctx: WriteContext<SubscriptionRef.SubscriptionRef<any>>, value: any) {\n    const ref = ctx.get(refAtom)\n    if (SubscriptionRef.SubscriptionRefTypeId in ref) {\n      Effect.runSync(SubscriptionRef.set(ref, value))\n    } else if (Result.isSuccess(ref)) {\n      Effect.runSync(SubscriptionRef.set(ref.value, value))\n    }\n  }\n  return writable((get) => {\n    const ref = get(refAtom)\n    if (SubscriptionRef.SubscriptionRefTypeId in ref) {\n      return read(get, ref)\n    } else if (Result.isSuccess(ref)) {\n      return read(get, ref)\n    }\n    return ref\n  }, write)\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const subscriptionRef: {\n  <A>(ref: SubscriptionRef.SubscriptionRef<A> | ((get: Context) => SubscriptionRef.SubscriptionRef<A>)): Writable<A>\n  <A, E>(\n    effect:\n      | Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, Scope.Scope | AtomRegistry>\n      | ((get: Context) => Effect.Effect<SubscriptionRef.SubscriptionRef<A>, E, Scope.Scope | AtomRegistry>)\n  ): Writable<Result.Result<A, E>, A>\n} = (\n  ref:\n    | SubscriptionRef.SubscriptionRef<any>\n    | ((get: Context) => SubscriptionRef.SubscriptionRef<any>)\n    | Effect.Effect<SubscriptionRef.SubscriptionRef<any>, any, Scope.Scope | AtomRegistry>\n    | ((get: Context) => Effect.Effect<SubscriptionRef.SubscriptionRef<any>, any, Scope.Scope | AtomRegistry>)\n) =>\n  makeSubRef(\n    readable((get) => {\n      const value = typeof ref === \"function\" ? ref(get) : ref\n      return SubscriptionRef.SubscriptionRefTypeId in value\n        ? value\n        : makeEffect(get, value, Result.initial(true))\n    }),\n    readSubscribable\n  ) as any\n\n// -----------------------------------------------------------------------------\n// constructors - subscribable\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const subscribable: {\n  <A, E>(\n    ref: Subscribable.Subscribable<A, E> | ((get: Context) => Subscribable.Subscribable<A, E>)\n  ): Atom<A>\n  <A, E, E1>(\n    effect:\n      | Effect.Effect<Subscribable.Subscribable<A, E1>, E, Scope.Scope | AtomRegistry>\n      | ((get: Context) => Effect.Effect<Subscribable.Subscribable<A, E1>, E, Scope.Scope | AtomRegistry>)\n  ): Atom<Result.Result<A, E | E1>>\n} = (\n  ref:\n    | Subscribable.Subscribable<any, any>\n    | ((get: Context) => Subscribable.Subscribable<any, any>)\n    | Effect.Effect<Subscribable.Subscribable<any, any>, any, Scope.Scope | AtomRegistry>\n    | ((get: Context) => Effect.Effect<Subscribable.Subscribable<any, any>, any, Scope.Scope | AtomRegistry>)\n) =>\n  makeSubscribable(\n    readable((get) => {\n      const value = typeof ref === \"function\" ? ref(get) : ref\n      return Subscribable.isSubscribable(value)\n        ? value\n        : makeEffect(get, value, Result.initial(true))\n    }),\n    readSubscribable\n  )\n\nconst makeSubscribable = (\n  subAtom: Atom<Subscribable.Subscribable<any, any> | Result.Result<Subscribable.Subscribable<any, any>, any>>,\n  read: (\n    get: Context,\n    sub: Subscribable.Subscribable<any, any> | Result.Success<Subscribable.Subscribable<any, any>, any>\n  ) => any\n) =>\n  readable((get) => {\n    const sub = get(subAtom)\n    if (Subscribable.isSubscribable(sub)) {\n      return read(get, sub)\n    } else if (Result.isSuccess(sub)) {\n      return read(get, sub)\n    }\n    return sub\n  })\n\n// -----------------------------------------------------------------------------\n// constructors - functions\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface FnContext {\n  <A>(atom: Atom<A>): A\n  result<A, E>(this: FnContext, atom: Atom<Result.Result<A, E>>, options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n  }): Effect.Effect<A, E>\n  addFinalizer(this: FnContext, f: () => void): void\n  mount<A>(this: FnContext, atom: Atom<A>): void\n  refresh<A>(this: FnContext, atom: Atom<A>): void\n  self<A>(this: FnContext): Option.Option<A>\n  setSelf<A>(this: FnContext, a: A): void\n  set<R, W>(this: FnContext, atom: Writable<R, W>, value: W): void\n  some<A>(this: FnContext, atom: Atom<Option.Option<A>>): Effect.Effect<A>\n  stream<A>(this: FnContext, atom: Atom<A>, options?: {\n    readonly withoutInitialValue?: boolean\n    readonly bufferSize?: number\n  }): Stream.Stream<A>\n  streamResult<A, E>(this: FnContext, atom: Atom<Result.Result<A, E>>, options?: {\n    readonly withoutInitialValue?: boolean\n    readonly bufferSize?: number\n  }): Stream.Stream<A, E>\n  subscribe<A>(this: FnContext, atom: Atom<A>, f: (_: A) => void, options?: {\n    readonly immediate?: boolean\n  }): void\n  readonly registry: Registry.Registry\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fnSync: {\n  <Arg>(): {\n    <A>(\n      f: (arg: Arg, get: FnContext) => A\n    ): Writable<Option.Option<A>, Arg>\n    <A>(\n      f: (arg: Arg, get: FnContext) => A,\n      options: { readonly initialValue: A }\n    ): Writable<A, Arg>\n  }\n  <A, Arg = void>(\n    f: (arg: Arg, get: FnContext) => A\n  ): Writable<Option.Option<A>, Arg>\n  <A, Arg = void>(\n    f: (arg: Arg, get: FnContext) => A,\n    options: { readonly initialValue: A }\n  ): Writable<A, Arg>\n} = function(...args: ReadonlyArray<any>) {\n  if (args.length === 0) {\n    return makeFnSync\n  }\n  return makeFnSync(...args as [any, any]) as any\n}\n\nconst makeFnSync = <Arg, A>(f: (arg: Arg, get: FnContext) => A, options?: {\n  readonly initialValue?: A\n}): Writable<Option.Option<A> | A, Arg> => {\n  const argAtom = state<[number, Arg]>([0, undefined as any])\n  const hasInitialValue = options?.initialValue !== undefined\n  return writable(function(get) {\n    ;(get as any).isFn = true\n    const [counter, arg] = get.get(argAtom)\n    if (counter === 0) {\n      return hasInitialValue ? options.initialValue : Option.none()\n    }\n    return hasInitialValue ? f(arg, get) : Option.some(f(arg, get))\n  }, function(ctx, arg) {\n    batch(() => {\n      ctx.set(argAtom, [ctx.get(argAtom)[0] + 1, arg as Arg])\n      ctx.refreshSelf()\n    })\n  })\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface AtomResultFn<Arg, A, E = never> extends Writable<Result.Result<A, E>, Arg | Reset | Interrupt> {}\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const Reset = Symbol.for(\"@effect-atom/atom/Atom/Reset\")\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport type Reset = typeof Reset\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const Interrupt = Symbol.for(\"@effect-atom/atom/Atom/Interrupt\")\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport type Interrupt = typeof Interrupt\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fn: {\n  <Arg>(): <E, A>(fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {\n    readonly initialValue?: A | undefined\n    readonly concurrent?: boolean | undefined\n  }) => AtomResultFn<Arg, A, E>\n  <E, A, Arg = void>(fn: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry>, options?: {\n    readonly initialValue?: A | undefined\n    readonly concurrent?: boolean | undefined\n  }): AtomResultFn<Arg, A, E>\n  <Arg>(): <E, A>(fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry>, options?: {\n    readonly initialValue?: A | undefined\n    readonly concurrent?: boolean | undefined\n  }) => AtomResultFn<Arg, A, E | NoSuchElementException>\n  <E, A, Arg = void>(fn: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry>, options?: {\n    readonly initialValue?: A | undefined\n    readonly concurrent?: boolean | undefined\n  }): AtomResultFn<Arg, A, E | NoSuchElementException>\n} = function(...args: ReadonlyArray<any>) {\n  if (args.length === 0) {\n    return makeFn\n  }\n  return makeFn(...args as [any, any]) as any\n}\n\nconst makeFn = <Arg, E, A>(\n  f: (arg: Arg, get: FnContext) => Stream.Stream<A, E, AtomRegistry> | Effect.Effect<A, E, Scope.Scope | AtomRegistry>,\n  options?: {\n    readonly initialValue?: A | undefined\n    readonly concurrent?: boolean | undefined\n  }\n): AtomResultFn<Arg, A, E | NoSuchElementException> => {\n  const [read, write] = makeResultFn(f, options)\n  return writable(read, write) as any\n}\n\nfunction makeResultFn<Arg, E, A>(\n  f: (arg: Arg, get: FnContext) => Effect.Effect<A, E, Scope.Scope | AtomRegistry> | Stream.Stream<A, E, AtomRegistry>,\n  options?: {\n    readonly initialValue?: A\n    readonly concurrent?: boolean | undefined\n  }\n) {\n  const argAtom = state<[number, Arg | Interrupt]>([0, undefined as any])\n  const initialValue = options?.initialValue !== undefined\n    ? Result.success<A, E>(options.initialValue)\n    : Result.initial<A, E>()\n  const fibersAtom = options?.concurrent\n    ? make((get) => {\n      const fibers = new Set<Fiber.RuntimeFiber<any, any>>()\n      get.addFinalizer(() => fibers.forEach((f) => f.unsafeInterruptAsFork(FiberId.none)))\n      return fibers\n    })\n    : undefined\n\n  function read(get: Context, runtime?: Runtime.Runtime<any>): Result.Result<A, E | NoSuchElementException> {\n    const fibers = fibersAtom ? get(fibersAtom) : undefined\n    ;(get as any).isFn = true\n    const [counter, arg] = get.get(argAtom)\n    if (counter === 0) {\n      return initialValue\n    } else if (arg === Interrupt) {\n      return Result.failureWithPrevious(Cause.interrupt(FiberId.none), { previous: get.self() })\n    }\n    let value = f(arg, get)\n    if (Effect.EffectTypeId in value) {\n      if (fibers) {\n        const eff = value\n        value = Effect.flatMap(Effect.runtime<any>(), (r) => {\n          const fiber = Runtime.runFork(r, eff)\n          fibers.add(fiber)\n          const arr = Array.from(fibers)\n          fiber.addObserver(() => fibers.delete(fiber))\n          return joinAll(arr)\n        })\n      }\n      return makeEffect(get, value as any, initialValue, runtime, false)\n    }\n    return makeStream(get, value, initialValue, runtime)\n  }\n  function write(ctx: WriteContext<Result.Result<A, E | NoSuchElementException>>, arg: Arg | Reset | Interrupt) {\n    batch(() => {\n      if (arg === Reset) {\n        ctx.set(argAtom, [0, undefined as any])\n      } else if (arg === Interrupt) {\n        ctx.set(argAtom, [ctx.get(argAtom)[0] + 1, Interrupt])\n      } else {\n        ctx.set(argAtom, [ctx.get(argAtom)[0] + 1, arg])\n      }\n      ctx.refreshSelf()\n    })\n  }\n  return [read, write, argAtom] as const\n}\n\nconst joinAll = <A, E>(fibers: ReadonlyArray<Fiber.RuntimeFiber<A, E>>) =>\n  Effect.async<A, E>((resume) => {\n    let i = 0\n    let cause: Cause.Cause<E> | undefined\n    let exit: Exit.Exit<A, E> | undefined\n    function onExit(exit_: Exit.Exit<A, E>, inLoop = false) {\n      if (exit_._tag === \"Failure\") {\n        cause = cause ? Cause.parallel(exit_.cause, cause) : exit_.cause\n      } else if (!cause) {\n        exit = exit_\n      }\n      i++\n      if (!inLoop) loop()\n    }\n    function loop() {\n      while (i < fibers.length) {\n        const fiber = fibers[i]\n        const exit = fiber.unsafePoll()\n        if (!exit) return fiber.addObserver(onExit)\n        onExit(exit, true)\n      }\n      resume(cause ? Exit.failCause(cause) : exit ? exit : Exit.failCause(Cause.empty))\n    }\n    loop()\n    return Effect.sync(() => {\n      if (i < fibers.length) {\n        fibers[i].removeObserver(onExit)\n      }\n    })\n  })\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type PullResult<A, E = never> = Result.Result<{\n  readonly done: boolean\n  readonly items: Arr.NonEmptyArray<A>\n}, E | Cause.NoSuchElementException>\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const pull = <A, E>(\n  create: ((get: Context) => Stream.Stream<A, E, AtomRegistry>) | Stream.Stream<A, E, AtomRegistry>,\n  options?: {\n    readonly disableAccumulation?: boolean | undefined\n  }\n): Writable<PullResult<A, E>, void> => {\n  const pullSignal = state(0)\n  const pullAtom = readable(\n    makeRead(function(get) {\n      return makeStreamPullEffect(get, pullSignal, create, options)\n    })\n  )\n  return makeStreamPull(pullSignal, pullAtom)\n}\n\nconst makeStreamPullEffect = <A, E>(\n  get: Context,\n  pullSignal: Atom<number>,\n  create: Stream.Stream<A, E, AtomRegistry> | ((get: Context) => Stream.Stream<A, E, AtomRegistry>),\n  options?: {\n    readonly disableAccumulation?: boolean\n  }\n): Effect.Effect<\n  { readonly done: boolean; readonly items: Arr.NonEmptyArray<A> },\n  E | Cause.NoSuchElementException,\n  Scope.Scope | AtomRegistry\n> =>\n  Effect.flatMap(\n    Channel.toPull(\n      Stream.toChannel(typeof create === \"function\" ? create(get) : create)\n    ),\n    (pullChunk) => {\n      const semaphore = Effect.unsafeMakeSemaphore(1)\n      const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n      const context = fiber.currentContext as EffectContext.Context<AtomRegistry | Scope.Scope>\n      let acc = Chunk.empty<A>()\n      const pull: Effect.Effect<\n        {\n          done: boolean\n          items: Arr.NonEmptyArray<A>\n        },\n        NoSuchElementException | E,\n        Registry.AtomRegistry\n      > = Effect.flatMap(\n        Effect.locally(\n          Effect.suspend(() => pullChunk),\n          FiberRef.currentContext,\n          context\n        ),\n        Either.match({\n          onLeft: (): Effect.Effect<\n            { done: boolean; items: Arr.NonEmptyArray<A> },\n            NoSuchElementException\n          > => {\n            const items = Chunk.toReadonlyArray(acc) as Array<A>\n            if (!Arr.isNonEmptyArray(items)) {\n              return Effect.fail(new Cause.NoSuchElementException(`Atom.pull: no items`))\n            }\n            return Effect.succeed({ done: true, items })\n          },\n          onRight(chunk) {\n            let items: Chunk.Chunk<A>\n            if (options?.disableAccumulation) {\n              items = chunk\n            } else {\n              items = Chunk.appendAll(acc, chunk)\n              acc = items\n            }\n            const arr = Chunk.toReadonlyArray(items) as Array<A>\n            if (!Arr.isNonEmptyArray(arr)) {\n              return pull\n            }\n            return Effect.succeed({ done: false, items: arr })\n          }\n        })\n      )\n      const pullWithSemaphore = semaphore.withPermits(1)(pull)\n\n      const runCallback = runCallbackSync(Runtime.make({\n        context,\n        fiberRefs: fiber.getFiberRefs(),\n        runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n      }))\n      const cancels = new Set<() => void>()\n      get.addFinalizer(() => {\n        for (const cancel of cancels) cancel()\n      })\n      get.once(pullSignal)\n      get.subscribe(pullSignal, () => {\n        get.setSelf(Result.waitingFrom(get.self<PullResult<A, E>>()))\n        let cancel: (() => void) | undefined\n        // eslint-disable-next-line prefer-const\n        cancel = runCallback(pullWithSemaphore, (exit) => {\n          if (cancel) cancels.delete(cancel)\n          const result = Result.fromExitWithPrevious(exit, get.self())\n          const pending = cancels.size > 0\n          get.setSelf(pending ? Result.waiting(result) : result)\n        })\n        if (cancel) cancels.add(cancel)\n      })\n\n      return pull\n    }\n  )\n\nconst makeStreamPull = <A, E>(\n  pullSignal: Writable<number>,\n  pullAtom: Atom<PullResult<A, E>>\n) =>\n  writable(pullAtom.read, function(ctx, _) {\n    ctx.set(pullSignal, ctx.get(pullSignal) + 1)\n  })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const family = typeof WeakRef === \"undefined\" || typeof FinalizationRegistry === \"undefined\" ?\n  <Arg, T extends object>(\n    f: (arg: Arg) => T\n  ): (arg: Arg) => T => {\n    const atoms = MutableHashMap.empty<Arg, T>()\n    return function(arg) {\n      const atomEntry = MutableHashMap.get(atoms, arg)\n      if (atomEntry._tag === \"Some\") {\n        return atomEntry.value\n      }\n      const newAtom = f(arg)\n      MutableHashMap.set(atoms, arg, newAtom)\n      return newAtom\n    }\n  } :\n  <Arg, T extends object>(\n    f: (arg: Arg) => T\n  ): (arg: Arg) => T => {\n    const atoms = MutableHashMap.empty<Arg, WeakRef<T>>()\n    const registry = new FinalizationRegistry<Arg>((arg) => {\n      MutableHashMap.remove(atoms, arg)\n    })\n    return function(arg) {\n      const atomEntry = MutableHashMap.get(atoms, arg).pipe(\n        Option.flatMapNullable((ref) => ref.deref())\n      )\n\n      if (atomEntry._tag === \"Some\") {\n        return atomEntry.value\n      }\n      const newAtom = f(arg)\n      MutableHashMap.set(atoms, arg, new WeakRef(newAtom))\n      registry.register(newAtom, arg)\n      return newAtom\n    }\n  }\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const withFallback: {\n  <E2, A2>(\n    fallback: Atom<Result.Result<A2, E2>>\n  ): <R extends Atom<Result.Result<any, any>>>(\n    self: R\n  ) => [R] extends [Writable<infer _, infer RW>]\n    ? Writable<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>, RW>\n    : Atom<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>>\n  <R extends Atom<Result.Result<any, any>>, A2, E2>(\n    self: R,\n    fallback: Atom<Result.Result<A2, E2>>\n  ): [R] extends [Writable<infer _, infer RW>]\n    ? Writable<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>, RW>\n    : Atom<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>>\n} = dual(2, <R extends Atom<Result.Result<any, any>>, A2, E2>(\n  self: R,\n  fallback: Atom<Result.Result<A2, E2>>\n): [R] extends [Writable<infer _, infer RW>]\n  ? Writable<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>, RW>\n  : Atom<Result.Result<Result.Result.Success<Type<R>> | A2, Result.Result.Failure<Type<R>> | E2>> =>\n{\n  function withFallback(get: Context) {\n    const result = get(self)\n    if (result._tag === \"Initial\") {\n      return Result.waiting(get(fallback))\n    }\n    return result\n  }\n  return isWritable(self)\n    ? writable(\n      withFallback,\n      self.write,\n      self.refresh ?? function(refresh) {\n        refresh(self)\n      }\n    ) as any\n    : readable(\n      withFallback,\n      self.refresh ?? function(refresh) {\n        refresh(self)\n      }\n    ) as any\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const keepAlive = <A extends Atom<any>>(self: A): A =>\n  Object.assign(Object.create(Object.getPrototypeOf(self)), {\n    ...self,\n    keepAlive: true\n  })\n\n/**\n * Reverts the `keepAlive` behavior of a reactive value, allowing it to be\n * disposed of when not in use.\n *\n * Note that Atom's have this behavior by default.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const autoDispose = <A extends Atom<any>>(self: A): A =>\n  Object.assign(Object.create(Object.getPrototypeOf(self)), {\n    ...self,\n    keepAlive: false\n  })\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setLazy: {\n  (lazy: boolean): <A extends Atom<any>>(self: A) => A\n  <A extends Atom<any>>(self: A, lazy: boolean): A\n} = dual(2, <A extends Atom<any>>(self: A, lazy: boolean) =>\n  Object.assign(Object.create(Object.getPrototypeOf(self)), {\n    ...self,\n    lazy\n  }))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const withLabel: {\n  (name: string): <A extends Atom<any>>(self: A) => A\n  <A extends Atom<any>>(self: A, name: string): A\n} = dual<\n  (name: string) => <A extends Atom<any>>(self: A) => A,\n  <A extends Atom<any>>(self: A, name: string) => A\n>(2, (self, name) =>\n  Object.assign(Object.create(Object.getPrototypeOf(self)), {\n    ...self,\n    label: [name, new Error().stack?.split(\"\\n\")[5] ?? \"\"]\n  }))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setIdleTTL: {\n  (duration: Duration.DurationInput): <A extends Atom<any>>(self: A) => A\n  <A extends Atom<any>>(self: A, duration: Duration.DurationInput): A\n} = dual<\n  (duration: Duration.DurationInput) => <A extends Atom<any>>(self: A) => A,\n  <A extends Atom<any>>(self: A, duration: Duration.DurationInput) => A\n>(2, (self, durationInput) => {\n  const duration = Duration.decode(durationInput)\n  const isFinite = Duration.isFinite(duration)\n  return Object.assign(Object.create(Object.getPrototypeOf(self)), {\n    ...self,\n    keepAlive: !isFinite,\n    idleTTL: isFinite ? Duration.toMillis(duration) : undefined\n  })\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const initialValue: {\n  <A>(initialValue: A): (self: Atom<A>) => readonly [Atom<A>, A]\n  <A>(self: Atom<A>, initialValue: A): readonly [Atom<A>, A]\n} = dual<\n  <A>(initialValue: A) => (self: Atom<A>) => readonly [Atom<A>, A],\n  <A>(self: Atom<A>, initialValue: A) => readonly [Atom<A>, A]\n>(2, (self, initialValue) => [self, initialValue])\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const transform: {\n  <R extends Atom<any>, B>(\n    f: (get: Context) => B\n  ): (self: R) => [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>\n  <R extends Atom<any>, B>(\n    self: R,\n    f: (get: Context) => B\n  ): [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>\n} = dual(\n  2,\n  (<A, B>(self: Atom<A>, f: (get: Context) => B): Atom<B> =>\n    isWritable(self)\n      ? writable(\n        f,\n        function(ctx, value) {\n          ctx.set(self, value)\n        },\n        self.refresh ?? function(refresh) {\n          refresh(self)\n        }\n      )\n      : readable(\n        f,\n        self.refresh ?? function(refresh) {\n          refresh(self)\n        }\n      )) as any\n)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const map: {\n  <R extends Atom<any>, B>(\n    f: (_: Type<R>) => B\n  ): (self: R) => [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>\n  <R extends Atom<any>, B>(\n    self: R,\n    f: (_: Type<R>) => B\n  ): [R] extends [Writable<infer _, infer RW>] ? Writable<B, RW> : Atom<B>\n} = dual(\n  2,\n  <A, B>(self: Atom<A>, f: (_: A) => B): Atom<B> => transform(self, (get) => f(get(self)))\n)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const mapResult: {\n  <R extends Atom<Result.Result<any, any>>, B>(\n    f: (_: Result.Result.Success<Type<R>>) => B\n  ): (\n    self: R\n  ) => [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<B, Result.Result.Failure<Type<R>>>, RW>\n    : Atom<Result.Result<B, Result.Result.Failure<Type<R>>>>\n  <R extends Atom<Result.Result<any, any>>, B>(\n    self: R,\n    f: (_: Result.Result.Success<Type<R>>) => B\n  ): [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<B, Result.Result.Failure<Type<R>>>, RW>\n    : Atom<Result.Result<B, Result.Result.Failure<Type<R>>>>\n} = dual(2, <R extends Atom<Result.Result<any, any>>, B>(\n  self: R,\n  f: (_: Result.Result.Success<Type<R>>) => B\n): [R] extends [Writable<infer _, infer RW>] ? Writable<Result.Result<B, Result.Result.Failure<Type<R>>>, RW>\n  : Atom<Result.Result<B, Result.Result.Failure<Type<R>>>> => map(self, Result.map(f)))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const debounce: {\n  (duration: Duration.DurationInput): <A extends Atom<any>>(self: A) => WithoutSerializable<A>\n  <A extends Atom<any>>(self: A, duration: Duration.DurationInput): WithoutSerializable<A>\n} = dual(\n  2,\n  <A>(self: Atom<A>, duration: Duration.DurationInput): Atom<A> => {\n    const millis = Duration.toMillis(duration)\n    return transform(self, function(get) {\n      let timeout: number | undefined\n      let value = get.once(self)\n      function update() {\n        timeout = undefined\n        get.setSelf(value)\n      }\n      get.addFinalizer(function() {\n        if (timeout) clearTimeout(timeout)\n      })\n      get.subscribe(self, function(val) {\n        value = val\n        if (timeout) clearTimeout(timeout)\n        timeout = setTimeout(update, millis)\n      })\n      return value\n    })\n  }\n)\n\n/**\n * @since 1.0.0\n * @category Optimistic\n */\nexport const optimistic = <A>(self: Atom<A>): Writable<A, Atom<Result.Result<A, unknown>>> => {\n  let counter = 0\n  const writeAtom = state(\n    [\n      counter,\n      undefined as any as Atom<Result.Result<A, unknown>>\n    ] as const\n  )\n  return writable(\n    (get) => {\n      let lastValue = get.once(self)\n      let needsRefresh = false\n      get.subscribe(self, (value) => {\n        lastValue = value\n        if (transitions.size > 0) {\n          return\n        }\n        needsRefresh = false\n        if (!Result.isResult(value)) {\n          return get.setSelf(value)\n        }\n        const current = Option.getOrUndefined(get.self<Result.Result<any, any>>())!\n        switch (value._tag) {\n          case \"Initial\": {\n            if (Result.isInitial(current)) {\n              get.setSelf(value)\n            }\n            return\n          }\n          case \"Success\": {\n            if (Result.isSuccess(current)) {\n              if (!value.waiting && value.timestamp >= current.timestamp) {\n                get.setSelf(value)\n              }\n            } else {\n              get.setSelf(value)\n            }\n            return\n          }\n          case \"Failure\": {\n            return get.setSelf(value)\n          }\n        }\n      })\n      const transitions = new Set<Atom<Result.Result<A, unknown>>>()\n      const cancels = new Set<() => void>()\n      get.subscribe(writeAtom, ([, atom]) => {\n        if (transitions.has(atom)) return\n        transitions.add(atom)\n        let cancel: (() => void) | undefined\n        // eslint-disable-next-line prefer-const\n        cancel = get.registry.subscribe(atom, (result) => {\n          if (Result.isSuccess(result) && result.waiting) {\n            return get.setSelf(result.value)\n          }\n          transitions.delete(atom)\n          if (cancel) {\n            cancels.delete(cancel)\n            cancel()\n          }\n          if (!needsRefresh && !Result.isFailure(result)) {\n            needsRefresh = true\n          }\n          if (transitions.size === 0) {\n            if (needsRefresh) {\n              needsRefresh = false\n              get.refresh(self)\n            } else {\n              get.setSelf(lastValue)\n            }\n          }\n        }, { immediate: true })\n        if (transitions.has(atom)) {\n          cancels.add(cancel)\n        } else {\n          cancel()\n        }\n      })\n      get.addFinalizer(() => {\n        for (const cancel of cancels) cancel()\n        transitions.clear()\n        cancels.clear()\n      })\n      return lastValue\n    },\n    (ctx, atom) => ctx.set(writeAtom, [++counter, atom]),\n    (refresh) => refresh(self)\n  )\n}\n\n/**\n * @since 1.0.0\n * @category Optimistic\n */\nexport const optimisticFn: {\n  <A, W, XA, XE, OW = void>(\n    options: {\n      readonly reducer: (current: NoInfer<A>, update: OW) => NoInfer<W>\n      readonly fn:\n        | AtomResultFn<OW, XA, XE>\n        | ((set: (result: NoInfer<W>) => void) => AtomResultFn<OW, XA, XE>)\n    }\n  ): (\n    self: Writable<A, Atom<Result.Result<W, unknown>>>\n  ) => AtomResultFn<OW, XA, XE>\n  <A, W, XA, XE, OW = void>(\n    self: Writable<A, Atom<Result.Result<W, unknown>>>,\n    options: {\n      readonly reducer: (current: NoInfer<A>, update: OW) => NoInfer<W>\n      readonly fn:\n        | AtomResultFn<OW, XA, XE>\n        | ((set: (result: NoInfer<W>) => void) => AtomResultFn<OW, XA, XE>)\n    }\n  ): AtomResultFn<OW, XA, XE>\n} = dual(2, <A, W, XA, XE, OW = void>(\n  self: Writable<A, Atom<Result.Result<W, unknown>>>,\n  options: {\n    readonly reducer: (current: NoInfer<A>, update: OW) => NoInfer<W>\n    readonly fn:\n      | AtomResultFn<OW, XA, XE>\n      | ((set: (result: NoInfer<W>) => void) => AtomResultFn<OW, XA, XE>)\n  }\n): AtomResultFn<OW, XA, XE> => {\n  const transition = state<Result.Result<W, unknown>>(Result.initial())\n  return fn((arg: OW, get) => {\n    let value = options.reducer(get(self), arg)\n    if (Result.isResult(value)) {\n      value = Result.waiting(value, { touch: true })\n    }\n    get.set(transition, Result.success(value, { waiting: true }))\n    get.set(self, transition)\n    const fn = typeof options.fn === \"function\"\n      ? autoDispose(options.fn((value) =>\n        get.set(\n          transition,\n          Result.success(Result.isResult(value) ? Result.waiting(value) : value, { waiting: true })\n        )\n      ))\n      : options.fn\n    get.set(fn, arg)\n    return Effect.async<XA, XE>((resume) => {\n      get.subscribe(fn, (result) => {\n        if (result._tag === \"Initial\" || result.waiting) return\n        get.set(transition, Result.map(result, () => value))\n        resume(Result.toExit(result) as any)\n      }, { immediate: true })\n    })\n  })\n})\n\n/**\n * @since 1.0.0\n * @category batching\n */\nexport const batch: (f: () => void) => void = internalRegistry.batch\n\n// -----------------------------------------------------------------------------\n// Focus\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category Focus\n */\nexport const windowFocusSignal: Atom<number> = readable((get) => {\n  let count = 0\n  function update() {\n    if (document.visibilityState === \"visible\") {\n      get.setSelf(++count)\n    }\n  }\n  window.addEventListener(\"visibilitychange\", update)\n  get.addFinalizer(() => {\n    window.removeEventListener(\"visibilitychange\", update)\n  })\n  return count\n})\n\n/**\n * @since 1.0.0\n * @category Focus\n */\nexport const makeRefreshOnSignal = <_>(signal: Atom<_>) => <A extends Atom<any>>(self: A): WithoutSerializable<A> =>\n  transform(self, (get) => {\n    get.once(signal)\n    get.subscribe(signal, (_) => get.refresh(self))\n    get.subscribe(self, (value) => get.setSelf(value))\n    return get.once(self)\n  }) as any\n\n/**\n * @since 1.0.0\n * @category Focus\n */\nexport const refreshOnWindowFocus: <A extends Atom<any>>(self: A) => WithoutSerializable<A> = makeRefreshOnSignal(\n  windowFocusSignal\n)\n\n// -----------------------------------------------------------------------------\n// KeyValueStore\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category KeyValueStore\n */\nexport const kvs = <A>(options: {\n  readonly runtime: AtomRuntime<KeyValueStore.KeyValueStore, any>\n  readonly key: string\n  readonly schema: Schema.Schema<A, any>\n  readonly defaultValue: LazyArg<A>\n}): Writable<A> => {\n  const setAtom = options.runtime.fn(\n    Effect.fnUntraced(function*(value: A) {\n      const store = (yield* KeyValueStore.KeyValueStore).forSchema(\n        options.schema\n      )\n      yield* store.set(options.key, value)\n    })\n  )\n  const resultAtom = options.runtime.atom(\n    Effect.flatMap(\n      KeyValueStore.KeyValueStore,\n      (store) => Effect.flatten(store.forSchema(options.schema).get(options.key))\n    )\n  )\n  return writable(\n    (get) => {\n      get.mount(setAtom)\n      return Result.getOrElse(get(resultAtom), options.defaultValue)\n    },\n    (ctx, value: A) => {\n      ctx.set(setAtom, value as any)\n      ctx.setSelf(value)\n    }\n  )\n}\n\n// -----------------------------------------------------------------------------\n// URL search params\n// -----------------------------------------------------------------------------\n\n/**\n * Create an Atom that reads and writes a URL search parameter.\n *\n * Note: If you pass a schema, it has to be synchronous and have no context.\n *\n * @since 1.0.0\n * @category URL search params\n */\nexport const searchParam = <A = never, I extends string = never>(name: string, options?: {\n  readonly schema?: Schema.Schema<A, I>\n}): Writable<[A] extends [never] ? string : Option.Option<A>> => {\n  const decode = options?.schema && Schema.decodeEither(options.schema)\n  const encode = options?.schema && Schema.encodeEither(options.schema)\n  return writable(\n    (get) => {\n      const handleUpdate = () => {\n        if (searchParamState.updating) return\n        const searchParams = new URLSearchParams(window.location.search)\n        const newValue = searchParams.get(name) || \"\"\n        if (decode) {\n          get.setSelf(Either.getRight(decode(newValue as I)))\n        } else if (newValue !== Option.getOrUndefined(get.self())) {\n          get.setSelf(newValue)\n        }\n      }\n      window.addEventListener(\"popstate\", handleUpdate)\n      window.addEventListener(\"pushstate\", handleUpdate)\n      get.addFinalizer(() => {\n        window.removeEventListener(\"popstate\", handleUpdate)\n        window.removeEventListener(\"pushstate\", handleUpdate)\n      })\n      const value = new URLSearchParams(window.location.search).get(name) || \"\"\n      return decode ? Either.getRight(decode(value as I)) : value as any\n    },\n    (ctx, value: any) => {\n      if (encode) {\n        const encoded = Option.flatMap(value, (v) => Either.getRight(encode(v as A)))\n        searchParamState.updates.set(name, Option.getOrElse(encoded, () => \"\"))\n        value = Option.zipRight(encoded, value)\n      } else {\n        searchParamState.updates.set(name, value)\n      }\n      ctx.setSelf(value)\n      if (searchParamState.timeout) {\n        clearTimeout(searchParamState.timeout)\n      }\n      searchParamState.timeout = setTimeout(updateSearchParams, 500)\n    }\n  )\n}\n\nconst searchParamState = {\n  timeout: undefined as number | undefined,\n  updates: new Map<string, string>(),\n  updating: false\n}\n\nfunction updateSearchParams() {\n  searchParamState.timeout = undefined\n  searchParamState.updating = true\n  const searchParams = new URLSearchParams(window.location.search)\n  for (const [key, value] of searchParamState.updates.entries()) {\n    if (value.length > 0) {\n      searchParams.set(key, value)\n    } else {\n      searchParams.delete(key)\n    }\n  }\n  searchParamState.updates.clear()\n  const newUrl = `${window.location.pathname}?${searchParams.toString()}`\n  window.history.pushState({}, \"\", newUrl)\n  searchParamState.updating = false\n}\n\n// -----------------------------------------------------------------------------\n// conversions\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const toStream = <A>(self: Atom<A>): Stream.Stream<A, never, AtomRegistry> =>\n  Stream.unwrap(Effect.map(AtomRegistry, Registry.toStream(self)))\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const toStreamResult = <A, E>(self: Atom<Result.Result<A, E>>): Stream.Stream<A, E, AtomRegistry> =>\n  Stream.unwrap(Effect.map(AtomRegistry, Registry.toStreamResult(self)))\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const get = <A>(self: Atom<A>): Effect.Effect<A, never, AtomRegistry> =>\n  Effect.map(AtomRegistry, (_) => _.get(self))\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const modify: {\n  <R, W, A>(\n    f: (_: R) => [returnValue: A, nextValue: W]\n  ): (self: Writable<R, W>) => Effect.Effect<A, never, AtomRegistry>\n  <R, W, A>(self: Writable<R, W>, f: (_: R) => [returnValue: A, nextValue: W]): Effect.Effect<A, never, AtomRegistry>\n} = dual(\n  2,\n  <R, W, A>(self: Writable<R, W>, f: (_: R) => [returnValue: A, nextValue: W]): Effect.Effect<A, never, AtomRegistry> =>\n    Effect.map(AtomRegistry, (_) => _.modify(self, f))\n)\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const set: {\n  <W>(value: W): <R>(self: Writable<R, W>) => Effect.Effect<void, never, AtomRegistry>\n  <R, W>(self: Writable<R, W>, value: W): Effect.Effect<void, never, AtomRegistry>\n} = dual(\n  2,\n  <R, W>(self: Writable<R, W>, value: W): Effect.Effect<void, never, AtomRegistry> =>\n    Effect.map(AtomRegistry, (_) => _.set(self, value))\n)\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const update: {\n  <R, W>(f: (_: R) => W): (self: Writable<R, W>) => Effect.Effect<void, never, AtomRegistry>\n  <R, W>(self: Writable<R, W>, f: (_: R) => W): Effect.Effect<void, never, AtomRegistry>\n} = dual(\n  2,\n  <R, W>(self: Writable<R, W>, f: (_: R) => W): Effect.Effect<void, never, AtomRegistry> =>\n    Effect.map(AtomRegistry, (_) => _.update(self, f))\n)\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const getResult = <A, E>(\n  self: Atom<Result.Result<A, E>>,\n  options?: { readonly suspendOnWaiting?: boolean | undefined }\n): Effect.Effect<A, E, AtomRegistry> => Effect.flatMap(AtomRegistry, Registry.getResult(self, options))\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const refresh = <A>(self: Atom<A>): Effect.Effect<void, never, AtomRegistry> =>\n  Effect.map(AtomRegistry, (_) => _.refresh(self))\n\n// -----------------------------------------------------------------------------\n// Serializable\n// -----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category Serializable\n */\nexport const SerializableTypeId: SerializableTypeId = \"~effect-atom/atom/Atom/Serializable\"\n\n/**\n * @since 1.0.0\n * @category Serializable\n */\nexport type SerializableTypeId = \"~effect-atom/atom/Atom/Serializable\"\n\n/**\n * @since 1.0.0\n * @category Serializable\n */\nexport interface Serializable {\n  readonly [SerializableTypeId]: {\n    readonly key: string\n    readonly encode: (value: unknown) => unknown\n    readonly decode: (value: unknown) => unknown\n  }\n}\n\n/**\n * @since 1.0.0\n * @category Serializable\n */\nexport const isSerializable = (self: Atom<any>): self is Atom<any> & Serializable => SerializableTypeId in self\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const serializable: {\n  <R extends Atom<any>, I>(options: {\n    readonly key: string\n    readonly schema: Schema.Schema<Type<R>, I>\n  }): (self: R) => R & Serializable\n  <R extends Atom<any>, I>(self: R, options: {\n    readonly key: string\n    readonly schema: Schema.Schema<Type<R>, I>\n  }): R & Serializable\n} = dual(2, <R extends Atom<any>, A, I>(self: R, options: {\n  readonly key: string\n  readonly schema: Schema.Schema<A, I>\n}): R & Serializable =>\n  Object.assign(Object.create(Object.getPrototypeOf(self)), {\n    ...self,\n    label: self.label ?? [options.key, new Error().stack?.split(\"\\n\")[5] ?? \"\"],\n    [SerializableTypeId]: {\n      key: options.key,\n      encode: Schema.encodeSync(options.schema),\n      decode: Schema.decodeSync(options.schema)\n    }\n  }))\n\n/**\n * @since 1.0.0\n * @category ServerValue\n */\nexport const ServerValueTypeId = \"~effect-atom/atom/Atom/ServerValue\" as const\n\n/**\n * Overrides the value of an Atom when read on the server.\n *\n * @since 1.0.0\n * @category ServerValue\n */\nexport const withServerValue: {\n  <A extends Atom<any>>(read: (get: <A>(atom: Atom<A>) => A) => Type<A>): (self: A) => A\n  <A extends Atom<any>>(self: A, read: (get: <A>(atom: Atom<A>) => A) => Type<A>): A\n} = dual(\n  2,\n  <A extends Atom<any>>(self: A, read: (get: <A>(atom: Atom<A>) => A) => Type<A>): A =>\n    Object.assign(Object.create(Object.getPrototypeOf(self)), {\n      ...self,\n      [ServerValueTypeId]: read\n    })\n)\n\n/**\n * Sets the Atom's server value to `Result.initial(true)`.\n *\n * @since 1.0.0\n * @category ServerValue\n */\nexport const withServerValueInitial = <A extends Atom<Result.Result<any, any>>>(self: A): A =>\n  withServerValue(self, constant(Result.initial(true)) as any)\n\n/**\n * @since 1.0.0\n * @category ServerValue\n */\nexport const getServerValue: {\n  (registry: Registry.Registry): <A>(self: Atom<A>) => A\n  <A>(self: Atom<A>, registry: Registry.Registry): A\n} = dual(\n  2,\n  <A>(self: Atom<A>, registry: Registry.Registry): A =>\n    ServerValueTypeId in self\n      ? (self as any)[ServerValueTypeId]((atom: Atom<any>) => registry.get(atom))\n      : registry.get(self)\n)\n","/**\n * @since 1.0.0\n */\n\"use client\"\n\nimport * as Atom from \"@effect-atom/atom/Atom\"\nimport type * as AtomRef from \"@effect-atom/atom/AtomRef\"\nimport * as Registry from \"@effect-atom/atom/Registry\"\nimport type * as Result from \"@effect-atom/atom/Result\"\nimport { Effect } from \"effect\"\nimport * as Cause from \"effect/Cause\"\nimport * as Exit from \"effect/Exit\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as React from \"react\"\nimport { RegistryContext } from \"./RegistryContext.js\"\n\ninterface AtomStore<A> {\n  readonly subscribe: (f: () => void) => () => void\n  readonly snapshot: () => A\n  readonly getServerSnapshot: () => A\n}\n\nconst storeRegistry = globalValue(\n  \"@effect-atom/atom-react/storeRegistry\",\n  () => new WeakMap<Registry.Registry, WeakMap<Atom.Atom<any>, AtomStore<any>>>()\n)\n\nfunction makeStore<A>(registry: Registry.Registry, atom: Atom.Atom<A>): AtomStore<A> {\n  let stores = storeRegistry.get(registry)\n  if (stores === undefined) {\n    stores = new WeakMap()\n    storeRegistry.set(registry, stores)\n  }\n  const store = stores.get(atom)\n  if (store !== undefined) {\n    return store\n  }\n  const newStore: AtomStore<A> = {\n    subscribe(f) {\n      return registry.subscribe(atom, f)\n    },\n    snapshot() {\n      return registry.get(atom)\n    },\n    getServerSnapshot() {\n      return Atom.getServerValue(atom, registry)\n    }\n  }\n  stores.set(atom, newStore)\n  return newStore\n}\n\nfunction useStore<A>(registry: Registry.Registry, atom: Atom.Atom<A>): A {\n  const store = makeStore(registry, atom)\n\n  return React.useSyncExternalStore(store.subscribe, store.snapshot, store.getServerSnapshot)\n}\n\nconst initialValuesSet = globalValue(\n  \"@effect-atom/atom-react/initialValuesSet\",\n  () => new WeakMap<Registry.Registry, WeakSet<Atom.Atom<any>>>()\n)\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomInitialValues = (initialValues: Iterable<readonly [Atom.Atom<any>, any]>): void => {\n  const registry = React.useContext(RegistryContext)\n  let set = initialValuesSet.get(registry)\n  if (set === undefined) {\n    set = new WeakSet()\n    initialValuesSet.set(registry, set)\n  }\n  for (const [atom, value] of initialValues) {\n    if (!set.has(atom)) {\n      set.add(atom)\n      ;(registry as any).ensureNode(atom).setValue(value)\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomValue: {\n  <A>(atom: Atom.Atom<A>): A\n  <A, B>(atom: Atom.Atom<A>, f: (_: A) => B): B\n} = <A>(atom: Atom.Atom<A>, f?: (_: A) => A): A => {\n  const registry = React.useContext(RegistryContext)\n  if (f) {\n    const atomB = React.useMemo(() => Atom.map(atom, f), [atom, f])\n    return useStore(registry, atomB)\n  }\n  return useStore(registry, atom)\n}\n\nfunction mountAtom<A>(registry: Registry.Registry, atom: Atom.Atom<A>): void {\n  React.useEffect(() => registry.mount(atom), [atom, registry])\n}\n\nfunction setAtom<R, W, Mode extends \"value\" | \"promise\" | \"promiseExit\" = never>(\n  registry: Registry.Registry,\n  atom: Atom.Writable<R, W>,\n  options?: {\n    readonly mode?: ([R] extends [Result.Result<any, any>] ? Mode : \"value\") | undefined\n  }\n): \"promise\" extends Mode ? (\n    (value: W) => Promise<Result.Result.Success<R>>\n  ) :\n  \"promiseExit\" extends Mode ? (\n      (value: W) => Promise<Exit.Exit<Result.Result.Success<R>, Result.Result.Failure<R>>>\n    ) :\n  ((value: W | ((value: R) => W)) => void)\n{\n  if (options?.mode === \"promise\" || options?.mode === \"promiseExit\") {\n    return React.useCallback((value: W) => {\n      registry.set(atom, value)\n      const promise = Effect.runPromiseExit(\n        Registry.getResult(registry, atom as Atom.Atom<Result.Result<any, any>>, { suspendOnWaiting: true })\n      )\n      return options!.mode === \"promise\" ? promise.then(flattenExit) : promise\n    }, [registry, atom, options.mode]) as any\n  }\n  return React.useCallback((value: W | ((value: R) => W)) => {\n    registry.set(atom, typeof value === \"function\" ? (value as any)(registry.get(atom)) : value)\n  }, [registry, atom]) as any\n}\n\nconst flattenExit = <A, E>(exit: Exit.Exit<A, E>): A => {\n  if (Exit.isSuccess(exit)) return exit.value\n  throw Cause.squash(exit.cause)\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomMount = <A>(atom: Atom.Atom<A>): void => {\n  const registry = React.useContext(RegistryContext)\n  mountAtom(registry, atom)\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomSet = <\n  R,\n  W,\n  Mode extends \"value\" | \"promise\" | \"promiseExit\" = never\n>(\n  atom: Atom.Writable<R, W>,\n  options?: {\n    readonly mode?: ([R] extends [Result.Result<any, any>] ? Mode : \"value\") | undefined\n  }\n): \"promise\" extends Mode ? (\n    (value: W) => Promise<Result.Result.Success<R>>\n  ) :\n  \"promiseExit\" extends Mode ? (\n      (value: W) => Promise<Exit.Exit<Result.Result.Success<R>, Result.Result.Failure<R>>>\n    ) :\n  ((value: W | ((value: R) => W)) => void) =>\n{\n  const registry = React.useContext(RegistryContext)\n  mountAtom(registry, atom)\n  return setAtom(registry, atom, options)\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomRefresh = <A>(atom: Atom.Atom<A>): () => void => {\n  const registry = React.useContext(RegistryContext)\n  mountAtom(registry, atom)\n  return React.useCallback(() => {\n    registry.refresh(atom)\n  }, [registry, atom])\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtom = <R, W, const Mode extends \"value\" | \"promise\" | \"promiseExit\" = never>(\n  atom: Atom.Writable<R, W>,\n  options?: {\n    readonly mode?: ([R] extends [Result.Result<any, any>] ? Mode : \"value\") | undefined\n  }\n): readonly [\n  value: R,\n  write: \"promise\" extends Mode ? (\n      (value: W) => Promise<Result.Result.Success<R>>\n    ) :\n    \"promiseExit\" extends Mode ? (\n        (value: W) => Promise<Exit.Exit<Result.Result.Success<R>, Result.Result.Failure<R>>>\n      ) :\n    ((value: W | ((value: R) => W)) => void)\n] => {\n  const registry = React.useContext(RegistryContext)\n  return [\n    useStore(registry, atom),\n    setAtom(registry, atom, options)\n  ] as const\n}\n\nconst atomPromiseMap = globalValue(\n  \"@effect-atom/atom-react/atomPromiseMap\",\n  () => ({\n    suspendOnWaiting: new Map<Atom.Atom<any>, Promise<void>>(),\n    default: new Map<Atom.Atom<any>, Promise<void>>()\n  })\n)\n\nfunction atomToPromise<A, E>(\n  registry: Registry.Registry,\n  atom: Atom.Atom<Result.Result<A, E>>,\n  suspendOnWaiting: boolean\n) {\n  const map = suspendOnWaiting ? atomPromiseMap.suspendOnWaiting : atomPromiseMap.default\n  let promise = map.get(atom)\n  if (promise !== undefined) {\n    return promise\n  }\n  promise = new Promise<void>((resolve) => {\n    const dispose = registry.subscribe(atom, (result) => {\n      if (result._tag === \"Initial\" || (suspendOnWaiting && result.waiting)) {\n        return\n      }\n      setTimeout(dispose, 1000)\n      resolve()\n      map.delete(atom)\n    })\n  })\n  map.set(atom, promise)\n  return promise\n}\n\nfunction atomResultOrSuspend<A, E>(\n  registry: Registry.Registry,\n  atom: Atom.Atom<Result.Result<A, E>>,\n  suspendOnWaiting: boolean\n) {\n  const value = useStore(registry, atom)\n  if (value._tag === \"Initial\" || (suspendOnWaiting && value.waiting)) {\n    throw atomToPromise(registry, atom, suspendOnWaiting)\n  }\n  return value\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomSuspense = <A, E, const IncludeFailure extends boolean = false>(\n  atom: Atom.Atom<Result.Result<A, E>>,\n  options?: {\n    readonly suspendOnWaiting?: boolean | undefined\n    readonly includeFailure?: IncludeFailure | undefined\n  }\n): Result.Success<A, E> | (IncludeFailure extends true ? Result.Failure<A, E> : never) => {\n  const registry = React.useContext(RegistryContext)\n  const result = atomResultOrSuspend(registry, atom, options?.suspendOnWaiting ?? false)\n  if (result._tag === \"Failure\" && !options?.includeFailure) {\n    throw Cause.squash(result.cause)\n  }\n  return result as any\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomSubscribe = <A>(\n  atom: Atom.Atom<A>,\n  f: (_: A) => void,\n  options?: { readonly immediate?: boolean }\n): void => {\n  const registry = React.useContext(RegistryContext)\n  React.useEffect(\n    () => registry.subscribe(atom, f, options),\n    [registry, atom, f, options?.immediate]\n  )\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomRef = <A>(ref: AtomRef.ReadonlyRef<A>): A => {\n  const [, setValue] = React.useState(ref.value)\n  React.useEffect(() => ref.subscribe(setValue), [ref])\n  return ref.value\n}\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomRefProp = <A, K extends keyof A>(ref: AtomRef.AtomRef<A>, prop: K): AtomRef.AtomRef<A[K]> =>\n  React.useMemo(() => ref.prop(prop), [ref, prop])\n\n/**\n * @since 1.0.0\n * @category hooks\n */\nexport const useAtomRefPropValue = <A, K extends keyof A>(ref: AtomRef.AtomRef<A>, prop: K): A[K] =>\n  useAtomRef(useAtomRefProp(ref, prop))\n","/**\n * @since 1.0.0\n */\nimport { NoSuchElementException } from \"effect/Cause\"\nimport type * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as FiberId from \"effect/FiberId\"\nimport * as Runtime from \"effect/Runtime\"\nimport { SyncScheduler } from \"effect/Scheduler\"\n\nconst fastPath = <R, E, A>(effect: Effect.Effect<A, E, R>): Exit.Exit<A, E> | undefined => {\n  const op = effect as any\n  switch (op._tag) {\n    case \"Failure\":\n    case \"Success\": {\n      return op\n    }\n    case \"Left\": {\n      return Exit.fail(op.left)\n    }\n    case \"Right\": {\n      return Exit.succeed(op.right)\n    }\n    case \"Some\": {\n      return Exit.succeed(op.value)\n    }\n    case \"None\": {\n      // @ts-expect-error\n      return Exit.fail(new NoSuchElementException())\n    }\n  }\n}\n\n/** @internal */\nexport const runCallbackSync = <R, ER = never>(runtime: Runtime.Runtime<R>) => {\n  const runFork = Runtime.runFork(runtime)\n  return <A, E>(\n    effect: Effect.Effect<A, E, R>,\n    onExit: (exit: Exit.Exit<A, E | ER>) => void,\n    uninterruptible = false\n  ): (() => void) | undefined => {\n    const op = fastPath(effect)\n    if (op) {\n      onExit(op)\n      return undefined\n    }\n    const scheduler = new SyncScheduler()\n    const fiberRuntime = runFork(effect, { scheduler })\n    scheduler.flush()\n    const result = fiberRuntime.unsafePoll()\n    if (result) {\n      onExit(result)\n      return undefined\n    }\n    fiberRuntime.addObserver(onExit)\n    function cancel() {\n      fiberRuntime.removeObserver(onExit)\n      if (!uninterruptible) {\n        fiberRuntime.unsafeInterruptAsFork(FiberId.none)\n      }\n    }\n    return cancel\n  }\n}\n","import { clientRuntimeLayer } from \"@beep/runtime-client/services/runtime/live-layer\";\nimport { Atom } from \"@effect-atom/atom-react\";\n\nexport const makeAtomRuntime = Atom.context({\n  memoMap: Atom.defaultMemoMap,\n});\n\nmakeAtomRuntime.addGlobalLayer(clientRuntimeLayer);\n","\"use client\";\nimport { useAtomMount } from \"@effect-atom/atom-react\";\nimport type React from \"react\";\nimport { WorkerClient } from \"../../worker/worker-client\";\nimport { makeAtomRuntime } from \"./make-atom-runtime\";\n\nconst kaRuntime = makeAtomRuntime(WorkerClient.Default);\n\nexport const KaServices: React.FC = () => {\n  useAtomMount(kaRuntime);\n  return null;\n};\n","\"use client\";\nimport React from \"react\";\nimport type { LiveManagedRuntime } from \"./live-layer\";\nimport { RuntimeContext } from \"./runtime-context\";\n\nexport const useRuntime = (): LiveManagedRuntime => {\n  const runtime = React.useContext(RuntimeContext);\n  if (runtime === null) throw new Error(\"useRuntime must be used within a RuntimeProvider\");\n  return runtime;\n};\n","export * from \"./beep-provider\";\nexport * from \"./services/runtime/ka-services\";\nexport * from \"./services/runtime/live-layer\";\nexport * from \"./services/runtime/use-runtime\";\n"],"names":["TypeId","Symbol","for","withRun","f","Effect","buffer","write","internal","layerManager","platformWorkerImpl","push","Inspectable","Option","Stream_","Schema","Redacted","FileSystem","Exit","FiberSet","Msgpackr","Layer","HttpClientRequest","Cookies","Rpc","Worker","makePlatform","identity","hasProperty","symbolRedactable","UrlParams","ParseResult","ExecutionStrategy","RpcSchema","Headers","Socket","Fiber","WorkerErrorTypeId","pipe","scope","args","a","constFalse","Ref","HashSet","defaultServices","Record","Cause","span","id","BigInt","Predicate","port","u","Tag","parent","_tag","value","spanId","traceparent","bodyError","globalValue","traceId","addFinalizer","Data","sync","postMessage","input","Context","reason","request","source","ErrorTypeId","requests","values","context","rpcs","annotations","isArray","i","schema","ast","AST","SchemaIdAnnotationId","StreamSchemaId","parsed","IncomingMessage","emit","BodyBase","_","Transferable","TraceContext","headers","keys","effect","join","flatMap","unsafeMake","url","prev","unsafeAddAll","internalRequest","Map","options","Error","provideService","TypeIdError","Collector","collector","map","encoded","unsafeClear","methodAndUrl","isStreamSchema","ATTR_HTTP_REQUEST_HEADER","bytes","event","parse","key","decode","out","tag","rpc","stringify","assign","PoolTypeId","GenericTag","Object","HeadersTypeId","makeProto","Runtime","set","tranferables","head","restore","core","FiberRefs","empty","getOrDefault","WorkerError","Arr","currentRedactedNames","entries","some","contextWith","orDie","makeInitialMessage","build","WorkerManager","arguments","acquire","merge","pool","iterator","schemaBodyUrlParams","error","errorSchema","concurrency","min","max","strategy","Math","targetUtilization","tap","Proto","resize","fiber","interruptFiber","method","toJSON","urlParams","urlParamsBody","hash","body","run","onMessage","protocol","shutdown","initialMessage","initialize","flatten","zipLeft","runStrategy","decodeUnknown","addEventListener","backing","transferables","unsafeRead","makeWith","success","failure","isHeaders","encodeCause","decoder","TextDecoder","WorkerManagerTypeId","del","ChunkFromSelf","parseStream","encodeUnknown","k","successSchema","nested","FiberRef","self","middleware","v","info","decodeCause","transformResponse","locally","currentTracerDisabledWhen","pred","middlewares","position","EmptyImpl","nlIndex","Tracer","timeToLiveStrategy","group","strategyCreationTTL","timeToLive","strategyUsageTTL","items","makeInternal","dual","PlatformWorker","enabled","internalBody","JSON","unsafeMakeCollector","Reference","schemaFromSelf","generateRequestId","modify","layerWorker","encode","message","succeed","payloadSchema","get","defaultValue","contentType","record","indexOf","spawn","CloseEventTypeId","handlers","decodeFailure","serviceOption","item","match","constructor","contextMap","layerSpawner","SpanNameGenerator","deferred","decodeSuccess","String","catchAll","size","cause","ResponseError","MaxBodySize","Size","pipeArguments","response","make","requestMap","mailbox","Deferred","DeferredTypeId","failCause","tapErrorCause","logWarning","retry","Schedule","spaced","annotateLogs","fail","makeSerialized","undefined","exit","data","Stream","delete","encodedSchema","zipRight","interrupt","end","discard","includes","code","as","clear","makePoolSerialized","prefix","resume","cookies","Set","acc","newRpc","raw","create","contentLength","makePoolSerializedLayer","execute","text","getRpcClientMiddleware","offerAll","post","opts","minSize","isStream","RpcSerialization","of","toLayer","payload","toLowerCase","disableTracing","onRequest","spanPrefix","findFirst","toLayerHandler","version","flags","maxSize","stream","tryPromise","gen","allocate","toString","setUrlParams","result","acquireUseRelease","fiberRuntime","endsWith","scopeExtend","streamBufferSize","decoded","obj","batches","Mailbox","test","toStream","accept","SocketErrorTypeId","length","append","setPrototypeOf","add","runSync","encodeJsonRpcMessage","available","sampled","postprocess","preprocess","encodeJsonRpcRaw","ClientProto","filterStatus","finalizer","onAcquire","withFiberRuntime","state","arrayHeaders","try","close","void","accessHandler","uint8Array","acceptJson","header","URLSearchParams","Uint8ArrayImpl","cookie","parentContext","TextEncoder","makeMailbox","currentContext","toSet","encoder","combine","internalFiberId","isSocketError","setHeader","parseSetCookie","wrappedEncode","parentFiber","prependUrl","currentHeaders","catchAllCause","isMailbox","registry","trim","controller","setAll","stringOrRedacted","utilization","effectOrStream","currentUsage","target","invalidate","onFromClient","provide","provideContext","isClean","username","password","btoa","appendUrl","ndjson","executeRelease","activeSize","is","token","runtime","appendAll","fromInput","annotate","none","invalidated","unregister","mediaType","parts","slice","frames","send","release","messages","getFiberRefs","closeReason","runtimeFlags","HttpBodyError","executeAcquire","annotateRpcs","valueEncoded","toAcquire","frame","targetSize","makeRuntimePromise","firstEqual","runtimePromise","annotateRpcsContext","internalFiberIdId","annotateContext","PrimaryKey","arrayBufferBody","setTimeout","CookieProto","abort","arrayBuffer","clone","urlInstance","baseUrl","fs","stat","path","Number","timer","open","resizeLoop","params","mapError","isSchema","right","left","unsafeMakeSemaphore","Struct","Void","timers","unsafePoll","fromReadableStream","file","type","FormDataImpl","writeScope","semaphore","take","scopeTag","suspend","unsafeInterruptAsFork","parser","equalIndex","chunk","part","appendUrlParam","formData","WeakMap","startsWith","executeEffect","Either","e","decodeJsonRpcRaw","scopedController","json","AbortController","forkIn","interruptible","loop","awaitRead","makeUrl","_id","FiberId","interruptAs","RpcGroupProto","Iterable","has","runFork","makeManager","domain","Scope","availableLatch","name","globalThis","mapRequestInput","location","origin","pathname","currentTracerEnabled","fromTaggedRequest","worker","acquireRelease","workers","onCreate","ensuring","Pool","Array","from","propagateInterruption","sendInterrupt","ids","isInternalInterruption","isInterruptedOnly","toUrl","getRight","decodeJsonRpcMessage","register","status","refCount","cases","requestId","getOrThrow","isFiberSet","fiberIdWith","fiberId","unsafeAdd","invalidatePoolItem","streamSchemas","isSocket","encoding","orElse","ATTR_HTTP_REQUEST_METHOD","clearFiber","ATTR_SERVER_ADDRESS","isClientRequest","setBody","isShuttingDown","getPoolItem","attribute","toChannelWith","toChannel","makePoolLayer","makePool","unsafeJson","exitSchemaCache","bodyUnsafeJson","poolItem","makeChannel","manager","Channel","bodyFileWeb","fileWeb","redactedHeaderNames","curr","getFiberRef","redactedHeaders","redact","serialize","jsonSchema","priority","currentTracerPropagation","setHeaders","toHeaders","uninterruptibleMask","signal","withParentSpan","matchCauseEffect","ATTR_HTTP_RESPONSE_STATUS_CODE","parseFailure","tapRequest","formDataRecord","mapEffect","parseSuccess","circular","isWrapper","WrapperTypeId","field","unsafeMap","fork","uninterruptible","onFailure","withCookiesRef","WebSocketConstructor","protocols","WebSocket","runImpl","httpOnly","isInterrupted","bodyStream","while","constInterruptedFiber","makeWebSocket","fromWebSocket","ws","secure","followRedirects","forEachSequentialDiscard","bodyFile","batch","currentWS","nextRequest","original","responses","runRaw","handler","wrap","fnUntraced","internalResponse","fiberSet","interruptors","async","releaseAll","withTracerDisabledWhen","responseRegistry","sameSite","andThen","Uint8Array","jsonrpc","schemaStruct","reclaim","broadcast","onError","removeEventListener","internalQueue","unbounded","queue","Duration","ttl","creationTimes","unsafeDone","SocketGenericError","addObserver","unwrapScoped","scoped","process","transform","fromA","now","clock","remoteAddress","unsafeCurrentTimeMillis","SocketCloseError","remaining","entry","Spawner","spawner","forever","supportsAck","PlatformWorkerTypeId","onClose","offer","toRecord","currentPort","coreEffect","succeedNone","toI","done","isEmpty","readyState","openDeferred","applyInterrupt","CookieTypeId","excess","Promise","resolve","reject","delay","timeoutFail","openTimeout","omit","onTimeout","withSpanNameGenerator","listen","jsonRpcInternalError","NodeInspectSymbol","defect","filter","disableReclaim","latch","withScope","onOpen","makeCookie","closeCodeIsError","acquireContext","client","CookiesError","scopeWith","transfers","encodedValue","fn","fieldContentRegExp","whenOpen","unhandledLogLevel","currentUnhandledErrorLogLevel","unpackr","Unpackr","dot","put","writer","buf","serviceFunctions","maxAge","constVoid","makeWebSocketChannel","filterStatusOk","unpackMultiple","error_","layerWebSocket","incomplete","subarray","lastPosition","catchTag","catchTags","supportsTransferables","packr","pack","unsafeMakeCookie","fromTransformStream","getOrThrowWith","filterOrElse","unsafeMakeLatch","currentStream","filterOrFail","orFailWith","defaultCloseCodeIsError","makeNoSerialization","reader","setCookie","readable","getReader","fromReadonlyRecord","cancel","extend","schemas","read","mapRequestInputEffect","decodeChunk","isSome","NonEmptyArray","layerNdjson","policy","retryTransient","isTransientError","or","schedule","jsonRpc","times","catch","that","TimeoutExceptionTypeId","isTransientHttpError","isHttpClientError","layerNdJsonRpc","ndJsonRpc","tapError","remove","catchIf","unsafeClose","ref","isCookies","toCookieHeader","layerMsgPack","msgPack","getWriter","isClient","maxRedirects","redirects","setUrl","URL","writers","getValue","mapInputContext","RequestId","isCloseEvent","clientId","promise","either","onSuccess","unsafeSetAll","serializeCookie","decodeDefect","str","toSeconds","trunc","logError","forkScoped","withHeaders","expires","toUTCString","locallyWith","withHeadersEffect","Protocol","partitioned","makeProtocolHttp","writeResponse","serialization","HttpBody","isJson","r","RpcClientError","dieMessage","index","runForEachChunk","Chunk","toReadonlyArray","toSetCookieHeaders","step","parseHeader","terminatorPos","strLen","pos","eqIdx","HttpClient","transformClient","val","charCodeAt","substring","tryDecodeURIComponent","socket","pinger","makePinger","constPing","clearCurrentError","decodeURIComponent","whileLoop","onPong","timeout","failureOption","retryTransientErrors","currentError","module","writePing","reset","recievedPong","ignore","await","makeProtocolWorker","workerId","RpcWorker","InitialMessage","unsafeOpen","readyLatch","layerProtocolWorker","layerProtocolSocket","makeProtocolSocket","decodeSync","Defect","Readable","Synchronized","SubscriptionRefTypeId","SubscriptionRefSymbolKey","makeSynchronized","subscriptionRefVariance","_A","getAndSet","isSubscribable","SubscriptionRefImpl","Effectable","Class","getAndUpdate","Subscribable","RefTypeId","ref_","refVariance","getAndUpdateEffect","SynchronizedRefTypeId","circular_","synchronizedVariance","pubsub","getAndUpdateSome","commit","changes","getAndUpdateSomeEffect","fromPubSub","s","concat","withPermits","modifyEffect","b","PubSub","publish","unwrap","makeSemaphore","modifySome","modifySomeEffect","setAndGet","update","updateEffect","updateAndGet","updateAndGetEffect","updateSome","updateSomeEffect","updateSomeAndGet","updateSomeAndGetEffect","updateSomeAndGetEffectSynchronized","unsafeMakeSynchronized","bigint1e9","OtelSemConv","InstrumentType","constant","internalCircular","HashMap","layerSessionStorage","KeyValueStore","layerStorage","sessionStorage","List","Otel","Config","nanosToHrTime","timestamp","layerLocalStorage","localStorage","fiberRefs","Metrics","MetricKeyType","recordToAttributes","reduce","log","fiberId_","Resource","Fetch","logLevel","sdkName","registerProducer","makeExternalSpan","unknownToAttributeValue","layerTracerProvider","processor","fetchTagKey","fetch","resource","OtelApi","RequestInit","WebTracerProvider","configToAttributes","config","then","provider","attributes","_options","evaluate","layer","spanProcessor","tracerConfig","TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS","Logger","layerLoggerProvider","logRecordProcessor","loggerProviderConfig","metricDataByName","links","ParentSpan","kind","withDefault","hrTimeNow","label","severityNumber","getOtelParent","traceApi","active","startTime","link","Resources","COUNTER","trace","deleteSpan","spanContext","isGaugeState","emptyResource","TraceFlags","SAMPLED","LoggerProvider","processors","dataPoint","ignoreLogged","timeoutOption","shutdownTimeout","CUMULATIVE","MetricState","isHistogramState","endTime","buckets","firstError","hrTime","SpanStatusCode","dataPoints","HISTOGRAM","freqKey","metricState","addEvent","EffectTracer","OtelSpan","tracer","execution","currentSpan","DataPointType","metricKey","AggregationTemporality","with","populateContext","traceFlags","quantiles","traceState","onNone","onSome","traceStateTag","quantile","replace","replaceLogger","replaceLoggerEffect","OtelSpanTypeId","countDataPoint","replaceScoped","count","TracerProvider","getTracerProvider","sumDataPoint","zip","getTracer","ATTR_SERVICE_NAME","ATTR_SERVICE_VERSION","simple","layerTracer","layerGlobalProvider","layerGlobal","sum","setTracer","provideMerge","layerGlobalTracer","descriptor","createTraceState","addMetricData","liftThrowable","SUM","setSpan","otelContext","setSpanContext","makeSpanContext","isRemote","getOrElse","extractTraceTag","traceFlagsTag","getOption","getOrUndefined","descriptorMeta","withSpanContext","unit","valueType","ValueType","INT","withMinimumLogLevel","DOUBLE","aggregationTemporality","withSpanAnnotations","loggerWithSpanAnnotations","resourceMetrics","metrics","metricData","errors","suffix","description","defaultLogger","advice","descriptorFromKey","tags","time_unit","keyType","bigint","instrumentTypeFromKey","isGaugeKey","OBSERVABLE_GAUGE","incremental","UP_DOWN_COUNTER","currentHrTime","jsonLogger","Date","floor","makeProducer","MetricProducerImpl","metricReader","readers","forEach","setMetricProducer","all","scopedDiscard","producer","logfmtLogger","stringLogger","prettyLogger","prettyLoggerDefault","structuredLogger","tracerLogger","logFmt","logFmtLogger","pretty","structured","minimumLogLevel","isLogger","debugEnabled: boolean","internalLayer","managed","runtimeEffect","rt","setFiberRefs","isManagedRuntime","currentRuntimeFlags","ManagedRuntimeProto","CommitPrototype","defaultRateLimit: LimitUrlUpdates","memoMap","unsafeMakeMemoMap","internalRuntime","buildFiber","unsafeForkEffect","toRuntimeWithMemoMap","cachedRuntime","scheduler","currentScheduler","unsafeRunPromiseEffect","dispose","disposeEffect","unsafeFork","runSyncExit","unsafeRunSyncExitEffect","unsafeRunSyncExit","runPromiseExit","unsafeRunPromiseExitEffect","unsafeRunPromiseExit","runCallback","unsafeRunCallback","defaultRuntime","runPromise","unsafeRunPromise","context: Context<AdapterContext>","resolve: (value: T | PromiseLike<T>) => void","reject: () => void","globalThrottleQueue: ThrottledQueue","debounceController: DebounceController","Equal","constImmediate","immediate","constListener","Schema_","scheduleTask","Scheduler","Result","unstable_scheduleCallback","unstable_LowPriority","RegistryImpl","initialValues","timeoutResolution","defaultIdleTTL","SerializableTypeId","atomKey","atom","RegistryContext","React","createContext","Registry","isResult","ResultProto","isRegistry","cb","queueMicrotask","RegistryProvider","round","current","waiting","ensureNode","setValue","layerOptions","AtomRegistry","clearTimeout","nodeTimeoutBucket","getNodes","Hash","symbol","tagHash","nodes","createElement","Provider","writeContext","children","setSerializable","preloadedSerializable","isWaiting","node","contextWithEffect","fromExit","subscribe","unsafeOffer","refresh","fromExitWithPrevious","failureWithPrevious","previous","invalidateAtom","waitingFrom","initial","toStreamResult","isNotInitial","_value","getResult","suspendOnWaiting","isInitial","scheduleNodeRemoval","toExit","mount","atomHasTtl","keepAlive","idleTTL","createNode","removeNodeTimeout","isSuccess","disposed","scheduleAtomRemoval","Node","isFailure","canBeRemoved","removeNode","previousSuccess","setNodeTimeout","currentSweepTTL","failWithPrevious","ceil","bucket","timeoutBuckets","touch","sweepBucket","handle","replacePrevious","NodeFlags","NodeState","NoSuchElementException","WriteContextImpl","uninitialized","lifetime","parents","previousParents","listeners","skipInvalidation","waitingForValue","makeLifetime","removeChild","valueOption","initialized","valid","onInitial","batchState","phase","BatchPhase","collect","notify","equals","matchWithError","invalidateChildren","failureOrCause","onDefect","squash","pop","onWaiting","stale","disposeLifetime","lazy","childrenAreActive","results","isIter","isIterable","successes","builder","BuilderImpl","output","when","refinement","onInitialOrWaiting","listener","onErrorIf","constTrue","onErrorTag","stack","stackIndex","len","dieOption","child","orNull","render","disposedError","LifetimeProto","declare","identifier","finalizers","success_","Never","Success","TaggedStruct","Boolean","addParent","Union","isFn","resultOnce","never","once","someOnce","isNone","refreshSelf","setSelf","Queue","bounded","bufferSize","withoutInitialValue","fromQueue","streamResult","disabled","depth","batchRebuildNode","Atom","SyncScheduler","fastPath","op","EffectContext","storeRegistry","makeStore","stores","store","MutableHashMap","newStore","snapshot","getServerSnapshot","SubscriptionRef","getServerValue","internalRegistry","runCallbackSync","useStore","useSyncExternalStore","onExit","initialValuesSet","useAtomInitialValues","flush","useContext","WeakSet","AtomProto","useAtomValue","format","atomB","useMemo","RuntimeProto","mountAtom","useEffect","arg","setAtom","mode","useCallback","runtimeResult","flattenExit","makeFnRuntime","pull","pullSignal","pullAtom","useAtomMount","makeEffect","makeStreamPullEffect","makeStreamPull","subscriptionRef","makeSubRef","useAtomSet","useAtomRefresh","subscribable","makeSubscribable","useAtom","readSubscribable","atomPromiseMap","default","atomToPromise","isEffect","Reactivity","mutation","reactivityKeys","writable","argAtom","WritableTypeId","atomResultOrSuspend","isWritable","useAtomSuspense","includeFailure","WritableProto","useAtomSubscribe","constSetSelf","ctx","useAtomRef","useState","readOrAtom","useAtomRefProp","makeRead","prop","useAtomRefPropValue","isDataType","StreamTypeId","providedRuntime","isObject","EffectTypeId","initialValue","_get","scopedRuntime","syncResult","isAsync","globalLayer","factory","layerAtom","buildWithMemoMap","addGlobalLayer","reactivityAtom","withReactivity","reactivity","unsafeRegister","defaultMemoMap","makeMemoMap","makeStream","readWithCause","onInput","last","onDone","_done","registryRuntime","runDrain","pipeTo","sub","runForEach","refAtom","subAtom","fnSync","makeFnSync","hasInitialValue","counter","Reset","Interrupt","makeFn","makeResultFn","fibersAtom","concurrent","fibers","eff","arr","joinAll","exit_","inLoop","parallel","removeObserver","toPull","pullChunk","getCurrentFiber","onLeft","isNonEmptyArray","onRight","disableAccumulation","pullWithSemaphore","cancels","pending","family","WeakRef","FinalizationRegistry","atoms","atomEntry","newAtom","flatMapNullable","deref","withFallback","fallback","getPrototypeOf","autoDispose","setLazy","withLabel","split","setIdleTTL","durationInput","duration","isFinite","toMillis","mapResult","debounce","millis","optimistic","writeAtom","lastValue","needsRefresh","transitions","optimisticFn","transition","reducer","windowFocusSignal","document","visibilityState","window","makeRefreshOnSignal","refreshOnWindowFocus","kvs","forSchema","resultAtom","searchParam","decodeEither","encodeEither","handleUpdate","searchParamState","updating","searchParams","search","newValue","updates","updateSearchParams","newUrl","history","pushState","isSerializable","serializable","encodeSync","ServerValueTypeId","withServerValue","withServerValueInitial"],"mappings":"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StB0B,CAACr6B,MAAuD,OAMjFi7B,WAAoBr3B,GTsBc,AAAF,CAAC,CAAC,CAAA,CAAA,MStBgE,sHLflGs1B,ELGE,ATQA,CcXoBC,CCOlB,AZRA,CLyBH,AGzBI,AUqBM,CZrBL,AYqBK,YGpBqC,CAAC,IAAME,EHqBrC,CAAC,CDHY,GAE3C,MAAM,CIpB2E,CAAC,IAGlDF,CGgCc,AL9BA,EAAA,YEFY,CAAC,CZoCrD,CM7BoEn5B,EMPT45B,MJiB3B,CAAC,KIjBsC,CJmBc,AInBb,CJmBc,CRiBlE,CAAC,4boGNa,CAAC,IAChC,EAAA,GAAA,EAAA,UAAA,CAAA,EAAA,qG5Db+C,KAAA,KAAU,CAAC,CCGnC,ADHyC,CDatE,AETH,ADJ0E,CCIzE,ADJ0E,CAAC,CAAC,oFAMzC,GAAA,GAAA,OAAA,gUAmDQ,0CAGM,qBAC5B,EAAA,GAAA,+C5C5DP,CCzBC,CGgBC,AFfA,ACDA,CEAC,ALyBW,CITV,AGZA,APqBU,AQfV,AFLA,AGIA,ACJA,CCDC,ACYA,CZUnB,AaToB,CCfC,AbFA,CcUC,AZVA,CaAC,AXAA,CHCC,AeMA,AXFA,ANqBlB,AOtBkB,ACMA,AJMA,AKPA,ACJA,CCDC,CACff,ANJAA,AYQAh5B,AdRAsM,AYUAsY,AFMgB,CAAC,AbUzB,AczByB,CduBC,AaH5B,ADHA,ARSA,AalBOsU,AFAqB,GdRlBE,AEAA7nB,AYUA4nB,AVVAz2B,AHYA6F,ASRAA,ONJA7F,GLyBiB,CefK,CfeI,CYNpC,SZM8C,CAAC,AaHhD,wBbI2B,CAAC,CaHK,AZtBA,CD4B1B,CYP4B,CZO5B,AiBpB6B,CLaC,AEjBS,CdwBlB,AWxBU,ATSA,CIDP,AHZQ,CkBAC,AhBAA,CSI0B,CK8BxB,CPbC,ACCA,CAAC,GPVb,gCNiBwB,CAAA,EAE/C,eAIoB,4GAYF,CAAA,CAAA,CAAA,gVAqByB,CAAC,CAAA,EAAA,EAAM,GAAA,GAAA,EACnC,CAAC,CAAC,CGnB2B,AHoB5C,CGpB6C+L,iB6BjBpD,CAAA,CAAA,CAC6B,2HAmBG,CAAA,QAAA,EAAA,EAAc,CwD1BlC,UAAA,EAAA,EAAA,CxD0BoD,CAC7D,CAAG,MAAM,AqBSe,CrBTd,AqBSe,YrBLf,IAAA,2LAwBQ,IAAI,CAAA,EAAA,CAAA,EAAa,CiFfvB,CAAC,kBjFiBsC,CAAC,oBAAoB,CAAC,qBACnC,GAAA,EAAiB,cACvC,CAAA,CAAA,EAAA,CAAA,oBAAiC,CAAC,C6FzDO,QAAA,yF7FmEb,wCACE,cAAc,CAAC,gEAEhC,uDAGE,CoDzBD,SpDyBW,CAAC,gDACO,sBAC1B,4DACkC,CwFZC,CAAA,2DxFaA,QAE/D,CAAC,AVIU,sBUCF,eAGgD,4BACpB,GAAO,CsCRL,AlE0CM,AkDtCA,ElDsCA,E4BlCe,CAAU,CAAC,EAAG,CAAA,CAC1E,CAAC,AsBJA,O9B3FG,CpBawB,AkBlCO,EpBaE,AEsBnC,CUhCoC,CK8BC,AdlCA,ASIA,qBUoB7B,EAAA,GAAA,EAA8C,mCAK7C,AADD,IAAA,cACC,MAAc,CAAA,KAAA,SAAe,CAAC,yBAElB,GACA,gBAIZ,KAAA,KAAA,CAAA,kBAAA,MAAA,CAAA,sKsBL8E,EAAa,EAAA,CAAI,CACvG,CAAC,ExBdiG,CAAC,EAGnG,CwBUmG,+CAqB7C,CACvD,CAAA,yCAI2C,EAAA,EAAA,aAAA,EAAA,EAAA,aAAA,yCAMjB,gBAAA,EAAA,EAAA,gBAAA,0BAGe,CrCLoD,CAAA,EAAA,WAAA,EAAA,EAAA,WAAA,2GqDvC3F,IAAA,EAAA,CAAA,+CACwD,EAAM,CdCG,CAAC,AcDF,0EAKf,E+BU9B,CCXoC,kBAAA,ChCCiB,yCpCIpE,EAAA,CAAA,sJAwB8B,YAC3B,IAAA,IAAA,EAAA,GAAA,IAAA,MACD,0EAEyD,CiBMhE,AyClB0D,CMqFtC,A/CnEnB,CAAA,CjBNqE,CACpE,eAUsD,CACzD,CAAqD,CACrD,CAA2C,C0Db8B,EyBkCzD,gBnFfZ,EACD,UuCPmB,OvCSoC,OAAO,CAAC,CmFsBpD,AnFrBV,EAAsB,OAAO,CAC7B,EAAqB,OAAO,CAC7B,UADqB,AAG8B,GAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,CAIxD,gBAI4B,KD7BkE,CAAC,6BCkCtF,yBAAA,6HC7CsD,CAC7D,AkEhBC,ClEgBwD,C8CtBxD,A9CuBD,CAA+C,EVkCJ,YAAP,KU5BhC,EACD,I2BlBsB,MAAyB,CAAC,CAClD,CAAC,8D3B0BqC,CAAA,CACb,CmFhCvB,CAAC,CQPc,CAAA,I3FyCX,C4FtC6D,CAAC,CAC5D,CAAC,O5FsC4D,gM8CrDqB,EAAU,ApBqBjF,CoBrBiF,CAAG,ApBsBxG,CoBrBG,CAAC,EpBqBS,EACb,AoBvBqG,UpBuB3F,GACX,MAAM,YAAY,CAAC,WoBfM,EAAA,QAAA,CAAA,gDAO1B,CAAC,APtBD,AhCWC,AcMA,ARHA,AcgBA,ArCsDM,A8E5DN,A7BdA,A/BCA,YsCcC,CAAA,8CAIqE,mGAKoB,EAAW,C7CiC/D,CAAA,C6CjCmE,CACvG,CAAC,8CAQsB,EAAA,YAAA,CAA8B,CACrD,CAAC,gKnBzCsC,KrCgCgE,GAAA,CAAA,kDqCtBtG,CQRsD,A7BQA,AWLE,gCUUP,2DAUzB,a3BiBF,2H2BNmD,C3CekB,CAAC7F,0BAAAA,CAAAA,8H2CAnB,C8BlBX,2BAAA,C9BkByC,CACtG,CAAC,iHAc8C,CXEO,CWFH,Q6CEb,4CAAA,E7CFoE,EAAG,CAAA,CAAG,CAChH,CAAC,WmCD4G,sFnCezE,EACzC,CAAC,SAEQ,GAAA,CAAA,MACD,EAAA,GAAA,CAAA,mBAAA,EACkB,C6D9B2B,AzEmBE,CYWb,A6D9BY,AzEmBE,SYWd,CAAW,ClDkCxC,AkDjCV,AUZS,C5D8CP,AkDlCD,AUXG,CAAC,A5D6CF,kBkDjCsB,oBAa1B,CAAwB,C2DDW,A3DEnC,C2DFoC,A3DEV,CjB8Gb,OiB5GN,IACF,GAAA,EAAuD,gCAKhC,uBlDvFU,YQlBa,GYFC,CrBrBK,GSuB9C,ERkBE,AQlBK,APvBH,ALyBF,CsBxBG,AjBDK,CYOJ,cLgBiB,CUtBG,ALMA,GbkCC,MQjBtB,CVTK,ASXA,eCoBW,CPvBK,AOuBJ,AEnB8B,AIiB9B,MNKpB,EAAA,gBAAA,QACF,QAAA,SAAA,MACE,CPtBK,ADuCJ,SQjBU,ETtBa,CAAA,QAAA,CSsBK,GAAG,CRiBC,ADvCU,AqBmBV,AZGK,CAAA,CAAE,CTtBW,ASsBV,oCAmBtD,CAAA,CAAA,CAC0B,CAAA,C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CAAU,CAAA,EAAG,CAAC,oBAAoB,qBAE/C,CAAC,CAAC,CAAA,CAAA,oBAAsB,CAAC,IM5CuB,CAAC,IN4Cf,OAGpC,IAAI,CfyBG,MevB1B,EAAA,GAAmC,GACnC,EAAmC,UAC7B,aACE,CoBqBD,sBpBpB2B,QAGhC,CAAA,WACkB,EAAE,CAAC,AiBFE,GlCxCK,IiB6C/B,CACT,CAAC,EM5CE,KPxIC,CNNgC,AMOlC,CjBvBmC,CWgBC,CKRC,IdRI,CSgBC,EVLE,AEQ/B,EFRiCjB,AiBsBA,CAAC,AfRhD,IcFmB,AAAC,CftBG,CcQe,AhBRd,AGwBlB,CSJY,AKEqB,AHbgB,CGcpD,CHbwB,AGYc,ALDxC,AAEO,ADDA,ARaS,Ecb0B,CAClC,ChBboD,AcT9B,AhBwBJ,AICH,CHzBT,AqBAA,AJsBI,CDdH,Ab0BiB,AgBEjC,ACpCwB,AlBAA,AEAA,CMIP,ATSA,AaHQ,ADNA,ADkBA,CVtBP,AkBAA,AhBAA,AasBiC,APpBc,ANJA,CUY9C,AFYQ,CDRwC,AMQX,AAAxC,CAAsC,ANRc,AXd/C,AqBAA,CpBSgD,AeD/C,Ab0BS,CQbgC,CAAC,KMEnD,CIrBO,CrBAC,CEAC,ADaA,CGdC,AasBN,EdAiB,CAAC,YcIhC,CJhBO,CZFuF,KgBiBxF,AACC,EjBpBM,ADwBF,EkBLS,ChBPK,agBQV,CfpBK,ADaA,AePA,AZPA,KaqBC,CAAC,KAAK,CJhBO,ACaa,QGGX,CAAC,CjBjB/B,IiBmBR,CJhB2B,mBIgBN,AAAC,gBAEX,CAAA,iBAEW,uF4DE2B,YAAa,ErDZ8C,CAAC,oH4BsDxG,gBEnDL,CAAA,CAAA,CAAA,gCAKc,CAAA,GAAA,GAAyB,MAAA,IAAW,C9BRK,AHSjC,CWC8B,AFLE,CAAC,AwBGF,AtBEA,0mBkGgCf,E/BNE,AtDcI,WqFRO,mLAIf,CnBnBG,AGAA,CAAC,ACaF,AJbE,ClFCC,AuEQE,UAAA,uF8BsBhC,aAAA,CAAA,QAAA,sFAOqB,2FAMD,wEAK8B,2GAenD,EAAA,KAAA,IAAA,CAAA,IAAA,CACC,CnBvB4B,CAAC,AvBuBA,iBAAA,CAAA,MAAA,CAAA,IAAA,C0CAK,mBAAmB,CA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","ignoreList":[0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239]}