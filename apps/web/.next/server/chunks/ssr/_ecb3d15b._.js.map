{"version":3,"sources":["turbopack:///[project]/node_modules/effect/src/Metric.ts","turbopack:///[project]/node_modules/picocolors/picocolors.js","turbopack:///[project]/node_modules/@effect/platform/src/HttpApiSchema.ts","turbopack:///[project]/packages/common/errors/src/shared.ts","turbopack:///[project]/packages/common/errors/src/errors.ts"],"sourcesContent":["/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as internal from \"./internal/metric.js\"\nimport type * as MetricBoundaries from \"./MetricBoundaries.js\"\nimport type * as MetricKey from \"./MetricKey.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as MetricLabel from \"./MetricLabel.js\"\nimport type * as MetricPair from \"./MetricPair.js\"\nimport type * as MetricRegistry from \"./MetricRegistry.js\"\nimport type * as MetricState from \"./MetricState.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricTypeId: unique symbol = internal.MetricTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricTypeId = typeof MetricTypeId\n\n/**\n * A `Metric<Type, In, Out>` represents a concurrent metric which accepts\n * updates of type `In` and are aggregated to a stateful value of type `Out`.\n *\n * For example, a counter metric would have type `Metric<number, number>`,\n * representing the fact that the metric can be updated with numbers (the amount\n * to increment or decrement the counter by), and the state of the counter is a\n * number.\n *\n * There are five primitive metric types supported by Effect:\n *\n *   - Counters\n *   - Frequencies\n *   - Gauges\n *   - Histograms\n *   - Summaries\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {\n  /**\n   * The type of the underlying primitive metric. For example, this could be\n   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.\n   */\n  readonly keyType: Type\n  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out\n  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  register(): this\n  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MetricApply {\n  <Type, In, Out>(\n    keyType: Type,\n    unsafeUpdate: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void,\n    unsafeValue: (extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => Out,\n    unsafeModify: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void\n  ): Metric<Type, In, Out>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Metric {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Counter<In extends number | bigint>\n    extends Metric<MetricKeyType.MetricKeyType.Counter<In>, In, MetricState.MetricState.Counter<In>>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Gauge<In extends number | bigint>\n    extends Metric<MetricKeyType.MetricKeyType.Gauge<In>, In, MetricState.MetricState.Gauge<In>>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Frequency<In>\n    extends Metric<MetricKeyType.MetricKeyType.Frequency, In, MetricState.MetricState.Frequency>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Histogram<In>\n    extends Metric<MetricKeyType.MetricKeyType.Histogram, In, MetricState.MetricState.Histogram>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Summary<In>\n    extends Metric<MetricKeyType.MetricKeyType.Summary, In, MetricState.MetricState.Summary>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out Type, in In, out Out> {\n    readonly [MetricTypeId]: {\n      readonly _Type: Types.Invariant<Type>\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category globals\n */\nexport const globalMetricRegistry: MetricRegistry.MetricRegistry = internal.globalMetricRegistry\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: MetricApply = internal.make\n\n/**\n * Returns a new metric that is powered by this one, but which accepts updates\n * of the specified new type, which must be transformable to the input type of\n * this metric.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInput: {\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of the specified new type, which must be transformable to the input type of\n   * this metric.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of the specified new type, which must be transformable to the input type of\n   * this metric.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>\n} = internal.mapInput\n\n/**\n * Represents a Counter metric that tracks cumulative numerical values over time.\n * Counters can be incremented and decremented and provide a running total of changes.\n *\n * **Options**\n *\n * - description - A description of the counter.\n * - bigint - Indicates if the counter uses 'bigint' data type.\n * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const numberCounter = Metric.counter(\"count\", {\n *   description: \"A number counter\"\n * });\n *\n * const bigintCounter = Metric.counter(\"count\", {\n *   description: \"A bigint counter\",\n *   bigint: true\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: {\n  /**\n   * Represents a Counter metric that tracks cumulative numerical values over time.\n   * Counters can be incremented and decremented and provide a running total of changes.\n   *\n   * **Options**\n   *\n   * - description - A description of the counter.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberCounter = Metric.counter(\"count\", {\n   *   description: \"A number counter\"\n   * });\n   *\n   * const bigintCounter = Metric.counter(\"count\", {\n   *   description: \"A bigint counter\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options?: {\n      readonly description?: string | undefined\n      readonly bigint?: false | undefined\n      readonly incremental?: boolean | undefined\n    }\n  ): Metric.Counter<number>\n  /**\n   * Represents a Counter metric that tracks cumulative numerical values over time.\n   * Counters can be incremented and decremented and provide a running total of changes.\n   *\n   * **Options**\n   *\n   * - description - A description of the counter.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberCounter = Metric.counter(\"count\", {\n   *   description: \"A number counter\"\n   * });\n   *\n   * const bigintCounter = Metric.counter(\"count\", {\n   *   description: \"A bigint counter\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options: {\n      readonly description?: string | undefined\n      readonly bigint: true\n      readonly incremental?: boolean | undefined\n    }\n  ): Metric.Counter<bigint>\n} = internal.counter\n\n/**\n * Creates a Frequency metric to count occurrences of events.\n * Frequency metrics are used to count the number of times specific events or incidents occur.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const errorFrequency = Metric.frequency(\"error_frequency\", {\n *    description: \"Counts the occurrences of errors.\"\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (\n  name: string,\n  options?:\n    | { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined }\n    | undefined\n) => Metric.Frequency<string> = internal.frequency\n\n/**\n * Returns a new metric that is powered by this one, but which accepts updates\n * of any type, and translates them to updates with the specified constant\n * update value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const withConstantInput: {\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of any type, and translates them to updates with the specified constant\n   * update value.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of any type, and translates them to updates with the specified constant\n   * update value.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>\n} = internal.withConstantInput\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const fromMetricKey: <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  key: MetricKey.MetricKey<Type>\n) => Metric<Type, MetricKeyType.MetricKeyType.InType<Type>, MetricKeyType.MetricKeyType.OutType<Type>> =\n  internal.fromMetricKey\n\n/**\n * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n *\n * **Options**\n *\n * - description - A description of the gauge metric.\n * - bigint - Indicates if the counter uses 'bigint' data type.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const numberGauge = Metric.gauge(\"memory_usage\", {\n *   description: \"A gauge for memory usage\"\n * });\n *\n * const bigintGauge = Metric.gauge(\"cpu_load\", {\n *   description: \"A gauge for CPU load\",\n *   bigint: true\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: {\n  /**\n   * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n   * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n   *\n   * **Options**\n   *\n   * - description - A description of the gauge metric.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberGauge = Metric.gauge(\"memory_usage\", {\n   *   description: \"A gauge for memory usage\"\n   * });\n   *\n   * const bigintGauge = Metric.gauge(\"cpu_load\", {\n   *   description: \"A gauge for CPU load\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options?: {\n      readonly description?: string | undefined\n      readonly bigint?: false | undefined\n    }\n  ): Metric.Gauge<number>\n  /**\n   * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n   * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n   *\n   * **Options**\n   *\n   * - description - A description of the gauge metric.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberGauge = Metric.gauge(\"memory_usage\", {\n   *   description: \"A gauge for memory usage\"\n   * });\n   *\n   * const bigintGauge = Metric.gauge(\"cpu_load\", {\n   *   description: \"A gauge for CPU load\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options: {\n      readonly description?: string | undefined\n      readonly bigint: true\n    }\n  ): Metric.Gauge<bigint>\n} = internal.gauge\n\n/**\n * Represents a Histogram metric that records observations in specified value boundaries.\n * Histogram metrics are useful for measuring the distribution of values within a range.\n *\n * @example\n * ```ts\n * import { Metric, MetricBoundaries } from \"effect\"\n *\n * const latencyHistogram = Metric.histogram(\"latency_histogram\",\n *   MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n *   \"Measures the distribution of request latency.\"\n * );\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (\n  name: string,\n  boundaries: MetricBoundaries.MetricBoundaries,\n  description?: string\n) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram> = internal.histogram\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const increment: (\n  self: Metric.Counter<number> | Metric.Counter<bigint> | Metric.Gauge<number> | Metric.Gauge<bigint>\n) => Effect.Effect<void> = internal.increment\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const incrementBy: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (amount: number): (self: Metric.Counter<number> | Metric.Counter<number>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (amount: bigint): (self: Metric.Counter<bigint> | Metric.Gauge<bigint>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (self: Metric.Counter<number> | Metric.Gauge<number>, amount: number): Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (self: Metric.Counter<bigint> | Metric.Gauge<bigint>, amount: bigint): Effect.Effect<void>\n} = internal.incrementBy\n\n/**\n * Returns a new metric that is powered by this one, but which outputs a new\n * state type, determined by transforming the state type of this metric by the\n * specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Returns a new metric that is powered by this one, but which outputs a new\n   * state type, determined by transforming the state type of this metric by the\n   * specified function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>\n  /**\n   * Returns a new metric that is powered by this one, but which outputs a new\n   * state type, determined by transforming the state type of this metric by the\n   * specified function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>\n} = internal.map\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapType: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, Type2>(f: (type: Type) => Type2): <In, Out>(self: Metric<Type, In, Out>) => Metric<Type2, In, Out>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, In, Out, Type2>(self: Metric<Type, In, Out>, f: (type: Type) => Type2): Metric<Type2, In, Out>\n} = internal.mapType\n\n/**\n * Modifies the metric with the specified update message. For example, if the\n * metric were a gauge, the update would increment the method by the provided\n * amount.\n *\n * @since 3.6.5\n * @category utils\n */\nexport const modify: {\n  /**\n   * Modifies the metric with the specified update message. For example, if the\n   * metric were a gauge, the update would increment the method by the provided\n   * amount.\n   *\n   * @since 3.6.5\n   * @category utils\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>\n  /**\n   * Modifies the metric with the specified update message. For example, if the\n   * metric were a gauge, the update would increment the method by the provided\n   * amount.\n   *\n   * @since 3.6.5\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category aspects\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (value: number): (self: Metric.Gauge<number>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (value: bigint): (self: Metric.Gauge<bigint>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (self: Metric.Gauge<number>, value: number): Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (self: Metric.Gauge<bigint>, value: bigint): Effect.Effect<void>\n} = internal.set\n\n/**\n * Captures a snapshot of all metrics recorded by the application.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>> = internal.snapshot\n\n/**\n * Creates a metric that ignores input and produces constant output.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <Out>(out: Out) => Metric<void, unknown, Out> = internal.succeed\n\n/**\n * Creates a metric that ignores input and produces constant output.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out> = internal.sync\n\n/**\n * Creates a Summary metric that records observations and calculates quantiles.\n * Summary metrics provide statistical information about a set of values, including quantiles.\n *\n * **Options**\n *\n * - name - The name of the Summary metric.\n * - maxAge - The maximum age of observations to retain.\n * - maxSize - The maximum number of observations to keep.\n * - error - The error percentage when calculating quantiles.\n * - quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).\n * - description - An optional description of the Summary metric.\n *\n * @example\n * ```ts\n * import { Metric, Chunk } from \"effect\"\n *\n * const responseTimesSummary = Metric.summary({\n *   name: \"response_times_summary\",\n *   maxAge: \"60 seconds\", // Retain observations for 60 seconds.\n *   maxSize: 1000, // Keep a maximum of 1000 observations.\n *   error: 0.01, // Allow a 1% error when calculating quantiles.\n *   quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n *   description: \"Measures the distribution of response times.\"\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n) => Metric.Summary<number> = internal.summary\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summaryTimestamp: (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n) => Metric.Summary<readonly [value: number, timestamp: number]> // readonly because contravariant\n = internal.summaryTimestamp\n\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * the specified tags have been added to the tags of this metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const tagged: {\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>\n} = internal.tagged\n\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * dynamic tags are added based on the update values. Note that the metric\n * returned by this method does not return any useful information, due to the\n * dynamic nature of the added tags.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const taggedWithLabelsInput: {\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * dynamic tags are added based on the update values. Note that the metric\n   * returned by this method does not return any useful information, due to the\n   * dynamic nature of the added tags.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * dynamic tags are added based on the update values. Note that the metric\n   * returned by this method does not return any useful information, due to the\n   * dynamic nature of the added tags.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(\n    self: Metric<Type, In, Out>,\n    f: (input: In) => Iterable<MetricLabel.MetricLabel>\n  ): Metric<Type, In, void>\n} = internal.taggedWithLabelsInput\n\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * the specified tags have been added to the tags of this metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const taggedWithLabels: {\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>\n} = internal.taggedWithLabels\n\n/**\n * Creates a timer metric, based on a histogram, which keeps track of\n * durations in milliseconds. The unit of time will automatically be added to\n * the metric as a tag (i.e. `\"time_unit: milliseconds\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const timer: (\n  name: string,\n  description?: string\n) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram> =\n  internal.timer\n\n/**\n * Creates a timer metric, based on a histogram created from the provided\n * boundaries, which keeps track of durations in milliseconds. The unit of time\n * will automatically be added to the metric as a tag (i.e.\n * `\"time_unit: milliseconds\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const timerWithBoundaries: (\n  name: string,\n  boundaries: ReadonlyArray<number>,\n  description?: string\n) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram> =\n  internal.timerWithBoundaries\n\n/**\n * Returns an aspect that will update this metric with the specified constant\n * value every time the aspect is applied to an effect, regardless of whether\n * that effect fails or succeeds.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackAll: {\n  /**\n   * Returns an aspect that will update this metric with the specified constant\n   * value every time the aspect is applied to an effect, regardless of whether\n   * that effect fails or succeeds.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the specified constant\n   * value every time the aspect is applied to an effect, regardless of whether\n   * that effect fails or succeeds.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n} = internal.trackAll\n\n/**\n * Returns an aspect that will update this metric with the defects of the\n * effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDefect: {\n  /**\n   * Returns an aspect that will update this metric with the defects of the\n   * effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the defects of the\n   * effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>\n} = internal.trackDefect\n\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the defect throwables of the effects that the\n * aspect is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDefectWith: {\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the defect throwables of the effects that the\n   * aspect is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the defect throwables of the effects that the\n   * aspect is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (defect: unknown) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackDefectWith\n\n/**\n * Returns an aspect that will update this metric with the duration that the\n * effect takes to execute. To call this method, the input type of the metric\n * must be `Duration`.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDuration: {\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, the input type of the metric\n   * must be `Duration`.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, the input type of the metric\n   * must be `Duration`.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>\n} = internal.trackDuration\n\n/**\n * Returns an aspect that will update this metric with the duration that the\n * effect takes to execute. To call this method, you must supply a function\n * that can convert the `Duration` to the input type of this metric.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDurationWith: {\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, you must supply a function\n   * that can convert the `Duration` to the input type of this metric.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, you must supply a function\n   * that can convert the `Duration` to the input type of this metric.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (duration: Duration.Duration) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackDurationWith\n\n/**\n * Returns an aspect that will update this metric with the failure value of\n * the effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackError: {\n  /**\n   * Returns an aspect that will update this metric with the failure value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the failure value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>\n} = internal.trackError\n\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the error value of the effects that the aspect is\n * applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackErrorWith: {\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the error value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the error value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E extends In2, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (error: In2) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackErrorWith\n\n/**\n * Returns an aspect that will update this metric with the success value of\n * the effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackSuccess: {\n  /**\n   * Returns an aspect that will update this metric with the success value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the success value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A extends In, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>\n} = internal.trackSuccess\n\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the success value of the effects that the aspect is\n * applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackSuccessWith: {\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the success value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out, A>(metric: Metric<Type, In, Out>, f: (value: Types.NoInfer<A>) => In): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the success value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (value: Types.NoInfer<A>) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackSuccessWith\n\n/**\n * Updates the metric with the specified update message. For example, if the\n * metric were a counter, the update would increment the method by the\n * provided amount.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * Updates the metric with the specified update message. For example, if the\n   * metric were a counter, the update would increment the method by the\n   * provided amount.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>\n  /**\n   * Updates the metric with the specified update message. For example, if the\n   * metric were a counter, the update would increment the method by the\n   * provided amount.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>\n} = internal.update\n\n/**\n * Retrieves a snapshot of the value of the metric at this moment in time.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out> = internal.value\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const withNow: <Type, In, Out>(self: Metric<Type, readonly [In, number], Out>) => Metric<Type, In, Out> =\n  internal.withNow\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Type2, In2, Out2>(that: Metric<Type2, In2, Out2>): <Type, In, Out>(\n    self: Metric<Type, In, Out>\n  ) => Metric<\n    readonly [Type, Type2], // readonly because invariant\n    readonly [In, In2], // readonly because contravariant\n    [Out, Out2]\n  >\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Type, In, Out, Type2, In2, Out2>(self: Metric<Type, In, Out>, that: Metric<Type2, In2, Out2>): Metric<\n    readonly [Type, Type2], // readonly because invariant\n    readonly [In, In2], // readonly because contravariant\n    [Out, Out2]\n  >\n} = internal.zip\n\n/**\n * Unsafely captures a snapshot of all metrics recorded by the application.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped> = internal.unsafeSnapshot\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberStarted: Metric.Counter<number> = fiberRuntime.fiberStarted\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberSuccesses: Metric.Counter<number> = fiberRuntime.fiberSuccesses\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberFailures: Metric.Counter<number> = fiberRuntime.fiberFailures\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberLifetimes: Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram> =\n  fiberRuntime.fiberLifetimes\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberActive: Metric.Counter<number> = fiberRuntime.fiberActive\n","let p = process || {}, argv = p.argv || [], env = p.env || {}\nlet isColorSupported =\n\t!(!!env.NO_COLOR || argv.includes(\"--no-color\")) &&\n\t(!!env.FORCE_COLOR || argv.includes(\"--color\") || p.platform === \"win32\" || ((p.stdout || {}).isTTY && env.TERM !== \"dumb\") || !!env.CI)\n\nlet formatter = (open, close, replace = open) =>\n\tinput => {\n\t\tlet string = \"\" + input, index = string.indexOf(close, open.length)\n\t\treturn ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close\n\t}\n\nlet replaceClose = (string, close, replace, index) => {\n\tlet result = \"\", cursor = 0\n\tdo {\n\t\tresult += string.substring(cursor, index) + replace\n\t\tcursor = index + close.length\n\t\tindex = string.indexOf(close, cursor)\n\t} while (~index)\n\treturn result + string.substring(cursor)\n}\n\nlet createColors = (enabled = isColorSupported) => {\n\tlet f = enabled ? formatter : () => String\n\treturn {\n\t\tisColorSupported: enabled,\n\t\treset: f(\"\\x1b[0m\", \"\\x1b[0m\"),\n\t\tbold: f(\"\\x1b[1m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[1m\"),\n\t\tdim: f(\"\\x1b[2m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[2m\"),\n\t\titalic: f(\"\\x1b[3m\", \"\\x1b[23m\"),\n\t\tunderline: f(\"\\x1b[4m\", \"\\x1b[24m\"),\n\t\tinverse: f(\"\\x1b[7m\", \"\\x1b[27m\"),\n\t\thidden: f(\"\\x1b[8m\", \"\\x1b[28m\"),\n\t\tstrikethrough: f(\"\\x1b[9m\", \"\\x1b[29m\"),\n\n\t\tblack: f(\"\\x1b[30m\", \"\\x1b[39m\"),\n\t\tred: f(\"\\x1b[31m\", \"\\x1b[39m\"),\n\t\tgreen: f(\"\\x1b[32m\", \"\\x1b[39m\"),\n\t\tyellow: f(\"\\x1b[33m\", \"\\x1b[39m\"),\n\t\tblue: f(\"\\x1b[34m\", \"\\x1b[39m\"),\n\t\tmagenta: f(\"\\x1b[35m\", \"\\x1b[39m\"),\n\t\tcyan: f(\"\\x1b[36m\", \"\\x1b[39m\"),\n\t\twhite: f(\"\\x1b[37m\", \"\\x1b[39m\"),\n\t\tgray: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n\n\t\tbgBlack: f(\"\\x1b[40m\", \"\\x1b[49m\"),\n\t\tbgRed: f(\"\\x1b[41m\", \"\\x1b[49m\"),\n\t\tbgGreen: f(\"\\x1b[42m\", \"\\x1b[49m\"),\n\t\tbgYellow: f(\"\\x1b[43m\", \"\\x1b[49m\"),\n\t\tbgBlue: f(\"\\x1b[44m\", \"\\x1b[49m\"),\n\t\tbgMagenta: f(\"\\x1b[45m\", \"\\x1b[49m\"),\n\t\tbgCyan: f(\"\\x1b[46m\", \"\\x1b[49m\"),\n\t\tbgWhite: f(\"\\x1b[47m\", \"\\x1b[49m\"),\n\n\t\tblackBright: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n\t\tredBright: f(\"\\x1b[91m\", \"\\x1b[39m\"),\n\t\tgreenBright: f(\"\\x1b[92m\", \"\\x1b[39m\"),\n\t\tyellowBright: f(\"\\x1b[93m\", \"\\x1b[39m\"),\n\t\tblueBright: f(\"\\x1b[94m\", \"\\x1b[39m\"),\n\t\tmagentaBright: f(\"\\x1b[95m\", \"\\x1b[39m\"),\n\t\tcyanBright: f(\"\\x1b[96m\", \"\\x1b[39m\"),\n\t\twhiteBright: f(\"\\x1b[97m\", \"\\x1b[39m\"),\n\n\t\tbgBlackBright: f(\"\\x1b[100m\", \"\\x1b[49m\"),\n\t\tbgRedBright: f(\"\\x1b[101m\", \"\\x1b[49m\"),\n\t\tbgGreenBright: f(\"\\x1b[102m\", \"\\x1b[49m\"),\n\t\tbgYellowBright: f(\"\\x1b[103m\", \"\\x1b[49m\"),\n\t\tbgBlueBright: f(\"\\x1b[104m\", \"\\x1b[49m\"),\n\t\tbgMagentaBright: f(\"\\x1b[105m\", \"\\x1b[49m\"),\n\t\tbgCyanBright: f(\"\\x1b[106m\", \"\\x1b[49m\"),\n\t\tbgWhiteBright: f(\"\\x1b[107m\", \"\\x1b[49m\"),\n\t}\n}\n\nmodule.exports = createColors()\nmodule.exports.createColors = createColors\n","/**\n * @since 1.0.0\n */\nimport type { Brand } from \"effect/Brand\"\nimport * as Effect from \"effect/Effect\"\nimport * as Effectable from \"effect/Effectable\"\nimport type { LazyArg } from \"effect/Function\"\nimport { constant, constVoid, dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Option from \"effect/Option\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport * as AST from \"effect/SchemaAST\"\nimport * as Struct from \"effect/Struct\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Multipart_ from \"./Multipart.js\"\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationMultipart: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationMultipart\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationMultipartStream: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationMultipartStream\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationStatus: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationStatus\")\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationEmptyDecodeable: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationEmptyDecodeable\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationEncoding: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationEncoding\")\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationParam: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationParam\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const extractAnnotations = (ast: AST.Annotations): AST.Annotations => {\n  const result: Record<symbol, unknown> = {}\n  if (AnnotationStatus in ast) {\n    result[AnnotationStatus] = ast[AnnotationStatus]\n  }\n  if (AnnotationEmptyDecodeable in ast) {\n    result[AnnotationEmptyDecodeable] = ast[AnnotationEmptyDecodeable]\n  }\n  if (AnnotationEncoding in ast) {\n    result[AnnotationEncoding] = ast[AnnotationEncoding]\n  }\n  if (AnnotationParam in ast) {\n    result[AnnotationParam] = ast[AnnotationParam]\n  }\n  if (AnnotationMultipart in ast) {\n    result[AnnotationMultipart] = ast[AnnotationMultipart]\n  }\n  if (AnnotationMultipartStream in ast) {\n    result[AnnotationMultipartStream] = ast[AnnotationMultipartStream]\n  }\n  return result\n}\n\nconst mergedAnnotations = (ast: AST.AST): Record<symbol, unknown> =>\n  ast._tag === \"Transformation\" ?\n    {\n      ...ast.to.annotations,\n      ...ast.annotations\n    } :\n    ast.annotations\n\nconst getAnnotation = <A>(ast: AST.AST, key: symbol): A | undefined => mergedAnnotations(ast)[key] as A\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getStatus = (ast: AST.AST, defaultStatus: number): number =>\n  getAnnotation<number>(ast, AnnotationStatus) ?? defaultStatus\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getEmptyDecodeable = (ast: AST.AST): boolean =>\n  getAnnotation<boolean>(ast, AnnotationEmptyDecodeable) ?? false\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getMultipart = (ast: AST.AST): Multipart_.withLimits.Options | undefined =>\n  getAnnotation<Multipart_.withLimits.Options>(ast, AnnotationMultipart)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getMultipartStream = (ast: AST.AST): Multipart_.withLimits.Options | undefined =>\n  getAnnotation<Multipart_.withLimits.Options>(ast, AnnotationMultipartStream)\n\nconst encodingJson: Encoding = {\n  kind: \"Json\",\n  contentType: \"application/json\"\n}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getEncoding = (ast: AST.AST, fallback = encodingJson): Encoding =>\n  getAnnotation<Encoding>(ast, AnnotationEncoding) ?? fallback\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getParam = (ast: AST.AST | Schema.PropertySignature.AST): string | undefined => {\n  const annotations = ast._tag === \"PropertySignatureTransformation\" ? ast.to.annotations : ast.annotations\n  return (annotations[AnnotationParam] as any)?.name as string | undefined\n}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const annotations = <A>(\n  annotations: Schema.Annotations.Schema<NoInfer<A>> & {\n    readonly status?: number | undefined\n  }\n): Schema.Annotations.Schema<A> => {\n  const result: Record<symbol, unknown> = Struct.omit(annotations, \"status\")\n  if (annotations.status !== undefined) {\n    result[AnnotationStatus] = annotations.status\n  }\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const isVoid = (ast: AST.AST): boolean => {\n  switch (ast._tag) {\n    case \"VoidKeyword\": {\n      return true\n    }\n    case \"Transformation\": {\n      return isVoid(ast.from)\n    }\n    case \"Suspend\": {\n      return isVoid(ast.f())\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusSuccessAST = (ast: AST.AST): number => getStatus(ast, isVoid(ast) ? 204 : 200)\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusSuccess = <A extends Schema.Schema.Any>(self: A): number => getStatusSuccessAST(self.ast)\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusErrorAST = (ast: AST.AST): number => getStatus(ast, 500)\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusError = <A extends Schema.Schema.All>(self: A): number => getStatusErrorAST(self.ast)\n\n/**\n * Extracts all individual types from a union type recursively.\n *\n * **Details**\n *\n * This function traverses an AST and collects all the types within a union,\n * even if they are nested. It ensures that every type in a union (including\n * deeply nested unions) is included in the resulting array. The returned array\n * contains each type as an individual AST node, preserving the order in which\n * they appear.\n *\n * @internal\n */\nexport const extractUnionTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => {\n  function process(ast: AST.AST): void {\n    if (AST.isUnion(ast)) {\n      for (const type of ast.types) {\n        process(type)\n      }\n    } else {\n      out.push(ast)\n    }\n  }\n  const out: Array<AST.AST> = []\n  process(ast)\n  return out\n}\n\n/** @internal */\nexport const UnionUnifyAST = (self: AST.AST, that: AST.AST): AST.AST =>\n  AST.Union.make(Array.from(new Set<AST.AST>([...extractUnionTypes(self), ...extractUnionTypes(that)])))\n\n/**\n * @since 1.0.0\n */\nexport const UnionUnify = <A extends Schema.Schema.All, B extends Schema.Schema.All>(self: A, that: B): Schema.Schema<\n  A[\"Type\"] | B[\"Type\"],\n  A[\"Encoded\"] | B[\"Encoded\"],\n  A[\"Context\"] | B[\"Context\"]\n> => Schema.make(UnionUnifyAST(self.ast, that.ast))\n\ntype Void$ = typeof Schema.Void\n\n/**\n * @since 1.0.0\n * @category path params\n */\nexport interface Param<Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>\n  extends Schema.Schema<Schema.Schema.Type<S>, Schema.Schema.Encoded<S>, Schema.Schema.Context<S>>\n{\n  readonly [AnnotationParam]: {\n    readonly name: Name\n    readonly schema: S\n  }\n}\n\n/**\n * @since 1.0.0\n * @category path params\n */\nexport const param: {\n  /**\n   * @since 1.0.0\n   * @category path params\n   */\n  <Name extends string>(name: Name): <S extends Schema.Schema.Any | Schema.PropertySignature.Any>(\n    schema:\n      & S\n      & ([Schema.Schema.Encoded<S> & {}] extends [string] ? unknown : \"Schema must be encodable to a string\")\n  ) => Param<Name, S>\n  /**\n   * @since 1.0.0\n   * @category path params\n   */\n  <Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>(\n    name: Name,\n    schema:\n      & S\n      & ([Schema.Schema.Encoded<S> & {}] extends [string] ? unknown : \"Schema must be encodable to a string\")\n  ): Param<Name, S>\n} = dual(\n  2,\n  <Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>(\n    name: Name,\n    schema: S\n  ): Param<Name, S> => {\n    const annotations: Record<string | symbol, unknown> = {\n      [AnnotationParam]: { name, schema }\n    }\n    if (Schema.isSchema(schema)) {\n      const identifier = AST.getIdentifierAnnotation(schema.ast)\n      if (Option.isSome(identifier)) {\n        annotations[AST.IdentifierAnnotationId] = identifier.value\n      }\n    }\n    return schema.annotations(annotations) as any\n  }\n)\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Empty = (status: number): typeof Schema.Void => Schema.Void.annotations(annotations({ status }))\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface asEmpty<\n  S extends Schema.Schema.Any\n> extends Schema.transform<typeof Schema.Void, S> {}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const asEmpty: {\n  /**\n   * @since 1.0.0\n   * @category empty response\n   */\n  <S extends Schema.Schema.Any>(\n    options: {\n      readonly status: number\n      readonly decode: LazyArg<Schema.Schema.Type<S>>\n    }\n  ): (self: S) => asEmpty<S>\n  /**\n   * @since 1.0.0\n   * @category empty response\n   */\n  <S extends Schema.Schema.Any>(\n    self: S,\n    options: {\n      readonly status: number\n      readonly decode: LazyArg<Schema.Schema.Type<S>>\n    }\n  ): asEmpty<S>\n} = dual(\n  2,\n  <S extends Schema.Schema.Any>(\n    self: S,\n    options: {\n      readonly status: number\n      readonly decode: LazyArg<Schema.Schema.Type<S>>\n    }\n  ): asEmpty<S> =>\n    Schema.transform(\n      Schema.Void.annotations(self.ast.annotations),\n      Schema.typeSchema(self),\n      {\n        decode: options.decode,\n        encode: constVoid\n      }\n    ).annotations(annotations({\n      status: options.status,\n      [AnnotationEmptyDecodeable]: true\n    })) as any\n)\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface Created extends Void$ {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Created: Created = Empty(201) as any\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface Accepted extends Void$ {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Accepted: Accepted = Empty(202) as any\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface NoContent extends Void$ {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const NoContent: NoContent = Empty(204) as any\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/Multipart\")\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport type MultipartTypeId = typeof MultipartTypeId\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport interface Multipart<S extends Schema.Schema.Any>\n  extends\n    Schema.Schema<Schema.Schema.Type<S> & Brand<MultipartTypeId>, Schema.Schema.Encoded<S>, Schema.Schema.Context<S>>\n{}\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const Multipart = <S extends Schema.Schema.Any>(self: S, options?: {\n  readonly maxParts?: Option.Option<number> | undefined\n  readonly maxFieldSize?: FileSystem.SizeInput | undefined\n  readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n}): Multipart<S> =>\n  self.annotations({\n    [AnnotationMultipart]: options ?? {}\n  }) as any\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartStreamTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/MultipartStream\")\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport type MultipartStreamTypeId = typeof MultipartStreamTypeId\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport interface MultipartStream<S extends Schema.Schema.Any> extends\n  Schema.Schema<\n    Schema.Schema.Type<S> & Brand<MultipartStreamTypeId>,\n    Schema.Schema.Encoded<S>,\n    Schema.Schema.Context<S>\n  >\n{}\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartStream = <S extends Schema.Schema.Any>(self: S, options?: {\n  readonly maxParts?: Option.Option<number> | undefined\n  readonly maxFieldSize?: FileSystem.SizeInput | undefined\n  readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n}): MultipartStream<S> =>\n  self.annotations({\n    [AnnotationMultipartStream]: options ?? {}\n  }) as any\n\nconst defaultContentType = (encoding: Encoding[\"kind\"]) => {\n  switch (encoding) {\n    case \"Json\": {\n      return \"application/json\"\n    }\n    case \"UrlParams\": {\n      return \"application/x-www-form-urlencoded\"\n    }\n    case \"Uint8Array\": {\n      return \"application/octet-stream\"\n    }\n    case \"Text\": {\n      return \"text/plain\"\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport interface Encoding {\n  readonly kind: \"Json\" | \"UrlParams\" | \"Uint8Array\" | \"Text\"\n  readonly contentType: string\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport declare namespace Encoding {\n  /**\n   * @since 1.0.0\n   * @category encoding\n   */\n  export type Validate<A extends Schema.Schema.Any, Kind extends Encoding[\"kind\"]> = Kind extends \"Json\" ? {}\n    : Kind extends \"UrlParams\" ? [A[\"Encoded\"]] extends [Readonly<Record<string, string | undefined>>] ? {}\n      : `'UrlParams' kind can only be encoded to 'Record<string, string | undefined>'`\n    : Kind extends \"Uint8Array\" ?\n      [A[\"Encoded\"]] extends [Uint8Array] ? {} : `'Uint8Array' kind can only be encoded to 'Uint8Array'`\n    : Kind extends \"Text\" ? [A[\"Encoded\"]] extends [string] ? {} : `'Text' kind can only be encoded to 'string'`\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const withEncoding: {\n  /**\n   * @since 1.0.0\n   * @category encoding\n   */\n  <A extends Schema.Schema.Any, Kind extends Encoding[\"kind\"]>(\n    options: {\n      readonly kind: Kind\n      readonly contentType?: string | undefined\n    } & Encoding.Validate<A, Kind>\n  ): (self: A) => A\n  /**\n   * @since 1.0.0\n   * @category encoding\n   */\n  <A extends Schema.Schema.Any, Kind extends Encoding[\"kind\"]>(\n    self: A,\n    options: {\n      readonly kind: Kind\n      readonly contentType?: string | undefined\n    } & Encoding.Validate<A, Kind>\n  ): A\n} = dual(2, <A extends Schema.Schema.Any>(self: A, options: {\n  readonly kind: Encoding[\"kind\"]\n  readonly contentType?: string | undefined\n}): A =>\n  self.annotations({\n    [AnnotationEncoding]: {\n      kind: options.kind,\n      contentType: options.contentType ?? defaultContentType(options.kind)\n    },\n    ...(options.kind === \"Uint8Array\" ?\n      {\n        jsonSchema: {\n          type: \"string\",\n          format: \"binary\"\n        }\n      } :\n      undefined)\n  }) as any)\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const Text = (options?: {\n  readonly contentType?: string\n}): typeof Schema.String => withEncoding(Schema.String, { kind: \"Text\", ...options })\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const Uint8Array = (options?: {\n  readonly contentType?: string\n}): typeof Schema.Uint8ArrayFromSelf => withEncoding(Schema.Uint8ArrayFromSelf, { kind: \"Uint8Array\", ...options })\n\nconst astCache = globalValue(\n  \"@effect/platform/HttpApiSchema/astCache\",\n  () => new WeakMap<AST.AST, Schema.Schema.Any>()\n)\n\n/**\n * @since 1.0.0\n */\nexport const deunionize = (\n  schemas: Set<Schema.Schema.Any>,\n  schema: Schema.Schema.Any\n): void => {\n  if (astCache.has(schema.ast)) {\n    schemas.add(astCache.get(schema.ast)!)\n    return\n  }\n  const ast = schema.ast\n  if (ast._tag === \"Union\") {\n    for (const astType of ast.types) {\n      if (astCache.has(astType)) {\n        schemas.add(astCache.get(astType)!)\n        continue\n      }\n      const memberSchema = Schema.make(AST.annotations(astType, {\n        ...ast.annotations,\n        ...astType.annotations\n      }))\n      astCache.set(astType, memberSchema)\n      schemas.add(memberSchema)\n    }\n  } else {\n    astCache.set(ast, schema)\n    schemas.add(schema)\n  }\n}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport interface EmptyErrorClass<Self, Tag> extends Schema.Schema<Self, void> {\n  new(_: void): { readonly _tag: Tag } & Effect.Effect<never, Self>\n}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport const EmptyError = <Self>() =>\n<const Tag extends string>(options: {\n  readonly tag: Tag\n  readonly status: number\n}): EmptyErrorClass<Self, Tag> => {\n  const symbol = Symbol.for(`@effect/platform/HttpApiSchema/EmptyError/${options.tag}`)\n  class EmptyError extends Effectable.StructuralClass<never, Self> {\n    readonly _tag: Tag = options.tag\n    commit(): Effect.Effect<never, Self> {\n      return Effect.fail(this) as any\n    }\n  }\n  ;(EmptyError as any).prototype[symbol] = symbol\n  Object.assign(EmptyError, {\n    [Schema.TypeId]: Schema.Void[Schema.TypeId],\n    pipe: Schema.Void.pipe,\n    annotations(this: any, annotations: any) {\n      return Schema.make(this.ast).annotations(annotations)\n    }\n  })\n  let transform: Schema.Schema.Any | undefined\n  Object.defineProperty(EmptyError, \"ast\", {\n    get() {\n      if (transform) {\n        return transform.ast\n      }\n      const self = this as any\n      transform = asEmpty(\n        Schema.declare((u) => hasProperty(u, symbol), {\n          identifier: options.tag,\n          title: options.tag\n        }),\n        {\n          status: options.status,\n          decode: constant(new self())\n        }\n      )\n      return transform.ast\n    }\n  })\n  return EmptyError as any\n}\n","import type { LogLevel as LogLevelSchema } from \"@beep/constants\";\nimport * as Cause from \"effect/Cause\";\nimport * as Chunk from \"effect/Chunk\";\nimport * as Clock from \"effect/Clock\";\nimport * as Effect from \"effect/Effect\";\nimport * as Exit from \"effect/Exit\";\nimport * as HashMap from \"effect/HashMap\";\nimport * as List from \"effect/List\";\nimport * as LogLevel from \"effect/LogLevel\";\nimport * as LogSpan from \"effect/LogSpan\";\nimport * as Match from \"effect/Match\";\nimport * as Metric from \"effect/Metric\";\nimport * as O from \"effect/Option\";\nimport color from \"picocolors\";\n\n/**\n * Pretty, colored console logger helpers + small telemetry helpers for Effect (shared/client-safe core).\n *\n * Node/server-specific features (env, FS, OS, process) are intentionally excluded here.\n */\n\nexport interface PrettyLoggerConfig {\n  readonly level: LogLevel.LogLevel;\n  readonly colors: boolean;\n  readonly showDate: boolean;\n  readonly showFiberId: boolean;\n  readonly showSpans: boolean;\n  readonly showAnnotations: boolean;\n  /**\n   * When true, will render Cause.pretty(cause) as a separate line\n   * for Warning and above (and any time a non-empty cause exists).\n   */\n  readonly includeCausePretty: boolean;\n}\n\nexport const defaultConfig: PrettyLoggerConfig = {\n  level: LogLevel.All,\n  colors: true,\n  showDate: true,\n  showFiberId: true,\n  showSpans: true,\n  showAnnotations: true,\n  includeCausePretty: true,\n};\n\nconst identity = (s: string) => s;\n\nexport function colorForLevel(level: LogLevel.LogLevel, enabled: boolean) {\n  if (!enabled) return identity;\n  const ord = level.ordinal;\n  if (ord >= LogLevel.Fatal.ordinal) return color.magenta;\n  if (ord >= LogLevel.Error.ordinal) return color.red;\n  if (ord >= LogLevel.Warning.ordinal) return color.yellow;\n  if (ord >= LogLevel.Info.ordinal) return color.green;\n  if (ord >= LogLevel.Debug.ordinal) return color.cyan;\n  return color.gray; // Trace and below\n}\n\nexport function formatMessage(message: unknown): string {\n  if (typeof message === \"string\") return message;\n  if (message instanceof Error) return `${message.name}: ${message.message}`;\n  try {\n    return typeof message === \"object\" ? JSON.stringify(message) : String(message);\n  } catch {\n    return String(message);\n  }\n}\n\nexport function formatAnnotations(ann: HashMap.HashMap<string, unknown>, enableColors: boolean): string {\n  const parts: string[] = [];\n  for (const [k, v] of HashMap.entries(ann)) {\n    const key = enableColors ? color.dim(String(k)) : String(k);\n    const val = formatMessage(v);\n    parts.push(`${key}=${val}`);\n  }\n  return parts.join(\" \");\n}\n\nexport function formatSpans(nowMs: number, spans: List.List<LogSpan.LogSpan>, enableColors: boolean): string {\n  const rendered = List.toArray(spans).map((s) => LogSpan.render(nowMs)(s));\n  const spanTxt = rendered.join(\" \");\n  return enableColors ? color.dim(spanTxt) : spanTxt;\n}\n\nexport function shouldPrintCause(\n  level: LogLevel.LogLevel,\n  cause: Cause.Cause<unknown>,\n  includePretty: boolean\n): boolean {\n  if (!includePretty) return false;\n  if (!Cause.isEmpty(cause)) return true;\n  return level.ordinal >= LogLevel.Warning.ordinal;\n}\n\nexport function formatCausePretty(cause: Cause.Cause<unknown>, enableColors = true): string {\n  const pretty = Cause.isEmpty(cause) ? \"\" : Cause.pretty(cause);\n  if (!enableColors || !pretty) return pretty;\n  const colored = color.red(pretty);\n  return colored === pretty ? `\\u001b[31m${pretty}\\u001b[39m` : colored;\n}\n\nexport function extractPrimaryError(cause: Cause.Cause<unknown>): { error?: Error; message: string } {\n  const failOpt = Cause.failureOption(cause);\n  if (O.isSome(failOpt)) {\n    const val = failOpt.value;\n    if (val instanceof Error) return { error: val, message: val.message };\n    return { message: String(val) };\n  }\n  const defects = Cause.defects(cause);\n  const arr = Chunk.toArray(defects);\n  const err = arr.find((d): d is Error => d instanceof Error);\n  if (err) return { error: err, message: err.message };\n  return { message: \"Unknown error\" };\n}\n\nexport interface CauseHeadingOptions {\n  readonly colors?: boolean;\n  readonly date?: Date;\n  readonly levelLabel?: string;\n  readonly fiberName?: string;\n  readonly spansText?: string;\n  readonly service?: string;\n  readonly environment?: string;\n  readonly requestId?: string;\n  readonly correlationId?: string;\n  readonly userId?: string;\n  readonly hostname?: string;\n  readonly pid?: number | string;\n  readonly nodeVersion?: string;\n  readonly includeCodeFrame?: boolean;\n}\n\n/**\n * Helper to annotate logs with a stable set of fields for a component/service.\n */\nexport const withLogContext =\n  (annotations: Readonly<Record<string, unknown>>) =>\n  <A, E, R>(self: Effect.Effect<A, E, R>) =>\n    self.pipe(Effect.annotateLogs(annotations));\n\n/**\n * Helper to add a root span around an operation.\n */\nexport const withRootSpan =\n  (label: string) =>\n  <A, E, R>(self: Effect.Effect<A, E, R>) =>\n    self.pipe(Effect.withLogSpan(label));\n\n/**\n * Instrument an effect with span, optional annotations, and optional metrics.\n */\nexport interface SpanMetricsConfig {\n  readonly successCounter?: Metric.Metric.Counter<number>;\n  readonly errorCounter?: Metric.Metric.Counter<number>;\n  readonly durationHistogram?: Metric.Metric.Histogram<number>;\n  /** How to record the duration value into the histogram (default: millis). */\n  readonly durationUnit?: \"millis\" | \"seconds\";\n}\n\nexport const withSpanAndMetrics =\n  (spanLabel: string, metrics?: SpanMetricsConfig, annotations?: Readonly<Record<string, unknown>>) =>\n  <A, E, R>(self: Effect.Effect<A, E, R>) =>\n    Effect.gen(function* () {\n      const start = yield* Clock.currentTimeMillis;\n      const exit = yield* Effect.exit(\n        self.pipe(Effect.withLogSpan(spanLabel), annotations ? Effect.annotateLogs(annotations) : (eff) => eff)\n      );\n      const end = yield* Clock.currentTimeMillis;\n      const durationMs = end - start;\n\n      if (metrics?.durationHistogram) {\n        const value = metrics.durationUnit === \"seconds\" ? durationMs / 1000 : durationMs;\n        yield* Metric.update(metrics.durationHistogram, value);\n      }\n\n      if (Exit.isSuccess(exit)) {\n        if (metrics?.successCounter) {\n          yield* Metric.increment(metrics.successCounter);\n        }\n        return exit.value;\n      }\n\n      if (metrics?.errorCounter) {\n        yield* Metric.increment(metrics.errorCounter);\n      }\n      // Re-emit the original cause to preserve failure semantics\n      return yield* Effect.failCause(exit.cause);\n    });\n\n/**\n * Convenience: log a cause pretty-printed (independent helper).\n */\nexport const logCausePretty = (cause: Cause.Cause<unknown>, colors = true) =>\n  Effect.sync(() => {\n    const pretty = formatCausePretty(cause, colors);\n    if (pretty) console.error(pretty);\n  });\n\n// =========================\n// Environment-driven config (shared parse only)\n// =========================\nexport const parseLevel = (raw: LogLevelSchema.Type): LogLevel.LogLevel => {\n  return Match.value(raw).pipe(\n    Match.when(\"All\", () => LogLevel.All),\n    Match.when(\"Trace\", () => LogLevel.Trace),\n    Match.when(\"Debug\", () => LogLevel.Debug),\n    Match.when(\"Info\", () => LogLevel.Info),\n    Match.when(\"Warning\", () => LogLevel.Warning),\n    Match.when(\"Error\", () => LogLevel.Error),\n    Match.when(\"Fatal\", () => LogLevel.Fatal),\n    Match.when(\"None\", () => LogLevel.None),\n    Match.exhaustive\n  );\n};\n\n// =========================\n// Accumulation helpers (pure/shared)\n// =========================\n\nexport interface AccumulateResult<A, E> {\n  readonly successes: ReadonlyArray<A>;\n  readonly errors: ReadonlyArray<Cause.Cause<E>>;\n}\n\nexport interface AccumulateOptions {\n  readonly concurrency?: number | \"unbounded\";\n  readonly spanLabel?: string;\n  readonly annotations?: Readonly<Record<string, string>>;\n  readonly colors?: boolean;\n}\n\nexport const accumulateEffects = <A, E, R>(\n  effects: ReadonlyArray<Effect.Effect<A, E, R>>,\n  options?: { readonly concurrency?: number | \"unbounded\" }\n): Effect.Effect<AccumulateResult<A, E>, never, R> =>\n  Effect.gen(function* () {\n    const [errs, oks] = yield* Effect.partition(effects, (eff) => Effect.sandbox(eff), {\n      concurrency: options?.concurrency ?? \"unbounded\",\n    });\n    return { successes: oks, errors: errs };\n  });\n\nexport * as BeepError from \"./errors\";\n","import * as HttpApiSchema from \"@effect/platform/HttpApiSchema\";\nimport * as Data from \"effect/Data\";\nimport * as S from \"effect/Schema\";\n\nexport class Es5Error extends Data.Error<{\n  readonly name: string;\n  readonly message: string;\n  readonly stack?: string | undefined;\n}> {}\n\nexport class UnrecoverableError extends S.TaggedError<UnrecoverableError>()(\n  \"UnrecoverableError\",\n  { message: S.String, stack: S.String, attributes: S.Any },\n  HttpApiSchema.annotations({ status: 500 })\n) {}\n\nexport namespace UnrecoverableError {\n  export type Type = S.Schema.Type<typeof UnrecoverableError>;\n  export type Encoded = S.Schema.Encoded<typeof UnrecoverableError>;\n}\n\n// Network\nexport class NotFoundError extends S.TaggedError<NotFoundError>()(\n  \"NotFoundError\",\n  { id: S.String, resource: S.String },\n  HttpApiSchema.annotations({ status: 404 })\n) {}\n\nexport namespace NotFoundError {\n  export type Type = S.Schema.Type<typeof NotFoundError>;\n  export type Encoded = S.Schema.Encoded<typeof NotFoundError>;\n}\n\nexport class UniqueViolationError extends S.TaggedError<UniqueViolationError>()(\n  \"UniqueViolationError\",\n  { field: S.String, value: S.String },\n  HttpApiSchema.annotations({ status: 409 })\n) {}\n\nexport namespace UniqueViolationError {\n  export type Type = S.Schema.Type<typeof UniqueViolationError>;\n  export type Encoded = S.Schema.Encoded<typeof UniqueViolationError>;\n}\n\n// Database\nexport class DatabaseError extends S.TaggedError<DatabaseError>()(\n  \"DatabaseError\",\n  { message: S.String, cause: S.optional(S.Any) },\n  HttpApiSchema.annotations({ status: 500 })\n) {}\n\nexport namespace DatabaseError {\n  export type Type = S.Schema.Type<typeof DatabaseError>;\n  export type Encoded = S.Schema.Encoded<typeof DatabaseError>;\n}\n\nexport class TransactionError extends S.TaggedError<TransactionError>()(\n  \"TransactionError\",\n  { message: S.String, operation: S.String },\n  HttpApiSchema.annotations({ status: 500 })\n) {}\n\nexport namespace TransactionError {\n  export type Type = S.Schema.Type<typeof TransactionError>;\n  export type Encoded = S.Schema.Encoded<typeof TransactionError>;\n}\n\nexport class ConnectionError extends S.TaggedError<ConnectionError>()(\n  \"ConnectionError\",\n  { message: S.String, path: S.optional(S.String) },\n  HttpApiSchema.annotations({ status: 500 })\n) {}\n\nexport namespace ConnectionError {\n  export type Type = S.Schema.Type<typeof ConnectionError>;\n  export type Encoded = S.Schema.Encoded<typeof ConnectionError>;\n}\n\nexport class ParseError extends S.TaggedError<ParseError>()(\n  \"ParseError\",\n  { message: S.String },\n  HttpApiSchema.annotations({ status: 400 })\n) {}\n\nexport namespace ParseError {\n  export type Type = S.Schema.Type<typeof ParseError>;\n  export type Encoded = S.Schema.Encoded<typeof ParseError>;\n}\n\nexport class Unauthorized extends S.TaggedError<Unauthorized>(\"Unauthorized\")(\n  \"Unauthorized\",\n  {\n    message: S.optional(S.String),\n  },\n  HttpApiSchema.annotations({\n    status: 401,\n    description: \"Authentication is required and has failed or has not been provided\",\n  })\n) {}\n\nexport namespace Unauthorized {\n  export type Type = S.Schema.Type<typeof Unauthorized>;\n  export type Encoded = S.Schema.Encoded<typeof Unauthorized>;\n}\n\nexport class Forbidden extends S.TaggedError<Forbidden>(\"Forbidden\")(\n  \"Forbidden\",\n  {\n    message: S.optional(S.String),\n  },\n  HttpApiSchema.annotations({\n    status: 403,\n    description: \"The server understood the request but refuses to authorize it\",\n  })\n) {}\n\nexport namespace Forbidden {\n  export type Type = S.Schema.Type<typeof Forbidden>;\n  export type Encoded = S.Schema.Encoded<typeof Forbidden>;\n}\n\nexport class UnknownError extends S.TaggedError<UnknownError>()(\"UnknownError\", {\n  cause: S.Unknown,\n  customMessage: S.optional(S.String),\n}) {\n  get message() {\n    return this.customMessage ?? \"An unknown error has occurred.\";\n  }\n}\n"],"names":["fiberRuntime","internal","MetricTypeId","globalMetricRegistry","make","mapInput","counter","frequency","withConstantInput","fromMetricKey","gauge","histogram","increment","incrementBy","map","mapType","modify","set","snapshot","succeed","sync","summary","summaryTimestamp","tagged","taggedWithLabelsInput","taggedWithLabels","timer","timerWithBoundaries","trackAll","trackDefect","trackDefectWith","trackDuration","trackDurationWith","trackError","trackErrorWith","trackSuccess","trackSuccessWith","update","value","withNow","zip","unsafeSnapshot","fiberStarted","fiberSuccesses","fiberFailures","fiberLifetimes","fiberActive","Effect","Effectable","constant","constVoid","dual","globalValue","Option","hasProperty","Schema","AST","Struct","AnnotationMultipart","Symbol","for","AnnotationMultipartStream","AnnotationStatus","AnnotationEmptyDecodeable","AnnotationEncoding","AnnotationParam","extractAnnotations","ast","result","mergedAnnotations","_tag","to","annotations","getAnnotation","key","getStatus","defaultStatus","getEmptyDecodeable","getMultipart","getMultipartStream","encodingJson","kind","contentType","getEncoding","fallback","getParam","name","omit","status","undefined","isVoid","from","f","getStatusSuccessAST","getStatusSuccess","self","getStatusErrorAST","getStatusError","extractUnionTypes","process","isUnion","type","types","out","push","UnionUnifyAST","that","Union","Array","Set","UnionUnify","param","schema","isSchema","identifier","getIdentifierAnnotation","isSome","IdentifierAnnotationId","Empty","Void","asEmpty","options","transform","typeSchema","decode","encode","Created","Accepted","NoContent","MultipartTypeId","Multipart","MultipartStreamTypeId","MultipartStream","defaultContentType","encoding","withEncoding","jsonSchema","format","Text","String","Uint8Array","Uint8ArrayFromSelf","astCache","WeakMap","deunionize","schemas","has","add","get","astType","memberSchema","EmptyError","symbol","tag","StructuralClass","commit","fail","prototype","Object","assign","TypeId","pipe","defineProperty","declare","u","title"],"mappings":"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","ignoreList":[1]}