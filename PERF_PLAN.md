# TypeScript Performance Plan

- **Establish baselines per slice.** Run `bunx tsc -p tsconfig.slices/apps.json --noEmit --extendedDiagnostics --pretty false` (and repeat for other heavy slices like `runtime.json`, `iam.json`, `files.json`) to capture `Program time`, `Check time`, and file counts. Save the outputs under `trace/tsc-<slice>.txt` for future comparison.
- **Audit the file graph.** For any slice with high `Program time` or file counts, run `bunx tsc -p tsconfig.slices/<slice>.json --listFilesOnly > trace/tsc-files-<slice>.txt` and `bunx tsc -p tsconfig.slices/<slice>.json --explainFiles > trace/tsc-explain-<slice>.txt` to spot mis-scoped includes (tests, storybook, build artifacts, nested node_modules/.turbo/.next). Tighten `include`/`exclude` globs in the affected tsconfig.slices file to keep only source inputs.
- **Validate effective configs.** Use `bunx tsc --showConfig -p tsconfig.slices/<slice>.json > trace/tsc-config-<slice>.json` to confirm the resolved `lib`, `types`, `paths`, and `moduleResolution` for each surface (web/server/tooling). For server-only projects, drop unused DOM libs; for client-only projects, ensure Bun/Node types are not leaking unless required.
- **Keep project references lean.** Run `bunx tsc -b tsconfig.json --verbose --dry` is not available, so run `bunx tsc -b tsconfig.json --verbose --extendedDiagnostics --noEmit` once to verify reference ordering and rebuild cost. Ensure each referenced project has a distinct `outDir`/`rootDir` and no cross-package source mixing; if a slice is too large, split it into smaller referenced projects that mirror workspace boundaries.
- **Optimize type acquisition.** The base config sets `types: []`; audit per-slice overrides for unnecessary globals (e.g., stray `@types/jest`, `@types/react-native`) and pin minimal `types` per environment (e.g., `["node", "bun"]` for tooling, `["node"]` for server-only, none for library-only). Remove unused `typeRoots` or ambient d.ts files pulled in by test helpers.
- **Trim heavy libraries per target.** Where possible, narrow `lib` arrays to what the environment needs (server slices often only need `ES2023`/`ESNext`, not `DOM`). This reduces declaration load and symbol creation during `Program time`.
- **Cache hygiene.** Because `incremental`/`composite` are enabled, set or confirm per-slice `tsBuildInfoFile` paths under `./.turbo/tsbuildinfo/<slice>.tsbuildinfo` to avoid contention and keep `.tsbuildinfo` files out of source directories. Periodically clean with `bunx tsc -b tsconfig.json --clean` before timing runs to compare cold vs warm builds.
- **Isolate type-heavy hotspots.** When a specific file or type alias is slow to check, capture a minimal repro by running `bunx tsc -p tsconfig.slices/<slice>.json --pretty false --traceResolution --explainFiles --noEmit` on the fileâ€™s folder and simplify unions/conditional types per considerations in `PERFORMANCE.md` (prefer interfaces over intersections, name complex conditional return types, reduce mega-unions).
- **Measure watch and editor paths.** Use `bunx tsc -b tsconfig.json --watch --extendedDiagnostics --preserveWatchOutput false` to time incremental rebuilds after single-file edits; compare to cold numbers to ensure `--incremental` wins are realized. For editor lag, capture a TSServer log once (`export TSS_LOG="-level verbose -file ./trace/tsserver.log"` before launching the editor) and scan for slow requests/files.
- **Integrate into CI checks.** Add a lightweight smoke step (non-blocking initially) that runs `bunx tsc -p tsconfig.slices/apps.json --noEmit --extendedDiagnostics --pretty false` and uploads logs as artifacts. Track regressions by diffing `Check time` and file counts; flag PRs that introduce new glob inclusions or large union-heavy types.
