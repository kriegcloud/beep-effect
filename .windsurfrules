# Windsurf v2 — Vibe Coding Rules for beep-effect

Make it fast, fun, and correct. These are the vibe-coded guardrails for pairing with Windsurf Cascade in this repo.

Source of truth links in this repo:
- README: `README.md`
- Path aliases and module boundaries: `tsconfig.base.json`
- Task graph and pipelines: `turbo.json`
- Workspaces: `pnpm-workspace.yaml`
- Patterns/docs: `docs/patterns/`
- Production posture: `docs/PRODUCTION_CHECKLIST.md`
- Architecture guardrails: `.windsurfrules`

## TL;DR
- Ask for intent first; optimize for momentum. Small, focused patches > big rewrites.
- Follow slice boundaries and path aliases. No cross-slice leaks.
- Prefer Effect-first patterns (Effect.fn, tagged errors, layers).
- Keep prod logs structured (JSON) and fast; pretty logs are for dev only.

---

## Tooling
- Prefer root npm scripts. They’re already wired with `dotenvx`.
- If a tool is not in `$PATH`, prefix with: `direnv exec . <cmd>`
  - Examples:
    - `direnv exec . pnpm check`
    - `direnv exec . pnpm lint`
    - `direnv exec . pnpm lint:fix`
- Dependency management: see `docs/dependency-management.md`
- Pinned pnpm version: see `packageManager`/`engines` in root `package.json`.

### MCP tools
- Effect code: always use the `effect-mcp` docs tool when dealing with Effect code (schemas, layers, platform). Cite the docs you fetch.
- MUI questions: use the `mui-mcp` docs tool and fetch the exact component/version.

## CLI Commands (common)
- Lint: `pnpm lint` / Fix: `pnpm lint:fix` (see `biome.jsonc`)
- Type check: `pnpm check`
- Test: `pnpm test` (workspace driven by `vitest.workspace.ts`)
- Build: `pnpm build`
- Dev (all): `pnpm dev`
- Dev (web): `pnpm dev --filter=@beep/web`
- DB lifecycle: `pnpm db:generate` | `pnpm db:push` | `pnpm db:migrate` | `pnpm db:studio`
- Local services up: `pnpm db:up` (see `docker-compose.yml` for Postgres, Redis, Jaeger)

---

## Project Structure & Architecture
Vertical Slice Architecture with a hexagonal/clean flavor. Each slice owns its domain and exposes use cases via application ports. Infrastructure adapters implement those ports. Cross-slice sharing only through shared/common modules.

Top-level layout:
- `apps/` — application surfaces (e.g., `web`, `server`, `mcp`)
- `packages/` — slices and shared libs
  - Slices today: `iam/*`, `files/*` (layers: `domain`, `application`, `infra`, `tables`, `ui`, `sdk`)
  - Cross-cutting: `shared/*`, `common/*`, `core/*`, `ui/*`
- `tooling/*` — repo scripts, config, testkit

Authoritative module boundaries: `tsconfig.base.json` (e.g., `@beep/iam-*`, `@beep/files-*`, `@beep/shared-*`, `@/*`).

### Layering & allowed imports (per slice S)
- `S/domain` — Entities, Value Objects, Domain Events, domain services.
  - May import: `@beep/shared-domain`, `@beep/common/*` (pure utilities/types)
  - Must NOT import: `S/application`, `S/infra`, `S/ui`, other slices
- `S/application` — Use cases, orchestrations, and ports (interfaces).
  - May import: `S/domain`, `@beep/shared-*`, `@beep/common/*`
  - Must NOT import: `S/infra`, `S/ui`, other slices directly
- `S/infra` — Adapters (DB, auth, email, file stores, etc.) implementing ports.
  - May import: `S/domain` (types), `S/application` ports (to implement), `@beep/persistence/*`
  - Must NOT invoke `S/application` use cases (no upward dependency)
- `S/ui` — UI components/state for the slice (if applicable).
  - For app-specific UI (e.g., Next.js), prefer `apps/web` with the `@/*` alias; import slice via `@beep/S-application` facades
- `S/tables` — DB schema/table definitions for the slice.
  - Referenced by `S/infra` for persistence; keep separate from domain entities

### Cross-slice rules
- No direct imports between slices (e.g., `iam-*` -> `files-*`). Use `@beep/shared-*` or `@beep/common/*`.
- If a genuine cross-slice use case emerges, elevate abstractions to `packages/shared/*` or compose at the app layer.

### Ports & adapters
- Define ports (interfaces) in `S/application`.
- Implement adapters in `S/infra`, `packages/adapters/*`, or app layers.
- Handlers/controllers (`S/api` or `apps/*`) depend on application use cases, not on `infra` directly.

### When adding a feature
1. Start in `S/domain` (entities/VOs/events).
2. Define use cases and ports in `S/application`.
3. Implement adapters in `S/infra` or app-layer code.
4. Expose API in `S/api` and UI in `apps/web` (via `@/*`) or `S/ui` if library UI.
5. Update path aliases if a new package is added (`tsconfig.base.json`), and wire tasks in `turbo.json` if needed.

### Testing strategy
- Unit tests colocated within each package (`vitest.workspace.ts` includes `packages/**`).
- Integration/e2e at the app layer (`apps/*`).
- Prefer testing use cases through application facades; mock adapters via ports.

### Conventions & guardrails
- Effect-first FP; preserve pure domain logic and deterministic use cases.
- Keep domain free of IO concerns; isolate IO in adapters.
- Maintain strict TS types; follow Biome lint rules.
- Use `direnv exec . pnpm <task>` if PATH issues arise.
- Do not add cross-slice imports or leak infrastructure into domain/application.
- Prefer new shared abstractions in `packages/shared/*` over ad-hoc cross-slice imports.

### Enforcement cues for the assistant
- Respect path aliases and layering; never import `infra` from `api` or `ui` from `domain`.
- For infrastructure needs, define/extend a port in `S/application` and implement it in an adapter.
- Keep new packages wired in `pnpm-workspace.yaml` and `turbo.json` as needed.

---

## Effect-Specific Patterns (vibe-friendly)
- Import conventions
  - Single-character for select Effect modules:
    ```ts
    import * as S from "effect/Schema";
    import * as A from "effect/Array";
    import * as O from "effect/Option";
    import * as F from "effect/Function";
    // for @effect/sql/Model
    import * as M from "@effect/sql/Model";
    ```
  - Otherwise import as namespaces:
    ```ts
    import * as Effect from "effect/Effect";
    import * as Data from "effect/Data";
    import * as Layer from "effect/Layer";
    ```
- Sequential ops: prefer `Effect.fn`
  ```ts
  const program = Effect.fn(function* () {
    const user = yield* getUser(id);
    const profile = yield* getProfile(user.profileId);
    return { user, profile };
  });
  ```
- Errors: use `Data.TaggedError`
  ```ts
  class UserNotFound extends Data.TaggedError("UserNotFound")<{ readonly id: string }>() {}
  ```
- Promise interop: `Effect.tryPromise`
  ```ts
  const fetchUser = (id: string) =>
    Effect.tryPromise({
      try: () => prisma.user.findUniqueOrThrow({ where: { id } }),
      catch: () => new UserNotFound({ id })
    });
  ```
- Testing with `@effect/vitest`
  ```ts
  import { assert, describe, it } from "@effect/vitest";
  import * as Effect from "effect/Effect";

  describe("UserService", () => {
    it.effect("fetches user", () =>
      Effect.fn(function* () {
        const user = yield* fetchUser("123");
        assert.strictEqual(user.id, "123");
      }));
  });
  ```

---

## Production posture (logging/observability)
- Defaults (see `docs/PRODUCTION_CHECKLIST.md`):
  - `APP_LOG_FORMAT=json`
  - `APP_LOG_LEVEL=error`
  - `NODE_ENV=production`
- Pretty/heading/code-frame logging is dev-focused; avoid in hot paths in prod.

---

## Vibe coding principles (how to pair with me)
- Keep momentum
  - Prefer minimal diffs and quick iterations. I’ll propose safe, isolated changes first.
- Be explicit about constraints
  - Tell me if we’re optimizing for speed, readability, or correctness—so I can choose the right trade-offs.
- Keep changes layered
  - I’ll refuse cross-slice imports and leaking infra into domain.
- I’ll cite sources
  - I link to files like `tsconfig.base.json`, `turbo.json`, and `README.md` when making structural calls.
- Safety-first commands
  - I won’t auto-run destructive commands. I’ll ask for approval before any mutation or external request.

---

## Apps overview
- Web: `apps/web` (Next.js, uses `@/*` alias)
- Server: `apps/server` (Effect + RPC/HTTP-ready)
- MCP: `apps/mcp`

CI: see `.github/workflows/check.yml` (types, lint, tests).
