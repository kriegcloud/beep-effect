import { $UiId } from "@beep/identity/packages";
import { BS } from "@beep/schema";
import { thunk, thunkFalse, thunkTrue, thunkZero } from "@beep/utils";
import * as F from "effect/Function";
import * as S from "effect/Schema";
import { ICloseType } from "./ICloseType";

const $I = $UiId.create("flex-layout/model/IJsonModel");

import { thunk1, thunk8, thunk100, thunk200, thunkDot30, thunkMaxSize, thunkNegativeOne } from "../values";
// import { $UiId } from "@beep/identity/packages";
export class BorderLocation extends BS.StringLiteralKit("top", "bottom", "left", "right").annotations(
  $I.annotations("BorderLocation", {
    description: "Location of a border panel in the layout (top, bottom, left, or right edge)",
  })
) {
  static readonly make = (name: string) => S.decodeUnknownSync(BorderLocation)(name);
}

export declare namespace BorderLocation {
  export type Type = typeof BorderLocation.Type;
  export type Encoded = typeof BorderLocation.Encoded;
}

export class TabLocation extends BS.StringLiteralKit("top", "bottom").annotations(
  $I.annotations("TabLocation", {
    description: "Location of tabs within a tabset (top or bottom of the tabset area)",
  })
) {
  static readonly thunkTop = thunk(TabLocation.Enum.top);
  static readonly thunkBottom = thunk(TabLocation.Enum.bottom);
}

export declare namespace TabLocation {
  export type Type = typeof TabLocation.Type;
  export type Encoded = typeof TabLocation.Encoded;
}

//----------------------------------------------------------------------------------------------------------
// below this line is autogenerated from attributes in code via Model static method toTypescriptInterfaces()
//----------------------------------------------------------------------------------------------------------
export class GlobalAttributes extends S.Class<GlobalAttributes>($I`GlobalAttributes`)(
  {
    // Border defaults
    borderAutoSelectTabWhenClosed: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Whether to select new/moved tabs in border when the border is currently closed",
    }),
    borderAutoSelectTabWhenOpen: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Whether to select new/moved tabs in border when the border is already open",
    }),
    borderClassName: S.optional(S.String).annotations({
      description: "Class applied to border tab buttons",
    }),
    borderEnableAutoHide: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Hide border if it has zero tabs",
    }),
    borderEnableDrop: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Whether tabs can be dropped into borders",
    }),
    borderEnableTabScrollbar: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Whether to show a mini scrollbar for border tabs",
    }),
    borderMaxSize: S.optionalWith(S.Number, { default: thunkMaxSize }).annotations({
      description: "Maximum size of the border tab area in pixels",
    }),
    borderMinSize: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Minimum size of the border tab area in pixels",
    }),
    borderSize: S.optionalWith(S.Number, { default: thunk200 }).annotations({
      description: "Size of the border tab area when selected in pixels",
    }),

    // Layout globals
    enableEdgeDock: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Enable docking to the edges of the layout, showing edge indicators",
    }),
    enableRotateBorderIcons: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Whether tab icons should rotate with text in left and right borders",
    }),
    rootOrientationVertical: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "The top level row will layout horizontally by default; set true for vertical layout",
    }),

    // Splitter settings
    splitterEnableHandle: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Enable a small centralized handle on all splitters",
    }),
    splitterExtra: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Additional width in pixels of the splitter hit test area",
    }),
    splitterSize: S.optionalWith(S.Number, { default: thunk8 }).annotations({
      description: "Width in pixels of all splitters between tabsets/borders",
    }),

    // Tab defaults
    tabBorderHeight: S.optionalWith(S.Number, { default: thunkNegativeOne }).annotations({
      description: "Height when tab is added to border (-1 uses border size)",
    }),
    tabBorderWidth: S.optionalWith(S.Number, { default: thunkNegativeOne }).annotations({
      description: "Width when tab is added to border (-1 uses border size)",
    }),
    tabClassName: S.optional(S.String).annotations({
      description: "Class applied to tab buttons",
    }),
    tabCloseType: S.optionalWith(ICloseType, { default: thunk1 }).annotations({
      description: "Close button behavior type (1=Visible, 2=Always, 3=Selected)",
    }),
    tabContentClassName: S.optional(S.String).annotations({
      description: "Class applied to tab content area",
    }),
    tabDragSpeed: S.optionalWith(S.Number, { default: thunkDot30 }).annotations({
      description: "Speed multiplier for tab drag operations",
    }),
    tabEnableClose: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to close tabs via close button",
    }),
    tabEnableDrag: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to drag tabs to new locations",
    }),
    tabEnablePopout: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Enable popout functionality in capable browsers",
    }),
    tabEnablePopoutIcon: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Whether to show the popout icon in tabset header for popout-enabled tabs",
    }),
    tabEnablePopoutOverlay: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Gray out tabs that won't work correctly in popout windows when main window is inactive",
    }),
    tabEnableRename: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to rename tabs by double clicking",
    }),
    tabEnableRenderOnDemand: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Avoid rendering component until tab is visible",
    }),
    tabIcon: S.optional(S.String).annotations({
      description: "Default tab icon",
    }),
    tabMaxHeight: S.optionalWith(S.Number, { default: thunkMaxSize }).annotations({
      description: "Maximum height of tabs in pixels",
    }),
    tabMaxWidth: S.optionalWith(S.Number, { default: thunkMaxSize }).annotations({
      description: "Maximum width of tabs in pixels",
    }),
    tabMinHeight: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Minimum height of tabs in pixels",
    }),
    tabMinWidth: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Minimum width of tabs in pixels",
    }),

    // TabSet defaults
    tabSetAutoSelectTab: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Whether to select new/moved tabs in tabset",
    }),
    tabSetClassNameTabStrip: S.optional(S.String).annotations({
      description: "Class name to apply to the tab strip",
    }),
    tabSetEnableActiveIcon: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Whether the active icon (*) should be displayed when tabset is active",
    }),
    tabSetEnableClose: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Allow user to close tabset via a close button",
    }),
    tabSetEnableDeleteWhenEmpty: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Whether to delete tabset when it has no tabs",
    }),
    tabSetEnableDivide: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to drag tabs to region of tabset, splitting into new tabset",
    }),
    tabSetEnableDrag: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to drag tabs out of this tabset",
    }),
    tabSetEnableDrop: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to drag tabs into this tabset",
    }),
    tabSetEnableMaximize: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Allow user to maximize tabset to fill view via maximize button",
    }),
    tabSetEnableSingleTabStretch: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "If tabset has only a single tab, stretch it to fill area and display in header style",
    }),
    tabSetEnableTabScrollbar: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Whether to show a mini scrollbar for the tabs",
    }),
    tabSetEnableTabStrip: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Enable tab strip and allow multiple tabs in this tabset",
    }),
    tabSetEnableTabWrap: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "Wrap tabs onto multiple lines",
    }),
    tabSetMaxHeight: S.optionalWith(S.Number, { default: thunkMaxSize }).annotations({
      description: "Maximum height in pixels for tabsets",
    }),
    tabSetMaxWidth: S.optionalWith(S.Number, { default: thunkMaxSize }).annotations({
      description: "Maximum width in pixels for tabsets",
    }),
    tabSetMinHeight: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Minimum height in pixels for tabsets",
    }),
    tabSetMinWidth: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Minimum width in pixels for tabsets",
    }),
    tabSetTabLocation: S.optionalWith(TabLocation, { default: TabLocation.thunkTop }).annotations({
      description: "Location of tabs in tabsets (top or bottom)",
    }),
  },
  $I.annotations("GlobalAttributes", {
    description: "Global configuration attributes that provide default values for all nodes in the layout",
  })
) {}

export class RowAttributes extends S.Class<RowAttributes>($I`RowAttributes`)(
  {
    id: S.optional(S.String).annotations({
      description: "Unique ID of the row; if undefined a UUID will be assigned",
    }),
    type: F.pipe("row" as const, (literal) =>
      S.optionalWith(S.Literal(literal), { default: thunk(literal) })
    ).annotations({
      description: "Node type identifier (fixed value: 'row')",
    }),
    weight: S.optionalWith(S.Number, { default: thunk100 }).annotations({
      description: "Relative weight for sizing this row in parent row",
    }),
  },
  $I.annotations("RowAttributes", {
    description: "Attributes for row nodes that contain child rows or tabsets",
  })
) {}

// =============================================================================
// TabSet Attributes
// =============================================================================

export class TabSetAttributes extends S.Class<TabSetAttributes>($I`TabSetAttributes`)(
  {
    autoSelectTab: S.optional(S.Boolean).annotations({
      description: "Whether to select new/moved tabs in tabset (inherited from global if not set)",
    }),
    classNameTabStrip: S.optional(S.String).annotations({
      description: "Class name to apply to the tab strip",
    }),
    config: S.optional(S.Unknown).annotations({
      description: "Custom JSON config for use in your own code",
    }),
    enableActiveIcon: S.optional(S.Boolean).annotations({
      description: "Whether the active icon (*) should be displayed when tabset is active",
    }),
    enableClose: S.optional(S.Boolean).annotations({
      description: "Allow user to close tabset via a close button",
    }),
    enableDeleteWhenEmpty: S.optional(S.Boolean).annotations({
      description: "Whether to delete this tabset when it has no tabs",
    }),
    enableDivide: S.optional(S.Boolean).annotations({
      description: "Allow user to drag tabs to region of this tabset, splitting into new tabset",
    }),
    enableDrag: S.optional(S.Boolean).annotations({
      description: "Allow user to drag tabs out of this tabset",
    }),
    enableDrop: S.optional(S.Boolean).annotations({
      description: "Allow user to drag tabs into this tabset",
    }),
    enableMaximize: S.optional(S.Boolean).annotations({
      description: "Allow user to maximize tabset to fill view via maximize button",
    }),
    enableSingleTabStretch: S.optional(S.Boolean).annotations({
      description: "If tabset has only a single tab, stretch it to fill area and display in header style",
    }),
    enableTabScrollbar: S.optional(S.Boolean).annotations({
      description: "Whether to show a mini scrollbar for the tabs",
    }),
    enableTabStrip: S.optional(S.Boolean).annotations({
      description: "Enable tab strip and allow multiple tabs in this tabset",
    }),
    enableTabWrap: S.optional(S.Boolean).annotations({
      description: "Wrap tabs onto multiple lines",
    }),
    id: S.optional(S.String).annotations({
      description: "Unique ID of the tab set; if undefined a UUID will be assigned",
    }),
    maxHeight: S.optional(S.Number).annotations({
      description: "Maximum height in pixels for this tabset",
    }),
    maxWidth: S.optional(S.Number).annotations({
      description: "Maximum width in pixels for this tabset",
    }),
    minHeight: S.optional(S.Number).annotations({
      description: "Minimum height in pixels for this tabset",
    }),
    minWidth: S.optional(S.Number).annotations({
      description: "Minimum width in pixels for this tabset",
    }),
    name: S.optional(S.String).annotations({
      description: "Display name of the tabset",
    }),
    selected: S.optionalWith(S.Number, { default: thunkZero }).annotations({
      description: "Index of selected/visible tab in tabset",
    }),
    tabLocation: S.optional(TabLocation).annotations({
      description: "Location of the tabs (top or bottom)",
    }),
    type: F.pipe("tabset" as const, (literal) =>
      S.optionalWith(S.Literal(literal), { default: thunk(literal) })
    ).annotations({
      description: "Node type identifier (fixed value: 'tabset')",
    }),
    weight: S.optionalWith(S.Number, { default: thunk100 }).annotations({
      description: "Relative weight for sizing this tabset in parent row",
    }),
  },
  $I.annotations("TabSetAttributes", {
    description: "Attributes for tabset nodes that contain tab children",
  })
) {}

// =============================================================================
// Tab Attributes
// =============================================================================

export class TabAttributes extends S.Class<TabAttributes>($I`TabAttributes`)(
  {
    altName: S.optional(S.String).annotations({
      description: "Alternative name used in overflow menu if no name is specified",
    }),
    borderHeight: S.optional(S.Number).annotations({
      description: "Height when added to border (-1 uses border size)",
    }),
    borderWidth: S.optional(S.Number).annotations({
      description: "Width when added to border (-1 uses border size)",
    }),
    className: S.optional(S.String).annotations({
      description: "Class applied to tab button",
    }),
    closeType: S.optional(ICloseType).annotations({
      description: "Close button behavior type (1=Visible, 2=Always, 3=Selected)",
    }),
    component: S.optional(S.String).annotations({
      description: "String identifying which component to run (for factory)",
    }),
    config: S.optional(S.Unknown).annotations({
      description: "Custom JSON config for the hosted component",
    }),
    contentClassName: S.optional(S.String).annotations({
      description: "Class applied to tab content area",
    }),
    enableClose: S.optional(S.Boolean).annotations({
      description: "Allow user to close tab via close button",
    }),
    enableDrag: S.optional(S.Boolean).annotations({
      description: "Allow user to drag tab to new location",
    }),
    enablePopout: S.optional(S.Boolean).annotations({
      description: "Enable popout in capable browsers",
    }),
    enablePopoutIcon: S.optional(S.Boolean).annotations({
      description: "Whether to show the popout icon in tabset header if this tab enables popouts",
    }),
    enablePopoutOverlay: S.optional(S.Boolean).annotations({
      description: "Gray out this tab in popout window when main window is inactive if it won't work correctly",
    }),
    enableRename: S.optional(S.Boolean).annotations({
      description: "Allow user to rename tabs by double clicking",
    }),
    enableRenderOnDemand: S.optional(S.Boolean).annotations({
      description: "Avoid rendering component until tab is visible",
    }),
    enableWindowReMount: S.optionalWith(S.Boolean, { default: thunkFalse }).annotations({
      description: "If enabled the tab will re-mount when popped out/in",
    }),
    helpText: S.optional(S.String).annotations({
      description: "Optional help text displayed upon tab hover",
    }),
    icon: S.optional(S.String).annotations({
      description: "The tab icon",
    }),
    id: S.optional(S.String).annotations({
      description: "Unique ID of the tab; if undefined a UUID will be assigned",
    }),
    maxHeight: S.optional(S.Number).annotations({
      description: "Maximum height of this tab in pixels",
    }),
    maxWidth: S.optional(S.Number).annotations({
      description: "Maximum width of this tab in pixels",
    }),
    minHeight: S.optional(S.Number).annotations({
      description: "Minimum height of this tab in pixels",
    }),
    minWidth: S.optional(S.Number).annotations({
      description: "Minimum width of this tab in pixels",
    }),
    name: S.optionalWith(S.String, { default: thunk("[Unnamed Tab]") }).annotations({
      description: "Name of tab displayed in the tab button",
    }),
    tabsetClassName: S.optional(S.String).annotations({
      description: "Class applied to parent tabset when this is the only tab and stretched to fill",
    }),
    type: F.pipe("tab" as const, (literal) =>
      S.optionalWith(S.Literal(literal), { default: thunk(literal) })
    ).annotations({
      description: "Node type identifier (fixed value: 'tab')",
    }),
  },
  $I.annotations("TabAttributes", {
    description: "Attributes for individual tab nodes within a tabset",
  })
) {}
export class JsonTabNode extends TabAttributes.extend<JsonTabNode>($I`JsonTabNode`)(
  {},
  $I.annotations("JsonTabNode", {
    description: "JSON representation of a tab node in the layout model",
  })
) {}
// =============================================================================
// Border Attributes
// =============================================================================

export class BorderAttributes extends S.Class<BorderAttributes>($I`BorderAttributes`)(
  {
    autoSelectTabWhenClosed: S.optional(S.Boolean).annotations({
      description: "Whether to select new/moved tabs in border when border is currently closed",
    }),
    autoSelectTabWhenOpen: S.optional(S.Boolean).annotations({
      description: "Whether to select new/moved tabs in border when border is already open",
    }),
    className: S.optional(S.String).annotations({
      description: "Class applied to border tab buttons",
    }),
    config: S.optional(S.Unknown).annotations({
      description: "Custom JSON config for use in your own code",
    }),
    enableAutoHide: S.optional(S.Boolean).annotations({
      description: "Hide border if it has zero tabs",
    }),
    enableDrop: S.optional(S.Boolean).annotations({
      description: "Whether tabs can be dropped into this border",
    }),
    enableTabScrollbar: S.optional(S.Boolean).annotations({
      description: "Whether to show a mini scrollbar for the tabs",
    }),
    maxSize: S.optional(S.Number).annotations({
      description: "Maximum size of the tab area in pixels",
    }),
    minSize: S.optional(S.Number).annotations({
      description: "Minimum size of the tab area in pixels",
    }),
    selected: S.optionalWith(S.Number, { default: thunkNegativeOne }).annotations({
      description: "Index of selected/visible tab in border; -1 means no tab selected",
    }),
    show: S.optionalWith(S.Boolean, { default: thunkTrue }).annotations({
      description: "Show/hide this border",
    }),
    size: S.optional(S.Number).annotations({
      description: "Size of the tab area when selected in pixels",
    }),
    type: F.pipe("border" as const, (literal) =>
      S.optionalWith(S.Literal(literal), { default: thunk(literal) })
    ).annotations({
      description: "Node type identifier (fixed value: 'border')",
    }),
  },
  $I.annotations("BorderAttributes", {
    description: "Attributes for border nodes that appear at the edges of the layout",
  })
) {
  static readonly new = (i: S.Schema.Encoded<typeof BorderAttributes>) => S.decodeSync(BorderAttributes)(i);
}
export class JsonTabSetNode extends TabSetAttributes.extend<JsonTabSetNode>($I`JsonTabSetNode`)(
  {
    active: S.optional(S.Boolean).annotations({
      description:
        "Marks this as the active tab set (read from initial JSON but must be set on model; only one can be active)",
    }),
    maximized: S.optional(S.Boolean).annotations({
      description:
        "Marks this tab set as maximized (read from initial JSON but must be set on model; only one can be maximized)",
    }),
    children: S.Array(JsonTabNode).annotations({
      description: "Array of tab nodes contained in this tabset",
    }),
  },
  $I.annotations("JsonTabSetNode", {
    description: "JSON representation of a tabset node containing multiple tabs",
  })
) {}
export type IGlobalAttributes = GlobalAttributes;
export type IBorderAttributes = BorderAttributes;

// =============================================================================
// JSON Row Node (recursive - contains itself or tabsets)
// =============================================================================

/**
 * JSON representation of a row node; the top level row is horizontal,
 * nested rows alternate orientation.
 *
 * Note: This uses S.Struct instead of S.Class because Effect Schema Classes
 * cannot handle direct self-references in their field definitions.
 */

export interface JsonRowNode {
  /** Unique ID of the row; if undefined a UUID will be assigned */
  readonly id?: string | undefined;
  /** Node type identifier (fixed value: 'row') */
  readonly type: "row";
  /** Relative weight for sizing this row in parent row */
  readonly weight: number;
  /** Array of child row nodes or tabset nodes; rows inside rows take opposite orientation to parent */
  readonly children: ReadonlyArray<JsonRowNode | JsonTabSetNode>;
}

/** Encoded form of JsonRowNode (for JSON serialization) */
export interface JsonRowNodeEncoded {
  readonly id?: string | undefined;
  readonly type?: "row" | undefined;
  readonly weight?: number | undefined;
  readonly children: ReadonlyArray<JsonRowNodeEncoded | S.Schema.Encoded<typeof JsonTabSetNode>>;
}

export const JsonRowNode: S.Schema<JsonRowNode, JsonRowNodeEncoded> = S.Struct({
  id: S.optional(S.String).annotations({
    description: "Unique ID of the row; if undefined a UUID will be assigned",
  }),
  type: S.optionalWith(S.Literal("row"), { default: () => "row" as const }).annotations({
    description: "Node type identifier (fixed value: 'row')",
  }),
  weight: S.optionalWith(S.Number, { default: thunk100 }).annotations({
    description: "Relative weight for sizing this row in parent row",
  }),
  children: S.Array(
    S.Union(
      S.suspend((): S.Schema<JsonRowNode, JsonRowNodeEncoded> => JsonRowNode),
      JsonTabSetNode
    )
  ).annotations({
    description: "Array of child row nodes or tabset nodes; rows inside rows take opposite orientation to parent",
  }),
}).annotations(
  $I.annotations("JsonRowNode", {
    description:
      "JSON representation of a row node; the top level row is horizontal, nested rows alternate orientation",
  })
);

// =============================================================================
// JSON Border Node
// =============================================================================

export class JsonBorderNode extends BorderAttributes.extend<JsonBorderNode>($I`JsonBorderNode`)(
  {
    location: BorderLocation.annotations({
      description: "Edge location of this border (top, bottom, left, or right)",
    }),
    children: S.Array(JsonTabNode).annotations({
      description: "Array of tab nodes contained in this border",
    }),
  },
  $I.annotations("JsonBorderNode", {
    description: "JSON representation of a border node at an edge of the layout",
  })
) {}

export class JsonRect extends S.Class<JsonRect>($I`JsonRect`)(
  {
    x: S.Number.annotations({ description: "X coordinate of the rectangle" }),
    y: S.Number.annotations({ description: "Y coordinate of the rectangle" }),
    width: S.Number.annotations({ description: "Width of the rectangle in pixels" }),
    height: S.Number.annotations({ description: "Height of the rectangle in pixels" }),
  },
  $I.annotations("JsonRect", {
    description: "Rectangle dimensions for positioning popout windows",
  })
) {}
// =============================================================================
// JSON Popout
// =============================================================================

export class JsonPopout extends S.Class<JsonPopout>($I`JsonPopout`)(
  {
    layout: JsonRowNode.annotations({
      description: "The row node layout of the popout window",
    }),
    rect: JsonRect.annotations({
      description: "Rectangle defining the position and size of the popout window",
    }),
  },
  $I.annotations("JsonPopout", {
    description: "JSON representation of a popout window containing its own layout",
  })
) {}

// =============================================================================
// JSON Model (root)
// =============================================================================

export class JsonModel extends S.Class<JsonModel>($I`JsonModel`)(
  {
    global: S.optional(GlobalAttributes).annotations({
      description: "Global configuration attributes providing defaults for all nodes",
    }),
    borders: S.optional(S.Array(JsonBorderNode)).annotations({
      description: "Array of border nodes at the edges of the layout",
    }),
    layout: JsonRowNode.annotations({
      description: "The root row node of the layout; top level row is horizontal, nested rows alternate orientation",
    }),
    popouts: S.optional(S.Record({ key: S.String, value: JsonPopout })).annotations({
      description: "Record of popout windows keyed by their identifiers",
    }),
  },
  $I.annotations("JsonModel", {
    description: "Root JSON model representing an entire flex layout configuration",
  })
) {}
