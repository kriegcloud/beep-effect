import { WalletAddress } from "@beep/iam-domain/entities";
import { $IamClientId } from "@beep/identity/packages";
import { IamEntityIds, SharedEntityIds } from "@beep/shared-domain";
import * as Effect from "effect/Effect";
import * as F from "effect/Function";
import * as ParseResult from "effect/ParseResult";
import * as S from "effect/Schema";
import { requireDate, requireNumber, requireString, toDate } from "./transformation-helpers.ts";

const $I = $IamClientId.create("_common/wallet-address.schemas");

/**
 * Schema representing a Better Auth wallet address object from the SIWE plugin.
 *
 * This captures the WalletAddress structure from Better Auth's Sign-In With Ethereum
 * plugin, representing blockchain wallet addresses linked to users.
 *
 * @remarks
 * Better Auth's WalletAddress schema from the SIWE plugin does NOT include `id` or `updatedAt`.
 * These fields come from the database layer and are captured via Record extension.
 * This pattern is similar to RateLimit, which also lacks core schema fields.
 *
 * Native SIWE plugin fields:
 * - userId: string (FK to user)
 * - address: string (blockchain wallet address)
 * - chainId: number (blockchain network chain ID)
 * - isPrimary: boolean (default false)
 * - createdAt: Date
 *
 * Database-provided fields (via Record extension):
 * - id: string (generated by database with branded format)
 * - updatedAt: Date
 * - _rowId, version, audit columns
 *
 * Uses Struct with Record extension to allow unknown properties from
 * Better Auth database layer.
 */
export const BetterAuthWalletAddressSchema = F.pipe(
  S.Struct({
    // Fields defined by Better Auth SIWE plugin (NO id or updatedAt)
    userId: S.String,
    address: S.String,
    chainId: S.Number,
    isPrimary: S.optionalWith(S.Boolean, { default: () => false }),
    createdAt: S.DateFromSelf,
    // NOTE: id and updatedAt come from Record extension (database layer)
  }),
  S.extend(S.Record({ key: S.String, value: S.Unknown })),
  S.annotations(
    $I.annotations("BetterAuthWalletAddress", {
      description: "The wallet address object from Better Auth SIWE plugin.",
    })
  )
);

export type BetterAuthWalletAddress = S.Schema.Type<typeof BetterAuthWalletAddressSchema>;
export type BetterAuthWalletAddressEncoded = S.Schema.Encoded<typeof BetterAuthWalletAddressSchema>;

/**
 * Type alias for WalletAddress.Model's encoded representation.
 * Used to ensure proper typing in the transformation without type assertions.
 */
type WalletAddressModelEncoded = S.Schema.Encoded<typeof WalletAddress.Model>;

/**
 * Transforms a Better Auth wallet address object into the domain WalletAddress.Model.
 *
 * IMPORTANT: Unlike entities that extend coreSchema, Better Auth's SIWE plugin
 * WalletAddress doesn't have id or updatedAt in its native schema. These are added
 * by our database and accessed via the Record extension pattern.
 *
 * This transformation handles:
 * - ID extraction from Record extension (database-generated, NOT from Better Auth)
 * - ID format validation (expects branded ID format "iam_wallet_address__<uuid>")
 * - userId validation (expects branded ID format "shared_user__<uuid>")
 * - Mapping Better Auth native fields to WalletAddress.Model encoded representation
 * - REQUIRED database fields validated via require* helpers (fail if missing)
 *
 * @remarks
 * Better Auth is configured with `generateId: false`, meaning the database
 * generates IDs in the branded format via EntityId.publicId().
 * For WalletAddress, the id comes ONLY from the database - Better Auth never
 * provides it since the SIWE plugin schema doesn't include id.
 *
 * Domain model field types:
 * - address: S.NonEmptyString (must be non-empty)
 * - chainId: S.Int (integer, schema handles number â†’ int coercion)
 * - isPrimary: BS.BoolWithDefault(false)
 *
 * The transformation returns the "encoded" representation of WalletAddress.Model.
 * The schema framework then internally decodes this to the Type form.
 * This avoids type assertions by using explicit type annotations.
 */
export const DomainWalletAddressFromBetterAuthWalletAddress = S.transformOrFail(
  BetterAuthWalletAddressSchema,
  WalletAddress.Model,
  {
    strict: true,
    decode: Effect.fn(function* (betterAuthWalletAddress, _options, ast) {
      // =======================================================================
      // ID VALIDATION - Must be present from database (via Record extension)
      // Better Auth's SIWE plugin schema does NOT include id - it comes from DB
      // =======================================================================

      const id = yield* requireString(betterAuthWalletAddress, "id", ast);
      if (id === null) {
        return yield* ParseResult.fail(new ParseResult.Type(ast, id, "WalletAddress id is required but was null"));
      }

      const isValidWalletAddressId = IamEntityIds.WalletAddressId.is(id);
      if (!isValidWalletAddressId) {
        return yield* ParseResult.fail(
          new ParseResult.Type(
            ast,
            id,
            `Invalid wallet address ID format: expected "iam_wallet_address__<uuid>", got "${id}"`
          )
        );
      }

      // =======================================================================
      // USER ID VALIDATION
      // =======================================================================

      const isValidUserId = SharedEntityIds.UserId.is(betterAuthWalletAddress.userId);
      if (!isValidUserId) {
        return yield* ParseResult.fail(
          new ParseResult.Type(
            ast,
            betterAuthWalletAddress.userId,
            `Invalid user ID format: expected "shared_user__<uuid>", got "${betterAuthWalletAddress.userId}"`
          )
        );
      }

      // =======================================================================
      // REQUIRED FIELDS from database (via Record extension)
      // These use require* helpers that FAIL if the field is missing
      // =======================================================================

      const _rowId = yield* requireNumber(betterAuthWalletAddress, "_rowId", ast);
      const version = yield* requireNumber(betterAuthWalletAddress, "version", ast);
      const source = yield* requireString(betterAuthWalletAddress, "source", ast);
      const createdAtRaw = betterAuthWalletAddress.createdAt; // From Struct, not Record
      const updatedAtRaw = yield* requireDate(betterAuthWalletAddress, "updatedAt", ast);
      const deletedAt = yield* requireDate(betterAuthWalletAddress, "deletedAt", ast);
      const createdBy = yield* requireString(betterAuthWalletAddress, "createdBy", ast);
      const updatedBy = yield* requireString(betterAuthWalletAddress, "updatedBy", ast);
      const deletedBy = yield* requireString(betterAuthWalletAddress, "deletedBy", ast);

      // createdAt is defined in Struct, validate it's present
      if (createdAtRaw === null || createdAtRaw === undefined) {
        return yield* ParseResult.fail(
          new ParseResult.Type(ast, createdAtRaw, "WalletAddress createdAt is required but was null")
        );
      }
      const createdAt = createdAtRaw;

      // updatedAt is required (M.Generated), so it must not be null
      if (updatedAtRaw === null) {
        return yield* ParseResult.fail(
          new ParseResult.Type(ast, updatedAtRaw, "WalletAddress updatedAt is required but was null")
        );
      }
      const updatedAt = updatedAtRaw;

      // =======================================================================
      // ADDRESS VALIDATION - Must be non-empty for domain model
      // =======================================================================

      if (betterAuthWalletAddress.address === "") {
        return yield* ParseResult.fail(
          new ParseResult.Type(ast, betterAuthWalletAddress.address, "WalletAddress address cannot be empty")
        );
      }

      // Construct the encoded form of WalletAddress.Model
      // Type annotation ensures proper typing without type assertions
      // The schema framework will decode this to WalletAddress.Model.Type
      const encodedWalletAddress: WalletAddressModelEncoded = {
        // Core identity fields (from database via Record extension)
        id,
        _rowId,
        version,

        // Timestamp fields
        createdAt, // From Struct (Better Auth native field)
        updatedAt, // From Record extension (database provides this)

        // Better Auth native fields from SIWE plugin
        userId: betterAuthWalletAddress.userId,
        address: betterAuthWalletAddress.address,
        // chainId: S.Int expects encoded form as number
        // The domain schema will decode this to S.Int (still number, just branded)
        chainId: betterAuthWalletAddress.chainId,
        // isPrimary: BS.BoolWithDefault(false) expects boolean
        isPrimary: betterAuthWalletAddress.isPrimary,

        // Audit fields (from database via Record extension)
        source,
        deletedAt,
        createdBy,
        updatedBy,
        deletedBy,
      };

      return encodedWalletAddress;
    }),

    encode: Effect.fn(function* (walletAddressEncoded, _options, _ast) {
      // id might be undefined in the encoded form (has default), handle that
      const id = walletAddressEncoded.id ?? IamEntityIds.WalletAddressId.create();

      // Convert dates - these may be DateTime.Utc or Date
      const createdAt = toDate(walletAddressEncoded.createdAt);
      const updatedAt = toDate(walletAddressEncoded.updatedAt);

      // Return BetterAuthWalletAddress form with database fields included via Record
      // This ensures proper round-trip through the transformation
      const betterAuthWalletAddress: BetterAuthWalletAddress = {
        // Better Auth SIWE plugin native fields
        userId: walletAddressEncoded.userId ?? "",
        address: walletAddressEncoded.address ?? "",
        chainId: walletAddressEncoded.chainId ?? 1,
        isPrimary: walletAddressEncoded.isPrimary ?? false,
        createdAt: createdAt,

        // Include database fields for round-trip (via Record extension)
        id,
        _rowId: walletAddressEncoded._rowId,
        version: walletAddressEncoded.version,
        source: walletAddressEncoded.source ?? undefined,
        updatedAt,
        deletedAt: walletAddressEncoded.deletedAt ? toDate(walletAddressEncoded.deletedAt) : undefined,
        createdBy: walletAddressEncoded.createdBy ?? undefined,
        updatedBy: walletAddressEncoded.updatedBy ?? undefined,
        deletedBy: walletAddressEncoded.deletedBy ?? undefined,
      };

      return betterAuthWalletAddress;
    }),
  }
).annotations(
  $I.annotations("DomainWalletAddressFromBetterAuthWalletAddress", {
    description:
      "Transforms a Better Auth SIWE plugin wallet address response into the domain WalletAddress.Model, handling the unique case where Better Auth doesn't provide id or updatedAt (they come from the database).",
  })
);

export declare namespace DomainWalletAddressFromBetterAuthWalletAddress {
  export type Type = typeof DomainWalletAddressFromBetterAuthWalletAddress.Type;
  export type Encoded = typeof DomainWalletAddressFromBetterAuthWalletAddress.Encoded;
}
