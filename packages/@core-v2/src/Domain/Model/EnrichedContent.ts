/**
 * Domain Model: Enriched Content
 *
 * Schema for AI-enriched metadata extracted from fetched content.
 * Used by ContentEnrichmentAgent to classify and describe ingested documents.
 *
 * @since 2.0.0
 * @module Domain/Model/EnrichedContent
 */

import { Schema } from "effect"

// =============================================================================
// Source Type Classification
// =============================================================================

/**
 * SourceType - Classification of content sources
 *
 * Used by the enrichment agent to classify the type of content.
 *
 * @since 2.0.0
 * @category Types
 */
export const SourceTypeSchema = Schema.Literal(
  "news",
  "blog",
  "press_release",
  "official",
  "academic",
  "unknown"
).annotations({
  title: "Source Type",
  description: "Classification of the content source"
})

export type SourceType = Schema.Schema.Type<typeof SourceTypeSchema>

// =============================================================================
// Enriched Content Model
// =============================================================================

/**
 * EnrichedContent - AI-derived metadata for ingested content
 *
 * Generated by ContentEnrichmentAgent using LLM analysis of fetched content.
 * Provides structured metadata for search, filtering, and display.
 *
 * @example
 * ```typescript
 * const metadata: EnrichedContent = {
 *   headline: "Seattle City Council Approves New Transit Plan",
 *   description: "Council votes 7-2 to fund light rail expansion to West Seattle",
 *   sourceType: "news",
 *   publishedAt: new Date("2024-03-15"),
 *   author: "Jane Smith",
 *   organization: "Seattle Times",
 *   keyEntities: ["Seattle City Council", "West Seattle", "Sound Transit"],
 *   topics: ["transportation", "infrastructure", "local government"],
 *   language: "en",
 *   wordCount: 847
 * }
 * ```
 *
 * @since 2.0.0
 * @category Domain
 */
export class EnrichedContent extends Schema.Class<EnrichedContent>("EnrichedContent")({
  /**
   * Main headline/title of the content
   *
   * Extracted or generated headline that summarizes the main topic.
   */
  headline: Schema.String.annotations({
    title: "Headline",
    description: "Main headline or title of the content"
  }),

  /**
   * Brief description/summary
   *
   * 1-2 sentence summary of the content's main points.
   */
  description: Schema.String.annotations({
    title: "Description",
    description: "Brief summary of the content"
  }),

  /**
   * Classification of source type
   *
   * Helps filter and weight content appropriately.
   */
  sourceType: SourceTypeSchema,

  /**
   * When the content was originally published
   *
   * Extracted from content metadata or inferred from text.
   */
  publishedAt: Schema.NullOr(Schema.DateFromString).annotations({
    title: "Published At",
    description: "Publication date if available"
  }),

  /**
   * Author name if identifiable
   *
   * Person or organization credited as the author.
   */
  author: Schema.NullOr(Schema.String).annotations({
    title: "Author",
    description: "Author name if available"
  }),

  /**
   * Publishing organization
   *
   * News outlet, company, or institution that published the content.
   */
  organization: Schema.NullOr(Schema.String).annotations({
    title: "Organization",
    description: "Publishing organization if identifiable"
  }),

  /**
   * Key named entities mentioned
   *
   * People, organizations, locations prominently featured in the content.
   * Used for quick entity-based filtering and linking.
   */
  keyEntities: Schema.Array(Schema.String).annotations({
    title: "Key Entities",
    description: "Named entities prominently mentioned in the content"
  }),

  /**
   * Topic/category tags
   *
   * General topics or themes covered by the content.
   */
  topics: Schema.Array(Schema.String).annotations({
    title: "Topics",
    description: "Topic tags for the content"
  }),

  /**
   * Content language (ISO 639-1 code)
   *
   * Defaults to "en" if not detected.
   */
  language: Schema.optionalWith(Schema.String, {
    default: () => "en"
  }).annotations({
    title: "Language",
    description: "ISO 639-1 language code"
  }),

  /**
   * Approximate word count of the content
   *
   * Used for display and content length filtering.
   */
  wordCount: Schema.Number.pipe(
    Schema.int(),
    Schema.nonNegative()
  ).annotations({
    title: "Word Count",
    description: "Approximate word count"
  })
}) {
  /**
   * Check if content has author attribution
   */
  get hasAuthor(): boolean {
    return this.author !== null && this.author.length > 0
  }

  /**
   * Check if content has publication date
   */
  get hasPublicationDate(): boolean {
    return this.publishedAt !== null
  }

  /**
   * Debugger-friendly representation
   */
  toJSON() {
    return {
      _tag: "EnrichedContent" as const,
      headline: this.headline,
      description: this.description,
      sourceType: this.sourceType,
      publishedAt: this.publishedAt?.toISOString() ?? null,
      author: this.author,
      organization: this.organization,
      keyEntities: this.keyEntities,
      topics: this.topics,
      language: this.language,
      wordCount: this.wordCount
    }
  }
}

// =============================================================================
// Jina Content Response
// =============================================================================

/**
 * JinaContent - Raw content from Jina Reader API
 *
 * Represents the cleaned markdown content returned by Jina Reader.
 *
 * @since 2.0.0
 * @category Types
 */
export class JinaContent extends Schema.Class<JinaContent>("JinaContent")({
  /**
   * Original URL fetched
   */
  url: Schema.String.annotations({
    title: "URL",
    description: "Original URL that was fetched"
  }),

  /**
   * Page title from HTML head or extracted
   */
  title: Schema.String.annotations({
    title: "Title",
    description: "Page title"
  }),

  /**
   * Clean markdown content
   */
  content: Schema.String.annotations({
    title: "Content",
    description: "Cleaned markdown content"
  }),

  /**
   * Content length in characters
   */
  length: Schema.optional(Schema.Number).annotations({
    title: "Length",
    description: "Content length in characters"
  }),

  /**
   * Meta description if available
   */
  description: Schema.optional(Schema.String).annotations({
    title: "Description",
    description: "Meta description from page"
  }),

  /**
   * Published date from meta tags
   */
  publishedDate: Schema.optional(Schema.String).annotations({
    title: "Published Date",
    description: "Publication date from meta tags"
  }),

  /**
   * Site name from meta tags
   */
  siteName: Schema.optional(Schema.String).annotations({
    title: "Site Name",
    description: "Site name from OpenGraph or meta"
  }),

  /**
   * Featured image URL if available
   */
  image: Schema.optional(Schema.String).annotations({
    title: "Image",
    description: "Featured image URL"
  })
}) {
  /**
   * Get approximate word count
   */
  get wordCount(): number {
    return this.content.split(/\s+/).filter((w) => w.length > 0).length
  }

  toJSON() {
    return {
      _tag: "JinaContent" as const,
      url: this.url,
      title: this.title,
      content: this.content.slice(0, 200) + (this.content.length > 200 ? "..." : ""),
      length: this.length ?? this.content.length,
      description: this.description,
      publishedDate: this.publishedDate,
      siteName: this.siteName,
      wordCount: this.wordCount
    }
  }
}
