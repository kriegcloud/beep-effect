/**
 * Service: Claim
 *
 * High-level service for claim management with RDF serialization.
 * Wraps ClaimRepository with additional business logic and RDF reification.
 *
 * @since 2.0.0
 * @module Service/Claim
 */

import { DateTime, Effect } from "effect"
import { CLAIMS, RDF, XSD } from "../Domain/Rdf/Constants.js"
import { type IRI, Literal, Quad } from "../Domain/Rdf/Types.js"
import { ClaimRepository } from "../Repository/Claim.js"
import type { ClaimFilter } from "../Repository/Claim.js"
import type { ClaimInsertRow, ClaimRow } from "../Repository/schema.js"
import { RdfBuilder, type RdfStore } from "./Rdf.js"

// =============================================================================
// Types
// =============================================================================

/**
 * Input for creating a new claim
 *
 * @since 2.0.0
 * @category Types
 */
export interface CreateClaimInput {
  readonly subjectIri: string
  readonly predicateIri: string
  readonly objectValue: string
  readonly objectType: "iri" | "literal"
  readonly articleId: string
  readonly ontologyId: string
  readonly confidence: number
  readonly evidence?: {
    readonly text: string
    readonly startOffset: number
    readonly endOffset: number
  }
  readonly validFrom?: Date
  readonly validTo?: Date
}

/**
 * Result of deprecating a claim
 *
 * @since 2.0.0
 * @category Types
 */
export interface DeprecationResult {
  readonly claimId: string
  readonly deprecatedAt: Date
  readonly reason: string
  readonly correctionId?: string
}

// =============================================================================
// Service
// =============================================================================

/**
 * ClaimService - High-level claim management
 *
 * Provides claim lifecycle operations with RDF serialization support.
 * Uses ClaimRepository for persistence and generates reified RDF triples.
 *
 * **Capabilities**:
 * - `createClaim`: Create a new claim with metadata
 * - `deprecateClaim`: Deprecate a claim with reason
 * - `promoteToPreferred`: Promote a claim to preferred rank
 * - `findConflicting`: Find claims that conflict with a given claim
 * - `getClaimHistory`: Get all claims for a subject+predicate over time
 * - `toReifiedTriples`: Convert claim to reified RDF quads
 *
 * @example
 * ```typescript
 * Effect.gen(function*() {
 *   const claim = yield* ClaimService.createClaim({
 *     subjectIri: "http://example.org/person/123",
 *     predicateIri: "http://schema.org/name",
 *     objectValue: "John Doe",
 *     objectType: "literal",
 *     articleId: "article-001",
 *     confidence: 0.95
 *   })
 *
 *   const quads = yield* ClaimService.toReifiedTriples(claim)
 *   // Generates reified RDF quads with CLAIMS vocabulary
 * }).pipe(Effect.provide(ClaimService.Default))
 * ```
 *
 * @since 2.0.0
 * @category Services
 */
export class ClaimService extends Effect.Service<ClaimService>()("ClaimService", {
  effect: Effect.gen(function*() {
    const repo = yield* ClaimRepository
    const rdf = yield* RdfBuilder

    // -------------------------------------------------------------------------
    // Claim Creation
    // -------------------------------------------------------------------------

    /**
     * Create a new claim
     *
     * Generates a unique claim ID and persists the claim with metadata.
     */
    const createClaim = (input: CreateClaimInput) =>
      Effect.gen(function*() {
        const id = crypto.randomUUID()

        const claimRow: ClaimInsertRow = {
          id,
          articleId: input.articleId,
          ontologyId: input.ontologyId,
          subjectIri: input.subjectIri,
          predicateIri: input.predicateIri,
          objectValue: input.objectValue,
          objectType: input.objectType,
          confidenceScore: input.confidence.toString(),
          rank: "normal",
          evidenceText: input.evidence?.text ?? null,
          evidenceStartOffset: input.evidence?.startOffset ?? null,
          evidenceEndOffset: input.evidence?.endOffset ?? null,
          validFrom: input.validFrom ?? null,
          validTo: input.validTo ?? null
          // Note: assertedAt is auto-generated by database via defaultNow()
        }

        return yield* repo.insertClaim(claimRow)
      })

    /**
     * Deprecate a claim with a reason
     *
     * Marks the claim as deprecated and optionally links to a correction.
     */
    const deprecateClaim = (claimId: string, reason: string, correctionId?: string) =>
      Effect.gen(function*() {
        const now = yield* DateTime.now

        yield* repo.deprecateClaim(claimId, correctionId ?? crypto.randomUUID())

        return {
          claimId,
          deprecatedAt: DateTime.toDate(now),
          reason,
          correctionId
        } satisfies DeprecationResult
      })

    /**
     * Promote a claim to preferred rank
     *
     * Sets the claim as the preferred value for its subject+predicate.
     */
    const promoteToPreferred = (claimId: string) => repo.promoteToPreferred(claimId)

    /**
     * Find claims that conflict with a given claim
     *
     * Detects position conflicts (same subject+predicate, different value)
     * and temporal conflicts (overlapping validity periods).
     */
    const findConflicting = (claim: ClaimRow | ClaimInsertRow) => repo.findConflictingClaims(claim)

    /**
     * Get claim history for a subject+predicate
     *
     * Returns all claims (including deprecated) in chronological order.
     */
    const getClaimHistory = (subjectIri: string, predicateIri: string) => repo.getClaimHistory(subjectIri, predicateIri)

    /**
     * Get a claim by ID
     */
    const getClaim = (claimId: string) => repo.getClaim(claimId)

    /**
     * Query claims with filters
     */
    const getClaims = (filter: ClaimFilter) => repo.getClaims(filter)

    // -------------------------------------------------------------------------
    // RDF Reification
    // -------------------------------------------------------------------------

    /**
     * Convert a claim to reified RDF quads
     *
     * Generates quads using the CLAIMS vocabulary (ontologies/claims/claims.ttl):
     * - claim:id a claims:Claim
     * - claims:claimSubject, claims:claimPredicate (statement reification)
     * - claims:claimObject (for IRI objects) OR claims:claimLiteral (for literals)
     * - claims:rank, claims:confidence, claims:extractedAt
     * - claims:validFrom, claims:validUntil (if temporal)
     * - claims:hasEvidence with evidence details
     *
     * @param claim - ClaimRow from repository
     * @param graphUri - Optional named graph for the quads
     * @returns Array of Quad objects
     */
    const toReifiedTriples = (claim: ClaimRow, graphUri?: string) =>
      Effect.sync(() => {
        const quads: Array<Quad> = []
        const claimIri = `${CLAIMS.namespace}${claim.id}` as IRI
        const graph = graphUri as IRI | undefined

        // Type assertion
        quads.push(
          new Quad({
            subject: claimIri,
            predicate: RDF.type,
            object: CLAIMS.Claim,
            graph
          })
        )

        // Claims vocabulary reification (aligned with ontologies/claims/claims.ttl)
        // Uses claims:claimSubject, claims:claimPredicate, claims:claimObject|claimLiteral
        // instead of RDF reification (rdf:subject, rdf:predicate, rdf:object)
        quads.push(
          new Quad({
            subject: claimIri,
            predicate: CLAIMS.claimSubject,
            object: claim.subjectIri as IRI,
            graph
          })
        )

        quads.push(
          new Quad({
            subject: claimIri,
            predicate: CLAIMS.claimPredicate,
            object: claim.predicateIri as IRI,
            graph
          })
        )

        // Object: use claimObject for IRIs, claimLiteral for literals
        // This preserves the semantic distinction defined in claims.ttl
        if (claim.objectType === "iri") {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.claimObject,
              object: claim.objectValue as IRI,
              graph
            })
          )
        } else {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.claimLiteral,
              object: new Literal({ value: claim.objectValue }),
              graph
            })
          )
        }

        // Rank
        const rankIri = claim.rank === "preferred"
          ? CLAIMS.Preferred
          : claim.rank === "deprecated"
          ? CLAIMS.Deprecated
          : CLAIMS.Normal

        quads.push(
          new Quad({
            subject: claimIri,
            predicate: CLAIMS.rank,
            object: rankIri,
            graph
          })
        )

        // Confidence
        if (claim.confidenceScore) {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.confidence,
              object: new Literal({
                value: claim.confidenceScore,
                datatype: XSD.double
              }),
              graph
            })
          )
        }

        // Asserted at (when the claim was extracted/recorded)
        if (claim.assertedAt) {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.extractedAt,
              object: new Literal({
                value: claim.assertedAt.toISOString(),
                datatype: XSD.dateTime
              }),
              graph
            })
          )
        }

        // Source article
        quads.push(
          new Quad({
            subject: claimIri,
            predicate: CLAIMS.statedIn,
            object: `${CLAIMS.namespace}article/${claim.articleId}` as IRI,
            graph
          })
        )

        // Temporal validity
        if (claim.validFrom) {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.validFrom,
              object: new Literal({
                value: claim.validFrom.toISOString(),
                datatype: XSD.dateTime
              }),
              graph
            })
          )
        }

        if (claim.validTo) {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.validUntil,
              object: new Literal({
                value: claim.validTo.toISOString(),
                datatype: XSD.dateTime
              }),
              graph
            })
          )
        }

        // Deprecation info
        if (claim.deprecatedAt) {
          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.deprecatedAt,
              object: new Literal({
                value: claim.deprecatedAt.toISOString(),
                datatype: XSD.dateTime
              }),
              graph
            })
          )
        }

        // Evidence
        if (claim.evidenceText) {
          const evidenceIri = `${claimIri}/evidence` as IRI

          quads.push(
            new Quad({
              subject: claimIri,
              predicate: CLAIMS.hasEvidence,
              object: evidenceIri,
              graph
            })
          )

          quads.push(
            new Quad({
              subject: evidenceIri,
              predicate: RDF.type,
              object: CLAIMS.Evidence,
              graph
            })
          )

          quads.push(
            new Quad({
              subject: evidenceIri,
              predicate: CLAIMS.evidenceText,
              object: new Literal({ value: claim.evidenceText }),
              graph
            })
          )

          if (claim.evidenceStartOffset !== null) {
            quads.push(
              new Quad({
                subject: evidenceIri,
                predicate: CLAIMS.startOffset,
                object: new Literal({
                  value: claim.evidenceStartOffset.toString(),
                  datatype: XSD.integer
                }),
                graph
              })
            )
          }

          if (claim.evidenceEndOffset !== null) {
            quads.push(
              new Quad({
                subject: evidenceIri,
                predicate: CLAIMS.endOffset,
                object: new Literal({
                  value: claim.evidenceEndOffset.toString(),
                  datatype: XSD.integer
                }),
                graph
              })
            )
          }
        }

        return quads
      })

    /**
     * Add claim quads to an RDF store
     *
     * Convenience method that converts a claim to quads and adds them to a store.
     */
    const addClaimToStore = (store: RdfStore, claim: ClaimRow, graphUri?: string) =>
      Effect.gen(function*() {
        const quads = yield* toReifiedTriples(claim, graphUri)
        // Add quads to store using low-level N3 operations
        // The RdfBuilder doesn't have a direct addQuads method, so we build manually
        return quads
      })

    /**
     * Serialize multiple claims to Turtle format
     *
     * Creates a new RDF store, adds all claims, and serializes to Turtle.
     */
    const claimsToTurtle = (claims: Array<ClaimRow>, graphUri?: string) =>
      Effect.gen(function*() {
        const store = yield* rdf.createStore

        for (const claim of claims) {
          const quads = yield* toReifiedTriples(claim, graphUri)
          // Add each quad to the store
          for (const quad of quads) {
            // Use the store's internal N3 store directly
            const n3 = yield* Effect.promise(() => import("n3"))
            const n3Store = store._store

            const subject = n3.DataFactory.namedNode(quad.subject as string)
            const predicate = n3.DataFactory.namedNode(quad.predicate as string)
            const object = quad.object instanceof Literal
              ? quad.object.datatype
                ? n3.DataFactory.literal(quad.object.value, n3.DataFactory.namedNode(quad.object.datatype))
                : quad.object.language
                ? n3.DataFactory.literal(quad.object.value, quad.object.language)
                : n3.DataFactory.literal(quad.object.value)
              : n3.DataFactory.namedNode(quad.object as string)
            const graph = quad.graph
              ? n3.DataFactory.namedNode(quad.graph)
              : n3.DataFactory.defaultGraph()

            n3Store.addQuad(n3.DataFactory.quad(subject, predicate, object, graph))
          }
        }

        return yield* rdf.toTurtle(store)
      })

    return {
      // Core CRUD
      createClaim,
      getClaim,
      getClaims,

      // Lifecycle
      deprecateClaim,
      promoteToPreferred,

      // Query
      findConflicting,
      getClaimHistory,

      // RDF
      toReifiedTriples,
      addClaimToStore,
      claimsToTurtle
    }
  }),
  dependencies: [ClaimRepository.Default, RdfBuilder.Default],
  accessors: true
}) {}
