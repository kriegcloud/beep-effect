import { entityKind, is } from "../entity";
import { SQL, type SQLWrapper, sql } from "../sql/sql";
import type { NonArray, Writable } from "../utils";
import { type PgEnum, type PgEnumObject, pgEnumObjectWithSchema, pgEnumWithSchema } from "./columns/enum";
import { type pgSequence, pgSequenceWithSchema } from "./sequence";
import { EnableRLS, type PgTableFn, type PgTableFnInternal, pgTableWithSchema } from "./table";
import { type pgMaterializedView, pgMaterializedViewWithSchema, type pgView, pgViewWithSchema } from "./view";

export class PgSchema<TName extends string = string> implements SQLWrapper {
  static readonly [entityKind]: string = "PgSchema";

  isExisting = false;
  constructor(public readonly schemaName: TName) {
    this.table = Object.assign(this.table, {
      withRLS: ((name, columns, extraConfig) => {
        const table = pgTableWithSchema(name, columns, extraConfig, this.schemaName);
        table[EnableRLS] = true;

        return table;
      }) as PgTableFnInternal<TName>,
    });
  }

  table: PgTableFn<TName> = ((name, columns, extraConfig) => {
    return pgTableWithSchema(name, columns, extraConfig, this.schemaName);
  }) as PgTableFn<TName>;

  view = ((name, columns) => {
    return pgViewWithSchema(name, columns, this.schemaName);
  }) as typeof pgView;

  materializedView = ((name, columns) => {
    return pgMaterializedViewWithSchema(name, columns, this.schemaName);
  }) as typeof pgMaterializedView;

  public enum<U extends string, T extends Readonly<[U, ...U[]]>>(
    enumName: string,
    values: T | Writable<T>
  ): PgEnum<Writable<T>>;

  public enum<E extends Record<string, string>>(enumName: string, enumObj: NonArray<E>): PgEnumObject<E>;

  public enum(enumName: any, input: any): any {
    return Array.isArray(input)
      ? pgEnumWithSchema(enumName, [...input] as [string, ...string[]], this.schemaName)
      : pgEnumObjectWithSchema(enumName, input, this.schemaName);
  }

  sequence: typeof pgSequence = (name, options) => {
    return pgSequenceWithSchema(name, options, this.schemaName);
  };

  getSQL(): SQL {
    return new SQL([sql.identifier(this.schemaName)]);
  }

  shouldOmitSQLParens(): boolean {
    return true;
  }

  existing(): this {
    this.isExisting = true;
    return this;
  }
}

export function isPgSchema(obj: unknown): obj is PgSchema {
  return is(obj, PgSchema);
}

export function pgSchema<T extends string>(name: T) {
  if (name === "public") {
    throw new Error(
      `You can't specify 'public' as schema name. Postgres is using public schema by default. If you want to use 'public' schema, just use pgTable() instead of creating a schema`
    );
  }

  return new PgSchema(name);
}
