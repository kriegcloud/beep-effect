import { LS_DEV, shouldNeverHappen } from "@beep/utils";
import { Chunk, Effect, Option, Schema } from "effect";
import type { PgDb } from "../adapter-types.ts";
import * as BeepEvent from "../schema/BeepEvent/mod.ts";
import * as EventSequenceNumber from "../schema/EventSequenceNumber/mod.ts";
import {
  EVENTLOG_META_TABLE,
  eventlogMetaTable,
  eventlogSystemTables,
  SYNC_STATUS_TABLE,
} from "../schema/state/pg/system-tables/eventlog-tables.ts";
import { sessionChangesetMetaTable } from "../schema/state/pg/system-tables/state-tables.ts";
import { migrateTable } from "../schema-management/migrations.ts";
import { insertRow, updateRows } from "../sql-queries/sql-queries.ts";
import type { PreparedBindValues } from "../util.ts";
import { sql } from "../util.ts";
import { execSql } from "./connection.ts";
import type { InitialSyncInfo, StreamEventsOptions } from "./types.ts";
import { LeaderThreadCtx, STREAM_EVENTS_BATCH_SIZE_DEFAULT } from "./types.ts";

export const initEventlogDb = (dbEventlog: PgDb) =>
  Effect.gen(function* () {
    for (const tableDef of eventlogSystemTables) {
      yield* migrateTable({
        db: dbEventlog,
        behaviour: "create-if-not-exists",
        tableAst: tableDef.pgDef.ast,
        skipMetaTable: true,
      });
    }

    // Create sync status row if it doesn't exist
    yield* execSql(
      dbEventlog,
      sql`INSERT INTO ${SYNC_STATUS_TABLE} (head)
          SELECT ${EventSequenceNumber.Client.ROOT.global}
          WHERE NOT EXISTS (SELECT 1 FROM ${SYNC_STATUS_TABLE})`,
      {}
    );
  });

/**
 * Exclusive of the "since event"
 * Also queries the state db in order to get the SQLite session changeset data.
 */
export const getEventsSince = ({
  dbEventlog,
  dbState,
  since,
}: {
  dbEventlog: PgDb;
  dbState: PgDb;
  since: EventSequenceNumber.Client.Composite;
}): ReadonlyArray<BeepEvent.Client.EncodedWithMeta> => {
  const pendingEvents = dbEventlog.select(eventlogMetaTable.where("seqNumGlobal", ">=", since.global));

  const sessionChangesetRowsDecoded = dbState.select(
    sessionChangesetMetaTable.where("seqNumGlobal", ">=", since.global)
  );

  return pendingEvents
    .map((eventlogEvent) => {
      const sessionChangeset = sessionChangesetRowsDecoded.find(
        (readModelEvent) =>
          readModelEvent.seqNumGlobal === eventlogEvent.seqNumGlobal &&
          readModelEvent.seqNumClient === eventlogEvent.seqNumClient
      );
      return BeepEvent.Client.EncodedWithMeta.make({
        name: eventlogEvent.name,
        args: eventlogEvent.argsJson,
        seqNum: {
          global: eventlogEvent.seqNumGlobal,
          client: eventlogEvent.seqNumClient,
          rebaseGeneration: eventlogEvent.seqNumRebaseGeneration,
        },
        parentSeqNum: {
          global: eventlogEvent.parentSeqNumGlobal,
          client: eventlogEvent.parentSeqNumClient,
          rebaseGeneration: eventlogEvent.parentSeqNumRebaseGeneration,
        },
        clientId: eventlogEvent.clientId,
        sessionId: eventlogEvent.sessionId,
        meta: {
          sessionChangeset:
            sessionChangeset && sessionChangeset.changeset !== null
              ? {
                  _tag: "sessionChangeset" as const,
                  data: sessionChangeset.changeset,
                  debug: sessionChangeset.debug,
                }
              : { _tag: "unset" as const },
          syncMetadata: eventlogEvent.syncMetadataJson,
          materializerHashLeader: Option.none(),
          materializerHashSession: Option.none(),
        },
      });
    })
    .filter((_) => EventSequenceNumber.Client.compare(_.seqNum, since) > 0)
    .sort((a, b) => EventSequenceNumber.Client.compare(a.seqNum, b.seqNum));
};

export const getEventsFromEventlog = ({
  dbEventlog,
  options,
}: {
  dbEventlog: PgDb;
  options: StreamEventsOptions;
}): Effect.Effect<Chunk.Chunk<BeepEvent.Client.Encoded>> =>
  Effect.gen(function* () {
    const since = options.since ?? EventSequenceNumber.Client.ROOT;
    const batchSize = options.batchSize ?? STREAM_EVENTS_BATCH_SIZE_DEFAULT;

    const makeQuery = () => {
      let query = eventlogMetaTable.where("seqNumGlobal", ">", since.global);

      if (options.until) {
        query = query.where("seqNumGlobal", "<=", options.until.global);
      }

      if (options.filter && options.filter.length > 0) {
        query = query.where({ name: { op: "IN", value: options.filter } });
      }

      if (options.clientIds && options.clientIds.length > 0) {
        query = query.where({ clientId: { op: "IN", value: options.clientIds } });
      }

      if (options.sessionIds && options.sessionIds.length > 0) {
        query = query.where({ sessionId: { op: "IN", value: options.sessionIds } });
      }

      if (options.includeClientOnly !== true) {
        query = query.where("seqNumClient", "<=", EventSequenceNumber.Client.DEFAULT);
      }

      return query
        .orderBy([
          { col: "seqNumGlobal", direction: "asc" },
          { col: "seqNumClient", direction: "asc" },
        ])
        .limit(batchSize);
    };

    const eventlogEvents = yield* Effect.sync(() => dbEventlog.select(makeQuery()));

    if (eventlogEvents.length === 0) {
      return Chunk.empty<BeepEvent.Client.Encoded>();
    }

    const spanAttributes = {
      "livestore.eventLog.since": since.global,
      "livestore.eventLog.until": options.until?.global,
    };

    return yield* Effect.sync(() => {
      const encodedEvents = eventlogEvents.map((eventlogEvent) => {
        return BeepEvent.Client.Encoded.make({
          name: eventlogEvent.name,
          args: eventlogEvent.argsJson,
          seqNum: {
            global: eventlogEvent.seqNumGlobal,
            client: eventlogEvent.seqNumClient,
            rebaseGeneration: eventlogEvent.seqNumRebaseGeneration,
          },
          parentSeqNum: {
            global: eventlogEvent.parentSeqNumGlobal,
            client: eventlogEvent.parentSeqNumClient,
            rebaseGeneration: eventlogEvent.parentSeqNumRebaseGeneration,
          },
          clientId: eventlogEvent.clientId,
          sessionId: eventlogEvent.sessionId,
        });
      });

      return Chunk.fromIterable(encodedEvents);
    }).pipe(Effect.withSpan("@beep/common:eventlog:getEventsFromEventlog", { attributes: spanAttributes }));
  });

export const getClientHeadFromDb = (dbEventlog: PgDb): EventSequenceNumber.Client.Composite => {
  const res = dbEventlog.select<{
    seqNumGlobal: EventSequenceNumber.Global.Type;
    seqNumClient: EventSequenceNumber.Client.Type;
    seqNumRebaseGeneration: number;
  }>(
    sql`select seqNumGlobal, seqNumClient, seqNumRebaseGeneration from ${EVENTLOG_META_TABLE} order by seqNumGlobal DESC, seqNumClient DESC limit 1`
  )[0];

  return res
    ? { global: res.seqNumGlobal, client: res.seqNumClient, rebaseGeneration: res.seqNumRebaseGeneration }
    : EventSequenceNumber.Client.ROOT;
};

export const getBackendHeadFromDb = (dbEventlog: PgDb): EventSequenceNumber.Global.Type =>
  dbEventlog.select<{ head: EventSequenceNumber.Global.Type }>(sql`select head from ${SYNC_STATUS_TABLE}`)[0]?.head ??
  EventSequenceNumber.Client.ROOT.global;

// TODO use prepared statements
export const updateBackendHead = (dbEventlog: PgDb, head: EventSequenceNumber.Client.Composite) =>
  dbEventlog.execute(sql`UPDATE ${SYNC_STATUS_TABLE} SET head = ${head.global}`);

export const getBackendIdFromDb = (dbEventlog: PgDb): Option.Option<string> =>
  Option.fromNullable(
    dbEventlog.select<{ backendId: string | null }>(sql`select backendId from ${SYNC_STATUS_TABLE}`)[0]?.backendId
  );

export const updateBackendId = (dbEventlog: PgDb, backendId: string) =>
  dbEventlog.execute(sql`UPDATE ${SYNC_STATUS_TABLE} SET backendId = '${backendId}'`);

export const insertIntoEventlog = (
  eventEncoded: BeepEvent.Client.EncodedWithMeta,
  dbEventlog: PgDb,
  eventDefSchemaHash: number,
  clientId: string,
  sessionId: string
) =>
  Effect.gen(function* () {
    // Check history consistency during LS_DEV
    if (LS_DEV && eventEncoded.parentSeqNum.global !== EventSequenceNumber.Client.ROOT.global) {
      const parentEventExists =
        dbEventlog.select<{ count: number }>(
          `SELECT COUNT(*) as count FROM ${EVENTLOG_META_TABLE} WHERE seqNumGlobal = ? AND seqNumClient = ?`,
          [eventEncoded.parentSeqNum.global, eventEncoded.parentSeqNum.client] as any as PreparedBindValues
        )[0]!.count === 1;

      if (parentEventExists === false) {
        shouldNeverHappen(
          `Parent event ${eventEncoded.parentSeqNum.global},${eventEncoded.parentSeqNum.client} does not exist in eventlog`
        );
      }
    }

    // TODO use prepared statements
    yield* execSql(
      dbEventlog,
      ...insertRow({
        tableName: EVENTLOG_META_TABLE,
        columns: eventlogMetaTable.pgDef.columns,
        values: {
          seqNumGlobal: eventEncoded.seqNum.global,
          seqNumClient: eventEncoded.seqNum.client,
          seqNumRebaseGeneration: eventEncoded.seqNum.rebaseGeneration,
          parentSeqNumGlobal: eventEncoded.parentSeqNum.global,
          parentSeqNumClient: eventEncoded.parentSeqNum.client,
          parentSeqNumRebaseGeneration: eventEncoded.parentSeqNum.rebaseGeneration,
          name: eventEncoded.name,
          argsJson: eventEncoded.args ?? {},
          clientId,
          sessionId,
          schemaHash: eventDefSchemaHash,
          syncMetadataJson: eventEncoded.meta.syncMetadata,
        },
      })
    );

    dbEventlog.debug.head = eventEncoded.seqNum;
  });

export const updateSyncMetadata = (items: ReadonlyArray<BeepEvent.Client.EncodedWithMeta>) =>
  Effect.gen(function* () {
    const { dbEventlog } = yield* LeaderThreadCtx;

    // TODO try to do this in a single query
    for (let i = 0; i < items.length; i++) {
      const event = items[i]!;

      yield* execSql(
        dbEventlog,
        ...updateRows({
          tableName: EVENTLOG_META_TABLE,
          columns: eventlogMetaTable.pgDef.columns,
          where: { seqNumGlobal: event.seqNum.global, seqNumClient: event.seqNum.client },
          updateValues: { syncMetadataJson: event.meta.syncMetadata },
        })
      );
    }
  });

export const getSyncBackendCursorInfo = ({ remoteHead }: { remoteHead: EventSequenceNumber.Global.Type }) =>
  Effect.gen(function* () {
    const { dbEventlog } = yield* LeaderThreadCtx;

    if (remoteHead === EventSequenceNumber.Client.ROOT.global) return Option.none();

    const EventlogQuerySchema = Schema.Struct({
      syncMetadataJson: Schema.parseJson(Schema.Option(Schema.JsonValue)),
    }).pipe(Schema.pluck("syncMetadataJson"), Schema.Array, Schema.head);

    const syncMetadataOption = yield* Effect.sync(() =>
      dbEventlog.select<{ syncMetadataJson: string }>(
        sql`SELECT syncMetadataJson FROM ${EVENTLOG_META_TABLE} WHERE seqNumGlobal = ${remoteHead} ORDER BY seqNumClient ASC LIMIT 1`
      )
    ).pipe(Effect.andThen(Schema.decode(EventlogQuerySchema)), Effect.map(Option.flatten), Effect.orDie);

    return Option.some({
      eventSequenceNumber: remoteHead,
      metadata: syncMetadataOption,
    }) satisfies InitialSyncInfo;
  }).pipe(Effect.withSpan("@beep/common:eventlog:getSyncBackendCursorInfo", { attributes: { remoteHead } }));
