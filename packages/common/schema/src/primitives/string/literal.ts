/**
 * Literal schema helpers that provide ergonomic defaults and property signatures.
 *
 * @example
 * import { LiteralDefaults, LiteralWithDefault } from "@beep/schema/primitives/string/literal";
 *
 * const Status = LiteralDefaults("draft", "published")("draft");
 * const StatusField = LiteralWithDefault("draft");
 *
 * @category Primitives/String
 * @since 0.1.0
 */

import type { StringTypes } from "@beep/types";
import type * as A from "effect/Array";
import * as S from "effect/Schema";
import type * as AST from "effect/SchemaAST";
import type { DefaultAnnotations } from "../../core/annotations/default";
import { $StringId } from "../../internal";

const { $LiteralId: Id } = $StringId.compose("literal");

/**
 * Builds literal schemas that automatically inject provided defaults.
 *
 * @example
 * import { LiteralDefaults } from "@beep/schema/primitives/string/literal";
 *
 * const StatusSchema = LiteralDefaults("draft", "published")("draft");
 *
 * @category Primitives/String
 * @since 0.1.0
 */
export function LiteralDefaults<const Literals extends A.NonEmptyReadonlyArray<AST.LiteralValue>>(
  ...literals: Literals
) {
  return (defaultValue: Literals[number]) => {
    return S.Literal(...literals)
      .pipe(
        S.optional,
        S.withDefaults({
          decoding: () => defaultValue,
          constructor: () => defaultValue,
        })
      )
      .annotations(
        Id.annotations("literal/LiteralDefaults", {
          default: defaultValue,
        })
      );
  };
}

/**
 * Namespace describing runtime and encoded types produced by {@link LiteralDefaults}.
 *
 * @example
 * import type { LiteralDefaults } from "@beep/schema/primitives/string/literal";
 *
 * type Status = LiteralDefaults.Type<readonly ["draft", "published"]>;
 *
 * @category Primitives/String
 * @since 0.1.0
 */
export declare namespace LiteralDefaults {
  /**
   * Runtime type alias provided by {@link LiteralDefaults}.
   *
   * @example
   * import type { LiteralDefaults } from "@beep/schema/primitives/string/literal";
   *
   * type Status = LiteralDefaults.Type<readonly ["draft", "published"]>;
   *
   * @category Primitives/String
   * @since 0.1.0
   */
  export type Type<Literals extends A.NonEmptyReadonlyArray<AST.LiteralValue>> = S.Schema.Type<
    ReturnType<typeof LiteralDefaults<Literals>>
  >;
  /**
   * Encoded type alias provided by {@link LiteralDefaults}.
   *
   * @example
   * import type { LiteralDefaults } from "@beep/schema/primitives/string/literal";
   *
   * type Status = LiteralDefaults.Encoded<readonly ["draft", "published"]>;
   *
   * @category Primitives/String
   * @since 0.1.0
   */
  export type Encoded<Literals extends A.NonEmptyReadonlyArray<AST.LiteralValue>> = S.Schema.Encoded<
    ReturnType<typeof LiteralDefaults<Literals>>
  >;
}

/**
 * Declares a literal property signature with a baked-in default value.
 *
 * @example
 * import { LiteralWithDefault } from "@beep/schema/primitives/string/literal";
 *
 * const StatusField = LiteralWithDefault("draft");
 *
 * @category Primitives/String
 * @since 0.1.0
 */
export const LiteralWithDefault = <const Literal extends StringTypes.NonEmptyString<string>>(
  value: Literal,
  annotations?: DefaultAnnotations<
    S.Schema.Type<S.PropertySignature<":", Exclude<Literal, undefined>, never, "?:", Literal | undefined, true, never>>
  >
): S.PropertySignature<":", Exclude<Literal, undefined>, never, "?:", Literal | undefined, true, never> =>
  S.Literal(value)
    .pipe(
      S.optional,
      S.withDefaults({
        constructor: () => value,
        decoding: () => value,
      })
    )
    .annotations(
      Id.annotations("literal/LiteralWithDefault", {
        ...annotations,
        default: value,
      })
    );

/**
 * Namespace exposing schema, runtime, and encoded types generated by {@link LiteralWithDefault}.
 *
 * @example
 * import type { LiteralWithDefault } from "@beep/schema/primitives/string/literal";
 *
 * type StatusField = LiteralWithDefault.Schema<"draft">;
 *
 * @category Primitives/String
 * @since 0.1.0
 */
export declare namespace LiteralWithDefault {
  /**
   * Schema type alias describing property signatures produced by {@link LiteralWithDefault}.
   *
   * @example
   * import type { LiteralWithDefault } from "@beep/schema/primitives/string/literal";
   *
   * type Field = LiteralWithDefault.Schema<"draft">;
   *
   * @category Primitives/String
   * @since 0.1.0
   */
  export type Schema<Literal extends string> = S.PropertySignature<
    ":",
    Exclude<Literal, undefined>,
    never,
    "?:",
    Literal | undefined,
    true,
    never
  >;
  /**
   * Runtime type alias for {@link LiteralWithDefault}.
   *
   * @example
   * import type { LiteralWithDefault } from "@beep/schema/primitives/string/literal";
   *
   * type FieldValue = LiteralWithDefault.Type<"draft">;
   *
   * @category Primitives/String
   * @since 0.1.0
   */
  export type Type<Literal extends string> = S.Schema.Type<Schema<Literal>>;
  /**
   * Encoded type alias for {@link LiteralWithDefault}.
   *
   * @example
   * import type { LiteralWithDefault } from "@beep/schema/primitives/string/literal";
   *
   * type FieldValue = LiteralWithDefault.Encoded<"draft">;
   *
   * @category Primitives/String
   * @since 0.1.0
   */
  export type Encoded<Literal extends string> = S.Schema.Encoded<Schema<Literal>>;
}

export function SignleLiteralWithEncodedDefault<const Literal extends AST.LiteralValue>(literal: Literal) {
  return LiteralDefaults(literal)(literal);
}
