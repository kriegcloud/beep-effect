import type { DefaultAnnotations } from "@beep/schema/annotations";
import type { UnsafeTypes } from "@beep/types";
import * as VariantSchema from "@effect/experimental/VariantSchema";
import * as M from "@effect/sql/Model";
import * as DateTime from "effect/DateTime";
import * as S from "effect/Schema";

const { Field } = VariantSchema.make({
  variants: ["select", "insert", "update", "json", "jsonCreate", "jsonUpdate"],
  defaultVariant: "select",
});

type Annotations<A, TypeParameters extends ReadonlyArray<UnsafeTypes.UnsafeAny> = readonly []> = Omit<
  DefaultAnnotations<A, TypeParameters>,
  "title" | "description"
> & {
  readonly title?: string;
  readonly description?: string;
};

/**
 * Optimal DateTime schemas for PostgresSQL with timezone support
 */
const dateTimeJsonSchemaAnnotations = (annotations?: Annotations<S.Schema.Type<typeof M.DateTimeFromDate>>) =>
  ({
    jsonSchema: {
      type: "string",
      format: "datetime",
    },
    ...annotations,
  }) as const;

export const DateTimeFromDate = (annotations?: Annotations<S.Schema.Type<typeof M.DateTimeFromDate>>) =>
  M.DateTimeFromDate.annotations(dateTimeJsonSchemaAnnotations(annotations));

/**
 * Make a field an Option for all variants, and omittable on write variants.
 *
 * Behavior by variant:
 * - select, json: required key; value is Option decoded from `S | null`
 * - insert, update, jsonCreate, jsonUpdate: key is omittable; when present, value is Option decoded from `S | null`
 *
 * Use this when a column may be null/absent but clients shouldn't be forced
 * to send the key on create/update requests.
 * - On update/jsonUpdate: missing key means "do not modify this field".
 * - On insert/jsonCreate: missing key lets defaults or DB behavior apply.
 * @since 1.0.0
 * @category optional
 */
export interface FieldOptionOmittable<S extends S.Schema.Any>
  extends VariantSchema.Field<{
    readonly select: S.OptionFromNullOr<S>;
    readonly insert: S.optionalWith<S.OptionFromNullOr<S>, { exact: true }>;
    readonly update: S.optionalWith<S.OptionFromNullOr<S>, { exact: true }>;
    readonly json: S.OptionFromNullOr<S>;
    readonly jsonCreate: S.optionalWith<S.OptionFromNullOr<S>, { exact: true }>;
    readonly jsonUpdate: S.optionalWith<S.OptionFromNullOr<S>, { exact: true }>;
  }> {}

/**
 * Make a field an Option for all variants, and omittable on write variants.
 *
 * Behavior by variant:
 * - select, json: required key; value is Option decoded from `S | null`
 * - insert, update, jsonCreate, jsonUpdate: key is omittable; when present, value is Option decoded from `S | null`
 *
 * Use this when a column may be null/absent but clients shouldn't be forced
 * to send the key on create/update requests.
 * - On update/jsonUpdate: missing key means "do not modify this field".
 * - On insert/jsonCreate: missing key lets defaults or DB behavior apply.
 * @since 1.0.0
 * @category optional
 */
export const FieldOptionOmittable = <S extends S.Schema.Any>(schema: S): FieldOptionOmittable<S> =>
  Field({
    select: S.OptionFromNullOr(schema),
    insert: S.optionalWith(S.OptionFromNullOr(schema), { exact: true }),
    update: S.optionalWith(S.OptionFromNullOr(schema), { exact: true }),
    json: S.OptionFromNullOr(schema),
    jsonCreate: S.optionalWith(S.OptionFromNullOr(schema), { exact: true }),
    jsonUpdate: S.optionalWith(S.OptionFromNullOr(schema), { exact: true }),
  });

/**
 * Make a field required everywhere except on update variants.
 *
 * Behavior by variant:
 * - select, insert, json, jsonCreate: required
 * - update, jsonUpdate: key is omittable (missing key allowed; when present, must satisfy `S`)
 * - When the key is missing, it will not be included in the update.
 * @since 1.0.0
 * @category optional
 */
export interface FieldUpdateOmittable<S extends S.Schema.Any>
  extends VariantSchema.Field<{
    readonly select: S;
    readonly insert: S;
    readonly update: S.optionalWith<S, { exact: true }>;
    readonly json: S;
    readonly jsonCreate: S;
    readonly jsonUpdate: S.optionalWith<S, { exact: true }>;
  }> {}

/**
 * Make a field required everywhere except on update variants.
 *
 * Behavior by variant:
 * - select, insert, json, jsonCreate: required
 * - update, jsonUpdate: key is omittable (missing key allowed; when present, must satisfy `S`)
 * - When the key is missing, it will not be included in the update.
 * @since 1.0.0
 * @category optional
 */
export const FieldUpdateOmittable = <S extends S.Schema.Any>(schema: S): FieldUpdateOmittable<S> =>
  Field({
    select: schema,
    insert: schema,
    update: S.optionalWith(schema, { exact: true }),
    json: schema,
    jsonCreate: schema,
    jsonUpdate: S.optionalWith(schema, { exact: true }),
  });

/**
 * Make a field required everywhere except on write variants. Used when a field is generated by the database.
 *
 * Behavior by variant:
 * - select, json: required key; value is S
 * - insert, update, jsonCreate, jsonUpdate: key is omittable; when present, value is decoded from `S`
 * - When the key is missing, it will not be included in the update.
 */
export interface FieldWriteOmittable<S extends S.Schema.Any>
  extends VariantSchema.Field<{
    readonly select: S;
    readonly insert: S.optionalWith<S, { exact: true }>;
    readonly update: S.optionalWith<S, { exact: true }>;
    readonly json: S;
    readonly jsonCreate: S.optionalWith<S, { exact: true }>;
    readonly jsonUpdate: S.optionalWith<S, { exact: true }>;
  }> {}

/**
 * Make a field required everywhere except on write variants. Used when a field is generated by the database.
 *
 * Behavior by variant:
 * - select, json: required key; value is S
 * - insert, update, jsonCreate, jsonUpdate: key is omittable; when present, value is decoded from `S`
 * - When the key is missing, it will not be included in the update.
 */
export const FieldWriteOmittable = <TSchema extends S.Schema.Any>(schema: TSchema): FieldWriteOmittable<TSchema> =>
  Field({
    select: schema,
    insert: S.optionalWith(schema, { exact: true }),
    update: S.optionalWith(schema, { exact: true }),
    json: schema,
    jsonCreate: S.optionalWith(schema, { exact: true }),
    jsonUpdate: S.optionalWith(schema, { exact: true }),
  });

export const DateTimeInsertFromDateOmittable = (annotations?: Annotations<S.Schema.Type<typeof M.DateTimeFromDate>>) =>
  DateTimeFromDate().pipe(
    M.fieldEvolve({
      select: (variant: M.DateTimeFromDate) => variant,
      insert: (variant: M.DateTimeFromDate) =>
        S.optionalWith(variant, { exact: true, default: () => DateTime.unsafeNow() }),
      update: (variant: M.DateTimeFromDate) =>
        S.optionalWith(variant, { exact: true, default: () => DateTime.unsafeNow() }),
      json: (variant: M.DateTimeFromDate) => variant,
      jsonCreate: (variant: M.DateTimeFromDate) =>
        S.optionalWith(variant, { exact: true, default: () => DateTime.unsafeNow() }),
      jsonUpdate: (variant: M.DateTimeFromDate) =>
        S.optionalWith(variant, { exact: true, default: () => DateTime.unsafeNow() }),
    })
  );

export const DateTimeUpdateFromDateOmittable = (annotations?: Annotations<S.Schema.Type<typeof M.DateTimeFromDate>>) =>
  DateTimeFromDate().pipe(
    M.fieldEvolve({
      select: (variant: M.DateTimeFromDate) => variant,
      insert: (variant: M.DateTimeFromDate) => S.optional(variant),
      update: (variant: M.DateTimeFromDate) =>
        S.optionalWith(variant, { exact: true, default: () => DateTime.unsafeNow() }),
      json: (variant: M.DateTimeFromDate) => variant,
      jsonCreate: (variant: M.DateTimeFromDate) => variant,
      jsonUpdate: (variant: M.DateTimeFromDate) =>
        S.optionalWith(variant, { exact: true, default: () => DateTime.unsafeNow() }),
    })
  );

/**
 * Make a field an Option for all variants, and omittable on write variants.
 *
 * Behavior by variant:
 * - select, json: required key; value is Option decoded from `S | null`
 * - insert, update, jsonCreate, jsonUpdate: key is omittable; when present, value is Option decoded from `S | null`
 *
 * Use this when a column may be null/absent but clients shouldn't be forced
 * to send the key on create/update requests.
 * - On update/jsonUpdate: missing key means "do not modify this field".
 * - On insert/jsonCreate: missing key lets defaults or DB behavior apply.
 * @since 1.0.0
 * @category optional
 */
export interface FieldSensitiveOptionOmittable<S extends S.Schema.Any>
  extends VariantSchema.Field<{
    readonly select: S.OptionFromNullOr<S.Redacted<S>>;
    readonly insert: S.optionalWith<S.OptionFromNullOr<S.Redacted<S>>, { exact: true }>;
    readonly update: S.optionalWith<S.OptionFromNullOr<S.Redacted<S>>, { exact: true }>;
    readonly json: S.OptionFromNullOr<S.Redacted<S>>;
    readonly jsonCreate: S.optionalWith<S.OptionFromNullOr<S.Redacted<S>>, { exact: true }>;
    readonly jsonUpdate: S.optionalWith<S.OptionFromNullOr<S.Redacted<S>>, { exact: true }>;
  }> {}

/**
 * Make a field an Option for all variants, and omittable on write variants.
 *
 * Behavior by variant:
 * - select, json: required key; value is Option decoded from `S | null`
 * - insert, update, jsonCreate, jsonUpdate: key is omittable; when present, value is Option decoded from `S | null`
 *
 * Use this when a column may be null/absent but clients shouldn't be forced
 * to send the key on create/update requests.
 * - On update/jsonUpdate: missing key means "do not modify this field".
 * - On insert/jsonCreate: missing key lets defaults or DB behavior apply.
 * @since 1.0.0
 * @category optional
 */
export const FieldSensitiveOptionOmittable = <S extends S.Schema.Any>(schema: S): FieldSensitiveOptionOmittable<S> =>
  Field({
    select: S.OptionFromNullOr(S.Redacted(schema)),
    insert: S.optionalWith(S.OptionFromNullOr(S.Redacted(schema)), { exact: true }),
    update: S.optionalWith(S.OptionFromNullOr(S.Redacted(schema)), { exact: true }),
    json: S.OptionFromNullOr(S.Redacted(schema)),
    jsonCreate: S.optionalWith(S.OptionFromNullOr(S.Redacted(schema)), { exact: true }),
    jsonUpdate: S.optionalWith(S.OptionFromNullOr(S.Redacted(schema)), { exact: true }),
  });

/**
 * Nullable JSON field stored as text in the database with Option semantics.
 *
 * Behavior by variant:
 * - select: required key; value decoded as Option from `string | null`
 * - insert, update: key is omittable; when present, value decoded as Option from `string | null`
 * - json: required key; value decoded as Option from `S | null`
 * - jsonCreate, jsonUpdate: key is omittable; when present, value decoded as Option from `S | null`
 *
 * This mirrors `M.FieldOption(M.JsonFromString(schema))` but ensures the encoded
 * shape for database selections is `string | null` (no `undefined`), matching
 * Drizzle models for nullable text columns.
 */
export const JsonFromStringOption = <TSchema extends S.Schema.All>(schema: TSchema) =>
  M.JsonFromString(schema).pipe(
    M.fieldEvolve({
      select: (variant) => S.OptionFromNullOr(S.asSchema(variant)),
      insert: (variant) => S.optionalWith(S.OptionFromNullOr(S.asSchema(variant)), { exact: true }),
      update: (variant) => S.optionalWith(S.OptionFromNullOr(S.asSchema(variant)), { exact: true }),
      json: (variant) => S.OptionFromNullOr(S.asSchema(variant)),
      jsonCreate: (variant) => S.optionalWith(S.OptionFromNullOr(S.asSchema(variant)), { exact: true }),
      jsonUpdate: (variant) => S.optionalWith(S.OptionFromNullOr(S.asSchema(variant)), { exact: true }),
    })
  );
