import * as VariantSchema from "@beep/schema/core/VariantSchema";
import type * as B from "effect/Brand";
import * as DateTime from "effect/DateTime";
import * as Effect from "effect/Effect";
import * as O from "effect/Option";
import * as ParseResult from "effect/ParseResult";
import * as S from "effect/Schema";
import * as Uuid from "uuid";
// import * as AST from "effect/SchemaAST";

const {
  Class,
  Field,
  FieldExcept,
  FieldOnly,
  Struct,
  Union,
  extract,
  fieldEvolve,
  fieldFromKey
} = VariantSchema.make({
  variants: ["select", "insert", "update", "json", "jsonCreate", "jsonUpdate"],
  defaultVariant: "select"
});


/**
 * @since 1.0.0
 * @category models
 */
export type Any = S.Schema.Any & {
  readonly fields: S.Struct.Fields
  readonly insert: S.Schema.Any
  readonly update: S.Schema.Any
  readonly json: S.Schema.Any
  readonly jsonCreate: S.Schema.Any
  readonly jsonUpdate: S.Schema.Any
}

/**
 * @since 1.0.0
 * @category models
 */
export type AnyNoContext = S.Schema.AnyNoContext & {
  readonly fields: S.Struct.Fields
  readonly insert: S.Schema.AnyNoContext
  readonly update: S.Schema.AnyNoContext
  readonly json: S.Schema.AnyNoContext
  readonly jsonCreate: S.Schema.AnyNoContext
  readonly jsonUpdate: S.Schema.AnyNoContext
}

/**
 * @since 1.0.0
 * @category models
 */
export type VariantsDatabase = "select" | "insert" | "update"

/**
 * @since 1.0.0
 * @category models
 */
export type VariantsJson = "json" | "jsonCreate" | "jsonUpdate"

export {
  /**
   * A base class used for creating domain model schemas.
   *
   * It supports common variants for database and JSON apis.
   *
   * @since 1.0.0
   * @category constructors
   * @example
   * ```ts
   * import { Schema } from "effect"
   * import { Model } from "@effect/sql"
   *
   * export const GroupId = Schema.Number.pipe(S.brand("GroupId"))
   *
   * export class Group extends Model.Class<Group>("Group")({
   *   id: Model.Generated(GroupId),
   *   name: Schema.NonEmptyTrimmedString,
   *   createdAt: Model.DateTimeInsertFromDate,
   *   updatedAt: Model.DateTimeUpdateFromDate
   * }) {}
   *
   * // schema used for selects
   * Group
   *
   * // schema used for inserts
   * Group.insert
   *
   * // schema used for updates
   * Group.update
   *
   * // schema used for json api
   * Group.json
   * Group.jsonCreate
   * Group.jsonUpdate
   *
   * // you can also turn them into classes
   * class GroupJson extends Schema.Class<GroupJson>("GroupJson")(Group.json) {
   *   get upperName() {
   *     return this.name.toUpperCase()
   *   }
   * }
   * ```
   */
    Class,
  /**
   * @since 1.0.0
   * @category extraction
   */
    extract,
  /**
   * @since 1.0.0
   * @category fields
   */
    Field,
  /**
   * @since 1.0.0
   * @category fields
   */
    fieldEvolve,
  /**
   * @since 1.0.0
   * @category fields
   */
    FieldExcept,
  /**
   * @since 1.0.0
   * @category fields
   */
    fieldFromKey,
  /**
   * @since 1.0.0
   * @category fields
   */
    FieldOnly,
  /**
   * @since 1.0.0
   * @category constructors
   */
    Struct,
  /**
   * @since 1.0.0
   * @category constructors
   */
    Union
};

/**
 * @since 1.0.0
 * @category fields
 */
export const fields: <A extends VariantSchema.Struct<any>>(self: A) => A[VariantSchema.TypeId] = VariantSchema.fields;

/**
 * @since 1.0.0
 * @category overrideable
 */
export const Override: <A>(value: A) => A & B.Brand<"Override"> = VariantSchema.Override;

/**
 * @since 1.0.0
 * @category generated
 */
export interface Generated<S extends S.Schema.All | S.PropertySignature.All> extends VariantSchema.Field<{
  readonly select: S
  readonly update: S
  readonly json: S
}> {
}

/**
 * A field that represents a column that is generated by the database.
 *
 * It is available for selection and update, but not for insertion.
 *
 * @since 1.0.0
 * @category generated
 */
export const Generated = <S extends S.Schema.All | S.PropertySignature.All>(
  schema: S
): Generated<S> =>
  Field({
    select: schema,
    update: schema,
    json: schema
  });

/**
 * @since 1.0.0
 * @category generated
 */
export interface GeneratedByApp<S extends S.Schema.All | S.PropertySignature.All>
  extends VariantSchema.Field<{
    readonly select: S
    readonly insert: S
    readonly update: S
    readonly json: S
  }> {
}

/**
 * A field that represents a column that is generated by the application.
 *
 * It is required by the database, but not by the JSON variants.
 *
 * @since 1.0.0
 * @category generated
 */
export const GeneratedByApp = <S extends S.Schema.All | S.PropertySignature.All>(
  schema: S
): GeneratedByApp<S> =>
  Field({
    select: schema,
    insert: schema,
    update: schema,
    json: schema
  });

/**
 * @since 1.0.0
 * @category sensitive
 */
export interface Sensitive<S extends S.Schema.All | S.PropertySignature.All> extends VariantSchema.Field<{
  readonly select: S
  readonly insert: S
  readonly update: S
}> {
}

/**
 * A field that represents a sensitive value that should not be exposed in the
 * JSON variants.
 *
 * @since 1.0.0
 * @category sensitive
 */
export const Sensitive = <S extends S.Schema.All | S.PropertySignature.All>(
  schema: S
): Sensitive<S> =>
  Field({
    select: schema,
    insert: schema,
    update: schema
  });

/**
 * Convert a field to one that is optional for all variants.
 *
 * For the database variants, it will accept `null`able values.
 * For the JSON variants, it will also accept missing keys.
 *
 * @since 1.0.0
 * @category optional
 */
export interface FieldOption<S extends S.Schema.Any> extends VariantSchema.Field<{
  readonly select: S.OptionFromNullOr<S>
  readonly insert: S.OptionFromNullOr<S>
  readonly update: S.OptionFromNullOr<S>
  readonly json: S.optionalWith<S, { as: "Option" }>
  readonly jsonCreate: S.optionalWith<S, { as: "Option"; nullable: true }>
  readonly jsonUpdate: S.optionalWith<S, { as: "Option"; nullable: true }>
}> {
}

/**
 * Convert a field to one that is optional for all variants.
 *
 * For the database variants, it will accept `null`able values.
 * For the JSON variants, it will also accept missing keys.
 *
 * @since 1.0.0
 * @category optional
 */
export const FieldOption: <Field extends VariantSchema.Field<any> | S.Schema.Any>(
  self: Field
) => Field extends S.Schema.Any ? FieldOption<Field>
  : Field extends VariantSchema.Field<infer S> ? VariantSchema.Field<
      {
        readonly [K in keyof S]: S[K] extends S.Schema.Any
        ? K extends VariantsDatabase ? S.OptionFromNullOr<S[K]> :
          S.optionalWith<S[K], { as: "Option"; nullable: true }>
        : never
      }
    > :
    never = fieldEvolve({
  select: S.OptionFromNullOr,
  insert: S.OptionFromNullOr,
  update: S.OptionFromNullOr,
  json: S.optionalWith({as: "Option"}),
  jsonCreate: S.optionalWith({as: "Option", nullable: true}),
  jsonUpdate: S.optionalWith({as: "Option", nullable: true})
}) as any;

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeFromDate extends S.transform<
  typeof S.ValidDateFromSelf,
  typeof S.DateTimeUtcFromSelf
> {
}

/**
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeFromDate: DateTimeFromDate = S.transform(
  S.ValidDateFromSelf,
  S.DateTimeUtcFromSelf,
  {
    decode: DateTime.unsafeFromDate,
    encode: DateTime.toDateUtc
  }
);

/**
 * @since 1.0.0
 * @category date & time
 */
export interface Date extends S.transformOrFail<typeof S.String, typeof S.DateTimeUtcFromSelf> {
}

/**
 * A schema for a `DateTime.Utc` that is serialized as a date string in the
 * format `YYYY-MM-DD`.
 *
 * @since 1.0.0
 * @category date & time
 */
export const Date: Date = S.transformOrFail(
  S.String,
  S.DateTimeUtcFromSelf,
  {
    decode: (s, _, ast) =>
      DateTime.make(s).pipe(
        O.map(DateTime.removeTime),
        O.match({
          onNone: () => ParseResult.fail(new ParseResult.Type(ast, s)),
          onSome: (dt) => ParseResult.succeed(dt)
        })
      ),
    encode: (dt) => ParseResult.succeed(DateTime.formatIsoDate(dt))
  }
);

/**
 * @since 1.0.0
 * @category date & time
 */
export const DateWithNow = VariantSchema.Overrideable(Date, S.DateTimeUtcFromSelf, {
  generate: O.match({
    onNone: () => Effect.map(DateTime.now, DateTime.removeTime),
    onSome: (dt) => Effect.succeed(DateTime.removeTime(dt))
  })
});

/**
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeWithNow = VariantSchema.Overrideable(S.String, S.DateTimeUtcFromSelf, {
  generate: O.match({
    onNone: () => Effect.map(DateTime.now, DateTime.formatIso),
    onSome: (dt) => Effect.succeed(DateTime.formatIso(dt))
  }),
  decode: S.DateTimeUtc
});

/**
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeFromDateWithNow = VariantSchema.Overrideable(S.DateFromSelf, S.DateTimeUtcFromSelf, {
  generate: O.match({
    onNone: () => Effect.map(DateTime.now, DateTime.toDateUtc),
    onSome: (dt) => Effect.succeed(DateTime.toDateUtc(dt))
  }),
  decode: DateTimeFromDate
});

/**
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeFromNumberWithNow = VariantSchema.Overrideable(S.Number, S.DateTimeUtcFromSelf, {
  generate: O.match({
    onNone: () => Effect.map(DateTime.now, DateTime.toEpochMillis),
    onSome: (dt) => Effect.succeed(DateTime.toEpochMillis(dt))
  }),
  decode: S.DateTimeUtcFromNumber
});

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeInsert extends VariantSchema.Field<{
  readonly select: typeof S.DateTimeUtc
  readonly insert: VariantSchema.Overrideable<DateTime.Utc, string>
  readonly json: typeof S.DateTimeUtc
}> {
}

/**
 * A field that represents a date-time value that is inserted as the current
 * `DateTime.Utc`. It is serialized as a string for the database.
 *
 * It is omitted from updates and is available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeInsert: DateTimeInsert = Field({
  select: S.DateTimeUtc,
  insert: DateTimeWithNow,
  json: S.DateTimeUtc
});

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeInsertFromDate extends VariantSchema.Field<{
  readonly select: DateTimeFromDate
  readonly insert: VariantSchema.Overrideable<DateTime.Utc, globalThis.Date>
  readonly json: typeof S.DateTimeUtc
}> {
}

/**
 * A field that represents a date-time value that is inserted as the current
 * `DateTime.Utc`. It is serialized as a `Date` for the database.
 *
 * It is omitted from updates and is available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeInsertFromDate: DateTimeInsertFromDate = Field({
  select: DateTimeFromDate,
  insert: DateTimeFromDateWithNow,
  json: S.DateTimeUtc
});

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeInsertFromNumber extends VariantSchema.Field<{
  readonly select: typeof S.DateTimeUtcFromNumber
  readonly insert: VariantSchema.Overrideable<DateTime.Utc, number>
  readonly json: typeof S.DateTimeUtcFromNumber
}> {
}

/**
 * A field that represents a date-time value that is inserted as the current
 * `DateTime.Utc`. It is serialized as a `number`.
 *
 * It is omitted from updates and is available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeInsertFromNumber: DateTimeInsertFromNumber = Field({
  select: S.DateTimeUtcFromNumber,
  insert: DateTimeFromNumberWithNow,
  json: S.DateTimeUtcFromNumber
});

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeUpdate extends VariantSchema.Field<{
  readonly select: typeof S.DateTimeUtc
  readonly insert: VariantSchema.Overrideable<DateTime.Utc, string>
  readonly update: VariantSchema.Overrideable<DateTime.Utc, string>
  readonly json: typeof S.DateTimeUtc
}> {
}

/**
 * A field that represents a date-time value that is updated as the current
 * `DateTime.Utc`. It is serialized as a string for the database.
 *
 * It is set to the current `DateTime.Utc` on updates and inserts and is
 * available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeUpdate: DateTimeUpdate = Field({
  select: S.DateTimeUtc,
  insert: DateTimeWithNow,
  update: DateTimeWithNow,
  json: S.DateTimeUtc
});

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeUpdateFromDate extends VariantSchema.Field<{
  readonly select: DateTimeFromDate
  readonly insert: VariantSchema.Overrideable<DateTime.Utc, globalThis.Date>
  readonly update: VariantSchema.Overrideable<DateTime.Utc, globalThis.Date>
  readonly json: typeof S.DateTimeUtc
}> {
}

/**
 * A field that represents a date-time value that is updated as the current
 * `DateTime.Utc`. It is serialized as a `Date` for the database.
 *
 * It is set to the current `DateTime.Utc` on updates and inserts and is
 * available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeUpdateFromDate: DateTimeUpdateFromDate = Field({
  select: DateTimeFromDate,
  insert: DateTimeFromDateWithNow,
  update: DateTimeFromDateWithNow,
  json: S.DateTimeUtc
});

/**
 * @since 1.0.0
 * @category date & time
 */
export interface DateTimeUpdateFromNumber extends VariantSchema.Field<{
  readonly select: typeof S.DateTimeUtcFromNumber
  readonly insert: VariantSchema.Overrideable<DateTime.Utc, number>
  readonly update: VariantSchema.Overrideable<DateTime.Utc, number>
  readonly json: typeof S.DateTimeUtcFromNumber
}> {
}

/**
 * A field that represents a date-time value that is updated as the current
 * `DateTime.Utc`. It is serialized as a `number`.
 *
 * It is set to the current `DateTime.Utc` on updates and inserts and is
 * available for selection.
 *
 * @since 1.0.0
 * @category date & time
 */
export const DateTimeUpdateFromNumber: DateTimeUpdateFromNumber = Field({
  select: S.DateTimeUtcFromNumber,
  insert: DateTimeFromNumberWithNow,
  update: DateTimeFromNumberWithNow,
  json: S.DateTimeUtcFromNumber
});

/**
 * @since 1.0.0
 * @category json
 */
export interface JsonFromString<S extends S.Schema.All | S.PropertySignature.All>
  extends VariantSchema.Field<{
    readonly select: S.Schema<S.Schema.Type<S>, string, S.Schema.Context<S>>
    readonly insert: S.Schema<S.Schema.Type<S>, string, S.Schema.Context<S>>
    readonly update: S.Schema<S.Schema.Type<S>, string, S.Schema.Context<S>>
    readonly json: S
    readonly jsonCreate: S
    readonly jsonUpdate: S
  }> {
}

/**
 * A field that represents a JSON value stored as text in the database.
 *
 * The "json" variants will use the object schema directly.
 *
 * @since 1.0.0
 * @category json
 */
export const JsonFromString = <S extends S.Schema.All | S.PropertySignature.All>(
  schema: S
): JsonFromString<S> => {
  const parsed = S.parseJson(schema as any);
  return Field({
    select: parsed,
    insert: parsed,
    update: parsed,
    json: schema,
    jsonCreate: schema,
    jsonUpdate: schema
  }) as any;
};

/**
 * @since 1.0.0
 * @category uuid
 */
export interface UuidV4Insert<B extends string | symbol> extends VariantSchema.Field<{
  readonly select: S.brand<typeof S.Uint8ArrayFromSelf, B>
  readonly insert: VariantSchema.Overrideable<Uint8Array & B.Brand<B>, Uint8Array>
  readonly update: S.brand<typeof S.Uint8ArrayFromSelf, B>
  readonly json: S.brand<typeof S.Uint8ArrayFromSelf, B>
}> {
}

/**
 * @since 1.0.0
 * @category uuid
 */
export const UuidV4WithGenerate = <B extends string | symbol>(
  schema: S.brand<typeof S.Uint8ArrayFromSelf, B>
): VariantSchema.Overrideable<Uint8Array & B.Brand<B>, Uint8Array> =>
  VariantSchema.Overrideable(S.Uint8ArrayFromSelf, schema, {
    generate: O.match({
      onNone: () => Effect.sync(() => Uuid.v4({}, new Uint8Array(16))),
      onSome: (id) => Effect.succeed(id as any)
    }),
    decode: S.Uint8ArrayFromSelf,
    constructorDefault: () => Uuid.v4({}, new Uint8Array(16)) as any
  });

/**
 * A field that represents a binary UUID v4 that is generated on inserts.
 *
 * @since 1.0.0
 * @category uuid
 */
export const UuidV4Insert = <const B extends string | symbol>(
  schema: S.brand<typeof S.Uint8ArrayFromSelf, B>
): UuidV4Insert<B> =>
  Field({
    select: schema,
    insert: UuidV4WithGenerate(schema),
    update: schema,
    json: schema
  });

/**
 * A boolean parsed from 0 or 1
 *
 * @since 1.0.0
 * @category uuid
 */
export class BooleanFromNumber extends S.transform(
  S.Literal(0, 1),
  S.Boolean,
  {
    decode: (n) => n === 1,
    encode: (b) => b ? 1 : 0
  }
) {
}

// const isParseJsonTransformation = (ast: AST.AST): boolean =>
//   ast.annotations[AST.SchemaIdAnnotationId] === AST.ParseJsonSchemaId;

// const toDsl = <SqlModel extends Any>(
//   model: SqlModel
// ) => {
//   const ast = AST.isTransformation(model.ast) && isParseJsonTransformation(model.ast.from)
//     // Special case top level `parseJson` transformations
//     ? model.ast.to
//     : model.ast;
//
//
// };