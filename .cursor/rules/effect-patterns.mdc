---
alwaysApply: false
description: "Effect-patterns rules"

globs:
  - "**/*.ts"
  - "**/*.tsx"
---


# Effect Patterns

## Namespace Imports (REQUIRED)

ALWAYS use namespace imports for Effect modules:

```typescript
// Core Effect modules - full namespace
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Context from "effect/Context";
import * as Struct from "effect/Struct";
import * as Cause from "effect/Cause";
```

## Single-Letter Aliases (REQUIRED)

Use abbreviated aliases for frequently used modules:

```typescript
import * as A from "effect/Array";
import * as BI from "effect/BigInt";
import * as Num from "effect/Number";
import * as P from "effect/Predicate";
import * as F from "effect/Function";
import * as O from "effect/Option";
import * as R from "effect/Record";
import * as S from "effect/Schema";
import * as Str from "effect/String";
import * as B from "effect/Brand";
import * as Bool from "effect/Boolean";
import * as AST from "effect/SchemaAST";
import * as DateTime from "effect/DateTime";
import * as Match from "effect/Match";
import * as M from "@effect/sql/Model";
```

## PascalCase Constructors (REQUIRED)

ALWAYS use PascalCase exports from Schema and other modules:

```typescript
// REQUIRED - PascalCase constructors
S.Struct({ name: S.String })
S.Array(S.Number)
S.String
S.Number
S.Boolean
S.Literal("active", "inactive")
S.Union(S.String, S.Number)
```

NEVER use lowercase constructors:

```typescript
// FORBIDDEN
S.struct({ name: S.string })  // Wrong!
S.array(S.number)              // Wrong!
```

## Alias Reference Table

| Module             | Alias      |
|--------------------|------------|
| effect/Array       | A          |
| effect/BigInt      | BI         |
| effect/Number      | Num        |
| effect/Predicate   | P          |
| effect/Function    | F          |
| effect/Option      | O          |
| effect/Record      | R          |
| effect/Schema      | S          |
| effect/String      | Str        |
| effect/Brand       | B          |
| effect/Boolean     | Bool       |
| effect/SchemaAST   | AST        |
| effect/DateTime    | DateTime   |
| effect/Match       | Match      |
| @effect/sql/Model  | M          |

## Native Method Ban

NEVER use native JavaScript array/string methods. Route ALL operations through Effect utilities:

```typescript
// FORBIDDEN
array.map(x => x + 1)
string.split(",")
array.filter(x => x > 0)

// REQUIRED
A.map(array, x => x + 1)
Str.split(string, ",")
A.filter(array, x => x > 0)
```

## Schema Type Selection

ALWAYS choose the correct Effect Schema type based on the runtime value:

| Runtime Value | Effect Schema | Example |
|---------------|---------------|---------|
| JavaScript `Date` object | `S.Date` | `createdAt: S.Date` |
| ISO 8601 string | `S.DateFromString` | `timestamp: S.DateFromString` |
| `string \| undefined` | `S.optional(S.String)` | `nickname: S.optional(S.String)` |
| `string \| null \| undefined` | `S.optionalWith(S.String, { nullable: true })` | `ipAddress: S.optionalWith(S.String, { nullable: true })` |
| User credential (password, API key) | `S.Redacted(S.String)` | `password: S.Redacted(S.String)` |
| Server-generated token | `S.String` | `sessionToken: S.String` |

**Key Decisions:**

- Use `S.Date` when working with JavaScript Date objects in memory
- Use `S.DateFromString` when receiving ISO 8601 strings from APIs or JSON
- Use `S.optional` for values that may be `undefined`
- Use `S.optionalWith({ nullable: true })` for values that may be `null` OR `undefined`
- Use `S.Redacted` for user-provided credentials to suppress logging
- Use plain `S.String` for server-generated tokens (already protected)

## BS Helper Reference (@beep/schema)

The `@beep/schema` package (imported as `BS`) provides specialized helpers for common schema patterns. ALWAYS prefer BS helpers over manual schema composition when available.

### Helper Quick Reference

```typescript
import { BS } from "@beep/schema";

// Boolean with default value
BS.BoolWithDefault(false)                    // Defaults to false if undefined

// Optional fields (omitted when undefined)
BS.FieldOptionOmittable(S.String)            // Optional field, omitted in output when undefined

// Sensitive + Optional (suppresses logging)
BS.FieldSensitiveOptionOmittable(S.String)   // Optional sensitive field, never logged

// DateTime helpers
BS.DateTimeUtcFromAllAcceptable              // DateTime accepting multiple input formats

// Validated primitives
BS.EmailBase                                 // Email validation schema
BS.NonEmptyString                            // Non-empty string validation
```

### Helper Selection Guide

| Use Case | BS Helper | Example |
|----------|-----------|---------|
| Boolean field with default | `BS.BoolWithDefault(value)` | `isActive: BS.BoolWithDefault(true)` |
| Optional non-sensitive field | `BS.FieldOptionOmittable(schema)` | `nickname: BS.FieldOptionOmittable(S.String)` |
| Optional sensitive field | `BS.FieldSensitiveOptionOmittable(schema)` | `apiKey: BS.FieldSensitiveOptionOmittable(S.String)` |
| DateTime from any format | `BS.DateTimeUtcFromAllAcceptable` | `timestamp: BS.DateTimeUtcFromAllAcceptable` |
| Email validation | `BS.EmailBase` | `email: BS.EmailBase` |
| Non-empty string | `BS.NonEmptyString` | `username: BS.NonEmptyString` |

**Common Mistakes:**

```typescript
// WRONG - Using deprecated pattern
const Schema = S.Struct({
  enabled: BS.toOptionalWithDefault(S.Boolean, false)  // Deprecated!
});

// CORRECT - Using modern BS helper
const Schema = S.Struct({
  enabled: BS.BoolWithDefault(false)
});
```

## Sensitive Field Guidelines

ALWAYS use sensitive field wrappers for data that could enable impersonation or system compromise if leaked through logs or error messages.

### When to Mark Fields as Sensitive

**ALWAYS mark as sensitive:**

```typescript
// User credentials
password: BS.FieldSensitiveOptionOmittable(S.String)
hashedPassword: BS.FieldSensitiveOptionOmittable(S.String)
apiKey: BS.FieldSensitiveOptionOmittable(S.String)
apiSecret: BS.FieldSensitiveOptionOmittable(S.String)

// OAuth tokens
accessToken: BS.FieldSensitiveOptionOmittable(S.String)
refreshToken: BS.FieldSensitiveOptionOmittable(S.String)
idToken: BS.FieldSensitiveOptionOmittable(S.String)

// Session & authentication tokens
sessionToken: BS.FieldSensitiveOptionOmittable(S.String)
csrfToken: BS.FieldSensitiveOptionOmittable(S.String)

// Private keys & secrets
privateKey: BS.FieldSensitiveOptionOmittable(S.String)
signingSecret: BS.FieldSensitiveOptionOmittable(S.String)
encryptionKey: BS.FieldSensitiveOptionOmittable(S.String)
```

**NEVER mark as sensitive (unnecessary overhead):**

```typescript
// Server-generated UUIDs/IDs - no security value in hiding
id: S.String
userId: S.String

// Timestamps - public metadata
createdAt: S.Date
updatedAt: S.Date

// Public identifiers - meant to be shared
email: BS.EmailBase
username: S.String
organizationId: S.String

// Non-sensitive enums/literals
status: S.Literal("active", "inactive")
role: S.Literal("admin", "member")
```

### Decision Criteria

Ask: "If this value appeared in application logs, could an attacker use it to:"
- Impersonate a user or system?
- Access protected resources?
- Decrypt sensitive data?
- Bypass authentication or authorization?

If **YES** to any → Mark as sensitive.
If **NO** to all → Regular field.

## FileSystem Service (REQUIRED)

NEVER use Node.js fs module. ALWAYS use Effect FileSystem service from @effect/platform:

```typescript
// FORBIDDEN - Node.js fs
import * as fs from "node:fs";
const exists = fs.existsSync(path);
const content = fs.readFileSync(path, "utf-8");

// FORBIDDEN - Wrapping Node.js fs in Effect.try
const exists = yield* Effect.try(() => fs.existsSync(path));

// REQUIRED - Effect FileSystem service
import { FileSystem } from "@effect/platform";
const fs = yield* FileSystem.FileSystem;
const exists = yield* fs.exists(path);
const content = yield* fs.readFileString(path);
```

**Key operations**:
- `fs.exists(path)` - Check existence
- `fs.readFileString(path)` - Read text file
- `fs.writeFileString(path, content)` - Write text file
- `fs.makeDirectory(path, { recursive: true })` - Create directory
- `fs.readDirectory(path)` - List directory contents

**Layer composition** (Bun runtime):
```typescript
import { BunFileSystem } from "@effect/platform-bun";

export const MyCommandLive = Layer.mergeAll(
  BunFileSystem.layer,  // Provides FileSystem.FileSystem service
  // ... other layers
);
```

Reference: `tooling/cli/src/commands/create-slice/handler.ts` for canonical patterns.

## Factory Encoding Behavior

When using `createHandler` factory (or similar factories), understand the encoding/decoding flow:

The factory automatically:
1. **Encodes** payload using `payloadSchema` (converts Date → ISO string, etc.)
2. Passes **encoded** value to `execute` function
3. Checks for `response.error`
4. **Decodes** `response.data` using `successSchema`
5. Notifies `$sessionSignal` if `mutatesSession: true`

**Critical Rule**: The `execute` function receives the ENCODED payload, not the original input.

```typescript
// CORRECT - execute receives encoded payload
const Handler = createHandler({
  domain: "sign-in",
  feature: "email",
  execute: (encoded) => client.signIn.email(encoded),  // encoded is post-schema-encoding
  successSchema: Contract.Success,
  payloadSchema: Contract.Payload,
  mutatesSession: true,
});

// WRONG - manual encoding or transformation
const Handler = createHandler({
  domain: "sign-in",
  feature: "email",
  execute: (encoded) => client.signIn.email({ token: encoded.token }),  // WRONG - redundant field extraction
  successSchema: Contract.Success,
  payloadSchema: Contract.Payload,
  mutatesSession: true,
});
```

**Why This Matters**: Schema transformations (like `S.DateFromString`, `S.Redacted`) happen BEFORE `execute` is called. The encoded value is already in the correct wire format.
