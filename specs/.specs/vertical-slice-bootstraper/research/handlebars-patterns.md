# Handlebars Template Compilation for create-slice CLI

**Research Date**: 2026-01-06
**Target**: Template system for vertical slice scaffolding in `@beep/repo-cli`
**Context**: beep-effect monorepo CLI tooling

---

## Executive Summary

Handlebars.js is a mature templating engine (v4.7.8) **already available** in the project's `node_modules` via transitive dependencies. It provides runtime template compilation with custom helper registration - ideal for the create-slice CLI. This research covers:

1. Handlebars API for template compilation
2. Custom helper registration for case transformations
3. Template loading strategies with Effect
4. Integration patterns with beep-effect architecture

**Key Finding**: Effect's `String` module already provides `snakeToPascal`, `pascalToSnake`, and related case conversions. Handlebars helpers can directly wrap these for consistent transformation logic.

---

## 1. Handlebars API Overview

### Installation Status

âœ… **Already Installed**: Handlebars v4.7.8 is present in `node_modules/` (transitive dependency).
âœ… **TypeScript Definitions**: Available at `node_modules/handlebars/types/index.d.ts`

**Required Action**: Add explicit dependency to `tooling/cli/package.json`:

```json
{
  "dependencies": {
    "handlebars": "^4.7.8"
  }
}
```

### Core API Functions

```typescript
import Handlebars from "handlebars";

// Compile a template string into a function
const template = Handlebars.compile<TContext>("{{sliceName}}");
const result = template({ sliceName: "notifications" }); // "notifications"

// Register custom helpers BEFORE compilation
Handlebars.registerHelper("pascalCase", (str: string) => {
  // transformation logic
});

// Register partials for reusable snippets
Handlebars.registerPartial("header", "// Generated by create-slice");

// Precompile for client-side use (NOT needed for CLI)
const precompiled = Handlebars.precompile("{{foo}}");
```

**Key TypeScript Types**:

```typescript
namespace Handlebars {
  export interface TemplateDelegate<T = any> {
    (context: T, options?: RuntimeOptions): string;
  }

  export interface HelperDelegate {
    (context?: any, arg1?: any, ...args: any[], options?: HelperOptions): any;
  }

  export function compile<T = any>(
    input: string,
    options?: CompileOptions
  ): TemplateDelegate<T>;

  export function registerHelper(name: string, fn: HelperDelegate): void;
  export function registerHelper(helpers: { [name: string]: HelperDelegate }): void;
}
```

### Compilation Options

```typescript
interface CompileOptions {
  data?: boolean;           // Enable @data tracking (default: true)
  compat?: boolean;         // Recursive field lookup (default: false)
  knownHelpers?: Record<string, boolean>; // Optimize for known helpers
  noEscape?: boolean;       // Disable HTML escaping (useful for code gen)
  strict?: boolean;         // Fail on missing properties
}

// For code generation, recommended:
const template = Handlebars.compile(source, {
  noEscape: true,   // Don't HTML-escape {{ }} expressions
  strict: false,    // Allow missing properties (graceful degradation)
});
```

---

## 2. Custom Helpers for Case Transformation

### Required Transformations

The create-slice CLI needs these case conversions:

| Template Variable | Example Input | Output | Use Case |
|-------------------|---------------|--------|----------|
| `{{sliceName}}` | `notifications` | `notifications` | Directory names, kebab-case IDs |
| `{{SliceName}}` | `notifications` | `Notifications` | PascalCase class names |
| `{{SLICE_NAME}}` | `notifications` | `NOTIFICATIONS` | SCREAMING_SNAKE_CASE constants |
| `{{slice_name}}` | `notifications` | `notifications` | snake_case table names |
| `{{sliceDescription}}` | `"Push notifications"` | `"Push notifications"` | Package descriptions |

### Helper Implementation with Effect String

```typescript
import * as Str from "effect/String";
import * as F from "effect/Function";
import Handlebars from "handlebars";

// Leverage Effect's built-in case converters
const registerCaseHelpers = (): void => {
  // PascalCase (capitalize first letter)
  Handlebars.registerHelper("pascalCase", (str: string) => {
    return F.pipe(str, Str.capitalize);
  });

  // SCREAMING_SNAKE_CASE
  Handlebars.registerHelper("screamingSnakeCase", (str: string) => {
    return F.pipe(
      str,
      Str.replace(/-/g, "_"),  // kebab to snake
      Str.toUpperCase
    );
  });

  // snake_case (kebab-case â†’ snake_case)
  Handlebars.registerHelper("snakeCase", (str: string) => {
    return F.pipe(str, Str.kebabToSnake);
  });

  // camelCase
  Handlebars.registerHelper("camelCase", (str: string) => {
    return F.pipe(str, Str.kebabToSnake, Str.snakeToCamel);
  });

  // Pluralize (if needed, use @beep/utils)
  Handlebars.registerHelper("pluralize", (str: string) => {
    return F.pipe(str, StrUtils.pluralize);
  });
};
```

### Helper Registration Pattern

**Option A: Global Registration** (simplest for CLI)

```typescript
import * as Effect from "effect/Effect";

// Register once at CLI startup
const setupHandlebars = Effect.sync(() => {
  registerCaseHelpers();
  registerPartials();
  return Handlebars;
});

// Use in command
const compileTemplate = (source: string) =>
  Effect.gen(function* () {
    const hbs = yield* setupHandlebars;
    return hbs.compile(source, { noEscape: true });
  });
```

**Option B: Service Pattern** (Effect-first, reusable)

```typescript
import * as Context from "effect/Context";
import * as Layer from "effect/Layer";

export class HandlebarsService extends Effect.Service<HandlebarsService>()(
  "HandlebarsService",
  {
    effect: Effect.sync(() => {
      registerCaseHelpers();
      return {
        compile: <T>(source: string) =>
          Handlebars.compile<T>(source, { noEscape: true }),
      };
    }),
  }
) {}

// Usage in command
const compileTemplate = (source: string) =>
  Effect.gen(function* () {
    const hbs = yield* HandlebarsService;
    return hbs.compile(source);
  });
```

**Recommendation**: **Option A** (global registration) is sufficient for CLI use case. Option B adds unnecessary ceremony.

---

## 3. Template Loading Strategies

### File Structure

```
tooling/cli/src/commands/create-slice/
â”œâ”€â”€ index.ts                      # Command entry point
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ package.json.hbs
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts.hbs
â”‚   â”‚   â””â”€â”€ tsconfig.json.hbs
â”‚   â”œâ”€â”€ tables/
â”‚   â”‚   â”œâ”€â”€ package.json.hbs
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â””â”€â”€ index.ts.hbs
â”‚   â”œâ”€â”€ server/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ client/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ partials/
â”‚       â”œâ”€â”€ header.hbs            # Common file header
â”‚       â””â”€â”€ imports.hbs           # Shared imports
â””â”€â”€ services/
    â”œâ”€â”€ template.service.ts       # Template loading/compilation
    â””â”€â”€ scaffold.service.ts       # File generation orchestration
```

### Template Loading with Effect FileSystem

```typescript
import * as FileSystem from "@effect/platform/FileSystem";
import * as Path from "@effect/platform/Path";
import * as Effect from "effect/Effect";
import * as A from "effect/Array";
import * as F from "effect/Function";

interface TemplateFile {
  readonly relativePath: string;  // e.g., "domain/src/index.ts"
  readonly content: string;
}

// Load all .hbs templates from a directory
const loadTemplates = (templateDir: string): Effect.Effect<
  ReadonlyArray<TemplateFile>,
  PlatformError,
  FileSystem.FileSystem | Path.Path
> =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;

    // Recursively find all .hbs files
    const findTemplates = (dir: string): Effect.Effect<
      ReadonlyArray<string>,
      PlatformError,
      FileSystem.FileSystem | Path.Path
    > =>
      Effect.gen(function* () {
        const entries = yield* fs.readDirectory(dir);

        const results = yield* F.pipe(
          entries,
          A.map((entry) =>
            Effect.gen(function* () {
              const fullPath = path.join(dir, entry);
              const stat = yield* fs.stat(fullPath);

              if (stat.type === "Directory") {
                return yield* findTemplates(fullPath);
              }

              if (entry.endsWith(".hbs")) {
                return [fullPath];
              }

              return [];
            })
          ),
          Effect.all,
          Effect.map(A.flatten)
        );

        return results;
      });

    const templatePaths = yield* findTemplates(templateDir);

    // Load content for each template
    return yield* F.pipe(
      templatePaths,
      A.map((templatePath) =>
        Effect.gen(function* () {
          const content = yield* fs.readFileString(templatePath);
          const relativePath = F.pipe(
            templatePath,
            Str.replace(templateDir, ""),
            Str.replace(/^\//, ""),      // Remove leading slash
            Str.replace(/\.hbs$/, "")    // Remove .hbs extension
          );

          return { relativePath, content };
        })
      ),
      Effect.all
    );
  });
```

### Compiled Template Cache

```typescript
import * as HashMap from "effect/HashMap";

interface CompiledTemplate {
  readonly compile: (context: Record<string, unknown>) => string;
}

// Service to manage compiled templates
export class TemplateService extends Effect.Service<TemplateService>()(
  "TemplateService",
  {
    effect: Effect.gen(function* () {
      const fs = yield* FileSystem.FileSystem;
      const path = yield* Path.Path;
      const repoRoot = yield* findRepoRoot; // from @beep/tooling-utils

      // Load and compile all templates once
      const templateDir = path.join(
        repoRoot,
        "tooling/cli/src/commands/create-slice/templates"
      );

      const rawTemplates = yield* loadTemplates(templateDir);

      // Register helpers BEFORE compiling
      registerCaseHelpers();

      // Compile all templates into HashMap
      const compiledMap = F.pipe(
        rawTemplates,
        A.reduce(
          HashMap.empty<string, CompiledTemplate>(),
          (acc, { relativePath, content }) => {
            const compiled = Handlebars.compile(content, { noEscape: true });
            return F.pipe(
              acc,
              HashMap.set(relativePath, { compile: compiled })
            );
          }
        )
      );

      return {
        render: (templatePath: string, context: Record<string, unknown>) =>
          F.pipe(
            compiledMap,
            HashMap.get(templatePath),
            O.map((template) => template.compile(context)),
            O.getOrElse(() => {
              throw new Error(`Template not found: ${templatePath}`);
            })
          ),

        renderAll: (context: Record<string, unknown>) =>
          F.pipe(
            compiledMap,
            HashMap.toEntries,
            A.map(([path, template]) => ({
              path,
              content: template.compile(context),
            }))
          ),
      };
    }),
    dependencies: [BunContext.layer, FsUtilsLive],
  }
) {}
```

**Benefits**:
- Templates loaded once at service initialization
- Compiled templates cached in memory
- Fast rendering for multiple slices
- Type-safe access via Effect service

---

## 4. Template Partials for Shared Snippets

### Use Cases for Partials

```handlebars
{{!-- templates/partials/header.hbs --}}
/**
 * @generated by create-slice CLI
 * @slice {{sliceName}}
 * @description {{sliceDescription}}
 */

{{!-- templates/partials/effect-imports.hbs --}}
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Context from "effect/Context";

{{!-- templates/domain/src/index.ts.hbs --}}
{{> header}}

{{> effect-imports}}

// {{SliceName}} domain exports
export * from "./entities";
```

### Partial Registration

```typescript
const registerPartials = (partialDir: string): Effect.Effect<
  void,
  PlatformError,
  FileSystem.FileSystem | Path.Path
> =>
  Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem;
    const path = yield* Path.Path;

    const partialFiles = yield* fs.readDirectory(partialDir);

    yield* F.pipe(
      partialFiles,
      A.filter((file) => file.endsWith(".hbs")),
      A.map((file) =>
        Effect.gen(function* () {
          const fullPath = path.join(partialDir, file);
          const content = yield* fs.readFileString(fullPath);
          const name = F.pipe(file, Str.replace(/\.hbs$/, ""));

          Handlebars.registerPartial(name, content);
        })
      ),
      Effect.all,
      Effect.asVoid
    );
  });
```

---

## 5. Effect Integration Pattern

### Complete Service Example

```typescript
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as FileSystem from "@effect/platform/FileSystem";
import * as Path from "@effect/platform/Path";
import * as BunContext from "@effect/platform-bun/BunContext";
import { FsUtilsLive } from "@beep/tooling-utils";
import { findRepoRoot } from "@beep/tooling-utils/repo";
import Handlebars from "handlebars";

// Context for template rendering
export interface SliceContext {
  readonly sliceName: string;        // "notifications"
  readonly SliceName: string;        // "Notifications"
  readonly SLICE_NAME: string;       // "NOTIFICATIONS"
  readonly slice_name: string;       // "notifications"
  readonly sliceDescription: string; // "Push notifications"
}

// Create context from user input
export const mkSliceContext = (
  sliceName: string,
  description: string
): SliceContext => ({
  sliceName,
  SliceName: F.pipe(sliceName, Str.capitalize),
  SLICE_NAME: F.pipe(
    sliceName,
    Str.replace(/-/g, "_"),
    Str.toUpperCase
  ),
  slice_name: F.pipe(sliceName, Str.kebabToSnake),
  sliceDescription: description,
});

// Template rendering service
export class TemplateService extends Effect.Service<TemplateService>()(
  $I`TemplateService`,
  {
    effect: Effect.gen(function* () {
      const path = yield* Path.Path;
      const repoRoot = yield* findRepoRoot;

      const templateDir = path.join(
        repoRoot,
        "tooling/cli/src/commands/create-slice/templates"
      );
      const partialDir = path.join(templateDir, "partials");

      // Setup Handlebars
      registerCaseHelpers();
      yield* registerPartials(partialDir);

      // Load and compile templates
      const rawTemplates = yield* loadTemplates(templateDir);
      const compiledMap = F.pipe(
        rawTemplates,
        A.reduce(
          HashMap.empty<string, Handlebars.TemplateDelegate>(),
          (acc, { relativePath, content }) =>
            F.pipe(
              acc,
              HashMap.set(
                relativePath,
                Handlebars.compile(content, { noEscape: true })
              )
            )
        )
      );

      return {
        render: (templatePath: string, context: SliceContext) =>
          Effect.gen(function* () {
            const template = F.pipe(
              compiledMap,
              HashMap.get(templatePath),
              O.getOrThrow
            );
            return template(context);
          }),

        renderAll: (context: SliceContext) =>
          Effect.succeed(
            F.pipe(
              compiledMap,
              HashMap.toEntries,
              A.map(([path, template]) => ({
                path,
                content: template(context),
              }))
            )
          ),
      };
    }),
    dependencies: [BunContext.layer, FsUtilsLive],
  }
) {}
```

### Usage in create-slice Command

```typescript
const createSliceCommand = Effect.gen(function* () {
  const templateSvc = yield* TemplateService;
  const sliceName = yield* getSliceNameFromArgs;
  const description = yield* getDescriptionFromArgs;

  const context = mkSliceContext(sliceName, description);

  // Render all templates
  const renderedFiles = yield* templateSvc.renderAll(context);

  // Write files to disk
  yield* F.pipe(
    renderedFiles,
    A.map(({ path, content }) =>
      Effect.gen(function* () {
        const fullPath = yield* resolveOutputPath(path);
        yield* writeFile(fullPath, content);
        yield* Effect.log(`Created: ${fullPath}`);
      })
    ),
    Effect.all
  );
});
```

---

## 6. Alternative: No Templating (AST Manipulation Only)

### Comparison

| Aspect | Handlebars Templates | ts-morph AST Only |
|--------|---------------------|-------------------|
| **Setup Complexity** | Low (register helpers, load templates) | High (manual AST construction) |
| **Maintainability** | High (templates are readable) | Low (AST code is verbose) |
| **Flexibility** | High (easy to tweak templates) | Medium (requires AST knowledge) |
| **Type Safety** | Low (string templates) | High (TypeScript AST) |
| **Performance** | Fast (compiled once) | Slower (AST construction per file) |
| **Best For** | Scaffolding entire files | Modifying existing code |

**Verdict**: **Use both**:
- **Handlebars** for generating new files (package.json, tsconfig.json, skeleton source files)
- **ts-morph** for modifying existing files (adding identity composers to `packages/common/identity/src/packages.ts`)

---

## 7. Recommendations

### Architecture

1. **TemplateService** (Handlebars-based):
   - Load/compile templates at initialization
   - Provide `render(path, context)` and `renderAll(context)` methods
   - Cache compiled templates in `HashMap`

2. **ScaffoldService** (File generation orchestrator):
   - Use TemplateService to render files
   - Use FsUtils to write files
   - Use ts-morph to modify existing files (identity composers, tsconfig references)

3. **CreateSliceCommand** (CLI entry point):
   - Parse args with `@effect/cli`
   - Validate slice name
   - Delegate to ScaffoldService
   - Handle dry-run mode

### Template Organization

```
templates/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ package.json.hbs
â”‚   â”œâ”€â”€ tsconfig.json.hbs
â”‚   â”œâ”€â”€ tsconfig.build.json.hbs
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ index.ts.hbs
â”œâ”€â”€ tables/
â”‚   â””â”€â”€ ... (similar structure)
â”œâ”€â”€ server/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ client/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ ui/
â”‚   â””â”€â”€ ...
â””â”€â”€ partials/
    â”œâ”€â”€ header.hbs               # File header comment
    â”œâ”€â”€ package-base.hbs         # Common package.json fields
    â””â”€â”€ tsconfig-extends.hbs     # Shared tsconfig extends
```

### Context Variables

**Base Context** (passed to all templates):

```typescript
interface SliceContext {
  sliceName: string;        // "notifications"
  SliceName: string;        // "Notifications"
  SLICE_NAME: string;       // "NOTIFICATIONS"
  slice_name: string;       // "notifications"
  sliceDescription: string; // "Push notifications"
}
```

**Template-specific context** (merged with base):

```typescript
// For package.json templates
interface PackageContext extends SliceContext {
  packageName: string;      // "@beep/notifications-domain"
  layer: "domain" | "tables" | "server" | "client" | "ui";
}

// For entity-id templates
interface EntityIdContext extends SliceContext {
  entityName: string;       // "User", "File", etc.
}
```

### Helper Registration

**Minimal Helpers** (leverage Effect String):

```typescript
const registerCaseHelpers = (): void => {
  Handlebars.registerHelper("pascalCase", Str.capitalize);
  Handlebars.registerHelper("camelCase", (str: string) =>
    F.pipe(str, Str.kebabToSnake, Str.snakeToCamel)
  );
  Handlebars.registerHelper("snakeCase", Str.kebabToSnake);
  Handlebars.registerHelper("screamingSnakeCase", (str: string) =>
    F.pipe(str, Str.kebabToSnake, Str.toUpperCase)
  );
};
```

**Why Minimal**: Context preparation (e.g., `mkSliceContext`) pre-computes most transformations. Helpers are only needed for dynamic transformations within templates.

---

## 8. Example Templates

### domain/package.json.hbs

```handlebars
{
  "name": "@beep/{{sliceName}}-domain",
  "version": "0.0.0",
  "type": "module",
  "license": "MIT",
  "description": "{{sliceDescription}} - Domain layer",
  "exports": {
    ".": "./src/index.ts",
    "./package.json": "./package.json",
    "./*": "./src/*.ts"
  },
  "dependencies": {
    "@beep/schema": "workspace:^",
    "@beep/types": "workspace:^",
    "effect": "catalog:"
  },
  "devDependencies": {
    "@beep/testkit": "workspace:^",
    "typescript": "catalog:"
  }
}
```

### domain/src/index.ts.hbs

```handlebars
{{> header}}

/**
 * {{SliceName}} domain - Pure business logic
 *
 * This module contains:
 * - Entity models
 * - Value objects
 * - Business rules (NO side effects)
 */

import * as S from "effect/Schema";

// TODO: Define your domain entities here

export {};
```

### partials/header.hbs

```handlebars
/**
 * @generated by create-slice CLI
 * @slice {{sliceName}}
 * @description {{sliceDescription}}
 * @do-not-edit
 */
```

---

## References

### Official Documentation

- [Handlebars Official Guide](https://handlebarsjs.com/guide/)
- [Handlebars API Reference - Compilation](https://handlebarsjs.com/api-reference/compilation.html)
- [Handlebars Precompilation Guide](https://handlebarsjs.com/guide/installation/precompilation.html)
- [Effect FileSystem Documentation](https://effect.website/docs/platform/file-system/)
- [Effect FileSystem API Reference](https://effect-ts.github.io/effect/platform/FileSystem.ts.html)

### Community Resources

- [handlebars-helpers (GitHub)](https://github.com/helpers/handlebars-helpers) - 188 helpers in ~20 categories
- [just-handlebars-helpers (npm)](https://www.npmjs.com/package/just-handlebars-helpers) - Lightweight helper library
- [handlebars npm package](https://www.npmjs.com/package/handlebars)

### Internal Codebase References

- **Case Transformations**: `/home/elpresidank/YeeBois/projects/beep-effect/packages/common/utils/src/data/string.utils.ts`
  - `kebabCase`, `mkEntityName`, `mkTableName` functions
  - Effect String utilities: `Str.snakeToPascal`, `Str.pascalToSnake`, `Str.kebabToSnake`
- **Effect String Module**: `/home/elpresidank/YeeBois/projects/beep-effect/node_modules/effect/src/String.ts`
  - Lines 931-969: `snakeToCamel`, `snakeToPascal`, `camelToSnake`, `pascalToSnake`, `kebabToSnake`
- **Existing Templates**: `/home/elpresidank/YeeBois/projects/beep-effect/tooling/repo-scripts/src/templates/package/*.hbs`
  - Handlebars templates exist but are not yet integrated

---

## Success Criteria Verification

### âœ… Template Compilation Documented

- Handlebars.compile API signature
- Compilation options for code generation (`noEscape: true`)
- TypeScript type definitions available

### âœ… Custom Helpers Documented

- Case transformation helpers (pascalCase, snakeCase, screamingSnakeCase)
- Integration with Effect String module
- Registration pattern (global vs. service-based)

### âœ… Template Loading Pattern Documented

- Effect FileSystem integration
- Recursive directory traversal
- HashMap-based template cache
- Partial registration for shared snippets

### âœ… Effect Wrapping Pattern Documented

- TemplateService with Effect.Service pattern
- Layer composition with BunContext and FsUtilsLive
- SliceContext type definition
- Complete usage example in create-slice command

---

## Prompt Feedback

### Efficiency Score: 9/10

**What Worked Well**:
âœ… Clear scope definition (template compilation for create-slice CLI)
âœ… Specific questions to answer (compilation, helpers, loading, partials, patterns)
âœ… Explicit output format and location
âœ… Concrete success criteria checklist

**What Could Be Improved**:
âš ï¸ **Minor**: Could have specified desired template syntax style (Handlebars vs. Mustache vs. EJS) - though Handlebars is the de facto standard for this use case.
âš ï¸ **Minor**: Could have provided example template files to analyze - though the repo-scripts templates were discoverable via grep.

**Suggestions for Future Prompts**:
1. âœ… **Keep**: The "Key Questions to Answer" structure - very effective for guiding research.
2. âœ… **Keep**: Explicit success criteria checklist - ensures completeness.
3. ğŸ’¡ **Add**: "Anti-patterns to avoid" section to prevent common mistakes (e.g., "Don't use ejs", "Don't inline templates in code").
4. ğŸ’¡ **Add**: Estimated time budget for research (e.g., "Spend max 30 min on this") to prevent over-research.

**Overall Assessment**: Highly effective prompt. Provided clear direction, concrete deliverables, and measurable success criteria. The research was scoped appropriately and aligned with beep-effect architectural constraints.
