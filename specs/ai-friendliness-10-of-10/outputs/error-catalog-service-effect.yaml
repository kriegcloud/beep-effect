# Error Catalog: Service/Layer + Effect Patterns
# Generated: 2026-02-04
# Categories: service, effect

version: "1.0"
errors:
  # ============================================================================
  # SERVICE/LAYER ERRORS (SVC_001 - SVC_008)
  # ============================================================================

  - id: SVC_001
    pattern: "Service\\.(.+)\\s+is not provided"
    category: service
    severity: error
    fix_type: unsafe
    remediation: easy
    description: Service not provided in Layer composition - Effect cannot find required dependency
    diagnosis: |
      Check the Effect's Requirements (R) type parameter. The service listed is required but not provided
      in the Layer chain. Trace back through Layer.provide/Effect.provide calls to find where the
      service should have been composed.
    fix_steps:
      - Identify the missing service from the error message
      - Find or create a Layer that provides this service
      - Add Layer.provide() or Layer.merge() to include the missing service Layer
      - Verify the Layer is in the dependency chain before the Effect runs
    example:
      error: "Service FileSystem.FileSystem is not provided"
      before: |
        import { FileSystem } from "@effect/platform";

        const program = Effect.gen(function* () {
          const fs = yield* FileSystem.FileSystem;
          const content = yield* fs.readFileString("/path/to/file");
          return content;
        });

        // Missing Layer.provide for FileSystem!
        Effect.runPromise(program);
      after: |
        import { FileSystem } from "@effect/platform";
        import { BunFileSystem } from "@effect/platform-bun";

        const program = Effect.gen(function* () {
          const fs = yield* FileSystem.FileSystem;
          const content = yield* fs.readFileString("/path/to/file");
          return content;
        });

        // Provide the FileSystem Layer
        Effect.runPromise(program.pipe(Effect.provide(BunFileSystem.layer)));

  - id: SVC_002
    pattern: "Cannot read properties of undefined.*Context\\.Tag|yield\\* \\w+ returns undefined"
    category: service
    severity: error
    fix_type: manual
    remediation: major
    description: Context.Tag defined incorrectly or service interface mismatch
    diagnosis: |
      The Context.Tag is either:
      1. Not properly exported/imported
      2. Missing the class extension pattern
      3. Service interface doesn't match what Layer.succeed/Layer.effect provides
    fix_steps:
      - Verify Context.Tag extends correctly with proper generics
      - Check that the tag identifier string is unique across the codebase
      - Ensure Layer.succeed/Layer.effect provides an object matching the Tag's interface
      - Verify imports use the correct package path alias
    example:
      error: "Cannot read properties of undefined (reading 'pipe')"
      before: |
        // Wrong: Missing class extension or wrong pattern
        const MyService = Context.Tag("MyService");

        // Or: Tag identifier collision
        export class UserRepo extends Context.Tag("Repo")<UserRepo, UserRepoService>() {}
        export class OrgRepo extends Context.Tag("Repo")<OrgRepo, OrgRepoService>() {}  // Same tag!
      after: |
        // Correct: Proper class extension with unique identifier
        export class MyService extends Context.Tag($I`MyService`)<
          MyService,
          {
            readonly doSomething: (input: string) => Effect.Effect<string>;
          }
        >() {}

        // Unique tag identifiers
        export class UserRepo extends Context.Tag($I`UserRepo`)<UserRepo, UserRepoService>() {}
        export class OrgRepo extends Context.Tag($I`OrgRepo`)<OrgRepo, OrgRepoService>() {}

  - id: SVC_003
    pattern: "Layer\\.provide.*Layer\\.Layer.*never"
    category: service
    severity: error
    fix_type: unsafe
    remediation: major
    description: Circular Layer dependency detected - two Layers depend on each other
    diagnosis: |
      Layer A requires Layer B, and Layer B requires Layer A (directly or transitively).
      This creates an impossible dependency resolution. Review the Layer dependency graph.
    fix_steps:
      - Map out the Layer dependency graph
      - Identify the circular reference
      - Extract shared functionality into a new independent Layer
      - Or restructure to break the cycle (often via interface segregation)
    example:
      error: "Type 'Layer<A, never, B>' is not assignable to type 'Layer<A, never, never>'"
      before: |
        // Circular: AuthService needs UserRepo, UserRepo needs AuthService
        const AuthServiceLive = Layer.effect(AuthService,
          Effect.gen(function* () {
            const userRepo = yield* UserRepo;  // Needs UserRepo
            return { ... };
          })
        );

        const UserRepoLive = Layer.effect(UserRepo,
          Effect.gen(function* () {
            const auth = yield* AuthService;  // Needs AuthService - CIRCULAR!
            return { ... };
          })
        );
      after: |
        // Break cycle: Extract password hashing to independent service
        const PasswordHasherLive = Layer.succeed(PasswordHasher, {
          hash: (password) => Effect.succeed(hashSync(password)),
        });

        const AuthServiceLive = Layer.effect(AuthService,
          Effect.gen(function* () {
            const hasher = yield* PasswordHasher;  // No cycle
            return { ... };
          })
        );

        const UserRepoLive = Layer.effect(UserRepo,
          Effect.gen(function* () {
            const hasher = yield* PasswordHasher;  // Shared dependency
            return { ... };
          })
        );

  - id: SVC_004
    pattern: "Effect\\.provide.*expecting.*Layer.*received.*Effect"
    category: service
    severity: error
    fix_type: safe
    remediation: trivial
    description: Confusion between Effect.provide and Layer.provide
    diagnosis: |
      Effect.provide() expects a Layer, but Layer.provide() is used for composing Layers.
      The error occurs when passing an Effect where a Layer is expected, or vice versa.
    fix_steps:
      - For providing a Layer to an Effect, use Effect.provide()
      - For composing Layers, use Layer.provide() or Layer.provideMerge()
      - Check the return type - Layer.effect returns Layer, Effect.gen returns Effect
    example:
      error: "Argument of type 'Effect<...>' is not assignable to parameter of type 'Layer<...>'"
      before: |
        // Wrong: Using Layer.provide to provide to an Effect
        const program = Effect.gen(function* () {
          const service = yield* MyService;
          return yield* service.doSomething();
        });

        Layer.provide(program, MyServiceLive);  // WRONG - program is Effect, not Layer
      after: |
        // Correct: Use Effect.provide for Effects
        const program = Effect.gen(function* () {
          const service = yield* MyService;
          return yield* service.doSomething();
        });

        program.pipe(Effect.provide(MyServiceLive));  // Correct

        // Layer.provide is for composing Layers:
        const ComposedLive = MyServiceLive.pipe(
          Layer.provide(DependencyLive)  // Provides Dependency to MyService Layer
        );

  - id: SVC_005
    pattern: "Layer\\.succeed.*as unknown as|type assertion.*Layer"
    category: service
    severity: warning
    fix_type: unsafe
    remediation: easy
    description: Unsafe type assertion in Layer.succeed for test mocks
    diagnosis: |
      Using `as unknown as` to cast mock implementations in tests bypasses type checking.
      If the mock interface changes, tests will pass but production may fail.
    fix_steps:
      - Define the mock object with explicit typing
      - Use satisfies operator for partial mocks
      - Or create a proper mock factory that type-checks
    example:
      error: "Unsafe type assertion detected in test mock"
      before: |
        // Unsafe: Type assertion bypasses interface checking
        const MockLanguageModel = Layer.succeed(
          LanguageModel.LanguageModel,
          {
            generateObject: () => Effect.succeed({ result: "mock" }),
            // Missing required methods won't be caught!
          } as unknown as LanguageModel.Service
        );
      after: |
        // Safe: Explicit interface implementation with type checking
        const mockService: LanguageModel.Service = {
          generateObject: (options) => Effect.succeed({
            result: "mock",
            usage: { promptTokens: 0, completionTokens: 0 }
          }),
          generateText: (options) => Effect.succeed({ text: "mock" }),
          // TypeScript will error if methods are missing
        };

        const MockLanguageModel = Layer.succeed(
          LanguageModel.LanguageModel,
          mockService
        );

  - id: SVC_006
    pattern: "double.*LanguageModel|LanguageModel\\.LanguageModel"
    category: service
    severity: error
    fix_type: safe
    remediation: trivial
    description: Double reference pattern for namespaced services (LanguageModel.LanguageModel)
    diagnosis: |
      Some Effect services use a namespace that contains a class/tag of the same name.
      Yielding just the namespace returns the module object, not the service instance.
    fix_steps:
      - Identify if the import is a namespace containing a service tag
      - Use ModuleName.ModuleName pattern for namespaced services
      - Check Effect documentation for the correct access pattern
    example:
      error: "Cannot read properties of undefined (reading 'generateObject')"
      before: |
        import * as LanguageModel from "@effect/ai/LanguageModel";

        const program = Effect.gen(function* () {
          const model = yield* LanguageModel;  // WRONG: yields the namespace object
          return yield* model.generateObject({ ... });  // Error: generateObject undefined
        });
      after: |
        import * as LanguageModel from "@effect/ai/LanguageModel";

        const program = Effect.gen(function* () {
          const model = yield* LanguageModel.LanguageModel;  // Correct: namespace.Tag
          return yield* model.generateObject({ ... });
        });

  - id: SVC_007
    pattern: "Layer\\.mergeAll|Layer\\.merge.*order|dependencies.*not.*satisfied"
    category: service
    severity: error
    fix_type: unsafe
    remediation: major
    description: Layer composition order matters - dependencies must be provided before dependents
    diagnosis: |
      When composing multiple Layers, dependent Layers must receive their requirements.
      Layer.mergeAll combines Layers but doesn't auto-resolve internal dependencies.
    fix_steps:
      - Draw the dependency graph of your Layers
      - Use Layer.provide() to satisfy each Layer's requirements
      - Or use Layer.provideMerge() to merge and provide in one step
      - Order matters - provide base Layers before dependent ones
    example:
      error: "Layer 'UserServiceLive' requires 'DatabaseLive' which is not provided"
      before: |
        // Wrong: mergeAll doesn't resolve internal dependencies
        const AppLive = Layer.mergeAll(
          UserServiceLive,  // Needs Database
          DatabaseLive,     // Provides Database, but merge doesn't wire it
        );
      after: |
        // Correct: Explicitly provide dependencies
        const AppLive = UserServiceLive.pipe(
          Layer.provide(DatabaseLive),  // Wire Database to UserService
          Layer.provideMerge(LoggerLive),  // Add Logger alongside
        );

        // Or use Layer.effect with explicit yields
        const UserServiceWithDeps = Layer.effect(
          UserService,
          Effect.gen(function* () {
            const db = yield* Database;
            return makeUserService(db);
          })
        ).pipe(Layer.provide(DatabaseLive));

  - id: SVC_008
    pattern: "Db\\.make|SliceDb.*not.*provided|missing.*database.*layer"
    category: service
    severity: error
    fix_type: unsafe
    remediation: easy
    description: Slice-scoped database client (Db.make) not properly layered
    diagnosis: |
      Each slice in beep-effect has its own typed Db service created with Db.make().
      The SliceDb Layer must be provided to Effects that need database access.
    fix_steps:
      - Verify the slice's Db is defined in {slice}/tables/src/Db/
      - Check that the Db exports the correct table shape
      - Provide the SliceDb Layer (e.g., IamDb, KnowledgeDb) to your Effect
      - For tests, use the testkit's database Layer setup
    example:
      error: "Service IamDb is not provided"
      before: |
        // packages/iam/server/src/repos/MemberRepo.ts
        import { IamDb } from "@beep/iam-tables/Db";

        const findAllMembers = Effect.gen(function* () {
          const db = yield* IamDb;
          return yield* db.select().from(members);
        });

        // Missing IamDb Layer!
        Effect.runPromise(findAllMembers);
      after: |
        // packages/iam/server/src/repos/MemberRepo.ts
        import { IamDb, IamDbLive } from "@beep/iam-tables/Db";

        const findAllMembers = Effect.gen(function* () {
          const db = yield* IamDb;
          return yield* db.select().from(members);
        });

        // Provide the database Layer
        findAllMembers.pipe(
          Effect.provide(IamDbLive),
          Effect.provide(SqlLive),  // Base SQL connection
        );

  # ============================================================================
  # EFFECT PATTERN ERRORS (EFF_001 - EFF_006)
  # ============================================================================

  - id: EFF_001
    pattern: "yield(?!\\*).*Effect|missing yield\\*|forgot yield"
    category: effect
    severity: error
    fix_type: safe
    remediation: trivial
    description: Missing yield* in Effect.gen - Effect not executed, returns Effect object instead of result
    diagnosis: |
      In Effect.gen, each Effect must be yielded with `yield*` to execute it.
      Without yield*, the Effect object is assigned to the variable, not its result.
    fix_steps:
      - Add yield* before each Effect call inside Effect.gen
      - Remember yield* is the Effect equivalent of await in async functions
      - Check return types - if a variable is Effect<T> instead of T, yield* is missing
    example:
      error: "Type 'Effect<string, Error, never>' is not assignable to type 'string'"
      before: |
        Effect.gen(function* () {
          const result = someEffect();  // Missing yield* - result is Effect, not value
          const data = anotherEffect();  // Same problem
          return result.length;  // Error: Effect has no .length
        });
      after: |
        Effect.gen(function* () {
          const result = yield* someEffect();  // Correct - result is the unwrapped value
          const data = yield* anotherEffect();  // Correct
          return result.length;  // Works - result is string
        });

  - id: EFF_002
    pattern: "Effect\\.fn.*test|test.*Effect\\.fn|function.*not.*executed"
    category: effect
    severity: error
    fix_type: safe
    remediation: easy
    description: Effect.fn vs Effect.gen confusion - Effect.fn returns a function, not an Effect
    diagnosis: |
      Effect.fn creates a function that returns an Effect (useful for service methods).
      Effect.gen creates an Effect directly. In tests, use Effect.gen, not Effect.fn.
    fix_steps:
      - For tests, use Effect.gen(function* () { ... })
      - Effect.fn is for defining reusable effectful functions
      - If using Effect.fn, call the returned function to get the Effect
    example:
      error: "Test passed but assertions never ran"
      before: |
        // Wrong: Effect.fn returns a function, not an Effect!
        effect("my test", () =>
          Effect.fn(function* () {
            const result = yield* someService.doThing();
            strictEqual(result, expected);  // Never executed!
          })  // Returns: (args) => Effect, not Effect
        );
      after: |
        // Correct: Effect.gen returns an Effect directly
        effect("my test", () =>
          Effect.gen(function* () {
            const result = yield* someService.doThing();
            strictEqual(result, expected);  // Executes properly
          })
        );

  - id: EFF_003
    pattern: "Effect\\.runPromise.*test|bun:test.*runPromise|runSync.*test"
    category: effect
    severity: error
    fix_type: unsafe
    remediation: easy
    description: Using Effect.runPromise in tests instead of @beep/testkit runners
    diagnosis: |
      Direct Effect.runPromise/runSync bypasses testkit's TestClock, TestRandom, and proper
      error handling. Tests may pass incorrectly or miss timing-dependent bugs.
    fix_steps:
      - Import effect/layer/scoped/live from @beep/testkit
      - Replace test() with effect() or layer() runners
      - Remove Effect.runPromise - testkit handles execution
    example:
      error: "Tests use manual Effect execution"
      before: |
        import { test } from "bun:test";

        test("my test", async () => {
          await Effect.gen(function* () {
            const result = yield* someEffect();
            expect(result).toBe(expected);
          }).pipe(
            Effect.provide(TestLayer),
            Effect.runPromise  // FORBIDDEN!
          );
        });
      after: |
        import { effect, strictEqual } from "@beep/testkit";

        effect("my test", () =>
          Effect.gen(function* () {
            const result = yield* someEffect();
            strictEqual(result, expected);
          }).pipe(Effect.provide(TestLayer))
        );

  - id: EFF_004
    pattern: "new Error|throw new Error|Effect\\.die\\(new Error"
    category: effect
    severity: error
    fix_type: unsafe
    remediation: easy
    description: Using native Error constructor instead of S.TaggedError
    diagnosis: |
      Native Error objects lose type information and can't be caught with catchTag.
      Effect errors should be tagged for proper error channel typing and handling.
    fix_steps:
      - Define error class extending S.TaggedError
      - Use Effect.fail(new MyError({ ... })) for expected errors
      - Use Effect.die() only for programmer errors (with TaggedError still preferred)
      - Use catchTag("MyError", handler) for typed error handling
    example:
      error: "Untyped error in Effect channel"
      before: |
        // Wrong: Native Error - no tag, untyped
        const fetchUser = (id: string) =>
          Effect.gen(function* () {
            const user = yield* db.findUser(id);
            if (!user) {
              throw new Error("User not found");  // WRONG: throws
            }
            return user;
          });

        // Can't use catchTag
        fetchUser("123").pipe(
          Effect.catchTag("UserNotFound", ...)  // Won't work!
        );
      after: |
        // Correct: Tagged error with typed fields
        export class UserNotFoundError extends S.TaggedError<UserNotFoundError>()(
          "UserNotFoundError",
          { userId: S.String }
        ) {}

        const fetchUser = (id: string) =>
          Effect.gen(function* () {
            const user = yield* db.findUser(id);
            if (!user) {
              return yield* Effect.fail(new UserNotFoundError({ userId: id }));
            }
            return user;
          });

        // Now catchTag works with type safety
        fetchUser("123").pipe(
          Effect.catchTag("UserNotFoundError", (e) =>
            Effect.succeed(createDefaultUser(e.userId))
          )
        );

  - id: EFF_005
    pattern: "catchAll.*ParseError|ParseError.*not.*handled|SqlSchema.*ParseError"
    category: effect
    severity: error
    fix_type: unsafe
    remediation: easy
    description: ParseError from SqlSchema operations not caught - causes unhandled Effect failure
    diagnosis: |
      SqlSchema operations (findById, findAll, etc.) can fail with ParseError when
      database values don't match the schema. This error must be handled explicitly.
    fix_steps:
      - Add catchTag("ParseError", handler) before other error mapping
      - Decide if ParseError should be a defect (die) or recoverable error
      - For repos, typically die on ParseError (schema mismatch is a bug)
    example:
      error: "Unhandled 'ParseError' in error channel"
      before: |
        // Wrong: ParseError escapes unhandled
        const findByIds = (ids: ReadonlyArray<string>) =>
          findByIdsSchema({ ids: [...ids], organizationId }).pipe(
            Effect.mapError(DatabaseError.$match),  // ParseError not caught!
          );
      after: |
        // Correct: Handle ParseError explicitly
        const findByIds = (ids: ReadonlyArray<string>) =>
          findByIdsSchema({ ids: [...ids], organizationId }).pipe(
            Effect.catchTag("ParseError", (e) => Effect.die(e)),  // Schema bug = defect
            Effect.mapError(DatabaseError.$match),
          );

  - id: EFF_006
    pattern: "Effect\\.sync.*promise|Effect\\.sync.*async|tryPromise.*sync"
    category: effect
    severity: error
    fix_type: safe
    remediation: trivial
    description: Using Effect.sync for async operations - should use Effect.tryPromise
    diagnosis: |
      Effect.sync is for synchronous operations that may throw.
      Effect.tryPromise is for async/Promise-based operations.
      Using sync for async code returns a Promise object, not its result.
    fix_steps:
      - Use Effect.sync only for synchronous throwing code
      - Use Effect.tryPromise for any Promise-returning code
      - Use Effect.try for synchronous code with typed error transformation
    example:
      error: "Type 'Promise<T>' is not assignable to type 'T'"
      before: |
        // Wrong: Effect.sync returns immediately, Promise isn't awaited
        const fetchData = Effect.sync(() => {
          return fetch("/api/data").then(r => r.json());  // Returns Promise!
        });

        // Wrong: async function in Effect.sync
        const readFile = Effect.sync(async () => {
          return await fs.readFile("file.txt");  // Returns Promise!
        });
      after: |
        // Correct: Effect.tryPromise for async operations
        const fetchData = Effect.tryPromise({
          try: () => fetch("/api/data").then(r => r.json()),
          catch: (e) => new FetchError({ cause: e }),
        });

        // Correct: Or use Effect FileSystem service
        const readFile = Effect.gen(function* () {
          const fs = yield* FileSystem.FileSystem;
          return yield* fs.readFileString("file.txt");
        });

        // Effect.sync is only for sync throwing code
        const parseJson = (str: string) => Effect.try({
          try: () => JSON.parse(str),  // Synchronous!
          catch: (e) => new ParseError({ cause: e }),
        });
