# DSL Module Issue Resolution Orchestrator

## Context

You are orchestrating the systematic resolution of issues identified in a comprehensive code review of the SQL DSL module in the beep-effect monorepo. This module is located at `packages/common/schema/src/integrations/sql/dsl/`.

The code review identified **35+ issues** across 8 priority categories. Your role is to deploy sub-agents sequentially to research and fix each issue, ensuring thorough analysis before any code changes.

## Codebase Conventions

Read `CLAUDE.md` at the repo root first - it contains critical rules:
- Effect-first patterns (no native arrays, strings, Date, switch statements)
- Required imports: `A`, `F`, `O`, `P`, `S`, `Match`, `Struct`, `R`, etc.
- `Schema.TaggedError` for all errors
- No `any`, `@ts-ignore`, or unnecessary type assertions

## Module Scope

**Source files** (`packages/common/schema/src/integrations/sql/dsl/`):
- `Field.ts` - DSLField factory, curried API, VariantField handling
- `Model.ts` - Model composition, schema extraction
- `derive-column-type.ts` - AST → SQL column type derivation
- `nullability.ts` - Schema nullability detection
- `types.ts` - Core type definitions, symbols, branded types
- `literals.ts` - ColumnType enum and utilities
- `errors.ts` - TaggedError hierarchy for DSL validation
- `combinators.ts` - Schema combinators for DSL
- `validate.ts` - Runtime validation utilities
- `adapters/drizzle.ts` - Drizzle ORM integration
- `adapters/drizzle-to-effect-schema.ts` - Drizzle to Effect schema conversion

**Test files** (`packages/common/schema/test/integrations/sql/dsl/`):
- `derive-column-type.test.ts`, `combinators.test.ts`, `field-model-comprehensive.test.ts`
- `variant-integration.test.ts`, `drizzle-typed-columns.test.ts`, `poc.test.ts`
- `invariants/model-composition.test.ts`, `invariants/sql-standard.test.ts`

---

## Issue Catalog

### P0 - Critical (Fix First)

#### P0-1: Union Type Derivation Bug
- **File**: `derive-column-type.ts:373`
- **Issue**: After filtering null literals into `nonNullMembers`, the code checks `unionAst.types` (original array including nulls) instead of `nonNullMembers` when testing for string literals
- **Impact**: `S.NullOr(S.Literal("a", "b"))` incorrectly returns `"json"` instead of `"string"`
- **Expected Fix**: Change `unionAst.types` to `nonNullMembers` in the `allStringLiterals` check

#### P0-2: Native AggregateError Instead of TaggedError
- **File**: `Model.ts:337`
- **Issue**: Uses `throw new AggregateError(...)` instead of a Schema.TaggedError
- **Impact**: Cannot pattern match with `Match.tag`, breaks Effect error handling
- **Expected Fix**: Create `ModelValidationAggregateError` TaggedError wrapping the error array

---

### P1 - High Priority

#### P1-1: Mutable Array in validateModelInvariants
- **File**: `Model.ts:165`
- **Issue**: Uses `const errors: DSLValidationError[] = []` with `.push()` mutations
- **Expected Fix**: Use `A.empty()` and functional accumulation with `A.append`

#### P1-2: Native for...of Loop in Field.ts
- **File**: `Field.ts:51-56`
- **Issue**: `for (const key of schemaKeys)` loop
- **Expected Fix**: Replace with `A.findFirst` or `F.pipe(..., A.findFirst(...))`

#### P1-3: Native for...of Loop in Model.ts
- **File**: `Model.ts:476-490`
- **Issue**: `for (const variant of ModelVariant.Options)` loop
- **Expected Fix**: Replace with `F.pipe(ModelVariant.Options, A.forEach(...))`

#### P1-4: Native for...of Loop in drizzle-to-effect-schema.ts (1)
- **File**: `adapters/drizzle-to-effect-schema.ts:152-158`
- **Issue**: `for (const [name, column] of columnEntries)` loop
- **Expected Fix**: Replace with `A.reduce`

#### P1-5: Native for...of Loop in drizzle-to-effect-schema.ts (2)
- **File**: `adapters/drizzle-to-effect-schema.ts:198-202`
- **Issue**: `for (const [name, column] of columnEntries)` loop
- **Expected Fix**: Replace with `A.reduce`

#### P1-6: Non-Exhaustive Match Pattern
- **File**: `Model.ts:301-310`
- **Issue**: Uses if-else chains for field type checks instead of `Match.exhaustive`
- **Expected Fix**: Refactor to `Match.value(...).pipe(Match.when(...), Match.exhaustive)`

#### P1-7: Prototype Chain Shallow Copy
- **File**: `Field.ts:283-299`
- **Issue**: `Object.assign()` creates shared references to `schemas`
- **Expected Fix**: Deep clone or use immutable patterns

---

### P2 - Medium Priority (Type Safety)

#### P2-1: DSL.Fields Index Signature Uses any
- **File**: `types.ts:533-535`
- **Issue**: `DSLField<any, any, any>` in index signature
- **Expected Fix**: Replace with `unknown` or proper constraints

#### P2-2: ExtractColumnsType Uses UnsafeAny
- **File**: `Model.ts:43-49`
- **Issue**: `UnsafeTypes.UnsafeAny` in type conditionals
- **Expected Fix**: Use `unknown` or proper type inference

#### P2-3: ExtractPrimaryKeys Uses UnsafeAny
- **File**: `Model.ts:54-66`
- **Issue**: Same pattern as P2-2
- **Expected Fix**: Use `unknown` or proper type inference

#### P2-4: attachColumnDef Returns any
- **File**: `combinators.ts:119`
- **Issue**: Return type `DSLField<A, I, R, any>`
- **Expected Fix**: Use generic constraint for ColumnDef

#### P2-5: attachColumnDef Double Assertion
- **File**: `combinators.ts:121`
- **Issue**: `(self as any)[ColumnMetaSymbol] as ColumnDef | undefined`
- **Expected Fix**: Use type guard or indexed type

#### P2-6 through P2-12: Combinator `as any` Returns
- **Files**: `combinators.ts:173, 195, 217, 239, 261, 288, 310`
- **Issue**: Each combinator casts return to `as any`
- **Expected Fix**: Remove casts, let TypeScript infer from `ValidateSchemaColumn`

#### P2-13: drizzle-to-effect-schema Schema<any> Fallback
- **File**: `adapters/drizzle-to-effect-schema.ts:16,49`
- **Issue**: Uses `S.Schema<any>` as fallback
- **Expected Fix**: Use `S.Schema<unknown>` or throw for unsupported types

#### P2-14: drizzle-to-effect-schema RefineFunction Uses any
- **File**: `adapters/drizzle-to-effect-schema.ts:69-72`
- **Issue**: All schema types are `any`
- **Expected Fix**: Use `unknown` or proper generics

#### P2-15: mapColumnToSchema Returns any
- **File**: `adapters/drizzle-to-effect-schema.ts:212-213`
- **Issue**: `S.Schema<any, any>` return type
- **Expected Fix**: Use `S.Schema<unknown, unknown>`

---

### P3 - Low Priority (Effect Patterns)

#### P3-1: Native typeof Check
- **File**: `types.ts:548`
- **Issue**: `typeof u === "object"` instead of `P.isObject(u)`
- **Expected Fix**: Use Effect Predicate

#### P3-2: Native .join() Method
- **File**: `Field.ts:63`
- **Issue**: `schemaKeys.join(", ")` instead of `A.join`
- **Expected Fix**: `F.pipe(schemaKeys, A.join(", "))`

#### P3-3: Native .length Property (1)
- **File**: `adapters/drizzle-to-effect-schema.ts:225`
- **Issue**: `column.enumValues.length`
- **Expected Fix**: Use `A.isNonEmptyArray`

#### P3-4: Native .length Property (2)
- **File**: `adapters/drizzle-to-effect-schema.ts:278`
- **Issue**: `column.enumValues.length > 0`
- **Expected Fix**: Use `A.isNonEmptyArray`

---

### P4 - Documentation & Tests (After Code Fixes)

#### P4-1 through P4-8: Missing Test Files
- `nullability.test.ts` - Test `isNullable()` and `isSchemaTypeNullable()`
- `validate.test.ts` - Test `validateField()`, `validateModel()`, sync variants
- `drizzle-to-effect-schema.test.ts` - Test adapter functions
- Additional edge case tests for existing files

#### P4-9 through P4-16: Missing JSDoc
- Module-level docs for `index.ts`
- Parameter docs for `extractASTFromInput`, `attachColumnDef`
- Explanatory comments for complex types in `types.ts`

---

## Execution Strategy

### Phase 1: Research Before Fix

For EACH issue, deploy a **Researcher Agent** first:

```
subagent_type: "Explore"
model: "sonnet"
prompt: |
  Research issue [ID] in the DSL module.

  1. Read the file(s) involved: [file paths]
  2. Understand the surrounding context (100+ lines around the issue)
  3. Identify all related code that may be affected by the fix
  4. Check for existing tests that cover this code path
  5. Analyze potential side effects of the proposed fix
  6. Document any alternative approaches

  Write a detailed report to: .specs/dsl-review-1/issue-reports/[ID].md

  Report format:
  ## Issue [ID]: [Title]
  ### Current Code
  [Exact code snippet with line numbers]
  ### Problem Analysis
  [Why this is an issue, what breaks]
  ### Affected Files
  [List of files that reference or depend on this code]
  ### Proposed Fix
  [Exact code changes with before/after]
  ### Test Requirements
  [What tests should verify the fix]
  ### Risks & Considerations
  [Potential side effects, edge cases]
```

### Phase 2: Fix After Research

After the research report is written, deploy a **Fixer Agent**:

```
subagent_type: "effect-code-writer"
model: "sonnet"
prompt: |
  Fix issue [ID] following the research report at:
  .specs/dsl-review-1/issue-reports/[ID].md

  1. Read the research report thoroughly
  2. Apply the proposed fix exactly as documented
  3. Run type checking: `bun run check --filter @beep/schema`
  4. Run tests: `bun test packages/common/schema/test/integrations/sql/dsl/`
  5. If tests fail, analyze and fix
  6. Add any missing tests identified in the research report

  After fixing:
  - Mark the issue as resolved in the report
  - Document any deviations from the proposed fix
  - List any follow-up issues discovered
```

### Phase 3: Verification

After each fix, verify before proceeding:

```bash
bun run check --filter @beep/schema
bun test packages/common/schema/test/integrations/sql/dsl/
```

If either fails, the fixer agent must resolve before moving to the next issue.

---

## Orchestration Flow

```
FOR each issue in priority order (P0 → P1 → P2 → P3 → P4):
  1. Deploy Researcher Agent
     - Wait for completion
     - Verify report exists at .specs/dsl-review-1/issue-reports/[ID].md

  2. Deploy Fixer Agent
     - Wait for completion
     - Verify type check passes
     - Verify tests pass

  3. Log progress:
     - Issue ID, status, time taken
     - Any deviations or discoveries

  4. IF critical failure:
     - Stop and report
     - Do not proceed to next issue

  5. Proceed to next issue
```

---

## Important Constraints

1. **One agent at a time** - Never run research and fix in parallel
2. **Research first, always** - Never skip the research phase
3. **Verify before proceeding** - Type check and tests must pass
4. **Document everything** - Reports capture institutional knowledge
5. **Stop on failure** - Critical failures halt the pipeline

---

## Progress Tracking

Create/update `.specs/dsl-review-1/progress.md` after each issue:

```markdown
# DSL Review Progress

## Completed
- [ ] P0-1: Union Type Derivation Bug
- [ ] P0-2: AggregateError → TaggedError
- [ ] P1-1: Mutable Array
... (all issues)

## Current
- Issue: [ID]
- Status: Research | Fixing | Verifying
- Agent: [agent ID]

## Blocked
- [Any issues that couldn't be resolved]

## Discoveries
- [New issues found during fixes]
```

---

## Start Condition

Begin with P0-1 (Union Type Derivation Bug) as it's the most critical and has the clearest fix path. This will also validate the research → fix → verify pipeline before tackling more complex issues.
