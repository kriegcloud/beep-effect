# Effect Predicate Master Agent

## Mission Statement

The **effect-predicate-master** agent transforms imperative conditional logic into type-safe Effect primitives. It replaces:

- `typeof`, `instanceof`, `Array.isArray` checks with Effect Predicate functions
- `switch` statements with `Match.value().pipe(Match.tag(...), Match.exhaustive)`
- `if/else` chains with `Match.value().pipe(Match.when(pred, fn), ...)`
- Native comparison operators (`<`, `>`, `<=`, `>=`) with `Num.lessThan`, `Num.greaterThan`, etc.
- Null/undefined checks with Option predicates
- Native `Date` comparisons with `DateTime` predicates

The goal is **100% elimination of imperative conditionals** in favor of composable, type-safe, exhaustive-checked functional patterns.

---

## Import Convention

```typescript
import * as P from "effect/Predicate";
import * as Num from "effect/Number";
import * as BI from "effect/BigInt";
import * as Bool from "effect/Boolean";
import * as Match from "effect/Match";
import * as O from "effect/Option";
import * as S from "effect/Schema";
import * as Equal from "effect/Equal";
import * as Equivalence from "effect/Equivalence";
import * as DateTime from "effect/DateTime";
import * as Duration from "effect/Duration";
import * as A from "effect/Array";
import * as F from "effect/Function";
import * as List from "effect/List";
```

---

## Complete Predicate Function Reference

### 1. Core Predicate Module (`effect/Predicate`)

The foundational module for type-safe predicates and refinements.

#### Type Guards (Refinements)

| Function | Signature | Replaces | Type Narrowing |
|----------|-----------|----------|----------------|
| `isString` | `(input: unknown) => input is string` | `typeof x === "string"` | Yes |
| `isNumber` | `(input: unknown) => input is number` | `typeof x === "number"` | Yes |
| `isBoolean` | `(input: unknown) => input is boolean` | `typeof x === "boolean"` | Yes |
| `isBigInt` | `(input: unknown) => input is bigint` | `typeof x === "bigint"` | Yes |
| `isSymbol` | `(input: unknown) => input is symbol` | `typeof x === "symbol"` | Yes |
| `isFunction` | `(input: unknown) => input is Function` | `typeof x === "function"` | Yes |
| `isObject` | `(input: unknown) => input is object` | Manual object check | Yes |
| `isRecord` | `(input: unknown) => input is { [x: string \| symbol]: unknown }` | Plain object check | Yes |
| `isSet` | `(input: unknown) => input is Set<unknown>` | `x instanceof Set` | Yes |
| `isMap` | `(input: unknown) => input is Map<unknown, unknown>` | `x instanceof Map` | Yes |
| `isError` | `(input: unknown) => input is Error` | `x instanceof Error` | Yes |
| `isDate` | `(input: unknown) => input is Date` | `x instanceof Date` | Yes |
| `isRegExp` | `(input: unknown) => input is RegExp` | `x instanceof RegExp` | Yes |
| `isUint8Array` | `(input: unknown) => input is Uint8Array` | `x instanceof Uint8Array` | Yes |
| `isIterable` | `(input: unknown) => input is Iterable<unknown>` | Manual iterable check | Yes |
| `isPromise` | `(input: unknown) => input is Promise<unknown>` | Duck-type Promise check | Yes |
| `isPromiseLike` | `(input: unknown) => input is PromiseLike<unknown>` | Duck-type PromiseLike check | Yes |
| `isArray` | `(input: unknown) => input is Array<unknown>` | `Array.isArray(x)` | Yes |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
if (typeof value === "string") {
  console.log(value.toUpperCase());
}

// AFTER (REQUIRED)
if (P.isString(value)) {
  console.log(value.toUpperCase()); // TypeScript narrows to string
}
```

#### Null/Undefined Guards

| Function | Signature | Use Case |
|----------|-----------|----------|
| `isNull` | `(input: unknown) => input is null` | Check for `null` |
| `isNotNull` | `<A>(input: A) => input is Exclude<A, null>` | Filter out `null` |
| `isUndefined` | `(input: unknown) => input is undefined` | Check for `undefined` |
| `isNotUndefined` | `<A>(input: A) => input is Exclude<A, undefined>` | Filter out `undefined` |
| `isNullable` | `<A>(input: A) => input is Extract<A, null \| undefined>` | Check for `null` OR `undefined` |
| `isNotNullable` | `<A>(input: A) => input is NonNullable<A>` | Filter out both `null` and `undefined` |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
if (value !== null && value !== undefined) {
  console.log(value.toUpperCase());
}

// AFTER (REQUIRED)
if (P.isNotNullable(value)) {
  console.log(value.toUpperCase()); // Narrowed to string
}

// With Array filtering
const filtered = F.pipe(items, A.filter(P.isNotNullable));
// Type: NonNullable<T>[]
```

#### Property and Tag Guards

| Function | Signature | Use Case |
|----------|-----------|----------|
| `hasProperty` | `<P extends PropertyKey>(self: unknown, property: P) => self is { [K in P]: unknown }` | Replace `"prop" in obj` |
| `isTagged` | `<K extends string>(self: unknown, tag: K) => self is { _tag: K }` | Discriminated union guards |
| `isTupleOf` | `<N extends number>(self: ReadonlyArray<T>, n: N) => self is TupleOf<N, T>` | Exact tuple length |
| `isTupleOfAtLeast` | `<N extends number>(self: ReadonlyArray<T>, n: N) => self is TupleOfAtLeast<N, T>` | Minimum tuple length |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
if (obj && typeof obj === "object" && "name" in obj) {
  console.log((obj as any).name);
}

// AFTER (REQUIRED)
if (P.hasProperty(obj, "name")) {
  console.log(obj.name); // Type-safe access
}
```

#### Predicate Combinators

| Function | Signature | Logic | Replaces |
|----------|-----------|-------|----------|
| `and` | `<A>(self: Predicate<A>, that: Predicate<A>) => Predicate<A>` | `self && that` | `if (a && b)` |
| `or` | `<A>(self: Predicate<A>, that: Predicate<A>) => Predicate<A>` | `self \|\| that` | `if (a \|\| b)` |
| `not` | `<A>(self: Predicate<A>) => Predicate<A>` | `!self` | `if (!a)` |
| `xor` | `<A>(self: Predicate<A>, that: Predicate<A>) => Predicate<A>` | Exclusive OR | `if ((a && !b) \|\| (!a && b))` |
| `implies` | `<A>(antecedent: Predicate<A>, consequent: Predicate<A>) => Predicate<A>` | If-then | `if (a) then b` |
| `every` | `<A>(collection: Iterable<Predicate<A>>) => Predicate<A>` | All must pass | Loop with early return |
| `some` | `<A>(collection: Iterable<Predicate<A>>) => Predicate<A>` | At least one | Loop with early return |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
const isValid = (n: number): boolean => {
  return n > 0 && n < 100 && n % 2 === 0;
};

// AFTER (REQUIRED)
const isValid = F.pipe(
  Num.greaterThan(0),
  P.and(Num.lessThan(100)),
  P.and((n: number) => n % 2 === 0)
);
```

#### Structural Combinators

| Function | Signature | Use Case |
|----------|-----------|----------|
| `tuple` | `<T extends ReadonlyArray<Predicate.Any>>(...elements: T)` | Test tuple structure |
| `struct` | `<R extends Record<string, Predicate.Any>>(fields: R)` | Test object structure |
| `compose` | `<A, B extends A, C extends B>(ab: Refinement<A, B>, bc: Refinement<C, D>) => Refinement<A, D>` | Chain refinements |
| `mapInput` | `<A, B>(self: Predicate<A>, f: (b: B) => A) => Predicate<B>` | Transform input (contramap) |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
if (typeof obj.name === "string" && typeof obj.age === "number") {
  // ...
}

// AFTER (REQUIRED)
const isPerson = P.struct({
  name: P.isString,
  age: P.isNumber
});

if (isPerson(obj)) {
  // obj is narrowed to { name: string; age: number }
}
```

---

### 2. Number Module (`effect/Number`)

Predicates for numeric comparisons. All support dual (data-first and data-last) forms.

| Function | Signature | Replaces |
|----------|-----------|----------|
| `isNumber` | `(input: unknown) => input is number` | `typeof x === "number"` |
| `lessThan` | `{ (that: number): (self: number) => boolean; (self: number, that: number): boolean }` | `x < y` |
| `lessThanOrEqualTo` | `{ (that: number): (self: number) => boolean; (self: number, that: number): boolean }` | `x <= y` |
| `greaterThan` | `{ (that: number): (self: number) => boolean; (self: number, that: number): boolean }` | `x > y` |
| `greaterThanOrEqualTo` | `{ (that: number): (self: number) => boolean; (self: number, that: number): boolean }` | `x >= y` |
| `between` | `{ (options: { minimum: number; maximum: number }): (self: number) => boolean; ... }` | `x >= min && x <= max` |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
if (age >= 18 && age <= 65) {
  return "Working age";
}

// AFTER (REQUIRED)
if (Num.between(age, { minimum: 18, maximum: 65 })) {
  return "Working age";
}

// Or curried
const isWorkingAge = Num.between({ minimum: 18, maximum: 65 });
if (isWorkingAge(age)) {
  return "Working age";
}
```

**Utility Functions (not predicates, but related):**

| Function | Signature | Replaces |
|----------|-----------|----------|
| `min` | `(self: number, that: number) => number` | `Math.min(a, b)` |
| `max` | `(self: number, that: number) => number` | `Math.max(a, b)` |
| `clamp` | `(self: number, options: { minimum: number; maximum: number }) => number` | Manual clamping |
| `sign` | `(n: number) => Ordering` | `Math.sign(n)` |

---

### 3. BigInt Module (`effect/BigInt`)

Predicates for arbitrary-precision integers. Mirrors Number module API.

| Function | Signature | Replaces |
|----------|-----------|----------|
| `isBigInt` | `(u: unknown) => u is bigint` | `typeof x === "bigint"` |
| `lessThan` | `{ (that: bigint): (self: bigint) => boolean; ... }` | `x < y` (bigint) |
| `lessThanOrEqualTo` | `{ (that: bigint): (self: bigint) => boolean; ... }` | `x <= y` (bigint) |
| `greaterThan` | `{ (that: bigint): (self: bigint) => boolean; ... }` | `x > y` (bigint) |
| `greaterThanOrEqualTo` | `{ (that: bigint): (self: bigint) => boolean; ... }` | `x >= y` (bigint) |
| `between` | `{ (options: { minimum: bigint; maximum: bigint }): (self: bigint) => boolean; ... }` | Range check |
| `sign` | `(n: bigint) => Ordering` | Sign detection (-1, 0, 1) |

**Note:** BigInt lacks `isPositive`, `isNegative`, `isZero`. Use:
```typescript
const isPositive = (n: bigint) => BI.sign(n) === 1;
const isNegative = (n: bigint) => BI.sign(n) === -1;
const isZero = (n: bigint) => BI.sign(n) === 0;
```

---

### 4. BigDecimal Module (`effect/BigDecimal`)

Arbitrary-precision decimal predicates for financial/precise calculations.

| Function | Signature | Description |
|----------|-----------|-------------|
| `isBigDecimal` | `(u: unknown) => u is BigDecimal` | Type guard |
| `lessThan` | Dual form | Comparison |
| `lessThanOrEqualTo` | Dual form | Comparison |
| `greaterThan` | Dual form | Comparison |
| `greaterThanOrEqualTo` | Dual form | Comparison |
| `between` | Dual form | Range (inclusive) |
| `equals` | Dual form | Equality (scale-aware) |
| `isInteger` | `(n: BigDecimal) => boolean` | No fractional part |
| `isZero` | `(n: BigDecimal) => boolean` | Equals zero |
| `isNegative` | `(n: BigDecimal) => boolean` | Less than zero |
| `isPositive` | `(n: BigDecimal) => boolean` | Greater than zero |

---

### 5. Boolean Module (`effect/Boolean`)

Logical operations on boolean values.

| Function | Signature | Description |
|----------|-----------|-------------|
| `isBoolean` | `(input: unknown) => input is boolean` | Type guard |
| `not` | `(self: boolean) => boolean` | Negation |
| `and` | Dual form | Logical AND |
| `or` | Dual form | Logical OR |
| `xor` | Dual form | Exclusive OR |
| `nand` | Dual form | NOT AND |
| `nor` | Dual form | NOT OR |
| `eqv` | Dual form | Equivalence (XNOR) |
| `implies` | Dual form | If-then (`!self \|\| that`) |
| `every` | `(collection: Iterable<boolean>) => boolean` | All true |
| `some` | `(collection: Iterable<boolean>) => boolean` | At least one true |
| `match` | Pattern matching | Lazy branching |

**Example - implies:**
```typescript
// "If premium, then must have payment method"
const validSubscription = Bool.implies(user.isPremium, user.hasPaymentMethod);
```

---

### 6. DateTime Module (`effect/DateTime`)

Immutable, timezone-aware date/time predicates. **Replaces all native Date comparisons.**

#### Type Guards

| Function | Signature | Description |
|----------|-----------|-------------|
| `isDateTime` | `(u: unknown) => u is DateTime` | Any DateTime |
| `isUtc` | `(self: DateTime) => self is Utc` | UTC variant |
| `isZoned` | `(self: DateTime) => self is Zoned` | Zoned variant |
| `isTimeZone` | `(u: unknown) => u is TimeZone` | TimeZone type |
| `isTimeZoneOffset` | `(u: unknown) => u is TimeZone.Offset` | Offset timezone |
| `isTimeZoneNamed` | `(u: unknown) => u is TimeZone.Named` | Named timezone |

#### Comparison Predicates

| Function | Signature | Description |
|----------|-----------|-------------|
| `greaterThan` | Dual form | After check |
| `greaterThanOrEqualTo` | Dual form | After or equal |
| `lessThan` | Dual form | Before check |
| `lessThanOrEqualTo` | Dual form | Before or equal |
| `between` | Dual form | Range (inclusive) |
| `isFuture` | `(self: DateTime) => Effect.Effect<boolean>` | After current time (Effect) |
| `unsafeIsFuture` | `(self: DateTime) => boolean` | After current time (sync) |
| `isPast` | `(self: DateTime) => Effect.Effect<boolean>` | Before current time (Effect) |
| `unsafeIsPast` | `(self: DateTime) => boolean` | Before current time (sync) |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
const date1 = new Date("2024-01-01");
if (date1 > new Date()) {
  // future
}

// AFTER (REQUIRED)
const date1 = DateTime.unsafeMake("2024-01-01");
if (DateTime.unsafeIsFuture(date1)) {
  // future
}
```

---

### 7. Duration Module (`effect/Duration`)

Time duration predicates.

| Function | Signature | Description |
|----------|-----------|-------------|
| `isDuration` | `(u: unknown) => u is Duration` | Type guard |
| `isFinite` | `(self: Duration) => boolean` | Not infinite |
| `isZero` | `(self: Duration) => boolean` | Zero duration |
| `lessThan` | Dual form | Comparison |
| `lessThanOrEqualTo` | Dual form | Comparison |
| `greaterThan` | Dual form | Comparison |
| `greaterThanOrEqualTo` | Dual form | Comparison |
| `equals` | Dual form | Equality |
| `between` | Dual form | Range check |

---

### 8. Equal Module (`effect/Equal`)

Structural equality protocol.

| Function | Signature | Description |
|----------|-----------|-------------|
| `equals` | `<A, B>(self: A, that: B) => boolean` | Structural equality |
| `isEqual` | `(u: unknown) => u is Equal` | Implements Equal protocol |
| `equivalence` | `<A>() => Equivalence<A>` | Equivalence instance |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
const obj1 = { id: 1 };
const obj2 = { id: 1 };
obj1 === obj2; // false (referential)

// AFTER (REQUIRED)
Equal.equals(obj1, obj2); // true (structural)
```

---

### 9. Equivalence Module (`effect/Equivalence`)

Equivalence relations for comparing two values.

| Function | Signature | Description |
|----------|-----------|-------------|
| `make` | `<A>(isEquivalent: (self: A, that: A) => boolean) => Equivalence<A>` | Custom equivalence |
| `strict` | `<A>() => Equivalence<A>` | Reference equality (`===`) |
| `string` | `Equivalence<string>` | String equality |
| `number` | `Equivalence<number>` | Number equality |
| `boolean` | `Equivalence<boolean>` | Boolean equality |
| `bigint` | `Equivalence<bigint>` | BigInt equality |
| `symbol` | `Equivalence<symbol>` | Symbol equality |
| `Date` | `Equivalence<Date>` | Date equality (by timestamp) |
| `mapInput` | `<B, A>(f: (b: B) => A) => (self: Equivalence<A>) => Equivalence<B>` | Contravariant map |
| `struct` | `<R>(fields: R) => Equivalence<...>` | Struct equivalence |
| `array` | `<A>(item: Equivalence<A>) => Equivalence<ReadonlyArray<A>>` | Array equivalence |
| `tuple` | `<T extends Equivalence<any>[]>(...elements: T) => Equivalence<[...]>` | Tuple equivalence |

---

### 10. Option Module (`effect/Option`)

Predicates for optional values.

#### Type Guards

| Function | Signature | Description |
|----------|-----------|-------------|
| `isOption` | `(input: unknown) => input is Option<unknown>` | Any Option |
| `isSome` | `<A>(self: Option<A>) => self is Some<A>` | Contains value |
| `isNone` | `<A>(self: Option<A>) => self is None<A>` | Empty |

#### Predicate-Based Constructors

| Function | Signature | Replaces |
|----------|-----------|----------|
| `liftPredicate` | `<A, B extends A>(refinement: Refinement<A, B>) => (a: A) => Option<B>` | `if (pred) return value else null` |
| `fromNullable` | `<A>(value: A) => Option<NonNullable<A>>` | Nullable to Option |
| `liftNullable` | `<A, B>(f: (...a: A) => B \| null \| undefined) => (...a: A) => Option<B>` | Wrap nullable functions |
| `liftThrowable` | `<A, B>(f: (...a: A) => B) => (...a: A) => Option<B>` | Wrap throwing functions |
| `toRefinement` | `<A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B` | Option function to type guard |

#### Filtering and Testing

| Function | Signature | Description |
|----------|-----------|-------------|
| `filter` | `<A, B extends A>(refinement: Refinement<A, B>) => (self: Option<A>) => Option<B>` | Filter with predicate |
| `exists` | `<A, B extends A>(refinement: Refinement<A, B>) => (self: Option<A>) => self is Option<B>` | Test contained value |
| `contains` | `<A>(a: A) => (self: Option<A>) => boolean` | Contains specific value |
| `containsWith` | `<A>(isEquivalent: (self: A, that: A) => boolean) => ...` | Custom equality check |

**Example Transformation:**
```typescript
// BEFORE (FORBIDDEN)
function validateAge(age: unknown): number | null {
  if (typeof age !== "number") return null;
  if (age < 0 || age > 120) return null;
  return age;
}

// AFTER (REQUIRED)
const validateAge = (age: unknown): O.Option<number> =>
  F.pipe(
    age,
    O.liftPredicate(P.isNumber),
    O.filter(Num.between({ minimum: 0, maximum: 120 }))
  );
```

---

### 11. Array Module (`effect/Array`)

Predicate-based array operations.

#### Type Guards

| Function | Signature | Description |
|----------|-----------|-------------|
| `isEmptyArray` | `<A>(self: Array<A>) => self is []` | Empty array guard |
| `isNonEmptyArray` | `<A>(self: Array<A>) => self is NonEmptyArray<A>` | Non-empty guard |

#### Predicate Consumers

| Function | Description | Returns |
|----------|-------------|---------|
| `filter` | Keep elements matching predicate | `Array<B>` (with refinement) |
| `filterMap` | Map + filter in one pass | `Array<B>` |
| `partition` | Split by predicate | `[excluded, satisfying]` |
| `partitionMap` | Map to Either and split | `[lefts, rights]` |
| `findFirst` | First matching element | `Option<A>` |
| `findLast` | Last matching element | `Option<A>` |
| `findFirstIndex` | Index of first match | `Option<number>` |
| `findLastIndex` | Index of last match | `Option<number>` |
| `takeWhile` | Take while predicate holds | `Array<A>` |
| `dropWhile` | Drop while predicate holds | `Array<A>` |
| `span` | Split at first failure | `[init, rest]` |
| `every` | All elements satisfy | `boolean` (narrows array type) |
| `some` | At least one satisfies | `boolean` (narrows to NonEmpty) |
| `contains` | Contains specific value | `boolean` |
| `dedupeWith` | Remove duplicates with equivalence | `Array<A>` |

**Example - Type Narrowing:**
```typescript
const values: Array<string | number> = [1, "hello", 2, "world"];

// Filter narrows type
const numbers = F.pipe(values, A.filter(P.isNumber));
// Type: Array<number>

// Every narrows entire array
if (F.pipe(values, A.every(P.isNumber))) {
  // values is Array<number> here
}
```

---

### 12. List Module (`effect/List`)

Immutable linked list predicates.

| Function | Signature | Description |
|----------|-----------|-------------|
| `isList` | `(u: unknown) => u is List<unknown>` | List type guard |
| `isNil` | `<A>(self: List<A>) => self is Nil<A>` | Empty list |
| `isCons` | `<A>(self: List<A>) => self is Cons<A>` | Non-empty list |
| `every` | `<A, B extends A>(refinement: Refinement<A, B>) => (self: List<A>) => self is List<B>` | All satisfy |
| `some` | `<A>(predicate: Predicate<A>) => (self: List<A>) => self is Cons<A>` | At least one |
| `filter` | With refinement support | Filtered list |
| `partition` | With refinement support | `[excluded, satisfying]` |
| `findFirst` | First matching | `Option<A>` |
| `filterMap` | Map + filter | `List<B>` |
| `compact` | Remove None values | `List<A>` |

---

### 13. Match Module (`effect/Match`)

**The primary replacement for switch statements and if/else chains.**

#### Creating Matchers

| Function | Signature | Use Case |
|----------|-----------|----------|
| `type<T>()` | `Matcher<T, ...>` | Reusable type-based matcher |
| `value(v)` | `Matcher<typeof v, ...>` | One-off value matching |
| `valueTags` | Object-style | Inline discriminated union matching |
| `typeTags<T>()` | Object-style | Type-based discriminated union |
| `withReturnType<Ret>()` | Enforces return type | Must be first in pipe |

#### Pattern Matching

| Function | Description |
|----------|-------------|
| `when(pattern, fn)` | Match value/predicate/object pattern |
| `whenOr(...patterns, fn)` | Match any of multiple patterns (OR) |
| `whenAnd(...patterns, fn)` | Match all patterns (AND) |
| `not(pattern, fn)` | Exclude specific value |

#### Discriminated Unions

| Function | Description |
|----------|-------------|
| `tag(...tags, fn)` | Match by `_tag` field |
| `tags(obj)` | Object-style (partial) |
| `tagsExhaustive(obj)` | Object-style (exhaustive) |
| `tagStartsWith(prefix, fn)` | Match tag prefix |
| `discriminator(field)` | Generic discriminator |
| `discriminators(field)(obj)` | Object-style generic |
| `discriminatorsExhaustive(field)(obj)` | Exhaustive generic |

#### Built-in Predicates

| Predicate | Type |
|-----------|------|
| `Match.string` | `Refinement<unknown, string>` |
| `Match.number` | `Refinement<unknown, number>` |
| `Match.boolean` | `Refinement<unknown, boolean>` |
| `Match.bigint` | `Refinement<unknown, bigint>` |
| `Match.symbol` | `Refinement<unknown, symbol>` |
| `Match.null` | `Refinement<unknown, null>` |
| `Match.undefined` | `Refinement<unknown, undefined>` |
| `Match.any` | Matches anything |
| `Match.defined` | Non-null and non-undefined |
| `Match.nonEmptyString` | Non-empty string |
| `Match.date` | Date instance |
| `Match.record` | Plain object |
| `Match.is(...literals)` | Specific literal values |
| `Match.instanceOf(Class)` | Class instances |

#### Completion

| Function | Description |
|----------|-------------|
| `exhaustive` | Compile error if cases missing |
| `orElse(fn)` | Default fallback |
| `orElseAbsurd` | Throw if unmatched |
| `either` | Return `Either<A, R>` |
| `option` | Return `Option<A>` |

**Example - Switch Replacement:**
```typescript
// BEFORE (FORBIDDEN)
switch (response._tag) {
  case "loading":
    return "Loading...";
  case "success":
    return `Found ${response.data.length} items`;
  case "error":
    return `Error: ${response.error}`;
  default:
    return "Unknown"; // Not type-safe!
}

// AFTER (REQUIRED)
const getMessage = Match.type<Response>().pipe(
  Match.tag("loading", () => "Loading..."),
  Match.tag("success", (r) => `Found ${r.data.length} items`),
  Match.tag("error", (r) => `Error: ${r.error}`),
  Match.exhaustive // Compile error if any case missing
);
```

**Example - If/Else Replacement:**
```typescript
// BEFORE (FORBIDDEN)
if (typeof value === "string") {
  return `String: ${value}`;
} else if (typeof value === "number") {
  return `Number: ${value}`;
} else if (Array.isArray(value)) {
  return `Array: ${value.length}`;
} else {
  return "Unknown";
}

// AFTER (REQUIRED)
const result = Match.value(value).pipe(
  Match.when(P.isString, (s) => `String: ${s}`),
  Match.when(P.isNumber, (n) => `Number: ${n}`),
  Match.when(P.isArray, (a) => `Array: ${a.length}`),
  Match.orElse(() => "Unknown")
);
```

---

### 14. Schema Module (`effect/Schema`)

Schema-based validation predicates.

#### Type Guards

| Function | Description |
|----------|-------------|
| `is(schema)` | Generate type guard from schema |
| `asserts(schema)` | Generate assertion (throws on failure) |
| `isSchema` | Check if value is a Schema |
| `isPropertySignature` | Check if value is PropertySignature |

#### Validation Functions

| Function | Returns | Description |
|----------|---------|-------------|
| `validate(schema)` | `Effect<A, ParseError, R>` | Effect-based validation |
| `validateEither(schema)` | `Either<A, ParseError>` | Either-based validation |
| `validateSync(schema)` | `A` (throws) | Synchronous validation |
| `validateOption(schema)` | `Option<A>` | Option-based validation |
| `validatePromise(schema)` | `Promise<A>` | Promise-based validation |

#### Filter Functions

| Category | Functions |
|----------|-----------|
| **Core** | `filter`, `filterEffect` |
| **String** | `minLength`, `maxLength`, `length`, `pattern`, `startsWith`, `endsWith`, `lowercased`, `uppercased`, `capitalized` |
| **Number** | `greaterThan`, `greaterThanOrEqualTo`, `lessThan`, `lessThanOrEqualTo`, `between`, `int`, `finite`, `nonNaN`, `positive`, `negative`, `nonPositive`, `nonNegative` |
| **BigInt** | All number filters with `BigInt` suffix |
| **BigDecimal** | All number filters with `BigDecimal` suffix |

**Example:**
```typescript
const UserSchema = S.Struct({
  id: S.Number.pipe(S.int(), S.positive()),
  email: S.String.pipe(S.pattern(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)),
  age: S.Number.pipe(S.int(), S.between(0, 150))
});

// Generate type guard
const isUser = S.is(UserSchema);

if (isUser(data)) {
  // data is validated User type
}
```

---

### 15. Function Module (`effect/Function`)

Utilities for predicate composition.

| Function | Description | Use Case |
|----------|-------------|----------|
| `pipe` | Sequential composition | Primary composition tool |
| `flow` | Create new function from pipeline | Reusable predicate functions |
| `dual` | Data-first and data-last support | Custom predicate combinators |
| `identity` | Returns input unchanged | No-op default |
| `constant` | Always returns same value | Fixed results |
| `constTrue` | Always true | Feature flags |
| `constFalse` | Always false | Disabled predicates |
| `isFunction` | Function type guard | Runtime checks |

---

## Transformation Rules

### Rule 1: Replace `typeof` with Type Guards

| Before | After |
|--------|-------|
| `typeof x === "string"` | `P.isString(x)` |
| `typeof x === "number"` | `P.isNumber(x)` |
| `typeof x === "boolean"` | `P.isBoolean(x)` |
| `typeof x === "bigint"` | `P.isBigInt(x)` |
| `typeof x === "symbol"` | `P.isSymbol(x)` |
| `typeof x === "function"` | `P.isFunction(x)` |
| `typeof x === "object"` | `P.isObject(x)` (or `P.isRecord(x)` for plain objects) |

### Rule 2: Replace `instanceof` with Type Guards

| Before | After |
|--------|-------|
| `x instanceof Date` | `P.isDate(x)` |
| `x instanceof Error` | `P.isError(x)` |
| `x instanceof Map` | `P.isMap(x)` |
| `x instanceof Set` | `P.isSet(x)` |
| `x instanceof RegExp` | `P.isRegExp(x)` |
| `x instanceof Promise` | `P.isPromise(x)` |
| `x instanceof Array` | `P.isArray(x)` |
| `x instanceof CustomClass` | `Match.instanceOf(CustomClass)` |

### Rule 3: Replace Comparison Operators

| Before | After |
|--------|-------|
| `x < y` | `Num.lessThan(x, y)` |
| `x <= y` | `Num.lessThanOrEqualTo(x, y)` |
| `x > y` | `Num.greaterThan(x, y)` |
| `x >= y` | `Num.greaterThanOrEqualTo(x, y)` |
| `x >= min && x <= max` | `Num.between(x, { minimum: min, maximum: max })` |

### Rule 4: Replace Null/Undefined Checks

| Before | After |
|--------|-------|
| `x === null` | `P.isNull(x)` |
| `x !== null` | `P.isNotNull(x)` |
| `x === undefined` | `P.isUndefined(x)` |
| `x !== undefined` | `P.isNotUndefined(x)` |
| `x != null` | `P.isNotNullable(x)` |
| `x ?? fallback` | `O.getOrElse(O.fromNullable(x), () => fallback)` |

### Rule 5: Replace Switch Statements

```typescript
// BEFORE
switch (value._tag) {
  case "A": return handleA(value);
  case "B": return handleB(value);
  default: return handleDefault();
}

// AFTER
Match.value(value).pipe(
  Match.tag("A", handleA),
  Match.tag("B", handleB),
  Match.exhaustive // or Match.orElse(handleDefault)
);
```

### Rule 6: Replace If/Else Chains

```typescript
// BEFORE
if (condA) {
  return resultA;
} else if (condB) {
  return resultB;
} else {
  return resultC;
}

// AFTER
Match.value(input).pipe(
  Match.when(predA, () => resultA),
  Match.when(predB, () => resultB),
  Match.orElse(() => resultC)
);
```

### Rule 7: Replace Boolean Logic

| Before | After |
|--------|-------|
| `a && b` | `P.and(predA, predB)` or `Bool.and(a, b)` |
| `a \|\| b` | `P.or(predA, predB)` or `Bool.or(a, b)` |
| `!a` | `P.not(predA)` or `Bool.not(a)` |
| `if (a) then b` | `Bool.implies(a, b)` |

### Rule 8: Replace Array Methods

| Before | After |
|--------|-------|
| `arr.filter(x => x != null)` | `F.pipe(arr, A.filter(P.isNotNullable))` |
| `arr.find(pred)` | `F.pipe(arr, A.findFirst(pred))` |
| `arr.some(pred)` | `F.pipe(arr, A.some(pred))` |
| `arr.every(pred)` | `F.pipe(arr, A.every(pred))` |

### Rule 9: Replace Property Checks

| Before | After |
|--------|-------|
| `"prop" in obj` | `P.hasProperty(obj, "prop")` |
| `obj._tag === "Tag"` | `P.isTagged(obj, "Tag")` |

### Rule 10: Replace Date Comparisons

| Before | After |
|--------|-------|
| `date1 > date2` | `DateTime.greaterThan(date1, date2)` |
| `date < new Date()` | `DateTime.unsafeIsPast(date)` |
| `date > new Date()` | `DateTime.unsafeIsFuture(date)` |

---

## Edge Cases and Caveats

### 1. `P.not` Returns Predicate, Not Refinement

```typescript
// ❌ This loses type information
const isNotString = P.not(P.isString);
// isNotString is Predicate<unknown>, not Refinement

// ✅ For type narrowing, use Match.not or manual refinement
Match.value(value).pipe(
  Match.not(P.isString, (v) => /* v is unknown, not non-string */),
  Match.orElse(() => /* ... */)
);
```

### 2. `Num.isNumber` Includes NaN and Infinity

```typescript
P.isNumber(NaN);       // true
P.isNumber(Infinity);  // true

// For finite numbers only:
F.pipe(value, P.isNumber, P.and((n) => Number.isFinite(n)));
// Or use Schema:
const isFiniteNumber = S.is(S.Number.pipe(S.finite()));
```

### 3. `P.isRecord` vs `P.isObject`

```typescript
P.isObject([]);        // true (arrays are objects)
P.isObject(() => {});  // true (functions are objects)
P.isRecord([]);        // false (excludes arrays)
P.isRecord(() => {});  // false (excludes functions)
P.isRecord({});        // true (plain objects only)
```

### 4. `isTruthy` Does Not Narrow Types

```typescript
P.isTruthy(value);  // returns boolean, doesn't narrow type
// Use P.isNotNullable for type narrowing
```

### 5. Match Requires First Combinator for Return Type

```typescript
// ✅ withReturnType must be first
Match.type<Input>().pipe(
  Match.withReturnType<string>(),  // FIRST!
  Match.when(...),
  Match.exhaustive
);

// ❌ Won't work if not first
Match.type<Input>().pipe(
  Match.when(...),
  Match.withReturnType<string>(),  // TOO LATE
  Match.exhaustive
);
```

### 6. `between` is Inclusive on Both Ends

```typescript
Num.between(5, { minimum: 5, maximum: 10 });  // true
Num.between(10, { minimum: 5, maximum: 10 }); // true
```

### 7. Schema `is` Uses Exact Mode by Default

```typescript
const isUser = S.is(UserSchema);
// Strict validation - extra properties cause failure

// For lenient validation:
const isUserLenient = S.is(UserSchema, { exact: false });
```

---

## Best Practices

### 1. Always Use Predicates for Type Narrowing

```typescript
// ❌ FORBIDDEN
if (typeof x === "string") { ... }

// ✅ REQUIRED
if (P.isString(x)) { ... }
```

### 2. Prefer Match Over Switch

```typescript
// ❌ FORBIDDEN
switch (response._tag) { ... }

// ✅ REQUIRED
Match.value(response).pipe(
  Match.tag("success", ...),
  Match.tag("error", ...),
  Match.exhaustive
);
```

### 3. Use exhaustive for Discriminated Unions

```typescript
// ✅ Compile error if new case added
Match.exhaustive

// ⚠️ Avoid unless intentionally handling "other" cases
Match.orElse(() => ...)
```

### 4. Compose Predicates with P.and/P.or

```typescript
// ✅ GOOD - Composable
const isValidAge = P.and(
  Num.greaterThanOrEqualTo(0),
  Num.lessThanOrEqualTo(120)
);

// ❌ BAD - Not composable
const isValidAge = (n: number) => n >= 0 && n <= 120;
```

### 5. Use Struct for Object Validation

```typescript
// ✅ GOOD - Structural predicate
const isPerson = P.struct({
  name: P.isString,
  age: P.isNumber
});

// ❌ BAD - Manual checks
if (typeof obj.name === "string" && typeof obj.age === "number") { ... }
```

### 6. Filter Arrays with Effect Predicates

```typescript
// ❌ FORBIDDEN
const filtered = items.filter(x => x != null);

// ✅ REQUIRED
const filtered = F.pipe(items, A.filter(P.isNotNullable));
```

### 7. Use hasProperty for Safe Property Access

```typescript
// ❌ FORBIDDEN
if ("prop" in obj && obj.prop) { ... }

// ✅ REQUIRED
if (P.hasProperty(obj, "prop")) {
  console.log(obj.prop); // Type-safe
}
```

### 8. Use DateTime Instead of Date

```typescript
// ❌ FORBIDDEN - Mutable, error-prone
new Date("2025-01-15") > new Date();

// ✅ REQUIRED - Immutable, type-safe
DateTime.unsafeIsFuture(DateTime.unsafeMake("2025-01-15"));
```

### 9. Use Schema for Complex Validation

```typescript
// ✅ Define schema once, use everywhere
const UserSchema = S.Struct({
  id: S.Number.pipe(S.positive()),
  email: S.String.pipe(S.pattern(/^.+@.+$/))
});

const isUser = S.is(UserSchema);
const validateUser = S.validate(UserSchema);
```

### 10. Use tagsExhaustive for Object-Style Matching

```typescript
// ✅ Clean and exhaustive
Match.type<Event>().pipe(
  Match.tagsExhaustive({
    fetch: () => "Loading",
    success: (e) => `Data: ${e.data}`,
    error: (e) => `Error: ${e.error}`
  })
);
```

---

## Quick Reference Card

### Type Checks
```typescript
P.isString(x)          // typeof x === "string"
P.isNumber(x)          // typeof x === "number"
P.isBoolean(x)         // typeof x === "boolean"
P.isNotNullable(x)     // x != null
P.hasProperty(x, "k")  // "k" in x
P.isTagged(x, "Tag")   // x._tag === "Tag"
P.isArray(x)           // Array.isArray(x)
P.isDate(x)            // x instanceof Date
```

### Number Comparisons
```typescript
Num.lessThan(x, y)                           // x < y
Num.greaterThan(x, y)                        // x > y
Num.between(x, { minimum: a, maximum: b })   // a <= x <= b
```

### Predicate Composition
```typescript
P.and(predA, predB)    // predA && predB
P.or(predA, predB)     // predA || predB
P.not(pred)            // !pred
P.struct({ a: P.isString, b: P.isNumber })   // Object validation
```

### Pattern Matching
```typescript
Match.value(x).pipe(
  Match.tag("A", handleA),
  Match.tag("B", handleB),
  Match.exhaustive
);

Match.value(x).pipe(
  Match.when(P.isString, (s) => ...),
  Match.when(P.isNumber, (n) => ...),
  Match.orElse(() => ...)
);
```

### Option from Nullable
```typescript
O.fromNullable(x)              // null/undefined -> None
O.liftPredicate(pred)(x)       // pred(x) ? Some(x) : None
O.filter(pred)(option)         // Keep if pred passes
```

### Array Operations
```typescript
F.pipe(arr, A.filter(P.isNotNullable))   // Remove null/undefined
F.pipe(arr, A.findFirst(pred))           // Option<A>
F.pipe(arr, A.every(pred))               // All match
F.pipe(arr, A.some(pred))                // Any match
```

---

## Summary

This agent systematically replaces imperative conditional logic with Effect's type-safe, composable predicates:

1. **Type Guards**: Replace `typeof`/`instanceof` with `P.is*` functions
2. **Comparisons**: Replace operators with `Num.*` functions
3. **Control Flow**: Replace `switch`/`if-else` with `Match.*`
4. **Nullability**: Replace null checks with `Option` and `P.isNotNullable`
5. **Validation**: Replace manual checks with Schema filters
6. **Collections**: Replace native array methods with Effect Array + predicates

The result is code that is:
- **Type-safe**: TypeScript narrows types correctly
- **Exhaustive**: Missing cases cause compile errors
- **Composable**: Predicates combine cleanly
- **Readable**: Declarative patterns over imperative logic
