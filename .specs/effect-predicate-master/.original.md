# Effect Predicate Master Agent

## Mission Statement

Replace imperative conditional checks (`if`, `switch`, `typeof`, `instanceof`) with Effect primitives for better type-safety and type-narrowing. This agent transforms JavaScript/TypeScript control flow into declarative, composable, and type-safe Effect patterns.

---

## Import Conventions

```typescript
import * as P from "effect/Predicate"
import * as Num from "effect/Number"
import * as Bool from "effect/Boolean"
import * as Match from "effect/Match"
import * as O from "effect/Option"
import * as S from "effect/Schema"
import * as Equal from "effect/Equal"
import * as Equivalence from "effect/Equivalence"
import * as DateTime from "effect/DateTime"
import * as Duration from "effect/Duration"
import * as A from "effect/Array"
import * as BI from "effect/BigInt"
import * as BigDecimal from "effect/BigDecimal"
import * as List from "effect/List"
import * as F from "effect/Function"
```

---

## Replacement Patterns by Module

### 1. Type Guards (effect/Predicate)

| Imperative                | Effect              | Type Narrows To |
|---------------------------|---------------------|-----------------|
| `typeof x === "string"`   | `P.isString(x)`     | `string`        |
| `typeof x === "number"`   | `P.isNumber(x)`     | `number`        |
| `typeof x === "boolean"`  | `P.isBoolean(x)`    | `boolean`       |
| `typeof x === "bigint"`   | `P.isBigInt(x)`     | `bigint`        |
| `typeof x === "symbol"`   | `P.isSymbol(x)`     | `symbol`        |
| `typeof x === "function"` | `P.isFunction(x)`   | `Function`      |
| `typeof x === "object"`   | `P.isObject(x)`     | `object`        |
| `x instanceof Date`       | `P.isDate(x)`       | `Date`          |
| `x instanceof Error`      | `P.isError(x)`      | `Error`         |
| `x instanceof RegExp`     | `P.isRegExp(x)`     | `RegExp`        |
| `x instanceof Map`        | `P.isMap(x)`        | `Map`           |
| `x instanceof Set`        | `P.isSet(x)`        | `Set`           |
| `x instanceof Promise`    | `P.isPromise(x)`    | `Promise`       |
| `x instanceof Uint8Array` | `P.isUint8Array(x)` | `Uint8Array`    |
| `Array.isArray(x)`        | `P.isArray(x)`      | `Array`         |
| `Symbol.iterator in x`    | `P.isIterable(x)`   | `Iterable`      |

### 2. Null/Undefined Checks

| Imperative        | Effect                | Type Narrows To         |
|-------------------|-----------------------|-------------------------|
| `x === null`      | `P.isNull(x)`         | `null`                  |
| `x !== null`      | `P.isNotNull(x)`      | `Exclude<A, null>`      |
| `x === undefined` | `P.isUndefined(x)`    | `undefined`             |
| `x !== undefined` | `P.isNotUndefined(x)` | `Exclude<A, undefined>` |
| `x == null`       | `P.isNullable(x)`     | `null \| undefined`     |
| `x != null`       | `P.isNotNullable(x)`  | `NonNullable<A>`        |

### 3. Property & Tag Checks

| Imperative           | Effect                       | Type Narrows To     |
|----------------------|------------------------------|---------------------|
| `"prop" in obj`      | `P.hasProperty(obj, "prop")` | `{ prop: unknown }` |
| `obj._tag === "Foo"` | `P.isTagged(obj, "Foo")`     | `{ _tag: "Foo" }`   |


### 4. Number Comparisons (effect/Number)

| Imperative             | Effect                                           |
|------------------------|--------------------------------------------------|
| `x < y`                | `Num.lessThan(y)(x)`                             |
| `x <= y`               | `Num.lessThanOrEqualTo(y)(x)`                    |
| `x > y`                | `Num.greaterThan(y)(x)`                          |
| `x >= y`               | `Num.greaterThanOrEqualTo(y)(x)`                 |
| `x >= min && x <= max` | `Num.between({ minimum: min, maximum: max })(x)` |

### 5. BigInt Comparisons (effect/BigInt)

| Imperative | Effect                  |
|------------|-------------------------|
| `x < y`    | `BI.lessThan(y)(x)`     |
| `x > 0n`   | `BI.greaterThan(0n)(x)` |
| `n < 0n`   | `BI.sign(n) === -1`     |
| `n === 0n` | `BI.sign(n) === 0`      |

### 6. BigDecimal Comparisons (effect/BigDecimal)

| Imperative      | Effect                          |
|-----------------|---------------------------------|
| `price > 0`     | `BigDecimal.isPositive(price)`  |
| `amount < 0`    | `BigDecimal.isNegative(amount)` |
| `total === 0`   | `BigDecimal.isZero(total)`      |
| `val % 1 === 0` | `BigDecimal.isInteger(val)`     |

### 7. DateTime Comparisons (effect/DateTime)

| Imperative                      | Effect                               |
|---------------------------------|--------------------------------------|
| `date1 > date2`                 | `DateTime.greaterThan(date1, date2)` |
| `date1 < date2`                 | `DateTime.lessThan(date1, date2)`    |
| `date > new Date()`             | `DateTime.unsafeIsFuture(date)`      |
| `date < new Date()`             | `DateTime.unsafeIsPast(date)`        |
| `d1.getTime() === d2.getTime()` | `DateTime.Equivalence(d1, d2)`       |

### 8. Duration Comparisons (effect/Duration)

| Imperative             | Effect                      |
|------------------------|-----------------------------|
| `d1 < d2`              | `Duration.lessThan(d1, d2)` |
| `d.value === Infinity` | `!Duration.isFinite(d)`     |
| `d === 0`              | `Duration.isZero(d)`        |

### 9. Equality (effect/Equal)

| Imperative                                | Effect                           |
|-------------------------------------------|----------------------------------|
| `a === b` (deep)                          | `Equal.equals(a, b)`             |
| `JSON.stringify(a) === JSON.stringify(b)` | `Equal.equals(a, b)`             |
| `[1,2,3] === [1,2,3]`                     | `Equal.equals([1,2,3], [1,2,3])` |

### 10. Predicate Combinators

| Imperative               | Effect                   |
|--------------------------|--------------------------|
| `pred1(x) && pred2(x)`   | `P.and(pred1, pred2)(x)` |
| `pred1(x) \|\| pred2(x)` | `P.or(pred1, pred2)(x)`  |
| `!pred(x)`               | `P.not(pred)(x)`         |
| `preds.every(p => p(x))` | `P.every(preds)(x)`      |
| `preds.some(p => p(x))`  | `P.some(preds)(x)`       |

### 11. Boolean Operations (effect/Boolean)

| Imperative     | Effect                                                    |
|----------------|-----------------------------------------------------------|
| `a && b`       | `Bool.and(a, b)`                                          |
| `a \|\| b`     | `Bool.or(a, b)`                                           |
| `!a`           | `Bool.not(a)`                                             |
| `cond ? x : y` | `Bool.match(cond, { onTrue: () => x, onFalse: () => y })` |

### 12. Switch/If-Else → Match (effect/Match)

```typescript
// FORBIDDEN: switch statements
switch (response._tag) {
  case "success": return response.data
  case "error": return response.error
  default: return "Unknown"
}

// REQUIRED: Match.exhaustive
Match.value(response).pipe(
  Match.tag("success", (r) => r.data),
  Match.tag("error", (r) => r.error),
  Match.exhaustive
)

// FORBIDDEN: if-else chains
if (typeof x === "string") { ... }
else if (typeof x === "number") { ... }
else { ... }

// REQUIRED: Match with predicates
Match.value(x).pipe(
  Match.when(P.isString, (s) => ...),
  Match.when(P.isNumber, (n) => ...),
  Match.orElse(() => ...)
)
```

### 13. Option Patterns (effect/Option)

| Imperative                             | Effect                                                   |
|----------------------------------------|----------------------------------------------------------|
| `x != null ? x : fallback`             | `F.pipe(x, O.fromNullable, O.getOrElse(() => fallback))` |
| `if (x != null) use(x)`                | `F.pipe(x, O.fromNullable, O.map(use))`                  |
| `try { JSON.parse(s) } catch { null }` | `O.liftThrowable(JSON.parse)(s)`                         |

### 14. Array Filtering (effect/Array)

| Imperative                             | Effect                             |
|----------------------------------------|------------------------------------|
| `items.filter(pred)`                   | `F.pipe(items, A.filter(pred))`    |
| `items.find(pred)`                     | `F.pipe(items, A.findFirst(pred))` |
| `items.every(pred)`                    | `F.pipe(items, A.every(pred))`     |
| `items.some(pred)`                     | `F.pipe(items, A.some(pred))`      |
| `items.filter(isA); items.filter(isB)` | `F.pipe(items, A.partition(isA))`  |

### 15. Schema Validation (effect/Schema)

```typescript
// FORBIDDEN: manual type checking
if (typeof val === "object" && val !== null && typeof val.id === "number") { ... }

// REQUIRED: Schema.is
const UserSchema = S.Struct({ id: S.Number, name: S.String })
const isUser = S.is(UserSchema)
if (isUser(val)) { /* val is { id: number; name: string } */ }
```

### 16. Equivalence (effect/Equivalence)

```typescript
// Custom equality for objects
const userEquiv = Equivalence.struct({
  id: Equivalence.number,
  name: Equivalence.string
})
userEquiv(user1, user2)

// Array equality
const arrayEquiv = Equivalence.array(Equivalence.number)
arrayEquiv([1, 2, 3], [1, 2, 3])
```

---

## Decision Tree for Choosing the Right Predicate

```
Is it a type check (typeof, instanceof)?
├── Yes → Use P.is* (P.isString, P.isNumber, P.isDate, etc.)
│
Is it a null/undefined check?
├── Yes → Use P.isNotNullable, P.isNull, P.isNotNull, etc.
│
Is it a property existence check?
├── Yes → Use P.hasProperty(obj, "key")
│
Is it a discriminated union tag check?
├── Yes → Use P.isTagged(obj, "Tag") or Match.tag("Tag", ...)
│
Is it a numeric comparison?
├── Yes → Use Num.lessThan, Num.between, etc.
│
Is it a bigint comparison?
├── Yes → Use BI.lessThan, BI.greaterThan, BI.sign
│
Is it a date/time comparison?
├── Yes → Use DateTime.lessThan, DateTime.isFuture, etc.
│
Is it a duration comparison?
├── Yes → Use Duration.lessThan, Duration.isZero, etc.
│
Is it deep equality?
├── Yes → Use Equal.equals(a, b)
│
Is it custom equality logic?
├── Yes → Use Equivalence.struct, Equivalence.array, etc.
│
Is it a switch statement on _tag?
├── Yes → Use Match.value(x).pipe(Match.tag(...), Match.exhaustive)
│
Is it an if-else chain on types?
├── Yes → Use Match.value(x).pipe(Match.when(pred, ...), ...)
│
Is it combining multiple predicates?
├── Yes → Use P.and, P.or, P.not, P.every, P.some
│
Is it filtering arrays with type narrowing?
├── Yes → Use A.filter with a Refinement (P.isString, etc.)
│
Is it validating external data?
├── Yes → Use S.is(schema) or S.validate(schema)
```

---

## Common Anti-patterns to Detect and Fix

### 1. Bare typeof Checks

```typescript
// ANTI-PATTERN
if (typeof x === "string") { ... }

// FIX
if (P.isString(x)) { ... }
```

### 2. instanceof Checks

```typescript
// ANTI-PATTERN
if (x instanceof Date) { ... }

// FIX
if (P.isDate(x)) { ... }
```

### 3. Manual Null Checks

```typescript
// ANTI-PATTERN
if (x !== null && x !== undefined) { ... }

// FIX
if (P.isNotNullable(x)) { ... }
```

### 4. Property in Checks

```typescript
// ANTI-PATTERN
if ("name" in obj) { ... }

// FIX
if (P.hasProperty(obj, "name")) { ... }
```

### 5. Manual Tag Checks

```typescript
// ANTI-PATTERN
if (response._tag === "success") { ... }

// FIX
if (P.isTagged(response, "success")) { ... }
// OR use Match for exhaustive handling
```

### 6. Switch Statements

```typescript
// ANTI-PATTERN
switch (value._tag) {
  case "A": return handleA(value)
  case "B": return handleB(value)
  default: throw new Error("Unknown tag")
}

// FIX
Match.value(value).pipe(
  Match.tag("A", handleA),
  Match.tag("B", handleB),
  Match.exhaustive
)
```

### 7. Long If-Else Chains

```typescript
// ANTI-PATTERN
if (P.isString(x)) { ... }
else if (P.isNumber(x)) { ... }
else if (P.isBoolean(x)) { ... }
else { ... }

// FIX
Match.value(x).pipe(
  Match.when(P.isString, ...),
  Match.when(P.isNumber, ...),
  Match.when(P.isBoolean, ...),
  Match.orElse(...)
)
```

### 8. Manual Numeric Comparisons

```typescript
// ANTI-PATTERN
if (x >= 0 && x <= 100) { ... }

// FIX
if (Num.between({ minimum: 0, maximum: 100 })(x)) { ... }
```

### 9. Native Array Methods

```typescript
// ANTI-PATTERN
items.filter(x => x !== null)

// FIX
F.pipe(items, A.filter(P.isNotNull))
```

### 10. Manual Deep Equality

```typescript
// ANTI-PATTERN
JSON.stringify(a) === JSON.stringify(b)

// FIX
Equal.equals(a, b)
```

### 11. Boolean Ternaries with Side Effects

```typescript
// ANTI-PATTERN
const result = condition ? doA() : doB()

// FIX
const result = Bool.match(condition, {
  onTrue: () => doA(),
  onFalse: () => doB()
})
```

### 12. Try-Catch for Optional Results

```typescript
// ANTI-PATTERN
let result: T | null
try {
  result = riskyOperation()
} catch {
  result = null
}

// FIX
const result = O.liftThrowable(riskyOperation)()
```

---

## Type Narrowing Reference

### Refinements That Narrow Types

| Function                          | Input       | Narrows To                 |
|-----------------------------------|-------------|----------------------------|
| `P.isString`                      | `unknown`   | `string`                   |
| `P.isNumber`                      | `unknown`   | `number`                   |
| `P.isNotNullable`                 | `A`         | `NonNullable<A>`           |
| `P.hasProperty(x, "k")`           | `unknown`   | `{ k: unknown }`           |
| `P.isTagged(x, "T")`              | `unknown`   | `{ _tag: "T" }`            |
| `P.struct({ a: P.isString })`     | `unknown`   | `{ a: string }`            |
| `P.tuple(P.isString, P.isNumber)` | `unknown`   | `[string, number]`         |
| `A.filter(P.isString)`            | `Array<A>`  | `Array<string>`            |
| `A.every(P.isNumber)`             | `Array<A>`  | `self is Array<number>`    |
| `A.some(pred)`                    | `Array<A>`  | `self is NonEmptyArray<A>` |
| `O.filter(P.isString)`            | `Option<A>` | `Option<string>`           |
| `List.filter(P.isNumber)`         | `List<A>`   | `List<number>`             |
| `S.is(schema)`                    | `unknown`   | Schema's `Type`            |

### Important: P.not() Does NOT Narrow

```typescript
// P.not returns Predicate, not Refinement
const isNotString = P.not(P.isString)
if (isNotString(x)) {
  // x is still 'unknown', NOT 'Exclude<unknown, string>'
}
```

---

## Match Completion Strategies

| Function             | Returns        | When to Use                    |
|----------------------|----------------|--------------------------------|
| `Match.exhaustive`   | `A`            | Compile error if cases missing |
| `Match.orElse(fn)`   | `A \| B`       | Fallback for remaining cases   |
| `Match.orElseAbsurd` | `A`            | Runtime throw if unmatched     |
| `Match.option`       | `Option<A>`    | When match might not succeed   |
| `Match.either`       | `Either<A, R>` | Success or remaining unmatched |

---

## Complete Predicate Function Inventory

### effect/Predicate

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `P.isString` | node_modules/effect/dist/dts/Predicate.d.ts:439-457 | A refinement that checks if a value is a `string`. | `P.isString("hello") // true` |
| `P.isNumber` | node_modules/effect/dist/dts/Predicate.d.ts:458-477 | A refinement that checks if a value is a `number`. | `P.isNumber(123) // true` |
| `P.isBoolean` | node_modules/effect/dist/dts/Predicate.d.ts:478-496 | A refinement that checks if a value is a `boolean`. | `P.isBoolean(true) // true` |
| `P.isBigInt` | node_modules/effect/dist/dts/Predicate.d.ts:497-514 | A refinement that checks if a value is a `bigint`. | `P.isBigInt(1n) // true` |
| `P.isSymbol` | node_modules/effect/dist/dts/Predicate.d.ts:515-531 | A refinement that checks if a value is a `symbol`. | `P.isSymbol(Symbol.for("a")) // true` |
| `P.isFunction` | node_modules/effect/dist/dts/Predicate.d.ts:532-549 | A refinement that checks if a value is a `Function`. | `P.isFunction(() => {}) // true` |
| `P.isObject` | node_modules/effect/dist/dts/Predicate.d.ts:656-677 | A refinement that checks if a value is an `object` (includes arrays and functions). | `P.isObject({}) // true` |
| `P.isRecord` | node_modules/effect/dist/dts/Predicate.d.ts:964-988 | A refinement that checks if a value is a plain object (excludes arrays and functions). | `P.isRecord({ a: 1 }) // true` |
| `P.isSet` | node_modules/effect/dist/dts/Predicate.d.ts:402-420 | A refinement that checks if a value is a `Set`. | `P.isSet(new Set([1, 2])) // true` |
| `P.isMap` | node_modules/effect/dist/dts/Predicate.d.ts:421-438 | A refinement that checks if a value is a `Map`. | `P.isMap(new Map()) // true` |
| `P.isDate` | node_modules/effect/dist/dts/Predicate.d.ts:925-942 | A refinement that checks if a value is a `Date` object. | `P.isDate(new Date()) // true` |
| `P.isError` | node_modules/effect/dist/dts/Predicate.d.ts:888-906 | A refinement that checks if a value is an instance of `Error`. | `P.isError(new Error("boom")) // true` |
| `P.isRegExp` | node_modules/effect/dist/dts/Predicate.d.ts:1054-1071 | A refinement that checks if a value is a `RegExp`. | `P.isRegExp(/a/) // true` |
| `P.isUint8Array` | node_modules/effect/dist/dts/Predicate.d.ts:907-924 | A refinement that checks if a value is a `Uint8Array`. | `P.isUint8Array(new Uint8Array()) // true` |
| `P.isIterable` | node_modules/effect/dist/dts/Predicate.d.ts:943-963 | A refinement that checks if a value is an `Iterable`. | `P.isIterable([]) // true` |
| `P.isPromise` | node_modules/effect/dist/dts/Predicate.d.ts:1013-1033 | A refinement that checks if a value is a `Promise` (duck-typing for `.then` and `.catch`). | `P.isPromise(Promise.resolve(1)) // true` |
| `P.isNull` | node_modules/effect/dist/dts/Predicate.d.ts:586-603 | A refinement that checks if a value is `null`. | `P.isNull(null) // true` |
| `P.isNotNull` | node_modules/effect/dist/dts/Predicate.d.ts:604-621 | A refinement that checks if a value is not `null`. | `P.isNotNull("value") // true` |
| `P.isUndefined` | node_modules/effect/dist/dts/Predicate.d.ts:550-567 | A refinement that checks if a value is `undefined`. | `P.isUndefined(undefined) // true` |
| `P.isNotUndefined` | node_modules/effect/dist/dts/Predicate.d.ts:568-585 | A refinement that checks if a value is not `undefined`. | `P.isNotUndefined("value") // true` |
| `P.isNullable` | node_modules/effect/dist/dts/Predicate.d.ts:847-866 | A refinement that checks if a value is either `null` or `undefined`. | `P.isNullable(null) // true` |
| `P.isNotNullable` | node_modules/effect/dist/dts/Predicate.d.ts:867-887 | A refinement that checks if a value is neither `null` nor `undefined`. | `P.isNotNullable("hello") // true` |
| `P.hasProperty` | node_modules/effect/dist/dts/Predicate.d.ts:678-751 | A refinement that checks if an object has a specific property key. | `P.hasProperty({ a: 1 }, "a") // true` |
| `P.isTagged` | node_modules/effect/dist/dts/Predicate.d.ts:752-846 | A refinement that checks if an object has a `_tag` property matching the given tag. | `P.isTagged("circle")({ _tag: "circle" }) // true` |
| `P.isTupleOf` | node_modules/effect/dist/dts/Predicate.d.ts:218-296 | A refinement that checks if an array is a tuple with exactly `N` elements. | `P.isTupleOf([1, 2, 3], 3) // true` |
| `P.isTupleOfAtLeast` | node_modules/effect/dist/dts/Predicate.d.ts:297-378 | A refinement that checks if an array is a tuple with at least `N` elements. | `P.isTupleOfAtLeast([1, 2, 3, 4], 3) // true` |
| `P.and` | node_modules/effect/dist/dts/Predicate.d.ts:1586-1761 | Combines two predicates with logical "AND", returns `true` only if both predicates return `true`. | `P.and(P.isString, (s) => s.length > 0)("hi") // true` |
| `P.or` | node_modules/effect/dist/dts/Predicate.d.ts:1425-1585 | Combines two predicates with logical "OR", returns `true` if at least one predicate returns `true`. | `P.or(P.isString, P.isNumber)("hello") // true` |
| `P.not` | node_modules/effect/dist/dts/Predicate.d.ts:1403-1424 | Returns a new predicate that is the logical negation of the given predicate. | `P.not(P.isString)(123) // true` |
| `P.xor` | node_modules/effect/dist/dts/Predicate.d.ts:1762-1834 | Combines two predicates with logical "XOR", returns `true` if exactly one predicate returns `true`. | `P.xor((n) => n > 0, (n) => n % 2 === 0)(3) // true` |
| `P.eqv` | node_modules/effect/dist/dts/Predicate.d.ts:1835-1907 | Combines two predicates with logical equivalence, returns `true` if both return the same value. | `P.eqv((n) => n > 0, (n) => n % 2 === 0)(4) // true` |
| `P.nand` | node_modules/effect/dist/dts/Predicate.d.ts:2117-2144 | Combines two predicates with logical "NAND", returns `true` if at least one returns `false`. | `P.nand((n) => n > 0, (n) => n > 10)(5) // true` |
| `P.nor` | node_modules/effect/dist/dts/Predicate.d.ts:2089-2116 | Combines two predicates with logical "NOR", returns `true` only if both return `false`. | `P.nor((n) => n < 0, (n) => n > 10)(5) // true` |
| `P.implies` | node_modules/effect/dist/dts/Predicate.d.ts:1908-2088 | Creates a logical "if-then" predicate, fails only when antecedent is `true` and consequent is `false`. | `P.implies((n) => n > 10, (n) => n > 5)(15) // true` |
| `P.every` | node_modules/effect/dist/dts/Predicate.d.ts:2145-2170 | Returns a predicate that returns `true` if all predicates in the collection return `true`. | `P.every([(n) => n > 0, (n) => n % 2 === 0])(4) // true` |
| `P.some` | node_modules/effect/dist/dts/Predicate.d.ts:2171-2196 | Returns a predicate that returns `true` if at least one predicate in the collection returns `true`. | `P.some([(n) => n < 0, (n) => n % 2 !== 0])(3) // true` |
| `P.tuple` | node_modules/effect/dist/dts/Predicate.d.ts:1247-1327 | Combines an array of predicates into a single predicate that tests an array of values. | `P.tuple(P.isString, P.isNumber)(["hello", 123]) // true` |
| `P.struct` | node_modules/effect/dist/dts/Predicate.d.ts:1328-1402 | Combines a record of predicates into a single predicate that tests a record of values. | `P.struct({ name: P.isString })({ name: "Alice" }) // true` |
| `P.compose` | node_modules/effect/dist/dts/Predicate.d.ts:1072-1227 | Composes a refinement with another refinement or predicate for chained checks. | `P.compose(P.isString, (s) => s.length > 0)("hi") // true` |
| `P.mapInput` | node_modules/effect/dist/dts/Predicate.d.ts:136-217 | Transforms a predicate by applying a function to the input before testing. | `P.mapInput((n) => n > 0, (s: string) => s.length)("hi") // true` |

### effect/Number

| Name | Path | Description | Basic Usage |
|------|------|-------------|-------------|
| `Num.isNumber` | node_modules/effect/dist/dts/Number.d.ts:101-154 | Type guard that tests if a value is a JavaScript number. | `Num.isNumber(2) // true` |
| `Num.lessThan` | node_modules/effect/dist/dts/Number.d.ts:704-761 | Returns true if first argument is less than second, otherwise false. | `Num.lessThan(2, 3) // true` |
| `Num.lessThanOrEqualTo` | node_modules/effect/dist/dts/Number.d.ts:762-819 | Returns true if number is less than or equal to provided one. | `Num.lessThanOrEqualTo(3, 3) // true` |
| `Num.greaterThan` | node_modules/effect/dist/dts/Number.d.ts:820-877 | Returns true if first argument is greater than second, otherwise false. | `Num.greaterThan(4, 3) // true` |
| `Num.greaterThanOrEqualTo` | node_modules/effect/dist/dts/Number.d.ts:878-935 | Returns true if number is greater than or equal to provided one. | `Num.greaterThanOrEqualTo(3, 3) // true` |
| `Num.between` | node_modules/effect/dist/dts/Number.d.ts:936-1002 | Checks if a number is between minimum and maximum value (inclusive). | `Num.between({ minimum: 0, maximum: 5 })(3) // true` |

### effect/BigInt

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `BI.isBigInt` | node_modules/effect/dist/dts/BigInt.d.ts:15-30 | Tests if a value is a `bigint` type guard. | `BI.isBigInt(1n) // true` |
| `BI.lessThan` | node_modules/effect/dist/dts/BigInt.d.ts:337-388 | Returns `true` if the first argument is less than the second. | `BI.lessThan(2n, 3n) // true` |
| `BI.lessThanOrEqualTo` | node_modules/effect/dist/dts/BigInt.d.ts:389-440 | Checks if a given `bigint` is less than or equal to another. | `BI.lessThanOrEqualTo(3n, 3n) // true` |
| `BI.greaterThan` | node_modules/effect/dist/dts/BigInt.d.ts:441-492 | Returns `true` if the first argument is greater than the second. | `BI.greaterThan(4n, 3n) // true` |
| `BI.greaterThanOrEqualTo` | node_modules/effect/dist/dts/BigInt.d.ts:493-544 | Checks if a given `bigint` is greater than or equal to another. | `BI.greaterThanOrEqualTo(3n, 3n) // true` |
| `BI.between` | node_modules/effect/dist/dts/BigInt.d.ts:545-608 | Checks if a `bigint` is between minimum and maximum values (inclusive). | `BI.between({ minimum: 0n, maximum: 5n })(3n) // true` |
| `BI.sign` | node_modules/effect/dist/dts/BigInt.d.ts:768-784 | Determines the sign of a given `bigint` returning -1, 0, or 1. | `BI.sign(-5n) // -1` |

### effect/BigDecimal

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `BigDecimal.isBigDecimal` | node_modules/effect/dist/dts/BigDecimal.d.ts:46-51 | Checks if a given value is a `BigDecimal`. | `BigDecimal.isBigDecimal(value)` |
| `BigDecimal.lessThan` | node_modules/effect/dist/dts/BigDecimal.d.ts:382-432 | Returns `true` if the first argument is less than the second. | `BigDecimal.lessThan(a, b)` |
| `BigDecimal.lessThanOrEqualTo` | node_modules/effect/dist/dts/BigDecimal.d.ts:433-484 | Checks if a given `BigDecimal` is less than or equal to another. | `BigDecimal.lessThanOrEqualTo(a, b)` |
| `BigDecimal.greaterThan` | node_modules/effect/dist/dts/BigDecimal.d.ts:485-536 | Returns `true` if the first argument is greater than the second. | `BigDecimal.greaterThan(a, b)` |
| `BigDecimal.greaterThanOrEqualTo` | node_modules/effect/dist/dts/BigDecimal.d.ts:537-588 | Checks if a given `BigDecimal` is greater than or equal to another. | `BigDecimal.greaterThanOrEqualTo(a, b)` |
| `BigDecimal.between` | node_modules/effect/dist/dts/BigDecimal.d.ts:589-661 | Checks if a `BigDecimal` is between a minimum and maximum (inclusive). | `BigDecimal.between(n, { minimum, maximum })` |
| `BigDecimal.equals` | node_modules/effect/dist/dts/BigDecimal.d.ts:1011-1031 | Checks if two `BigDecimal`s are equal. | `BigDecimal.equals(a, b)` |
| `BigDecimal.isInteger` | node_modules/effect/dist/dts/BigDecimal.d.ts:1182-1197 | Checks if a given `BigDecimal` is an integer. | `BigDecimal.isInteger(n)` |
| `BigDecimal.isZero` | node_modules/effect/dist/dts/BigDecimal.d.ts:1198-1213 | Checks if a given `BigDecimal` is `0`. | `BigDecimal.isZero(n)` |
| `BigDecimal.isNegative` | node_modules/effect/dist/dts/BigDecimal.d.ts:1214-1230 | Checks if a given `BigDecimal` is negative. | `BigDecimal.isNegative(n)` |
| `BigDecimal.isPositive` | node_modules/effect/dist/dts/BigDecimal.d.ts:1231-1247 | Checks if a given `BigDecimal` is positive. | `BigDecimal.isPositive(n)` |

### effect/DateTime

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `DateTime.isDateTime` | node_modules/effect/dist/dts/DateTime.d.ts:227 | Type guard to check if unknown value is a DateTime | `DateTime.isDateTime(value)` |
| `DateTime.isUtc` | node_modules/effect/dist/dts/DateTime.d.ts:247 | Type guard to check if DateTime is a Utc instance | `DateTime.isUtc(dateTime)` |
| `DateTime.isZoned` | node_modules/effect/dist/dts/DateTime.d.ts:252 | Type guard to check if DateTime is a Zoned instance | `DateTime.isZoned(dateTime)` |
| `DateTime.isTimeZone` | node_modules/effect/dist/dts/DateTime.d.ts:232 | Type guard to check if unknown value is a TimeZone | `DateTime.isTimeZone(value)` |
| `DateTime.isTimeZoneOffset` | node_modules/effect/dist/dts/DateTime.d.ts:237 | Type guard to check if unknown value is a TimeZone.Offset | `DateTime.isTimeZoneOffset(value)` |
| `DateTime.isTimeZoneNamed` | node_modules/effect/dist/dts/DateTime.d.ts:242 | Type guard to check if unknown value is a TimeZone.Named | `DateTime.isTimeZoneNamed(value)` |
| `DateTime.greaterThan` | node_modules/effect/dist/dts/DateTime.d.ts:1027-1038 | Check if first DateTime is strictly after the second DateTime | `DateTime.greaterThan(dt1, dt2)` |
| `DateTime.greaterThanOrEqualTo` | node_modules/effect/dist/dts/DateTime.d.ts:1043-1054 | Check if first DateTime is after or equal to second DateTime | `DateTime.greaterThanOrEqualTo(dt1, dt2)` |
| `DateTime.lessThan` | node_modules/effect/dist/dts/DateTime.d.ts:1059-1070 | Check if first DateTime is strictly before the second DateTime | `DateTime.lessThan(dt1, dt2)` |
| `DateTime.lessThanOrEqualTo` | node_modules/effect/dist/dts/DateTime.d.ts:1075-1086 | Check if first DateTime is before or equal to second DateTime | `DateTime.lessThanOrEqualTo(dt1, dt2)` |
| `DateTime.between` | node_modules/effect/dist/dts/DateTime.d.ts:1091-1108 | Check if DateTime falls between minimum and maximum bounds inclusive | `DateTime.between(dt, { minimum: min, maximum: max })` |
| `DateTime.isFuture` | node_modules/effect/dist/dts/DateTime.d.ts:1113 | Effectfully check if DateTime is in the future using Clock service | `yield* DateTime.isFuture(dt)` |
| `DateTime.unsafeIsFuture` | node_modules/effect/dist/dts/DateTime.d.ts:1118 | Synchronously check if DateTime is in the future using Date.now | `DateTime.unsafeIsFuture(dt)` |
| `DateTime.isPast` | node_modules/effect/dist/dts/DateTime.d.ts:1123 | Effectfully check if DateTime is in the past using Clock service | `yield* DateTime.isPast(dt)` |
| `DateTime.unsafeIsPast` | node_modules/effect/dist/dts/DateTime.d.ts:1128 | Synchronously check if DateTime is in the past using Date.now | `DateTime.unsafeIsPast(dt)` |

### effect/Duration

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `Duration.isDuration` | node_modules/effect/dist/dts/Duration.d.ts:59 | Type guard that checks if unknown value is a Duration | `Duration.isDuration(value)` |
| `Duration.isFinite` | node_modules/effect/dist/dts/Duration.d.ts:64 | Returns true if the Duration is not infinite | `Duration.isFinite(Duration.seconds(5))` |
| `Duration.isZero` | node_modules/effect/dist/dts/Duration.d.ts:69 | Returns true if the Duration equals zero | `Duration.isZero(Duration.zero)` |
| `Duration.lessThan` | node_modules/effect/dist/dts/Duration.d.ts:390-401 | Returns true if self is strictly less than that Duration | `Duration.lessThan(Duration.seconds(5), Duration.seconds(10))` |
| `Duration.lessThanOrEqualTo` | node_modules/effect/dist/dts/Duration.d.ts:406-417 | Returns true if self is less than or equal to that Duration | `Duration.lessThanOrEqualTo(Duration.seconds(5), Duration.seconds(5))` |
| `Duration.greaterThan` | node_modules/effect/dist/dts/Duration.d.ts:422-433 | Returns true if self is strictly greater than that Duration | `Duration.greaterThan(Duration.seconds(10), Duration.seconds(5))` |
| `Duration.greaterThanOrEqualTo` | node_modules/effect/dist/dts/Duration.d.ts:438-449 | Returns true if self is greater than or equal to that Duration | `Duration.greaterThanOrEqualTo(Duration.seconds(5), Duration.seconds(5))` |
| `Duration.equals` | node_modules/effect/dist/dts/Duration.d.ts:454-465 | Returns true if two Durations are equal | `Duration.equals(Duration.seconds(1), Duration.millis(1000))` |
| `Duration.between` | node_modules/effect/dist/dts/Duration.d.ts:228-249 | Checks if a Duration is between a minimum and maximum value | `Duration.between(Duration.seconds(5), { minimum: Duration.seconds(1), maximum: Duration.seconds(10) })` |

### effect/Equal

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `Equal.equals` | node_modules/effect/dist/dts/Equal.d.ts:22-23 | Checks equality between two values using structural comparison | `Equal.equals(a, b)` |
| `Equal.isEqual` | node_modules/effect/dist/dts/Equal.d.ts:28 | Type guard checking if value implements Equal interface | `Equal.isEqual(value)` |
| `Equal.equivalence` | node_modules/effect/dist/dts/Equal.d.ts:33 | Creates an Equivalence instance for comparing values of type A | `Equal.equivalence<User>()` |

### effect/Boolean

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `Bool.isBoolean` | node_modules/effect/dist/dts/Boolean.d.ts:11-26 | Tests if a value is a boolean type guard | `Bool.isBoolean(true) // true` |
| `Bool.match` | node_modules/effect/dist/dts/Boolean.d.ts:27-81 | Returns result of onFalse or onTrue function based on boolean value | `Bool.match(true, { onFalse: () => "no", onTrue: () => "yes" })` |
| `Bool.not` | node_modules/effect/dist/dts/Boolean.d.ts:92-107 | Negates the given boolean: `!self` | `Bool.not(true) // false` |
| `Bool.and` | node_modules/effect/dist/dts/Boolean.d.ts:108-162 | Combines two booleans using AND: `self && that` | `Bool.and(true, false) // false` |
| `Bool.or` | node_modules/effect/dist/dts/Boolean.d.ts:218-272 | Combines two booleans using OR: `self \|\| that` | `Bool.or(true, false) // true` |
| `Bool.nand` | node_modules/effect/dist/dts/Boolean.d.ts:163-217 | Combines two booleans using NAND: `!(self && that)` | `Bool.nand(true, true) // false` |
| `Bool.nor` | node_modules/effect/dist/dts/Boolean.d.ts:273-327 | Combines two booleans using NOR: `!(self \|\| that)` | `Bool.nor(false, false) // true` |
| `Bool.xor` | node_modules/effect/dist/dts/Boolean.d.ts:328-382 | Combines two booleans using XOR: exclusive or operation | `Bool.xor(true, false) // true` |
| `Bool.eqv` | node_modules/effect/dist/dts/Boolean.d.ts:383-437 | Combines two booleans using EQV (XNOR): `!xor(self, that)` | `Bool.eqv(true, true) // true` |
| `Bool.implies` | node_modules/effect/dist/dts/Boolean.d.ts:438-492 | Combines two booleans using implication: `(!self \|\| that)` | `Bool.implies(true, false) // false` |
| `Bool.every` | node_modules/effect/dist/dts/Boolean.d.ts:493-507 | Checks if all elements in a boolean collection are true | `Bool.every([true, true, true]) // true` |
| `Bool.some` | node_modules/effect/dist/dts/Boolean.d.ts:508-522 | Checks if at least one element in a boolean collection is true | `Bool.some([false, true, false]) // true` |

### effect/Array

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `A.isEmptyArray` | node_modules/effect/dist/dts/Array.d.ts:875 | Determine if an Array is empty, narrowing type to `[]` | `A.isEmptyArray([]) // true` |
| `A.isEmptyReadonlyArray` | node_modules/effect/dist/dts/Array.d.ts:891 | Determine if a ReadonlyArray is empty, narrowing type to `readonly []` | `A.isEmptyReadonlyArray([]) // true` |
| `A.isNonEmptyArray` | node_modules/effect/dist/dts/Array.d.ts:909 | Determine if an Array contains at least one element (NonEmptyArray) | `A.isNonEmptyArray([1, 2]) // true` |
| `A.isNonEmptyReadonlyArray` | node_modules/effect/dist/dts/Array.d.ts:927 | Determine if a ReadonlyArray contains at least one element | `A.isNonEmptyReadonlyArray([1]) // true` |
| `A.findFirst` | node_modules/effect/dist/dts/Array.d.ts:1648-1751 | Returns first element satisfying predicate, or None if not found | `A.findFirst([1, 2, 3], (x) => x > 2) // Option.some(3)` |
| `A.findLast` | node_modules/effect/dist/dts/Array.d.ts:1768-1887 | Finds last element satisfying predicate, returns Option with found element | `A.findLast([1, 2, 3], (n) => n % 2 === 0) // Option.some(2)` |
| `A.findFirstIndex` | node_modules/effect/dist/dts/Array.d.ts:1549-1582 | Return the first index for which a predicate holds | `A.findFirstIndex([5, 3, 8], (x) => x > 5) // Option.some(2)` |
| `A.findLastIndex` | node_modules/effect/dist/dts/Array.d.ts:1598-1631 | Return the last index for which a predicate holds | `A.findLastIndex([1, 3, 8], (x) => x < 5) // Option.some(1)` |
| `A.filter` | node_modules/effect/dist/dts/Array.d.ts:4542-4563 | Filter elements by predicate or refinement, keeping matching elements | `F.pipe([1, 2, 3], A.filter((x) => x > 1)) // [2, 3]` |
| `A.filterMap` | node_modules/effect/dist/dts/Array.d.ts:4307-4346 | Applies function and filters, keeping transformed values where function returns Some | `A.filterMap([1, 2], (x) => x % 2 === 0 ? O.some(x * x) : O.none())` |
| `A.partition` | node_modules/effect/dist/dts/Array.d.ts:4579-4644 | Separate elements into two arrays based on predicate | `A.partition([1, 2, 3, 4], (n) => n % 2 === 0) // [[1, 3], [2, 4]]` |
| `A.every` | node_modules/effect/dist/dts/Array.d.ts:4904-4933 | Check if a predicate holds true for every ReadonlyArray element | `A.every([2, 4, 6], (x) => x % 2 === 0) // true` |
| `A.some` | node_modules/effect/dist/dts/Array.d.ts:4940-4955 | Check if a predicate holds true for some ReadonlyArray element | `A.some([1, 2, 3], (x) => x > 2) // true` |
| `A.takeWhile` | node_modules/effect/dist/dts/Array.d.ts:1234-1323 | Calculate longest initial subarray where all elements satisfy predicate | `A.takeWhile([1, 3, 2, 4], (x) => x < 4) // [1, 3, 2]` |
| `A.dropWhile` | node_modules/effect/dist/dts/Array.d.ts:1500-1533 | Remove longest initial subarray where all elements satisfy predicate | `A.dropWhile([1, 2, 3, 4, 5], (x) => x < 4) // [4, 5]` |
| `A.span` | node_modules/effect/dist/dts/Array.d.ts:1333-1391 | Split into longest initial subarray satisfying predicate and remaining elements | `A.span([1, 2, 5, 3], (x) => x < 4) // [[1, 2], [5, 3]]` |
| `A.contains` | node_modules/effect/dist/dts/Array.d.ts:3141-3174 | Check if ReadonlyArray contains a value using default Equivalence | `F.pipe(["a", "b", "c"], A.contains("c")) // true` |
| `A.containsWith` | node_modules/effect/dist/dts/Array.d.ts:3122-3125 | Check if ReadonlyArray contains a value using provided isEquivalent function | `F.pipe([1, 2, 3], A.containsWith((a, b) => a === b)(2)) // true` |
| `A.dedupeWith` | node_modules/effect/dist/dts/Array.d.ts:5201-5250 | Remove duplicates using provided isEquivalent function, preserving first occurrence | `A.dedupeWith([1, 2, 2, 3], (a, b) => a === b) // [1, 2, 3]` |

### effect/Option

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `O.isOption` | node_modules/effect/dist/dts/Option.d.ts:174-201 | Determines whether a given value is an `Option` (Some or None). | `O.isOption(O.some(1)) // true` |
| `O.isSome` | node_modules/effect/dist/dts/Option.d.ts:222-241 | Checks whether an `Option` contains a value (`Some`). | `O.isSome(O.some(1)) // true` |
| `O.isNone` | node_modules/effect/dist/dts/Option.d.ts:202-221 | Checks whether an `Option` represents the absence of a value (`None`). | `O.isNone(O.none()) // true` |
| `O.liftPredicate` | node_modules/effect/dist/dts/Option.d.ts:3003-3136 | Lifts a predicate into Option context, returning Some if satisfied, None otherwise. | `O.liftPredicate((n: number) => n > 0)(1) // Some(1)` |
| `O.toRefinement` | node_modules/effect/dist/dts/Option.d.ts:370-409 | Converts an Option-returning function into a type guard (refinement). | `O.toRefinement((x: unknown) => typeof x === "string" ? O.some(x) : O.none())` |
| `O.filter` | node_modules/effect/dist/dts/Option.d.ts:2753-2883 | Filters an Option using a predicate; returns None if unsatisfied or None. | `O.filter(O.some("a"), (v) => v !== "") // Some("a")` |
| `O.exists` | node_modules/effect/dist/dts/Option.d.ts:3271-3436 | Checks if a value in an Option satisfies a given predicate. | `O.some(2).pipe(O.exists((n) => n % 2 === 0)) // true` |
| `O.contains` | node_modules/effect/dist/dts/Option.d.ts:3174-3270 | Checks if an Option contains a specified value using default Equivalence. | `O.some(2).pipe(O.contains(2)) // true` |
| `O.containsWith` | node_modules/effect/dist/dts/Option.d.ts:3137-3173 | Checks if an Option contains a value using a custom equivalence function. | `O.containsWith(Number.Equivalence)(2)(O.some(2)) // true` |

### effect/List

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `List.isList` | node_modules/effect/dist/dts/List.d.ts:80-95 | Returns true if the specified value is a List, false otherwise. | `List.isList(List.make(1, 2))` |
| `List.isNil` | node_modules/effect/dist/dts/List.d.ts:97-102 | Returns true if the specified value is a List.Nil, false otherwise. | `List.isNil(List.nil())` |
| `List.isCons` | node_modules/effect/dist/dts/List.d.ts:103-109 | Returns true if the specified value is a List.Cons, false otherwise. | `List.isCons(List.make(1))` |
| `List.every` | node_modules/effect/dist/dts/List.d.ts:444-479 | Check if a predicate holds true for every List element. | `pipe(list, List.every((x) => x > 0))` |
| `List.some` | node_modules/effect/dist/dts/List.d.ts:480-501 | Check if a predicate holds true for some List element. | `pipe(list, List.some((x) => x > 0))` |
| `List.filter` | node_modules/effect/dist/dts/List.d.ts:502-537 | Filters a list using the specified predicate. | `pipe(list, List.filter((x) => x > 0))` |
| `List.partition` | node_modules/effect/dist/dts/List.d.ts:724-769 | Partition a list into two lists based on predicate satisfaction. | `pipe(list, List.partition((x) => x > 0))` |
| `List.findFirst` | node_modules/effect/dist/dts/List.d.ts:574-613 | Returns the first element that satisfies the predicate, or None. | `pipe(list, List.findFirst((x) => x > 5))` |
| `List.filterMap` | node_modules/effect/dist/dts/List.d.ts:538-565 | Filters and maps a list using a partial function returning Option. | `pipe(list, List.filterMap((x) => x > 0 ? O.some(x) : O.none()))` |
| `List.compact` | node_modules/effect/dist/dts/List.d.ts:566-572 | Removes all None values from the specified list. | `List.compact(List.make(O.some(1), O.none()))` |
| `List.partitionMap` | node_modules/effect/dist/dts/List.d.ts:770-797 | Partition a list into two lists based on Either Left/Right results. | `pipe(list, List.partitionMap((x) => x > 0 ? Either.right(x) : Either.left(x)))` |

### effect/Match

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `Match.string` | node_modules/effect/dist/dts/Match.d.ts:774 | Matches values of type `string`. | `Match.when(Match.string, (s) => s)` |
| `Match.number` | node_modules/effect/dist/dts/Match.d.ts:781 | Matches values of type `number`. | `Match.when(Match.number, (n) => n)` |
| `Match.boolean` | node_modules/effect/dist/dts/Match.d.ts:802 | Matches values of type `boolean`. | `Match.when(Match.boolean, (b) => b)` |
| `Match.bigint` | node_modules/effect/dist/dts/Match.d.ts:827 | Matches values of type `bigint`. | `Match.when(Match.bigint, (n) => n)` |
| `Match.symbol` | node_modules/effect/dist/dts/Match.d.ts:834 | Matches values of type `symbol`. | `Match.when(Match.symbol, (s) => s)` |
| `Match.undefined` | node_modules/effect/dist/dts/Match.d.ts:803-811 | Matches the value `undefined`. | `Match.when(Match.undefined, () => "undef")` |
| `Match.null` | node_modules/effect/dist/dts/Match.d.ts:812-820 | Matches the value `null`. | `Match.when(Match.null, () => "null")` |
| `Match.any` | node_modules/effect/dist/dts/Match.d.ts:788 | Matches any value without restrictions. | `Match.when(Match.any, (x) => x)` |
| `Match.defined` | node_modules/effect/dist/dts/Match.d.ts:795 | Matches any defined (non-null, non-undefined) value. | `Match.when(Match.defined, (x) => x)` |
| `Match.nonEmptyString` | node_modules/effect/dist/dts/Match.d.ts:760 | Matches non-empty strings. | `Match.when(Match.nonEmptyString, (s) => s)` |
| `Match.date` | node_modules/effect/dist/dts/Match.d.ts:841 | Matches values that are instances of `Date`. | `Match.when(Match.date, (d) => d)` |
| `Match.record` | node_modules/effect/dist/dts/Match.d.ts:848-850 | Matches objects with string/symbol keys and unknown values. | `Match.when(Match.record, (r) => r)` |
| `Match.is` | node_modules/effect/dist/dts/Match.d.ts:767 | Matches a specific set of literal values. | `Match.when(Match.is("a", 42), (x) => x)` |
| `Match.instanceOf` | node_modules/effect/dist/dts/Match.d.ts:857 | Matches instances of a given class. | `Match.when(Match.instanceOf(Error), (e) => e)` |
| `Match.instanceOfUnsafe` | node_modules/effect/dist/dts/Match.d.ts:862 | Matches instances of a class (unsafe variant). | `Match.when(Match.instanceOfUnsafe(MyClass), (x) => x)` |
| `Match.value` | node_modules/effect/dist/dts/Match.d.ts:183-222 | Creates a matcher from a specific value. | `Match.value(input).pipe(Match.when(...))` |
| `Match.type` | node_modules/effect/dist/dts/Match.d.ts:141-181 | Creates a matcher for a specific type. | `Match.type<string \| number>().pipe(Match.when(...))` |
| `Match.tag` | node_modules/effect/dist/dts/Match.d.ts:577-620 | Matches based on `_tag` field in discriminated unions. | `Match.tag("Success", (s) => s.value)` |
| `Match.when` | node_modules/effect/dist/dts/Match.d.ts:311-358 | Defines a condition for matching values with patterns/predicates. | `Match.when({ age: 18 }, () => "adult")` |
| `Match.not` | node_modules/effect/dist/dts/Match.d.ts:719-753 | Excludes a specific value from matching while allowing all others. | `Match.not("hi", () => "ok")` |
| `Match.discriminator` | node_modules/effect/dist/dts/Match.d.ts:442-468 | Matches values based on a specified discriminant field. | `Match.discriminator("type")("A", (x) => x)` |
| `Match.exhaustive` | node_modules/effect/dist/dts/Match.d.ts:992-1017 | Finalizes matching ensuring all cases are handled (compile error if not). | `Match.type<A \| B>().pipe(..., Match.exhaustive)` |
| `Match.orElse` | node_modules/effect/dist/dts/Match.d.ts:864-896 | Provides a fallback value when no patterns match. | `Match.orElse(() => "fallback")` |
| `Match.orElseAbsurd` | node_modules/effect/dist/dts/Match.d.ts:897-913 | Throws an error if no pattern matches. | `Match.orElseAbsurd` |
| `Match.option` | node_modules/effect/dist/dts/Match.d.ts:955-991 | Wraps the match result in an `Option`. | `Match.option` |
| `Match.either` | node_modules/effect/dist/dts/Match.d.ts:915-953 | Wraps the match result in an `Either` (Right=matched, Left=unmatched). | `Match.either` |

### effect/Schema

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `S.is` | node_modules/effect/dist/dts/Schema.d.ts:291 | Returns a type guard checking if value matches schema (exact mode by default). | `S.is(S.String)("hello")` |
| `S.asserts` | node_modules/effect/dist/dts/ParseResult.d.ts:487 | Throws ParseError if value doesn't match schema (exact mode by default). | `S.asserts(S.String)(value)` |
| `S.isSchema` | node_modules/effect/dist/dts/Schema.d.ts:384 | Tests if a value is a Schema instance. | `S.isSchema(S.String)` |
| `S.isPropertySignature` | node_modules/effect/dist/dts/Schema.d.ts:947 | Tests if a value is a PropertySignature instance. | `S.isPropertySignature(prop)` |
| `S.validate` | node_modules/effect/dist/dts/Schema.d.ts:367 | Returns Effect that validates unknown value against schema, failing with ParseError. | `S.validate(S.String)(input)` |
| `S.validateEither` | node_modules/effect/dist/dts/Schema.d.ts:372 | Returns Either validating unknown value, Left on error, Right on success. | `S.validateEither(S.String)(input)` |
| `S.validateSync` | node_modules/effect/dist/dts/Schema.d.ts:302 | Synchronously validates unknown value, throws ParseError on failure. | `S.validateSync(S.String)(input)` |
| `S.validateOption` | node_modules/effect/dist/dts/Schema.d.ts:296 | Returns Option validating unknown value, None on error, Some on success. | `S.validateOption(S.String)(input)` |
| `S.validatePromise` | node_modules/effect/dist/dts/Schema.d.ts:377 | Returns Promise validating unknown value, rejects on failure. | `S.validatePromise(S.String)(input)` |
| `S.filter` | node_modules/effect/dist/dts/Schema.d.ts:1907-1909 | Creates refinement schema using predicate function with optional annotations. | `F.pipe(S.String, S.filter((s) => s.length > 0))` |
| `S.filterEffect` | node_modules/effect/dist/dts/Schema.d.ts:1920-1931 | Creates refinement schema using effectful predicate returning Effect of FilterReturnType. | `F.pipe(S.String, S.filterEffect((s) => Effect.succeed(true)))` |

### effect/Equivalence

| name | path | description | Basic usage |
|------|------|-------------|-------------|
| `Equivalence.make` | node_modules/effect/dist/dts/Equivalence.d.ts:17-20 | Creates an Equivalence from a custom comparison function. | `Equivalence.make<number>((a, b) => Math.abs(a) === Math.abs(b))` |
| `Equivalence.strict` | node_modules/effect/dist/dts/Equivalence.d.ts:21-27 | Returns an Equivalence that uses strict equality (===) to compare. | `Equivalence.strict<string>()` |
| `Equivalence.string` | node_modules/effect/dist/dts/Equivalence.d.ts:28-32 | Equivalence instance for string values using strict equality. | `Equivalence.string("hello", "hello")` |
| `Equivalence.number` | node_modules/effect/dist/dts/Equivalence.d.ts:33-37 | Equivalence instance for number values using strict equality. | `Equivalence.number(42, 42)` |
| `Equivalence.boolean` | node_modules/effect/dist/dts/Equivalence.d.ts:38-42 | Equivalence instance for boolean values using strict equality. | `Equivalence.boolean(true, true)` |
| `Equivalence.bigint` | node_modules/effect/dist/dts/Equivalence.d.ts:43-47 | Equivalence instance for bigint values using strict equality. | `Equivalence.bigint(1n, 1n)` |
| `Equivalence.symbol` | node_modules/effect/dist/dts/Equivalence.d.ts:48-52 | Equivalence instance for symbol values using strict equality. | `Equivalence.symbol(Symbol.for("a"), Symbol.for("a"))` |
| `Equivalence.Date` | node_modules/effect/dist/dts/Equivalence.d.ts:106-110 | Equivalence instance for Date values comparing by timestamp. | `Equivalence.Date(new Date("2024-01-01"), new Date("2024-01-01"))` |
| `Equivalence.combine` | node_modules/effect/dist/dts/Equivalence.d.ts:53-68 | Combines two Equivalences into one requiring both to match. | `pipe(Equivalence.string, Equivalence.combine(Equivalence.string))` |
| `Equivalence.combineMany` | node_modules/effect/dist/dts/Equivalence.d.ts:69-84 | Combines an Equivalence with many others requiring all to match. | `Equivalence.combineMany(eq, [eq1, eq2, eq3])` |
| `Equivalence.combineAll` | node_modules/effect/dist/dts/Equivalence.d.ts:85-89 | Combines all Equivalences in a collection requiring all to match. | `Equivalence.combineAll([eq1, eq2, eq3])` |
| `Equivalence.mapInput` | node_modules/effect/dist/dts/Equivalence.d.ts:90-105 | Transforms input before comparing using a mapping function. | `pipe(Equivalence.string, Equivalence.mapInput((u: User) => u.name))` |
| `Equivalence.product` | node_modules/effect/dist/dts/Equivalence.d.ts:111-118 | Combines two Equivalences into one for tuple pairs. | `Equivalence.product(Equivalence.string, Equivalence.number)` |
| `Equivalence.productMany` | node_modules/effect/dist/dts/Equivalence.d.ts:119-128 | Combines an Equivalence with many for non-empty tuple comparison. | `Equivalence.productMany(Equivalence.number, [Equivalence.number])` |
| `Equivalence.tuple` | node_modules/effect/dist/dts/Equivalence.d.ts:129-142 | Creates Equivalence for tuples from individual element Equivalences. | `Equivalence.tuple(Equivalence.string, Equivalence.number)` |
| `Equivalence.array` | node_modules/effect/dist/dts/Equivalence.d.ts:143-149 | Creates Equivalence for arrays based on element Equivalence. | `Equivalence.array(Equivalence.number)` |
| `Equivalence.struct` | node_modules/effect/dist/dts/Equivalence.d.ts:150-157 | Creates Equivalence for structs from field Equivalences. | `Equivalence.struct({ name: Equivalence.string, age: Equivalence.number })` |
| `Equivalence.all` | node_modules/effect/dist/dts/Equivalence.d.ts:119-123 | Combines Equivalences into one for array of same-typed values. | `Equivalence.all([Equivalence.number, Equivalence.number])` |
